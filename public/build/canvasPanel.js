"use strict";
(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["canvasPanel"],{

/***/ "./public/app/core/components/Layers/AddLayerButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddLayerButton": () => (/* binding */ AddLayerButton)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



const AddLayerButton = ({
  onChange,
  options,
  label
}) => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.ValuePicker, {
    icon: "plus",
    label: label,
    variant: "secondary",
    options: options,
    onChange: onChange,
    isFullWidth: true
  });
};

/***/ }),

/***/ "./public/app/core/components/Layers/LayerDragDropList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerDragDropList": () => (/* binding */ LayerDragDropList)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _LayerName__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/components/Layers/LayerName.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









const LayerDragDropList = ({
  layers,
  getLayerInfo,
  onDragEnd,
  onSelect,
  onDelete,
  onDuplicate,
  isGroup,
  selection,
  excludeBaseLayer,
  onNameChange,
  verifyLayerNameUniqueness
}) => {
  const style = styles(_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.theme);

  const getRowStyle = isSelected => {
    return isSelected ? `${style.row} ${style.sel}` : style.row;
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
    onDragEnd: onDragEnd,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
      droppableId: "droppable",
      children: (provided, snapshot) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({}, provided.droppableProps, {
        ref: provided.innerRef,
        children: [(() => {
          // reverse order
          const rows = [];
          const lastLayerIndex = excludeBaseLayer ? 1 : 0;
          const shouldRenderDragIconLengthThreshold = excludeBaseLayer ? 2 : 1;

          for (let i = layers.length - 1; i >= lastLayerIndex; i--) {
            const element = layers[i];
            const uid = element.getName();
            const isSelected = Boolean(selection === null || selection === void 0 ? void 0 : selection.includes(uid));
            rows.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Draggable, {
              draggableId: uid,
              index: rows.length,
              children: (provided, snapshot) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
                className: getRowStyle(isSelected),
                ref: provided.innerRef
              }, provided.draggableProps, provided.dragHandleProps, {
                onMouseDown: () => onSelect(element),
                children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_LayerName__WEBPACK_IMPORTED_MODULE_4__.LayerName, {
                  name: uid,
                  onChange: v => onNameChange(element, v),
                  verifyLayerNameUniqueness: verifyLayerNameUniqueness !== null && verifyLayerNameUniqueness !== void 0 ? verifyLayerNameUniqueness : undefined
                }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
                  className: style.textWrapper,
                  children: ["\xA0 ", getLayerInfo(element)]
                }), !isGroup(element) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
                  children: [onDuplicate ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
                    name: "copy",
                    title: 'Duplicate',
                    className: style.actionIcon,
                    onClick: () => onDuplicate(element),
                    surface: "header"
                  }) : null, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.IconButton, {
                    name: "trash-alt",
                    title: 'remove',
                    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.cx)(style.actionIcon, style.dragIcon),
                    onClick: () => onDelete(element),
                    surface: "header"
                  }), layers.length > shouldRenderDragIconLengthThreshold && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, {
                    title: "Drag and drop to reorder",
                    name: "draggabledots",
                    size: "lg",
                    className: style.dragIcon
                  })]
                })]
              }))
            }, uid));
          }

          return rows;
        })(), provided.placeholder]
      }))
    })
  });
};
LayerDragDropList.defaultProps = {
  isGroup: () => false
};
const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.stylesFactory)(theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    margin-bottom: ${theme.spacing.md};
  `,
  row: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    padding: ${theme.spacing.xs} ${theme.spacing.sm};
    border-radius: ${theme.border.radius.sm};
    background: ${theme.colors.bg2};
    min-height: ${theme.spacing.formInputHeight}px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 3px;
    cursor: pointer;

    border: 1px solid ${theme.colors.formInputBorder};
    &:hover {
      border: 1px solid ${theme.colors.formInputBorderHover};
    }
  `,
  sel: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    border: 1px solid ${theme.colors.formInputBorderActive};
    &:hover {
      border: 1px solid ${theme.colors.formInputBorderActive};
    }
  `,
  dragIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    cursor: drag;
  `,
  actionIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    color: ${theme.colors.textWeak};
    &:hover {
      color: ${theme.colors.text};
    }
  `,
  typeWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    color: ${theme.colors.textBlue};
    margin-right: 5px;
  `,
  textWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    display: flex;
    align-items: center;
    flex-grow: 1;
    overflow: hidden;
    margin-right: ${theme.spacing.sm};
  `
}));

/***/ }),

/***/ "./public/app/core/components/Layers/LayerName.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerName": () => (/* binding */ LayerName)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






const LayerName = ({
  name,
  onChange,
  verifyLayerNameUniqueness
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles)(getStyles);
  const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [validationError, setValidationError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);

  const onEditLayer = event => {
    setIsEditing(true);
  };

  const onEndEditName = newName => {
    setIsEditing(false);

    if (validationError) {
      setValidationError(null);
      return;
    }

    if (name !== newName) {
      onChange(newName);
    }
  };

  const onInputChange = event => {
    const newName = event.currentTarget.value.trim();

    if (newName.length === 0) {
      setValidationError('An empty layer name is not allowed');
      return;
    }

    if (verifyLayerNameUniqueness && !verifyLayerNameUniqueness(newName) && newName !== name) {
      setValidationError('Layer name already exists');
      return;
    }

    if (validationError) {
      setValidationError(null);
    }
  };

  const onEditLayerBlur = event => {
    onEndEditName(event.currentTarget.value.trim());
  };

  const onKeyDown = event => {
    if (event.key === 'Enter') {
      onEndEditName(event.target.value);
    }
  };

  const onFocus = event => {
    event.target.select();
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
      className: styles.wrapper,
      children: [!isEditing && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("button", {
        className: styles.layerNameWrapper,
        title: "Edit layer name",
        onClick: onEditLayer,
        "data-testid": "layer-name-div",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("span", {
          className: styles.layerName,
          children: name
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, {
          name: "pen",
          className: styles.layerEditIcon,
          size: "sm"
        })]
      }), isEditing && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Input, {
          type: "text",
          defaultValue: name,
          onBlur: onEditLayerBlur,
          autoFocus: true,
          onKeyDown: onKeyDown,
          onFocus: onFocus,
          invalid: validationError !== null,
          onChange: onInputChange,
          className: styles.layerNameInput,
          "data-testid": "layer-name-input"
        }), validationError && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.FieldValidationMessage, {
          horizontal: true,
          children: validationError
        })]
      })]
    })
  });
};

const getStyles = theme => {
  return {
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
      label: Wrapper;
      display: flex;
      align-items: center;
      margin-left: ${theme.spacing.xs};
    `,
    layerNameWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
      display: flex;
      cursor: pointer;
      border: 1px solid transparent;
      border-radius: ${theme.border.radius.md};
      align-items: center;
      padding: 0 0 0 ${theme.spacing.xs};
      margin: 0;
      background: transparent;

      &:hover {
        background: ${theme.colors.bg3};
        border: 1px dashed ${theme.colors.border3};
      }

      &:focus {
        border: 2px solid ${theme.colors.formInputBorderActive};
      }

      &:hover,
      &:focus {
        .query-name-edit-icon {
          visibility: visible;
        }
      }
    `,
    layerName: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
      font-weight: ${theme.typography.weight.semibold};
      color: ${theme.colors.textBlue};
      cursor: pointer;
      overflow: hidden;
      margin-left: ${theme.spacing.xs};
    `,
    layerEditIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.cx)(_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
        margin-left: ${theme.spacing.md};
        visibility: hidden;
      `, 'query-name-edit-icon'),
    layerNameInput: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
      max-width: 300px;
      margin: -4px 0;
    `
  };
};

/***/ }),

/***/ "./public/app/features/canvas/element.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ "./public/app/features/canvas/elements/button.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buttonItem": () => (/* binding */ buttonItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dimensions/editors/TextDimensionEditor.tsx");
/* harmony import */ var app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/APIEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






class ButtonDisplay extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      data
    } = this.props;

    const onClick = () => {
      if (data !== null && data !== void 0 && data.api) {
        (0,app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__.callApi)(data.api);
      }
    };

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
      onClick: onClick,
      children: data === null || data === void 0 ? void 0 : data.text
    });
  }

}

const buttonItem = {
  id: 'button',
  name: 'Button',
  description: 'Button',
  display: ButtonDisplay,
  defaultSize: {
    width: 200,
    height: 50
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$api;

    const data = {
      text: cfg !== null && cfg !== void 0 && cfg.text ? ctx.getText(cfg.text).value() : '',
      api: (_cfg$api = cfg === null || cfg === void 0 ? void 0 : cfg.api) !== null && _cfg$api !== void 0 ? _cfg$api : undefined
    };
    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Button'];
    builder.addCustomEditor({
      category,
      id: 'textSelector',
      path: 'config.text',
      name: 'Text',
      editor: app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_2__.TextDimensionEditor
    }).addCustomEditor({
      category,
      id: 'apiSelector',
      path: 'config.api',
      name: 'API',
      editor: app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_3__.APIEditor
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/droneFront.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneFrontItem": () => (/* binding */ droneFrontItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _g, _g2, _g3, _g4;








const DroneFrontDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const droneFrontTransformStyle = `rotate(${data !== null && data !== void 0 && data.rollAngle ? data.rollAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    className: styles.droneFront,
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 1300 290",
    style: {
      transform: droneFrontTransformStyle
    },
    children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "arms",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "100",
        y2: "150"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "100",
        y2: "150"
      })]
    })), _g2 || (_g2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "body",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "none",
        d: " M 510 130 C 510 124 510 110 510 100 C 510 90 530 71 540 70 C 640 61 670 60 760 70 C 770 71 790 90 790 100 Q 790 120 790 130 L 790 130 Q 790 177 790 196 C 790 207 770 225 760 226 C 670 236 640 236 540 226 C 530 226 510 206 510 196 Q 510 177 510 130 Q 510 133 510 130 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
        cx: "650",
        cy: "160",
        r: "40",
        fill: "none"
      })]
    })), _g3 || (_g3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "motors",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 320 60 L 250 60 L 250 230 L 260 290 L 310 290 L 320 230 L 320 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 1050 60 L 980 60 L 980 230 L 990 290 L 1040 290 L 1050 230 L 1050 60 Z "
      })]
    })), _g4 || (_g4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propellers",
      fill: "black",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 270 60 L 300 60 L 300 20 Q 311 30 330 30 Q 349 30 570 10 L 300 10 Q 300 0 290 0 C 286 0 284 0 280 0 Q 270 0 270 10 L 0 10 Q 220 30 240 30 Q 260 30 270 20 L 270 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 1000 60 L 1030 60 L 1030 20 Q 1041 30 1060 30 Q 1079 30 1300 10 L 1030 10 Q 1030 0 1020 0 C 1016 0 1014 0 1010 0 Q 1000 0 1000 10 L 730 10 Q 950 30 970 30 Q 990 30 1000 20 L 1000 60 Z "
      })]
    }))]
  });
};

const droneFrontItem = {
  id: 'droneFront',
  name: 'Drone Front',
  description: 'Drone front',
  display: DroneFrontDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      rollAngle: cfg !== null && cfg !== void 0 && cfg.rollAngle ? ctx.getScalar(cfg.rollAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Front'];
    builder.addCustomEditor({
      category,
      id: 'rollAngle',
      path: 'config.rollAngle',
      name: 'Roll Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  droneFront: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    transition: transform 0.4s;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/droneSide.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneSideItem": () => (/* binding */ droneSideItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _g, _g2, _g3, _g4;








const DroneSideDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const droneSidePitchTransformStyle = `rotate(${data !== null && data !== void 0 && data.pitchAngle ? data.pitchAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    className: styles.droneSide,
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 1300 290",
    style: {
      transform: droneSidePitchTransformStyle
    },
    children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "arms",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "100",
        y2: "150"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "510",
        x2: "320",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "190",
        y2: "210"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("line", {
        x1: "790",
        x2: "980",
        y1: "100",
        y2: "150"
      })]
    })), _g2 || (_g2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("g", {
      className: "body",
      stroke: "black",
      strokeWidth: "28px",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "none",
        d: " M 510 130 C 510 124 510 110 510 100 C 510 90 530 71 540 70 C 640 61 670 60 760 70 C 770 71 790 90 790 100 Q 790 120 790 130 L 790 130 Q 790 177 790 196 C 790 207 770 225 760 226 C 670 236 640 236 540 226 C 530 226 510 206 510 196 Q 510 177 510 130 Q 510 133 510 130 Z "
      })
    })), _g3 || (_g3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "motors",
      stroke: "black",
      strokeWidth: "28px",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 320 60 L 250 60 L 250 230 L 260 290 L 310 290 L 320 230 L 320 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "motor",
        fill: "none",
        d: " M 1050 60 L 980 60 L 980 230 L 990 290 L 1040 290 L 1050 230 L 1050 60 Z "
      })]
    })), _g4 || (_g4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propellers",
      fill: "black",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 270 60 L 300 60 L 300 20 Q 311 30 330 30 Q 349 30 570 10 L 300 10 Q 300 0 290 0 C 286 0 284 0 280 0 Q 270 0 270 10 L 0 10 Q 220 30 240 30 Q 260 30 270 20 L 270 60 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: "prop",
        d: " M 1000 60 L 1030 60 L 1030 20 Q 1041 30 1060 30 Q 1079 30 1300 10 L 1030 10 Q 1030 0 1020 0 C 1016 0 1014 0 1010 0 Q 1000 0 1000 10 L 730 10 Q 950 30 970 30 Q 990 30 1000 20 L 1000 60 Z "
      })]
    }))]
  });
};

const droneSideItem = {
  id: 'droneSide',
  name: 'Drone Side',
  description: 'Drone Side',
  display: DroneSideDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      pitchAngle: cfg !== null && cfg !== void 0 && cfg.pitchAngle ? ctx.getScalar(cfg.pitchAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Side'];
    builder.addCustomEditor({
      category,
      id: 'pitchAngle',
      path: 'config.pitchAngle',
      name: 'Pitch Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  droneSide: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    transition: transform 0.4s;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/droneTop.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "droneTopItem": () => (/* binding */ droneTopItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _path, _path2;








const DroneTopDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const fRightRotorAnimation = `spin ${data !== null && data !== void 0 && data.fRightRotorRPM ? 60 / Math.abs(data.fRightRotorRPM) : 0}s linear infinite`;
  const fLeftRotorAnimation = `spin ${data !== null && data !== void 0 && data.fLeftRotorRPM ? 60 / Math.abs(data.fLeftRotorRPM) : 0}s linear infinite`;
  const bRightRotorAnimation = `spin ${data !== null && data !== void 0 && data.bRightRotorRPM ? 60 / Math.abs(data.bRightRotorRPM) : 0}s linear infinite`;
  const bLeftRotorAnimation = `spin ${data !== null && data !== void 0 && data.bLeftRotorRPM ? 60 / Math.abs(data.bLeftRotorRPM) : 0}s linear infinite`;
  const droneTopTransformStyle = `rotate(${data !== null && data !== void 0 && data.yawAngle ? data.yawAngle : 0}deg)`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "-43 -43 640 640",
    xmlSpace: "preserve",
    style: {
      transform: droneTopTransformStyle
    },
    children: [_path || (_path = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
      fillRule: "evenodd",
      d: " M 137.95 127.967 C 137.14 127.157 136.189 126.58 135.178 126.218 C 138.173 121.545 139.967 116.036 140.125 110.123 L 217.64 151.862 C 214.049 157.411 211.8 163.922 211.386 170.95 L 209.694 199.712 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 L 137.95 127.967 Z  M 134.268 426.981 C 130.211 421.314 124.328 417.045 117.482 415.041 L 201.999 330.523 L 201.385 340.955 C 200.67 353.107 202.829 364.914 207.563 375.673 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 L 134.268 426.981 Z  M 324.765 373.673 L 228.527 373.673 Q 215.374 358.611 216.361 341.835 L 226.361 171.832 C 226.825 163.94 231.012 157.096 237.146 152.957 L 316.146 152.957 C 322.28 157.096 326.466 163.94 326.931 171.832 L 336.931 341.835 Q 337.918 358.611 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 L 324.765 373.673 Z  M 435.81 415.041 C 428.964 417.045 423.081 421.314 419.024 426.981 L 345.727 375.673 C 350.461 364.914 352.62 353.107 351.905 340.955 L 351.291 330.523 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 L 435.81 415.041 Z  M 343.596 199.713 L 341.904 170.951 C 341.49 163.923 339.242 157.411 335.651 151.863 L 413.167 110.124 C 413.325 116.037 415.119 121.546 418.114 126.219 C 417.103 126.581 416.152 127.158 415.342 127.968 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 L 343.596 199.713 Z  M 444.646 92.771 C 453.744 92.771 461.146 100.172 461.146 109.271 C 461.146 118.369 453.744 125.771 444.646 125.771 C 435.548 125.771 428.146 118.369 428.146 109.271 C 428.146 100.172 435.548 92.771 444.646 92.771 L 444.646 92.771 L 444.646 92.771 L 444.646 92.771 Z  M 108.647 92.771 C 117.745 92.771 125.147 100.172 125.147 109.271 C 125.147 118.369 117.745 125.771 108.647 125.771 C 99.549 125.771 92.147 118.369 92.147 109.271 C 92.147 100.172 99.549 92.771 108.647 92.771 L 108.647 92.771 L 108.647 92.771 Z  M 108.647 461.771 C 99.549 461.771 92.147 454.369 92.147 445.271 C 92.147 436.172 99.549 428.771 108.647 428.771 C 117.745 428.771 125.147 436.172 125.147 445.271 C 125.147 454.369 117.745 461.771 108.647 461.771 L 108.647 461.771 Z  M 92.322 136.202 C 97.086 139.1 102.675 140.771 108.647 140.771 C 114.883 140.771 120.697 138.941 125.594 135.802 C 125.956 136.813 126.534 137.764 127.343 138.573 L 207.342 218.573 C 207.711 218.942 208.109 219.264 208.528 219.54 L 203.212 309.908 C 201.794 310.182 200.44 310.869 199.342 311.967 L 95.343 415.967 C 94.954 416.356 94.62 416.779 94.335 417.224 C 93.651 417.575 92.976 417.942 92.322 418.34 Q 84.615 424.182 81.716 428.946 C 78.817 433.71 77.147 439.299 77.147 445.271 C 77.147 462.64 91.278 476.771 108.647 476.771 C 114.619 476.771 120.208 475.1 124.972 472.202 C 129.736 469.304 132.678 466.36 135.577 461.596 C 138.476 456.832 140.147 451.243 140.147 445.271 C 140.147 443.943 140.055 442.637 139.895 441.352 L 214.997 388.78 C 217.05 391.677 336.242 391.678 338.295 388.78 L 413.398 441.352 C 413.238 442.637 413.146 443.943 413.146 445.271 C 413.146 451.243 414.817 456.832 417.715 461.596 C 420.613 466.36 423.557 469.304 428.321 472.202 C 433.085 475.1 438.674 476.771 444.646 476.771 C 462.015 476.771 476.146 462.64 476.146 445.271 C 476.146 439.299 474.475 433.71 471.577 428.946 C 468.679 424.182 459.642 417.575 458.958 417.224 C 458.672 416.779 458.339 416.356 457.95 415.967 L 353.95 311.967 C 352.852 310.869 351.498 310.182 350.08 309.908 L 344.764 219.54 C 345.183 219.264 345.581 218.942 345.95 218.573 L 425.95 138.573 C 426.76 137.763 427.337 136.812 427.699 135.802 C 432.596 138.941 438.409 140.771 444.646 140.771 C 450.618 140.771 456.207 139.1 460.971 136.202 C 465.735 133.304 468.679 130.36 471.577 125.596 C 474.475 120.832 476.146 115.243 476.146 109.271 C 476.146 91.903 462.015 77.772 444.646 77.772 C 438.674 77.772 433.085 79.442 428.321 82.34 L 416.215 91.446 L 324.765 140.688 C 318.402 136.324 310.718 133.771 302.473 133.771 L 250.819 133.771 C 242.574 133.771 234.89 136.324 228.527 140.688 L 137.078 91.446 L 124.972 82.34 C 120.208 79.442 114.619 77.772 108.647 77.772 C 91.278 77.772 77.147 91.903 77.147 109.271 C 77.147 115.243 78.818 120.832 81.716 125.595 C 84.614 130.358 87.558 133.304 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 L 92.322 136.202 Z  M 444.646 461.771 C 435.548 461.771 428.146 454.369 428.146 445.271 C 428.146 436.172 435.548 428.771 444.646 428.771 C 453.744 428.771 461.146 436.172 461.146 445.271 C 461.146 454.369 453.744 461.771 444.646 461.771 Z "
    })), _path2 || (_path2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
      fillRule: "evenodd",
      d: " M 259.458 334.235 L 259.458 337.211 L 254.514 337.211 L 254.514 350.795 L 250.842 350.795 L 250.842 337.211 L 245.898 337.211 L 245.898 334.235 L 259.458 334.235 Z  M 266.226 347.939 L 272.586 347.939 L 272.754 350.627 L 272.754 350.627 Q 270.498 350.867 265.074 350.867 L 265.074 350.867 L 265.074 350.867 Q 263.418 350.867 262.434 349.967 L 262.434 349.967 L 262.434 349.967 Q 261.45 349.067 261.426 347.531 L 261.426 347.531 L 261.426 337.499 L 261.426 337.499 Q 261.45 335.963 262.434 335.063 L 262.434 335.063 L 262.434 335.063 Q 263.418 334.163 265.074 334.163 L 265.074 334.163 L 265.074 334.163 Q 270.498 334.163 272.754 334.403 L 272.754 334.403 L 272.586 337.115 L 266.226 337.115 L 266.226 337.115 Q 265.626 337.115 265.362 337.403 L 265.362 337.403 L 265.362 337.403 Q 265.098 337.691 265.098 338.339 L 265.098 338.339 L 265.098 340.859 L 271.698 340.859 L 271.698 343.499 L 265.098 343.499 L 265.098 346.691 L 265.098 346.691 Q 265.098 347.363 265.362 347.651 L 265.362 347.651 L 265.362 347.651 Q 265.626 347.939 266.226 347.939 L 266.226 347.939 Z  M 275.202 333.995 L 278.73 333.995 L 278.73 346.931 L 278.73 346.931 Q 278.73 348.131 280.074 348.131 L 280.074 348.131 L 281.034 348.131 L 281.442 350.603 L 281.442 350.603 Q 280.53 351.083 278.61 351.083 L 278.61 351.083 L 278.61 351.083 Q 277.026 351.083 276.114 350.231 L 276.114 350.231 L 276.114 350.231 Q 275.202 349.379 275.202 347.819 L 275.202 347.819 L 275.202 333.995 Z  M 283.05 333.995 L 286.578 333.995 L 286.578 346.931 L 286.578 346.931 Q 286.578 348.131 287.922 348.131 L 287.922 348.131 L 288.882 348.131 L 289.29 350.603 L 289.29 350.603 Q 288.378 351.083 286.458 351.083 L 286.458 351.083 L 286.458 351.083 Q 284.874 351.083 283.962 350.231 L 283.962 350.231 L 283.962 350.231 Q 283.05 349.379 283.05 347.819 L 283.05 347.819 L 283.05 333.995 Z  M 292.086 335.759 L 292.086 335.759 L 292.086 335.759 Q 293.634 333.923 297.618 333.923 L 297.618 333.923 L 297.618 333.923 Q 301.602 333.923 303.162 335.759 L 303.162 335.759 L 303.162 335.759 Q 304.722 337.595 304.722 342.515 L 304.722 342.515 L 304.722 342.515 Q 304.722 347.435 303.162 349.271 L 303.162 349.271 L 303.162 349.271 Q 301.602 351.107 297.618 351.107 L 297.618 351.107 L 297.618 351.107 Q 293.634 351.107 292.086 349.271 L 292.086 349.271 L 292.086 349.271 Q 290.538 347.435 290.538 342.515 L 290.538 342.515 L 290.538 342.515 Q 290.538 337.595 292.086 335.759 Z  M 300.174 338.051 L 300.174 338.051 L 300.174 338.051 Q 299.49 336.875 297.618 336.875 L 297.618 336.875 L 297.618 336.875 Q 295.746 336.875 295.062 338.051 L 295.062 338.051 L 295.062 338.051 Q 294.378 339.227 294.378 342.515 L 294.378 342.515 L 294.378 342.515 Q 294.378 345.803 295.062 346.979 L 295.062 346.979 L 295.062 346.979 Q 295.746 348.155 297.618 348.155 L 297.618 348.155 L 297.618 348.155 Q 299.49 348.155 300.174 346.979 L 300.174 346.979 L 300.174 346.979 Q 300.858 345.803 300.858 342.515 L 300.858 342.515 L 300.858 342.515 Q 300.858 339.227 300.174 338.051 Z "
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      className: "propeller-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCW}`,
        style: {
          animation: bRightRotorAnimation
        },
        d: " M 461.563 418.77 L 463.992 416.34 Q 465.495 407.116 466.461 400.395 C 467.426 393.675 469.363 388.087 474.731 383.284 Q 533.862 341.514 538.196 338.859 C 542.529 336.203 548.345 334.299 551.492 338.29 C 554.639 342.282 553.481 346.02 549.419 350.082 L 471.147 428.354 L 461.563 418.77 Z  M 427.729 471.772 L 425.299 474.202 Q 423.797 483.426 422.831 490.146 C 421.866 496.867 419.929 502.454 414.561 507.257 Q 355.43 549.028 351.096 551.683 C 346.763 554.338 340.947 556.243 337.8 552.251 C 334.653 548.26 335.811 544.522 339.873 540.46 L 418.145 462.187 L 427.729 471.772 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCCW}`,
        style: {
          animation: fRightRotorAnimation
        },
        d: " M 461.563 135.773 L 463.992 138.203 Q 465.495 147.426 466.461 154.147 C 467.426 160.868 469.363 166.455 474.731 171.258 Q 533.862 213.028 538.196 215.684 C 542.529 218.339 548.345 220.244 551.492 216.252 C 554.639 212.26 553.481 208.523 549.419 204.46 L 471.147 126.188 L 461.563 135.773 Z  M 427.729 82.77 L 425.299 80.34 Q 423.797 71.117 422.831 64.396 C 421.866 57.675 419.929 52.088 414.561 47.285 Q 355.43 5.515 351.096 2.859 C 346.763 0.204 340.947 -1.701 337.8 2.291 C 334.653 6.282 335.811 10.02 339.873 14.082 L 418.145 92.355 L 427.729 82.77 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCCW}`,
        style: {
          animation: bLeftRotorAnimation
        },
        d: " M 125.563 471.772 L 127.993 474.202 Q 129.496 483.426 130.461 490.146 C 131.427 496.867 133.363 502.454 138.731 507.257 Q 197.863 549.028 202.196 551.683 C 206.53 554.338 212.345 556.243 215.492 552.251 C 218.639 548.26 217.482 544.522 213.419 540.46 L 135.148 462.187 L 125.563 471.772 Z  M 91.73 418.77 L 89.3 416.34 Q 87.797 407.116 86.832 400.395 C 85.866 393.675 83.93 388.087 78.562 383.284 Q 19.431 341.514 15.097 338.859 C 10.763 336.203 4.948 334.299 1.801 338.29 C -1.346 342.282 -0.189 346.02 3.874 350.082 L 82.146 428.354 L 91.73 418.77 Z "
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        className: `${styles.propeller} ${styles.propellerCW}`,
        style: {
          animation: fLeftRotorAnimation
        },
        d: " M 125.563 82.77 L 127.993 80.34 Q 129.496 71.117 130.461 64.396 C 131.427 57.675 133.363 52.088 138.731 47.285 Q 197.863 5.515 202.196 2.859 C 206.53 0.204 212.345 -1.701 215.492 2.291 C 218.639 6.282 217.482 10.02 213.419 14.083 L 135.147 92.355 L 125.563 82.77 Z  M 91.73 135.773 L 89.3 138.203 Q 87.797 147.426 86.832 154.147 C 85.866 160.868 83.93 166.455 78.562 171.258 Q 19.431 213.028 15.097 215.684 C 10.763 218.339 4.948 220.243 1.801 216.252 C -1.346 212.26 -0.189 208.523 3.874 204.46 L 82.146 126.188 L 91.73 135.773 Z "
      })]
    })]
  });
};

const droneTopItem = {
  id: 'droneTop',
  name: 'Drone Top',
  description: 'Drone top',
  display: DroneTopDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      bRightRotorRPM: cfg !== null && cfg !== void 0 && cfg.bRightRotorRPM ? ctx.getScalar(cfg.bRightRotorRPM).value() : 0,
      bLeftRotorRPM: cfg !== null && cfg !== void 0 && cfg.bLeftRotorRPM ? ctx.getScalar(cfg.bLeftRotorRPM).value() : 0,
      fRightRotorRPM: cfg !== null && cfg !== void 0 && cfg.fRightRotorRPM ? ctx.getScalar(cfg.fRightRotorRPM).value() : 0,
      fLeftRotorRPM: cfg !== null && cfg !== void 0 && cfg.fLeftRotorRPM ? ctx.getScalar(cfg.fLeftRotorRPM).value() : 0,
      yawAngle: cfg !== null && cfg !== void 0 && cfg.yawAngle ? ctx.getScalar(cfg.yawAngle).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Drone Top'];
    builder.addCustomEditor({
      category,
      id: 'yawAngle',
      path: 'config.yawAngle',
      name: 'Yaw Angle',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'fRightRotorRPM',
      path: 'config.fRightRotorRPM',
      name: 'Front Right Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'fLeftRotorRPM',
      path: 'config.fLeftRotorRPM',
      name: 'Front Left Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'bRightRotorRPM',
      path: 'config.bRightRotorRPM',
      name: 'Back Right Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    }).addCustomEditor({
      category,
      id: 'bLeftRotorRPM',
      path: 'config.bLeftRotorRPM',
      name: 'Back Left Rotor RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  propeller: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    transform-origin: 50% 50%;
    transform-box: fill-box;
    display: block;
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  `,
  propellerCW: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    animation-direction: normal;
  `,
  propellerCCW: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    animation-direction: reverse;
  `
});

/***/ }),

/***/ "./public/app/features/canvas/elements/icon.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IconDisplay": () => (/* binding */ IconDisplay),
/* harmony export */   "iconItem": () => (/* binding */ iconItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_features_dimensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_inlinesvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-inlinesvg-virtual-f6307798ef/0/cache/react-inlinesvg-npm-2.3.0-9b0402e461-ea43f6ec06.zip/node_modules/react-inlinesvg/esm/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/APIEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








// When a stoke is defined, we want the path to be in page units
const svgStrokePathClass = _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
  path {
    vector-effect: non-scaling-stroke;
  }
`;
function IconDisplay(props) {
  const {
    width,
    height,
    data
  } = props;

  if (!(data !== null && data !== void 0 && data.path)) {
    return null;
  }

  const onClick = () => {
    if (data !== null && data !== void 0 && data.api) {
      (0,app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__.callApi)(data.api);
    }
  };

  const svgStyle = {
    fill: data === null || data === void 0 ? void 0 : data.fill,
    stroke: data === null || data === void 0 ? void 0 : data.strokeColor,
    strokeWidth: data === null || data === void 0 ? void 0 : data.stroke
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(react_inlinesvg__WEBPACK_IMPORTED_MODULE_7__["default"], {
    onClick: onClick,
    src: data.path,
    width: width,
    height: height,
    style: svgStyle,
    className: svgStyle.strokeWidth ? svgStrokePathClass : undefined
  });
}
const iconItem = {
  id: 'icon',
  name: 'Icon',
  description: 'SVG Icon display',
  display: IconDisplay,
  getNewOptions: options => Object.assign({
    placement: {
      width: 50,
      height: 50
    }
  }, options, {
    config: {
      path: {
        mode: app_features_dimensions__WEBPACK_IMPORTED_MODULE_1__.ResourceDimensionMode.Fixed,
        fixed: 'img/icons/unicons/question-circle.svg'
      },
      fill: {
        fixed: '#FFF899'
      }
    }
  }),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$api, _cfg$stroke;

    let path = undefined;

    if (cfg.path) {
      path = ctx.getResource(cfg.path).value();
    }

    if (!path || !(0,lodash__WEBPACK_IMPORTED_MODULE_4__.isString)(path)) {
      path = (0,app_features_dimensions__WEBPACK_IMPORTED_MODULE_1__.getPublicOrAbsoluteUrl)('img/icons/unicons/question-circle.svg');
    }

    const data = {
      path,
      fill: cfg.fill ? ctx.getColor(cfg.fill).value() : '#CCC',
      api: (_cfg$api = cfg === null || cfg === void 0 ? void 0 : cfg.api) !== null && _cfg$api !== void 0 ? _cfg$api : undefined
    };

    if ((_cfg$stroke = cfg.stroke) !== null && _cfg$stroke !== void 0 && _cfg$stroke.width && cfg.stroke.color) {
      if (cfg.stroke.width > 0) {
        var _cfg$stroke2;

        data.stroke = (_cfg$stroke2 = cfg.stroke) === null || _cfg$stroke2 === void 0 ? void 0 : _cfg$stroke2.width;
        data.strokeColor = ctx.getColor(cfg.stroke.color).value();
      }
    }

    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Icon'];
    builder.addCustomEditor({
      category,
      id: 'iconSelector',
      path: 'config.path',
      name: 'SVG Path',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_2__.ResourceDimensionEditor,
      settings: {
        resourceType: 'icon'
      }
    }).addCustomEditor({
      category,
      id: 'config.fill',
      path: 'config.fill',
      name: 'Fill color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_2__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: 'grey'
      }
    }).addSliderInput({
      category,
      path: 'config.stroke.width',
      name: 'Stroke',
      defaultValue: 0,
      settings: {
        min: 0,
        max: 10
      }
    }).addCustomEditor({
      category,
      id: 'config.stroke.color',
      path: 'config.stroke.color',
      name: 'Stroke color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_2__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: 'grey'
      },
      showIf: cfg => {
        var _cfg$config, _cfg$config$stroke;

        return Boolean(cfg === null || cfg === void 0 ? void 0 : (_cfg$config = cfg.config) === null || _cfg$config === void 0 ? void 0 : (_cfg$config$stroke = _cfg$config.stroke) === null || _cfg$config$stroke === void 0 ? void 0 : _cfg$config$stroke.width);
      }
    }).addCustomEditor({
      category,
      id: 'apiSelector',
      path: 'config.api',
      name: 'API',
      editor: app_plugins_panel_canvas_editor_APIEditor__WEBPACK_IMPORTED_MODULE_5__.APIEditor
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/notFound.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "notFoundItem": () => (/* binding */ notFoundItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;





class NotFoundDisplay extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      config
    } = this.props;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
      children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("h3", {
        children: "NOT FOUND:"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("pre", {
        children: JSON.stringify(config, null, 2)
      })]
    });
  }

}

const notFoundItem = {
  id: 'not-found',
  name: 'Not found',
  description: 'Display when element type is not found in the registry',
  display: NotFoundDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: () => ({
    config: {}
  })
};

/***/ }),

/***/ "./public/app/features/canvas/elements/textBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Align": () => (/* binding */ Align),
/* harmony export */   "VAlign": () => (/* binding */ VAlign),
/* harmony export */   "textBoxItem": () => (/* binding */ textBoxItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_features_dimensions_editors_ColorDimensionEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/editors/ColorDimensionEditor.tsx");
/* harmony import */ var app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dimensions/editors/TextDimensionEditor.tsx");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







let Align;

(function (Align) {
  Align["Left"] = "left";
  Align["Center"] = "center";
  Align["Right"] = "right";
})(Align || (Align = {}));

let VAlign;

(function (VAlign) {
  VAlign["Top"] = "top";
  VAlign["Middle"] = "middle";
  VAlign["Bottom"] = "bottom";
})(VAlign || (VAlign = {}));

class TextBoxDisplay extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      data
    } = this.props;
    const styles = getStyles(app_core_config__WEBPACK_IMPORTED_MODULE_5__.config.theme2, data);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: styles.container,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("span", {
        className: styles.span,
        children: data === null || data === void 0 ? void 0 : data.text
      })
    });
  }

}

const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_4__.stylesFactory)((theme, data) => ({
  container: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    position: absolute;
    height: 100%;
    width: 100%;
    display: table;
  `,
  span: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    display: table-cell;
    vertical-align: ${data.valign};
    text-align: ${data.align};
    font-size: ${data === null || data === void 0 ? void 0 : data.size}px;
    color: ${data === null || data === void 0 ? void 0 : data.color};
  `
}));
const textBoxItem = {
  id: 'text-box',
  name: 'Text',
  description: 'Text box',
  display: TextBoxDisplay,
  defaultSize: {
    width: 240,
    height: 160
  },
  getNewOptions: options => Object.assign({
    background: {
      color: {
        fixed: 'grey'
      }
    }
  }, options, {
    config: {
      align: Align.Left,
      valign: VAlign.Middle
    }
  }),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    var _cfg$align, _cfg$valign;

    const data = {
      text: cfg.text ? ctx.getText(cfg.text).value() : '',
      align: (_cfg$align = cfg.align) !== null && _cfg$align !== void 0 ? _cfg$align : Align.Center,
      valign: (_cfg$valign = cfg.valign) !== null && _cfg$valign !== void 0 ? _cfg$valign : VAlign.Middle,
      size: cfg.size
    };

    if (cfg.color) {
      data.color = ctx.getColor(cfg.color).value();
    }

    return data;
  },
  // Heatmap overlay options
  registerOptionsUI: builder => {
    const category = ['Text box'];
    builder.addCustomEditor({
      category,
      id: 'textSelector',
      path: 'config.text',
      name: 'Text',
      editor: app_features_dimensions_editors_TextDimensionEditor__WEBPACK_IMPORTED_MODULE_2__.TextDimensionEditor
    }).addCustomEditor({
      category,
      id: 'config.color',
      path: 'config.color',
      name: 'Text color',
      editor: app_features_dimensions_editors_ColorDimensionEditor__WEBPACK_IMPORTED_MODULE_1__.ColorDimensionEditor,
      settings: {},
      defaultValue: {}
    }).addRadio({
      category,
      path: 'config.align',
      name: 'Align text',
      settings: {
        options: [{
          value: Align.Left,
          label: 'Left'
        }, {
          value: Align.Center,
          label: 'Center'
        }, {
          value: Align.Right,
          label: 'Right'
        }]
      },
      defaultValue: Align.Left
    }).addRadio({
      category,
      path: 'config.valign',
      name: 'Vertical align',
      settings: {
        options: [{
          value: VAlign.Top,
          label: 'Top'
        }, {
          value: VAlign.Middle,
          label: 'Middle'
        }, {
          value: VAlign.Bottom,
          label: 'Bottom'
        }]
      },
      defaultValue: VAlign.Middle
    }).addNumberInput({
      category,
      path: 'config.size',
      name: 'Text size',
      settings: {
        placeholder: 'Auto'
      }
    });
  }
};

/***/ }),

/***/ "./public/app/features/canvas/elements/windTurbine.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "windTurbineItem": () => (/* binding */ windTurbineItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _symbol, _g, _use, _use2, _use3;








const WindTurbineDisplay = props => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    data
  } = props;
  const windTurbineAnimation = `spin ${data !== null && data !== void 0 && data.rpm ? 60 / Math.abs(data.rpm) : 0}s linear infinite`;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("svg", {
    viewBox: "0 0 189.326 283.989",
    preserveAspectRatio: "xMidYMid meet",
    children: [_symbol || (_symbol = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("symbol", {
      id: "blade",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "#e6e6e6",
        id: "blade-front",
        d: "M14.6491879,1.85011601 C14.2684455,-0.0535962877 10.7150812,-0.815081206 9.06473318,3.37308585 L0.434338747,70.7658933 L8.93805104,91.9607889 L15.4106729,90.437819 L17.5684455,78.3807425 L14.5218097,1.97679814 L14.6491879,1.85011601 Z"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
        fill: "#d0d6d7",
        id: "blade-side",
        d: "M11.0951276,0.581206497 C10.3336427,0.961948956 9.57215777,1.85011601 8.93735499,3.24640371 L0.306960557,70.6392111 L8.81067285,91.8341067 L3.35359629,70.0044084 L11.0951276,0.581206497 Z"
      })]
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
      children: [_g || (_g = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
        id: "structure",
        transform: "translate(58.123, 82.664)",
        fillRule: "nonzero",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("polygon", {
          id: "tower",
          fill: "#e6e6e6",
          points: "33.111,10.984 39.965,10.984 44.28,196.176 28.796,196.176"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
          id: "yaw",
          fill: "rgba(0,0,0,0.25)",
          d: "M40.3454756,23.2948956 L40.7262181,34.8445476 C38.8225058,35.0986079 35.7765661,35.0986079 32.349884,34.337123 L32.7306265,23.2955916 L40.3454756,23.2955916 L40.3454756,23.2948956 Z"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("path", {
          id: "base",
          fill: "#d0d6d7",
          transform: "translate(0 42)",
          d: "M26.3846868,150.591647 L46.5640371,150.591647 C48.8484919,150.591647 50.7522042,152.49536 50.7522042,154.779814 L50.7522042,158.967981 L22.0691415,158.967981 L22.0691415,154.779814 C22.0691415,152.49536 23.9728538,150.591647 26.2573086,150.591647 L26.3846868,150.591647 Z"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
          id: "nacelle",
          fill: "#e6e6e6",
          cx: "36.54",
          cy: "12",
          r: "11.93"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("circle", {
          id: "gearbox",
          fill: "none",
          stroke: "#d0d6d7",
          strokeWidth: "2.75",
          cx: "36.538",
          cy: "11.999",
          r: "5.8"
        })]
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("g", {
        className: styles.blade,
        style: {
          animation: windTurbineAnimation
        },
        children: [_use || (_use = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade1",
          href: "#blade",
          x: "83.24",
          y: "0"
        })), _use2 || (_use2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade2",
          href: "#blade",
          x: "83.24",
          y: "0",
          transform: "rotate(120 94.663 94.663)"
        })), _use3 || (_use3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("use", {
          id: "blade3",
          href: "#blade",
          x: "83.24",
          y: "0",
          transform: "rotate(-120 94.663 94.663)"
        }))]
      })]
    })]
  });
};

const windTurbineItem = {
  id: 'windTurbine',
  name: 'Wind Turbine',
  description: 'Spinny spinny',
  display: WindTurbineDisplay,
  defaultSize: {
    width: 100,
    height: 100
  },
  getNewOptions: options => Object.assign({}, options),
  // Called when data changes
  prepareData: (ctx, cfg) => {
    const data = {
      rpm: cfg !== null && cfg !== void 0 && cfg.rpm ? ctx.getScalar(cfg.rpm).value() : 0
    };
    return data;
  },
  registerOptionsUI: builder => {
    const category = ['Wind Turbine'];
    builder.addCustomEditor({
      category,
      id: 'rpm',
      path: 'config.rpm',
      name: 'RPM',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_3__.ScalarDimensionEditor
    });
  }
};

const getStyles = theme => ({
  blade: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    transform-origin: 94.663px 94.663px;
    transform: rotate(15deg);
  `
});

/***/ }),

/***/ "./public/app/features/canvas/group.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ "./public/app/features/canvas/index.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundImageSize": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize),
/* harmony export */   "CanvasGroupOptions": () => (/* reexport safe */ _group__WEBPACK_IMPORTED_MODULE_2__.CanvasGroupOptions),
/* harmony export */   "DEFAULT_CANVAS_ELEMENT_CONFIG": () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CANVAS_ELEMENT_CONFIG),
/* harmony export */   "canvasElementRegistry": () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.canvasElementRegistry)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/canvas/types.ts");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/element.ts");
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/group.ts");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/registry.ts");





/***/ }),

/***/ "./public/app/features/canvas/registry.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_CANVAS_ELEMENT_CONFIG": () => (/* binding */ DEFAULT_CANVAS_ELEMENT_CONFIG),
/* harmony export */   "canvasElementRegistry": () => (/* binding */ canvasElementRegistry)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _elements_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/elements/button.tsx");
/* harmony import */ var _elements_droneFront__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/elements/droneFront.tsx");
/* harmony import */ var _elements_droneSide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/elements/droneSide.tsx");
/* harmony import */ var _elements_droneTop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/elements/droneTop.tsx");
/* harmony import */ var _elements_icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/canvas/elements/icon.tsx");
/* harmony import */ var _elements_textBox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/canvas/elements/textBox.tsx");
/* harmony import */ var _elements_windTurbine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/canvas/elements/windTurbine.tsx");








const DEFAULT_CANVAS_ELEMENT_CONFIG = Object.assign({}, _elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem.getNewOptions(), {
  type: _elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem.id,
  name: `Element 1`
});
const canvasElementRegistry = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(() => [_elements_icon__WEBPACK_IMPORTED_MODULE_5__.iconItem, // default for now
_elements_textBox__WEBPACK_IMPORTED_MODULE_6__.textBoxItem, _elements_button__WEBPACK_IMPORTED_MODULE_1__.buttonItem, _elements_droneTop__WEBPACK_IMPORTED_MODULE_4__.droneTopItem, _elements_droneFront__WEBPACK_IMPORTED_MODULE_2__.droneFrontItem, _elements_droneSide__WEBPACK_IMPORTED_MODULE_3__.droneSideItem, _elements_windTurbine__WEBPACK_IMPORTED_MODULE_7__.windTurbineItem]);

/***/ }),

/***/ "./public/app/features/canvas/runtime/element.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ElementState": () => (/* binding */ ElementState)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





let counter = 0;
class ElementState {
  // UID necessary for moveable to work (for now)
  // Filled in by ref
  // Calculated
  // depends on the type
  // From options, but always set and always valid
  constructor(item, options, parent) {
    var _options$anchor, _options$placement;

    this.item = item;
    this.options = options;
    this.parent = parent;

    _defineProperty(this, "UID", counter++);

    _defineProperty(this, "revId", 0);

    _defineProperty(this, "sizeStyle", {});

    _defineProperty(this, "dataStyle", {});

    _defineProperty(this, "div", void 0);

    _defineProperty(this, "width", 100);

    _defineProperty(this, "height", 100);

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "anchor", void 0);

    _defineProperty(this, "placement", void 0);

    _defineProperty(this, "initElement", target => {
      this.div = target;
    });

    _defineProperty(this, "applyDrag", event => {
      const {
        placement,
        anchor
      } = this;
      const deltaX = event.delta[0];
      const deltaY = event.delta[1];
      const style = event.target.style;

      if (anchor.top) {
        placement.top += deltaY;
        style.top = `${placement.top}px`;
      }

      if (anchor.bottom) {
        placement.bottom -= deltaY;
        style.bottom = `${placement.bottom}px`;
      }

      if (anchor.left) {
        placement.left += deltaX;
        style.left = `${placement.left}px`;
      }

      if (anchor.right) {
        placement.right -= deltaX;
        style.right = `${placement.right}px`;
      }
    });

    _defineProperty(this, "applyResize", event => {
      const {
        placement,
        anchor
      } = this;
      const style = event.target.style;
      const deltaX = event.delta[0];
      const deltaY = event.delta[1];
      const dirLR = event.direction[0];
      const dirTB = event.direction[1];

      if (dirLR === 1) {
        // RIGHT
        if (anchor.right) {
          placement.right -= deltaX;
          style.right = `${placement.right}px`;

          if (!anchor.left) {
            placement.width = event.width;
            style.width = `${placement.width}px`;
          }
        } else {
          placement.width = event.width;
          style.width = `${placement.width}px`;
        }
      } else if (dirLR === -1) {
        // LEFT
        if (anchor.left) {
          placement.left -= deltaX;
          placement.width = event.width;
          style.left = `${placement.left}px`;
          style.width = `${placement.width}px`;
        } else {
          placement.width += deltaX;
          style.width = `${placement.width}px`;
        }
      }

      if (dirTB === -1) {
        // TOP
        if (anchor.top) {
          placement.top -= deltaY;
          placement.height = event.height;
          style.top = `${placement.top}px`;
          style.height = `${placement.height}px`;
        } else {
          placement.height = event.height;
          style.height = `${placement.height}px`;
        }
      } else if (dirTB === 1) {
        // BOTTOM
        if (anchor.bottom) {
          placement.bottom -= deltaY;
          placement.height = event.height;
          style.bottom = `${placement.bottom}px`;
          style.height = `${placement.height}px`;
        } else {
          placement.height = event.height;
          style.height = `${placement.height}px`;
        }
      }

      this.width = event.width;
      this.height = event.height;
    });

    this.item = item;
    this.options = options;
    this.parent = parent;
    const fallbackName = `Element ${Date.now()}`;

    if (!options) {
      this.options = {
        type: item.id,
        name: fallbackName
      };
    }

    this.anchor = (_options$anchor = options.anchor) !== null && _options$anchor !== void 0 ? _options$anchor : {};
    this.placement = (_options$placement = options.placement) !== null && _options$placement !== void 0 ? _options$placement : {};
    options.anchor = this.anchor;
    options.placement = this.placement;
    const scene = this.getScene();

    if (!options.name) {
      const newName = scene === null || scene === void 0 ? void 0 : scene.getNextElementName();
      options.name = newName !== null && newName !== void 0 ? newName : fallbackName;
    }

    scene === null || scene === void 0 ? void 0 : scene.byName.set(options.name, this);
  }

  getScene() {
    let trav = this.parent;

    while (trav) {
      if (trav.isRoot()) {
        return trav.scene;
        break;
      }

      trav = trav.parent;
    }

    return undefined;
  }

  getName() {
    return this.options.name;
  }

  validatePlacement() {
    var _placement$width, _placement$height;

    const {
      anchor,
      placement
    } = this;

    if (!(anchor.left || anchor.right)) {
      anchor.left = true;
    }

    if (!(anchor.top || anchor.bottom)) {
      anchor.top = true;
    }

    const w = (_placement$width = placement.width) !== null && _placement$width !== void 0 ? _placement$width : 100; // this.div ? this.div.clientWidth : this.width;

    const h = (_placement$height = placement.height) !== null && _placement$height !== void 0 ? _placement$height : 100; // this.div ? this.div.clientHeight : this.height;

    if (anchor.top) {
      if (!placement.top) {
        placement.top = 0;
      }

      if (anchor.bottom) {
        delete placement.height;
      } else {
        placement.height = h;
        delete placement.bottom;
      }
    } else if (anchor.bottom) {
      if (!placement.bottom) {
        placement.bottom = 0;
      }

      placement.height = h;
      delete placement.top;
    }

    if (anchor.left) {
      if (!placement.left) {
        placement.left = 0;
      }

      if (anchor.right) {
        delete placement.width;
      } else {
        placement.width = w;
        delete placement.right;
      }
    } else if (anchor.right) {
      if (!placement.right) {
        placement.right = 0;
      }

      placement.width = w;
      delete placement.left;
    }

    this.width = w;
    this.height = h;
    this.options.anchor = this.anchor;
    this.options.placement = this.placement;
  } // The parent size, need to set our own size based on offsets


  updateSize(width, height) {
    this.width = width;
    this.height = height;
    this.validatePlacement(); // Update the CSS position

    this.sizeStyle = Object.assign({}, this.options.placement, {
      position: 'absolute'
    });
  }

  updateData(ctx) {
    var _background$size;

    if (this.item.prepareData) {
      this.data = this.item.prepareData(ctx, this.options.config);
      this.revId++; // rerender
    }

    const {
      background,
      border
    } = this.options;
    const css = {};

    if (background) {
      if (background.color) {
        const color = ctx.getColor(background.color);
        css.backgroundColor = color.value();
      }

      if (background.image) {
        const image = ctx.getResource(background.image);

        if (image) {
          const v = image.value();

          if (v) {
            css.backgroundImage = `url("${v}")`;

            switch ((_background$size = background.size) !== null && _background$size !== void 0 ? _background$size : app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Contain) {
              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Contain:
                css.backgroundSize = 'contain';
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Cover:
                css.backgroundSize = 'cover';
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Original:
                css.backgroundRepeat = 'no-repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Tile:
                css.backgroundRepeat = 'repeat';
                break;

              case app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.BackgroundImageSize.Fill:
                css.backgroundSize = '100% 100%';
                break;
            }
          }
        }
      }
    }

    if (border && border.color && border.width) {
      const color = ctx.getColor(border.color);
      css.borderWidth = border.width;
      css.borderStyle = 'solid';
      css.borderColor = color.value(); // Move the image to inside the border

      if (css.backgroundImage) {
        css.backgroundOrigin = 'padding-box';
      }
    }

    this.dataStyle = css;
  }
  /** Recursively visit all nodes */


  visit(visitor) {
    visitor(this);
  }

  onChange(options) {
    if (this.item.id !== options.type) {
      var _canvasElementRegistr;

      this.item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.getIfExists(options.type)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_2__.notFoundItem;
    } // rename handling


    const oldName = this.options.name;
    const newName = options.name;
    this.revId++;
    this.options = Object.assign({}, options);
    let trav = this.parent;

    while (trav) {
      if (trav.isRoot()) {
        trav.scene.save();
        break;
      }

      trav.revId++;
      trav = trav.parent;
    }

    const scene = this.getScene();

    if (oldName !== newName && scene) {
      scene.byName.delete(oldName);
      scene.byName.set(newName, this);
    }
  }

  getSaveModel() {
    return Object.assign({}, this.options);
  }

  render() {
    const {
      item
    } = this;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
      style: Object.assign({}, this.sizeStyle, this.dataStyle),
      ref: this.initElement,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(item.display, {
        config: this.options.config,
        width: this.width,
        height: this.height,
        data: this.data
      }, `${this.UID}/${this.revId}`)
    }, `${this.UID}`);
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/group.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GroupState": () => (/* binding */ GroupState),
/* harmony export */   "groupItemDummy": () => (/* binding */ groupItemDummy)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/canvas/runtime/element.tsx");
/* harmony import */ var app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const groupItemDummy = {
  id: 'group',
  name: 'Group',
  description: 'Group',
  getNewOptions: () => ({
    config: {}
  }),
  // eslint-disable-next-line react/display-name
  display: () => {
    return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      children: "GROUP!"
    }));
  }
};
class GroupState extends _element__WEBPACK_IMPORTED_MODULE_3__.ElementState {
  constructor(options, scene, parent) {
    super(groupItemDummy, options, parent);
    this.options = options;
    this.parent = parent;

    _defineProperty(this, "elements", []);

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "doAction", (action, element, updateName = true) => {
      switch (action) {
        case app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.Delete:
          this.elements = this.elements.filter(e => e !== element);
          this.scene.byName.delete(element.options.name);
          this.scene.save();
          this.reinitializeMoveable();
          break;

        case app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_4__.LayerActionID.Duplicate:
          if (element.item.id === 'group') {
            console.log('Can not duplicate groups (yet)', action, element);
            return;
          }

          const opts = (0,lodash__WEBPACK_IMPORTED_MODULE_5__.cloneDeep)(element.options);

          if (element.anchor.top) {
            opts.placement.top += 10;
          }

          if (element.anchor.left) {
            opts.placement.left += 10;
          }

          if (element.anchor.bottom) {
            opts.placement.bottom += 10;
          }

          if (element.anchor.right) {
            opts.placement.right += 10;
          }

          const copy = new _element__WEBPACK_IMPORTED_MODULE_3__.ElementState(element.item, opts, this);
          copy.updateSize(element.width, element.height);
          copy.updateData(this.scene.context);

          if (updateName) {
            copy.options.name = this.scene.getNextElementName();
          }

          this.elements.push(copy);
          this.scene.byName.set(copy.options.name, copy);
          this.scene.save();
          this.reinitializeMoveable();
          break;

        default:
          console.log('DO action', action, element);
          return;
      }
    });

    this.options = options;
    this.parent = parent;
    this.scene = scene; // mutate options object

    let {
      elements
    } = this.options;

    if (!elements) {
      this.options.elements = elements = [];
    }

    for (const c of elements) {
      if (c.type === 'group') {
        this.elements.push(new GroupState(c, scene, this));
      } else {
        var _canvasElementRegistr;

        const item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_1__.canvasElementRegistry.getIfExists(c.type)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_2__.notFoundItem;
        this.elements.push(new _element__WEBPACK_IMPORTED_MODULE_3__.ElementState(item, c, this));
      }
    }
  }

  isRoot() {
    return false;
  } // The parent size, need to set our own size based on offsets


  updateSize(width, height) {
    super.updateSize(width, height);

    if (!this.parent) {
      this.width = width;
      this.height = height;
      this.sizeStyle.width = width;
      this.sizeStyle.height = height;
    } // Update children with calculated size


    for (const elem of this.elements) {
      elem.updateSize(this.width, this.height);
    } // The group forced to full width (for now)


    this.sizeStyle.width = width;
    this.sizeStyle.height = height;
    this.sizeStyle.position = 'absolute';
  }

  updateData(ctx) {
    super.updateData(ctx);

    for (const elem of this.elements) {
      elem.updateData(ctx);
    }
  } // used in the layer editor


  reorder(startIndex, endIndex) {
    const result = Array.from(this.elements);
    const [removed] = result.splice(startIndex, 1);
    result.splice(endIndex, 0, removed);
    this.elements = result;
    this.reinitializeMoveable();
  }

  reinitializeMoveable() {
    // Need to first clear current selection and then re-init moveable with slight delay
    this.scene.clearCurrentSelection();
    setTimeout(() => this.scene.initMoveable(true), 100);
  } // ??? or should this be on the element directly?
  // are actions scoped to layers?


  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      style: Object.assign({}, this.sizeStyle, this.dataStyle),
      children: this.elements.map(v => v.render())
    }, `${this.UID}/${this.revId}`);
  }
  /** Recursively visit all nodes */


  visit(visitor) {
    super.visit(visitor);

    for (const e of this.elements) {
      visitor(e);
    }
  }

  getSaveModel() {
    return Object.assign({}, this.options, {
      elements: this.elements.map(v => v.getSaveModel())
    });
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/root.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RootElement": () => (/* binding */ RootElement)
/* harmony export */ });
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/canvas/runtime/group.tsx");
const _excluded = ["placement", "anchor"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }


class RootElement extends _group__WEBPACK_IMPORTED_MODULE_0__.GroupState {
  constructor(options, scene, changeCallback) {
    super(options, scene);
    this.options = options;
    this.scene = scene;
    this.changeCallback = changeCallback;
    this.options = options;
    this.scene = scene;
    this.changeCallback = changeCallback;
  }

  isRoot() {
    return true;
  } // The parent size is always fullsize


  updateSize(width, height) {
    super.updateSize(width, height);
    this.width = width;
    this.height = height;
    this.sizeStyle.width = width;
    this.sizeStyle.height = height;
  } // root type can not change


  onChange(options) {
    this.revId++;
    this.options = Object.assign({}, options);
    this.changeCallback();
  }

  getSaveModel() {
    const _this$options = this.options,
          rest = _objectWithoutPropertiesLoose(_this$options, _excluded);

    return Object.assign({}, rest, {
      // everything except placement & anchor
      elements: this.elements.map(v => v.getSaveModel())
    });
  }

}

/***/ }),

/***/ "./public/app/features/canvas/runtime/scene.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scene": () => (/* binding */ Scene)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/first.js");
/* harmony import */ var moveable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./.yarn/cache/moveable-npm-0.28.0-32d066096a-1fee85a8c7.zip/node_modules/moveable/dist/moveable.esm.js");
/* harmony import */ var selecto__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./.yarn/cache/selecto-npm-1.15.0-eb84959df5-ae19513c77.zip/node_modules/selecto/dist/selecto.esm.js");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/dimensions/utils.ts");
/* harmony import */ var _root__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/canvas/runtime/root.tsx");
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/canvas/runtime/group.tsx");
/* harmony import */ var app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }















class Scene {
  // called after resize/drag for editor updates
  constructor(cfg, enableEditing, onSave) {
    this.onSave = onSave;

    _defineProperty(this, "styles", getStyles(app_core_config__WEBPACK_IMPORTED_MODULE_2__.config.theme2));

    _defineProperty(this, "selection", new rxjs__WEBPACK_IMPORTED_MODULE_10__.ReplaySubject(1));

    _defineProperty(this, "moved", new rxjs__WEBPACK_IMPORTED_MODULE_11__.Subject());

    _defineProperty(this, "byName", new Map());

    _defineProperty(this, "root", void 0);

    _defineProperty(this, "revId", 0);

    _defineProperty(this, "width", 0);

    _defineProperty(this, "height", 0);

    _defineProperty(this, "style", {});

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "selecto", void 0);

    _defineProperty(this, "moveable", void 0);

    _defineProperty(this, "div", void 0);

    _defineProperty(this, "currentLayer", void 0);

    _defineProperty(this, "getNextElementName", (isGroup = false) => {
      const label = isGroup ? 'Group' : 'Element';
      let idx = this.byName.size + 1;
      const max = idx + 100;

      while ( true && idx < max) {
        const name = `${label} ${idx++}`;

        if (!this.byName.has(name)) {
          return name;
        }
      }

      return `${label} ${Date.now()}`;
    });

    _defineProperty(this, "canRename", v => {
      return !this.byName.has(v);
    });

    _defineProperty(this, "context", {
      getColor: color => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getColorDimensionFromData)(this.data, color),
      getScale: scale => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getScaleDimensionFromData)(this.data, scale),
      getScalar: scalar => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getScalarDimensionFromData)(this.data, scalar),
      getText: text => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getTextDimensionFromData)(this.data, text),
      getResource: res => (0,app_features_dimensions_utils__WEBPACK_IMPORTED_MODULE_5__.getResourceDimensionFromData)(this.data, res)
    });

    _defineProperty(this, "save", () => {
      this.onSave(this.root.getSaveModel());
    });

    _defineProperty(this, "findElementByTarget", target => {
      // We will probably want to add memoization to this as we are calling on drag / resize
      const stack = [...this.root.elements];

      while (stack.length > 0) {
        const currentElement = stack.shift();

        if (currentElement && currentElement.div && currentElement.div === target) {
          return currentElement;
        }

        const nestedElements = currentElement instanceof _group__WEBPACK_IMPORTED_MODULE_7__.GroupState ? currentElement.elements : [];

        for (const nestedElement of nestedElements) {
          stack.unshift(nestedElement);
        }
      }

      return undefined;
    });

    _defineProperty(this, "setRef", sceneContainer => {
      this.div = sceneContainer;
    });

    _defineProperty(this, "select", selection => {
      if (this.selecto) {
        this.selecto.setSelectedTargets(selection.targets);
        this.updateSelection(selection);
      }
    });

    _defineProperty(this, "updateSelection", selection => {
      this.moveable.target = selection.targets;

      if (selection.group) {
        this.selection.next([selection.group]);
      } else {
        const s = selection.targets.map(t => this.findElementByTarget(t));
        this.selection.next(s);
      }
    });

    _defineProperty(this, "generateTargetElements", rootElements => {
      let targetElements = [];
      const stack = [...rootElements];

      while (stack.length > 0) {
        const currentElement = stack.shift();

        if (currentElement && currentElement.div) {
          targetElements.push(currentElement.div);
        }

        const nestedElements = currentElement instanceof _group__WEBPACK_IMPORTED_MODULE_7__.GroupState ? currentElement.elements : [];

        for (const nestedElement of nestedElements) {
          stack.unshift(nestedElement);
        }
      }

      return targetElements;
    });

    _defineProperty(this, "initMoveable", (destroySelecto = false, allowChanges = true) => {
      const targetElements = this.generateTargetElements(this.root.elements);

      if (destroySelecto) {
        var _this$selecto;

        (_this$selecto = this.selecto) === null || _this$selecto === void 0 ? void 0 : _this$selecto.destroy();
      }

      this.selecto = new selecto__WEBPACK_IMPORTED_MODULE_12__["default"]({
        container: this.div,
        selectableTargets: targetElements,
        selectByClick: true
      });
      this.moveable = new moveable__WEBPACK_IMPORTED_MODULE_13__["default"](this.div, {
        draggable: allowChanges,
        resizable: allowChanges,
        origin: false
      }).on('clickGroup', event => {
        this.selecto.clickTarget(event.inputEvent, event.inputTarget);
      }).on('drag', event => {
        const targetedElement = this.findElementByTarget(event.target);
        targetedElement.applyDrag(event);
        this.moved.next(Date.now()); // TODO only on end
      }).on('dragGroup', e => {
        e.events.forEach(event => {
          const targetedElement = this.findElementByTarget(event.target);
          targetedElement.applyDrag(event);
        });
        this.moved.next(Date.now()); // TODO only on end
      }).on('dragEnd', event => {
        const targetedElement = this.findElementByTarget(event.target);

        if (targetedElement && targetedElement.parent) {
          const parent = targetedElement.parent;
          targetedElement.updateSize(parent.width, parent.height);
        }
      }).on('resize', event => {
        const targetedElement = this.findElementByTarget(event.target);
        targetedElement.applyResize(event);
        this.moved.next(Date.now()); // TODO only on end
      }).on('resizeGroup', e => {
        e.events.forEach(event => {
          const targetedElement = this.findElementByTarget(event.target);
          targetedElement.applyResize(event);
        });
        this.moved.next(Date.now()); // TODO only on end
      });
      let targets = [];
      this.selecto.on('dragStart', event => {
        const selectedTarget = event.inputEvent.target;
        const isTargetMoveableElement = this.moveable.isMoveableElement(selectedTarget) || targets.some(target => target === selectedTarget || target.contains(selectedTarget));

        if (isTargetMoveableElement) {
          // Prevent drawing selection box when selected target is a moveable element
          event.stop();
        }
      }).on('selectEnd', event => {
        targets = event.selected;
        this.updateSelection({
          targets
        });

        if (event.isDragStart) {
          event.inputEvent.preventDefault();
          setTimeout(() => {
            this.moveable.dragStart(event.inputEvent);
          });
        }
      });
    });

    this.onSave = onSave;
    this.root = this.load(cfg, enableEditing);
  }

  load(cfg, enableEditing) {
    this.root = new _root__WEBPACK_IMPORTED_MODULE_6__.RootElement(cfg !== null && cfg !== void 0 ? cfg : {
      type: 'group',
      elements: [app_features_canvas__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_CANVAS_ELEMENT_CONFIG]
    }, this, this.save // callback when changes are made
    );
    setTimeout(() => {
      if (this.div) {
        // If editing is enabled, clear selecto instance
        const destroySelecto = enableEditing;
        this.initMoveable(destroySelecto, enableEditing);
      }
    }, 100);
    return this.root;
  }

  updateData(data) {
    this.data = data;
    this.root.updateData(this.context);
  }

  updateSize(width, height) {
    var _this$selecto2;

    this.width = width;
    this.height = height;
    this.style = {
      width,
      height
    };
    this.root.updateSize(width, height);

    if ((_this$selecto2 = this.selecto) !== null && _this$selecto2 !== void 0 && _this$selecto2.getSelectedTargets().length) {
      this.clearCurrentSelection();
    }
  }

  groupSelection() {
    this.selection.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.first)()).subscribe(currentSelectedElements => {
      const currentLayer = currentSelectedElements[0].parent;
      const newLayer = new _group__WEBPACK_IMPORTED_MODULE_7__.GroupState({
        type: 'group',
        name: this.getNextElementName(true),
        elements: []
      }, this, currentSelectedElements[0].parent);
      currentSelectedElements.forEach(element => {
        currentLayer.doAction(app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_8__.LayerActionID.Delete, element);
        newLayer.doAction(app_plugins_panel_canvas_types__WEBPACK_IMPORTED_MODULE_8__.LayerActionID.Duplicate, element, false);
      });
      currentLayer.elements.push(newLayer);
      this.byName.set(newLayer.getName(), newLayer);
      this.save();
    });
  }

  clearCurrentSelection() {
    var _this$selecto3;

    let event = new MouseEvent('click');
    (_this$selecto3 = this.selecto) === null || _this$selecto3 === void 0 ? void 0 : _this$selecto3.clickTarget(event, this.div);
  }

  updateCurrentLayer(newLayer) {
    this.currentLayer = newLayer;
    this.clearCurrentSelection();
    this.save();
  }

  toggleAnchor(element, k) {
    var _element$parent$width, _element$parent, _element$parent$heigh, _element$parent2;

    const {
      div
    } = element;

    if (!div) {
      console.log('Not ready');
      return;
    }

    const w = (_element$parent$width = (_element$parent = element.parent) === null || _element$parent === void 0 ? void 0 : _element$parent.width) !== null && _element$parent$width !== void 0 ? _element$parent$width : 100;
    const h = (_element$parent$heigh = (_element$parent2 = element.parent) === null || _element$parent2 === void 0 ? void 0 : _element$parent2.height) !== null && _element$parent$heigh !== void 0 ? _element$parent$heigh : 100; // Get computed position....

    const info = div.getBoundingClientRect(); // getElementInfo(div, element.parent?.div);

    console.log('DIV info', div);
    const placement = {
      top: info.top,
      left: info.left,
      width: info.width,
      height: info.height,
      bottom: h - info.bottom,
      right: w - info.right
    };
    console.log('PPP', placement); // // TODO: needs to recalculate placement based on absolute values...
    // element.anchor[k] = !Boolean(element.anchor[k]);
    // element.placement = placement;
    // element.validatePlacement();
    // element.revId++;
    // this.revId++;
    //    this.save();

    this.moved.next(Date.now());
  }

  render() {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
      className: this.styles.wrap,
      style: this.style,
      ref: this.setRef,
      children: this.root.render()
    }, this.revId);
  }

}
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.stylesFactory)(theme => ({
  wrap: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    overflow: hidden;
    position: relative;
  `,
  toolbar: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    position: absolute;
    bottom: 0;
    margin: 10px;
  `
}));

/***/ }),

/***/ "./public/app/features/canvas/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundImageSize": () => (/* binding */ BackgroundImageSize)
/* harmony export */ });
let BackgroundImageSize;

(function (BackgroundImageSize) {
  BackgroundImageSize["Original"] = "original";
  BackgroundImageSize["Contain"] = "contain";
  BackgroundImageSize["Cover"] = "cover";
  BackgroundImageSize["Fill"] = "fill";
  BackgroundImageSize["Tile"] = "tile";
})(BackgroundImageSize || (BackgroundImageSize = {}));

/***/ }),

/***/ "./public/app/plugins/panel/canvas/CanvasPanel.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasPanel": () => (/* binding */ CanvasPanel)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var app_types_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/types/events.ts");
/* harmony import */ var app_features_canvas_runtime_scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/runtime/scene.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






class CanvasPanel extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "panelContext", {});

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "subs", new rxjs__WEBPACK_IMPORTED_MODULE_4__.Subscription());

    _defineProperty(this, "needsReload", false);

    _defineProperty(this, "onUpdateScene", root => {
      const {
        onOptionsChange,
        options
      } = this.props;
      onOptionsChange(Object.assign({}, options, {
        root
      }));
      this.setState({
        refresh: this.state.refresh + 1
      }); // console.log('send changes', root);
    });

    this.state = {
      refresh: 0
    }; // Only the initial options are ever used.
    // later changes are all controlled by the scene

    this.scene = new app_features_canvas_runtime_scene__WEBPACK_IMPORTED_MODULE_2__.Scene(this.props.options.root, this.props.options.inlineEditing, this.onUpdateScene);
    this.scene.updateSize(props.width, props.height);
    this.scene.updateData(props.data);
    this.subs.add(this.props.eventBus.subscribe(app_types_events__WEBPACK_IMPORTED_MODULE_1__.PanelEditEnteredEvent, evt => {
      // Remove current selection when entering edit mode for any panel in dashboard
      this.scene.clearCurrentSelection();
    }));
    this.subs.add(this.props.eventBus.subscribe(app_types_events__WEBPACK_IMPORTED_MODULE_1__.PanelEditExitedEvent, evt => {
      if (this.props.id === evt.payload) {
        this.needsReload = true;
      }
    }));
  }

  componentDidMount() {
    this.panelContext = this.context;

    if (this.panelContext.onInstanceStateChange) {
      this.panelContext.onInstanceStateChange({
        scene: this.scene,
        layer: this.scene.root
      });
      this.subs.add(this.scene.selection.subscribe({
        next: v => {
          this.panelContext.onInstanceStateChange({
            scene: this.scene,
            selected: v,
            layer: this.scene.root
          });
        }
      }));
    }
  }

  componentWillUnmount() {
    this.subs.unsubscribe();
  } // NOTE, all changes to the scene flow through this function
  // even the editor gets current state from the same scene instance!


  shouldComponentUpdate(nextProps, nextState) {
    const {
      width,
      height,
      data
    } = this.props;
    let changed = false;

    if (width !== nextProps.width || height !== nextProps.height) {
      this.scene.updateSize(nextProps.width, nextProps.height);
      changed = true;
    }

    if (data !== nextProps.data) {
      this.scene.updateData(nextProps.data);
      changed = true;
    }

    if (this.state.refresh !== nextState.refresh) {
      changed = true;
    } // After editing, the options are valid, but the scene was in a different panel or inline editing mode has changed


    const shouldUpdateSceneAndPanel = this.needsReload && this.props.options !== nextProps.options || this.props.options.inlineEditing !== nextProps.options.inlineEditing;

    if (shouldUpdateSceneAndPanel) {
      this.needsReload = false;
      this.scene.load(nextProps.options.root, nextProps.options.inlineEditing);
      this.scene.updateSize(nextProps.width, nextProps.height);
      this.scene.updateData(nextProps.data);
      changed = true;

      if (this.props.options.inlineEditing) {
        var _this$scene$selecto;

        (_this$scene$selecto = this.scene.selecto) === null || _this$scene$selecto === void 0 ? void 0 : _this$scene$selecto.destroy();
      }
    }

    return changed;
  }

  render() {
    return this.scene.render();
  }

}

_defineProperty(CanvasPanel, "contextType", _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.PanelContextRoot);

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/APIEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "APIEditor": () => (/* binding */ APIEditor),
/* harmony export */   "callApi": () => (/* binding */ callApi)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_core_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/core.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _JSONFormatter, _br;









const dummyStringSettings = {
  settings: {}
};
const callApi = (api, isTest = false) => {
  if (api) {
    var _api$data;

    (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getBackendSrv)().fetch({
      url: api.endpoint,
      method: 'POST',
      data: (_api$data = api.data) !== null && _api$data !== void 0 ? _api$data : {}
    }).subscribe({
      error: error => {
        if (isTest) {
          app_core_core__WEBPACK_IMPORTED_MODULE_4__.appEvents.emit(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.AppEvents.alertError, ['Error has occurred: ', JSON.stringify(error)]);
          console.error(error);
        }
      },
      complete: () => {
        if (isTest) {
          app_core_core__WEBPACK_IMPORTED_MODULE_4__.appEvents.emit(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.AppEvents.alertSuccess, ['Test successful']);
        }
      }
    });
  }
};
const APIEditor = props => {
  var _value$data, _value$data2;

  const {
    value,
    context,
    onChange
  } = props;
  const labelWidth = 9;
  const onEndpointChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(endpoint => {
    onChange(Object.assign({}, value, {
      endpoint
    }));
  }, [onChange, value]);
  const onDataChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(data => {
    onChange(Object.assign({}, value, {
      data
    }));
  }, [onChange, value]);

  const renderJSON = data => {
    try {
      const json = JSON.parse(data);
      return _JSONFormatter || (_JSONFormatter = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.JSONFormatter, {
        json: json
      }));
    } catch (error) {
      return `Invalid JSON provided: ${error.message}`;
    }
  };

  const renderTestAPIButton = api => {
    if (api && api.endpoint) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
        onClick: () => callApi(api, true),
        title: 'Test API',
        children: "Test API"
      });
    }

    return;
  };

  return _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.disableSanitizeHtml ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFieldRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineField, {
        label: 'Endpoint',
        labelWidth: labelWidth,
        grow: true,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.StringValueEditor, {
          context: context,
          value: value === null || value === void 0 ? void 0 : value.endpoint,
          onChange: onEndpointChange,
          item: dummyStringSettings
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFieldRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineField, {
        label: 'Data',
        labelWidth: labelWidth,
        grow: true,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.StringValueEditor, {
          context: context,
          value: (_value$data = value === null || value === void 0 ? void 0 : value.data) !== null && _value$data !== void 0 ? _value$data : '{}',
          onChange: onDataChange,
          item: dummyStringSettings
        })
      })
    }), renderTestAPIButton(value), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("br", {})), renderJSON((_value$data2 = value === null || value === void 0 ? void 0 : value.data) !== null && _value$data2 !== void 0 ? _value$data2 : '{}')]
  }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: "Must enable disableSanitizeHtml feature flag to access"
  });
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/LayerElementListEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerElementListEditor": () => (/* binding */ LayerElementListEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/types.ts");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_core_app_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/app_events.ts");
/* harmony import */ var app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/canvas/runtime/element.tsx");
/* harmony import */ var app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/canvas/elements/notFound.tsx");
/* harmony import */ var app_features_canvas_runtime_group__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/features/canvas/runtime/group.tsx");
/* harmony import */ var app_types_events__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/types/events.ts");
/* harmony import */ var app_core_components_Layers_LayerDragDropList__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/core/components/Layers/LayerDragDropList.tsx");
/* harmony import */ var app_core_components_Layers_AddLayerButton__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/core/components/Layers/AddLayerButton.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div, _div2, _br;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
















class LayerElementListEditor extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "getScene", () => {
      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      return settings.layer.scene;
    });

    _defineProperty(this, "onAddItem", sel => {
      var _canvasElementRegistr;

      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const item = (_canvasElementRegistr = app_features_canvas__WEBPACK_IMPORTED_MODULE_4__.canvasElementRegistry.getIfExists(sel.value)) !== null && _canvasElementRegistr !== void 0 ? _canvasElementRegistr : app_features_canvas_elements_notFound__WEBPACK_IMPORTED_MODULE_7__.notFoundItem;
      const newElementOptions = item.getNewOptions();
      newElementOptions.type = item.id;
      const newElement = new app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_6__.ElementState(item, newElementOptions, layer);
      newElement.updateSize(newElement.width, newElement.height);
      newElement.updateData(layer.scene.context);
      layer.elements.push(newElement);
      layer.scene.save();
      layer.reinitializeMoveable();
    });

    _defineProperty(this, "onSelect", item => {
      const {
        settings
      } = this.props.item;

      if (settings !== null && settings !== void 0 && settings.scene) {
        try {
          let selection = {
            targets: []
          };

          if (item instanceof app_features_canvas_runtime_group__WEBPACK_IMPORTED_MODULE_8__.GroupState) {
            const targetElements = [];
            item.elements.forEach(element => {
              targetElements.push(element.div);
            });
            selection.targets = targetElements;
            selection.group = item;
            settings.scene.select(selection);
          } else if (item instanceof app_features_canvas_runtime_element__WEBPACK_IMPORTED_MODULE_6__.ElementState) {
            const targetElement = [item === null || item === void 0 ? void 0 : item.div];
            selection.targets = targetElement;
            settings.scene.select(selection);
          }
        } catch (error) {
          app_core_app_events__WEBPACK_IMPORTED_MODULE_5__["default"].emit(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.AppEvents.alertError, ['Unable to select element, try selecting element in panel instead']);
        }
      }
    });

    _defineProperty(this, "onClearSelection", () => {
      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      layer.scene.clearCurrentSelection();
    });

    _defineProperty(this, "onDragEnd", result => {
      if (!result.destination) {
        return;
      }

      const {
        settings
      } = this.props.item;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const count = layer.elements.length - 1;
      const src = (result.source.index - count) * -1;
      const dst = (result.destination.index - count) * -1;
      layer.reorder(src, dst);
    });

    _defineProperty(this, "goUpLayer", () => {
      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer) || !(settings !== null && settings !== void 0 && settings.scene)) {
        return;
      }

      const {
        scene,
        layer
      } = settings;

      if (layer.parent) {
        scene.updateCurrentLayer(layer.parent);
      }
    });

    _defineProperty(this, "decoupleGroup", () => {
      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      this.deleteGroup();
      layer.elements.forEach(element => {
        var _layer$parent;

        (_layer$parent = layer.parent) === null || _layer$parent === void 0 ? void 0 : _layer$parent.doAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Duplicate, element, false);
      });
    });

    _defineProperty(this, "onDecoupleGroup", () => {
      app_core_app_events__WEBPACK_IMPORTED_MODULE_5__["default"].publish(new app_types_events__WEBPACK_IMPORTED_MODULE_9__.ShowConfirmModalEvent({
        title: 'Decouple group',
        text: `Are you sure you want to decouple this group?`,
        text2: 'This will remove the group and push nested elements in the next level up.',
        confirmText: 'Yes',
        yesText: 'Decouple',
        onConfirm: async () => {
          this.decoupleGroup();
        }
      }));
    });

    _defineProperty(this, "deleteGroup", () => {
      var _layer$parent2;

      const settings = this.props.item.settings;

      if (!(settings !== null && settings !== void 0 && settings.layer)) {
        return;
      }

      const {
        layer
      } = settings;
      const scene = this.getScene();
      scene === null || scene === void 0 ? void 0 : scene.byName.delete(layer.getName());
      layer.elements.forEach(element => scene === null || scene === void 0 ? void 0 : scene.byName.delete(element.getName()));
      (_layer$parent2 = layer.parent) === null || _layer$parent2 === void 0 ? void 0 : _layer$parent2.doAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Delete, layer);
      this.goUpLayer();
    });

    _defineProperty(this, "onGroupSelection", () => {
      const scene = this.getScene();

      if (scene) {
        scene.groupSelection();
      } else {
        console.warn('no scene!');
      }
    });

    _defineProperty(this, "onDeleteGroup", () => {
      app_core_app_events__WEBPACK_IMPORTED_MODULE_5__["default"].publish(new app_types_events__WEBPACK_IMPORTED_MODULE_9__.ShowConfirmModalEvent({
        title: 'Delete group',
        text: `Are you sure you want to delete this group?`,
        text2: 'This will delete the group and all nested elements.',
        icon: 'trash-alt',
        confirmText: 'Delete',
        yesText: 'Delete',
        onConfirm: async () => {
          this.deleteGroup();
        }
      }));
    });
  }

  render() {
    const settings = this.props.item.settings;

    if (!settings) {
      return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)("div", {
        children: "No settings"
      }));
    }

    const layer = settings.layer;

    if (!layer) {
      return _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)("div", {
        children: "Missing layer?"
      }));
    }

    const onDelete = element => {
      layer.doAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Delete, element);
    };

    const onDuplicate = element => {
      layer.doAction(_types__WEBPACK_IMPORTED_MODULE_3__.LayerActionID.Duplicate, element);
    };

    const getLayerInfo = element => {
      return element.options.type;
    };

    const onNameChange = (element, name) => {
      element.onChange(Object.assign({}, element.options, {
        name
      }));
    };

    const isGroup = element => {
      return element instanceof app_features_canvas_runtime_group__WEBPACK_IMPORTED_MODULE_8__.GroupState;
    };

    const verifyLayerNameUniqueness = nameToVerify => {
      const scene = this.getScene();
      return Boolean(scene === null || scene === void 0 ? void 0 : scene.canRename(nameToVerify));
    };

    const selection = settings.selected ? settings.selected.map(v => v.getName()) : [];
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.Fragment, {
      children: [!layer.isRoot() && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
          icon: "angle-up",
          size: "sm",
          variant: "secondary",
          onClick: this.goUpLayer,
          children: "Go Up Level"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onSelect(layer),
          children: "Select Group"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onDecoupleGroup(),
          children: "Decouple Group"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: () => this.onDeleteGroup(),
          children: "Delete Group"
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(app_core_components_Layers_LayerDragDropList__WEBPACK_IMPORTED_MODULE_10__.LayerDragDropList, {
        onDragEnd: this.onDragEnd,
        onSelect: this.onSelect,
        onDelete: onDelete,
        onDuplicate: onDuplicate,
        getLayerInfo: getLayerInfo,
        onNameChange: onNameChange,
        verifyLayerNameUniqueness: verifyLayerNameUniqueness,
        isGroup: isGroup,
        layers: layer.elements,
        selection: selection
      }), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)("br", {})), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.HorizontalGroup, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(app_core_components_Layers_AddLayerButton__WEBPACK_IMPORTED_MODULE_11__.AddLayerButton, {
          onChange: this.onAddItem,
          options: app_features_canvas__WEBPACK_IMPORTED_MODULE_4__.canvasElementRegistry.selectOptions().options,
          label: 'Add item'
        }), selection.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: this.onClearSelection,
          children: "Clear Selection"
        }), selection.length > 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_12__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
          size: "sm",
          variant: "secondary",
          onClick: this.onGroupSelection,
          children: "Group items"
        })]
      })]
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PlacementEditor": () => (/* binding */ PlacementEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useObservable.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var app_features_dimensions_editors_NumberInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dimensions/editors/NumberInput.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _div, _div2, _br;









const anchors = ['top', 'left', 'bottom', 'right'];
const places = ['top', 'left', 'bottom', 'right', 'width', 'height'];
const PlacementEditor = ({
  item
}) => {
  const settings = item.settings; // Will force a rerender whenever the subject changes

  (0,react_use__WEBPACK_IMPORTED_MODULE_4__["default"])(settings !== null && settings !== void 0 && settings.scene ? settings.scene.moved : new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject());

  if (!settings) {
    return _div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
      children: "Loading..."
    }));
  }

  const element = settings.element;

  if (!element) {
    return _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("div", {
      children: "???"
    }));
  }

  const {
    placement
  } = element;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.HorizontalGroup, {
      children: anchors.map(a => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
        size: "sm",
        variant: element.anchor[a] ? 'primary' : 'secondary',
        onClick: () => settings.scene.toggleAnchor(element, a),
        children: a
      }, a))
    }), _br || (_br = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("br", {})), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Field, {
      label: "Position",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.Fragment, {
        children: places.map(p => {
          const v = placement[p];

          if (v == null) {
            return null;
          }

          return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFieldRow, {
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineField, {
              label: p,
              labelWidth: 8,
              grow: true,
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(app_features_dimensions_editors_NumberInput__WEBPACK_IMPORTED_MODULE_2__.NumberInput, {
                value: v,
                onChange: v => console.log('TODO, edit!!!', p, v)
              })
            })
          }, p);
        })
      })
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/elementEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getElementEditor": () => (/* binding */ getElementEditor)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/options.ts");
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _PlacementEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx");





function getElementEditor(opts) {
  return {
    category: opts.category,
    path: '--',
    // not used!
    // Note that canvas editor writes things to the scene!
    values: parent => ({
      getValue: path => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(opts.element.options, path);
      },
      onChange: (path, value) => {
        let options = opts.element.options;

        if (path === 'type' && value) {
          const layer = app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.canvasElementRegistry.getIfExists(value);

          if (!layer) {
            console.warn('layer does not exist', value);
            return;
          }

          options = Object.assign({}, options, layer.getNewOptions(options), {
            type: layer.id
          });
        } else {
          options = (0,app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_3__.setOptionImmutably)(options, path, value);
        }

        opts.element.onChange(options);
        opts.element.updateData(opts.scene.context);
      }
    }),
    // Dynamically fill the selected element
    build: (builder, context) => {
      var _options$type;

      const {
        options
      } = opts.element;
      const layerTypes = app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.canvasElementRegistry.selectOptions(options !== null && options !== void 0 && options.type // the selected value
      ? [options.type] // as an array
      : [app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CANVAS_ELEMENT_CONFIG.type]);
      builder.addSelect({
        path: 'type',
        name: undefined,
        // required, but hide space
        settings: {
          options: layerTypes.options
        }
      }); // force clean layer configuration

      const layer = app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.canvasElementRegistry.getIfExists((_options$type = options === null || options === void 0 ? void 0 : options.type) !== null && _options$type !== void 0 ? _options$type : app_features_canvas__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CANVAS_ELEMENT_CONFIG.type);
      let currentOptions = options;

      if (!currentOptions) {
        currentOptions = Object.assign({}, layer.getNewOptions(options), {
          type: layer.id,
          name: `Element ${Date.now()}.${Math.floor(Math.random() * 100)}`
        });
      }

      const ctx = Object.assign({}, context, {
        options: currentOptions
      });

      if (layer !== null && layer !== void 0 && layer.registerOptionsUI) {
        layer.registerOptionsUI(builder, ctx);
      }

      _options__WEBPACK_IMPORTED_MODULE_1__.optionBuilder.addBackground(builder, ctx);
      _options__WEBPACK_IMPORTED_MODULE_1__.optionBuilder.addBorder(builder, ctx);
      builder.addCustomEditor({
        category: ['Layout'],
        id: 'content',
        path: '__',
        // not used
        name: 'Anchor',
        editor: _PlacementEditor__WEBPACK_IMPORTED_MODULE_4__.PlacementEditor,
        settings: opts
      });
    }
  };
}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/layerEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLayerEditor": () => (/* binding */ getLayerEditor)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/options.ts");
/* harmony import */ var app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/dashboard/components/PanelEditor/utils.ts");
/* harmony import */ var _LayerElementListEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/LayerElementListEditor.tsx");
/* harmony import */ var app_features_canvas_runtime_group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/runtime/group.tsx");
/* harmony import */ var _PlacementEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/PlacementEditor.tsx");






function getLayerEditor(opts) {
  const {
    selected,
    scene
  } = opts;

  if (!scene.currentLayer) {
    scene.currentLayer = scene.root;
  }

  if (selected) {
    for (const element of selected) {
      if (element instanceof app_features_canvas_runtime_group__WEBPACK_IMPORTED_MODULE_4__.GroupState) {
        scene.currentLayer = element;
        break;
      }

      if (element.parent) {
        scene.currentLayer = element.parent;
        break;
      }
    }
  }

  const options = scene.currentLayer.options || {
    elements: []
  };
  return {
    category: ['Layer'],
    path: '--',
    // not used!
    // Note that canvas editor writes things to the scene!
    values: parent => ({
      getValue: path => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.get)(options, path);
      },
      onChange: (path, value) => {
        var _scene$currentLayer;

        if (path === 'type' && value) {
          console.warn('unable to change layer type');
          return;
        }

        const c = (0,app_features_dashboard_components_PanelEditor_utils__WEBPACK_IMPORTED_MODULE_2__.setOptionImmutably)(options, path, value);
        (_scene$currentLayer = scene.currentLayer) === null || _scene$currentLayer === void 0 ? void 0 : _scene$currentLayer.onChange(c);
      }
    }),
    // Dynamically fill the selected element
    build: (builder, context) => {
      const currentLayer = scene.currentLayer;

      if (currentLayer && !currentLayer.isRoot()) {// TODO: the non-root nav option
      }

      builder.addCustomEditor({
        id: 'content',
        path: 'root',
        name: 'Elements',
        editor: _LayerElementListEditor__WEBPACK_IMPORTED_MODULE_3__.LayerElementListEditor,
        settings: {
          scene,
          layer: scene.currentLayer,
          selected
        }
      });
      const ctx = Object.assign({}, context, {
        options
      });
      _options__WEBPACK_IMPORTED_MODULE_1__.optionBuilder.addBackground(builder, ctx);
      _options__WEBPACK_IMPORTED_MODULE_1__.optionBuilder.addBorder(builder, ctx);

      if (currentLayer && !currentLayer.isRoot()) {
        builder.addCustomEditor({
          category: ['Layout'],
          id: 'content',
          path: '__',
          // not used
          name: 'Anchor',
          editor: _PlacementEditor__WEBPACK_IMPORTED_MODULE_5__.PlacementEditor,
          settings: {
            scene: opts.scene,
            element: currentLayer
          }
        });
      }
    }
  };
}

/***/ }),

/***/ "./public/app/plugins/panel/canvas/editor/options.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "optionBuilder": () => (/* binding */ optionBuilder)
/* harmony export */ });
/* harmony import */ var app_features_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/features/canvas/index.ts");
/* harmony import */ var app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dimensions/editors/index.ts");


const optionBuilder = {
  addBackground: (builder, context) => {
    const category = ['Background'];
    builder.addCustomEditor({
      category,
      id: 'background.color',
      path: 'background.color',
      name: 'Color',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ColorDimensionEditor,
      settings: {},
      defaultValue: {
        // Configured values
        fixed: ''
      }
    }).addCustomEditor({
      category,
      id: 'background.image',
      path: 'background.image',
      name: 'Image',
      editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ResourceDimensionEditor,
      settings: {
        resourceType: 'image'
      }
    }).addRadio({
      category,
      path: 'background.size',
      name: 'Image size',
      settings: {
        options: [{
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Original,
          label: 'Original'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Contain,
          label: 'Contain'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Cover,
          label: 'Cover'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Fill,
          label: 'Fill'
        }, {
          value: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Tile,
          label: 'Tile'
        }]
      },
      defaultValue: app_features_canvas__WEBPACK_IMPORTED_MODULE_0__.BackgroundImageSize.Cover
    });
  },
  addBorder: (builder, context) => {
    var _context$options, _context$options$bord;

    const category = ['Border'];
    builder.addSliderInput({
      category,
      path: 'border.width',
      name: 'Width',
      defaultValue: 2,
      settings: {
        min: 0,
        max: 20
      }
    });

    if ((_context$options = context.options) !== null && _context$options !== void 0 && (_context$options$bord = _context$options.border) !== null && _context$options$bord !== void 0 && _context$options$bord.width) {
      builder.addCustomEditor({
        category,
        id: 'border.color',
        path: 'border.color',
        name: 'Color',
        editor: app_features_dimensions_editors__WEBPACK_IMPORTED_MODULE_1__.ColorDimensionEditor,
        settings: {},
        defaultValue: {
          // Configured values
          fixed: ''
        }
      });
    }
  }
};

/***/ }),

/***/ "./public/app/plugins/panel/canvas/module.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _CanvasPanel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/panel/canvas/CanvasPanel.tsx");
/* harmony import */ var _editor_elementEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/elementEditor.tsx");
/* harmony import */ var _editor_layerEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/panel/canvas/editor/layerEditor.tsx");
/* harmony import */ var app_features_canvas_runtime_group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/canvas/runtime/group.tsx");





const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.PanelPlugin(_CanvasPanel__WEBPACK_IMPORTED_MODULE_1__.CanvasPanel).setNoPadding() // extend to panel edges
.useFieldConfig().setPanelOptions((builder, context) => {
  const state = context.instanceState;
  builder.addBooleanSwitch({
    path: 'inlineEditing',
    name: 'Inline editing',
    description: 'Enable editing the panel directly',
    defaultValue: true
  });

  if (state) {
    builder.addNestedOptions((0,_editor_layerEditor__WEBPACK_IMPORTED_MODULE_3__.getLayerEditor)(state));
    const selection = state.selected;

    if ((selection === null || selection === void 0 ? void 0 : selection.length) === 1) {
      const element = selection[0];

      if (!(element instanceof app_features_canvas_runtime_group__WEBPACK_IMPORTED_MODULE_4__.GroupState)) {
        builder.addNestedOptions((0,_editor_elementEditor__WEBPACK_IMPORTED_MODULE_2__.getElementEditor)({
          category: [`Selected element (${element.options.name})`],
          element,
          scene: state.scene
        }));
      }
    }
  }
});

/***/ }),

/***/ "./public/app/plugins/panel/canvas/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerActionID": () => (/* binding */ LayerActionID)
/* harmony export */ });
let LayerActionID;

(function (LayerActionID) {
  LayerActionID["Delete"] = "delete";
  LayerActionID["Duplicate"] = "duplicate";
  LayerActionID["MoveTop"] = "move-top";
  LayerActionID["MoveBottom"] = "move-bottom";
})(LayerActionID || (LayerActionID = {}));

/***/ }),

/***/ "./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: css-styled
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-styled.git
version: 1.0.0
*/


function hash(str) {
  var hash = 5381,
      i    = str.length;

  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

var stringHash = hash;

function getHash(str) {
  return stringHash(str).toString(36);
}
function getShadowRoot(parentElement) {
  if (parentElement && parentElement.getRootNode) {
    var rootNode = parentElement.getRootNode();

    if (rootNode.nodeType === 11) {
      return rootNode;
    }
  }

  return;
}
function replaceStyle(className, css, options) {
  if (options.original) {
    return css;
  }

  return css.replace(/([^};{\s}][^};{]*|^\s*){/mg, function (_, selector) {
    var trimmedSelector = selector.trim();
    return (trimmedSelector ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitComma)(trimmedSelector) : [""]).map(function (subSelector) {
      var trimmedSubSelector = subSelector.trim();

      if (trimmedSubSelector.indexOf("@") === 0) {
        return trimmedSubSelector;
      } else if (trimmedSubSelector.indexOf(":global") > -1) {
        return trimmedSubSelector.replace(/\:global/g, "");
      } else if (trimmedSubSelector.indexOf(":host") > -1) {
        return "" + trimmedSubSelector.replace(/\:host/g, "." + className);
      } else if (trimmedSubSelector) {
        return "." + className + " " + trimmedSubSelector;
      } else {
        return "." + className;
      }
    }).join(", ") + " {";
  });
}
function injectStyle(className, css, options, shadowRoot) {
  var style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.setAttribute("data-styled-id", className);

  if (options.nonce) {
    style.setAttribute("nonce", options.nonce);
  }

  style.innerHTML = replaceStyle(className, css, options);
  (shadowRoot || document.head || document.body).appendChild(style);
  return style;
}

/**
 * Create an styled object that can be defined and inserted into the css.
 * @param - css styles
 */

function styled(css) {
  var injectClassName = "rCS" + getHash(css);
  var injectCount = 0;
  var injectElement;
  return {
    className: injectClassName,
    inject: function (el, options) {
      if (options === void 0) {
        options = {};
      }

      var shadowRoot = getShadowRoot(el);
      var firstMount = injectCount === 0;
      var styleElement;

      if (shadowRoot || firstMount) {
        styleElement = injectStyle(injectClassName, css, options, shadowRoot);
      }

      if (firstMount) {
        injectElement = styleElement;
      }

      if (!shadowRoot) {
        ++injectCount;
      }

      return {
        destroy: function () {
          if (shadowRoot) {
            el.removeChild(styleElement);
            styleElement = null;
          } else {
            if (injectCount > 0) {
              --injectCount;
            }

            if (injectCount === 0 && injectElement) {
              injectElement.parentNode.removeChild(injectElement);
              injectElement = null;
            }
          }
        }
      };
    }
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styled);
//# sourceMappingURL=styled.esm.js.map


/***/ }),

/***/ "./.yarn/__virtual__/react-compat-moveable-virtual-81b7a42abb/0/cache/react-compat-moveable-npm-0.16.0-395b3c92e9-b20bd91698.zip/node_modules/react-compat-moveable/dist/moveable.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Clippable": () => (/* binding */ Clippable),
/* harmony export */   "Draggable": () => (/* binding */ Draggable),
/* harmony export */   "EdgeDraggable": () => (/* binding */ edgeDraggable),
/* harmony export */   "InitialMoveable": () => (/* binding */ InitialMoveable),
/* harmony export */   "MOVEABLE_ABLES": () => (/* binding */ MOVEABLE_ABLES),
/* harmony export */   "MOVEABLE_EVENTS": () => (/* binding */ MOVEABLE_EVENTS),
/* harmony export */   "MOVEABLE_EVENTS_MAP": () => (/* binding */ MOVEABLE_EVENTS_MAP),
/* harmony export */   "MOVEABLE_EVENTS_PROPS_MAP": () => (/* binding */ MOVEABLE_EVENTS_PROPS_MAP),
/* harmony export */   "MOVEABLE_METHODS": () => (/* binding */ MOVEABLE_METHODS),
/* harmony export */   "MOVEABLE_PROPS": () => (/* binding */ MOVEABLE_PROPS),
/* harmony export */   "MOVEABLE_PROPS_MAP": () => (/* binding */ MOVEABLE_PROPS_MAP),
/* harmony export */   "Pinchable": () => (/* binding */ Pinchable),
/* harmony export */   "Resizable": () => (/* binding */ Resizable),
/* harmony export */   "Rotatable": () => (/* binding */ Rotatable),
/* harmony export */   "Roundable": () => (/* binding */ Roundable),
/* harmony export */   "Scalable": () => (/* binding */ Scalable),
/* harmony export */   "Snappable": () => (/* binding */ Snappable),
/* harmony export */   "Warpable": () => (/* binding */ Warpable),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getElementInfo": () => (/* binding */ getElementInfo),
/* harmony export */   "makeAble": () => (/* binding */ makeAble),
/* harmony export */   "makeMoveable": () => (/* binding */ makeMoveable)
/* harmony export */ });
/* harmony import */ var _egjs_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@egjs-agent-npm-2.3.0-e88ca0eec2-2506e8feff.zip/node_modules/@egjs/agent/dist/agent.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _scena_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js");
/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js");
/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js");
/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js");
/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.1-d35db08ba4-07a47e750f.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/gesto-npm-1.7.0-7d5440000b-f2a66bcf0f.zip/node_modules/gesto/dist/gesto.esm.js");
/* harmony import */ var react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/cache/react-compat-css-styled-npm-1.0.8-52211d26f8-7a8e51849e.zip/node_modules/react-compat-css-styled/dist/styled.esm.js");
/*
Copyright (c) 2019 Daybrush
name: react-compat-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-compat-moveable
version: 0.16.0
*/












/*
Copyright (c) 2019 Daybrush
name: react-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable
version: 0.31.0
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function makeAble(name, able) {
  var _a;

  return __assign({
    events: {},
    props: (_a = {}, _a[name] = Boolean, _a),
    name: name
  }, able);
}

function getSVGCursor(scale, degree) {
  return "data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + 32 * scale + "px\" height=\"" + 32 * scale + "px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(" + degree + "deg);transform-origin: 16px 16px\"></path></svg>";
}

function getCursorCSS(degree) {
  var x1 = getSVGCursor(1, degree); // const x2 = getSVGCursor(2, degree);

  var degree45 = Math.round(degree / 45) * 45 % 180;
  var defaultCursor = "ns-resize";

  if (degree45 === 135) {
    defaultCursor = "nwse-resize";
  } else if (degree45 === 45) {
    defaultCursor = "nesw-resize";
  } else if (degree45 === 90) {
    defaultCursor = "ew-resize";
  } // tslint:disable-next-line: max-line-length


  return "cursor:" + defaultCursor + ";cursor: url('" + x1 + "') 16 16, " + defaultCursor + ";";
}

var agent = (0,_egjs_agent__WEBPACK_IMPORTED_MODULE_0__["default"])();
var IS_WEBKIT = agent.browser.webkit;
var IS_WEBKIT605 = IS_WEBKIT && function () {
  var navi = typeof window === "undefined" ? {
    userAgent: ""
  } : window.navigator;
  var res = /applewebkit\/([^\s]+)/g.exec(navi.userAgent.toLowerCase());
  return res ? parseFloat(res[1]) < 605 : false;
}();
var PREFIX = "moveable-";
var MOVEABLE_CSS = "\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n" + [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (degree) {
  return "\n.direction[data-rotation=\"" + degree + "\"] {\n\t" + getCursorCSS(degree) + "\n}\n";
}).join("\n") + "\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n" + (IS_WEBKIT605 ? ":global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}" : "") + "\n";
var NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];
var FLOAT_POINT_NUM = 0.0001;
var TINY_NUM = 0.0000001;
var MIN_SCALE = 0.000000001;
var MAX_NUM = Math.pow(10, 10);
var MIN_NUM = -MAX_NUM;
var DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
var DIRECTION_INDEXES = {
  n: [0, 1],
  s: [2, 3],
  w: [2, 0],
  e: [1, 3],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
};
var DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
};
var MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate"];

function multiply2(pos1, pos2) {
  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];
}
function prefix() {
  var classNames = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    classNames[_i] = arguments[_i];
  }

  return framework_utils__WEBPACK_IMPORTED_MODULE_1__.prefixNames.apply(void 0, __spreadArray([PREFIX], classNames));
}
function getTransformMatrix(transform) {
  if (!transform || transform === "none") {
    return [1, 0, 0, 1, 0, 0];
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(transform)) {
    return transform;
  }

  var value = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitBracket)(transform).value;
  return value.split(/s*,\s*/g).map(function (v) {
    return parseFloat(v);
  });
}
function getAbsoluteMatrix(matrix, n, origin) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiplies)(n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)(origin, n), matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)(origin.map(function (a) {
    return -a;
  }), n));
}
function measureSVGSize(el, unit, isHorizontal) {
  if (unit === "%") {
    var viewBox = getSVGViewBox(el.ownerSVGElement);
    return viewBox[isHorizontal ? "width" : "height"] / 100;
  }

  return 1;
}
function getBeforeTransformOrigin(el) {
  var relativeOrigin = getTransformOrigin(getComputedStyle(el, ":before"));
  return relativeOrigin.map(function (o, i) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitUnit)(o),
        value = _a.value,
        unit = _a.unit;

    return value * measureSVGSize(el, unit, i === 0);
  });
}
function getTransformOrigin(style) {
  var transformOrigin = style.transformOrigin;
  return transformOrigin ? transformOrigin.split(" ") : ["0", "0"];
}
function getOffsetInfo(el, lastParent, isParent) {
  var body = document.body;
  var target = !el || isParent ? el : el.parentElement;
  var isEnd = el === lastParent || target === lastParent;
  var position = "relative";

  while (target && target !== body) {
    if (lastParent === target) {
      isEnd = true;
    }

    var style = getComputedStyle(target);
    var transform = style.transform;
    position = style.position;

    if (target.tagName.toLowerCase() === "svg" || position !== "static" || transform && transform !== "none") {
      break;
    }

    target = target.parentElement;
    position = "relative";
  }

  return {
    isStatic: position === "static",
    isEnd: isEnd || !target || target === body,
    offsetParent: target || body
  };
}
function getOffsetPosInfo(el, container, style, isFixed) {
  var _a;

  var tagName = el.tagName.toLowerCase();
  var offsetLeft = el.offsetLeft;
  var offsetTop = el.offsetTop;

  if (isFixed) {
    var containerClientRect = (container || document.documentElement).getBoundingClientRect();
    offsetLeft -= containerClientRect.left;
    offsetTop -= containerClientRect.top;
  } // svg


  var isSVG = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(offsetLeft);
  var hasOffset = !isSVG;
  var origin;
  var targetOrigin; // inner svg element

  if (!hasOffset && tagName !== "svg") {
    origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function (pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
    hasOffset = true;
    _a = getSVGGraphicsOffset(el, origin), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];
  } else {
    origin = getTransformOrigin(style).map(function (pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
  }

  return {
    tagName: tagName,
    isSVG: isSVG,
    hasOffset: hasOffset,
    offset: [offsetLeft || 0, offsetTop || 0],
    origin: origin,
    targetOrigin: targetOrigin
  };
}
function getBodyOffset(el, isSVG, style) {
  if (style === void 0) {
    style = getComputedStyle(el);
  }

  var bodyStyle = getComputedStyle(document.body);
  var bodyPosition = bodyStyle.position;

  if (!isSVG && (!bodyPosition || bodyPosition === "static")) {
    return [0, 0];
  }

  var marginLeft = parseInt(bodyStyle.marginLeft, 10);
  var marginTop = parseInt(bodyStyle.marginTop, 10);

  if (style.position === "absolute") {
    if (style.top !== "auto" || style.bottom !== "auto") {
      marginTop = 0;
    }

    if (style.left !== "auto" || style.right !== "auto") {
      marginLeft = 0;
    }
  }

  return [marginLeft, marginTop];
}
function convert3DMatrixes(matrixes) {
  matrixes.forEach(function (info) {
    var matrix = info.matrix;

    if (matrix) {
      info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(matrix, 3, 4);
    }
  });
}
function getMatrixStackInfo(target, container, checkContainer) {
  var el = target;
  var matrixes = [];
  var requestEnd = !checkContainer && target === container;
  var isEnd = requestEnd;
  var is3d = false;
  var n = 3;
  var transformOrigin;
  var targetTransformOrigin;
  var targetMatrix;
  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;

  while (el && !isEnd) {
    isEnd = requestEnd;
    var style = getComputedStyle(el);
    var position = style.position;
    var isFixed = position === "fixed";
    var matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertCSStoMatrix)(getTransformMatrix(style.transform)); // convert 3 to 4

    var length = matrix.length;

    if (!is3d && length === 16) {
      is3d = true;
      n = 4;
      convert3DMatrixes(matrixes);

      if (targetMatrix) {
        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(targetMatrix, 3, 4);
      }
    }

    if (is3d && length === 9) {
      matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(matrix, 3, 4);
    }

    var _a = getOffsetPosInfo(el, container, style, isFixed),
        tagName = _a.tagName,
        hasOffset = _a.hasOffset,
        isSVG = _a.isSVG,
        origin = _a.origin,
        targetOrigin = _a.targetOrigin,
        offsetPos = _a.offset;

    var offsetLeft = offsetPos[0],
        offsetTop = offsetPos[1];

    if (tagName === "svg" && targetMatrix) {
      // scale matrix for svg's SVGElements.
      matrixes.push({
        type: "target",
        target: el,
        matrix: getSVGMatrix(el, n)
      });
      matrixes.push({
        type: "offset",
        target: el,
        matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n)
      });
    } else if (tagName === "g" && target !== el) {
      offsetLeft = 0;
      offsetTop = 0;
    }

    var _b = getOffsetInfo(el, container),
        offsetParent = _b.offsetParent,
        isOffsetEnd = _b.isEnd,
        isStatic = _b.isStatic;

    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === "relative" || position === "static")) {
      offsetLeft -= offsetParent.offsetLeft;
      offsetTop -= offsetParent.offsetTop;
      requestEnd = requestEnd || isOffsetEnd;
    }

    var parentClientLeft = 0;
    var parentClientTop = 0;

    if (hasOffset && offsetContainer !== offsetParent) {
      // border
      parentClientLeft = offsetParent.clientLeft;
      parentClientTop = offsetParent.clientTop;
    }

    if (hasOffset && offsetParent === document.body) {
      var margin = getBodyOffset(el, false, style);
      offsetLeft += margin[0];
      offsetTop += margin[1];
    }

    matrixes.push({
      type: "target",
      target: el,
      matrix: getAbsoluteMatrix(matrix, n, origin)
    });

    if (hasOffset) {
      matrixes.push({
        type: "offset",
        target: el,
        matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)([offsetLeft - el.scrollLeft + parentClientLeft, offsetTop - el.scrollTop + parentClientTop], n)
      });
    } else {
      // svg
      matrixes.push({
        type: "offset",
        target: el,
        origin: origin
      });
    }

    if (!targetMatrix) {
      targetMatrix = matrix;
    }

    if (!transformOrigin) {
      transformOrigin = origin;
    }

    if (!targetTransformOrigin) {
      targetTransformOrigin = targetOrigin;
    }

    if (isEnd || isFixed) {
      break;
    } else {
      el = offsetParent;
      requestEnd = isOffsetEnd;
    }

    if (!checkContainer || el === document.body) {
      isEnd = requestEnd;
    }
  }

  if (!targetMatrix) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  }

  if (!transformOrigin) {
    transformOrigin = [0, 0];
  }

  if (!targetTransformOrigin) {
    targetTransformOrigin = [0, 0];
  }

  return {
    offsetContainer: offsetContainer,
    matrixes: matrixes,
    targetMatrix: targetMatrix,
    transformOrigin: transformOrigin,
    targetOrigin: targetTransformOrigin,
    is3d: is3d
  };
}
function calculateElementInfo(target, container, rootContainer, isAbsolute3d) {
  var _a;

  if (rootContainer === void 0) {
    rootContainer = container;
  }

  var width = 0;
  var height = 0;
  var rotation = 0;
  var allResult = {};

  if (target) {
    var style = getComputedStyle(target);
    width = target.offsetWidth;
    height = target.offsetHeight;

    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(width)) {
      _a = getSize(target, style, true), width = _a[0], height = _a[1];
    }
  }

  if (target) {
    var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);
    var position = calculateMoveablePosition(result.allMatrix, result.transformOrigin, width, height);
    allResult = __assign(__assign({}, result), position);
    var rotationPosition = calculateMoveablePosition(result.allMatrix, [50, 50], 100, 100);
    rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);
  }

  var n = isAbsolute3d ? 4 : 3;
  return __assign({
    width: width,
    height: height,
    rotation: rotation,
    // rootMatrix: number[];
    // beforeMatrix: number[];
    // offsetMatrix: number[];
    // allMatrix: number[];
    // targetMatrix: number[];
    // targetTransform: string;
    // transformOrigin: number[];
    // targetOrigin: number[];
    // is3d: boolean;
    rootMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    beforeMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    offsetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    allMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    targetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!isAbsolute3d,
    // left: number;
    // top: number;
    // right: number;
    // bottom: number;
    // origin: number[];
    // pos1: number[];
    // pos2: number[];
    // pos3: number[];
    // pos4: number[];
    // direction: 1 | -1;
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1
  }, allResult);
}
function getElementInfo(target, container, rootContainer) {
  if (rootContainer === void 0) {
    rootContainer = container;
  }

  return calculateElementInfo(target, container, rootContainer, true);
}
function calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {
  var _a;

  if (rootContainer === void 0) {
    rootContainer = container;
  }

  var _b = getMatrixStackInfo(target, container),
      matrixes = _b.matrixes,
      is3d = _b.is3d,
      prevTargetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin,
      targetOrigin = _b.targetOrigin,
      offsetContainer = _b.offsetContainer; // prevMatrix


  var _c = getMatrixStackInfo(offsetContainer, rootContainer, true),
      rootMatrixes = _c.matrixes,
      isRoot3d = _c.is3d; // prevRootMatrix
  // if (rootContainer === document.body) {
  //     console.log(offsetContainer, rootContainer, rootMatrixes);
  // }


  var isNext3d = isAbsolute3d || isRoot3d || is3d;
  var n = isNext3d ? 4 : 3;
  var isSVGGraphicElement = target.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in target;
  var targetMatrix = prevTargetMatrix; // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);
  // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);
  // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);

  var allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  var rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  var beforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  var offsetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n);
  var length = matrixes.length;
  rootMatrixes.reverse();
  matrixes.reverse();

  if (!is3d && isNext3d) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(targetMatrix, 3, 4);
    convert3DMatrixes(matrixes);
  }

  if (!isRoot3d && isNext3d) {
    convert3DMatrixes(rootMatrixes);
  } // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)
  // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container
  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)
  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)


  rootMatrixes.forEach(function (info) {
    rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(rootMatrix, info.matrix, n);
  });
  var originalRootContainer = rootContainer || document.body;
  var endContainer = ((_a = rootMatrixes[0]) === null || _a === void 0 ? void 0 : _a.target) || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;
  var rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce(function (matrix, info) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(matrix, info.matrix, n);
  }, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(n));
  matrixes.forEach(function (info, i) {
    if (length - 2 === i) {
      // length - 3
      beforeMatrix = allMatrix.slice();
    }

    if (length - 1 === i) {
      // length - 2
      offsetMatrix = allMatrix.slice();
    } // calculate for SVGElement


    if (!info.matrix) {
      var nextInfo = matrixes[i + 1];
      var offset = getSVGOffset(info, nextInfo, endContainer, n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(rootMatrixBeforeOffset, allMatrix, n));
      info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)(offset, n);
    }

    allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(allMatrix, info.matrix, n);
  });
  var isMatrix3d = !isSVGGraphicElement && is3d;

  if (!targetMatrix) {
    targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(isMatrix3d ? 4 : 3);
  }

  var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);
  rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.ignoreDimension)(rootMatrix, n, n);
  return {
    rootMatrix: rootMatrix,
    beforeMatrix: beforeMatrix,
    offsetMatrix: offsetMatrix,
    allMatrix: allMatrix,
    targetMatrix: targetMatrix,
    targetTransform: targetTransform,
    transformOrigin: transformOrigin,
    targetOrigin: targetOrigin,
    is3d: isNext3d
  };
}
function makeMatrixCSS(matrix, is3d) {
  if (is3d === void 0) {
    is3d = matrix.length > 9;
  }

  return (is3d ? "matrix3d" : "matrix") + "(" + (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertMatrixtoCSS)(matrix, !is3d).join(",") + ")";
}
function getSVGViewBox(el) {
  var clientWidth = el.clientWidth;
  var clientHeight = el.clientHeight;

  if (!el) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: clientWidth,
      clientHeight: clientHeight
    };
  }

  var viewBox = el.viewBox;
  var baseVal = viewBox && viewBox.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: baseVal.x,
    y: baseVal.y,
    width: baseVal.width || clientWidth,
    height: baseVal.height || clientHeight,
    clientWidth: clientWidth,
    clientHeight: clientHeight
  };
}
function getSVGMatrix(el, n) {
  var _a = getSVGViewBox(el),
      viewBoxWidth = _a.width,
      viewBoxHeight = _a.height,
      clientWidth = _a.clientWidth,
      clientHeight = _a.clientHeight;

  var scaleX = clientWidth / viewBoxWidth;
  var scaleY = clientHeight / viewBoxHeight;
  var preserveAspectRatio = el.preserveAspectRatio.baseVal; // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio

  var align = preserveAspectRatio.align; // 1 : meet 2: slice

  var meetOrSlice = preserveAspectRatio.meetOrSlice;
  var svgOrigin = [0, 0];
  var scale = [scaleX, scaleY];
  var translate = [0, 0];

  if (align !== 1) {
    var xAlign = (align - 2) % 3;
    var yAlign = Math.floor((align - 2) / 3);
    svgOrigin[0] = viewBoxWidth * xAlign / 2;
    svgOrigin[1] = viewBoxHeight * yAlign / 2;
    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);
    scale[0] = scaleDimension;
    scale[1] = scaleDimension;
    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;
    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;
  }

  var scaleMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createScaleMatrix)(scale, n);
  scaleMatrix[n * (n - 1)] = translate[0], scaleMatrix[n * (n - 1) + 1] = translate[1];
  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);
}
function getSVGGraphicsOffset(el, origin) {
  if (!el.getBBox) {
    return [0, 0];
  }

  var bbox = el.getBBox();
  var viewBox = getSVGViewBox(el.ownerSVGElement);
  var left = bbox.x - viewBox.x;
  var top = bbox.y - viewBox.y;
  return [left, top, origin[0] - left, origin[1] - top];
}
function calculatePosition(matrix, pos, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertPositionMatrix)(pos, n), n);
}
function calculatePoses(matrix, width, height, n) {
  return [[0, 0], [width, 0], [0, height], [width, height]].map(function (pos) {
    return calculatePosition(matrix, pos, n);
  });
}
function getRect(poses) {
  var posesX = poses.map(function (pos) {
    return pos[0];
  });
  var posesY = poses.map(function (pos) {
    return pos[1];
  });
  var left = Math.min.apply(Math, posesX);
  var top = Math.min.apply(Math, posesY);
  var right = Math.max.apply(Math, posesX);
  var bottom = Math.max.apply(Math, posesY);
  var rectWidth = right - left;
  var rectHeight = bottom - top;
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    width: rectWidth,
    height: rectHeight
  };
}
function calculateRect(matrix, width, height, n) {
  var poses = calculatePoses(matrix, width, height, n);
  return getRect(poses);
}
function getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {
  var _a;

  var target = offsetInfo.target;
  var origin = offsetInfo.origin;
  var targetMatrix = targetInfo.matrix;

  var _b = getSize(target, undefined, true),
      width = _b[0],
      height = _b[1];

  var containerClientRect = container.getBoundingClientRect();
  var margin = [0, 0];

  if (container === document.body) {
    margin = getBodyOffset(target, true);
  }

  var rect = target.getBoundingClientRect();
  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];
  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  var mat = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiplies)(n, beforeMatrix, targetMatrix);

  var _c = calculateRect(mat, width, height, n),
      prevLeft = _c.left,
      prevTop = _c.top,
      prevWidth = _c.width,
      prevHeight = _c.height;

  var posOrigin = calculatePosition(mat, origin, n);
  var prevOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(posOrigin, [prevLeft, prevTop]);
  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];
  var offset = [0, 0];
  var count = 0;

  while (++count < 10) {
    var inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(beforeMatrix, n);
    _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a[0], offset[1] = _a[1];
    var mat2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiplies)(n, beforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createOriginMatrix)(offset, n), targetMatrix);

    var _d = calculateRect(mat2, width, height, n),
        nextLeft = _d.left,
        nextTop = _d.top;

    var distLeft = nextLeft - rectLeft;
    var distTop = nextTop - rectTop;

    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {
      break;
    }

    rectOrigin[0] -= distLeft;
    rectOrigin[1] -= distTop;
  }

  return offset.map(function (p) {
    return Math.round(p);
  });
}
function calculateMoveablePosition(matrix, origin, width, height) {
  var is3d = matrix.length === 16;
  var n = is3d ? 4 : 3;
  var poses = calculatePoses(matrix, width, height, n);
  var _a = poses[0],
      x1 = _a[0],
      y1 = _a[1],
      _b = poses[1],
      x2 = _b[0],
      y2 = _b[1],
      _c = poses[2],
      x3 = _c[0],
      y3 = _c[1],
      _d = poses[3],
      x4 = _d[0],
      y4 = _d[1];

  var _e = calculatePosition(matrix, origin, n),
      originX = _e[0],
      originY = _e[1];

  var left = Math.min(x1, x2, x3, x4);
  var top = Math.min(y1, y2, y3, y4);
  var right = Math.max(x1, x2, x3, x4);
  var bottom = Math.max(y1, y2, y3, y4);
  x1 = x1 - left || 0;
  x2 = x2 - left || 0;
  x3 = x3 - left || 0;
  x4 = x4 - left || 0;
  y1 = y1 - top || 0;
  y2 = y2 - top || 0;
  y3 = y3 - top || 0;
  y4 = y4 - top || 0;
  originX = originX - left || 0;
  originY = originY - top || 0;
  var direction = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getShapeDirection)(poses);
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    origin: [originX, originY],
    pos1: [x1, y1],
    pos2: [x2, y2],
    pos3: [x3, y3],
    pos4: [x4, y4],
    direction: direction
  };
}
function getDistSize(vec) {
  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
}
function getDiagonalSize(pos1, pos2) {
  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);
}
function getLineStyle(pos1, pos2, zoom, rad) {
  if (zoom === void 0) {
    zoom = 1;
  }

  if (rad === void 0) {
    rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos2);
  }

  var width = getDiagonalSize(pos1, pos2);
  return {
    transform: "translateY(-50%) translate(" + pos1[0] + "px, " + pos1[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")",
    width: width + "px"
  };
}
function getControlTransform(rotation, zoom) {
  var poses = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    poses[_i - 2] = arguments[_i];
  }

  var length = poses.length;
  var x = poses.reduce(function (prev, pos) {
    return prev + pos[0];
  }, 0) / length;
  var y = poses.reduce(function (prev, pos) {
    return prev + pos[1];
  }, 0) / length;
  return {
    transform: "translateZ(0px) translate(" + x + "px, " + y + "px) rotate(" + rotation + "rad) scale(" + zoom + ")"
  };
}
function getCSSSize(target) {
  var style = getComputedStyle(target);
  return [parseFloat(style.width), parseFloat(style.height)];
}
function getSize(target, style, isOffset, isBoxSizing) {
  if (style === void 0) {
    style = getComputedStyle(target);
  }

  if (isBoxSizing === void 0) {
    isBoxSizing = isOffset || style.boxSizing === "border-box";
  }

  var width = target.offsetWidth;
  var height = target.offsetHeight;
  var hasOffset = !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(width);

  if ((isOffset || isBoxSizing) && hasOffset) {
    return [width, height];
  }

  if (!hasOffset && target.tagName.toLowerCase() !== "svg") {
    var bbox = target.getBBox();
    return [bbox.width, bbox.height];
  }

  width = target.clientWidth;
  height = target.clientHeight;

  if (isOffset || isBoxSizing) {
    var borderLeft = parseFloat(style.borderLeftWidth) || 0;
    var borderRight = parseFloat(style.borderRightWidth) || 0;
    var borderTop = parseFloat(style.borderTopWidth) || 0;
    var borderBottom = parseFloat(style.borderBottomWidth) || 0;
    return [width + borderLeft + borderRight, height + borderTop + borderBottom];
  } else {
    var paddingLeft = parseFloat(style.paddingLeft) || 0;
    var paddingRight = parseFloat(style.paddingRight) || 0;
    var paddingTop = parseFloat(style.paddingTop) || 0;
    var paddingBottom = parseFloat(style.paddingBottom) || 0;
    return [width - paddingLeft - paddingRight, height - paddingTop - paddingBottom];
  }
}
function getRotationRad(poses, direction) {
  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);
}
function getTargetInfo(moveableElement, target, container, parentContainer, rootContainer) {
  var beforeDirection = 1;
  var beforeOrigin = [0, 0];
  var targetClientRect = resetClientRect();
  var containerClientRect = resetClientRect();
  var moveableClientRect = resetClientRect();
  var result = calculateElementInfo(target, container, rootContainer, false);

  if (target) {
    var n = result.is3d ? 4 : 3;
    var beforePosition = calculateMoveablePosition(result.offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(result.transformOrigin, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.getOrigin)(result.targetMatrix, n)), result.width, result.height);
    beforeDirection = beforePosition.direction;
    beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);
    targetClientRect = getClientRect(target);
    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);

    if (moveableElement) {
      moveableClientRect = getClientRect(moveableElement);
    }
  }

  return __assign({
    targetClientRect: targetClientRect,
    containerClientRect: containerClientRect,
    moveableClientRect: moveableClientRect,
    beforeDirection: beforeDirection,
    beforeOrigin: beforeOrigin,
    originalBeforeOrigin: beforeOrigin,
    target: target
  }, result);
}
function resetClientRect() {
  return {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    width: 0,
    height: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function getClientRect(el, isExtends) {
  var left = 0;
  var top = 0;
  var width = 0;
  var height = 0;

  if (el === document.body || el === document.documentElement) {
    width = window.innerWidth;
    height = window.innerHeight;
    left = -(document.documentElement.scrollLeft || document.body.scrollLeft);
    top = -(document.documentElement.scrollTop || document.body.scrollTop);
  } else {
    var clientRect = el.getBoundingClientRect();
    left = clientRect.left;
    top = clientRect.top;
    width = clientRect.width;
    height = clientRect.height;
  }

  var rect = {
    left: left,
    right: left + width,
    top: top,
    bottom: top + height,
    width: width,
    height: height
  };

  if (isExtends) {
    rect.clientLeft = el.clientLeft;
    rect.clientTop = el.clientTop;
    rect.clientWidth = el.clientWidth;
    rect.clientHeight = el.clientHeight;
    rect.scrollWidth = el.scrollWidth;
    rect.scrollHeight = el.scrollHeight;
    rect.overflow = getComputedStyle(el).overflow !== "visible";
  }

  return rect;
}
function getDirection(target) {
  if (!target) {
    return;
  }

  var direciton = target.getAttribute("data-direction");

  if (!direciton) {
    return;
  }

  var dir = [0, 0];
  direciton.indexOf("w") > -1 && (dir[0] = -1);
  direciton.indexOf("e") > -1 && (dir[0] = 1);
  direciton.indexOf("n") > -1 && (dir[1] = -1);
  direciton.indexOf("s") > -1 && (dir[1] = 1);
  return dir;
}
function getAbsolutePoses(poses, dist) {
  return [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(dist, poses[0]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(dist, poses[1]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(dist, poses[2]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(dist, poses[3])];
}
function getAbsolutePosesByState(_a) {
  var left = _a.left,
      top = _a.top,
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;
  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);
}
function roundSign(num) {
  return Math.round(num % 1 === -0.5 ? num - 1 : num);
}
function unset(self, name) {
  var _a;

  (_a = self[name]) === null || _a === void 0 ? void 0 : _a.unset();
  self[name] = null;
}
function fillParams(moveable, e, params) {
  var datas = e.datas;

  if (!datas.datas) {
    datas.datas = {};
  }

  var nextParams = __assign(__assign({}, params), {
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    moveable: moveable,
    datas: datas.datas
  });

  if (datas.isStartEvent) {
    datas.lastEvent = nextParams;
  } else {
    datas.isStartEvent = true;
  }

  return nextParams;
}
function fillEndParams(moveable, e, params) {
  var datas = e.datas;
  var isDrag = "isDrag" in params ? params.isDrag : e.isDrag;

  if (!datas.datas) {
    datas.datas = {};
  }

  return __assign(__assign({
    isDrag: isDrag
  }, params), {
    moveable: moveable,
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    lastEvent: datas.lastEvent,
    isDouble: e.isDouble,
    datas: datas.datas
  });
}
function triggerEvent(moveable, name, params, isManager) {
  return moveable.triggerEvent(name, params, isManager);
}
function getComputedStyle(el, pseudoElt) {
  return window.getComputedStyle(el, pseudoElt);
}
function filterAbles(ables, methods, triggerAblesSimultaneously) {
  var enabledAbles = {};
  var ableGroups = {};
  return ables.filter(function (able) {
    var name = able.name;

    if (enabledAbles[name] || !methods.some(function (method) {
      return able[method];
    })) {
      return false;
    }

    if (!triggerAblesSimultaneously && able.ableGroup) {
      if (ableGroups[able.ableGroup]) {
        return false;
      }

      ableGroups[able.ableGroup] = true;
    }

    enabledAbles[name] = true;
    return true;
  });
}
function equals(a1, a2) {
  return a1 === a2 || a1 == null && a2 == null;
}
function selectValue() {
  var values = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }

  var length = values.length - 1;

  for (var i = 0; i < length; ++i) {
    var value = values[i];

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(value)) {
      return value;
    }
  }

  return values[length];
}
function groupBy(arr, func) {
  var groups = [];
  var groupKeys = [];
  arr.forEach(function (el, index) {
    var groupKey = func(el, index, arr);
    var keyIndex = groupKeys.indexOf(groupKey);
    var group = groups[keyIndex] || [];

    if (keyIndex === -1) {
      groupKeys.push(groupKey);
      groups.push(group);
    }

    group.push(el);
  });
  return groups;
}
function groupByMap(arr, func) {
  var groups = [];
  var groupKeys = {};
  arr.forEach(function (el, index) {
    var groupKey = func(el, index, arr);
    var group = groupKeys[groupKey];

    if (!group) {
      group = [];
      groupKeys[groupKey] = group;
      groups.push(group);
    }

    group.push(el);
  });
  return groups;
}
function flat(arr) {
  return arr.reduce(function (prev, cur) {
    return prev.concat(cur);
  }, []);
}
function maxOffset() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  args.sort(function (a, b) {
    return Math.abs(b) - Math.abs(a);
  });
  return args[0];
}
function calculateInversePosition(matrix, pos, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(matrix, n), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertPositionMatrix)(pos, n), n);
}
function convertDragDist(state, e) {
  var _a;

  var is3d = state.is3d,
      rootMatrix = state.rootMatrix;
  var n = is3d ? 4 : 3;
  _a = calculateInversePosition(rootMatrix, [e.distX, e.distY], n), e.distX = _a[0], e.distY = _a[1];
  return e;
}
function calculatePadding(matrix, pos, transformOrigin, origin, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(transformOrigin, pos), n), origin);
}
function convertCSSSize(value, size, isRelative) {
  return isRelative ? value / size * 100 + "%" : value + "px";
}
function moveControlPos(controlPoses, index, dist, isRect) {
  var _a = controlPoses[index],
      direction = _a.direction,
      sub = _a.sub;
  var dists = controlPoses.map(function () {
    return [0, 0];
  });
  var directions = direction ? direction.split("") : [];

  if (isRect && index < 8) {
    var verticalDirection_1 = directions.filter(function (dir) {
      return dir === "w" || dir === "e";
    })[0];
    var horizontalDirection_1 = directions.filter(function (dir) {
      return dir === "n" || dir === "s";
    })[0];
    dists[index] = dist;
    controlPoses.forEach(function (controlPose, i) {
      var controlDir = controlPose.direction;

      if (!controlDir) {
        return;
      }

      if (controlDir.indexOf(verticalDirection_1) > -1) {
        dists[i][0] = dist[0];
      }

      if (controlDir.indexOf(horizontalDirection_1) > -1) {
        dists[i][1] = dist[1];
      }
    });

    if (verticalDirection_1) {
      dists[1][0] = dist[0] / 2;
      dists[5][0] = dist[0] / 2;
    }

    if (horizontalDirection_1) {
      dists[3][1] = dist[1] / 2;
      dists[7][1] = dist[1] / 2;
    }
  } else if (direction && !sub) {
    directions.forEach(function (dir) {
      var isVertical = dir === "n" || dir === "s";
      controlPoses.forEach(function (controlPose, i) {
        var dirDir = controlPose.direction,
            dirHorizontal = controlPose.horizontal,
            dirVertical = controlPose.vertical;

        if (!dirDir || dirDir.indexOf(dir) === -1) {
          return;
        }

        dists[i] = [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]];
      });
    });
  } else {
    dists[index] = dist;
  }

  return dists;
}
function getTinyDist(v) {
  return Math.abs(v) <= TINY_NUM ? 0 : v;
}
function directionCondition(moveable, e) {
  if (e.isRequest) {
    if (e.requestAble === "resizable" || e.requestAble === "scalable") {
      return e.parentDirection;
    } else {
      return false;
    }
  }

  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(e.inputEvent.target, prefix("direction"));
}
function invertObject(obj) {
  var nextObj = {};

  for (var name in obj) {
    nextObj[obj[name]] = name;
  }

  return nextObj;
}
function getTransform(transforms, index) {
  var beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);
  var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);
  var targetFunctionText = transforms[index] || "";
  var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);
  var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);
  var beforeFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(beforeFunctionTexts);
  var beforeFunctions2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(beforeFunctionTexts2);
  var targetFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)([targetFunctionText]);
  var afterFunctions = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(afterFunctionTexts);
  var afterFunctions2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(afterFunctionTexts2);
  var beforeFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(beforeFunctions);
  var beforeFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(beforeFunctions2);
  var afterFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(afterFunctions);
  var afterFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(afterFunctions2);
  var allFunctionMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(beforeFunctionMatrix, afterFunctionMatrix, 4);
  return {
    transforms: transforms,
    beforeFunctionMatrix: beforeFunctionMatrix,
    beforeFunctionMatrix2: beforeFunctionMatrix2,
    targetFunctionMatrix: (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(targetFunctions),
    afterFunctionMatrix: afterFunctionMatrix,
    afterFunctionMatrix2: afterFunctionMatrix2,
    allFunctionMatrix: allFunctionMatrix,
    beforeFunctions: beforeFunctions,
    beforeFunctions2: beforeFunctions2,
    targetFunction: targetFunctions[0],
    afterFunctions: afterFunctions,
    afterFunctions2: afterFunctions2,
    beforeFunctionTexts: beforeFunctionTexts,
    beforeFunctionTexts2: beforeFunctionTexts2,
    targetFunctionText: targetFunctionText,
    afterFunctionTexts: afterFunctionTexts,
    afterFunctionTexts2: afterFunctionTexts2
  };
}
function isArrayFormat(arr) {
  if (!arr || !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(arr)) {
    return false;
  }

  return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(arr) || "length" in arr;
}
function getRefTarget(target, isSelector) {
  if (!target) {
    return null;
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(target)) {
    if (isSelector) {
      return document.querySelector(target);
    }

    return target;
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(target)) {
    return target();
  }

  if ("current" in target) {
    return target.current;
  }

  return target;
}
function getRefTargets(targets, isSelector) {
  if (!targets) {
    return [];
  }

  var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];
  return userTargets.reduce(function (prev, target) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(target) && isSelector) {
      return __spreadArray(__spreadArray([], prev), [].slice.call(document.querySelectorAll(target)));
    }

    prev.push(getRefTarget(target, isSelector));
    return prev;
  }, []);
}
function getElementTargets(targets, selectorMap) {
  var elementTargets = [];
  targets.forEach(function (target) {
    if (!target) {
      return;
    }

    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(target)) {
      if (selectorMap[target]) {
        elementTargets.push.apply(elementTargets, selectorMap[target]);
      }

      return;
    }

    elementTargets.push(target);
  });
  return elementTargets;
}
function getAbsoluteRotation(pos1, pos2, direction) {
  var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos2) / Math.PI * 180;
  deg = direction >= 0 ? deg : 180 - deg;
  deg = deg >= 0 ? deg : 360 + deg;
  return deg;
}
function getDragDistByState(state, dist) {
  var rootMatrix = state.rootMatrix,
      is3d = state.is3d;
  var n = is3d ? 4 : 3;
  var inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(rootMatrix, n);

  if (!is3d) {
    inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(inverseMatrix, 3, 4);
  }

  inverseMatrix[12] = 0;
  inverseMatrix[13] = 0;
  inverseMatrix[14] = 0;
  return (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(inverseMatrix, dist);
}

/**
 * @namespace Moveable.Pinchable
 * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)
 */

var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function () {
    return true;
  },
  pinchStart: function (moveable, e) {
    var datas = e.datas,
        targets = e.targets,
        angle = e.angle,
        originalDatas = e.originalDatas;
    var _a = moveable.props,
        pinchable = _a.pinchable,
        ables = _a.ables;

    if (!pinchable) {
      return false;
    }

    var eventName = "onPinch" + (targets ? "Group" : "") + "Start";
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlStart";
    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {
      return pinchable.indexOf(able.name) > -1;
    })).filter(function (able) {
      return able.canPinch && able[controlEventName];
    });
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var result = triggerEvent(moveable, eventName, params);
    datas.isPinch = result !== false;
    datas.ables = pinchAbles;
    var isPinch = datas.isPinch;

    if (!isPinch) {
      return false;
    }

    pinchAbles.forEach(function (able) {
      originalDatas[able.name] = originalDatas[able.name] || {};

      if (!able[controlEventName]) {
        return;
      }

      var ableEvent = __assign(__assign({}, e), {
        datas: originalDatas[able.name],
        parentRotate: angle,
        isPinch: true
      });

      able[controlEventName](moveable, ableEvent);
    });
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      direction: [0, 0]
    };
    return isPinch;
  },
  pinch: function (moveable, e) {
    var datas = e.datas,
        pinchScale = e.scale,
        distance = e.distance,
        originalDatas = e.originalDatas,
        inputEvent = e.inputEvent,
        targets = e.targets,
        angle = e.angle;

    if (!datas.isPinch) {
      return;
    }

    var parentDistance = distance * (1 - 1 / pinchScale);
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var eventName = "onPinch" + (targets ? "Group" : "");
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "Control";
    ables.forEach(function (able) {
      if (!able[controlEventName]) {
        return;
      }

      able[controlEventName](moveable, __assign(__assign({}, e), {
        datas: originalDatas[able.name],
        inputEvent: inputEvent,
        parentDistance: parentDistance,
        parentRotate: angle,
        isPinch: true
      }));
    });
    return params;
  },
  pinchEnd: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        targets = e.targets,
        originalDatas = e.originalDatas;

    if (!datas.isPinch) {
      return;
    }

    var eventName = "onPinch" + (targets ? "Group" : "") + "End";
    var params = fillEndParams(moveable, e, {
      isDrag: isPinch
    });

    if (targets) {
      params.targets = targets;
    }

    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlEnd";
    ables.forEach(function (able) {
      if (!able[controlEventName]) {
        return;
      }

      able[controlEventName](moveable, __assign(__assign({}, e), {
        isDrag: isPinch,
        datas: originalDatas[able.name],
        inputEvent: inputEvent,
        isPinch: true
      }));
    });
    return isPinch;
  },
  pinchGroupStart: function (moveable, e) {
    return this.pinchStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroup: function (moveable, e) {
    return this.pinch(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroupEnd: function (moveable, e) {
    return this.pinchEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  }
});
/**
 * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)
 * @name Moveable.Pinchable#pinchable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.pinchable = true;
 */

/**
 * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart
 * @memberof Moveable.Pinchable
 * @event pinchStart
 * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinchStart", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotateStart", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scaleStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When pinching, the pinch event is called with part of scale, rotate, resize
 * @memberof Moveable.Pinchable
 * @event pinch
 * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinch", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotate", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scale", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When the pinch finishes, the pinchEnd event is called.
 * @memberof Moveable.Pinchable
 * @event pinchEnd
 * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     rotatable: true,
 *     scalable: true,
 *     pinchable: true, // ["rotatable", "scalable"]
 * });
 * moveable.on("pinchEnd", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("rotateEnd", ({ target }) => {
 *     console.log(target);
 * });
 * moveable.on("scaleEnd", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When the group pinch starts, the `pinchGroupStart` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroupStart
 * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroupStart", ({ targets }) => {
 *     console.log("onPinchGroupStart", targets);
 * });
 */

/**
 * When the group pinch, the `pinchGroup` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroup
 * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroup", ({ targets, events }) => {
 *     console.log("onPinchGroup", targets);
 * });
 */

/**
 * When the group pinch finishes, the `pinchGroupEnd` event is called.
 * @memberof Moveable.Pinchable
 * @event pinchGroupEnd
 * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     pinchable: true
 * });
 * moveable.on("pinchGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onPinchGroupEnd", targets, isDrag);
 * });
 */

function setCustomDrag(e, state, delta, isPinch, isConvert) {
  var result = state.gesto.move(delta, e.inputEvent);
  var datas = result.originalDatas || result.datas;
  var draggableDatas = datas.draggable || (datas.draggable = {});
  return __assign(__assign({}, isConvert ? convertDragDist(state, result) : result), {
    isDrag: true,
    isPinch: !!isPinch,
    parentEvent: true,
    datas: draggableDatas,
    originalDatas: e.originalDatas
  });
}

var CustomGesto =
/*#__PURE__*/
function () {
  function CustomGesto() {
    this.prevX = 0;
    this.prevY = 0;
    this.startX = 0;
    this.startY = 0;
    this.isDrag = false;
    this.isFlag = false;
    this.datas = {
      draggable: {}
    };
  }

  var __proto = CustomGesto.prototype;

  __proto.dragStart = function (client, e) {
    this.isDrag = false;
    this.isFlag = false;
    var originalDatas = e.originalDatas;
    this.datas = originalDatas;

    if (!originalDatas.draggable) {
      originalDatas.draggable = {};
    }

    return __assign(__assign({}, this.move(client, e.inputEvent)), {
      type: "dragstart"
    });
  };

  __proto.drag = function (client, inputEvent) {
    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);
  };

  __proto.move = function (delta, inputEvent) {
    var clientX;
    var clientY;

    if (!this.isFlag) {
      this.prevX = delta[0];
      this.prevY = delta[1];
      this.startX = delta[0];
      this.startY = delta[1];
      clientX = delta[0];
      clientY = delta[1];
      this.isFlag = true;
    } else {
      clientX = this.prevX + delta[0];
      clientY = this.prevY + delta[1];
      this.isDrag = true;
    }

    this.prevX = clientX;
    this.prevY = clientY;
    return {
      type: "drag",
      clientX: clientX,
      clientY: clientY,
      inputEvent: inputEvent,
      isDrag: this.isDrag,
      distX: clientX - this.startX,
      distY: clientY - this.startY,
      deltaX: delta[0],
      deltaY: delta[1],
      datas: this.datas.draggable,
      originalDatas: this.datas,
      parentEvent: true,
      parentGesto: this
    };
  };

  return CustomGesto;
}();

function fillChildEvents(moveable, name, e) {
  var datas = e.originalDatas;
  datas.groupable = datas.groupable || {};
  var groupableDatas = datas.groupable;
  groupableDatas.childDatas = groupableDatas.childDatas || [];
  var childDatas = groupableDatas.childDatas;
  return moveable.moveables.map(function (_, i) {
    childDatas[i] = childDatas[i] || {};
    childDatas[i][name] = childDatas[i][name] || {};
    return __assign(__assign({}, e), {
      datas: childDatas[i][name],
      originalDatas: childDatas[i]
    });
  });
}
function triggerChildGesto(moveable, able, type, delta, e, isConvert) {
  var isStart = !!type.match(/Start$/g);
  var isEnd = !!type.match(/End$/g);
  var isPinch = e.isPinch;
  var datas = e.datas;
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function (ev, i) {
    var childMoveable = moveables[i];
    var childEvent = ev;

    if (isStart) {
      childEvent = new CustomGesto().dragStart(delta, ev);
    } else {
      if (!childMoveable.state.gesto) {
        childMoveable.state.gesto = datas.childGestos[i];
      }

      childEvent = setCustomDrag(ev, childMoveable.state, delta, isPinch, isConvert);
    }

    var result = able[type](childMoveable, __assign(__assign({}, childEvent), {
      parentFlag: true
    }));

    if (isEnd) {
      childMoveable.state.gesto = null;
    }

    return result;
  });

  if (isStart) {
    datas.childGestos = moveables.map(function (child) {
      return child.state.gesto;
    });
  }

  return childs;
}
function triggerChildAbles(moveable, able, type, e, eachEvent, callback) {
  if (eachEvent === void 0) {
    eachEvent = function (_, ev) {
      return ev;
    };
  }

  var isEnd = !!type.match(/End$/g);
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function (ev, i) {
    var childMoveable = moveables[i];
    var childEvent = ev;
    childEvent = eachEvent(childMoveable, ev);
    var result = able[type](childMoveable, __assign(__assign({}, childEvent), {
      parentFlag: true
    }));
    result && callback && callback(childMoveable, ev, result, i);

    if (isEnd) {
      childMoveable.state.gesto = null;
    }

    return result;
  });
  return childs;
}

function calculatePointerDist(moveable, e) {
  var clientX = e.clientX,
      clientY = e.clientY,
      datas = e.datas;
  var _a = moveable.state,
      moveableClientRect = _a.moveableClientRect,
      rootMatrix = _a.rootMatrix,
      is3d = _a.is3d,
      pos1 = _a.pos1;
  var left = moveableClientRect.left,
      top = moveableClientRect.top;
  var n = is3d ? 4 : 3;

  var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1),
      posX = _b[0],
      posY = _b[1];

  var _c = getDragDist({
    datas: datas,
    distX: posX,
    distY: posY
  }),
      distX = _c[0],
      distY = _c[1];

  return [distX, distY];
}
function setDragStart(moveable, _a) {
  var datas = _a.datas;
  var _b = moveable.state,
      allMatrix = _b.allMatrix,
      beforeMatrix = _b.beforeMatrix,
      is3d = _b.is3d,
      left = _b.left,
      top = _b.top,
      origin = _b.origin,
      offsetMatrix = _b.offsetMatrix,
      targetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin;
  var n = is3d ? 4 : 3;
  datas.is3d = is3d;
  datas.matrix = allMatrix;
  datas.targetMatrix = targetMatrix;
  datas.beforeMatrix = beforeMatrix;
  datas.offsetMatrix = offsetMatrix;
  datas.transformOrigin = transformOrigin;
  datas.inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(allMatrix, n);
  datas.inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(beforeMatrix, n);
  datas.absoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertPositionMatrix)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)([left, top], origin), n);
  datas.startDragBeforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);
  datas.startDragDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(datas.inverseMatrix, datas.absoluteOrigin, n);
}
function getTransformDirection(e) {
  return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function resolveTransformEvent(event, functionName) {
  var datas = event.datas,
      originalDatas = event.originalDatas.beforeRenderable;
  var index = datas.transformIndex;
  var nextTransforms = originalDatas.nextTransforms;
  var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;
  var nextIndex = 0;

  if (index === -1) {
    nextIndex = nextTransforms.length;
    datas.transformIndex = nextIndex;
  } else {
    nextIndex = index + nextTransformAppendedIndexes.filter(function (i) {
      return i < index;
    }).length;
  }

  var result = getTransform(nextTransforms, nextIndex);
  var targetFunction = result.targetFunction;
  var matFunctionName = functionName === "rotate" ? "rotateZ" : functionName;
  datas.beforeFunctionTexts = result.beforeFunctionTexts;
  datas.afterFunctionTexts = result.afterFunctionTexts;
  datas.beforeTransform = result.beforeFunctionMatrix;
  datas.beforeTransform2 = result.beforeFunctionMatrix2;
  datas.targetTansform = result.targetFunctionMatrix;
  datas.afterTransform = result.afterFunctionMatrix;
  datas.afterTransform2 = result.afterFunctionMatrix2;
  datas.targetAllTransform = result.allFunctionMatrix;

  if (targetFunction.functionName === matFunctionName) {
    datas.afterFunctionTexts.splice(0, 1);
    datas.isAppendTransform = false;
  } else {
    datas.isAppendTransform = true;
    originalDatas.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], nextTransformAppendedIndexes), [nextIndex]);
  }
}
function convertTransformFormat(datas, value, dist) {
  return datas.beforeFunctionTexts.join(" ") + " " + (datas.isAppendTransform ? dist : value) + " " + datas.afterFunctionTexts.join(" ");
}
function getTransformDist(_a) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;

  var _b = getBeforeDragDist({
    datas: datas,
    distX: distX,
    distY: distY
  }),
      bx = _b[0],
      by = _b[1]; // B * [tx, ty] * A = [bx, by] * targetMatrix;
  // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];


  var res = getTransfromMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.fromTranslation)([bx, by], 4));
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(res, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertPositionMatrix)([0, 0, 0], 4), 4);
}
function getTransfromMatrix(datas, targetMatrix, isAfter) {
  var beforeTransform = datas.beforeTransform,
      afterTransform = datas.afterTransform,
      beforeTransform2 = datas.beforeTransform2,
      afterTransform2 = datas.afterTransform2,
      targetAllTransform = datas.targetAllTransform; // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)
  // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1
  // nextTargetMatrix = (targetMatrix * targetAllTransform)

  var nextTargetMatrix = isAfter ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(targetAllTransform, targetMatrix, 4) : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(targetMatrix, targetAllTransform, 4); // res1 = B-1 * nextTargetMatrix

  var res1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4); // res3 = res2 * A-1

  var afterTargetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(res1, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(isAfter ? afterTransform2 : afterTransform, 4), 4);
  return afterTargetMatrix;
}
function getBeforeDragDist(_a) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY; // TT = BT

  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3; // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])
  // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]

  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(inverseBeforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);
}
function getDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      inverseMatrix = datas.inverseMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(isBefore ? inverseBeforeMatrix : inverseMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);
}
function getInverseDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var beforeMatrix = datas.beforeMatrix,
      matrix = datas.matrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(isBefore ? beforeMatrix : matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);
}
function calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {
  if (prevWidth === void 0) {
    prevWidth = width;
  }

  if (prevHeight === void 0) {
    prevHeight = height;
  }

  if (prevOrigin === void 0) {
    prevOrigin = [0, 0];
  }

  if (!transformOrigin) {
    return prevOrigin;
  }

  return transformOrigin.map(function (pos, i) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitUnit)(pos),
        value = _a.value,
        unit = _a.unit;

    var prevSize = i ? prevHeight : prevWidth;
    var size = i ? height : width;

    if (pos === "%" || isNaN(value)) {
      // no value but %
      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;
      return size * measureRatio;
    } else if (unit !== "%") {
      return value;
    }

    return size * value / 100;
  });
}
function getPosIndexesByDirection(direction) {
  var indexes = [];

  if (direction[1] >= 0) {
    if (direction[0] >= 0) {
      indexes.push(3);
    }

    if (direction[0] <= 0) {
      indexes.push(2);
    }
  }

  if (direction[1] <= 0) {
    if (direction[0] >= 0) {
      indexes.push(1);
    }

    if (direction[0] <= 0) {
      indexes.push(0);
    }
  }

  return indexes;
}
function getPosesByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  return getPosIndexesByDirection(direction).map(function (index) {
    return poses[index];
  });
}
function getPosByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  var nextPoses = getPosesByDirection(poses, direction);
  return [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.average)(nextPoses.map(function (pos) {
    return pos[0];
  })), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.average)(nextPoses.map(function (pos) {
    return pos[1];
  }))];
}
function getPosByReverseDirection(poses, direction) {
  /*
  [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)
  [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)
  [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)
  */
  return getPosByDirection(poses, direction.map(function (dir) {
    return -dir;
  }));
}

function getDist(startPos, matrix, width, height, n, fixedDirection) {
  var poses = calculatePoses(matrix, width, height, n);
  var fixedPos = getPosByDirection(poses, fixedDirection);
  var distX = startPos[0] - fixedPos[0];
  var distY = startPos[1] - fixedPos[1];
  return [distX, distY];
}

function getNextMatrix(offsetMatrix, targetMatrix, origin, n) {
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);
}
function getNextTransformMatrix(state, datas, transform) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d;
  var beforeTransform = datas.beforeTransform,
      afterTransform = datas.afterTransform;
  var n = is3d ? 4 : 3;
  var targetTransform = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)([transform]);
  return getNextMatrix(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(beforeTransform, targetTransform, 4), afterTransform, 4), 4, n), transformOrigin, n);
}
function scaleMatrix(state, scale) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d,
      targetMatrix = state.targetMatrix;
  var n = is3d ? 4 : 3;
  return getNextMatrix(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(targetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createScaleMatrix)(scale, n), n), transformOrigin, n);
}
function fillTransformStartEvent(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return {
    setTransform: function (transform, index) {
      if (index === void 0) {
        index = -1;
      }

      originalDatas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(transform);
      setTransformIndex(e, index);
    },
    setTransformIndex: function (index) {
      setTransformIndex(e, index);
    }
  };
}
function setDefaultTransformIndex(e, property) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var startTransforms = originalDatas.startTransforms;
  setTransformIndex(e, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.findIndex)(startTransforms, function (func) {
    return func.indexOf(property + "(") === 0;
  }));
}
function setTransformIndex(e, index) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var datas = e.datas;
  datas.transformIndex = index;

  if (index === -1) {
    return;
  }

  var transform = originalDatas.startTransforms[index];

  if (!transform) {
    return;
  }

  var info = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)([transform]);
  datas.startValue = info[0].functionValue;
}
function fillOriginalTransform(e, transform) {
  var originalDatas = e.originalDatas.beforeRenderable;
  originalDatas.nextTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(transform);
}
function getNextTransformText(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return originalDatas.nextTransforms.join(" ");
}
function fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {
  fillOriginalTransform(e, nextTransform);
  return {
    transform: nextTransform,
    drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false))
  };
}
function getTranslateDist(moveable, transform, fixedDirection, fixedPosition, datas) {
  var state = moveable.state;
  var left = state.left,
      top = state.top;
  var groupable = moveable.props.groupable;
  var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);
  var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(fixedPosition, nextFixedPosition);
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, [groupLeft, groupTop]);
}
function getScaleDist(moveable, scaleDist, fixedDirection, fixedPosition, datas) {
  return getTranslateDist(moveable, "scale(" + scaleDist.join(", ") + ")", fixedDirection, fixedPosition, datas);
}
function getOriginDirection(moveable) {
  var _a = moveable.state,
      width = _a.width,
      height = _a.height,
      transformOrigin = _a.transformOrigin;
  return [-1 + transformOrigin[0] / (width / 2), -1 + transformOrigin[1] / (height / 2)];
}
function getDirectionOffset(moveable, direction, nextMatrix) {
  if (nextMatrix === void 0) {
    nextMatrix = moveable.state.allMatrix;
  }

  var _a = moveable.state,
      width = _a.width,
      height = _a.height,
      is3d = _a.is3d;
  var n = is3d ? 4 : 3;
  var nextFixedOffset = [width / 2 * (1 + direction[0]), height / 2 * (1 + direction[1])];
  return calculatePosition(nextMatrix, nextFixedOffset, n);
}
function getRotateDist(moveable, rotateDist, fixedPosition, datas) {
  var fixedDirection = getOriginDirection(moveable);
  return getTranslateDist(moveable, "rotate(" + rotateDist + "deg)", fixedDirection, fixedPosition, datas);
}
function getResizeDist(moveable, width, height, fixedDirection, fixedPosition, transformOrigin) {
  var groupable = moveable.props.groupable;
  var _a = moveable.state,
      prevOrigin = _a.transformOrigin,
      targetMatrix = _a.targetMatrix,
      offsetMatrix = _a.offsetMatrix,
      is3d = _a.is3d,
      prevWidth = _a.width,
      prevHeight = _a.height,
      left = _a.left,
      top = _a.top;
  var n = is3d ? 4 : 3;
  var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);
  var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);
  return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, [groupLeft, groupTop]);
}
function getAbsolutePosition(moveable, direction) {
  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);
}

var VERTICAL_NAMES = ["left", "right", "center"];
var HORIZONTAL_NAMES = ["top", "bottom", "middle"];
var VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
};
var HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function hasGuidelines(moveable, ableName) {
  var _a = moveable.props,
      snappable = _a.snappable,
      bounds = _a.bounds,
      innerBounds = _a.innerBounds,
      verticalGuidelines = _a.verticalGuidelines,
      horizontalGuidelines = _a.horizontalGuidelines,
      snapGridWidth = _a.snapGridWidth,
      snapGridHeight = _a.snapGridHeight,
      _b = moveable.state,
      guidelines = _b.guidelines,
      enableSnap = _b.enableSnap;

  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {
    return false;
  }

  if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {
    return true;
  }

  return false;
}
function getSnapDirections(snapDirections) {
  if (snapDirections === false) {
    return {};
  } else if (snapDirections === true || !snapDirections) {
    return {
      left: true,
      right: true,
      top: true,
      bottom: true
    };
  }

  return snapDirections;
}
function mapSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapDirections = getSnapDirections(snapDirections);
  var nextSnapPoses = {};

  for (var name in nextSnapDirections) {
    if (name in snapPoses && nextSnapDirections[name]) {
      nextSnapPoses[name] = snapPoses[name];
    }
  }

  return nextSnapPoses;
}
function splitSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);
  var horizontalNames = HORIZONTAL_NAMES.filter(function (name) {
    return name in nextSnapPoses;
  });
  var verticalNames = VERTICAL_NAMES.filter(function (name) {
    return name in nextSnapPoses;
  });
  return {
    horizontal: horizontalNames.map(function (name) {
      return nextSnapPoses[name];
    }),
    vertical: verticalNames.map(function (name) {
      return nextSnapPoses[name];
    })
  };
}
function getGapGuidelines(moveable, targetRect, snapThreshold) {
  var elementRects = moveable.state.elementRects;
  var gapGuidelines = [];
  [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function (_a) {
    var type = _a[0],
        mainNames = _a[1],
        sideNames = _a[2];
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetCenter = targetRect[mainNames.center];
    var targetStart2 = targetRect[sideNames.start];
    var targetEnd2 = targetRect[sideNames.end]; // element : moveable

    function getDist(elementRect) {
      var rect = elementRect.rect;

      if (rect[mainNames.end] < targetStart + snapThreshold) {
        return targetStart - rect[mainNames.end];
      } else if (targetEnd - snapThreshold < rect[mainNames.start]) {
        return rect[mainNames.start] - targetEnd;
      } else {
        return -1;
      }
    }

    var nextElementRects = elementRects.filter(function (elementRect) {
      var rect = elementRect.rect;

      if (rect[sideNames.start] > targetEnd2 || rect[sideNames.end] < targetStart2) {
        return false;
      }

      return getDist(elementRect) > 0;
    }).sort(function (a, b) {
      return getDist(a) - getDist(b);
    });
    var groups = [];
    nextElementRects.forEach(function (snapRect1) {
      nextElementRects.forEach(function (snapRect2) {
        if (snapRect1 === snapRect2) {
          return;
        }

        var rect1 = snapRect1.rect;
        var rect2 = snapRect2.rect;
        var rect1Start = rect1[sideNames.start];
        var rect1End = rect1[sideNames.end];
        var rect2Start = rect2[sideNames.start];
        var rect2End = rect2[sideNames.end];

        if (rect1Start > rect2End || rect2Start > rect1End) {
          return;
        }

        groups.push([snapRect1, snapRect2]);
      });
    });
    groups.forEach(function (_a) {
      var snapRect1 = _a[0],
          snapRect2 = _a[1];
      var rect1 = snapRect1.rect;
      var rect2 = snapRect2.rect;
      var rect1Start = rect1[mainNames.start];
      var rect1End = rect1[mainNames.end];
      var rect2Start = rect2[mainNames.start];
      var rect2End = rect2[mainNames.end];
      var gap = 0;
      var pos = 0;
      var isStart = false;
      var isCenter = false;
      var isEnd = false;

      if (rect1End <= targetStart && targetEnd <= rect2Start) {
        // (l)element1(r) : (l)target(r) : (l)element2(r)
        isCenter = true;
        gap = (rect2Start - rect1End - (targetEnd - targetStart)) / 2;
        pos = rect1End + gap + (targetEnd - targetStart) / 2;

        if (Math.abs(pos - targetCenter) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {
        // (l)element1(r) : (l)element2(r) : (l)target
        isStart = true;
        gap = rect2Start - rect1End;
        pos = rect2End + gap;

        if (Math.abs(pos - targetStart) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {
        // target(r) : (l)element1(r) : (l)element2(r)
        isEnd = true;
        gap = rect2Start - rect1End;
        pos = rect1Start - gap;

        if (Math.abs(pos - targetEnd) > snapThreshold) {
          return;
        }
      } else {
        return;
      }

      if (!gap) {
        return;
      }

      gapGuidelines.push({
        type: type,
        pos: type === "vertical" ? [pos, 0] : [0, pos],
        element: snapRect2.element,
        size: 0,
        className: snapRect2.className,
        isStart: isStart,
        isCenter: isCenter,
        isEnd: isEnd,
        gap: gap,
        hide: true,
        gapRects: [snapRect1, snapRect2]
      });
    });
  });
  return gapGuidelines;
}
function getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }

  if (clientTop === void 0) {
    clientTop = 0;
  }

  if (snapOffset === void 0) {
    snapOffset = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }

  var guidelines = [];
  var snapOffsetLeft = snapOffset.left,
      snapOffsetTop = snapOffset.top,
      snapOffsetBottom = snapOffset.bottom,
      snapOffsetRight = snapOffset.right;
  var snapWidth = width + snapOffsetRight - snapOffsetLeft;
  var snapHeight = height + snapOffsetBottom - snapOffsetTop;
  horizontalGuidelines && horizontalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "horizontal",
      pos: [snapOffsetLeft, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos - clientTop + snapOffsetTop, 0.1)],
      size: snapWidth
    });
  });
  verticalGuidelines && verticalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "vertical",
      pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos - clientLeft + snapOffsetLeft, 0.1), snapOffsetTop],
      size: snapHeight
    });
  });
  return guidelines;
}
function calculateContainerPos(rootMatrix, containerRect, n) {
  var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);
  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];
}
function getSnapElementRects(moveable, values) {
  if (!values.length) {
    return [];
  }

  var state = moveable.state;
  var containerClientRect = state.containerClientRect,
      _a = state.targetClientRect,
      clientTop = _a.top,
      clientLeft = _a.left,
      rootMatrix = state.rootMatrix,
      is3d = state.is3d;
  var n = is3d ? 4 : 3;

  var _b = calculateContainerPos(rootMatrix, containerClientRect, n),
      containerLeft = _b[0],
      containerTop = _b[1];

  var poses = getAbsolutePosesByState(state);

  var _c = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getMinMaxs)(poses),
      targetLeft = _c.minX,
      targetTop = _c.minY;

  var _d = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)([targetLeft, targetTop], calculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function (pos) {
    return roundSign(pos);
  }),
      distLeft = _d[0],
      distTop = _d[1];

  return values.map(function (value) {
    var rect = value.element.getBoundingClientRect();
    var left = rect.left - containerLeft;
    var top = rect.top - containerTop;
    var bottom = top + rect.height;
    var right = left + rect.width;

    var _a = calculateInversePosition(rootMatrix, [left, top], n),
        elementLeft = _a[0],
        elementTop = _a[1];

    var _b = calculateInversePosition(rootMatrix, [right, bottom], n),
        elementRight = _b[0],
        elementBottom = _b[1];

    return __assign(__assign({}, value), {
      rect: {
        left: elementLeft + distLeft,
        right: elementRight + distLeft,
        top: elementTop + distTop,
        bottom: elementBottom + distTop,
        center: (elementLeft + elementRight) / 2 + distLeft,
        middle: (elementTop + elementBottom) / 2 + distTop
      }
    });
  });
}
function getElementGuidelines(moveable) {
  var state = moveable.state;
  var _a = moveable.props.elementGuidelines,
      elementGuidelines = _a === void 0 ? [] : _a;

  if (!elementGuidelines.length) {
    state.elementRects = [];
    return [];
  }

  var prevValues = (state.elementRects || []).filter(function (snapRect) {
    return !snapRect.refresh;
  });
  var nextElementGuidelines = elementGuidelines.map(function (el) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(el) && "element" in el) {
      return el;
    }

    return {
      element: getRefTarget(el, true)
    };
  }).filter(function (value) {
    return value.element;
  });

  var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_6__.diff)(prevValues.map(function (v) {
    return v.element;
  }), nextElementGuidelines.map(function (v) {
    return v.element;
  })),
      maintained = _b.maintained,
      added = _b.added;

  var nextValues = [];
  maintained.forEach(function (_a) {
    var prevIndex = _a[0],
        nextIndex = _a[1];
    nextValues[nextIndex] = prevValues[prevIndex];
  });
  getSnapElementRects(moveable, added.map(function (index) {
    return nextElementGuidelines[index];
  })).map(function (rect, i) {
    nextValues[added[i]] = rect;
  });
  state.elementRects = nextValues;
  var elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);
  var nextGuidelines = [];
  nextValues.forEach(function (snapRect) {
    var element = snapRect.element,
        _a = snapRect.top,
        topValue = _a === void 0 ? elementSnapDirections.top : _a,
        _b = snapRect.left,
        leftValue = _b === void 0 ? elementSnapDirections.left : _b,
        _c = snapRect.right,
        rightValue = _c === void 0 ? elementSnapDirections.right : _c,
        _d = snapRect.bottom,
        bottomValue = _d === void 0 ? elementSnapDirections.bottom : _d,
        _e = snapRect.center,
        centerValue = _e === void 0 ? elementSnapDirections.center : _e,
        _f = snapRect.middle,
        middleValue = _f === void 0 ? elementSnapDirections.middle : _f,
        className = snapRect.className,
        rect = snapRect.rect;

    var _g = splitSnapDirectionPoses({
      top: topValue,
      right: rightValue,
      left: leftValue,
      bottom: bottomValue,
      center: centerValue,
      middle: middleValue
    }, rect),
        horizontal = _g.horizontal,
        vertical = _g.vertical;

    var rectTop = rect.top;
    var rectLeft = rect.left;
    var width = rect.right - rectLeft;
    var height = rect.bottom - rectTop;
    var sizes = [width, height];
    vertical.forEach(function (pos) {
      nextGuidelines.push({
        type: "vertical",
        element: element,
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos, 0.1), rectTop],
        size: height,
        sizes: sizes,
        className: className,
        elementRect: snapRect
      });
    });
    horizontal.forEach(function (pos) {
      nextGuidelines.push({
        type: "horizontal",
        element: element,
        pos: [rectLeft, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos, 0.1)],
        size: width,
        sizes: sizes,
        className: className,
        elementRect: snapRect
      });
    });
  });
  return nextGuidelines;
}
function getTotalGuidelines(moveable) {
  var _a = moveable.state,
      snapOffset = _a.snapOffset,
      _b = _a.containerClientRect,
      overflow = _b.overflow,
      containerHeight = _b.scrollHeight,
      containerWidth = _b.scrollWidth,
      containerClientHeight = _b.clientHeight,
      containerClientWidth = _b.clientWidth,
      clientLeft = _b.clientLeft,
      clientTop = _b.clientTop;
  var _c = moveable.props,
      _d = _c.snapGap,
      snapGap = _d === void 0 ? true : _d,
      verticalGuidelines = _c.verticalGuidelines,
      horizontalGuidelines = _c.horizontalGuidelines,
      _e = _c.snapThreshold,
      snapThreshold = _e === void 0 ? 5 : _e,
      _f = _c.snapGridWidth,
      snapGridWidth = _f === void 0 ? 0 : _f,
      _g = _c.snapGridHeight,
      snapGridHeight = _g === void 0 ? 0 : _g;
  var elementGuidelines = getElementGuidelines(moveable);

  var totalGuidelines = __spreadArray([], elementGuidelines);

  if (snapGap) {
    var _h = getRect(getAbsolutePosesByState(moveable.state)),
        top = _h.top,
        left = _h.left,
        bottom = _h.bottom,
        right = _h.right;

    totalGuidelines.push.apply(totalGuidelines, getGapGuidelines(moveable, {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    }, snapThreshold));
  }

  totalGuidelines.push.apply(totalGuidelines, getGridGuidelines(snapGridWidth, snapGridHeight, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop));
  totalGuidelines.push.apply(totalGuidelines, getDefaultGuidelines(horizontalGuidelines || false, verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset));
  return totalGuidelines;
}
function getGridGuidelines(snapGridWidth, snapGridHeight, containerWidth, containerHeight, clientLeft, clientTop) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }

  if (clientTop === void 0) {
    clientTop = 0;
  }

  var guidelines = [];

  if (snapGridHeight) {
    for (var pos = 0; pos <= containerHeight; pos += snapGridHeight) {
      guidelines.push({
        type: "horizontal",
        pos: [0, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos - clientTop, 0.1)],
        size: containerWidth,
        hide: true
      });
    }
  }

  if (snapGridWidth) {
    for (var pos = 0; pos <= containerWidth; pos += snapGridWidth) {
      guidelines.push({
        type: "vertical",
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(pos - clientLeft, 0.1), 0],
        size: containerHeight,
        hide: true
      });
    }
  }

  return guidelines;
}

function checkMoveableSnapPoses(moveable, posesX, posesY, customSnapThreshold) {
  var props = moveable.props;
  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);
  return checkSnapPoses(moveable.state.guidelines, posesX, posesY, snapThreshold);
}
function checkSnapPoses(guidelines, posesX, posesY, snapThreshold) {
  return {
    vertical: checkSnap(guidelines, "vertical", posesX, snapThreshold),
    horizontal: checkSnap(guidelines, "horizontal", posesY, snapThreshold)
  };
}
function checkSnapKeepRatio(moveable, startPos, endPos) {
  var endX = endPos[0],
      endY = endPos[1];
  var startX = startPos[0],
      startY = startPos[1];

  var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(endPos, startPos),
      dx = _a[0],
      dy = _a[1];

  var isBottom = dy > 0;
  var isRight = dx > 0;
  dx = getTinyDist(dx);
  dy = getTinyDist(dy);
  var verticalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };

  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  }

  var _b = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []),
      verticalSnapInfo = _b.vertical,
      horizontalSnapInfo = _b.horizontal;

  verticalSnapInfo.posInfos.filter(function (_a) {
    var pos = _a.pos;
    return isRight ? pos >= startX : pos <= startX;
  });
  horizontalSnapInfo.posInfos.filter(function (_a) {
    var pos = _a.pos;
    return isBottom ? pos >= startY : pos <= startY;
  });
  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;
  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;

  var _c = getNearestSnapGuidelineInfo(verticalSnapInfo),
      isVerticalSnap = _c.isSnap,
      verticalGuideline = _c.guideline;

  var _d = getNearestSnapGuidelineInfo(horizontalSnapInfo),
      isHorizontalSnap = _d.isSnap,
      horizontalGuideline = _d.guideline;

  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;
  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;

  if (dx === 0) {
    if (isHorizontalSnap) {
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = horizontalGuideline.pos[1];
      horizontalInfo.offset = endY - horizontalInfo.pos;
    }
  } else if (dy === 0) {
    if (isVerticalSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = verticalPos;
      verticalInfo.offset = endX - verticalPos;
    }
  } else {
    // y - y1 = a * (x - x1)
    var a = dy / dx;
    var b = endPos[1] - a * endX;
    var y = 0;
    var x = 0;
    var isSnap = false;

    if (isVerticalSnap) {
      x = verticalPos;
      y = a * x + b;
      isSnap = true;
    } else if (isHorizontalSnap) {
      y = horizontalPos;
      x = (y - b) / a;
      isSnap = true;
    }

    if (isSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }

  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}
function checkSnaps(moveable, rect, customSnapThreshold) {
  var poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);
  return checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, customSnapThreshold);
}
function getNearestSnapGuidelineInfo(snapInfo) {
  var isSnap = snapInfo.isSnap;

  if (!isSnap) {
    return {
      isSnap: false,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  }

  var posInfo = snapInfo.posInfos[0];
  var guidelineInfo = posInfo.guidelineInfos[0];
  var offset = guidelineInfo.offset;
  var dist = guidelineInfo.dist;
  var guideline = guidelineInfo.guideline;
  return {
    isSnap: isSnap,
    offset: offset,
    dist: dist,
    pos: posInfo.pos,
    guideline: guideline
  };
}

function checkSnap(guidelines, targetType, targetPoses, snapThreshold) {
  if (!guidelines || !guidelines.length) {
    return {
      isSnap: false,
      index: -1,
      posInfos: []
    };
  }

  var isVertical = targetType === "vertical";
  var posType = isVertical ? 0 : 1;
  var snapPosInfos = targetPoses.map(function (targetPos, index) {
    var guidelineInfos = guidelines.map(function (guideline) {
      var pos = guideline.pos;
      var offset = targetPos - pos[posType];
      return {
        offset: offset,
        dist: Math.abs(offset),
        guideline: guideline
      };
    }).filter(function (_a) {
      var guideline = _a.guideline,
          dist = _a.dist;
      var type = guideline.type;

      if (type !== targetType || dist > snapThreshold) {
        return false;
      }

      return true;
    }).sort(function (a, b) {
      return a.dist - b.dist;
    });
    return {
      pos: targetPos,
      index: index,
      guidelineInfos: guidelineInfos
    };
  }).filter(function (snapPosInfo) {
    return snapPosInfo.guidelineInfos.length > 0;
  }).sort(function (a, b) {
    return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;
  });
  var isSnap = snapPosInfos.length > 0;
  return {
    isSnap: isSnap,
    index: isSnap ? snapPosInfos[0].index : -1,
    posInfos: snapPosInfos
  };
}

function getSnapInfosByDirection(moveable, poses, snapDirection) {
  var nextPoses = [];

  if (snapDirection[0] && snapDirection[1]) {
    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function (direction) {
      return getPosByDirection(poses, direction);
    });
  } else if (!snapDirection[0] && !snapDirection[1]) {
    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];

    for (var i = 0; i < 4; ++i) {
      nextPoses.push(alignPoses[i]);
      nextPoses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);
    }
  } else {
    if (moveable.props.keepRatio) {
      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function (dir) {
        return getPosByDirection(poses, dir);
      });
    } else {
      nextPoses = getPosesByDirection(poses, snapDirection);

      if (nextPoses.length > 1) {
        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);
      }
    }
  }

  return checkMoveableSnapPoses(moveable, nextPoses.map(function (pos) {
    return pos[0];
  }), nextPoses.map(function (pos) {
    return pos[1];
  }), 1);
}
function checkSnapBoundPriority(a, b) {
  var aDist = Math.abs(a.offset);
  var bDist = Math.abs(b.offset);

  if (a.isBound && b.isBound) {
    return bDist - aDist;
  } else if (a.isBound) {
    return -1;
  } else if (b.isBound) {
    return 1;
  } else if (a.isSnap && b.isSnap) {
    return bDist - aDist;
  } else if (a.isSnap) {
    return -1;
  } else if (b.isSnap) {
    return 1;
  } else if (aDist < TINY_NUM) {
    return 1;
  } else if (bDist < TINY_NUM) {
    return -1;
  }

  return aDist - bDist;
}
function getNearOffsetInfo(offsets, index) {
  return offsets.slice().sort(function (a, b) {
    var aSign = a.sign[index];
    var bSign = b.sign[index];
    var aOffset = a.offset[index];
    var bOffset = b.offset[index]; // -1 The positions of a and b do not change.
    // 1 The positions of a and b are reversed.

    if (!aSign) {
      return 1;
    } else if (!bSign) {
      return -1;
    }

    return checkSnapBoundPriority({
      isBound: a.isBound,
      isSnap: a.isSnap,
      offset: aOffset
    }, {
      isBound: b.isBound,
      isSnap: b.isSnap,
      offset: bOffset
    });
  })[0];
}
function getCheckSnapDirections(direction, keepRatio) {
  var directions = [];
  var fixedDirection = [-direction[0], -direction[1]];

  if (direction[0] && direction[1]) {
    directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);

    if (keepRatio) {
      // pass two direction condition
      directions.push([fixedDirection, direction]);
    }
  } else if (direction[0]) {
    // vertcal
    if (keepRatio) {
      directions.push([fixedDirection, [fixedDirection[0], -1]], [fixedDirection, [fixedDirection[0], 1]], [fixedDirection, [direction[0], -1]], [fixedDirection, direction], [fixedDirection, [direction[0], 1]]);
    } else {
      directions.push([[fixedDirection[0], -1], [direction[0], -1]], [[fixedDirection[0], 0], [direction[0], 0]], [[fixedDirection[0], 1], [direction[0], 1]]);
    }
  } else if (direction[1]) {
    // horizontal
    if (keepRatio) {
      directions.push([fixedDirection, [-1, fixedDirection[1]]], [fixedDirection, [1, fixedDirection[1]]], [fixedDirection, [-1, direction[1]]], [fixedDirection, [1, direction[1]]], [fixedDirection, direction]);
    } else {
      directions.push([[-1, fixedDirection[1]], [-1, direction[1]]], [[0, fixedDirection[1]], [0, direction[1]]], [[1, fixedDirection[1]], [1, direction[1]]]);
    }
  } else {
    // [0, 0] to all direction
    directions.push([fixedDirection, [1, 0]], [fixedDirection, [-1, 0]], [fixedDirection, [0, -1]], [fixedDirection, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]);
  }

  return directions;
}

function isStartLine(dot, line) {
  // l    o     => true
  // o    l    => false
  var cx = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.average)([line[0][0], line[1][0]]);
  var cy = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.average)([line[0][1], line[1][1]]);
  return {
    vertical: cx <= dot[0],
    horizontal: cy <= dot[1]
  };
}

function hitTestLine(dot, _a) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }

  var test1;
  var test2;

  if (!dx) {
    test1 = pos1[0];
    test2 = dot[0];
  } else if (!dy) {
    test1 = pos1[1];
    test2 = dot[1];
  } else {
    var a = dy / dx; // y = a * (x - pos1) + pos1

    test1 = a * (dot[0] - pos1[0]) + pos1[1];
    test2 = dot[1];
  }

  return test1 - test2;
}

function isSameStartLine(dots, line, error) {
  if (error === void 0) {
    error = TINY_NUM;
  }

  var centerSign = hitTestLine(dots[0], line) <= 0;
  return dots.slice(1).every(function (dot) {
    var value = hitTestLine(dot, line);
    var sign = value <= 0;
    return sign === centerSign || Math.abs(value) <= error;
  });
}

function checkInnerBoundDot(pos, start, end, isStart, threshold) {
  if (threshold === void 0) {
    threshold = 0;
  }

  if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {
    // false 402 565 602 => 37 ([0, 37])
    // true 400 524.9712603540036 600 => 124 ([124, 0])
    // true 400 410 600 => 10 ([10, 0])
    return {
      isBound: true,
      offset: isStart ? start - pos : end - pos
    };
  }

  return {
    isBound: false,
    offset: 0
  };
}

function checkInnerBound(moveable, line, center) {
  var bounds = moveable.props.innerBounds;

  if (!bounds) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  }

  var left = bounds.left,
      top = bounds.top,
      width = bounds.width,
      height = bounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];

  var _a = isStartLine(center, line),
      isHorizontalStart = _a.horizontal,
      isVerticalStart = _a.vertical;

  if (isSameStartLine([center, [left, top], [left + width, top], [left, top + height], [left + width, top + height]], line)) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  } // test vertical


  var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);
  var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart); // test horizontal

  var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);
  var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);
  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;
  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;
  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;
  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;
  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);
  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);
  var offset = [0, 0];
  var isBound = false;
  var isAllBound = false;

  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {
    offset = [verticalOffset, 0];
    isBound = isVerticalBound;
    isAllBound = isAllVerticalBound;
  } else {
    offset = [0, horizontalOffset];
    isBound = isHorizontalBound;
    isAllBound = isAllHorizontalBound;
  }

  return {
    isAllBound: isAllBound,
    isVerticalBound: isVerticalBound,
    isHorizontalBound: isHorizontalBound,
    isBound: isBound,
    offset: offset
  };
}

function checkLineBoundCollision(line, boundLine, isStart, threshold, isRender) {
  var dot1 = line[0];
  var dot2 = line[1];
  var boundDot1 = boundLine[0];
  var boundDot2 = boundLine[1];
  var dy1 = getTinyDist(dot2[1] - dot1[1]);
  var dx1 = getTinyDist(dot2[0] - dot1[0]);
  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);
  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]); // dx2 or dy2 is zero

  if (!dx2) {
    // vertical
    if (isRender && !dy1) {
      // 90deg
      return {
        isBound: false,
        offset: 0
      };
    } else if (dx1) {
      // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];
      var y = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1]; // boundDot1[1] <= y  <= boundDot2[1]

      return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);
    } else {
      var offset = boundDot1[0] - dot1[0];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound: isBound,
        offset: isBound ? offset : 0
      };
    }
  } else if (!dy2) {
    // horizontal
    if (isRender && !dx1) {
      // 90deg
      return {
        isBound: false,
        offset: 0
      };
    } else if (dy1) {
      // y = a * (x - x1) + y1
      // x = (y - y1) / a + x1
      // const a = dy1 / dx1;
      // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];
      var x = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0]; // boundDot1[0] <= x && x <= boundDot2[0]

      return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);
    } else {
      var offset = boundDot1[1] - dot1[1];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound: isBound,
        offset: isBound ? offset : 0
      };
    }
  }

  return {
    isBound: false,
    offset: 0
  };
}

function getInnerBoundInfo(moveable, lines, center, datas) {
  return lines.map(function (_a) {
    var multiple = _a[0],
        pos1 = _a[1],
        pos2 = _a[2];

    var _b = checkInnerBound(moveable, [pos1, pos2], center),
        isBound = _b.isBound,
        offset = _b.offset,
        isVerticalBound = _b.isVerticalBound,
        isHorizontalBound = _b.isHorizontalBound;

    var sizeOffset = getDragDist({
      datas: datas,
      distX: offset[0],
      distY: offset[1]
    }).map(function (size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isBound,
      isVerticalBound: isVerticalBound,
      isHorizontalBound: isHorizontalBound,
      isSnap: false,
      offset: sizeOffset
    };
  });
}
function getInnerBoundDragInfo(moveable, poses, datas) {
  var _a;

  var lines = getCheckInnerBoundLines(poses, [0, 0], false).map(function (_a) {
    var sign = _a[0],
        pos1 = _a[1],
        pos2 = _a[2];
    return [sign.map(function (dir) {
      return Math.abs(dir) * 2;
    }), pos1, pos2];
  });
  var innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);
  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);
  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);
  var verticalOffset = 0;
  var horizontalOffset = 0;
  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;
  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;

  if (isVerticalBound || isHorizontalBound) {
    _a = getInverseDragDist({
      datas: datas,
      distX: -widthOffsetInfo.offset[0],
      distY: -heightOffsetInfo.offset[1]
    }), verticalOffset = _a[0], horizontalOffset = _a[1];
  }

  return {
    vertical: {
      isBound: isVerticalBound,
      offset: verticalOffset
    },
    horizontal: {
      isBound: isHorizontalBound,
      offset: horizontalOffset
    }
  };
}
function getCheckSnapLineDirections(direction, keepRatio) {
  var lineDirections = [];
  var x = direction[0];
  var y = direction[1];

  if (x && y) {
    lineDirections.push([[0, y * 2], direction, [-x, y]], [[x * 2, 0], direction, [x, -y]]);
  } else if (x) {
    // vertcal
    lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);

    if (keepRatio) {
      lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);
    }
  } else if (y) {
    // horizontal
    lineDirections.push([[0, y * 2], [1, y], [-1, y]]);

    if (keepRatio) {
      lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);
    }
  } else {
    // [0, 0] to all direction
    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);
  }

  return lineDirections;
}
function getCheckInnerBoundLines(poses, direction, keepRatio) {
  return getCheckSnapLineDirections(direction, keepRatio).map(function (_a) {
    var sign = _a[0],
        dir1 = _a[1],
        dir2 = _a[2];
    return [sign, getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)];
  });
}

function isBoundRotate(relativePoses, boundDots, center, rad) {
  var nextPoses = rad ? relativePoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos, rad);
  }) : relativePoses;

  var dots = __spreadArray([center], boundDots);

  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function (line) {
    return !isSameStartLine(dots, line);
  });
}

function getDistPointLine(_a) {
  // x = 0, y = 0
  // d = (ax + by + c) / root(a2 + b2)
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    return Math.abs(pos1[0]);
  }

  if (!dy) {
    return Math.abs(pos1[1]);
  } // y - y1 = a(x - x1)
  // 0 = ax -y + -a * x1 + y1


  var a = dy / dx;
  return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));
}

function solveReverseLine(_a) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    return [pos1[0], 0];
  }

  if (!dy) {
    return [0, pos1[1]];
  }

  var a = dy / dx; // y - y1 = a (x  - x1)
  // y = ax - a * x1 + y1

  var b = -a * pos1[0] + pos1[1]; // y = ax + b = -1/a x
  // x = -b / (a + 1 / a)
  // y = b / (1 + 1 / a^2)

  return [-b / (a + 1 / a), b / (a * a + 1)];
}

function checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  var bounds = moveable.props.innerBounds;
  var rad = rotation * Math.PI / 180;

  if (!bounds) {
    return [];
  }

  var left = bounds.left,
      top = bounds.top,
      width = bounds.width,
      height = bounds.height;
  var relativeLeft = left - origin[0];
  var relativeRight = left + width - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = top + height - origin[1];
  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];
  var center = getPosByDirection(nextPoses, [0, 0]);

  if (!isBoundRotate(nextPoses, dots, center, 0)) {
    return [];
  }

  var result = [];
  var dotInfos = dots.map(function (dot) {
    return [getDistSize(dot), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], dot)];
  });
  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function (line) {
    var lineRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], solveReverseLine(line));
    var lineDist = getDistPointLine(line);
    result.push.apply(result, dotInfos.filter(function (_a) {
      var dotDist = _a[0];
      return dotDist && lineDist <= dotDist;
    }).map(function (_a) {
      var dotDist = _a[0],
          dotRad = _a[1];
      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);
      var nextRad1 = dotRad + distRad;
      var nextRad2 = dotRad - distRad;
      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];
    }).reduce(function (prev, cur) {
      prev.push.apply(prev, cur);
      return prev;
    }, []).filter(function (nextRad) {
      return !isBoundRotate(prevPoses, dots, center, nextRad);
    }).map(function (nextRad) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextRad * 180 / Math.PI, TINY_NUM);
    }));
  });
  return result;
}
function checkInnerBoundPoses(moveable) {
  var innerBounds = moveable.props.innerBounds;

  if (!innerBounds) {
    return {
      vertical: [],
      horizontal: []
    };
  }

  var _a = moveable.getRect(),
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;

  var poses = [pos1, pos2, pos3, pos4];
  var center = getPosByDirection(poses, [0, 0]);
  var left = innerBounds.left,
      top = innerBounds.top,
      width = innerBounds.width,
      height = innerBounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];
  var lines = [[pos1, pos2], [pos2, pos4], [pos4, pos3], [pos3, pos1]];
  var horizontalPoses = [];
  var verticalPoses = [];
  var boundMap = {
    top: false,
    bottom: false,
    left: false,
    right: false
  };
  lines.forEach(function (line) {
    var _a = isStartLine(center, line),
        isHorizontalStart = _a.horizontal,
        isVerticalStart = _a.vertical; // test vertical


    var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);
    var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true); // test horizontal

    var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);
    var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);

    if (topBoundInfo.isBound && !boundMap.top) {
      horizontalPoses.push(top);
      boundMap.top = true;
    }

    if (bottomBoundInfo.isBound && !boundMap.bottom) {
      horizontalPoses.push(top + height);
      boundMap.bottom = true;
    }

    if (leftBoundInfo.isBound && !boundMap.left) {
      verticalPoses.push(left);
      boundMap.left = true;
    }

    if (rightBoundInfo.isBound && !boundMap.right) {
      verticalPoses.push(left + width);
      boundMap.right = true;
    }
  });
  return {
    horizontal: horizontalPoses,
    vertical: verticalPoses
  };
}

function checkBoundPoses(bounds, verticalPoses, horizontalPoses) {
  var _a = bounds || {},
      _b = _a.position,
      position = _b === void 0 ? "client" : _b,
      _c = _a.left,
      left = _c === void 0 ? -Infinity : _c,
      _d = _a.top,
      top = _d === void 0 ? -Infinity : _d,
      _e = _a.right,
      right = _e === void 0 ? Infinity : _e,
      _f = _a.bottom,
      bottom = _f === void 0 ? Infinity : _f;

  var nextBounds = {
    position: position,
    left: left,
    top: top,
    right: right,
    bottom: bottom
  };
  return {
    vertical: checkBounds(nextBounds, verticalPoses, true),
    horizontal: checkBounds(nextBounds, horizontalPoses, false)
  };
}
function getBounds(moveable, externalBounds) {
  var _a = moveable.state,
      _b = _a.containerClientRect,
      containerHeight = _b.clientHeight,
      containerWidth = _b.clientWidth,
      clientLeft = _b.clientLeft,
      clientTop = _b.clientTop,
      _c = _a.snapOffset,
      snapOffsetLeft = _c.left,
      snapOffsetTop = _c.top,
      snapOffsetRight = _c.right,
      snapOffsetBottom = _c.bottom;
  var bounds = externalBounds || moveable.props.bounds || {};
  var position = bounds.position || "client";
  var isCSS = position === "css";
  var _d = bounds.left,
      left = _d === void 0 ? -Infinity : _d,
      _e = bounds.top,
      top = _e === void 0 ? -Infinity : _e;
  var _f = bounds.right,
      right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f,
      _g = bounds.bottom,
      bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;

  if (isCSS) {
    right = containerWidth + snapOffsetRight - snapOffsetLeft - right;
    bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;
  }

  return {
    left: left + snapOffsetLeft - clientLeft,
    right: right + snapOffsetLeft - clientLeft,
    top: top + snapOffsetTop - clientTop,
    bottom: bottom + snapOffsetTop - clientTop
  };
}
function checkBoundKeepRatio(moveable, startPos, endPos) {
  var _a = getBounds(moveable),
      left = _a.left,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom;

  var endX = endPos[0],
      endY = endPos[1];

  var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(endPos, startPos),
      dx = _b[0],
      dy = _b[1];

  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }

  var isBottom = dy > 0;
  var isRight = dx > 0;
  var verticalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };

  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  } else if (dx === 0) {
    if (isBottom) {
      if (bottom < endY) {
        horizontalInfo.pos = bottom;
        horizontalInfo.offset = endY - bottom;
      }
    } else {
      if (top > endY) {
        horizontalInfo.pos = top;
        horizontalInfo.offset = endY - top;
      }
    }
  } else if (dy === 0) {
    if (isRight) {
      if (right < endX) {
        verticalInfo.pos = right;
        verticalInfo.offset = endX - right;
      }
    } else {
      if (left > endX) {
        verticalInfo.pos = left;
        verticalInfo.offset = endX - left;
      }
    }
  } else {
    // y - y1 = a * (x - x1)
    var a = dy / dx;
    var b = endPos[1] - a * endX;
    var y = 0;
    var x = 0;
    var isBound = false;

    if (isRight && right <= endX) {
      y = a * right + b;
      x = right;
      isBound = true;
    } else if (!isRight && endX <= left) {
      y = a * left + b;
      x = left;
      isBound = true;
    }

    if (isBound) {
      if (y < top || y > bottom) {
        isBound = false;
      }
    }

    if (!isBound) {
      if (isBottom && bottom <= endY) {
        y = bottom;
        x = (y - b) / a;
        isBound = true;
      } else if (!isBottom && endY <= top) {
        y = top;
        x = (y - b) / a;
        isBound = true;
      }
    }

    if (isBound) {
      verticalInfo.isBound = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isBound = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }

  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}

function checkBounds(bounds, poses, isVertical) {
  // 0   [100 - 200]  300
  var startBoundPos = bounds[isVertical ? "left" : "top"];
  var endBoundPos = bounds[isVertical ? "right" : "bottom"]; // 450

  var minPos = Math.min.apply(Math, poses);
  var maxPos = Math.max.apply(Math, poses);
  var boundInfos = [];

  if (startBoundPos + 1 > minPos) {
    boundInfos.push({
      isBound: true,
      offset: minPos - startBoundPos,
      pos: startBoundPos
    });
  }

  if (endBoundPos - 1 < maxPos) {
    boundInfos.push({
      isBound: true,
      offset: maxPos - endBoundPos,
      pos: endBoundPos
    });
  }

  if (!boundInfos.length) {
    boundInfos.push({
      isBound: false,
      offset: 0,
      pos: 0
    });
  }

  return boundInfos.sort(function (a, b) {
    return Math.abs(b.offset) - Math.abs(a.offset);
  });
}

function isBoundRotate$1(relativePoses, boundRect, rad) {
  var nextPoses = rad ? relativePoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos, rad);
  }) : relativePoses;
  return nextPoses.some(function (pos) {
    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;
  });
}
function boundRotate(vec, boundPos, index) {
  var r = getDistSize(vec);
  var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;
  return [nextPos, -nextPos].sort(function (a, b) {
    return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);
  }).map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], index ? [pos, boundPos] : [boundPos, pos]);
  });
}
function checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  if (!moveable.props.bounds) {
    return [];
  }

  var rad = rotation * Math.PI / 180;

  var _a = getBounds(moveable),
      left = _a.left,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom;

  var relativeLeft = left - origin[0];
  var relativeRight = right - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = bottom - origin[1];
  var boundRect = {
    left: relativeLeft,
    top: relativeTop,
    right: relativeRight,
    bottom: relativeBottom
  };

  if (!isBoundRotate$1(nextPoses, boundRect, 0)) {
    return [];
  }

  var result = [];
  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function (_a) {
    var boundPos = _a[0],
        index = _a[1];
    nextPoses.forEach(function (nextPos) {
      var relativeRad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], nextPos);
      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function (relativeRad2) {
        return rad + relativeRad2 - relativeRad1;
      }).filter(function (nextRad) {
        return !isBoundRotate$1(prevPoses, boundRect, nextRad);
      }).map(function (nextRad) {
        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextRad * 180 / Math.PI, TINY_NUM);
      }));
    });
  });
  return result;
}

function renderGuideline(info, React) {
  var _a;

  var direction = info.direction,
      classNames = info.classNames,
      size = info.size,
      pos = info.pos,
      zoom = info.zoom,
      key = info.key;
  var isHorizontal = direction === "horizontal";
  var scaleType = isHorizontal ? "Y" : "X"; // const scaleType2 = isHorizontal ? "Y" : "X";

  return React.createElement("div", {
    key: key,
    className: classNames.join(" "),
    style: (_a = {}, _a[isHorizontal ? "width" : "height"] = "" + size, _a.transform = "translate(" + pos[0] + ", " + pos[1] + ") translate" + scaleType + "(-50%) scale" + scaleType + "(" + zoom + ")", _a)
  });
}
function renderInnerGuideline(info, React) {
  return renderGuideline(__assign(__assign({}, info), {
    classNames: __spreadArray([prefix("line", "guideline", info.direction)], info.classNames).filter(function (className) {
      return className;
    }),
    size: info.size || info.sizeValue + "px",
    pos: info.pos || info.posValue.map(function (v) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(v, 0.1) + "px";
    })
  }), React);
}
function renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {
  var zoom = moveable.props.zoom;
  return snapPoses.map(function (_a, i) {
    var type = _a.type,
        pos = _a.pos;
    var renderPos = [0, 0];
    renderPos[index] = minPos;
    renderPos[index ? 0 : 1] = -targetPos + pos;
    return renderInnerGuideline({
      key: direction + "TargetGuideline" + i,
      classNames: [prefix("target", "bold", type)],
      posValue: renderPos,
      sizeValue: size,
      zoom: zoom,
      direction: direction
    }, React);
  });
}
function renderGuidelines(moveable, type, guidelines, targetPos, targetRect, React) {
  var _a = moveable.props,
      zoom = _a.zoom,
      isDisplayInnerSnapDigit = _a.isDisplayInnerSnapDigit;
  var mainNames = type === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[mainNames.start];
  var targetEnd = targetRect[mainNames.end];
  return guidelines.filter(function (_a) {
    var hide = _a.hide,
        elementRect = _a.elementRect;

    if (hide) {
      return false;
    }

    if (isDisplayInnerSnapDigit && elementRect) {
      // inner
      var rect = elementRect.rect;

      if (rect[mainNames.start] <= targetStart && targetEnd <= rect[mainNames.end]) {
        return false;
      }
    }

    return true;
  }).map(function (guideline, i) {
    var pos = guideline.pos,
        size = guideline.size,
        element = guideline.element;
    var renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];
    return renderInnerGuideline({
      key: type + "-default-guideline-" + i,
      classNames: element ? [prefix("bold")] : [],
      direction: type,
      posValue: renderPos,
      sizeValue: size,
      zoom: zoom
    }, React);
  });
}
function renderDigitLine(moveable, type, lineType, index, gap, renderPos, className, React) {
  var _a;

  var _b = moveable.props,
      _c = _b.snapDigit,
      snapDigit = _c === void 0 ? 0 : _c,
      _d = _b.isDisplaySnapDigit,
      isDisplaySnapDigit = _d === void 0 ? true : _d,
      _e = _b.snapDistFormat,
      snapDistFormat = _e === void 0 ? function (v) {
    return v;
  } : _e,
      zoom = _b.zoom;
  var scaleType = type === "horizontal" ? "X" : "Y";
  var sizeName = type === "vertical" ? "height" : "width";
  var absGap = Math.abs(gap);
  var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;
  return React.createElement("div", {
    key: type + "-" + lineType + "-guideline-" + index,
    className: prefix("guideline-group", type),
    style: (_a = {
      left: renderPos[0] + "px",
      top: renderPos[1] + "px"
    }, _a[sizeName] = absGap + "px", _a)
  }, renderInnerGuideline({
    direction: type,
    classNames: [prefix(lineType), className],
    size: "100%",
    posValue: [0, 0],
    sizeValue: absGap,
    zoom: zoom
  }, React), React.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate" + scaleType + "(-50%) scale(" + zoom + ")"
    }
  }, snapSize > 0 ? snapDistFormat(snapSize) : ""));
}
function groupByElementGuidelines(type, guidelines, targetRect, isDisplayInnerSnapDigit) {
  var index = type === "vertical" ? 0 : 1;
  var otherIndex = type === "vertical" ? 1 : 0;
  var names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[names.start];
  var targetEnd = targetRect[names.end];
  return groupBy(guidelines, function (guideline) {
    return guideline.pos[index];
  }).map(function (nextGuidelines) {
    var start = [];
    var end = [];
    var inner = [];
    nextGuidelines.forEach(function (guideline) {
      var _a, _b;

      var element = guideline.element;
      var rect = guideline.elementRect.rect;

      if (rect[names.end] < targetStart) {
        start.push(guideline);
      } else if (targetEnd < rect[names.start]) {
        end.push(guideline);
      } else if (rect[names.start] <= targetStart && targetEnd <= rect[names.end] && isDisplayInnerSnapDigit) {
        var pos = guideline.pos;
        var elementRect1 = {
          element: element,
          rect: __assign(__assign({}, rect), (_a = {}, _a[names.end] = rect[names.start], _a))
        };
        var elementRect2 = {
          element: element,
          rect: __assign(__assign({}, rect), (_b = {}, _b[names.start] = rect[names.end], _b))
        };
        var nextPos1 = [0, 0];
        var nextPos2 = [0, 0];
        nextPos1[index] = pos[index];
        nextPos1[otherIndex] = pos[otherIndex];
        nextPos2[index] = pos[index];
        nextPos2[otherIndex] = pos[otherIndex] + guideline.size;
        start.push({
          type: type,
          pos: nextPos1,
          size: 0,
          elementRect: elementRect1
        });
        end.push({
          type: type,
          pos: nextPos2,
          size: 0,
          elementRect: elementRect2
        }); // inner.push(guideline);
      }
    });
    start.sort(function (a, b) {
      return b.pos[otherIndex] - a.pos[otherIndex];
    });
    end.sort(function (a, b) {
      return a.pos[otherIndex] - b.pos[otherIndex];
    });
    return {
      total: nextGuidelines,
      start: start,
      end: end,
      inner: inner
    };
  });
}
function renderDashedGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;
  var rendered = [];
  ["vertical", "horizontal"].forEach(function (type) {
    var nextGuidelines = guidelines.filter(function (guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 1 : 0;
    var otherIndex = index ? 0 : 1;
    var groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit);
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    groups.forEach(function (_a) {
      var total = _a.total,
          start = _a.start,
          end = _a.end,
          inner = _a.inner;
      var sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start];
      var prevRect = targetRect;
      start.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = prevRect[mainNames.start] - nextRect[mainNames.end];

        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.start] - targetStart - size;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }

        prevRect = nextRect;
      });
      prevRect = targetRect;
      end.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = nextRect[mainNames.start] - prevRect[mainNames.end];

        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.end] - targetStart;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }

        prevRect = nextRect;
      });
      inner.forEach(function (guideline) {
        var nextRect = guideline.elementRect.rect;
        var size1 = targetStart - nextRect[mainNames.start];
        var size2 = nextRect[mainNames.end] - targetEnd;
        var renderPos1 = [0, 0];
        var renderPos2 = [0, 0];
        renderPos1[index] = targetPos[index] - size1;
        renderPos1[otherIndex] = sidePos;
        renderPos2[index] = targetPos[index] + targetEnd - targetStart;
        renderPos2[otherIndex] = sidePos;
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size1, renderPos1, guideline.className, React));
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size2, renderPos2, guideline.className, React));
      });
    });
  });
  return rendered;
}
function renderGapGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var rendered = [];
  ["horizontal", "vertical"].forEach(function (type) {
    var nextGuidelines = guidelines.filter(function (guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 0 : 1;
    var otherIndex = index ? 0 : 1;
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetSideStart = targetRect[sideNames.start];
    var targetSideEnd = targetRect[sideNames.end];
    nextGuidelines.forEach(function (_a) {
      var gap = _a.gap,
          gapRects = _a.gapRects,
          className = _a.className;
      var sideStartPos = Math.max.apply(Math, __spreadArray([targetSideStart], gapRects.map(function (_a) {
        var rect = _a.rect;
        return rect[sideNames.start];
      })));
      var sideEndPos = Math.min.apply(Math, __spreadArray([targetSideEnd], gapRects.map(function (_a) {
        var rect = _a.rect;
        return rect[sideNames.end];
      })));
      var sideCenterPos = (sideStartPos + sideEndPos) / 2;

      if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd) / 2) {
        return;
      }

      gapRects.forEach(function (_a) {
        var rect = _a.rect;
        var renderPos = [targetPos[0], targetPos[1]];

        if (rect[mainNames.end] < targetStart) {
          renderPos[index] += rect[mainNames.end] - targetStart;
        } else if (targetEnd < rect[mainNames.start]) {
          renderPos[index] += rect[mainNames.start] - targetStart - gap;
        } else {
          return;
        }

        renderPos[otherIndex] += sideCenterPos - targetSideStart;
        rendered.push(renderDigitLine(moveable, index ? "vertical" : "horizontal", "gap", rendered.length, gap, renderPos, className, React));
      });
    });
  });
  return rendered;
}

function solveEquation(pos1, pos2, snapOffset, isVertical) {
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (Math.abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM) {
    dx = 0;
  }

  if (Math.abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM) {
    dy = 0;
  }

  if (!dx) {
    // y = 0 * x + b
    // only horizontal
    if (!isVertical) {
      return [0, snapOffset];
    }

    return [0, 0];
  }

  if (!dy) {
    // only vertical
    if (isVertical) {
      return [snapOffset, 0];
    }

    return [0, 0];
  } // y = ax + b


  var a = dy / dx;
  var b = pos1[1] - a * pos1[0];

  if (isVertical) {
    // y = a * x + b
    var y = a * (pos2[0] + snapOffset) + b;
    return [snapOffset, y - pos2[1]];
  } else {
    // x = (y - b) / a
    var x = (pos2[1] + snapOffset - b) / a;
    return [x - pos2[0], snapOffset];
  }
}

function solveNextOffset(pos1, pos2, offset, isVertical, datas) {
  var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);

  if (!sizeOffset) {
    return {
      isOutside: false,
      offset: [0, 0]
    };
  }

  var size = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos1, pos2);
  var dist1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(sizeOffset, pos1);
  var dist2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(sizeOffset, pos2);
  var isOutside = dist1 > size || dist2 > size;

  var _a = getDragDist({
    datas: datas,
    distX: sizeOffset[0],
    distY: sizeOffset[1]
  }),
      widthOffset = _a[0],
      heightOffset = _a[1];

  return {
    offset: [widthOffset, heightOffset],
    isOutside: isOutside
  };
}

function getSnapBound(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return getNearestSnapGuidelineInfo(snapInfo).offset;
  }

  return 0;
}

function checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {
  var distX = _a[0],
      distY = _a[1];
  var isVerticalBound = _b[0],
      isHorizontalBound = _b[1];
  var isVerticalSnap = _c[0],
      isHorizontalSnap = _c[1];
  var verticalOffset = _d[0],
      horizontalOffset = _d[1];
  var offsetX = -verticalOffset;
  var offsetY = -horizontalOffset;

  if (throttleDragRotate && distX && distY) {
    offsetX = 0;
    offsetY = 0;
    var adjustPoses = [];

    if (isVerticalBound && isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalBound) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset]);
    } else if (isVerticalSnap && isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalSnap) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset]);
    }

    if (adjustPoses.length) {
      adjustPoses.sort(function (a, b) {
        return getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)([distX, distY], a)) - getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)([distX, distY], b));
      });
      var adjustPos = adjustPoses[0];

      if (adjustPos[0] && Math.abs(distX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM) {
        offsetX = -adjustPos[0];
        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;
      } else if (adjustPos[1] && Math.abs(distY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM) {
        var prevDistY = distY;
        offsetY = -adjustPos[1];
        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;
      }

      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {
        if (Math.abs(offsetX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {
          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);
          offsetX *= scale;
          offsetY *= scale;
        } else if (Math.abs(offsetY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {
          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);
          offsetX *= scale;
          offsetY *= scale;
        } else {
          offsetX = maxOffset(-verticalOffset, offsetX);
          offsetY = maxOffset(-horizontalOffset, offsetY);
        }
      }
    }
  } else {
    offsetX = distX || isVerticalBound ? -verticalOffset : 0;
    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;
  }

  return [offsetX, offsetY];
}
function checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {
  if (!hasGuidelines(moveable, "draggable")) {
    return [{
      isSnap: false,
      isBound: false,
      offset: 0
    }, {
      isSnap: false,
      isBound: false,
      offset: 0
    }];
  }

  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);

  var _a = getRect(poses),
      left = _a.left,
      right = _a.right,
      top = _a.top,
      bottom = _a.bottom;

  var boundPoses = {
    horizontal: poses.map(function (pos) {
      return pos[1];
    }),
    vertical: poses.map(function (pos) {
      return pos[0];
    })
  };
  var snapDirections = getSnapDirections(moveable.props.snapDirections);
  var snapPoses = splitSnapDirectionPoses(snapDirections, {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    center: (left + right) / 2,
    middle: (top + bottom) / 2
  });

  var _b = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses),
      verticalSnapBoundInfo = _b.vertical,
      horizontalSnapBoundInfo = _b.horizontal;

  var _c = getInnerBoundDragInfo(moveable, poses, datas),
      verticalInnerBoundInfo = _c.vertical,
      horizontalInnerBoundInfo = _c.horizontal;

  var isVerticalSnap = verticalSnapBoundInfo.isSnap;
  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;
  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;
  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;
  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);
  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);

  var _d = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]),
      offsetX = _d[0],
      offsetY = _d[1];

  return [{
    isBound: isVerticalBound,
    isSnap: isVerticalSnap,
    offset: offsetX
  }, {
    isBound: isHorizontalBound,
    isSnap: isHorizontalSnap,
    offset: offsetY
  }];
}
function checkMoveableSnapBounds(moveable, isRequest, poses, boundPoses) {
  if (boundPoses === void 0) {
    boundPoses = poses;
  }

  var _a = checkBoundPoses(getBounds(moveable), boundPoses.vertical, boundPoses.horizontal),
      horizontalBoundInfos = _a.horizontal,
      verticalBoundInfos = _a.vertical;

  var _b = isRequest ? {
    horizontal: {
      isSnap: false,
      index: -1
    },
    vertical: {
      isSnap: false,
      index: -1
    }
  } : checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}
function checkSnapBounds(guideines, bounds, posesX, posesY, snapThreshold) {
  var _a = checkBoundPoses(bounds, posesX, posesY),
      horizontalBoundInfos = _a.horizontal,
      verticalBoundInfos = _a.vertical; // options.isRequest ? {
  //     horizontal: { isSnap: false, index: -1 } as SnapInfo,
  //     vertical: { isSnap: false, index: -1 } as SnapInfo,
  // } :


  var _b = checkSnapPoses(guideines, posesX, posesY, snapThreshold),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}

function checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {
  var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(startPos, endPos) / Math.PI * 180;
  var _a = snapBoundInfo.vertical,
      isVerticalBound = _a.isBound,
      isVerticalSnap = _a.isSnap,
      verticalDist = _a.dist,
      _b = snapBoundInfo.horizontal,
      isHorizontalBound = _b.isBound,
      isHorizontalSnap = _b.isSnap,
      horizontalDist = _b.dist;
  var rad180 = rad % 180;
  var isHorizontalLine = rad180 < 3 || rad180 > 177;
  var isVerticalLine = rad180 > 87 && rad180 < 93;

  if (horizontalDist < verticalDist) {
    if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {
      return "vertical";
    }
  }

  if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {
    return "horizontal";
  }

  return "";
}

function getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {
  return directions.map(function (_a) {
    var startDirection = _a[0],
        endDirection = _a[1];
    var otherStartPos = getPosByDirection(poses, startDirection);
    var otherEndPos = getPosByDirection(poses, endDirection);
    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, {
      vertical: [otherEndPos[0]],
      horizontal: [otherEndPos[1]]
    });
    var _b = snapBoundInfo.horizontal,
        // dist: otherHorizontalDist,
    otherHorizontalOffset = _b.offset,
        isOtherHorizontalBound = _b.isBound,
        isOtherHorizontalSnap = _b.isSnap,
        _c = snapBoundInfo.vertical,
        // dist: otherVerticalDist,
    otherVerticalOffset = _c.offset,
        isOtherVerticalBound = _c.isBound,
        isOtherVerticalSnap = _c.isSnap;
    var multiple = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(endDirection, startDirection);

    if (!otherVerticalOffset && !otherHorizontalOffset) {
      return {
        isBound: isOtherVerticalBound || isOtherHorizontalBound,
        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,
        sign: multiple,
        offset: [0, 0]
      };
    }

    var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);

    if (!snapLine) {
      return {
        sign: multiple,
        isBound: false,
        isSnap: false,
        offset: [0, 0]
      };
    }

    var isVertical = snapLine === "vertical";
    var sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset.map(function (size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,
      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,
      offset: sizeOffset
    };
  });
}

function getSnapBoundOffset(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return snapInfo.offset;
  }

  return 0;
}

function checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {
  var _a = checkBoundKeepRatio(moveable, startPos, endPos),
      horizontalBoundInfo = _a.horizontal,
      verticalBoundInfo = _a.vertical;

  var _b = isRequest ? {
    horizontal: {
      isSnap: false
    },
    vertical: {
      isSnap: false
    }
  } : checkSnapKeepRatio(moveable, startPos, endPos),
      horizontalSnapInfo = _b.horizontal,
      verticalSnapInfo = _b.vertical;

  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);
  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfo.isBound,
      isSnap: horizontalSnapInfo.isSnap,
      offset: horizontalOffset,
      dist: horizontalDist
    },
    vertical: {
      isBound: verticalBoundInfo.isBound,
      isSnap: verticalSnapInfo.isSnap,
      offset: verticalOffset,
      dist: verticalDist
    }
  };
}
function checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {
  var fixedDirection = [-direction[0], -direction[1]];
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  var bounds = moveable.props.bounds;
  var maxWidth = Infinity;
  var maxHeight = Infinity;

  if (bounds) {
    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];
    var _b = bounds.left,
        left_1 = _b === void 0 ? -Infinity : _b,
        _c = bounds.top,
        top_1 = _c === void 0 ? -Infinity : _c,
        _d = bounds.right,
        right_1 = _d === void 0 ? Infinity : _d,
        _e = bounds.bottom,
        bottom_1 = _e === void 0 ? Infinity : _e;
    directions.forEach(function (otherDirection) {
      var isCheckVertical = otherDirection[0] !== fixedDirection[0];
      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];
      var otherPos = getPosByDirection(poses, otherDirection);
      var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(fixedPosition, otherPos) * 360 / Math.PI;

      if (isCheckHorizontal) {
        var nextOtherPos = otherPos.slice();

        if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {
          nextOtherPos[1] = fixedPosition[1];
        }

        var _a = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas),
            _b = _a.offset,
            heightOffset = _b[1],
            isHeightOutside = _a.isOutside;

        if (!isNaN(heightOffset)) {
          maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);
        }
      }

      if (isCheckVertical) {
        var nextOtherPos = otherPos.slice();

        if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {
          nextOtherPos[0] = fixedPosition[0];
        }

        var _c = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas),
            widthOffset = _c.offset[0],
            isWidthOutside = _c.isOutside;

        if (!isNaN(widthOffset)) {
          maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);
        }
      }
    });
  }

  return {
    maxWidth: maxWidth,
    maxHeight: maxHeight
  };
}

function snapStart(moveable) {
  var state = moveable.state;

  if (state.guidelines && state.guidelines.length) {
    return;
  }

  var container = moveable.state.container;
  var snapContainer = moveable.props.snapContainer || container;
  var containerClientRect = state.containerClientRect;
  var snapOffset = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };

  if (container !== snapContainer) {
    var snapContainerTarget = getRefTarget(snapContainer, true);

    if (snapContainerTarget) {
      var snapContainerRect = getClientRect(snapContainerTarget);
      var offset1 = getDragDistByState(state, [snapContainerRect.left - containerClientRect.left, snapContainerRect.top - containerClientRect.top]);
      var offset2 = getDragDistByState(state, [snapContainerRect.right - containerClientRect.right, snapContainerRect.bottom - containerClientRect.bottom]);
      snapOffset.left = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(offset1[0], 0.1);
      snapOffset.top = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(offset1[1], 0.1);
      snapOffset.right = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(offset2[0], 0.1);
      snapOffset.bottom = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(offset2[1], 0.1);
    }
  }

  state.snapOffset = snapOffset;
  state.guidelines = getTotalGuidelines(moveable);
  state.enableSnap = true;
}

function getNextFixedPoses(matrix, width, height, fixedPos, direction, is3d) {
  var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);
  var nextPos = getPosByReverseDirection(nextPoses, direction);
  return getAbsolutePoses(nextPoses, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(fixedPos, nextPos));
}
function getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {
  var directions = getCheckSnapDirections(direction, keepRatio);
  var lines = getCheckInnerBoundLines(poses, direction, keepRatio);

  var offsets = __spreadArray(__spreadArray([], getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas)), getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas));

  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);
  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);
  return {
    width: {
      isBound: widthOffsetInfo.isBound,
      offset: widthOffsetInfo.offset[0]
    },
    height: {
      isBound: heightOffsetInfo.isBound,
      offset: heightOffsetInfo.offset[1]
    }
  };
}
function recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {
  var snapPos = getPosByDirection(poses, direction);

  var _a = checkMoveableSnapBounds(moveable, isRequest, {
    vertical: [snapPos[0]],
    horizontal: [snapPos[1]]
  }),
      horizontalOffset = _a.horizontal.offset,
      verticalOffset = _a.vertical.offset;

  if (verticalOffset || horizontalOffset) {
    var _b = getDragDist({
      datas: datas,
      distX: -verticalOffset,
      distY: -horizontalOffset
    }),
        nextWidthOffset = _b[0],
        nextHeightOffset = _b[1];

    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);
    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);
    return [nextWidth - width, nextHeight - height];
  }

  return [0, 0];
}
function checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {
  var poses = getAbsolutePosesByState(moveable.state);
  var keepRatio = moveable.props.keepRatio;
  var widthOffset = 0;
  var heightOffset = 0;

  for (var i = 0; i < 2; ++i) {
    var nextPoses = getNextPoses(widthOffset, heightOffset);

    var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas),
        widthOffsetInfo = _a.width,
        heightOffsetInfo = _a.height;

    var isWidthBound = widthOffsetInfo.isBound;
    var isHeightBound = heightOffsetInfo.isBound;
    var nextWidthOffset = widthOffsetInfo.offset;
    var nextHeightOffset = heightOffsetInfo.offset;

    if (i === 1) {
      if (!isWidthBound) {
        nextWidthOffset = 0;
      }

      if (!isHeightBound) {
        nextHeightOffset = 0;
      }
    }

    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {
      return [0, 0];
    }

    if (keepRatio) {
      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);
      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);
      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;

      if (isGetWidthOffset) {
        // width : height = ? : heightOffset
        nextWidthOffset = width * nextHeightOffset / height;
      } else {
        // width : height = widthOffset : ?
        nextHeightOffset = height * nextWidthOffset / width;
      }
    }

    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }

  if (direction[0] && direction[1]) {
    var _b = checkMaxBounds(moveable, poses, direction, fixedPosition, datas),
        maxWidth = _b.maxWidth,
        maxHeight = _b.maxHeight;

    var _c = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function (pos) {
      return pos.map(function (p) {
        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(p, FLOAT_POINT_NUM);
      });
    }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas),
        nextWidthOffset = _c[0],
        nextHeightOffset = _c[1];

    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }

  return [widthOffset, heightOffset];
}
function checkSnapRotate(moveable, rect, origin, rotation) {
  if (!hasGuidelines(moveable, "rotatable")) {
    return rotation;
  }

  var pos1 = rect.pos1,
      pos2 = rect.pos2,
      pos3 = rect.pos3,
      pos4 = rect.pos4;
  var rad = rotation * Math.PI / 180;
  var prevPoses = [pos1, pos2, pos3, pos4].map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos, origin);
  });
  var nextPoses = prevPoses.map(function (pos) {
    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos, rad);
  });

  var result = __spreadArray(__spreadArray([], checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation)), checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation));

  result.sort(function (a, b) {
    return Math.abs(a - rotation) - Math.abs(b - rotation);
  });

  if (result.length) {
    return result[0];
  } else {
    return rotation;
  }
}
function checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {
  if (!hasGuidelines(moveable, "resizable")) {
    return [0, 0];
  }

  var _a = moveable.state,
      allMatrix = _a.allMatrix,
      is3d = _a.is3d;
  return checkSizeDist(moveable, function (widthOffset, heightOffset) {
    return getNextFixedPoses(allMatrix, width + widthOffset, height + heightOffset, fixedPosition, direction, is3d);
  }, width, height, direction, fixedPosition, isRequest, datas);
}
function checkSnapScale(moveable, scale, direction, isRequest, datas) {
  var width = datas.width,
      height = datas.height,
      fixedPosition = datas.fixedPosition;

  if (!hasGuidelines(moveable, "scalable")) {
    return [0, 0];
  }

  var is3d = datas.is3d;
  var sizeDist = checkSizeDist(moveable, function (widthOffset, heightOffset) {
    return getNextFixedPoses(scaleMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(scale, [widthOffset / width, heightOffset / height])), width, height, fixedPosition, direction, is3d);
  }, width, height, direction, fixedPosition, isRequest, datas);
  return [sizeDist[0] / width, sizeDist[1] / height];
}
function startCheckSnapDrag(moveable, datas) {
  datas.absolutePoses = getAbsolutePosesByState(moveable.state);
}

function getSnapGuidelines(posInfos) {
  var guidelines = [];
  posInfos.forEach(function (posInfo) {
    posInfo.guidelineInfos.forEach(function (_a) {
      var guideline = _a.guideline;

      if (guidelines.indexOf(guideline) > -1) {
        return;
      }

      guidelines.push(guideline);
    });
  });
  return guidelines;
}

function addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {
  var _a = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses),
      verticalBoundInfos = _a.vertical,
      horizontalBoundInfos = _a.horizontal;

  verticalBoundInfos.forEach(function (info) {
    if (info.isBound) {
      verticalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });
  horizontalBoundInfos.forEach(function (info) {
    if (info.isBound) {
      horizontalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });

  var _b = checkInnerBoundPoses(moveable),
      verticalInnerBoundPoses = _b.vertical,
      horizontalInnerBoundPoses = _b.horizontal;

  verticalInnerBoundPoses.forEach(function (innerPos) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.findIndex)(verticalSnapPoses, function (_a) {
      var type = _a.type,
          pos = _a.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }

    verticalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
  horizontalInnerBoundPoses.forEach(function (innerPos) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.findIndex)(horizontalSnapPoses, function (_a) {
      var type = _a.type,
          pos = _a.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }

    horizontalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
}
/**
 * @namespace Moveable.Snappable
 * @description Whether or not target can be snapped to the guideline. (default: false)
 * @sort 2
 */


var Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapDirections: [Boolean, Object],
    elementSnapDirections: [Boolean, Object],
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function
  },
  events: {
    onSnap: "snap"
  },
  css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"],
  render: function (moveable, React) {
    var state = moveable.state;
    var targetTop = state.top,
        targetLeft = state.left,
        pos1 = state.pos1,
        pos2 = state.pos2,
        pos3 = state.pos3,
        pos4 = state.pos4,
        snapRenderInfo = state.snapRenderInfo;

    if (!snapRenderInfo || !hasGuidelines(moveable, "")) {
      return [];
    }

    state.guidelines = getTotalGuidelines(moveable);
    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);
    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);
    var externalPoses = snapRenderInfo.externalPoses || [];
    var poses = getAbsolutePosesByState(moveable.state);
    var verticalSnapPoses = [];
    var horizontalSnapPoses = [];
    var verticalGuidelines = [];
    var horizontalGuidelines = [];
    var snapInfos = [];

    var _a = getRect(poses),
        width = _a.width,
        height = _a.height,
        top = _a.top,
        left = _a.left,
        bottom = _a.bottom,
        right = _a.right;

    var targetRect = {
      left: left,
      right: right,
      top: top,
      bottom: bottom,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    };
    var hasExternalPoses = externalPoses.length > 0;
    var externalRect = hasExternalPoses ? getRect(externalPoses) : {};

    if (!snapRenderInfo.request) {
      if (snapRenderInfo.direction) {
        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));
      }

      if (snapRenderInfo.snap) {
        var rect = getRect(poses);

        if (snapRenderInfo.center) {
          rect.middle = (rect.top + rect.bottom) / 2;
          rect.center = (rect.left + rect.right) / 2;
        }

        snapInfos.push(checkSnaps(moveable, rect, 1));
      }

      if (hasExternalPoses) {
        if (snapRenderInfo.center) {
          externalRect.middle = (externalRect.top + externalRect.bottom) / 2;
          externalRect.center = (externalRect.left + externalRect.right) / 2;
        }

        snapInfos.push(checkSnaps(moveable, externalRect, 1));
      }

      snapInfos.forEach(function (snapInfo) {
        var verticalPosInfos = snapInfo.vertical.posInfos,
            horizontalPosInfos = snapInfo.horizontal.posInfos;
        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.filter(function (_a) {
          var guidelineInfos = _a.guidelineInfos;
          return guidelineInfos.some(function (_a) {
            var guideline = _a.guideline;
            return !guideline.hide;
          });
        }).map(function (posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.filter(function (_a) {
          var guidelineInfos = _a.guidelineInfos;
          return guidelineInfos.some(function (_a) {
            var guideline = _a.guideline;
            return !guideline.hide;
          });
        }).map(function (posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));
        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));
      });
    }

    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);

    if (hasExternalPoses) {
      addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);
    }

    var allGuidelines = __spreadArray(__spreadArray([], verticalGuidelines), horizontalGuidelines);

    var elementGuidelines = allGuidelines.filter(function (guideline) {
      return guideline.element && !guideline.gapRects;
    });
    var gapGuidelines = allGuidelines.filter(function (guideline) {
      return guideline.gapRects;
    });
    triggerEvent(moveable, "onSnap", {
      guidelines: allGuidelines.filter(function (_a) {
        var element = _a.element;
        return !element;
      }),
      elements: elementGuidelines,
      gaps: gapGuidelines
    }, true);
    return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(moveable, elementGuidelines, [minLeft, minTop], targetRect, React)), renderGapGuidelines(moveable, gapGuidelines, [minLeft, minTop], targetRect, React)), renderGuidelines(moveable, "horizontal", horizontalGuidelines, [targetLeft, targetTop], targetRect, React)), renderGuidelines(moveable, "vertical", verticalGuidelines, [targetLeft, targetTop], targetRect, React)), renderSnapPoses(moveable, "horizontal", horizontalSnapPoses, minLeft, targetTop, width, 0, React)), renderSnapPoses(moveable, "vertical", verticalSnapPoses, minTop, targetLeft, height, 1, React));
  },
  dragStart: function (moveable, e) {
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      snap: true,
      center: true
    };
    snapStart(moveable);
  },
  drag: function (moveable) {
    var state = moveable.state;
    state.guidelines = getTotalGuidelines(moveable);
  },
  pinchStart: function (moveable) {
    this.unset(moveable);
  },
  dragEnd: function (moveable) {
    this.unset(moveable);
  },
  dragControlCondition: function (moveable, e) {
    if (directionCondition(moveable, e) || dragControlCondition(moveable, e)) {
      return true;
    }

    if (!e.isRequest && e.inputEvent) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(e.inputEvent.target, prefix("snap-control"));
    }
  },
  dragControlStart: function (moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragControl: function (moveable) {
    this.drag(moveable);
  },
  dragControlEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroup: function (moveable) {
    this.drag(moveable);
  },
  dragGroupEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupControlStart: function (moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragGroupControl: function (moveable) {
    this.drag(moveable);
  },
  dragGroupControlEnd: function (moveable) {
    this.unset(moveable);
  },
  unset: function (moveable) {
    var state = moveable.state;
    state.enableSnap = false;
    state.guidelines = [];
    state.snapRenderInfo = null;
    state.elementRects = [];
  }
};
/**
 * Whether or not target can be snapped to the guideline. (default: false)
 * @name Moveable.Snappable#snappable
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snappable = true;
 */

/**
 *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)
 * @name Moveable.Snappable#snapContainer
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.querySelector(".container"));
 *
 * moveable.snapContainer = document.body;
 */

/**
 * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })
 * @name Moveable.Snappable#snapDirections
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   snapDirections: true,
 * });
 * // snap center
 * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };
 */

/**
 * You can specify the snap directions of elements. (default: { left: true, top: true, right: true, bottom: true })
 * @name Moveable.Snappable#elementSnapDirections
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   elementSnapDirections: true,
 * });
 * // snap center
 * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };
 */

/**
 * When you drag, make the gap snap in the element guidelines. (default: true)
 * @name Moveable.Snappable#snapGap
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   snappable: true,
 *   snapVertical: true,
 *   snapHorizontal: true,
 *   snapElement: true,
 *   snapGap: true,
 * });
 *
 * moveable.snapGap = false;
 */

/**
 * Distance value that can snap to guidelines. (default: 5)
 * @name Moveable.Snappable#snapThreshold
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapThreshold = 5;
 */

/**
 * Add guidelines in the horizontal direction. (default: [])
 * @name Moveable.Snappable#horizontalGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.horizontalGuidelines = [100, 200, 500];
 */

/**
 * Add guidelines in the vertical direction. (default: [])
 * @name Moveable.Snappable#verticalGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.verticalGuidelines = [100, 200, 500];
 */

/**
 * Add guidelines for the element. (default: [])
 * @name Moveable.Snappable#elementGuidelines
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.elementGuidelines = [
 *   document.querySelector(".element"),
 * ];
 */

/**
 * You can set up boundaries. (default: null)
 * @name Moveable.Snappable#bounds
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};
 */

/**
 * You can set up inner boundaries. (default: null)
 * @name Moveable.Snappable#innerBounds
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};
 */

/**
 * snap distance digits (default: 0)
 * @name Moveable.Snappable#snapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapDigit = 0
 */

/**
 * If width size is greater than 0, you can vertical snap to the grid. (default: 0)
 * @name Moveable.Snappable#snapGridWidth
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapGridWidth = 5;
 */

/**
 * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)
 * @name Moveable.Snappable#snapGridHeight
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.snapGridHeight = 5;
 */

/**
 * Whether to show snap distance (default: true)
 * @name Moveable.Snappable#isDisplaySnapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.isDisplaySnapDigit = true;
 */

/**
 * Whether to show element inner snap distance (default: false)
 * @name Moveable.Snappable#isDisplayInnerSnapDigit
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.isDisplayInnerSnapDigit = true;
 */

/**
 * You can set the text format of the distance shown in the guidelines. (default: self)
 * @name Moveable.Snappable#snapDistFormat
 * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  snappable: true,
 *  snapDistFormat: v => v,
 * });
 * moveable.snapDistFormat = v => `${v}px`;
 */

/**
 * When you drag or dragControl, the `snap` event is called.
 * @memberof Moveable.Snappable
 * @event snap
 * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     snappable: true
 * });
 * moveable.on("snap", e => {
 *     console.log("onSnap", e);
 * });
 */

/**
 * @namespace Draggable
 * @memberof Moveable
 * @description Draggable refers to the ability to drag and move targets.
 */

var Draggable = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        throttleDragRotate = _a.throttleDragRotate,
        zoom = _a.zoom;
    var _b = moveable.state,
        dragInfo = _b.dragInfo,
        beforeOrigin = _b.beforeOrigin;

    if (!throttleDragRotate || !dragInfo) {
      return [];
    }

    var dist = dragInfo.dist;

    if (!dist[0] && !dist[1]) {
      return [];
    }

    var width = getDistSize(dist);
    var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(dist, [0, 0]);
    return [React.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: width + "px",
        transform: "translate(" + beforeOrigin[0] + "px, " + beforeOrigin[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")"
      }
    })];
  },
  dragStart: function (moveable, e) {
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentGesto = e.parentGesto;
    var state = moveable.state;
    var target = state.target,
        gesto = state.gesto;

    if (gesto) {
      return false;
    }

    state.gesto = parentGesto || moveable.targetGesto;
    var style = getComputedStyle(target);
    datas.datas = {};
    datas.left = parseFloat(style.left || "") || 0;
    datas.top = parseFloat(style.top || "") || 0;
    datas.bottom = parseFloat(style.bottom || "") || 0;
    datas.right = parseFloat(style.right || "") || 0;
    datas.startValue = [0, 0];
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "translate");
    startCheckSnapDrag(moveable, datas);
    datas.prevDist = [0, 0];
    datas.prevBeforeDist = [0, 0];
    datas.isDrag = false;
    datas.deltaOffset = [0, 0];
    datas.distOffset = [0, 0];
    var params = fillParams(moveable, e, __assign({
      set: function (translate) {
        datas.startValue = translate;
      }
    }, fillTransformStartEvent(e)));
    var result = parentEvent || triggerEvent(moveable, "onDragStart", params);

    if (result !== false) {
      datas.isDrag = true;
      moveable.state.dragInfo = {
        startRect: moveable.getRect(),
        dist: [0, 0]
      };
    } else {
      state.gesto = null;
      datas.isPinch = false;
    }

    return datas.isDrag ? params : false;
  },
  drag: function (moveable, e) {
    if (!e) {
      return;
    }

    resolveTransformEvent(e, "translate");
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        isRequest = e.isRequest;
    var distX = e.distX,
        distY = e.distY;
    var isDrag = datas.isDrag,
        prevDist = datas.prevDist,
        prevBeforeDist = datas.prevBeforeDist,
        startValue = datas.startValue,
        distOffset = datas.distOffset;

    if (!isDrag) {
      return;
    }

    distX += distOffset[0];
    distY += distOffset[1];
    var props = moveable.props;
    var parentMoveable = props.parentMoveable;
    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;
    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;
    var isSnap = false;
    var dragRotateRad = 0;

    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {
      var startDragRotate = props.startDragRotate || 0;
      var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(startDragRotate + (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;
      var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));
      var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));
      var r = getDistSize([rx, ry]);
      dragRotateRad = deg * Math.PI / 180;
      distX = r * Math.cos(dragRotateRad);
      distY = r * Math.sin(dragRotateRad);
    }

    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {
      var _a = checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas),
          verticalInfo = _a[0],
          horizontalInfo = _a[1];

      var isVerticalSnap = verticalInfo.isSnap,
          isVerticalBound = verticalInfo.isBound,
          verticalOffset = verticalInfo.offset;
      var isHorizontalSnap = horizontalInfo.isSnap,
          isHorizontalBound = horizontalInfo.isBound,
          horizontalOffset = horizontalInfo.offset;
      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;
      distX += verticalOffset;
      distY += horizontalOffset;
    }

    var beforeTranslate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(getBeforeDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }), startValue);
    var translate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(getTransformDist({
      datas: datas,
      distX: distX,
      distY: distY
    }), startValue);

    if (!throttleDragRotate && !isSnap) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttleArray)(translate, throttleDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttleArray)(beforeTranslate, throttleDrag);
    }

    var beforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(beforeTranslate, startValue);
    var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(translate, startValue);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, prevDist);
    var beforeDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(beforeDist, prevBeforeDist);
    datas.prevDist = dist;
    datas.prevBeforeDist = beforeDist;
    datas.passDelta = delta; //distX - (datas.passDistX || 0);
    // datas.passDeltaY = distY - (datas.passDistY || 0);

    datas.passDist = dist; //distX;
    // datas.passDistY = distY;

    var left = datas.left + beforeDist[0];
    var top = datas.top + beforeDist[1];
    var right = datas.right - beforeDist[0];
    var bottom = datas.bottom - beforeDist[1];
    var nextTransform = convertTransformFormat(datas, "translate(" + translate[0] + "px, " + translate[1] + "px)", "translate(" + dist[0] + "px, " + dist[1] + "px)");
    fillOriginalTransform(e, nextTransform);
    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;

    if (!parentEvent && !parentMoveable && delta.every(function (num) {
      return !num;
    }) && beforeDelta.some(function (num) {
      return !num;
    })) {
      return;
    }

    var _b = moveable.state,
        width = _b.width,
        height = _b.height;
    var params = fillParams(moveable, e, {
      transform: nextTransform,
      dist: dist,
      delta: delta,
      translate: translate,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeTranslate: beforeTranslate,
      left: left,
      top: top,
      right: right,
      bottom: bottom,
      width: width,
      height: height,
      isPinch: isPinch
    });
    !parentEvent && triggerEvent(moveable, "onDrag", params);
    return params;
  },
  dragAfter: function (moveable, e) {
    var datas = e.datas;
    var _a = e.datas,
        deltaOffset = _a.deltaOffset,
        distOffset = _a.distOffset;

    if (deltaOffset[0] || deltaOffset[1]) {
      datas.deltaOffset = [0, 0];
      distOffset[0] = deltaOffset[0];
      distOffset[1] = deltaOffset[1];
      return this.drag(moveable, e);
    }

    return false;
  },
  dragEnd: function (moveable, e) {
    var parentEvent = e.parentEvent,
        datas = e.datas;
    moveable.state.gesto = null;
    moveable.state.dragInfo = null;

    if (!datas.isDrag) {
      return;
    }

    datas.isDrag = false;
    var param = fillEndParams(moveable, e, {});
    !parentEvent && triggerEvent(moveable, "onDragEnd", param);
    return param;
  },
  dragGroupStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY;
    var params = this.dragStart(moveable, e);

    if (!params) {
      return false;
    }

    var events = triggerChildGesto(moveable, this, "dragStart", [clientX || 0, clientY || 0], e, false);

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onDragGroupStart", nextParams);
    datas.isDrag = result !== false;
    return datas.isDrag ? params : false;
  },
  dragGroup: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    var params = this.drag(moveable, e);
    var passDelta = e.datas.passDelta;
    var events = triggerChildGesto(moveable, this, "drag", passDelta, e, false);

    if (!params) {
      return;
    }

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onDragGroup", nextParams);
    return nextParams;
  },
  dragGroupEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    this.dragEnd(moveable, e);
    var events = triggerChildGesto(moveable, this, "dragEnd", [0, 0], e, false);
    triggerEvent(moveable, "onDragGroupEnd", fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    }));
    return isDrag;
  },

  /**
   * @method Moveable.Draggable#request
   * @param {object} [e] - the draggable's request parameter
   * @param {number} [e.x] - x position
   * @param {number} [e.y] - y position
   * @param {number} [e.deltaX] - X number to move
   * @param {number} [e.deltaY] - Y number to move
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("draggable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * // Use Absolute Value
   * moveable.request("draggable", { x: 200, y: 100 });
   * moveable.request("draggable", { x: 220, y: 100 });
   * moveable.request("draggable", { x: 240, y: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    return {
      isControl: false,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("x" in e) {
          distX = e.x - rect.left;
        } else if ("deltaX" in e) {
          distX += e.deltaX;
        }

        if ("y" in e) {
          distY = e.y - rect.top;
        } else if ("deltaY" in e) {
          distY += e.deltaY;
        }

        return {
          datas: datas,
          distX: distX,
          distY: distY
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  },
  unset: function (moveable) {
    moveable.state.dragInfo = null;
  }
};
/**
 * Whether or not target can be dragged. (default: false)
 * @name Moveable.Draggable#draggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.draggable = true;
 */

/**
 * throttle of x, y when drag.
 * @name Moveable.Draggable#throttleDrag
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleDrag = 1;
 */

/**
* throttle of angle of x, y when drag.
* @name Moveable.Draggable#throttleDragRotate
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body);
*
* moveable.throttleDragRotate = 45;
*/

/**
* start angle of throttleDragRotate of x, y when drag.
* @name Moveable.Draggable#startDragRotate
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body);
*
* // 45, 135, 225, 315
* moveable.throttleDragRotate = 90;
* moveable.startDragRotate = 45;
*/

/**
 * When the drag starts, the dragStart event is called.
 * @memberof Moveable.Draggable
 * @event dragStart
 * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("dragStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When dragging, the drag event is called.
 * @memberof Moveable.Draggable
 * @event drag
 * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("drag", ({ target, transform }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When the drag finishes, the dragEnd event is called.
 * @memberof Moveable.Draggable
 * @event dragEnd
 * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { draggable: true });
 * moveable.on("dragEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group drag starts, the `dragGroupStart` event is called.
* @memberof Moveable.Draggable
* @event dragGroupStart
* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     draggable: true
* });
* moveable.on("dragGroupStart", ({ targets }) => {
*     console.log("onDragGroupStart", targets);
* });
*/

/**
* When the group drag, the `dragGroup` event is called.
* @memberof Moveable.Draggable
* @event dragGroup
* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     draggable: true
* });
* moveable.on("dragGroup", ({ targets, events }) => {
*     console.log("onDragGroup", targets);
*     events.forEach(ev => {
*          // drag event
*          console.log("onDrag left, top", ev.left, ev.top);
*          // ev.target!.style.left = `${ev.left}px`;
*          // ev.target!.style.top = `${ev.top}px`;
*          console.log("onDrag translate", ev.dist);
*          ev.target!.style.transform = ev.transform;)
*     });
* });
*/

/**
 * When the group drag finishes, the `dragGroupEnd` event is called.
 * @memberof Moveable.Draggable
 * @event dragGroupEnd
 * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     draggable: true
 * });
 * moveable.on("dragGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onDragGroupEnd", targets, isDrag);
 * });
 */

function renderDirectionControls(moveable, defaultDirections, React, additionalClassName) {
  if (additionalClassName === void 0) {
    additionalClassName = "";
  }

  var _a = moveable.state,
      renderPoses = _a.renderPoses,
      rotationRad = _a.rotation,
      direction = _a.direction;
  var _b = moveable.props,
      _c = _b.renderDirections,
      directions = _c === void 0 ? defaultDirections : _c,
      zoom = _b.zoom;
  var directionMap = {};

  if (!directions) {
    return [];
  }

  var sign = direction > 0 ? 1 : -1;
  var renderDirections = directions === true ? DIRECTIONS : directions;
  var degRotation = rotationRad / Math.PI * 180;
  renderDirections.forEach(function (dir) {
    directionMap[dir] = true;
  });
  return renderDirections.map(function (dir) {
    var indexes = DIRECTION_INDEXES[dir];

    if (!indexes || !directionMap[dir]) {
      return null;
    }

    var directionRotation = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;
    return React.createElement("div", {
      className: prefix("control", "direction", dir, additionalClassName),
      "data-rotation": directionRotation,
      "data-direction": dir,
      key: "direction-" + dir,
      style: getControlTransform.apply(void 0, __spreadArray([rotationRad, zoom], indexes.map(function (index) {
        return renderPoses[index];
      })))
    });
  });
}
function renderLine(React, direction, pos1, pos2, zoom, key) {
  var classNames = [];

  for (var _i = 6; _i < arguments.length; _i++) {
    classNames[_i - 6] = arguments[_i];
  }

  var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos2);
  var rotation = direction ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(rad / Math.PI * 180, 15) % 180 : -1;
  return React.createElement("div", {
    key: "line" + key,
    className: prefix.apply(void 0, __spreadArray(["line", "direction", direction], classNames)),
    "data-rotation": rotation,
    "data-line-index": key,
    "data-direction": direction,
    style: getLineStyle(pos1, pos2, zoom, rad)
  });
}
function renderAllDirections(moveable, React) {
  return renderDirectionControls(moveable, DIRECTIONS, React);
}
function renderDiagonalDirections(moveable, React) {
  return renderDirectionControls(moveable, ["nw", "ne", "sw", "se"], React);
}

/**
 * @namespace Rotatable
 * @memberof Moveable
 * @description Rotatable indicates whether the target can be rotated.
 */

function setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {
  var n = moveable.state.is3d ? 4 : 3;
  var nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);
  var startAbsoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)([rect.left, rect.top], nextOrigin);
  datas.startAbsoluteOrigin = startAbsoluteOrigin;
  datas.prevDeg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;
  datas.prevSnapDeg = datas.prevDeg;
  datas.startDeg = datas.prevDeg;
  datas.loop = 0;
}

function getParentDeg(moveable, moveableRect, datas, parentDist, direction, startValue) {
  var prevDeg = datas.prevDeg; // const absoluteDeg = startValue + parentDist;

  var dist = checkSnapRotate(moveable, moveableRect, datas.origin, parentDist);
  datas.prevDeg = dist;
  var delta = dist - prevDeg;
  return [delta, dist, startValue + dist];
}

function getDeg(moveable, moveableRect, datas, deg, direction, startValue, throttleRotate, isSnap) {
  var prevDeg = datas.prevDeg,
      prevSnapDeg = datas.prevSnapDeg,
      startDeg = datas.startDeg,
      prevLoop = datas.loop;

  if (prevDeg > deg && prevDeg > 270 && deg < 90) {
    // 360 => 0
    ++datas.loop;
  } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {
    // 0 => 360
    --datas.loop;
  }

  var loop = datas.loop;
  var absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startValue;
  var absoluteDeg = loop * 360 + deg - startDeg + startValue;
  datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startValue;
  absoluteDeg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(absoluteDeg, throttleRotate);
  var dist = direction * (absoluteDeg - startValue);

  if (isSnap) {
    dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);
    absoluteDeg = dist / direction + startValue;
  }

  datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startValue;
  var delta = direction * (absoluteDeg - absolutePrevSnapDeg);
  return [delta, dist, startValue + dist];
}

function getRotateInfo(moveable, moveableRect, datas, direction, clientX, clientY, startValue, throttleRotate) {
  return getDeg(moveable, moveableRect, datas, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, startValue, throttleRotate, true);
}
function getRotationPositions(rotationPosition, _a, direction) {
  var pos1 = _a[0],
      pos2 = _a[1],
      pos3 = _a[2],
      pos4 = _a[3];

  if (rotationPosition === "none") {
    return;
  }

  var _b = (rotationPosition || "top").split("-"),
      dir1 = _b[0],
      dir2 = _b[1];

  var radPoses = [pos1, pos2]; // if (scale[0] < 0) {
  //     dir1 = getReversePositionX(dir1);
  //     dir2 = getReversePositionX(dir2);
  // }
  // if (scale[1] < 0) {
  //     dir1 = getReversePositionY(dir1);
  //     dir2 = getReversePositionY(dir2);
  // }

  if (dir1 === "left") {
    radPoses = [pos3, pos1];
  } else if (dir1 === "right") {
    radPoses = [pos2, pos4];
  } else if (dir1 === "bottom") {
    radPoses = [pos4, pos3];
  }

  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];
  var rad = getRotationRad(radPoses, direction);

  if (dir2) {
    var isStart = dir2 === "top" || dir2 === "left";
    var isReverse = dir1 === "bottom" || dir1 === "left";
    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];
  }

  return [pos, rad];
}
function dragControlCondition(moveable, e) {
  if (e.isRequest) {
    return e.requestAble === "rotatable";
  }

  var target = e.inputEvent.target;

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("rotation-control"))) {
    return true;
  }

  var rotationTarget = moveable.props.rotationTarget;

  if (rotationTarget) {
    return getRefTargets(rotationTarget, true).some(function (element) {
      if (!element) {
        return false;
      }

      return target === element || target.contains(element);
    });
  }

  return false;
}
var Rotatable = {
  name: "rotatable",
  canPinch: true,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [".rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }"],
  render: function (moveable, React) {
    var _a = moveable.props,
        rotatable = _a.rotatable,
        rotationPosition = _a.rotationPosition,
        zoom = _a.zoom,
        renderDirections = _a.renderDirections;
    var _b = moveable.state,
        renderPoses = _b.renderPoses,
        direction = _b.direction;

    if (!rotatable) {
      return null;
    }

    var positions = getRotationPositions(rotationPosition, renderPoses, direction);
    var jsxs = [];

    if (positions) {
      var pos = positions[0],
          rad = positions[1];
      jsxs.push(React.createElement("div", {
        key: "rotation",
        className: prefix("rotation"),
        style: {
          // tslint:disable-next-line: max-line-length
          transform: "translate(-50%) translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rad + "rad)"
        }
      }, React.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(" + zoom + ")"
        }
      }), React.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(" + zoom + ")"
        }
      })));
    }

    if (renderDirections) {
      jsxs.push.apply(jsxs, renderDirectionControls(moveable, [], React));
    }

    return jsxs;
  },
  dragControlCondition: dragControlCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        isRequest = e.isRequest;
    var _a = moveable.state,
        target = _a.target,
        left = _a.left,
        top = _a.top,
        origin = _a.origin,
        beforeOrigin = _a.beforeOrigin,
        direction = _a.direction,
        beforeDirection = _a.beforeDirection,
        targetTransform = _a.targetTransform,
        moveableClientRect = _a.moveableClientRect;

    if (!isRequest && !target) {
      return false;
    }

    var rect = moveable.getRect();
    datas.rect = rect;
    datas.transform = targetTransform;
    datas.left = left;
    datas.top = top;
    datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));
    datas.absoluteInfo = {
      origin: rect.origin,
      startValue: rect.rotation
    };
    setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);

    if (isRequest || isPinch || parentFlag) {
      var externalRotate = parentRotate || 0;
      datas.beforeInfo = {
        origin: rect.beforeOrigin,
        prevDeg: externalRotate,
        startDeg: externalRotate,
        prevSnapDeg: externalRotate,
        loop: 0
      };
      datas.afterInfo = {
        origin: rect.origin,
        prevDeg: externalRotate,
        startDeg: externalRotate,
        prevSnapDeg: externalRotate,
        loop: 0
      };
    } else {
      datas.beforeInfo = {
        origin: rect.beforeOrigin
      };
      datas.afterInfo = {
        origin: rect.origin
      };
      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);
      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);
    }

    datas.direction = direction;
    datas.beforeDirection = beforeDirection;
    datas.startValue = 0;
    datas.datas = {};
    setDefaultTransformIndex(e, "rotate");
    var params = fillParams(moveable, e, __assign(__assign({
      set: function (rotatation) {
        datas.startValue = rotatation * Math.PI / 180;
      }
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onRotateStart", params);
    datas.isRotate = result !== false;
    moveable.state.snapRenderInfo = {
      request: e.isRequest
    };
    return datas.isRotate ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;

    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        groupDelta = e.groupDelta;
    var beforeDirection = datas.beforeDirection,
        beforeInfo = datas.beforeInfo,
        afterInfo = datas.afterInfo,
        absoluteInfo = datas.absoluteInfo,
        isRotate = datas.isRotate,
        startValue = datas.startValue,
        rect = datas.rect;

    if (!isRotate) {
      return;
    }

    resolveTransformEvent(e, "rotate");
    var targetDirection = getTransformDirection(e);
    var direction = beforeDirection * targetDirection;
    var _k = moveable.props,
        _l = _k.throttleRotate,
        throttleRotate = _l === void 0 ? 0 : _l,
        parentMoveable = _k.parentMoveable;
    var delta;
    var dist;
    var rotate;
    var beforeDelta;
    var beforeDist;
    var beforeRotate;
    var absoluteDelta;
    var absoluteDist;
    var absoluteRotate;
    var startDeg = 180 / Math.PI * startValue;
    var absoluteStartDeg = absoluteInfo.startValue;

    if (!parentFlag && "parentDist" in e) {
      var parentDist = e.parentDist;
      _a = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startDeg), delta = _a[0], dist = _a[1], rotate = _a[2];
      _b = getParentDeg(moveable, rect, beforeInfo, parentDist, beforeDirection, startDeg), beforeDelta = _b[0], beforeDist = _b[1], beforeRotate = _b[2];
      _c = getParentDeg(moveable, rect, absoluteInfo, parentDist, direction, absoluteStartDeg), absoluteDelta = _c[0], absoluteDist = _c[1], absoluteRotate = _c[2];
    } else if (isPinch || parentFlag) {
      _d = getDeg(moveable, rect, afterInfo, parentRotate, direction, startDeg, throttleRotate), delta = _d[0], dist = _d[1], rotate = _d[2];
      _e = getDeg(moveable, rect, beforeInfo, parentRotate, beforeDirection, startDeg, throttleRotate), beforeDelta = _e[0], beforeDist = _e[1], beforeRotate = _e[2];
      _f = getDeg(moveable, rect, absoluteInfo, parentRotate, direction, absoluteStartDeg, throttleRotate), absoluteDelta = _f[0], absoluteDist = _f[1], absoluteRotate = _f[2];
    } else {
      _g = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startDeg, throttleRotate), delta = _g[0], dist = _g[1], rotate = _g[2];
      _h = getRotateInfo(moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startDeg, throttleRotate), beforeDelta = _h[0], beforeDist = _h[1], beforeRotate = _h[2];
      _j = getRotateInfo(moveable, rect, absoluteInfo, direction, clientX, clientY, absoluteStartDeg, throttleRotate), absoluteDelta = _j[0], absoluteDist = _j[1], absoluteRotate = _j[2];
    }

    if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {
      return;
    }

    var nextTransform = convertTransformFormat(datas, "rotate(" + rotate + "deg)", "rotate(" + dist + "deg)");
    var inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);
    var inverseDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);
    datas.prevInverseDist = inverseDist;
    var params = fillParams(moveable, e, __assign({
      delta: delta,
      dist: dist,
      rotate: rotate,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeRotate: beforeRotate,
      absoluteDist: absoluteDist,
      absoluteDelta: absoluteDelta,
      absoluteRotate: absoluteRotate,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onRotate", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    datas.isRotate = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onRotateEnd", params);
    return params;
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var _a = moveable.state,
        parentLeft = _a.left,
        parentTop = _a.top,
        parentBeforeOrigin = _a.beforeOrigin;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    params.set(datas.beforeDirection * moveable.rotation);
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      var _a = child.state,
          left = _a.left,
          top = _a.top,
          beforeOrigin = _a.beforeOrigin;
      var childClient = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)([left, top], [parentLeft, parentTop]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(beforeOrigin, parentBeforeOrigin));
      ev.datas.groupClient = childClient;
      return __assign(__assign({}, ev), {
        parentRotate: 0
      });
    });

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onRotateGroupStart", nextParams);
    datas.isRotate = result !== false;
    return datas.isRotate ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var direction = datas.beforeDirection;
    var parentRotate = params.beforeDist;
    var deg = params.beforeDelta;
    var rad = deg / 180 * Math.PI;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = ev.datas.groupClient,
          prevX = _a[0],
          prevY = _a[1];

      var _b = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)([prevX, prevY], rad * direction),
          clientX = _b[0],
          clientY = _b[1];

      var delta = [clientX - prevX, clientY - prevY];
      ev.datas.groupClient = [clientX, clientY];
      return __assign(__assign({}, ev), {
        parentRotate: parentRotate,
        groupDelta: delta
      });
    });
    moveable.rotation = direction * params.beforeRotate;

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events,
      set: function (rotation) {
        moveable.rotation = rotation;
      }
    }, params);

    triggerEvent(moveable, "onRotateGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onRotateGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Rotatable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.deltaRotate=0] -  delta number of rotation
   * @param {number} [e.rotate=0] - absolute number of moveable's rotation
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("rotatable", { deltaRotate: 10 }, true);
   *
   * * moveable.request("rotatable", { rotate: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("rotatable");
   *
   * // request
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   * requester.request({ deltaRotate: 10 });
   *
   * requester.request({ rotate: 10 });
   * requester.request({ rotate: 20 });
   * requester.request({ rotate: 30 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var distRotate = 0;
    var startRotation = moveable.getRotation();
    return {
      isControl: true,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("deltaRotate" in e) {
          distRotate += e.deltaRotate;
        } else if ("rotate" in e) {
          distRotate = e.rotate - startRotation;
        }

        return {
          datas: datas,
          parentDist: distRotate
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can be rotated. (default: false)
 * @name Moveable.Rotatable#rotatable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.rotatable = true;
 */

/**
 * You can specify the position of the rotation. (default: "top")
 * @name Moveable.Rotatable#rotationPosition
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   rotationPosition: "top",
 * });
 *
 * moveable.rotationPosition = "bottom"
 */

/**
 * throttle of angle(degree) when rotate.
 * @name Moveable.Rotatable#throttleRotate
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleRotate = 1;
 */

/**
 * When the rotate starts, the rotateStart event is called.
 * @memberof Moveable.Rotatable
 * @event rotateStart
 * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { rotatable: true });
 * moveable.on("rotateStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
* When rotating, the rotate event is called.
* @memberof Moveable.Rotatable
* @event rotate
* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, { rotatable: true });
* moveable.on("rotate", ({ target, transform, dist }) => {
*     target.style.transform = transform;
* });
*/

/**
 * When the rotate finishes, the rotateEnd event is called.
 * @memberof Moveable.Rotatable
 * @event rotateEnd
 * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { rotatable: true });
 * moveable.on("rotateEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
 * When the group rotate starts, the `rotateGroupStart` event is called.
 * @memberof Moveable.Rotatable
 * @event rotateGroupStart
 * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     rotatable: true
 * });
 * moveable.on("rotateGroupStart", ({ targets }) => {
 *     console.log("onRotateGroupStart", targets);
 * });
 */

/**
* When the group rotate, the `rotateGroup` event is called.
* @memberof Moveable.Rotatable
* @event rotateGroup
* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     rotatable: true
* });
* moveable.on("rotateGroup", ({ targets, events }) => {
*     console.log("onRotateGroup", targets);
*     events.forEach(ev => {
*         const target = ev.target;
*         // ev.drag is a drag event that occurs when the group rotate.
*         const left = ev.drag.beforeDist[0];
*         const top = ev.drag.beforeDist[1];
*         const deg = ev.beforeDist;
*     });
* });
*/

/**
 * When the group rotate finishes, the `rotateGroupEnd` event is called.
 * @memberof Moveable.Rotatable
 * @event rotateGroupEnd
 * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     rotatable: true
 * });
 * moveable.on("rotateGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onRotateGroupEnd", targets, isDrag);
 * });
 */

/**
 * @namespace Resizable
 * @memberof Moveable
 * @description Resizable indicates whether the target's width and height can be increased or decreased.
 */

var Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: true,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean
  },
  events: {
    onResizeStart: "resizeStart",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        edge = _a.edge;

    if (resizable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var _a;

    var inputEvent = e.inputEvent,
        isPinch = e.isPinch,
        parentDirection = e.parentDirection,
        datas = e.datas,
        parentFlag = e.parentFlag;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height;

    if (!direction || !target) {
      return false;
    }

    !isPinch && setDragStart(moveable, e);
    datas.datas = {};
    datas.direction = direction;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.prevWidth = 0;
    datas.prevHeight = 0;
    _a = getCSSSize(target), datas.startWidth = _a[0], datas.startHeight = _a[1];
    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];
    datas.minSize = padding;
    datas.maxSize = [Infinity, Infinity];

    if (!parentFlag) {
      var style = getComputedStyle(target);
      var position = style.position,
          minWidth = style.minWidth,
          minHeight = style.minHeight,
          maxWidth = style.maxWidth,
          maxHeight = style.maxHeight;
      var isParentElement = position === "static" || position === "relative";
      var container = isParentElement ? target.parentElement : target.offsetParent;
      var containerWidth = width;
      var containerHeight = height;

      if (container) {
        containerWidth = container.clientWidth;
        containerHeight = container.clientHeight;

        if (isParentElement) {
          var containerStyle = getComputedStyle(container);
          containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;
          containerHeight -= parseFloat(containerStyle.paddingTop) || 0;
        }
      }

      datas.minSize = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)([(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(minWidth, containerWidth) || 0, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(minHeight, containerHeight) || 0], padding);
      datas.maxSize = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)([(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(maxWidth, containerWidth) || Infinity, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(maxHeight, containerHeight) || Infinity], padding);
    }

    var transformOrigin = moveable.props.transformOrigin || "% %";
    datas.transformOrigin = transformOrigin && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(transformOrigin) ? transformOrigin.split(" ") : transformOrigin;
    datas.isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];

    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }

    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);
    }

    setRatio(width / height);
    setFixedDirection([-direction[0], -direction[1]]);
    var params = fillParams(moveable, e, {
      direction: direction,
      set: function (_a) {
        var startWidth = _a[0],
            startHeight = _a[1];
        datas.startWidth = startWidth;
        datas.startHeight = startHeight;
      },
      setMin: function (minSize) {
        datas.minSize = minSize;
      },
      setMax: function (maxSize) {
        datas.maxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];
      },
      setRatio: setRatio,
      setFixedDirection: setFixedDirection,
      setOrigin: function (origin) {
        datas.transformOrigin = origin;
      },
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onResizeStart", params);

    if (result !== false) {
      datas.isResize = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction: direction
      };
    }

    return datas.isResize ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a;

    var datas = e.datas,
        distX = e.distX,
        distY = e.distY,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        parentDistance = e.parentDistance,
        parentScale = e.parentScale,
        parentKeepRatio = e.parentKeepRatio,
        dragClient = e.dragClient,
        parentDist = e.parentDist,
        isRequest = e.isRequest;
    var isResize = datas.isResize,
        transformOrigin = datas.transformOrigin,
        fixedDirection = datas.fixedDirection,
        startWidth = datas.startWidth,
        startHeight = datas.startHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight,
        minSize = datas.minSize,
        maxSize = datas.maxSize,
        ratio = datas.ratio,
        isWidth = datas.isWidth,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight;

    if (!isResize) {
      return;
    }

    var _b = moveable.props,
        _c = _b.throttleResize,
        throttleResize = _c === void 0 ? 0 : _c,
        parentMoveable = _b.parentMoveable,
        _d = _b.snapThreshold,
        snapThreshold = _d === void 0 ? 5 : _d;
    var direction = datas.direction;
    var sizeDirection = direction;
    var distWidth = 0;
    var distHeight = 0;

    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }

    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);
    var fixedPosition = dragClient;

    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }

    if (parentDist) {
      distWidth = parentDist[0];
      distHeight = parentDist[1];

      if (keepRatio) {
        if (!distWidth) {
          distWidth = distHeight * ratio;
        } else if (!distHeight) {
          distHeight = distWidth / ratio;
        }
      }
    } else if (parentScale) {
      distWidth = (parentScale[0] - 1) * startOffsetWidth;
      distHeight = (parentScale[1] - 1) * startOffsetHeight;
    } else if (isPinch) {
      if (parentDistance) {
        distWidth = parentDistance;
        distHeight = parentDistance * startOffsetHeight / startOffsetWidth;
      }
    } else {
      var dist = getDragDist({
        datas: datas,
        distX: distX,
        distY: distY
      });
      distWidth = sizeDirection[0] * dist[0];
      distHeight = sizeDirection[1] * dist[1];

      if (keepRatio && startOffsetWidth && startOffsetHeight) {
        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], dist);
        var standardRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], sizeDirection);
        var size = getDistSize([distWidth, distHeight]);
        var signSize = Math.cos(rad - standardRad) * size;

        if (!sizeDirection[0]) {
          // top, bottom
          distHeight = signSize;
          distWidth = distHeight / ratio;
        } else if (!sizeDirection[1]) {
          // left, right
          distWidth = signSize;
          distHeight = distWidth * ratio;
        } else {
          // two-way
          var startWidthSize = sizeDirection[0] * 2 * startOffsetWidth;
          var startHeightSize = sizeDirection[1] * 2 * startOffsetHeight;
          var distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) - getDistSize([startWidthSize, startHeightSize]);
          var ratioRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], [ratio, 1]);
          distWidth = Math.cos(ratioRad) * distSize;
          distHeight = Math.sin(ratioRad) * distSize;
        }
      } else if (!keepRatio) {
        var nextDirection = __spreadArray([], direction);

        if (!startOffsetWidth) {
          if (dist[0] < 0) {
            nextDirection[0] = -1;
          } else if (dist[0] > 0) {
            nextDirection[0] = 1;
          }
        }

        if (!startOffsetHeight) {
          if (dist[1] < 0) {
            nextDirection[1] = -1;
          } else if (dist[1] > 0) {
            nextDirection[1] = 1;
          }
        }

        direction = nextDirection;
        sizeDirection = nextDirection;
        distWidth = sizeDirection[0] * dist[0];
        distHeight = sizeDirection[1] * dist[1];
      }
    }

    var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;
    var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;

    if (keepRatio && startOffsetWidth && startOffsetHeight) {
      // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight
      if (isWidth) {
        nextHeight = nextWidth / ratio;
      } else {
        nextWidth = nextHeight * ratio;
      }
    }

    var snapDist = [0, 0];

    if (!isPinch) {
      snapDist = checkSnapResize(moveable, nextWidth, nextHeight, direction, fixedPosition, isRequest, datas);
    }

    if (parentDist) {
      !parentDist[0] && (snapDist[0] = 0);
      !parentDist[1] && (snapDist[1] = 0);
    }

    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        if (isWidth) {
          nextWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextWidth, throttleResize);
        } else {
          nextHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextHeight, throttleResize);
        }
      }

      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        nextWidth += snapDist[0];
        nextHeight = nextWidth / ratio;
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        nextHeight += snapDist[1];
        nextWidth = nextHeight * ratio;
      }
    } else {
      if (startOffsetWidth + distWidth < -snapThreshold) {
        snapDist[0] = 0;
      }

      if (startOffsetWidth + distHeight < -snapThreshold) {
        snapDist[1] = 0;
      }

      nextWidth += snapDist[0];
      nextHeight += snapDist[1];

      if (!snapDist[0]) {
        nextWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextWidth, throttleResize);
      }

      if (!snapDist[1]) {
        nextHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(nextHeight, throttleResize);
      }
    }

    _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.calculateBoundSize)([nextWidth, nextHeight], minSize, maxSize, keepRatio), nextWidth = _a[0], nextHeight = _a[1];
    nextWidth = Math.round(nextWidth);
    nextHeight = Math.round(nextHeight);
    distWidth = nextWidth - startOffsetWidth;
    distHeight = nextHeight - startOffsetHeight;
    var delta = [distWidth - prevWidth, distHeight - prevHeight];
    datas.prevWidth = distWidth;
    datas.prevHeight = distHeight;
    var inverseDelta = getResizeDist(moveable, nextWidth, nextHeight, fixedDirection, fixedPosition, transformOrigin);

    if (!parentMoveable && delta.every(function (num) {
      return !num;
    }) && inverseDelta.every(function (num) {
      return !num;
    })) {
      return;
    }

    var params = fillParams(moveable, e, {
      width: startWidth + distWidth,
      height: startHeight + distHeight,
      offsetWidth: nextWidth,
      offsetHeight: nextHeight,
      direction: direction,
      dist: [distWidth, distHeight],
      delta: delta,
      isPinch: !!isPinch,
      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onResize", params);
    return params;
  },
  dragControlAfter: function (moveable, e) {
    var datas = e.datas;
    var isResize = datas.isResize,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight;

    if (!isResize) {
      return;
    }

    var _a = moveable.state,
        width = _a.width,
        height = _a.height;
    var errorWidth = width - (startOffsetWidth + prevWidth);
    var errorHeight = height - (startOffsetHeight + prevHeight);
    var isErrorWidth = Math.abs(errorWidth) > 3;
    var isErrorHeight = Math.abs(errorHeight) > 3;

    if (isErrorWidth) {
      datas.startWidth += errorWidth;
      datas.startOffsetWidth += errorWidth;
      datas.prevWidth += errorWidth;
    }

    if (isErrorHeight) {
      datas.startHeight += errorHeight;
      datas.startOffsetHeight += errorHeight;
      datas.prevHeight += errorHeight;
    }

    if (isErrorWidth || isErrorHeight) {
      return this.dragControl(moveable, e);
    }
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    datas.isResize = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onResizeEnd", params);
    return params;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var originalEvents = fillChildEvents(moveable, "resizable", e);

    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var pos = getAbsolutePosition(child, fixedDirection);

      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createRotateMatrix)(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }

    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      return setDist(child, ev);
    });

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events,
      setFixedDirection: function (fixedDirection) {
        params.setFixedDirection(fixedDirection);
        events.forEach(function (ev, i) {
          ev.setFixedDirection(fixedDirection);
          setDist(moveable.moveables[i], originalEvents[i]);
        });
      }
    });

    var result = triggerEvent(moveable, "onResizeGroupStart", nextParams);
    datas.isResize = result !== false;
    return datas.isResize ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var offsetWidth = params.offsetWidth,
        offsetHeight = params.offsetHeight,
        dist = params.dist;
    var keepRatio = moveable.props.keepRatio;
    var parentScale = [offsetWidth / (offsetWidth - dist[0]), offsetHeight / (offsetHeight - dist[1])];
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * parentScale[0], ev.datas.originalY * parentScale[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign(__assign({}, ev), {
        parentDist: null,
        parentScale: parentScale,
        dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(fixedPosition, [clientX, clientY]),
        parentKeepRatio: keepRatio
      });
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onResizeGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onResizeGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Resizable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.direction=[1, 1]] - Direction to resize
   * @param {number} [e.deltaWidth] - delta number of width
   * @param {number} [e.deltaHeight] - delta number of height
   * @param {number} [e.offsetWidth] - offset number of width
   * @param {number} [e.offsetHeight] - offset number of height
   * @param {number} [e.isInstant] - Whether to execute the request instantly
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * // Use Relative Value
   * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
   *
   * // requestStart
   * const requester = moveable.request("resizable");
   *
   * // request
   * // Use Relative Value
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // Use Absolute Value
   * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
   * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function (moveable) {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    var rect = moveable.getRect();
    return {
      isControl: true,
      requestStart: function (e) {
        return {
          datas: datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function (e) {
        if ("offsetWidth" in e) {
          distWidth = e.offsetWidth - rect.offsetWidth;
        } else if ("deltaWidth" in e) {
          distWidth += e.deltaWidth;
        }

        if ("offsetHeight" in e) {
          distHeight = e.offsetHeight - rect.offsetHeight;
        } else if ("deltaHeight" in e) {
          distHeight += e.deltaHeight;
        }

        return {
          datas: datas,
          parentDist: [distWidth, distHeight]
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can be resized. (default: false)
 * @name Moveable.Resizable#resizable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     resizable: false,
 * });
 *
 * moveable.resizable = true;
 */

/**
 * throttle of width, height when resize.
 * @name Moveable.Resizable#throttleResize
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   throttleResize: 0,
 * });
 *
 * moveable.throttleResize = 1;
 */

/**
 * When resize or scale, keeps a ratio of the width, height. (default: false)
 * @name Moveable.Resizable#keepRatio
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 * });
 *
 * moveable.keepRatio = true;
 */

/**
 * Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
 * @name Moveable.Resizable#renderDirections
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   resizable: true,
 *   renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
 * });
 *
 * moveable.renderDirections = ["nw", "ne", "sw", "se"];
 */

/**
 * When the resize starts, the resizeStart event is called.
 * @memberof Moveable.Resizable
 * @event resizeStart
 * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resizeStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When resizing, the resize event is called.
 * @memberof Moveable.Resizable
 * @event resize
 * @param {Moveable.Resizable.OnResize} - Parameters for the resize event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resize", ({ target, width, height }) => {
 *     target.style.width = `${e.width}px`;
 *     target.style.height = `${e.height}px`;
 * });
 */

/**
 * When the resize finishes, the resizeEnd event is called.
 * @memberof Moveable.Resizable
 * @event resizeEnd
 * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { resizable: true });
 * moveable.on("resizeEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group resize starts, the `resizeGroupStart` event is called.
* @memberof Moveable.Resizable
* @event resizeGroupStart
* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     resizable: true
* });
* moveable.on("resizeGroupStart", ({ targets }) => {
*     console.log("onResizeGroupStart", targets);
* });
*/

/**
* When the group resize, the `resizeGroup` event is called.
* @memberof Moveable.Resizable
* @event resizeGroup
* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     resizable: true
* });
* moveable.on("resizeGroup", ({ targets, events }) => {
*     console.log("onResizeGroup", targets);
*     events.forEach(ev => {
*         const offset = [
*             direction[0] < 0 ? -ev.delta[0] : 0,
*             direction[1] < 0 ? -ev.delta[1] : 0,
*         ];
*         // ev.drag is a drag event that occurs when the group resize.
*         const left = offset[0] + ev.drag.beforeDist[0];
*         const top = offset[1] + ev.drag.beforeDist[1];
*         const width = ev.width;
*         const top = ev.top;
*     });
* });
*/

/**
 * When the group resize finishes, the `resizeGroupEnd` event is called.
 * @memberof Moveable.Resizable
 * @event resizeGroupEnd
 * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     resizable: true
 * });
 * moveable.on("resizeGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onResizeGroupEnd", targets, isDrag);
 * });
 */

/**
 * @namespace Scalable
 * @memberof Moveable
 * @description Scalable indicates whether the target's x and y can be scale of transform.
 */

var Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: true,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        edge = _a.edge;

    if (!resizable && scalable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        parentDirection = e.parentDirection;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _a = moveable.state,
        width = _a.width,
        height = _a.height,
        targetTransform = _a.targetTransform,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos4 = _a.pos4;

    if (!direction || !target) {
      return false;
    }

    if (!isPinch) {
      setDragStart(moveable, e);
    }

    datas.datas = {};
    datas.transform = targetTransform;
    datas.prevDist = [1, 1];
    datas.direction = direction;
    datas.width = width;
    datas.height = height;
    datas.startValue = [1, 1];
    var scaleWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos1, pos2);
    var scaleHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos2, pos4);
    var isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];
    datas.scaleWidth = scaleWidth;
    datas.scaleHeight = scaleHeight;
    datas.scaleXRatio = scaleWidth / width;
    datas.scaleYRatio = scaleHeight / height;
    setDefaultTransformIndex(e, "scale");
    datas.isWidth = isWidth;

    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }

    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);
    }

    setRatio((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos1, pos2) / (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getDist)(pos2, pos4));
    setFixedDirection([-direction[0], -direction[1]]);
    var params = fillParams(moveable, e, __assign(__assign({
      direction: direction,
      set: function (scale) {
        datas.startValue = scale;
      },
      setRatio: setRatio,
      setFixedDirection: setFixedDirection
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onScaleStart", params);

    if (result !== false) {
      datas.isScale = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction: direction
      };
    }

    return datas.isScale ? params : false;
  },
  dragControl: function (moveable, e) {
    resolveTransformEvent(e, "scale");
    var datas = e.datas,
        distX = e.distX,
        distY = e.distY,
        parentScale = e.parentScale,
        parentDistance = e.parentDistance,
        parentKeepRatio = e.parentKeepRatio,
        parentFlag = e.parentFlag,
        isPinch = e.isPinch,
        dragClient = e.dragClient,
        parentDist = e.parentDist,
        isRequest = e.isRequest;
    var prevDist = datas.prevDist,
        direction = datas.direction,
        width = datas.width,
        height = datas.height,
        isScale = datas.isScale,
        startValue = datas.startValue,
        isWidth = datas.isWidth,
        ratio = datas.ratio,
        fixedDirection = datas.fixedDirection,
        scaleXRatio = datas.scaleXRatio,
        scaleYRatio = datas.scaleYRatio;

    if (!isScale) {
      return false;
    }

    var _a = moveable.props,
        throttleScale = _a.throttleScale,
        parentMoveable = _a.parentMoveable;
    var sizeDirection = direction;

    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }

    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);
    var state = moveable.state;
    var scaleX = 1;
    var scaleY = 1;
    var fixedPosition = dragClient;

    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }

    if (parentDist) {
      scaleX = (width + parentDist[0]) / width;
      scaleY = (height + parentDist[1]) / height;
    } else if (parentScale) {
      scaleX = parentScale[0];
      scaleY = parentScale[1];
    } else if (isPinch) {
      if (parentDistance) {
        scaleX = (width + parentDistance) / width;
        scaleY = (height + parentDistance * height / width) / height;
      }
    } else {
      var dragDist = getDragDist({
        datas: datas,
        distX: distX,
        distY: distY
      });
      var distScaleWidth = sizeDirection[0] * dragDist[0] * scaleXRatio;
      var distScaleHeight = sizeDirection[1] * dragDist[1] * scaleYRatio;

      if (keepRatio && width && height) {
        if (!sizeDirection[0]) {
          // top, bottom
          // distHeight = signSize;
          distScaleWidth = distScaleHeight * ratio;
        } else if (!sizeDirection[1]) {
          // left, right
          // distWidth = signSize;
          distScaleHeight = distScaleWidth / ratio;
        } else {
          var size = getDistSize([distScaleWidth, distScaleHeight]); // two-way

          var dragRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], dragDist);
          var standardRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], sizeDirection);
          var signSize = Math.cos(dragRad - standardRad) * size;
          var ratioRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)([0, 0], [ratio, 1]);
          distScaleWidth = Math.cos(ratioRad) * signSize;
          distScaleHeight = Math.sin(ratioRad) * signSize;
        }
      }

      scaleX = (width + distScaleWidth / scaleXRatio) / width;
      scaleY = (height + distScaleHeight / scaleYRatio) / height;
    }

    scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];
    scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];

    if (scaleX === 0) {
      scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }

    if (scaleY === 0) {
      scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }

    var dist = [scaleX / startValue[0], scaleY / startValue[1]];
    var scale = [scaleX, scaleY];

    if (!isPinch && moveable.props.groupable) {
      var snapRenderInfo = state.snapRenderInfo || {};
      var stateDirection = snapRenderInfo.direction;

      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(stateDirection) && (stateDirection[0] || stateDirection[1])) {
        state.snapRenderInfo = {
          direction: direction,
          request: e.isRequest
        };
      }
    }

    var snapDist = [0, 0];

    if (!isPinch) {
      snapDist = checkSnapScale(moveable, dist, direction, isRequest, datas);
    }

    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0] * width) > Math.abs(snapDist[1] * height)) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        if (isWidth) {
          dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(dist[0] * startValue[0], throttleScale) / startValue[0];
        } else {
          dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(dist[1] * startValue[1], throttleScale) / startValue[1];
        }
      }

      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        dist[0] += snapDist[0];
        var snapHeight = width * dist[0] * startValue[0] / ratio;
        dist[1] = snapHeight / height / startValue[1];
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        dist[1] += snapDist[1];
        var snapWidth = height * dist[1] * startValue[1] * ratio;
        dist[0] = snapWidth / width / startValue[0];
      }
    } else {
      dist[0] += snapDist[0];
      dist[1] += snapDist[1];

      if (!snapDist[0]) {
        dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(dist[0] * startValue[0], throttleScale) / startValue[0];
      }

      if (!snapDist[1]) {
        dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(dist[1] * startValue[1], throttleScale) / startValue[1];
      }
    }

    if (dist[0] === 0) {
      dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }

    if (dist[1] === 0) {
      dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }

    var delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];
    scale = multiply2(dist, startValue);
    var inverseDist = getScaleDist(moveable, dist, fixedDirection, fixedPosition, datas);
    var inverseDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(inverseDist, datas.prevInverseDist || [0, 0]);
    datas.prevDist = dist;
    datas.prevInverseDist = inverseDist;

    if (scaleX === prevDist[0] && scaleY === prevDist[1] && inverseDelta.every(function (num) {
      return !num;
    }) && !parentMoveable) {
      return false;
    }

    var nextTransform = convertTransformFormat(datas, "scale(" + scale.join(", ") + ")", "scale(" + dist.join(", ") + ")");
    var params = fillParams(moveable, e, __assign({
      offsetWidth: width,
      offsetHeight: height,
      direction: direction,
      // beforeScale,
      // beforeDist,
      // beforeDelta,
      scale: scale,
      dist: dist,
      delta: delta,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onScale", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isScale) {
      return false;
    }

    datas.isScale = false;
    triggerEvent(moveable, "onScaleEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var originalEvents = fillChildEvents(moveable, "resizable", e);

    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var pos = getAbsolutePosition(child, fixedDirection);

      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createRotateMatrix)(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }

    datas.moveableScale = moveable.scale;
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function (child, ev) {
      return setDist(child, ev);
    });

    var nextParams = __assign(__assign({}, params), {
      targets: moveable.props.targets,
      events: events,
      setFixedDirection: function (fixedDirection) {
        params.setFixedDirection(fixedDirection);
        events.forEach(function (ev, i) {
          ev.setFixedDirection(fixedDirection);
          setDist(moveable.moveables[i], originalEvents[i]);
        });
      }
    });

    var result = triggerEvent(moveable, "onScaleGroupStart", nextParams);
    datas.isScale = result !== false;
    return datas.isScale ? nextParams : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var moveableScale = datas.moveableScale;
    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];
    var keepRatio = moveable.props.keepRatio;
    var dist = params.dist,
        scale = params.scale;
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function (_, ev) {
      var _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign(__assign({}, ev), {
        parentDist: null,
        parentScale: scale,
        parentKeepRatio: keepRatio,
        dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(fixedPosition, [clientX, clientY])
      });
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onScaleGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events: events
    });
    triggerEvent(moveable, "onScaleGroupEnd", nextParams);
    return isDrag;
  },

  /**
   * @method Moveable.Scalable#request
   * @param {object} [e] - the Resizable's request parameter
   * @param {number} [e.direction=[1, 1]] - Direction to scale
   * @param {number} [e.deltaWidth] - delta number of width
   * @param {number} [e.deltaHeight] - delta number of height
   * @return {Moveable.Requester} Moveable Requester
   * @example
    * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
   *
   * // requestStart
   * const requester = moveable.request("scalable");
   *
   * // request
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   * requester.request({ deltaWidth: 10, deltaHeight: 10 });
   *
   * // requestEnd
   * requester.requestEnd();
   */
  request: function () {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    return {
      isControl: true,
      requestStart: function (e) {
        return {
          datas: datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function (e) {
        distWidth += e.deltaWidth;
        distHeight += e.deltaHeight;
        return {
          datas: datas,
          parentDist: [distWidth, distHeight]
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether or not target can scaled. (default: false)
 * @name Moveable.Scalable#scalable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.scalable = true;
 */

/**
 * throttle of scaleX, scaleY when scale.
 * @name Moveable.Scalable#throttleScale
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.throttleScale = 0.1;
 */

/**
 * Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
 * @name Moveable.Scalable#renderDirections
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     scalable: true,
 *   renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
 * });
 *
 * moveable.renderDirections = ["nw", "ne", "sw", "se"];
 */

/**
 * When resize or scale, keeps a ratio of the width, height. (default: false)
 * @name Moveable.Scalable#keepRatio
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     scalable: true,
 * });
 *
 * moveable.keepRatio = true;
 */

/**
 * When the scale starts, the scaleStart event is called.
 * @memberof Moveable.Scalable
 * @event scaleStart
 * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scaleStart", ({ target }) => {
 *     console.log(target);
 * });
 */

/**
 * When scaling, the scale event is called.
 * @memberof Moveable.Scalable
 * @event scale
 * @param {Moveable.Scalable.OnScale} - Parameters for the scale event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scale", ({ target, transform, dist }) => {
 *     target.style.transform = transform;
 * });
 */

/**
 * When the scale finishes, the scaleEnd event is called.
 * @memberof Moveable.Scalable
 * @event scaleEnd
 * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the scaleEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { scalable: true });
 * moveable.on("scaleEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

/**
* When the group scale starts, the `scaleGroupStart` event is called.
* @memberof Moveable.Scalable
* @event scaleGroupStart
* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     scalable: true
* });
* moveable.on("scaleGroupStart", ({ targets }) => {
*     console.log("onScaleGroupStart", targets);
* });
*/

/**
* When the group scale, the `scaleGroup` event is called.
* @memberof Moveable.Scalable
* @event scaleGroup
* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     target: [].slice.call(document.querySelectorAll(".target")),
*     scalable: true
* });
* moveable.on("scaleGroup", ({ targets, events }) => {
*     console.log("onScaleGroup", targets);
*     events.forEach(ev => {
*         const target = ev.target;
*         // ev.drag is a drag event that occurs when the group scale.
*         const left = ev.drag.beforeDist[0];
*         const top = ev.drag.beforeDist[1];
*         const scaleX = ev.scale[0];
*         const scaleY = ev.scale[1];
*     });
* });
*/

/**
 * When the group scale finishes, the `scaleGroupEnd` event is called.
 * @memberof Moveable.Scalable
 * @event scaleGroupEnd
 * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 *     scalable: true
 * });
 * moveable.on("scaleGroupEnd", ({ targets, isDrag }) => {
 *     console.log("onScaleGroupEnd", targets, isDrag);
 * });
 */

function getMiddleLinePos(pos1, pos2) {
  return pos1.map(function (pos, i) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.dot)(pos, pos2[i], 1, 2);
  });
}

function getTriangleRad(pos1, pos2, pos3) {
  // pos1 Rad
  var rad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos2);
  var rad2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(pos1, pos3);
  var rad = rad2 - rad1;
  return rad >= 0 ? rad : rad + 2 * Math.PI;
}

function isValidPos(poses1, poses2) {
  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);
  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);
  var pi = Math.PI;

  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {
    return false;
  }

  return true;
}
/**
 * @namespace Moveable.Warpable
 * @description Warpable indicates whether the target can be warped(distorted, bented).
 */


var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        warpable = _a.warpable,
        zoom = _a.zoom;

    if (resizable || scalable || !warpable) {
      return [];
    }

    var _b = moveable.state,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4;
    var linePosFrom1 = getMiddleLinePos(pos1, pos2);
    var linePosFrom2 = getMiddleLinePos(pos2, pos1);
    var linePosFrom3 = getMiddleLinePos(pos1, pos3);
    var linePosFrom4 = getMiddleLinePos(pos3, pos1);
    var linePosTo1 = getMiddleLinePos(pos3, pos4);
    var linePosTo2 = getMiddleLinePos(pos4, pos3);
    var linePosTo3 = getMiddleLinePos(pos2, pos4);
    var linePosTo4 = getMiddleLinePos(pos4, pos2);
    return __spreadArray([React.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(linePosFrom1, linePosTo1, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(linePosFrom2, linePosTo2, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(linePosFrom3, linePosTo3, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(linePosFrom4, linePosTo4, zoom)
    })], renderAllDirections(moveable, React));
  },
  dragControlCondition: function (moveable, e) {
    if (e.isRequest) {
      return false;
    }

    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(e.inputEvent.target, prefix("direction"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        inputEvent = e.inputEvent;
    var target = moveable.props.target;
    var inputTarget = inputEvent.target;
    var direction = getDirection(inputTarget);

    if (!direction || !target) {
      return false;
    }

    var state = moveable.state;
    var transformOrigin = state.transformOrigin,
        is3d = state.is3d,
        targetTransform = state.targetTransform,
        targetMatrix = state.targetMatrix,
        width = state.width,
        height = state.height,
        left = state.left,
        top = state.top;
    datas.datas = {};
    datas.targetTransform = targetTransform;
    datas.warpTargetMatrix = is3d ? targetMatrix : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertDimension)(targetMatrix, 3, 4);
    datas.targetInverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.ignoreDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(datas.warpTargetMatrix, 4), 3, 4);
    datas.direction = direction;
    datas.left = left;
    datas.top = top;
    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function (p) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(p, transformOrigin);
    });
    datas.nextPoses = datas.poses.map(function (_a) {
      var x = _a[0],
          y = _a[1];
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.calculate)(datas.warpTargetMatrix, [x, y, 0, 1], 4);
    });
    datas.startValue = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(4);
    datas.prevMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(4);
    datas.absolutePoses = getAbsolutePosesByState(state);
    datas.posIndexes = getPosIndexesByDirection(direction);
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "matrix3d");
    state.snapRenderInfo = {
      request: e.isRequest,
      direction: direction
    };
    var params = fillParams(moveable, e, __assign({
      set: function (matrix) {
        datas.startValue = matrix;
      }
    }, fillTransformStartEvent(e)));
    var result = triggerEvent(moveable, "onWarpStart", params);

    if (result !== false) {
      datas.isWarp = true;
    }

    return datas.isWarp;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        isRequest = e.isRequest;
    var distX = e.distX,
        distY = e.distY;
    var targetInverseMatrix = datas.targetInverseMatrix,
        prevMatrix = datas.prevMatrix,
        isWarp = datas.isWarp,
        startValue = datas.startValue,
        poses = datas.poses,
        posIndexes = datas.posIndexes,
        absolutePoses = datas.absolutePoses;

    if (!isWarp) {
      return false;
    }

    resolveTransformEvent(e, "matrix3d");

    if (hasGuidelines(moveable, "warpable")) {
      var selectedPoses = posIndexes.map(function (index) {
        return absolutePoses[index];
      });

      if (selectedPoses.length > 1) {
        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);
      }

      var _a = checkMoveableSnapBounds(moveable, isRequest, {
        horizontal: selectedPoses.map(function (pos) {
          return pos[1] + distY;
        }),
        vertical: selectedPoses.map(function (pos) {
          return pos[0] + distX;
        })
      }),
          horizontalSnapInfo = _a.horizontal,
          verticalSnapInfo = _a.vertical;

      distY -= horizontalSnapInfo.offset;
      distX -= verticalSnapInfo.offset;
    }

    var dist = getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }, true);
    var nextPoses = datas.nextPoses.slice();
    posIndexes.forEach(function (index) {
      nextPoses[index] = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(nextPoses[index], dist);
    });

    if (!NEARBY_POS.every(function (nearByPoses) {
      return isValidPos(nearByPoses.map(function (i) {
        return poses[i];
      }), nearByPoses.map(function (i) {
        return nextPoses[i];
      }));
    })) {
      return false;
    }

    var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createWarpMatrix)(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);

    if (!h.length) {
      return false;
    } // B * A * M


    var afterMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(targetInverseMatrix, h, 4); // B * M * A

    var matrix = getTransfromMatrix(datas, afterMatrix, true);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.invert)(prevMatrix, 4), matrix, 4);
    datas.prevMatrix = matrix;
    var totalMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(startValue, matrix, 4);
    var nextTransform = convertTransformFormat(datas, "matrix3d(" + totalMatrix.join(", ") + ")", "matrix3d(" + matrix.join(", ") + ")");
    fillOriginalTransform(e, nextTransform);
    triggerEvent(moveable, "onWarp", fillParams(moveable, e, {
      delta: delta,
      matrix: totalMatrix,
      dist: matrix,
      multiply: _scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply,
      transform: nextTransform
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isWarp) {
      return false;
    }

    datas.isWarp = false;
    triggerEvent(moveable, "onWarpEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  }
};
/**
 * Whether or not target can be warped. (default: false)
 * @name Moveable.Warpable#warpable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.warpable = true;
 */

/**
* Set directions to show the control box. (default: ["n", "nw", "ne", "s", "se", "sw", "e", "w"])
* @name Moveable.Warpable#renderDirections
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     warpable: true,
*     renderDirections: ["n", "nw", "ne", "s", "se", "sw", "e", "w"],
* });
*
* moveable.renderDirections = ["nw", "ne", "sw", "se"];
*/

/**
* When the warp starts, the warpStart event is called.
* @memberof Moveable.Warpable
* @event warpStart
* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, { warpable: true });
* moveable.on("warpStart", ({ target }) => {
*     console.log(target);
* });
*/

/**
 * When warping, the warp event is called.
 * @memberof Moveable.Warpable
 * @event warp
 * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event
 * @example
 * import Moveable from "moveable";
 * let matrix = [
 *  1, 0, 0, 0,
 *  0, 1, 0, 0,
 *  0, 0, 1, 0,
 *  0, 0, 0, 1,
 * ];
 * const moveable = new Moveable(document.body, { warpable: true });
 * moveable.on("warp", ({ target, transform, delta, multiply }) => {
 *    // target.style.transform = transform;
 *    matrix = multiply(matrix, delta);
 *    target.style.transform = `matrix3d(${matrix.join(",")})`;
 * });
 */

/**
 * When the warp finishes, the warpEnd event is called.
 * @memberof Moveable.Warpable
 * @event warpEnd
 * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, { warpable: true });
 * moveable.on("warpEnd", ({ target, isDrag }) => {
 *     console.log(target, isDrag);
 * });
 */

var AREA_PIECES = /*#__PURE__*/prefix("area-pieces");
var AREA_PIECE = /*#__PURE__*/prefix("area-piece");
var AVOID = /*#__PURE__*/prefix("avoid");

function restoreStyle(moveable) {
  var el = moveable.areaElement;
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.removeClass)(el, AVOID);
  el.style.cssText += "left: 0px; top: 0px; width: " + width + "px; height: " + height + "px";
}

function renderPieces(React) {
  return React.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }));
}

var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function (moveable, React) {
    var _a = moveable.props,
        target = _a.target,
        dragArea = _a.dragArea,
        groupable = _a.groupable,
        passDragArea = _a.passDragArea;
    var _b = moveable.state,
        width = _b.width,
        height = _b.height,
        renderPoses = _b.renderPoses;
    var className = passDragArea ? prefix("area", "pass") : prefix("area");

    if (groupable) {
      return [React.createElement("div", {
        key: "area",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(moveable, "areaElement"),
        className: className
      }), renderPieces(React)];
    }

    if (!target || !dragArea) {
      return [];
    }

    var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createWarpMatrix)([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);
    var transform = h.length ? makeMatrixCSS(h, true) : "none";
    return [React.createElement("div", {
      key: "area",
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(moveable, "areaElement"),
      className: className,
      style: {
        top: "0px",
        left: "0px",
        width: width + "px",
        height: height + "px",
        transformOrigin: "0 0",
        transform: transform
      }
    }), renderPieces(React)];
  },
  dragStart: function (moveable, _a) {
    var datas = _a.datas,
        clientX = _a.clientX,
        clientY = _a.clientY,
        inputEvent = _a.inputEvent;

    if (!inputEvent) {
      return false;
    }

    datas.isDragArea = false;
    var areaElement = moveable.areaElement;
    var state = moveable.state;
    var moveableClientRect = state.moveableClientRect,
        renderPoses = state.renderPoses,
        rootMatrix = state.rootMatrix,
        is3d = state.is3d;
    var left = moveableClientRect.left,
        top = moveableClientRect.top;

    var _b = getRect(renderPoses),
        relativeLeft = _b.left,
        relativeTop = _b.top,
        width = _b.width,
        height = _b.height;

    var n = is3d ? 4 : 3;

    var _c = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n),
        posX = _c[0],
        posY = _c[1];

    posX -= relativeLeft;
    posY -= relativeTop;
    var rects = [{
      left: relativeLeft,
      top: relativeTop,
      width: width,
      height: posY - 10
    }, {
      left: relativeLeft,
      top: relativeTop,
      width: posX - 10,
      height: height
    }, {
      left: relativeLeft,
      top: relativeTop + posY + 10,
      width: width,
      height: height - posY - 10
    }, {
      left: relativeLeft + posX + 10,
      top: relativeTop,
      width: width - posX - 10,
      height: height
    }];
    var children = [].slice.call(areaElement.nextElementSibling.children);
    rects.forEach(function (rect, i) {
      children[i].style.cssText = "left: " + rect.left + "px;top: " + rect.top + "px; width: " + rect.width + "px; height: " + rect.height + "px;";
    });
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.addClass)(areaElement, AVOID);
    state.disableNativeEvent = true;
    return;
  },
  drag: function (moveable, _a) {
    var datas = _a.datas,
        inputEvent = _a.inputEvent;
    this.enableNativeEvent(moveable);

    if (!inputEvent) {
      return false;
    }

    if (!datas.isDragArea) {
      datas.isDragArea = true;
      restoreStyle(moveable);
    }
  },
  dragEnd: function (moveable, e) {
    this.enableNativeEvent(moveable);
    var inputEvent = e.inputEvent,
        datas = e.datas;

    if (!inputEvent) {
      return false;
    }

    if (!datas.isDragArea) {
      restoreStyle(moveable);
    }
  },
  dragGroupStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragGroup: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragGroupEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  unset: function (moveable) {
    restoreStyle(moveable);
    moveable.state.disableNativeEvent = false;
  },
  enableNativeEvent: function (moveable) {
    var state = moveable.state;

    if (state.disableNativeEvent) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.requestAnimationFrame)(function () {
        state.disableNativeEvent = false;
      });
    }
  }
};
/**
 * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)
 * @name Moveable#dragArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  dragArea: false,
 * });
 */

/**
 * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)
 * @name Moveable#passDragArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  dragArea: false,
 * });
 */

var Origin = makeAble("origin", {
  render: function (moveable, React) {
    var zoom = moveable.props.zoom;
    var _a = moveable.state,
        beforeOrigin = _a.beforeOrigin,
        rotation = _a.rotation;
    return [React.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(rotation, zoom, beforeOrigin),
      key: "beforeOrigin"
    })];
  }
});
/**
 * Whether or not the origin controlbox will be visible or not (default: true)
 * @name Moveable#origin
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 *
 * moveable.origin = true;
 */

function getDefaultScrollPosition(e) {
  var scrollContainer = e.scrollContainer;
  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];
}
/**
 * @namespace Moveable.Scrollable
 * @description Whether or not target can be scrolled to the scroll container (default: false)
 */


var Scrollable = {
  name: "scrollable",
  canPinch: true,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragRelation: "strong",
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.scrollContainer,
        scrollContainer = _a === void 0 ? moveable.getContainer() : _a;
    var dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__["default"]();
    var scrollContainerElement = getRefTarget(scrollContainer, true);
    e.datas.dragScroll = dragScroll;
    var gestoName = e.isControl ? "controlGesto" : "targetGesto";
    var targets = e.targets;
    dragScroll.on("scroll", function (_a) {
      var container = _a.container,
          direction = _a.direction;
      var params = fillParams(moveable, e, {
        scrollContainer: container,
        direction: direction
      });
      var eventName = targets ? "onScrollGroup" : "onScroll";

      if (targets) {
        params.targets = targets;
      }

      triggerEvent(moveable, eventName, params);
    }).on("move", function (_a) {
      var offsetX = _a.offsetX,
          offsetY = _a.offsetY;
      moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);
    });
    dragScroll.dragStart(e, {
      container: scrollContainerElement
    });
  },
  checkScroll: function (moveable, e) {
    var dragScroll = e.datas.dragScroll;

    if (!dragScroll) {
      return;
    }

    var _a = moveable.props,
        _b = _a.scrollContainer,
        scrollContainer = _b === void 0 ? moveable.getContainer() : _b,
        _c = _a.scrollThreshold,
        scrollThreshold = _c === void 0 ? 0 : _c,
        _d = _a.getScrollPosition,
        getScrollPosition = _d === void 0 ? getDefaultScrollPosition : _d;
    dragScroll.drag(e, {
      container: scrollContainer,
      threshold: scrollThreshold,
      getScrollPosition: function (ev) {
        return getScrollPosition({
          scrollContainer: ev.container,
          direction: ev.direction
        });
      }
    });
    return true;
  },
  drag: function (moveable, e) {
    return this.checkScroll(moveable, e);
  },
  dragEnd: function (moveable, e) {
    e.datas.dragScroll.dragEnd();
    e.datas.dragScroll = null;
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      isControl: true
    }));
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroup: function (moveable, e) {
    return this.drag(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupEnd: function (moveable, e) {
    return this.dragEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragStart(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets,
      isControl: true
    }));
  },
  dragGroupContro: function (moveable, e) {
    return this.drag(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControEnd: function (moveable, e) {
    return this.dragEnd(moveable, __assign(__assign({}, e), {
      targets: moveable.props.targets
    }));
  }
};
/**
 * Whether or not target can be scrolled to the scroll container (default: false)
 * @name Moveable.Scrollable#scrollable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 *
 * moveable.scrollable = true;
 */

/**
 * The container to which scroll is applied (default: container)
 * @name Moveable.Scrollable#scrollContainer
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 */

/**
 * Expand the range of the scroll check area. (default: 0)
 * @name Moveable.Scrollable#scrollThreshold
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 */

/**
 * Sets a function to get the scroll position. (default: Function)
 * @name Moveable.Scrollable#getScrollPosition
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   scrollable: true,
 *   scrollContainer: document.body,
 *   scrollThreshold: 0,
 *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),
 * });
 *
 */

/**
 * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.
 * @memberof Moveable.Scrollable
 * @event scroll
 * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("scroll", ({ scrollContainer, direction }) => {
 *   scrollContainer.scrollLeft += direction[0] * 10;
 *   scrollContainer.scrollTop += direction[1] * 10;
 * });
 */

/**
 * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.
 * @memberof Moveable.Scrollable
 * @event scrollGroup
 * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("scroll", ({ scrollContainer, direction }) => {
 *   scrollContainer.scrollLeft += direction[0] * 10;
 *   scrollContainer.scrollTop += direction[1] * 10;
 * });
 */

var Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    useResizeObserver: Boolean,
    zoom: Number,
    transformOrigin: Array,
    edge: Boolean,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    hideDefaultLines: Boolean,
    props: Object
  },
  events: {}
};

var Padding = makeAble("padding", {
  render: function (moveable, React) {
    var props = moveable.props;

    if (props.dragArea) {
      return [];
    }

    var padding = props.padding || {};
    var _a = padding.left,
        left = _a === void 0 ? 0 : _a,
        _b = padding.top,
        top = _b === void 0 ? 0 : _b,
        _c = padding.right,
        right = _c === void 0 ? 0 : _c,
        _d = padding.bottom,
        bottom = _d === void 0 ? 0 : _d;
    var _e = moveable.state,
        renderPoses = _e.renderPoses,
        pos1 = _e.pos1,
        pos2 = _e.pos2,
        pos3 = _e.pos3,
        pos4 = _e.pos4;
    var poses = [pos1, pos2, pos3, pos4];
    var paddingDirections = [];

    if (left > 0) {
      paddingDirections.push([0, 2]);
    }

    if (top > 0) {
      paddingDirections.push([0, 1]);
    }

    if (right > 0) {
      paddingDirections.push([1, 3]);
    }

    if (bottom > 0) {
      paddingDirections.push([2, 3]);
    }

    return paddingDirections.map(function (_a, i) {
      var dir1 = _a[0],
          dir2 = _a[1];
      var paddingPos1 = poses[dir1];
      var paddingPos2 = poses[dir2];
      var paddingPos3 = renderPoses[dir1];
      var paddingPos4 = renderPoses[dir2];
      var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createWarpMatrix)([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);

      if (!h.length) {
        return undefined;
      }

      return React.createElement("div", {
        key: "padding" + i,
        className: prefix("padding"),
        style: {
          transform: makeMatrixCSS(h, true)
        }
      });
    });
  }
});
/**
 * Add padding around the target to increase the drag area. (default: null)
 * @name Moveable#padding
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  target: document.querySelector(".target"),
 *  padding: { left: 0, top: 0, right: 0, bottom: 0 },
 * });
 * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },
 * moveable.updateRect();
 */

var RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];

function calculateRatio(values, size) {
  var sumSize = values[0] + values[1];
  var sumRatio = sumSize > size ? size / sumSize : 1;
  values[0] *= sumRatio;
  values[1] = size - values[1] * sumRatio;
  return values;
}

var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];
var VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];
var HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];
var VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];
function getRadiusStyles(poses, controlPoses, isRelative, width, height, left, top, right, bottom) {
  if (left === void 0) {
    left = 0;
  }

  if (top === void 0) {
    top = 0;
  }

  if (right === void 0) {
    right = width;
  }

  if (bottom === void 0) {
    bottom = height;
  }

  var clipStyles = [];
  var isVertical = false;
  var raws = poses.map(function (pos, i) {
    var _a = controlPoses[i],
        horizontal = _a.horizontal,
        vertical = _a.vertical;

    if (vertical && !isVertical) {
      isVertical = true;
      clipStyles.push("/");
    }

    if (isVertical) {
      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);
      clipStyles.push(convertCSSSize(rawPos, height, isRelative));
      return rawPos;
    } else {
      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);
      clipStyles.push(convertCSSSize(rawPos, width, isRelative));
      return rawPos;
    }
  });
  return {
    styles: clipStyles,
    raws: raws
  };
}
function getRadiusRange(controlPoses) {
  // [start, length]
  var horizontalRange = [0, 0];
  var verticalRange = [0, 0];
  var length = controlPoses.length;

  for (var i = 0; i < length; ++i) {
    var clipPose = controlPoses[i];

    if (!clipPose.sub) {
      continue;
    }

    if (clipPose.horizontal) {
      if (horizontalRange[1] === 0) {
        horizontalRange[0] = i;
      }

      horizontalRange[1] = i - horizontalRange[0] + 1;
      verticalRange[0] = i + 1;
    }

    if (clipPose.vertical) {
      if (verticalRange[1] === 0) {
        verticalRange[0] = i;
      }

      verticalRange[1] = i - verticalRange[0] + 1;
    }
  }

  return {
    horizontalRange: horizontalRange,
    verticalRange: verticalRange
  };
}
function getRadiusValues(values, width, height, left, top, minCounts) {
  var _a, _b, _c, _d;

  if (minCounts === void 0) {
    minCounts = [0, 0];
  }

  var splitIndex = values.indexOf("/");
  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;
  var horizontalValues = values.slice(0, splitLength);
  var verticalValues = values.slice(splitLength + 1);
  var _e = horizontalValues[0],
      nwValue = _e === void 0 ? "0px" : _e,
      _f = horizontalValues[1],
      neValue = _f === void 0 ? nwValue : _f,
      _g = horizontalValues[2],
      seValue = _g === void 0 ? nwValue : _g,
      _h = horizontalValues[3],
      swValue = _h === void 0 ? neValue : _h;
  var _j = verticalValues[0],
      wnValue = _j === void 0 ? nwValue : _j,
      _k = verticalValues[1],
      enValue = _k === void 0 ? wnValue : _k,
      _l = verticalValues[2],
      esValue = _l === void 0 ? wnValue : _l,
      _m = verticalValues[3],
      wsValue = _m === void 0 ? enValue : _m;
  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(pos, width);
  });
  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function (pos) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(pos, height);
  });
  var horizontalPoses = horizontalRawPoses.slice();
  var verticalPoses = verticalRawPoses.slice();
  _a = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a[0], horizontalPoses[1] = _a[1];
  _b = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];
  _c = calculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];
  _d = calculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];
  var nextHorizontalPoses = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));
  var nextVerticalPoses = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));
  return __spreadArray(__spreadArray([], nextHorizontalPoses.map(function (pos, i) {
    var direction = RADIUS_DIRECTIONS[i];
    return {
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
      vertical: 0,
      pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],
      sub: true,
      raw: horizontalRawPoses[i],
      direction: direction
    };
  })), nextVerticalPoses.map(function (pos, i) {
    var direction = RADIUS_DIRECTIONS[i];
    return {
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[i],
      pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],
      sub: true,
      raw: verticalRawPoses[i],
      direction: direction
    };
  }));
}
function removeRadiusPos(controlPoses, poses, index, startIndex, length) {
  if (length === void 0) {
    length = poses.length;
  }

  var _a = getRadiusRange(controlPoses.slice(startIndex)),
      horizontalRange = _a.horizontalRange,
      verticalRange = _a.verticalRange;

  var radiuslIndex = index - startIndex;
  var deleteCount = 0;

  if (radiuslIndex === 0) {
    deleteCount = length;
  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {
    deleteCount = horizontalRange[1] - radiuslIndex;
  } else if (radiuslIndex >= verticalRange[0]) {
    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;
  } else {
    return;
  }

  controlPoses.splice(index, deleteCount);
  poses.splice(index, deleteCount);
}
function addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {
  if (left === void 0) {
    left = 0;
  }

  if (top === void 0) {
    top = 0;
  }

  var _a = getRadiusRange(controlPoses.slice(startIndex)),
      horizontalRange = _a.horizontalRange,
      verticalRange = _a.verticalRange;

  if (horizontalIndex > -1) {
    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;

    for (var i = horizontalRange[1]; i <= horizontalIndex; ++i) {
      var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;
      var x = 0;

      if (horizontalIndex === i) {
        x = distX;
      } else if (i === 0) {
        x = left + radiusX;
      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {
        x = right - (poses[startIndex][0] - left);
      }

      controlPoses.splice(startIndex + i, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
        vertical: 0,
        pos: [x, y]
      });
      poses.splice(startIndex + i, 0, [x, y]);

      if (i === 0) {
        break;
      }
    }
  } else if (verticalIndex > -1) {
    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;

    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {
      var pos = [left + radiusY, top];
      controlPoses.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos: pos
      });
      poses.push(pos);
    }

    var startVerticalIndex = verticalRange[0];

    for (var i = verticalRange[1]; i <= verticalIndex; ++i) {
      var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;
      var y = 0;

      if (verticalIndex === i) {
        y = distY;
      } else if (i === 0) {
        y = top + radiusY;
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {
        y = poses[startIndex + startVerticalIndex][1];
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {
        y = bottom - (poses[startIndex + startVerticalIndex][1] - top);
      }

      controlPoses.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[i],
        pos: [x, y]
      });
      poses.push([x, y]);

      if (i === 0) {
        break;
      }
    }
  }
}
function splitRadiusPoses(controlPoses, raws) {
  if (raws === void 0) {
    raws = controlPoses.map(function (pos) {
      return pos.raw;
    });
  }

  var horizontals = controlPoses.map(function (pos, i) {
    return pos.horizontal ? raws[i] : null;
  }).filter(function (pos) {
    return pos != null;
  });
  var verticals = controlPoses.map(function (pos, i) {
    return pos.vertical ? raws[i] : null;
  }).filter(function (pos) {
    return pos != null;
  });
  return {
    horizontals: horizontals,
    verticals: verticals
  };
}

var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]];
var CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]]; // 1 2 5 6 0 3 4 7
// 0 1 2 3 4 5 6 7

function getClipStyles(moveable, clipPath, poses) {
  var clipRelative = moveable.props.clipRelative;
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  var _b = clipPath,
      clipType = _b.type,
      clipPoses = _b.poses;
  var isRect = clipType === "rect";
  var isCircle = clipType === "circle";

  if (clipType === "polygon") {
    return poses.map(function (pos) {
      return convertCSSSize(pos[0], width, clipRelative) + " " + convertCSSSize(pos[1], height, clipRelative);
    });
  } else if (isRect || clipType === "inset") {
    var top = poses[1][1];
    var right = poses[3][0];
    var left = poses[7][0];
    var bottom = poses[5][1];

    if (isRect) {
      return [top, right, bottom, left].map(function (pos) {
        return pos + "px";
      });
    }

    var clipStyles = [top, width - right, height - bottom, left].map(function (pos, i) {
      return convertCSSSize(pos, i % 2 ? width : height, clipRelative);
    });

    if (poses.length > 8) {
      var _c = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(poses[4], poses[0]),
          subWidth = _c[0],
          subHeight = _c[1];

      clipStyles.push.apply(clipStyles, __spreadArray(["round"], getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left, top, right, bottom).styles));
    }

    return clipStyles;
  } else if (isCircle || clipType === "ellipse") {
    var center = poses[0];
    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);
    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];
    clipStyles.push("at", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));
    return clipStyles;
  }
}

function getRectPoses(top, right, bottom, left) {
  var xs = [left, (left + right) / 2, right];
  var ys = [top, (top + bottom) / 2, bottom];
  return CLIP_RECT_DIRECTIONS.map(function (_a) {
    var dirx = _a[0],
        diry = _a[1],
        dir = _a[2];
    var x = xs[dirx + 1];
    var y = ys[diry + 1];
    return {
      vertical: Math.abs(diry),
      horizontal: Math.abs(dirx),
      direction: dir,
      pos: [x, y]
    };
  });
}

function getClipPath(target, width, height, defaultClip, customClip) {
  var _a, _b, _c, _d, _e, _f, _g;

  var clipText = customClip;

  if (!clipText) {
    var style = getComputedStyle(target);
    var clipPath = style.clipPath;
    clipText = clipPath !== "none" ? clipPath : style.clip;
  }

  if (!clipText || clipText === "none" || clipText === "auto") {
    clipText = defaultClip;

    if (!clipText) {
      return;
    }
  }

  var _h = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitBracket)(clipText),
      _j = _h.prefix,
      clipPrefix = _j === void 0 ? clipText : _j,
      _k = _h.value,
      value = _k === void 0 ? "" : _k;

  var isCircle = clipPrefix === "circle";
  var splitter = " ";

  if (clipPrefix === "polygon") {
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitComma)(value || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    splitter = ",";
    var poses = values.map(function (pos) {
      var _a = pos.split(" "),
          xPos = _a[0],
          yPos = _a[1];

      return {
        vertical: 1,
        horizontal: 1,
        pos: [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(xPos, width), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(yPos, height)]
      };
    });
    return {
      type: clipPrefix,
      clipText: clipText,
      poses: poses,
      splitter: splitter
    };
  } else if (isCircle || clipPrefix === "ellipse") {
    var xPos = "";
    var yPos = "";
    var radiusX_1 = 0;
    var radiusY_1 = 0;
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(value);

    if (isCircle) {
      var radius = "";
      _a = values[0], radius = _a === void 0 ? "50%" : _a, _b = values[2], xPos = _b === void 0 ? "50%" : _b, _c = values[3], yPos = _c === void 0 ? "50%" : _c;
      radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(radius, Math.sqrt((width * width + height * height) / 2));
      radiusY_1 = radiusX_1;
    } else {
      var xRadius = "";
      var yRadius = "";
      _d = values[0], xRadius = _d === void 0 ? "50%" : _d, _e = values[1], yRadius = _e === void 0 ? "50%" : _e, _f = values[3], xPos = _f === void 0 ? "50%" : _f, _g = values[4], yPos = _g === void 0 ? "50%" : _g;
      radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(xRadius, width);
      radiusY_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(yRadius, height);
    }

    var centerPos_1 = [(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(xPos, width), (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(yPos, height)];

    var poses = __spreadArray([{
      vertical: 1,
      horizontal: 1,
      pos: centerPos_1,
      direction: "nesw"
    }], CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function (dir) {
      return {
        vertical: Math.abs(dir[1]),
        horizontal: dir[0],
        direction: dir[2],
        sub: true,
        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]
      };
    }));

    return {
      type: clipPrefix,
      clipText: clipText,
      radiusX: radiusX_1,
      radiusY: radiusY_1,
      left: centerPos_1[0] - radiusX_1,
      top: centerPos_1[1] - radiusY_1,
      poses: poses,
      splitter: splitter
    };
  } else if (clipPrefix === "inset") {
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(value || "0 0 0 0");
    var roundIndex = values.indexOf("round");
    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;
    var radiusValues = values.slice(rectLength + 1);

    var _l = values.slice(0, rectLength),
        topValue = _l[0],
        _m = _l[1],
        rightValue = _m === void 0 ? topValue : _m,
        _o = _l[2],
        bottomValue = _o === void 0 ? topValue : _o,
        _p = _l[3],
        leftValue = _p === void 0 ? rightValue : _p;

    var _q = [topValue, bottomValue].map(function (pos) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(pos, height);
    }),
        top = _q[0],
        bottom = _q[1];

    var _r = [leftValue, rightValue].map(function (pos) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)(pos, width);
    }),
        left = _r[0],
        right = _r[1];

    var nextRight = width - right;
    var nextBottom = height - bottom;
    var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top, left, top);

    var poses = __spreadArray(__spreadArray([], getRectPoses(top, nextRight, nextBottom, left)), radiusPoses);

    return {
      type: "inset",
      clipText: clipText,
      poses: poses,
      top: top,
      left: left,
      right: nextRight,
      bottom: nextBottom,
      radius: radiusValues,
      splitter: splitter
    };
  } else if (clipPrefix === "rect") {
    // top right bottom left
    var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitComma)(value || "0px, " + width + "px, " + height + "px, 0px");
    splitter = ",";

    var _s = values.map(function (pos) {
      var posValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitUnit)(pos).value;
      return posValue;
    }),
        top = _s[0],
        right = _s[1],
        bottom = _s[2],
        left = _s[3];

    var poses = getRectPoses(top, right, bottom, left);
    return {
      type: "rect",
      clipText: clipText,
      poses: poses,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      values: values,
      splitter: splitter
    };
  }

  return;
}

function addClipPath(moveable, e) {
  var _a = calculatePointerDist(moveable, e),
      distX = _a[0],
      distY = _a[1];

  var _b = e.datas,
      clipPath = _b.clipPath,
      index = _b.index;
  var _c = clipPath,
      clipType = _c.type,
      clipPoses = _c.poses,
      splitter = _c.splitter;
  var poses = clipPoses.map(function (pos) {
    return pos.pos;
  });

  if (clipType === "polygon") {
    poses.splice(index, 0, [distX, distY]);
  } else if (clipType === "inset") {
    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);
    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);
    var length = clipPoses.length;
    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);

    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }

  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "added",
    clipType: clipType,
    poses: poses,
    clipStyles: clipStyles,
    clipStyle: clipType + "(" + clipStyles.join(splitter) + ")",
    distX: 0,
    distY: 0
  }));
}

function removeClipPath(moveable, e) {
  var _a = e.datas,
      clipPath = _a.clipPath,
      index = _a.index;
  var _b = clipPath,
      clipType = _b.type,
      clipPoses = _b.poses,
      splitter = _b.splitter;
  var poses = clipPoses.map(function (pos) {
    return pos.pos;
  });
  var length = poses.length;

  if (clipType === "polygon") {
    clipPoses.splice(index, 1);
    poses.splice(index, 1);
  } else if (clipType === "inset") {
    if (index < 8) {
      return;
    }

    removeRadiusPos(clipPoses, poses, index, 8, length);

    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }

  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "removed",
    clipType: clipType,
    poses: poses,
    clipStyles: clipStyles,
    clipStyle: clipType + "(" + clipStyles.join(splitter) + ")",
    distX: 0,
    distY: 0
  }));
}
/**
 * @namespace Moveable.Clippable
 * @description Whether to clip the target.
 */


var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"],
  render: function (moveable, React) {
    var _a = moveable.props,
        customClipPath = _a.customClipPath,
        defaultClipPath = _a.defaultClipPath,
        clipArea = _a.clipArea,
        zoom = _a.zoom;
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height,
        allMatrix = _b.allMatrix,
        is3d = _b.is3d,
        left = _b.left,
        top = _b.top,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4,
        clipPathState = _b.clipPathState,
        snapBoundInfos = _b.snapBoundInfos,
        rotationRad = _b.rotation;

    if (!target) {
      return [];
    }

    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", clipPathState || customClipPath);

    if (!clipPath) {
      return [];
    }

    var n = is3d ? 4 : 3;
    var type = clipPath.type;
    var clipPoses = clipPath.poses;
    var poses = clipPoses.map(function (pos) {
      // return [x, y];
      var calculatedPos = calculatePosition(allMatrix, pos.pos, n);
      return [calculatedPos[0] - left, calculatedPos[1] - top];
    });
    var controls = [];
    var lines = [];
    var isRect = type === "rect";
    var isInset = type === "inset";
    var isPolygon = type === "polygon";

    if (isRect || isInset || isPolygon) {
      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;
      lines = linePoses_1.map(function (to, i) {
        var from = i === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i - 1];
        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getRad)(from, to);
        var dist = getDiagonalSize(from, to);
        return React.createElement("div", {
          key: "clipLine" + i,
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": i,
          style: {
            width: dist + "px",
            transform: "translate(" + from[0] + "px, " + from[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")"
          }
        });
      });
    }

    controls = poses.map(function (pos, i) {
      return React.createElement("div", {
        key: "clipControl" + i,
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": i,
        style: {
          transform: "translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rotationRad + "rad) scale(" + zoom + ")"
        }
      });
    });

    if (isInset) {
      controls.push.apply(controls, poses.slice(8).map(function (pos, i) {
        return React.createElement("div", {
          key: "clipRadiusControl" + i,
          className: prefix("control", "clip-control", "clip-radius", "snap-control"),
          "data-clip-index": 8 + i,
          style: {
            transform: "translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rotationRad + "rad) scale(" + zoom + ")"
          }
        });
      }));
    }

    if (type === "circle" || type === "ellipse") {
      var clipLeft = clipPath.left,
          clipTop = clipPath.top,
          radiusX = clipPath.radiusX,
          radiusY = clipPath.radiusY;

      var _c = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)),
          distLeft = _c[0],
          distTop = _c[1];

      var ellipseClipPath = "none";

      if (!clipArea) {
        var piece = Math.max(10, radiusX / 5, radiusY / 5);
        var areaPoses = [];

        for (var i = 0; i <= piece; ++i) {
          var rad = Math.PI * 2 / piece * i;
          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);
        }

        areaPoses.push([radiusX, -2]);
        areaPoses.push([-2, -2]);
        areaPoses.push([-2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, -2]);
        areaPoses.push([radiusX, -2]);
        ellipseClipPath = "polygon(" + areaPoses.map(function (pos) {
          return pos[0] + "px " + pos[1] + "px";
        }).join(", ") + ")";
      }

      controls.push(React.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: radiusX * 2 + "px",
          height: radiusY * 2 + "px",
          clipPath: ellipseClipPath,
          transform: "translate(" + (-left + distLeft) + "px, " + (-top + distTop) + "px) " + makeMatrixCSS(allMatrix)
        }
      }));
    }

    if (clipArea) {
      var _d = getRect(__spreadArray([pos1, pos2, pos3, pos4], poses)),
          allWidth = _d.width,
          allHeight = _d.height,
          allLeft_1 = _d.left,
          allTop_1 = _d.top;

      if (isPolygon || isRect || isInset) {
        var areaPoses = isInset ? poses.slice(0, 8) : poses;
        controls.push(React.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: allWidth + "px",
            height: allHeight + "px",
            transform: "translate(" + allLeft_1 + "px, " + allTop_1 + "px)",
            clipPath: "polygon(" + areaPoses.map(function (pos) {
              return pos[0] - allLeft_1 + "px " + (pos[1] - allTop_1) + "px";
            }).join(", ") + ")"
          }
        }));
      }
    }

    if (snapBoundInfos) {
      ["vertical", "horizontal"].forEach(function (directionType) {
        var info = snapBoundInfos[directionType];
        var isHorizontal = directionType === "horizontal";

        if (info.isSnap) {
          lines.push.apply(lines, info.snap.posInfos.map(function (_a, i) {
            var pos = _a.pos;
            var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip" + directionType + "snap" + i, "guideline");
          }));
        }

        if (info.isBound) {
          lines.push.apply(lines, info.bounds.map(function (_a, i) {
            var pos = _a.pos;
            var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip" + directionType + "bounds" + i, "guideline", "bounds", "bold");
          }));
        }
      });
    }

    return __spreadArray(__spreadArray([], controls), lines);
  },
  dragControlCondition: function (moveable, e) {
    return e.inputEvent && (e.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.dragWithClip,
        dragWithClip = _a === void 0 ? true : _a;

    if (dragWithClip) {
      return false;
    }

    return this.dragControlStart(moveable, e);
  },
  drag: function (moveable, e) {
    return this.dragControl(moveable, e);
  },
  dragEnd: function (moveable, e) {
    return this.dragControlEnd(moveable, e);
  },
  dragControlStart: function (moveable, e) {
    var state = moveable.state;
    var _a = moveable.props,
        defaultClipPath = _a.defaultClipPath,
        customClipPath = _a.customClipPath;
    var target = state.target,
        width = state.width,
        height = state.height;
    var inputTarget = e.inputEvent ? e.inputEvent.target : null;
    var className = inputTarget && inputTarget.getAttribute("class") || "";
    var datas = e.datas;
    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", customClipPath);

    if (!clipPath) {
      return false;
    }

    var clipText = clipPath.clipText,
        type = clipPath.type,
        poses = clipPath.poses;
    var result = triggerEvent(moveable, "onClipStart", fillParams(moveable, e, {
      clipType: type,
      clipStyle: clipText,
      poses: poses.map(function (pos) {
        return pos.pos;
      })
    }));

    if (result === false) {
      datas.isClipStart = false;
      return false;
    }

    datas.isControl = className && className.indexOf("clip-control") > -1;
    datas.isLine = className.indexOf("clip-line") > -1;
    datas.isArea = className.indexOf("clip-area") > -1 || className.indexOf("clip-ellipse") > -1;
    datas.index = inputTarget ? parseInt(inputTarget.getAttribute("data-clip-index"), 10) : -1;
    datas.clipPath = clipPath;
    datas.isClipStart = true;
    state.clipPathState = clipText;
    setDragStart(moveable, e);
    return true;
  },
  dragControl: function (moveable, e) {
    var _a;

    var datas = e.datas,
        originalDatas = e.originalDatas;

    if (!datas.isClipStart) {
      return false;
    }

    var _b = datas,
        isControl = _b.isControl,
        isLine = _b.isLine,
        isArea = _b.isArea,
        index = _b.index,
        clipPath = _b.clipPath;

    if (!clipPath) {
      return false;
    }

    var _c = getDragDist(e),
        distX = _c[0],
        distY = _c[1];

    var props = moveable.props;
    var state = moveable.state;
    var width = state.width,
        height = state.height;
    var isDragWithTarget = !isArea && !isControl && !isLine;
    var clipType = clipPath.type,
        clipPoses = clipPath.poses,
        splitter = clipPath.splitter;
    var poses = clipPoses.map(function (pos) {
      return pos.pos;
    });

    if (isDragWithTarget) {
      distX = -distX;
      distY = -distY;
    }

    var isAll = !isControl || clipPoses[index].direction === "nesw";
    var isRect = clipType === "inset" || clipType === "rect";
    var dists = clipPoses.map(function () {
      return [0, 0];
    });

    if (isControl && !isAll) {
      var _d = clipPoses[index],
          horizontal = _d.horizontal,
          vertical = _d.vertical;
      var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];
      dists = moveControlPos(clipPoses, index, dist, isRect);
    } else if (isAll) {
      dists = poses.map(function () {
        return [distX, distY];
      });
    }

    var nextPoses = poses.map(function (pos, i) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos, dists[i]);
    });

    var guidePoses = __spreadArray([], nextPoses);

    state.snapBoundInfos = null;
    var isCircle = clipPath.type === "circle";
    var isEllipse = clipPath.type === "ellipse";

    if (isCircle || isEllipse) {
      var guideRect = getRect(nextPoses);
      var ry = Math.abs(guideRect.bottom - guideRect.top);
      var rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);
      var bottom = nextPoses[0][1] + ry;
      var left = nextPoses[0][0] - rx;
      var right = nextPoses[0][0] + rx; // right

      if (isCircle) {
        guidePoses.push([right, guideRect.bottom]);
        dists.push([1, 0]);
      } // bottom


      guidePoses.push([guideRect.left, bottom]);
      dists.push([0, 1]); // left

      guidePoses.push([left, guideRect.bottom]);
      dists.push([1, 0]);
    }

    var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function (v) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)("" + v, height);
    }), (props.clipVerticalGuidelines || []).map(function (v) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.convertUnitSize)("" + v, width);
    }), width, height);
    var guideXPoses = [];
    var guideYPoses = [];

    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];
      guideXPoses = rectPoses.filter(function (_, i) {
        return rectDists_1[i][0];
      }).map(function (pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.filter(function (_, i) {
        return rectDists_1[i][1];
      }).map(function (pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.filter(function (_, i) {
        return dists[i][0];
      }).map(function (pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.filter(function (_, i) {
        return dists[i][1];
      }).map(function (pos) {
        return pos[1];
      });
    }

    var boundDelta = [0, 0];

    var _loop_1 = function (i) {
      var _e = checkSnapBounds(guidelines, props.clipTargetBounds && {
        left: 0,
        top: 0,
        right: width,
        bottom: height
      }, guideXPoses, guideYPoses, 5),
          horizontalSnapInfo = _e.horizontal,
          verticalSnapInfo = _e.vertical;

      var snapOffsetY = horizontalSnapInfo.offset;
      var snapOffsetX = verticalSnapInfo.offset;

      if (horizontalSnapInfo.isBound) {
        boundDelta[1] += snapOffsetY;
      }

      if (verticalSnapInfo.isBound) {
        boundDelta[0] += snapOffsetX;
      }

      if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {
        var guideRect = getRect(nextPoses);
        var cy = guideRect.bottom - guideRect.top;
        var cx = isEllipse ? guideRect.right - guideRect.left : cy;
        var distSnapX = verticalSnapInfo.isBound ? Math.abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;
        var distSnapY = horizontalSnapInfo.isBound ? Math.abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;
        cx -= distSnapX;
        cy -= distSnapY;

        if (isCircle) {
          cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;
          cx = cy;
        }

        var center = guidePoses[0];
        guidePoses[1][1] = center[1] - cy;
        guidePoses[2][0] = center[0] + cx;
        guidePoses[3][1] = center[1] + cy;
        guidePoses[4][0] = center[0] - cx;
      } else {
        guidePoses.forEach(function (pos, j) {
          var dist = dists[j];

          if (dist[0]) {
            pos[0] -= snapOffsetX;
          }

          if (dist[1]) {
            pos[1] -= snapOffsetY;
          }
        });
        return "break";
      }
    };

    for (var i = 0; i < 2; ++i) {
      var state_1 = _loop_1();

      if (state_1 === "break") break;
    }

    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);
    var clipStyle = clipType + "(" + nextClipStyles.join(splitter) + ")";
    state.clipPathState = clipStyle;

    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      guideXPoses = rectPoses.map(function (pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.map(function (pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.map(function (pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.map(function (pos) {
        return pos[1];
      });
    }

    state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && {
      left: 0,
      top: 0,
      right: width,
      bottom: height
    }, guideXPoses, guideYPoses, 1);

    if (originalDatas.draggable) {
      var is3d = state.is3d,
          allMatrix = state.allMatrix;
      var n = is3d ? 4 : 3;
      _a = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply)(allMatrix, [boundDelta[0], boundDelta[1], 0, 0], n), boundDelta[0] = _a[0], boundDelta[1] = _a[1];
      originalDatas.draggable.deltaOffset = boundDelta;
    }

    triggerEvent(moveable, "onClip", fillParams(moveable, e, {
      clipEventType: "changed",
      clipType: clipType,
      poses: nextPoses,
      clipStyle: clipStyle,
      clipStyles: nextClipStyles,
      distX: distX,
      distY: distY
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    this.unset(moveable);
    var isDrag = e.isDrag,
        datas = e.datas,
        isDouble = e.isDouble;
    var isLine = datas.isLine,
        isClipStart = datas.isClipStart,
        isControl = datas.isControl;

    if (!isClipStart) {
      return false;
    }

    triggerEvent(moveable, "onClipEnd", fillEndParams(moveable, e, {}));

    if (isDouble) {
      if (isControl) {
        removeClipPath(moveable, e);
      } else if (isLine) {
        // add
        addClipPath(moveable, e);
      }
    }

    return isDouble || isDrag;
  },
  unset: function (moveable) {
    moveable.state.clipPathState = "";
    moveable.state.snapBoundInfos = null;
  }
};
/**
 * Whether to clip the target. (default: false)
 * @name Moveable.Clippable#clippable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)
 * @name Moveable.Clippable#defaultClipPath
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px (`rect` not possible) (default: false)
 * @name Moveable.Clippable#clipRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)
 * @name Moveable.Clippable#customClipPath
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When dragging the target, the clip also moves. (default: true)
 * @name Moveable.Clippable#dragWithClip
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * You can drag the clip by setting clipArea. (default: false)
 * @name Moveable.Clippable#clipArea
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
* Whether the clip is bound to the target. (default: false)
* @name Moveable.Clippable#clipTargetBounds
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipTargetBounds: true,
* });
* moveable.on("clipStart", e => {
*     console.log(e);
* }).on("clip", e => {
*     if (e.clipType === "rect") {
*         e.target.style.clip = e.clipStyle;
*     } else {
*         e.target.style.clipPath = e.clipStyle;
*     }
* }).on("clipEnd", e => {
*     console.log(e);
* });
*/

/**
* Add clip guidelines in the vertical direction. (default: [])
* @name Moveable.Clippable#clipVerticalGuidelines
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
* Add clip guidelines in the horizontal direction. (default: [])
* @name Moveable.Clippable#clipHorizontalGuidelines
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
* istance value that can snap to clip guidelines. (default: 5)
* @name Moveable.Clippable#clipSnapThreshold
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     clippable: true,
*     defaultClipPath: "inset",
*     customClipPath: "",
*     clipRelative: false,
*     clipArea: false,
*     dragWithClip: true,
*     clipVerticalGuidelines: [0, 100, 200],
*     clipHorizontalGuidelines: [0, 100, 200],
*     clipSnapThreshold: 5,
* });
*/

/**
 * When drag start the clip area or controls, the `clipStart` event is called.
 * @memberof Moveable.Clippable
 * @event clipStart
 * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag the clip area or controls, the `clip` event is called.
 * @memberof Moveable.Clippable
 * @event clip
 * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag end the clip area or controls, the `clipEnd` event is called.
 * @memberof Moveable.Clippable
 * @event clipEnd
 * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     clippable: true,
 *     defaultClipPath: "inset",
 *     customClipPath: "",
 *     clipRelative: false,
 *     clipArea: false,
 *     dragWithClip: true,
 * });
 * moveable.on("clipStart", e => {
 *     console.log(e);
 * }).on("clip", e => {
 *     if (e.clipType === "rect") {
 *         e.target.style.clip = e.clipStyle;
 *     } else {
 *         e.target.style.clipPath = e.clipStyle;
 *     }
 * }).on("clipEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * @namespace OriginDraggable
 * @memberof Moveable
 * @description Whether to drag origin (default: false)
 */

var OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"],
  dragControlCondition: function (_, e) {
    if (e.isRequest) {
      return e.requestAble === "originDraggable";
    }

    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(e.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas;
    setDragStart(moveable, e);
    var params = fillParams(moveable, e, {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onDragOriginStart", params);
    datas.startOrigin = moveable.state.transformOrigin;
    datas.startTargetOrigin = moveable.state.targetOrigin;
    datas.prevOrigin = [0, 0];
    datas.isDragOrigin = true;

    if (result === false) {
      datas.isDragOrigin = false;
      return false;
    }

    return params;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        isPinch = e.isPinch,
        isRequest = e.isRequest;

    if (!datas.isDragOrigin) {
      return false;
    }

    var _a = getDragDist(e),
        distX = _a[0],
        distY = _a[1];

    var state = moveable.state;
    var width = state.width,
        height = state.height,
        offsetMatrix = state.offsetMatrix,
        targetMatrix = state.targetMatrix,
        is3d = state.is3d;
    var _b = moveable.props.originRelative,
        originRelative = _b === void 0 ? true : _b;
    var n = is3d ? 4 : 3;
    var dist = [distX, distY];

    if (isRequest) {
      var distOrigin = e.distOrigin;

      if (distOrigin[0] || distOrigin[1]) {
        dist = distOrigin;
      }
    }

    var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(datas.startOrigin, dist);
    var targetOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(datas.startTargetOrigin, dist);
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, datas.prevOrigin);
    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);
    var rect = moveable.getRect();
    var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));
    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];
    datas.prevOrigin = dist;
    var transformOrigin = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(" ");
    var params = fillParams(moveable, e, {
      width: width,
      height: height,
      origin: origin,
      dist: dist,
      delta: delta,
      transformOrigin: transformOrigin,
      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onDragOrigin", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDragOrigin) {
      return false;
    }

    triggerEvent(moveable, "onDragOriginEnd", fillEndParams(moveable, e, {}));
    return true;
  },
  dragGroupControlCondition: function (moveable, e) {
    return this.dragControlCondition(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    return true;
  },
  dragGroupControl: function (moveable, e) {
    var params = this.dragControl(moveable, e);

    if (!params) {
      return false;
    }

    moveable.transformOrigin = params.transformOrigin;
    return true;
  },

  /**
  * @method Moveable.OriginDraggable#request
  * @param {object} e - the OriginDraggable's request parameter
  * @param {number} [e.x] - x position
  * @param {number} [e.y] - y position
  * @param {number} [e.deltaX] - x number to move
  * @param {number} [e.deltaY] - y number to move
  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
  * @param {array} [e.origin] - transform-origin position
  * @param {number} [e.isInstant] - Whether to execute the request instantly
  * @return {Moveable.Requester} Moveable Requester
  * @example
   * // Instantly Request (requestStart - request - requestEnd)
  * // Use Relative Value
  * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 }, true);
  * // Use Transform Value
  * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
  * moveable.request("originDraggable", { origin: [100, 0] }, true);
  * // requestStart
  * const requester = moveable.request("originDraggable");
  *
  * // request
  * // Use Relative Value
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * requester.request({ deltaX: 10, deltaY: 10 });
  * // Use Absolute Value
  * moveable.request("originDraggable", { x: 200, y: 100 });
  * moveable.request("originDraggable", { x: 220, y: 100 });
  * moveable.request("originDraggable", { x: 240, y: 100 });
  *
  * // requestEnd
  * requester.requestEnd();
  */
  request: function (moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    var transformOrigin = rect.transformOrigin;
    var distOrigin = [0, 0];
    return {
      isControl: true,
      requestStart: function () {
        return {
          datas: datas
        };
      },
      request: function (e) {
        if ("deltaOrigin" in e) {
          distOrigin[0] += e.deltaOrigin[0];
          distOrigin[1] += e.deltaOrigin[1];
        } else if ("origin" in e) {
          distOrigin[0] = e.origin[0] - transformOrigin[0];
          distOrigin[1] = e.origin[1] - transformOrigin[1];
        } else {
          if ("x" in e) {
            distX = e.x - rect.left;
          } else if ("deltaX" in e) {
            distX += e.deltaX;
          }

          if ("y" in e) {
            distY = e.y - rect.top;
          } else if ("deltaY" in e) {
            distY += e.deltaY;
          }
        }

        return {
          datas: datas,
          distX: distX,
          distY: distY,
          distOrigin: distOrigin
        };
      },
      requestEnd: function () {
        return {
          datas: datas,
          isDrag: true
        };
      }
    };
  }
};
/**
 * Whether to drag origin (default: false)
 * @name Moveable.OriginDraggable#originDraggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     originDraggable: true,
 * });
 * let translate = [0, 0];
 * moveable.on("dragOriginStart", e => {
 *     e.dragStart && e.dragStart.set(translate);
 * }).on("dragOrigin", e => {
 *     translate = e.drag.beforeTranslate;
 *     e.target.style.cssText
 *         = `transform-origin: ${e.transformOrigin};`
 *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
 * }).on("dragOriginEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px (default: true)
 * @name Moveable.OriginDraggable#originRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     originDraggable: true,
 *     originRelative: false,
 * });
 * moveable.originRelative = true;
 */

/**
* When drag start the origin, the `dragOriginStart` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOriginStart
* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

/**
* When drag the origin, the `dragOrigin` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOrigin
* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

/**
* When drag end the origin, the `dragOriginEnd` event is called.
* @memberof Moveable.OriginDraggable
* @event dragOriginEnd
* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event
* @example
* import Moveable from "moveable";
*
* const moveable = new Moveable(document.body, {
*     originDraggable: true,
* });
* let translate = [0, 0];
* moveable.on("dragOriginStart", e => {
*     e.dragStart && e.dragStart.set(translate);
* }).on("dragOrigin", e => {
*     translate = e.drag.beforeTranslate;
*     e.target.style.cssText
*         = `transform-origin: ${e.transformOrigin};`
*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;
* }).on("dragOriginEnd", e => {
*     console.log(e);
* });
*/

function addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {
  var _a = splitRadiusPoses(controlPoses),
      horizontals = _a.horizontals,
      verticals = _a.verticals;

  var horizontalsLength = horizontals.length;
  var verticalsLength = verticals.length; // lineIndex
  // 0 top
  // 1 right
  // 2 left
  // 3 bottom
  // 0 top - left
  // 1 top - right
  // 2 bottom - right
  // 3 bottom - left
  // 0 left - top
  // 1 right - top
  // 2 right - bottom
  // 3 left - bottom

  var horizontalIndex = -1;
  var verticalIndex = -1;

  if (lineIndex === 0) {
    if (horizontalsLength === 0) {
      horizontalIndex = 0;
    } else if (horizontalsLength === 1) {
      horizontalIndex = 1;
    }
  } else if (lineIndex === 3) {
    if (horizontalsLength <= 2) {
      horizontalIndex = 2;
    } else if (horizontalsLength <= 3) {
      horizontalIndex = 3;
    }
  }

  if (lineIndex === 2) {
    if (verticalsLength === 0) {
      verticalIndex = 0;
    } else if (verticalsLength < 4) {
      verticalIndex = 3;
    }
  } else if (lineIndex === 1) {
    if (verticalsLength <= 1) {
      verticalIndex = 1;
    } else if (verticalsLength <= 2) {
      verticalIndex = 2;
    }
  }

  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);
}

function getBorderRadius(target, width, height, minCounts, state) {
  if (minCounts === void 0) {
    minCounts = [0, 0];
  }

  var borderRadius;
  var values = [];

  if (!state) {
    var style = getComputedStyle(target);
    borderRadius = style && style.borderRadius || "";
  } else {
    borderRadius = state;
  }

  if (!borderRadius || !state && borderRadius === "0px") {
    values = [];
  } else {
    values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(borderRadius);
  }

  return getRadiusValues(values, width, height, 0, 0, minCounts);
}

function triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses) {
  var state = moveable.state;
  var width = state.width,
      height = state.height;

  var _a = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height),
      raws = _a.raws,
      styles = _a.styles;

  var _b = splitRadiusPoses(controlPoses, raws),
      horizontals = _b.horizontals,
      verticals = _b.verticals;

  var borderRadius = styles.join(" ");
  state.borderRadiusState = borderRadius;
  triggerEvent(moveable, "onRound", fillParams(moveable, e, {
    horizontals: horizontals,
    verticals: verticals,
    borderRadius: borderRadius,
    width: width,
    height: height,
    delta: delta,
    dist: dist
  }));
}
/**
 * @namespace Moveable.Roundable
 * @description Whether to show and drag or double click border-radius
 */


var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd"
  },
  css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}", ":host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}"],
  render: function (moveable, React) {
    var _a = moveable.state,
        target = _a.target,
        width = _a.width,
        height = _a.height,
        allMatrix = _a.allMatrix,
        is3d = _a.is3d,
        left = _a.left,
        top = _a.top,
        borderRadiusState = _a.borderRadiusState;
    var _b = moveable.props,
        _c = _b.minRoundControls,
        minRoundControls = _c === void 0 ? [0, 0] : _c,
        _d = _b.maxRoundControls,
        maxRoundControls = _d === void 0 ? [4, 4] : _d,
        zoom = _b.zoom;

    if (!target) {
      return null;
    }

    var n = is3d ? 4 : 3;
    var radiusValues = getBorderRadius(target, width, height, minRoundControls, borderRadiusState);

    if (!radiusValues) {
      return null;
    }

    var verticalCount = 0;
    var horizontalCount = 0;
    return radiusValues.map(function (v, i) {
      horizontalCount += Math.abs(v.horizontal);
      verticalCount += Math.abs(v.vertical);
      var pos = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(calculatePosition(allMatrix, v.pos, n), [left, top]);
      var isDisplay = v.vertical ? verticalCount <= maxRoundControls[1] : horizontalCount <= maxRoundControls[0];
      return React.createElement("div", {
        key: "borderRadiusControl" + i,
        className: prefix("control", "border-radius"),
        "data-radius-index": i,
        style: {
          display: isDisplay ? "block" : "none",
          transform: "translate(" + pos[0] + "px, " + pos[1] + "px) scale(" + zoom + ")"
        }
      });
    });
  },
  dragControlCondition: function (moveable, e) {
    if (!e.inputEvent || e.isRequest) {
      return false;
    }

    var className = e.inputEvent.target.getAttribute("class") || "";
    return className.indexOf("border-radius") > -1 || className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
  },
  dragControlStart: function (moveable, e) {
    var inputEvent = e.inputEvent,
        datas = e.datas;
    var inputTarget = inputEvent.target;
    var className = inputTarget.getAttribute("class") || "";
    var isControl = className.indexOf("border-radius") > -1;
    var isLine = className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
    var controlIndex = isControl ? parseInt(inputTarget.getAttribute("data-radius-index"), 10) : -1;
    var lineIndex = isLine ? parseInt(inputTarget.getAttribute("data-line-index"), 10) : -1;

    if (!isControl && !isLine) {
      return false;
    }

    var result = triggerEvent(moveable, "onRoundStart", fillParams(moveable, e, {}));

    if (result === false) {
      return false;
    }

    datas.lineIndex = lineIndex;
    datas.controlIndex = controlIndex;
    datas.isControl = isControl;
    datas.isLine = isLine;
    setDragStart(moveable, e);
    var _a = moveable.props,
        roundRelative = _a.roundRelative,
        _b = _a.minRoundControls,
        minRoundControls = _b === void 0 ? [0, 0] : _b;
    var state = moveable.state;
    var target = state.target,
        width = state.width,
        height = state.height;
    datas.isRound = true;
    datas.prevDist = [0, 0];
    var controlPoses = getBorderRadius(target, width, height, minRoundControls) || [];
    datas.controlPoses = controlPoses;
    state.borderRadiusState = getRadiusStyles(controlPoses.map(function (pos) {
      return pos.pos;
    }), controlPoses, roundRelative, width, height).styles.join(" ");
    return true;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {
      return false;
    }

    var index = datas.controlIndex;
    var controlPoses = datas.controlPoses;

    var _a = getDragDist(e),
        distX = _a[0],
        distY = _a[1];

    var dist = [distX, distY];
    var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(dist, datas.prevDist);
    var _b = moveable.props.maxRoundControls,
        maxRoundControls = _b === void 0 ? [4, 4] : _b;
    var _c = moveable.state,
        width = _c.width,
        height = _c.height;
    var selectedControlPose = controlPoses[index];
    var selectedVertical = selectedControlPose.vertical;
    var selectedHorizontal = selectedControlPose.horizontal; // 0: [0, 1, 2, 3] maxCount === 1
    // 0: [0, 2] maxCount === 2
    // 1: [1, 3] maxCount === 2
    // 0: [0] maxCount === 3
    // 1: [1, 3] maxCount === 3

    var dists = controlPoses.map(function (pose) {
      var horizontal = pose.horizontal,
          vertical = pose.vertical;
      var poseDist = [horizontal * selectedHorizontal * dist[0], vertical * selectedVertical * dist[1]];

      if (horizontal) {
        if (maxRoundControls[0] === 1) {
          return poseDist;
        } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {
          return poseDist;
        }
      } else if (maxRoundControls[1] === 0) {
        poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;
        return poseDist;
      } else if (selectedVertical) {
        if (maxRoundControls[1] === 1) {
          return poseDist;
        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {
          return poseDist;
        }
      }

      return [0, 0];
    });
    dists[index] = dist;
    var nextPoses = controlPoses.map(function (pos, i) {
      return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos.pos, dists[i]);
    });
    datas.prevDist = [distX, distY];
    triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses);
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var state = moveable.state;
    state.borderRadiusState = "";
    var datas = e.datas,
        isDouble = e.isDouble;

    if (!datas.isRound) {
      return false;
    }

    var width = state.width,
        height = state.height;
    var isControl = datas.isControl,
        controlIndex = datas.controlIndex,
        isLine = datas.isLine,
        lineIndex = datas.lineIndex;
    var controlPoses = datas.controlPoses;
    var poses = controlPoses.map(function (pos) {
      return pos.pos;
    });
    var length = poses.length;
    var _a = moveable.props.roundClickable,
        roundClickable = _a === void 0 ? true : _a;

    if (isDouble && roundClickable) {
      if (isControl) {
        removeRadiusPos(controlPoses, poses, controlIndex, 0);
      } else if (isLine) {
        var _b = calculatePointerDist(moveable, e),
            distX = _b[0],
            distY = _b[1];

        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);
      }

      if (length !== controlPoses.length) {
        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses, poses);
      }
    }

    triggerEvent(moveable, "onRoundEnd", fillEndParams(moveable, e, {}));
    state.borderRadiusState = "";
    return true;
  },
  unset: function (moveable) {
    moveable.state.borderRadiusState = "";
  }
};
/**
 * Whether to show and drag or double click border-radius, (default: false)
 * @name Moveable.Roundable#roundable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * % Can be used instead of the absolute px
 * @name Moveable.Roundable#roundRelative
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])
 * @name Moveable.Roundable#minRoundControls
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     minRoundControls: [0, 0],
 * });
 * moveable.maxRoundControls = [1, 0];
 */

/**
 * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])
 * @name Moveable.Roundable#maxRoundControls
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     maxRoundControls: [4, 4],
 * });
 * moveable.maxRoundControls = [1, 0];
 */

/**
 * @property - Whether you can add/delete round controls by double-clicking a line or control. (default: true)
 * @name Moveable.Roundable#roundClickable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 *     roundClickable: true,
 * });
 * moveable.roundClickable = false;
 */

/**
 * When drag start the clip area or controls, the `roundStart` event is called.
 * @memberof Moveable.Roundable
 * @event roundStart
 * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag or double click the border area or controls, the `round` event is called.
 * @memberof Moveable.Roundable
 * @event round
 * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event
 * @example
  * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

/**
 * When drag end the border area or controls, the `roundEnd` event is called.
 * @memberof Moveable.Roundable
 * @event roundEnd
 * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event
 * @example
  * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     roundable: true,
 *     roundRelative: false,
 * });
 * moveable.on("roundStart", e => {
 *     console.log(e);
 * }).on("round", e => {
 *     e.target.style.borderRadius = e.borderRadius;
 * }).on("roundEnd", e => {
 *     console.log(e);
 * });
 */

function isIdentityMatrix(matrix, is3d) {
  var value = is3d ? "matrix3d(" + (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(4) : "matrix(" + (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.createIdentityMatrix)(3) + ")";
  return matrix === value || matrix === "matrix(1,0,0,1,0,0)";
}

var BeforeRenderable = {
  isPinch: true,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  dragRelation: "weak",
  setTransform: function (moveable, e) {
    var _a = moveable.state,
        is3d = _a.is3d,
        target = _a.target,
        targetMatrix = _a.targetMatrix;
    var transform = target === null || target === void 0 ? void 0 : target.style.transform;
    var cssMatrix = is3d ? "matrix3d(" + targetMatrix.join(",") + ")" : "matrix(" + (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.convertMatrixtoCSS)(targetMatrix, true) + ")";
    var startTransform = !transform || transform === "none" ? cssMatrix : transform;
    e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(startTransform);
  },
  resetTransform: function (e) {
    e.datas.nextTransforms = e.datas.startTransforms;
    e.datas.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function (moveable, e) {
    return fillParams(moveable, e, {
      setTransform: function (transform) {
        e.datas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.splitSpace)(transform);
      },
      isPinch: !!e.isPinch
    });
  },
  fillDragParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch
    });
  },
  dragStart: function (moveable, e) {
    this.setTransform(moveable, e);
    triggerEvent(moveable, "onBeforeRenderStart", this.fillDragStartParams(moveable, e));
  },
  drag: function (moveable, e) {
    this.resetTransform(e);
    triggerEvent(moveable, "onBeforeRender", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  dragEnd: function (moveable, e) {
    triggerEvent(moveable, "onBeforeRenderEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    }));
  },
  dragGroupStart: function (moveable, e) {
    var _this = this;

    this.dragStart(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];

      _this.setTransform(childMoveable, childEvent);

      return _this.fillDragStartParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      setTransform: function () {},
      events: params
    }));
  },
  dragGroup: function (moveable, e) {
    var _this = this;

    this.drag(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];

      _this.resetTransform(childEvent);

      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
    triggerEvent(moveable, "onBeforeRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets
    }));
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function (moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    return this.dragGroupEnd(moveable, e);
  }
};

var Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragRelation: "weak",
  dragStart: function (moveable, e) {
    triggerEvent(moveable, "onRenderStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  drag: function (moveable, e) {
    triggerEvent(moveable, "onRender", this.fillDragParams(moveable, e));
  },
  dragAfter: function (moveable, e) {
    if (e.resultCount) {
      return this.drag(moveable, e);
    }
  },
  dragEnd: function (moveable, e) {
    triggerEvent(moveable, "onRenderEnd", this.fillDragEndParams(moveable, e));
  },
  dragGroupStart: function (moveable, e) {
    triggerEvent(moveable, "onRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets
    }));
  },
  dragGroup: function (moveable, e) {
    var _this = this;

    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];
      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      transform: getNextTransformText(e),
      events: params
    }));
  },
  dragGroupEnd: function (moveable, e) {
    var _this = this;

    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function (childEvent, i) {
      var childMoveable = moveables[i];
      return _this.fillDragEndParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragControlStart: function (moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function (moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlAfter: function (moveable, e) {
    return this.dragAfter(moveable, e);
  },
  dragControlEnd: function (moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function (moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function (moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    return this.dragGroupEnd(moveable, e);
  },
  fillDragParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      transform: getNextTransformText(e)
    });
  },
  fillDragEndParams: function (moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    });
  }
};

function triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, requestInstant) {
  var isStart = eventType === "Start";
  var target = moveable.state.target;
  var isRequest = e.isRequest;

  if (!target || isStart && eventAffix.indexOf("Control") > -1 && !isRequest && moveable.areaElement === e.inputEvent.target) {
    return false;
  } // "drag" "Control" "After"


  var eventName = "" + eventOperation + eventAffix + eventType;
  var conditionName = "" + eventOperation + eventAffix + "Condition";
  var isEnd = eventType === "End";
  var isAfter = eventType === "After";
  var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());

  if (isFirstStart) {
    moveable.updateRect(eventType, true, false);
  }

  if (eventType === "" && !isRequest) {
    convertDragDist(moveable.state, e);
  } // const isGroup = eventAffix.indexOf("Group") > -1;


  var ables = __spreadArray([], moveable[ableType]);

  if (isRequest) {
    var requestAble_1 = e.requestAble;

    if (!ables.some(function (able) {
      return able.name === requestAble_1;
    })) {
      ables.push.apply(ables, moveable.props.ables.filter(function (able) {
        return able.name === requestAble_1;
      }));
    }
  }

  if (!ables.length) {
    return false;
  }

  var eventAbles = __spreadArray(__spreadArray([BeforeRenderable], ables), [Renderable]).filter(function (able) {
    return able[eventName];
  });

  var datas = e.datas;

  if (isFirstStart) {
    eventAbles.forEach(function (able) {
      able.unset && able.unset(moveable);
    });
  }

  var inputEvent = e.inputEvent;
  var inputTarget;

  if (isEnd && inputEvent) {
    inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;
  }

  var resultCount = 0;
  var results = eventAbles.filter(function (able) {
    var ableName = able.name;
    var nextDatas = datas[ableName] || (datas[ableName] = {});

    if (isStart) {
      nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);
    }

    if (nextDatas.isEventStart) {
      var result = able[eventName](moveable, __assign(__assign({}, e), {
        resultCount: resultCount,
        datas: nextDatas,
        originalDatas: datas,
        inputTarget: inputTarget
      }));

      if (isStart && result === false) {
        nextDatas.isEventStart = false;
      }

      resultCount += result ? 1 : 0;
      return result;
    }

    return false;
  });
  var isUpdate = results.length;
  var isForceEnd = false; // end ables

  if (isStart && eventAbles.length && !isUpdate) {
    isForceEnd = eventAbles.filter(function (able) {
      var ableName = able.name;
      var nextDatas = datas[ableName];

      if (nextDatas.isEventStart) {
        if (able.dragRelation === "strong") {
          // cancel drag
          nextDatas.isEventStart = false;
          return false;
        } // start drag


        return true;
      } // cancel event


      return false;
    }).length === 0;
  }

  if (isEnd || isForceEnd) {
    moveable.state.gesto = null;

    if (moveable.moveables) {
      moveable.moveables.forEach(function (childMoveable) {
        childMoveable.state.gesto = null;
      });
    }
  }

  if (isFirstStart && isForceEnd) {
    eventAbles.forEach(function (able) {
      able.unset && able.unset(moveable);
    });
  }

  if (isStart && !isRequest && isUpdate) {
    e === null || e === void 0 ? void 0 : e.preventDefault();
  }

  if (moveable.isUnmounted || isForceEnd) {
    return false;
  }

  if (!isStart && isUpdate && !requestInstant || isEnd) {
    moveable.updateRect(isEnd ? eventType : "", true, false);
    moveable.forceUpdate();
  }

  if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {
    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + "After", e);
  }

  return true;
}
function getTargetAbleGesto(moveable, moveableTarget, eventAffix) {
  var controlBox = moveable.controlBox.getElement();
  var targets = [];
  targets.push(controlBox);

  if (!moveable.props.dragArea || moveable.props.dragTarget) {
    targets.push(moveableTarget);
  }

  var startFunc = function (e) {
    var eventTarget = e.inputEvent.target;
    var areaElement = moveable.areaElement;
    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(eventTarget, "moveable-area") || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(eventTarget, "moveable-padding");
  };

  return getAbleGesto(moveable, targets, "targetAbles", eventAffix, {
    dragStart: startFunc,
    pinchStart: startFunc
  });
}
function getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {
  if (conditionFunctions === void 0) {
    conditionFunctions = {};
  }

  var _a = moveable.props,
      pinchOutside = _a.pinchOutside,
      pinchThreshold = _a.pinchThreshold;
  var options = {
    preventDefault: false,
    container: window,
    pinchThreshold: pinchThreshold,
    pinchOutside: pinchOutside
  };
  var gesto = new gesto__WEBPACK_IMPORTED_MODULE_8__["default"](target, options);
  ["drag", "pinch"].forEach(function (eventOperation) {
    ["Start", "", "End"].forEach(function (eventType) {
      gesto.on("" + eventOperation + eventType, function (e) {
        var eventName = e.eventType;

        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {
          e.stop();
          return;
        }

        var result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);

        if (!result) {
          e.stop();
        }
      });
    });
  });
  return gesto;
}

var EventManager =
/*#__PURE__*/
function () {
  function EventManager(target, moveable, eventName) {
    var _this = this;

    this.target = target;
    this.moveable = moveable;
    this.eventName = eventName;
    this.ables = [];

    this.onEvent = function (e) {
      var eventName = _this.eventName;
      var moveable = _this.moveable;

      if (moveable.state.disableNativeEvent) {
        return;
      }

      _this.ables.forEach(function (able) {
        able[eventName](moveable, {
          inputEvent: e
        });
      });
    };

    this.target.addEventListener(this.eventName.toLowerCase(), this.onEvent);
  }

  var __proto = EventManager.prototype;

  __proto.setAbles = function (ables) {
    this.ables = ables;
  };

  __proto.destroy = function () {
    this.target.removeEventListener(this.eventName.toLowerCase(), this.onEvent);
    this.target = null;
    this.moveable = null;
  };

  return EventManager;
}();

var MoveableManager =
/*#__PURE__*/
function (_super) {
  __extends(MoveableManager, _super);

  function MoveableManager() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = __assign({
      container: null,
      gesto: null,
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: false
    }, getTargetInfo(null));
    _this.enabledAbles = [];
    _this.targetAbles = [];
    _this.controlAbles = [];
    _this.rotation = 0;
    _this.scale = [1, 1];
    _this.isUnmounted = false;
    _this.events = {
      "mouseEnter": null,
      "mouseLeave": null
    };
    _this._prevTarget = null;
    _this._prevDragArea = false;
    _this._observer = null;
    _this._observerId = 0;

    _this.onPreventClick = function (e) {
      e.stopPropagation();
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.removeEvent)(window, "click", _this.onPreventClick, true);
    };

    _this.checkUpdateRect = function () {
      if (_this.isDragging()) {
        return;
      }

      var parentMoveable = _this.props.parentMoveable;

      if (parentMoveable) {
        parentMoveable.checkUpdateRect();
        return;
      }

      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.cancelAnimationFrame)(_this._observerId);
      _this._observerId = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.requestAnimationFrame)(function () {
        if (_this.isDragging()) {
          return;
        }

        _this.updateRect();
      });
    };

    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.render = function () {
    var props = this.props;
    var state = this.state;
    var parentPosition = props.parentPosition,
        className = props.className,
        propsTarget = props.target,
        zoom = props.zoom,
        cspNonce = props.cspNonce,
        translateZ = props.translateZ,
        ControlBoxElement = props.cssStyled,
        portalContainer = props.portalContainer;
    this.checkUpdate();
    this.updateRenderPoses();

    var _a = parentPosition || {
      left: 0,
      top: 0
    },
        parentLeft = _a.left,
        parentTop = _a.top;

    var left = state.left,
        top = state.top,
        stateTarget = state.target,
        direction = state.direction;
    var groupTargets = props.targets;
    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;
    var isDragging = this.isDragging();
    var ableAttributes = {};
    this.getEnabledAbles().forEach(function (able) {
      ableAttributes["data-able-" + able.name.toLowerCase()] = true;
    });
    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(ControlBoxElement, __assign({
      cspNonce: cspNonce,
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "controlBox"),
      className: prefix("control-box", direction === -1 ? "reverse" : "", isDragging ? "dragging" : "") + " " + className
    }, ableAttributes, {
      onClick: this.onPreventClick,
      portalContainer: portalContainer,
      style: {
        "position": "absolute",
        "display": isDisplay ? "block" : "none",
        "transform": "translate3d(" + (left - parentLeft) + "px, " + (top - parentTop) + "px, " + translateZ + ")",
        "--zoom": zoom,
        "--zoompx": zoom + "px"
      }
    }), this.renderAbles(), this._renderLines());
  };

  __proto.componentDidMount = function () {
    this.controlBox.getElement();
    var props = this.props;
    var parentMoveable = props.parentMoveable,
        container = props.container,
        wrapperMoveable = props.wrapperMoveable;

    this._updateTargets();

    this._updateNativeEvents();

    this._updateEvents();

    if (!container && !parentMoveable && !wrapperMoveable) {
      this.updateRect("", false, true);
    }

    this.updateCheckInput();

    this._updateObserver(this.props);
  };

  __proto.componentDidUpdate = function (prevProps) {
    this._updateNativeEvents();

    this._updateEvents();

    this._updateTargets();

    this.updateCheckInput();

    this._updateObserver(prevProps);
  };

  __proto.componentWillUnmount = function () {
    this.isUnmounted = true;
    unset(this, "targetGesto");
    unset(this, "controlGesto");
    var events = this.events;

    for (var name in events) {
      var manager = events[name];
      manager && manager.destroy();
    }
  };

  __proto.getContainer = function () {
    var _a = this.props,
        parentMoveable = _a.parentMoveable,
        wrapperMoveable = _a.wrapperMoveable,
        container = _a.container;
    return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;
  };
  /**
   * Check if the target is an element included in the moveable.
   * @method Moveable#isMoveableElement
   * @param - the target
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("click", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *         moveable.target = e.target;
   *     }
   * });
   */


  __proto.isMoveableElement = function (target) {
    return target && (target.getAttribute("class") || "").indexOf(PREFIX) > -1;
  };
  /**
   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)
   * @method Moveable#dragStart
   * @param - external `MouseEvent`or `TouchEvent`
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *          moveable.dragStart(e);
   *     }
   * });
   */


  __proto.dragStart = function (e) {
    if (this.targetGesto) {
      this.targetGesto.triggerDragStart(e);
    }

    return this;
  };
  /**
   * Hit test an element or rect on a moveable target.
   * @method Moveable#hitTest
   * @param - element or rect to test
   * @return - Get hit test rate (rate > 0 is hitted)
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.hitTest(e.target) > 0) {
   *          console.log("hiited");
   *     }
   * });
   */


  __proto.hitTest = function (el) {
    var _a = this.state,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        targetClientRect = _a.targetClientRect;

    if (!target) {
      return 0;
    }

    var rect;

    if (el instanceof Element) {
      var clientRect = el.getBoundingClientRect();
      rect = {
        left: clientRect.left,
        top: clientRect.top,
        width: clientRect.width,
        height: clientRect.height
      };
    } else {
      rect = __assign({
        width: 0,
        height: 0
      }, el);
    }

    var rectLeft = rect.left,
        rectTop = rect.top,
        rectWidth = rect.width,
        rectHeight = rect.height;
    var points = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)([pos1, pos2, pos4, pos3], targetClientRect);
    var size = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapSize)(points, [[rectLeft, rectTop], [rectLeft + rectWidth, rectTop], [rectLeft + rectWidth, rectTop + rectHeight], [rectLeft, rectTop + rectHeight]]);
    var totalSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points);

    if (!size || !totalSize) {
      return 0;
    }

    return Math.min(100, size / totalSize * 100);
  };
  /**
   * Whether the coordinates are inside Moveable
   * @method Moveable#isInside
   * @param - x coordinate
   * @param - y coordinate
   * @return - True if the coordinate is in moveable or false
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.isInside(e.clientX, e.clientY)) {
   *          console.log("inside");
   *     }
   * });
   */


  __proto.isInside = function (clientX, clientY) {
    var _a = this.state,
        target = _a.target,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        targetClientRect = _a.targetClientRect;

    if (!target) {
      return false;
    }

    return (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.isInside)([clientX, clientY], (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)([pos1, pos2, pos4, pos3], targetClientRect));
  };
  /**
   * If the width, height, left, and top of all elements change, update the shape of the moveable.
   * @method Moveable#updateRect
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("resize", e => {
   *     moveable.updateRect();
   * });
   */


  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    var props = this.props;
    var parentMoveable = props.parentMoveable;
    var state = this.state;
    var target = state.target || this.props.target;
    var container = this.getContainer();
    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;
    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container), parentMoveable ? false : isSetState);
  };
  /**
   * Check if the moveable state is being dragged.
   * @method Moveable#isDragging
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // false
   * console.log(moveable.isDragging());
   *
   * moveable.on("drag", () => {
   *   // true
   *   console.log(moveable.isDragging());
   * });
   */


  __proto.isDragging = function () {
    return (this.targetGesto ? this.targetGesto.isFlag() : false) || (this.controlGesto ? this.controlGesto.isFlag() : false);
  };
  /**
   * If the width, height, left, and top of the only target change, update the shape of the moveable.
   * @method Moveable#updateTarget
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.updateTarget();
   */


  __proto.updateTarget = function (type) {
    this.updateRect(type, true);
  };
  /**
   * You can get the vertex information, position and offset size information of the target based on the container.
   * @method Moveable#getRect
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const rectInfo = moveable.getRect();
   */


  __proto.getRect = function () {
    var state = this.state;
    var poses = getAbsolutePosesByState(this.state);
    var pos1 = poses[0],
        pos2 = poses[1],
        pos3 = poses[2],
        pos4 = poses[3];
    var rect = getRect(poses);
    var offsetWidth = state.width,
        offsetHeight = state.height;
    var width = rect.width,
        height = rect.height,
        left = rect.left,
        top = rect.top;
    var statePos = [state.left, state.top];
    var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(statePos, state.origin);
    var beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(statePos, state.beforeOrigin);
    var transformOrigin = state.transformOrigin;
    return {
      width: width,
      height: height,
      left: left,
      top: top,
      pos1: pos1,
      pos2: pos2,
      pos3: pos3,
      pos4: pos4,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight,
      beforeOrigin: beforeOrigin,
      origin: origin,
      transformOrigin: transformOrigin,
      rotation: this.getRotation()
    };
  };
  /**
   * Get a manager that manages the moveable's state and props.
   * @method Moveable#getManager
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const manager = moveable.getManager(); // real moveable class instance
   */


  __proto.getManager = function () {
    return this;
  };

  __proto.getRotation = function () {
    var _a = this.state,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        direction = _a.direction;
    return getAbsoluteRotation(pos1, pos2, direction);
  };
  /**
   * Request able through a method rather than an event.
   * At the moment of execution, requestStart is executed,
   * and then request and requestEnd can be executed through Requester.
   * @method Moveable#request
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}
   * @param - ableName
   * @param - request to be able params.
   * @param - If isInstant is true, request and requestEnd are executed immediately.
   * @return - Able Requester. If there is no request in able, nothing will work.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   *
   * // Start move
   * const requester = moveable.request("draggable");
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.requestEnd();
   */


  __proto.request = function (ableName, param, isInstant) {
    if (param === void 0) {
      param = {};
    }

    var _a = this.props,
        ables = _a.ables,
        groupable = _a.groupable;
    var requsetAble = ables.filter(function (able) {
      return able.name === ableName;
    })[0];

    if (this.isDragging() || !requsetAble || !requsetAble.request) {
      return {
        request: function () {
          return this;
        },
        requestEnd: function () {
          return this;
        }
      };
    }

    var self = this;
    var ableRequester = requsetAble.request(this);
    var requestInstant = isInstant || param.isInstant;
    var ableType = ableRequester.isControl ? "controlAbles" : "targetAbles";
    var eventAffix = "" + (groupable ? "Group" : "") + (ableRequester.isControl ? "Control" : "");
    var requester = {
      request: function (ableParam) {
        triggerAble(self, ableType, "drag", eventAffix, "", __assign(__assign({}, ableRequester.request(ableParam)), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      },
      requestEnd: function () {
        triggerAble(self, ableType, "drag", eventAffix, "End", __assign(__assign({}, ableRequester.requestEnd()), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      }
    };
    triggerAble(self, ableType, "drag", eventAffix, "Start", __assign(__assign({}, ableRequester.requestStart(param)), {
      requestAble: ableName,
      isRequest: true
    }), requestInstant);
    return requestInstant ? requester.request(param).requestEnd() : requester;
  };
  /**
   * Remove the Moveable object and the events.
   * @method Moveable#destroy
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.destroy();
   */


  __proto.destroy = function () {
    this.componentWillUnmount();
  };

  __proto.updateRenderPoses = function () {
    var state = this.state;
    var props = this.props;
    var originalBeforeOrigin = state.originalBeforeOrigin,
        transformOrigin = state.transformOrigin,
        allMatrix = state.allMatrix,
        is3d = state.is3d,
        pos1 = state.pos1,
        pos2 = state.pos2,
        pos3 = state.pos3,
        pos4 = state.pos4,
        stateLeft = state.left,
        stateTop = state.top;

    var _a = props.padding || {},
        _b = _a.left,
        left = _b === void 0 ? 0 : _b,
        _c = _a.top,
        top = _c === void 0 ? 0 : _c,
        _d = _a.bottom,
        bottom = _d === void 0 ? 0 : _d,
        _e = _a.right,
        right = _e === void 0 ? 0 : _e;

    var n = is3d ? 4 : 3;
    var absoluteOrigin = props.groupable ? originalBeforeOrigin : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(originalBeforeOrigin, [stateLeft, stateTop]);
    state.renderPoses = [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n))];
  };

  __proto.checkUpdate = function () {
    var _a = this.props,
        target = _a.target,
        container = _a.container,
        parentMoveable = _a.parentMoveable;
    var _b = this.state,
        stateTarget = _b.target,
        stateContainer = _b.container;

    if (!stateTarget && !target) {
      return;
    }

    this.updateAbles();
    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);

    if (!isChanged) {
      return;
    }

    var moveableContainer = container || this.controlBox;

    if (moveableContainer) {
      this.unsetAbles();
    }

    this.updateState({
      target: target,
      container: container
    });

    if (!parentMoveable && moveableContainer) {
      this.updateRect("End", false, false);
    }
  };

  __proto.triggerEvent = function (name, e) {
    var callback = this.props[name];
    return callback && callback(e);
  };

  __proto.useCSS = function (tag, css) {
    var customStyleMap = this.props.customStyledMap;
    var key = tag + css;

    if (!customStyleMap[key]) {
      customStyleMap[key] = (0,react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__["default"])(tag, css);
    }

    return customStyleMap[key];
  };

  __proto.unsetAbles = function () {
    var _this = this;

    this.targetAbles.forEach(function (able) {
      if (able.unset) {
        able.unset(_this);
      }
    });
  };

  __proto.updateAbles = function (ables, eventAffix) {
    if (ables === void 0) {
      ables = this.props.ables;
    }

    if (eventAffix === void 0) {
      eventAffix = "";
    }

    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var enabledAbles = ables.filter(function (able) {
      return able && (able.always && props[able.name] !== false || props[able.name]);
    });
    var dragStart = "drag" + eventAffix + "Start";
    var pinchStart = "pinch" + eventAffix + "Start";
    var dragControlStart = "drag" + eventAffix + "ControlStart";
    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);
    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);
    this.enabledAbles = enabledAbles;
    this.targetAbles = targetAbles;
    this.controlAbles = controlAbles;
  };

  __proto.updateState = function (nextState, isSetState) {
    if (isSetState) {
      this.setState(nextState);
    } else {
      var state = this.state;

      for (var name in nextState) {
        state[name] = nextState[name];
      }
    }
  };

  __proto.getEnabledAbles = function () {
    var props = this.props;
    var ables = props.ables;
    return ables.filter(function (able) {
      return able && props[able.name];
    });
  };

  __proto.renderAbles = function () {
    var _this = this;

    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var Renderer = {
      createElement: react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement
    };
    return groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], triggerAblesSimultaneously).map(function (_a) {
      var render = _a.render;
      return render(_this, Renderer) || [];
    })).filter(function (el) {
      return el;
    }), function (_a) {
      var key = _a.key;
      return key;
    }).map(function (group) {
      return group[0];
    });
  };

  __proto.updateCheckInput = function () {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  };

  __proto._updateObserver = function (prevProps) {
    var _a;

    var props = this.props;
    var target = props.target;

    if (!window.ResizeObserver || !target || !props.useResizeObserver) {
      (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
      return;
    }

    if (prevProps.target === target && this._observer) {
      return;
    }

    var observer = new ResizeObserver(this.checkUpdateRect);
    observer.observe(target, {
      box: "border-box"
    });
    this._observer = observer;
    return;
  };

  __proto._updateEvents = function () {
    var controlBoxElement = this.controlBox.getElement();
    var hasTargetAble = this.targetAbles.length;
    var hasControlAble = this.controlAbles.length;
    var props = this.props;
    var target = props.dragTarget || props.target;

    var isUnset = !hasTargetAble && this.targetGesto || this._isTargetChanged(true);

    if (isUnset) {
      unset(this, "targetGesto");
      this.updateState({
        gesto: null
      });
    }

    if (!hasControlAble) {
      unset(this, "controlGesto");
    }

    if (target && hasTargetAble && !this.targetGesto) {
      this.targetGesto = getTargetAbleGesto(this, target, "");
    }

    if (!this.controlGesto && hasControlAble) {
      this.controlGesto = getAbleGesto(this, controlBoxElement, "controlAbles", "Control");
    }
  };

  __proto._updateTargets = function () {
    var props = this.props;
    this._prevTarget = props.dragTarget || props.target;
    this._prevDragArea = props.dragArea;
  };

  __proto._renderLines = function () {
    var props = this.props;
    var edge = props.edge,
        zoom = props.zoom,
        hideDefaultLines = props.hideDefaultLines;

    if (hideDefaultLines) {
      return [];
    }

    var renderPoses = this.state.renderPoses;
    var Renderer = {
      createElement: react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement
    };
    return [renderLine(Renderer, edge ? "n" : "", renderPoses[0], renderPoses[1], zoom, 0), renderLine(Renderer, edge ? "e" : "", renderPoses[1], renderPoses[3], zoom, 1), renderLine(Renderer, edge ? "w" : "", renderPoses[0], renderPoses[2], zoom, 2), renderLine(Renderer, edge ? "s" : "", renderPoses[2], renderPoses[3], zoom, 3)];
  };

  __proto._isTargetChanged = function (useDragArea) {
    var props = this.props;
    var target = props.dragTarget || props.target;
    var prevTarget = this._prevTarget;
    var prevDragArea = this._prevDragArea;
    var dragArea = props.dragArea; // check target without dragArea

    var isTargetChanged = !dragArea && prevTarget !== target;
    var isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;
    return isTargetChanged || isDragAreaChanged;
  };

  __proto._updateNativeEvents = function () {
    var _this = this;

    var props = this.props;
    var target = props.dragArea ? this.areaElement : this.state.target;
    var events = this.events;
    var eventKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getKeys)(events);

    if (this._isTargetChanged()) {
      for (var eventName in events) {
        var manager = events[eventName];
        manager && manager.destroy();
        events[eventName] = null;
      }
    }

    if (!target) {
      return;
    }

    var enabledAbles = this.enabledAbles;
    eventKeys.forEach(function (eventName) {
      var ables = filterAbles(enabledAbles, [eventName]);
      var hasAbles = ables.length > 0;
      var manager = events[eventName];

      if (!hasAbles) {
        if (manager) {
          manager.destroy();
          events[eventName] = null;
        }

        return;
      }

      if (!manager) {
        manager = new EventManager(target, _this, eventName);
        events[eventName] = manager;
      }

      manager.setAbles(ables);
    });
  };

  MoveableManager.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: true,
    edge: false,
    parentMoveable: null,
    wrapperMoveable: null,
    parentPosition: null,
    portalContainer: null,
    useResizeObserver: false,
    ables: [],
    pinchThreshold: 20,
    dragArea: false,
    passDragArea: false,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: false,
    padding: {},
    pinchOutside: true,
    checkInput: false,
    groupable: false,
    hideDefaultLines: false,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {}
  };
  return MoveableManager;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.PureComponent);
/**
 * The target to indicate Moveable Control Box.
 * @name Moveable#target
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.target = document.querySelector(".target");
 */

/**
 * Zooms in the elements of a moveable.
 * @name Moveable#zoom
 * @default 1
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.zoom = 2;
 */

/**
 * Whether the target size is detected and updated whenever it changes.
 * @name Moveable#zoom
 * @default false
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.useResizeObserver = true;
 */

/**
 * Resize, Scale Events at edges
 * @name Moveable#edge
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.edge = true;
 */

/**
 * You can specify the className of the moveable controlbox.
 * @name Moveable#className
 * @default ""
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *   className: "",
 * });
 *
 * moveable.className = "moveable1";
 */

/**
 * The target(s) to drag Moveable target(s)
 * @name Moveable#dragTarget
 * @default target
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body);
 * moveable.target = document.querySelector(".target");
 * moveable.dragTarget = document.querySelector(".dragTarget");
 */

/**
 * `renderStart` event occurs at the first start of all events.
 * @memberof Moveable
 * @event renderStart
 * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("renderStart", ({ target }) => {
 *     console.log("onRenderStart", target);
 * });
 */

/**
 * `render` event occurs before the target is drawn on the screen.
 * @memberof Moveable
 * @event render
 * @param {Moveable.OnRender} - Parameters for the `render` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("render", ({ target }) => {
 *     console.log("onRender", target);
 * });
 */

/**
 * `renderEnd` event occurs at the end of all events.
 * @memberof Moveable
 * @event renderEnd
 * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("renderEnd", ({ target }) => {
 *     console.log("onRenderEnd", target);
 * });
 */

/**
 * `renderGroupStart` event occurs at the first start of all events in group.
 * @memberof Moveable
 * @event renderGroupStart
 * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroupStart", ({ targets }) => {
 *     console.log("onRenderGroupStart", targets);
 * });
 */

/**
 * `renderGroup` event occurs before the target is drawn on the screen in group.
 * @memberof Moveable
 * @event renderGroup
 * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroup", ({ targets }) => {
 *     console.log("onRenderGroup", targets);
 * });
 */

/**
 * `renderGroupEnd` event occurs at the end of all events in group.
 * @memberof Moveable
 * @event renderGroupEnd
 * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("renderGroupEnd", ({ targets }) => {
 *     console.log("onRenderGroupEnd", targets);
 * });
 */

var Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean
  },
  events: {},
  render: function (moveable, React) {
    var targets = moveable.props.targets || [];
    moveable.moveables = [];
    var _a = moveable.state,
        left = _a.left,
        top = _a.top;
    var position = {
      left: left,
      top: top
    };
    var props = moveable.props;
    return targets.map(function (target, i) {
      return React.createElement(MoveableManager, {
        key: "moveable" + i,
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.refs)(moveable, "moveables", i),
        target: target,
        origin: false,
        cssStyled: props.cssStyled,
        customStyledMap: props.customStyledMap,
        useResizeObserver: props.useResizeObserver,
        parentMoveable: moveable,
        parentPosition: position
      });
    });
  }
};

var Clickable = makeAble("clickable", {
  props: {
    clickable: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: true,
  dragRelation: "weak",
  dragStart: function (moveable, e) {
    if (!e.isRequest) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.addEvent)(window, "click", moveable.onPreventClick, true);
    }
  },
  dragControlStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;
  },
  dragEnd: function (moveable, e) {
    this.endEvent(moveable);
    var target = moveable.state.target;
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;
    var isMoveableElement = moveable.isMoveableElement(inputTarget);
    var containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);

    if (!e.isDrag || containsElement) {
      this.unset(moveable);
    }

    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || containsElement // External event duplicate target or dragAreaElement
    ) {
        return;
      }

    var containsTarget = target.contains(inputTarget);
    triggerEvent(moveable, "onClick", fillParams(moveable, e, {
      isDouble: e.isDouble,
      inputTarget: inputTarget,
      isTarget: target === inputTarget,
      containsTarget: containsTarget
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.endEvent(moveable);
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;

    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) // External event duplicate target or dragAreaElement
    || e.datas.inputTarget === inputTarget) {
      return;
    }

    var targets = moveable.props.targets;
    var targetIndex = targets.indexOf(inputTarget);
    var isTarget = targetIndex > -1;
    var containsTarget = false;

    if (targetIndex === -1) {
      targetIndex = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.findIndex)(targets, function (parentTarget) {
        return parentTarget.contains(inputTarget);
      });
      containsTarget = targetIndex > -1;
    }

    triggerEvent(moveable, "onClickGroup", fillParams(moveable, e, {
      isDouble: e.isDouble,
      targets: targets,
      inputTarget: inputTarget,
      targetIndex: targetIndex,
      isTarget: isTarget,
      containsTarget: containsTarget
    }));
  },
  dragControlEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  dragGroupControlEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  endEvent: function (moveable) {
    var _this = this;

    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.requestAnimationFrame)(function () {
      _this.unset(moveable);
    });
  },
  unset: function (moveable) {
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.removeEvent)(window, "click", moveable.onPreventClick, true);
  }
});
/**
 * When you click on the element, the `click` event is called.
 * @memberof Moveable
 * @event click
 * @param {Moveable.OnClick} - Parameters for the `click` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: document.querySelector(".target"),
 * });
 * moveable.on("click", ({ hasTarget, containsTarget, targetIndex }) => {
 *     // If you click on an element other than the target and not included in the target, index is -1.
 *     console.log("onClickGroup", target, hasTarget, containsTarget, targetIndex);
 * });
 */

/**
 * When you click on the element inside the group, the `clickGroup` event is called.
 * @memberof Moveable
 * @event clickGroup
 * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *     target: [].slice.call(document.querySelectorAll(".target")),
 * });
 * moveable.on("clickGroup", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {
 *     // If you click on an element other than the target and not included in the target, index is -1.
 *     console.log("onClickGroup", inputTarget, isTarget, containsTarget, targetIndex);
 * });
 */

function getDraggableEvent(e) {
  var datas = e.originalDatas.draggable;

  if (!datas) {
    e.originalDatas.draggable = {};
    datas = e.originalDatas.draggable;
  }

  return __assign(__assign({}, e), {
    datas: datas
  });
}

var edgeDraggable = makeAble("edgeDraggable", {
  dragControlCondition: function (moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }

    var target = e.inputEvent.target;
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("direction")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("line"));
  },
  dragControlStart: function (moveable, e) {
    return Draggable.dragStart(moveable, getDraggableEvent(e));
  },
  dragControl: function (moveable, e) {
    return Draggable.drag(moveable, getDraggableEvent(e));
  },
  dragControlEnd: function (moveable, e) {
    return Draggable.dragEnd(moveable, getDraggableEvent(e));
  },
  dragGroupControlCondition: function (moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }

    var target = e.inputEvent.target;
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("direction")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.hasClass)(target, prefix("line"));
  },
  dragGroupControlStart: function (moveable, e) {
    return Draggable.dragGroupStart(moveable, getDraggableEvent(e));
  },
  dragGroupControl: function (moveable, e) {
    return Draggable.dragGroup(moveable, getDraggableEvent(e));
  },
  dragGroupControlEnd: function (moveable, e) {
    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));
  },
  unset: function (moveable) {
    return Draggable.unset(moveable);
  }
});
/**
 * Whether to move by dragging the edge line (default: false)
 * @name Moveable.Draggable#edgeDraggable
 * @example
 * import Moveable from "moveable";
 *
 * const moveable = new Moveable(document.body, {
 *  draggable: true,
 *  edgeDraggable: false,
 * });
 *
 * moveable.edgeDraggable = true;
 */

var IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
};

var MOVEABLE_ABLES = /*#__PURE__*/[BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable];
var MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {
  return __assign(__assign({}, current), "events" in able ? able.events : {});
}, {});
var MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {
  return __assign(__assign({}, current), able.props);
}, {});
var MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);
var MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);
var MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);

function getMaxPos(poses, index) {
  return Math.max.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getMinPos(poses, index) {
  return Math.min.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getGroupRect(moveables, rotation) {
  if (!moveables.length) {
    return [0, 0, 0, 0];
  }

  var moveablePoses = moveables.map(function (_a) {
    var state = _a.state;
    return getAbsolutePosesByState(state);
  });
  var minX = MAX_NUM;
  var minY = MAX_NUM;
  var groupWidth = 0;
  var groupHeight = 0;
  var fixedRotation = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.throttle)(rotation, TINY_NUM);

  if (fixedRotation % 90) {
    var rad_1 = fixedRotation / 180 * Math.PI;
    var a1_1 = Math.tan(rad_1);
    var a2_1 = -1 / a1_1;
    var b1MinMax_1 = [MIN_NUM, MAX_NUM];
    var b2MinMax_1 = [MIN_NUM, MAX_NUM];
    moveablePoses.forEach(function (poses) {
      poses.forEach(function (pos) {
        // ax + b = y
        // b = y - ax
        var b1 = pos[1] - a1_1 * pos[0];
        var b2 = pos[1] - a2_1 * pos[0];
        b1MinMax_1[0] = Math.max(b1MinMax_1[0], b1);
        b1MinMax_1[1] = Math.min(b1MinMax_1[1], b1);
        b2MinMax_1[0] = Math.max(b2MinMax_1[0], b2);
        b2MinMax_1[1] = Math.min(b2MinMax_1[1], b2);
      });
    });
    b1MinMax_1.forEach(function (b1) {
      // a1x + b1 = a2x + b2
      b2MinMax_1.forEach(function (b2) {
        // (a1 - a2)x = b2 - b1
        var x = (b2 - b1) / (a1_1 - a2_1);
        var y = a1_1 * x + b1;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
      });
    });
    var rotatePoses = moveablePoses.map(function (_a) {
      var pos1 = _a[0],
          pos2 = _a[1],
          pos3 = _a[2],
          pos4 = _a[3];
      return [(0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos1, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos2, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos3, -rad_1), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate)(pos4, -rad_1)];
    });
    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);
    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);
  } else {
    minX = getMinPos(moveablePoses, 0);
    minY = getMinPos(moveablePoses, 1);
    groupWidth = getMaxPos(moveablePoses, 0) - minX;
    groupHeight = getMaxPos(moveablePoses, 1) - minY;

    if (fixedRotation % 180) {
      var changedWidth = groupWidth;
      groupWidth = groupHeight;
      groupHeight = changedWidth;
    }
  }

  return [minX, minY, groupWidth, groupHeight];
}
/**
 * @namespace Moveable.Group
 * @description You can make targets moveable.
 */


var MoveableGroup =
/*#__PURE__*/
function (_super) {
  __extends(MoveableGroup, _super);

  function MoveableGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.differ = new _egjs_children_differ__WEBPACK_IMPORTED_MODULE_6__["default"]();
    _this.moveables = [];
    _this.transformOrigin = "50% 50%";
    return _this;
  }

  var __proto = MoveableGroup.prototype;

  __proto.checkUpdate = function () {
    this.updateAbles();
  };

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    if (!this.controlBox) {
      return;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, false, false);
    });
    var state = this.state;
    var props = this.props;
    var target = state.target || props.target;

    if (!isTarget || type !== "" && props.updateGroup) {
      // reset rotataion
      this.rotation = props.defaultGroupRotate;
      this.transformOrigin = props.defaultGroupOrigin || "50% 50%";
      this.scale = [1, 1];
    }

    var rotation = this.rotation;
    var scale = this.scale;

    var _a = getGroupRect(this.moveables, rotation),
        left = _a[0],
        top = _a[1],
        width = _a[2],
        height = _a[3]; // tslint:disable-next-line: max-line-length


    var transform = "rotate(" + rotation + "deg) scale(" + (scale[0] >= 0 ? 1 : -1) + ", " + (scale[1] >= 0 ? 1 : -1) + ")";
    target.style.cssText += "left:0px;top:0px; transform-origin: " + this.transformOrigin + "; width:" + width + "px; height:" + height + "px;" + ("transform:" + transform);
    state.width = width;
    state.height = height;
    var container = this.getContainer();
    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container);
    var pos = [info.left, info.top];

    var _b = getAbsolutePosesByState(info),
        pos1 = _b[0],
        pos2 = _b[1],
        pos3 = _b[2],
        pos4 = _b[3]; // info.left + info.pos(1 ~ 4)


    var minPos = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getMinMaxs)([pos1, pos2, pos3, pos4]);
    var delta = [minPos.minX, minPos.minY];
    info.pos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos1, delta);
    info.pos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos2, delta);
    info.pos3 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos3, delta);
    info.pos4 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)(pos4, delta);
    info.left = left - info.left + delta[0];
    info.top = top - info.top + delta[1];
    info.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos, info.origin), delta);
    info.beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos, info.beforeOrigin), delta);
    info.originalBeforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_3__.plus)(pos, info.originalBeforeOrigin); // info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);

    var clientRect = info.targetClientRect;
    var direction = scale[0] * scale[1] > 0 ? 1 : -1;
    clientRect.top += info.top - state.top;
    clientRect.left += info.left - state.left;
    target.style.transform = "translate(" + -delta[0] + "px, " + -delta[1] + "px) " + transform;
    this.updateState(__assign(__assign({}, info), {
      direction: direction,
      beforeDirection: direction
    }), isSetState);
  };

  __proto.getRect = function () {
    return __assign(__assign({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function (child) {
        return child.getRect();
      })
    });
  };

  __proto.triggerEvent = function (name, e, isManager) {
    if (isManager || name.indexOf("Group") > -1) {
      return _super.prototype.triggerEvent.call(this, name, e);
    }
  };

  __proto.updateAbles = function () {
    _super.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables), [Groupable]), "Group");
  };

  __proto._updateTargets = function () {
    _super.prototype._updateTargets.call(this);

    this._prevTarget = this.props.dragTarget || this.areaElement;
  };

  __proto._updateEvents = function () {
    var state = this.state;
    var props = this.props;
    var prevTarget = this._prevTarget;
    var nextTarget = props.dragTarget || this.areaElement;

    if (prevTarget !== nextTarget) {
      unset(this, "targetGesto");
      unset(this, "controlGesto");
      state.target = null;
    }

    if (!state.target) {
      state.target = this.areaElement;
      this.controlBox.getElement().style.display = "block";
      this.targetGesto = getTargetAbleGesto(this, nextTarget, "Group");
      this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl");
    }

    var isContainerChanged = !equals(state.container, props.container);

    if (isContainerChanged) {
      state.container = props.container;
    }

    var _a = this.differ.update(props.targets),
        added = _a.added,
        changed = _a.changed,
        removed = _a.removed;

    if (isContainerChanged || added.length || changed.length || removed.length) {
      this.updateRect();
    }
  };

  __proto._updateObserver = function () {};

  MoveableGroup.defaultProps = __assign(__assign({}, MoveableManager.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: true,
    dragArea: true,
    keepRatio: true,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  });
  return MoveableGroup;
}(MoveableManager);

/**
 * @namespace Moveable.IndividualGroup
 * @description Create targets individually, not as a group.Create targets individually, not as a group.
 */

var MoveableIndividualGroup =
/*#__PURE__*/
function (_super) {
  __extends(MoveableIndividualGroup, _super);

  function MoveableIndividualGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.moveables = [];
    return _this;
  }

  var __proto = MoveableIndividualGroup.prototype;

  __proto.render = function () {
    var _this = this;

    var _a = this.props,
        cspNonce = _a.cspNonce,
        ControlBoxElement = _a.cssStyled,
        targets = _a.targets;
    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(ControlBoxElement, {
      cspNonce: cspNonce,
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "controlBox"),
      className: prefix("control-box")
    }, targets.map(function (target, i) {
      return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(MoveableManager, __assign({
        key: "moveable" + i,
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.refs)(_this, "moveables", i)
      }, _this.props, {
        target: target,
        wrapperMoveable: _this
      }));
    }));
  };

  __proto.componentDidUpdate = function () {};

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, isTarget, isSetState);
    });
  };

  __proto.getRect = function () {
    return __assign(__assign({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function (child) {
        return child.getRect();
      })
    });
  };

  __proto.request = function () {
    return {
      request: function () {
        return this;
      },
      requestEnd: function () {
        return this;
      }
    };
  };

  __proto.dragStart = function () {
    return this;
  };

  __proto.hitTest = function () {
    return 0;
  };

  __proto.isInside = function () {
    return false;
  };

  __proto.isDragging = function () {
    return false;
  };

  __proto.updateRenderPoses = function () {};

  __proto.checkUpdate = function () {};

  __proto.triggerEvent = function () {};

  __proto.updateAbles = function () {};

  __proto._updateEvents = function () {};

  __proto._updateObserver = function () {};

  return MoveableIndividualGroup;
}(MoveableManager);

var InitialMoveable =
/*#__PURE__*/
function (_super) {
  __extends(InitialMoveable, _super);

  function InitialMoveable() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.refTargets = [];
    _this.selectorMap = {};
    return _this;
  }

  var __proto = InitialMoveable.prototype;

  InitialMoveable.makeStyled = function () {
    var cssMap = {};
    var ables = this.getTotalAbles();
    ables.forEach(function (_a) {
      var css = _a.css;

      if (!css) {
        return;
      }

      css.forEach(function (text) {
        cssMap[text] = true;
      });
    });
    var style = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.getKeys)(cssMap).join("\n");
    this.defaultStyled = (0,react_compat_css_styled__WEBPACK_IMPORTED_MODULE_10__["default"])("div", (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.prefixCSS)(PREFIX, MOVEABLE_CSS + style));
  };

  InitialMoveable.getTotalAbles = function () {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles);
  };

  __proto.render = function () {
    var moveableContructor = this.constructor;

    if (!moveableContructor.defaultStyled) {
      moveableContructor.makeStyled();
    }

    var _a = this.props,
        userAbles = _a.ables,
        userProps = _a.props,
        props = __rest(_a, ["ables", "props"]);

    var refTargets = this._updateRefs(true);

    var elementTargets = getElementTargets(refTargets, this.selectorMap);
    var isGroup = elementTargets.length > 1;
    var totalAbles = moveableContructor.getTotalAbles();

    var ables = __spreadArray(__spreadArray([], totalAbles), userAbles || []);

    var nextProps = __assign(__assign(__assign({}, props), userProps || {}), {
      ables: ables,
      cssStyled: moveableContructor.defaultStyled,
      customStyledMap: moveableContructor.customStyledMap
    });

    if (isGroup) {
      if (props.individualGroupable) {
        return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(MoveableIndividualGroup, __assign({
          key: "individual-group",
          ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "moveable")
        }, nextProps, {
          target: null,
          targets: elementTargets
        }));
      }

      return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(MoveableGroup, __assign({
        key: "group",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "moveable")
      }, nextProps, {
        target: null,
        targets: elementTargets
      }));
    } else {
      return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.createElement)(MoveableManager, __assign({
        key: "single",
        ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "moveable")
      }, nextProps, {
        target: elementTargets[0]
      }));
    }
  };

  __proto.componentDidMount = function () {
    this._updateRefs();
  };

  __proto.componentDidUpdate = function () {
    this._updateRefs();
  };

  __proto.getManager = function () {
    return this.moveable;
  };

  __proto._updateRefs = function (isRender) {
    var prevRefTargets = this.refTargets;
    var nextRefTargets = getRefTargets(this.props.target || this.props.targets);
    var isBrowser = typeof document !== "undefined";
    var isUpdate = prevRefTargets.length !== nextRefTargets.length || prevRefTargets.some(function (target, i) {
      var nextTarget = nextRefTargets[i];

      if (!target && !nextTarget) {
        return false;
      } else if (target !== nextTarget) {
        return true;
      }

      return false;
    });
    var selectorMap = this.selectorMap;
    var nextSelectorMap = {};
    this.refTargets.forEach(function (target) {
      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(target)) {
        if (!selectorMap[target] && isBrowser) {
          isUpdate = true;
          nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));
        } else {
          nextSelectorMap[target] = selectorMap[target];
        }
      }
    });
    this.refTargets = nextRefTargets;
    this.selectorMap = nextSelectorMap;

    if (!isRender && isUpdate) {
      this.forceUpdate();
    }

    return nextRefTargets;
  };

  InitialMoveable.defaultAbles = [];
  InitialMoveable.customStyledMap = {};
  InitialMoveable.defaultStyled = null;

  __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.withMethods)(MOVEABLE_METHODS)], InitialMoveable.prototype, "moveable", void 0);

  return InitialMoveable;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_9__.PureComponent);

var Moveable =
/*#__PURE__*/
function (_super) {
  __extends(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Moveable.defaultAbles = MOVEABLE_ABLES;
  return Moveable;
}(InitialMoveable);

function makeMoveable(ables) {
  var _a;

  return _a =
  /*#__PURE__*/
  function (_super) {
    __extends(Moveable, _super);

    function Moveable() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    return Moveable;
  }(InitialMoveable), _a.defaultAbles = ables, _a;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Moveable);



/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useObservable.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useIsomorphicLayoutEffect.js");


function useObservable(observable$, initialValue) {
    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialValue), value = _a[0], update = _a[1];
    (0,_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
        var s = observable$.subscribe(update);
        return function () { return s.unsubscribe(); };
    }, [observable$]);
    return value;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useObservable);


/***/ }),

/***/ "./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ $),
/* harmony export */   "ANIMATION": () => (/* binding */ ANIMATION),
/* harmony export */   "ARRAY": () => (/* binding */ ARRAY),
/* harmony export */   "COLOR_MODELS": () => (/* binding */ COLOR_MODELS),
/* harmony export */   "DEFAULT_UNIT_PRESETS": () => (/* binding */ DEFAULT_UNIT_PRESETS),
/* harmony export */   "FILTER": () => (/* binding */ FILTER),
/* harmony export */   "FUNCTION": () => (/* binding */ FUNCTION),
/* harmony export */   "HSL": () => (/* binding */ HSL),
/* harmony export */   "HSLA": () => (/* binding */ HSLA),
/* harmony export */   "IS_WINDOW": () => (/* binding */ IS_WINDOW),
/* harmony export */   "KEYFRAMES": () => (/* binding */ KEYFRAMES),
/* harmony export */   "NUMBER": () => (/* binding */ NUMBER),
/* harmony export */   "OBJECT": () => (/* binding */ OBJECT),
/* harmony export */   "OPEN_CLOSED_CHARACTERS": () => (/* binding */ OPEN_CLOSED_CHARACTERS),
/* harmony export */   "PROPERTY": () => (/* binding */ PROPERTY),
/* harmony export */   "RGB": () => (/* binding */ RGB),
/* harmony export */   "RGBA": () => (/* binding */ RGBA),
/* harmony export */   "STRING": () => (/* binding */ STRING),
/* harmony export */   "TINY_NUM": () => (/* binding */ TINY_NUM),
/* harmony export */   "TRANSFORM": () => (/* binding */ TRANSFORM),
/* harmony export */   "UNDEFINED": () => (/* binding */ UNDEFINED),
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "addEvent": () => (/* binding */ addEvent),
/* harmony export */   "average": () => (/* binding */ average),
/* harmony export */   "between": () => (/* binding */ between),
/* harmony export */   "calculateBoundSize": () => (/* binding */ calculateBoundSize),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "cancelAnimationFrame": () => (/* binding */ cancelAnimationFrame),
/* harmony export */   "checkBoundSize": () => (/* binding */ checkBoundSize),
/* harmony export */   "convertUnitSize": () => (/* binding */ convertUnitSize),
/* harmony export */   "counter": () => (/* binding */ counter),
/* harmony export */   "cutHex": () => (/* binding */ cutHex),
/* harmony export */   "decamelize": () => (/* binding */ decamelize),
/* harmony export */   "document": () => (/* binding */ doc),
/* harmony export */   "dot": () => (/* binding */ dot),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "findIndex": () => (/* binding */ findIndex),
/* harmony export */   "findLast": () => (/* binding */ findLast),
/* harmony export */   "findLastIndex": () => (/* binding */ findLastIndex),
/* harmony export */   "fromCSS": () => (/* binding */ fromCSS),
/* harmony export */   "getCenterPoint": () => (/* binding */ getCenterPoint),
/* harmony export */   "getCrossBrowserProperty": () => (/* binding */ getCrossBrowserProperty),
/* harmony export */   "getDist": () => (/* binding */ getDist),
/* harmony export */   "getKeys": () => (/* binding */ getKeys),
/* harmony export */   "getRad": () => (/* binding */ getRad),
/* harmony export */   "getShapeDirection": () => (/* binding */ getShapeDirection),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "hexToRGBA": () => (/* binding */ hexToRGBA),
/* harmony export */   "hslToRGBA": () => (/* binding */ hslToRGBA),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isUndefined": () => (/* binding */ isUndefined),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "removeEvent": () => (/* binding */ removeEvent),
/* harmony export */   "replaceOnce": () => (/* binding */ replaceOnce),
/* harmony export */   "requestAnimationFrame": () => (/* binding */ requestAnimationFrame),
/* harmony export */   "sortOrders": () => (/* binding */ sortOrders),
/* harmony export */   "splitBracket": () => (/* binding */ splitBracket),
/* harmony export */   "splitComma": () => (/* binding */ splitComma),
/* harmony export */   "splitSpace": () => (/* binding */ splitSpace),
/* harmony export */   "splitText": () => (/* binding */ splitText),
/* harmony export */   "splitUnit": () => (/* binding */ splitUnit),
/* harmony export */   "stringToRGBA": () => (/* binding */ stringToRGBA),
/* harmony export */   "sum": () => (/* binding */ sum),
/* harmony export */   "throttle": () => (/* binding */ throttle),
/* harmony export */   "throttleArray": () => (/* binding */ throttleArray),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "toFullHex": () => (/* binding */ toFullHex)
/* harmony export */ });
/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.6.0
*/
/**
* @namespace
* @name Consts
*/

/**
* get string "rgb"
* @memberof Color
* @example
import {RGB} from "@daybrush/utils";

console.log(RGB); // "rgb"
*/
var RGB = "rgb";
/**
* get string "rgba"
* @memberof Color
* @example
import {RGBA} from "@daybrush/utils";

console.log(RGBA); // "rgba"
*/

var RGBA = "rgba";
/**
* get string "hsl"
* @memberof Color
* @example
import {HSL} from "@daybrush/utils";

console.log(HSL); // "hsl"
*/

var HSL = "hsl";
/**
* get string "hsla"
* @memberof Color
* @example
import {HSLA} from "@daybrush/utils";

console.log(HSLA); // "hsla"
*/

var HSLA = "hsla";
/**
* gets an array of color models.
* @memberof Color
* @example
import {COLOR_MODELS} from "@daybrush/utils";

console.log(COLOR_MODELS); // ["rgb", "rgba", "hsl", "hsla"];
*/

var COLOR_MODELS = [RGB, RGBA, HSL, HSLA];
/**
* get string "function"
* @memberof Consts
* @example
import {FUNCTION} from "@daybrush/utils";

console.log(FUNCTION); // "function"
*/

var FUNCTION = "function";
/**
* get string "property"
* @memberof Consts
* @example
import {PROPERTY} from "@daybrush/utils";

console.log(PROPERTY); // "property"
*/

var PROPERTY = "property";
/**
* get string "array"
* @memberof Consts
* @example
import {ARRAY} from "@daybrush/utils";

console.log(ARRAY); // "array"
*/

var ARRAY = "array";
/**
* get string "object"
* @memberof Consts
* @example
import {OBJECT} from "@daybrush/utils";

console.log(OBJECT); // "object"
*/

var OBJECT = "object";
/**
* get string "string"
* @memberof Consts
* @example
import {STRING} from "@daybrush/utils";

console.log(STRING); // "string"
*/

var STRING = "string";
/**
* get string "number"
* @memberof Consts
* @example
import {NUMBER} from "@daybrush/utils";

console.log(NUMBER); // "number"
*/

var NUMBER = "number";
/**
* get string "undefined"
* @memberof Consts
* @example
import {UNDEFINED} from "@daybrush/utils";

console.log(UNDEFINED); // "undefined"
*/

var UNDEFINED = "undefined";
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var IS_WINDOW = typeof window !== UNDEFINED;
/**
* Check whether the environment is window or node.js.
* @memberof Consts
* @name document
* @example
import {IS_WINDOW} from "@daybrush/utils";

console.log(IS_WINDOW); // false in node.js
console.log(IS_WINDOW); // true in browser
*/

var doc = typeof document !== UNDEFINED && document; // FIXME: this type maybe false
var prefixes = ["webkit", "ms", "moz", "o"];
/**
 * @namespace CrossBrowser
 */

/**
* Get a CSS property with a vendor prefix that supports cross browser.
* @function
* @param {string} property - A CSS property
* @return {string} CSS property with cross-browser vendor prefix
* @memberof CrossBrowser
* @example
import {getCrossBrowserProperty} from "@daybrush/utils";

console.log(getCrossBrowserProperty("transform")); // "transform", "-ms-transform", "-webkit-transform"
console.log(getCrossBrowserProperty("filter")); // "filter", "-webkit-filter"
*/

var getCrossBrowserProperty = /*#__PURE__*/function (property) {
  if (!doc) {
    return "";
  }

  var styles = (doc.body || doc.documentElement).style;
  var length = prefixes.length;

  if (typeof styles[property] !== UNDEFINED) {
    return property;
  }

  for (var i = 0; i < length; ++i) {
    var name = "-" + prefixes[i] + "-" + property;

    if (typeof styles[name] !== UNDEFINED) {
      return name;
    }
  }

  return "";
};
/**
* get string "transfrom" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {TRANSFORM} from "@daybrush/utils";

console.log(TRANSFORM); // "transform", "-ms-transform", "-webkit-transform"
*/

var TRANSFORM = /*#__PURE__*/getCrossBrowserProperty("transform");
/**
* get string "filter" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {FILTER} from "@daybrush/utils";

console.log(FILTER); // "filter", "-ms-filter", "-webkit-filter"
*/

var FILTER = /*#__PURE__*/getCrossBrowserProperty("filter");
/**
* get string "animation" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {ANIMATION} from "@daybrush/utils";

console.log(ANIMATION); // "animation", "-ms-animation", "-webkit-animation"
*/

var ANIMATION = /*#__PURE__*/getCrossBrowserProperty("animation");
/**
* get string "keyframes" with the vendor prefix.
* @memberof CrossBrowser
* @example
import {KEYFRAMES} from "@daybrush/utils";

console.log(KEYFRAMES); // "keyframes", "-ms-keyframes", "-webkit-keyframes"
*/

var KEYFRAMES = /*#__PURE__*/ANIMATION.replace("animation", "keyframes");
var OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: "\"",
  close: "\""
}, {
  open: "'",
  close: "'"
}, {
  open: "\\\"",
  close: "\\\""
}, {
  open: "\\'",
  close: "\\'"
}];
var TINY_NUM = 0.0000001;
var DEFAULT_UNIT_PRESETS = {
  "cm": function (pos) {
    return pos * 96 / 2.54;
  },
  "mm": function (pos) {
    return pos * 96 / 254;
  },
  "in": function (pos) {
    return pos * 96;
  },
  "pt": function (pos) {
    return pos * 96 / 72;
  },
  "pc": function (pos) {
    return pos * 96 / 6;
  },
  "%": function (pos, size) {
    return pos * size / 100;
  },
  "vw": function (pos, size) {
    if (size === void 0) {
      size = window.innerWidth;
    }

    return pos / 100 * size;
  },
  "vh": function (pos, size) {
    if (size === void 0) {
      size = window.innerHeight;
    }

    return pos / 100 * size;
  },
  "vmax": function (pos, size) {
    if (size === void 0) {
      size = Math.max(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  },
  "vmin": function (pos, size) {
    if (size === void 0) {
      size = Math.min(window.innerWidth, window.innerHeight);
    }

    return pos / 100 * size;
  }
};

/**
* @namespace
* @name Utils
*/

/**
 * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).
 * @memberof Utils
 * @param - The first number
 * @param - The second number
 * @param - The first number to base on the inner product
 * @param - The second number to base on the inner product
 * @return - Returns the inner product
import { dot } from "@daybrush/utils";

console.log(dot(0, 15, 2, 3)); // 6
console.log(dot(5, 15, 2, 3)); // 9
console.log(dot(5, 15, 1, 1)); // 10
 */

function dot(a1, a2, b1, b2) {
  return (a1 * b2 + a2 * b1) / (b1 + b2);
}
/**
* Check the type that the value is undefined.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {boolean} true if the type is correct, false otherwise
* @example
import {isUndefined} from "@daybrush/utils";

console.log(isUndefined(undefined)); // true
console.log(isUndefined("")); // false
console.log(isUndefined(1)); // false
console.log(isUndefined(null)); // false
*/

function isUndefined(value) {
  return typeof value === UNDEFINED;
}
/**
* Check the type that the value is object.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isObject} from "@daybrush/utils";

console.log(isObject({})); // true
console.log(isObject(undefined)); // false
console.log(isObject("")); // false
console.log(isObject(null)); // false
*/

function isObject(value) {
  return value && typeof value === OBJECT;
}
/**
* Check the type that the value is isArray.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isArray} from "@daybrush/utils";

console.log(isArray([])); // true
console.log(isArray({})); // false
console.log(isArray(undefined)); // false
console.log(isArray(null)); // false
*/

function isArray(value) {
  return Array.isArray(value);
}
/**
* Check the type that the value is string.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isString} from "@daybrush/utils";

console.log(isString("1234")); // true
console.log(isString(undefined)); // false
console.log(isString(1)); // false
console.log(isString(null)); // false
*/

function isString(value) {
  return typeof value === STRING;
}
function isNumber(value) {
  return typeof value === NUMBER;
}
/**
* Check the type that the value is function.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isFunction} from "@daybrush/utils";

console.log(isFunction(function a() {})); // true
console.log(isFunction(() => {})); // true
console.log(isFunction("1234")); // false
console.log(isFunction(1)); // false
console.log(isFunction(null)); // false
*/

function isFunction(value) {
  return typeof value === FUNCTION;
}

function isEqualSeparator(character, separator) {
  var isCharacterSpace = character === "" || character == " ";
  var isSeparatorSpace = separator === "" || separator == " ";
  return isSeparatorSpace && isCharacterSpace || character === separator;
}

function findOpen(openCharacter, texts, index, length, openCloseCharacters) {
  var isIgnore = findIgnore(openCharacter, texts, index);

  if (!isIgnore) {
    return findClose(openCharacter, texts, index + 1, length, openCloseCharacters);
  }

  return index;
}

function findIgnore(character, texts, index) {
  if (!character.ignore) {
    return null;
  }

  var otherText = texts.slice(Math.max(index - 3, 0), index + 3).join("");
  return new RegExp(character.ignore).exec(otherText);
}

function findClose(closeCharacter, texts, index, length, openCloseCharacters) {
  var _loop_1 = function (i) {
    var character = texts[i].trim();

    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i)) {
      return {
        value: i
      };
    }

    var nextIndex = i; // re open

    var openCharacter = find(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);
    }

    if (nextIndex === -1) {
      return out_i_1 = i, "break";
    }

    i = nextIndex;
    out_i_1 = i;
  };

  var out_i_1;

  for (var i = index; i < length; ++i) {
    var state_1 = _loop_1(i);

    i = out_i_1;
    if (typeof state_1 === "object") return state_1.value;
    if (state_1 === "break") break;
  }

  return -1;
}

function splitText(text, splitOptions) {
  var _a = isString(splitOptions) ? {
    separator: splitOptions
  } : splitOptions,
      _b = _a.separator,
      separator = _b === void 0 ? "," : _b,
      isSeparateFirst = _a.isSeparateFirst,
      isSeparateOnlyOpenClose = _a.isSeparateOnlyOpenClose,
      _c = _a.isSeparateOpenClose,
      isSeparateOpenClose = _c === void 0 ? isSeparateOnlyOpenClose : _c,
      _d = _a.openCloseCharacters,
      openCloseCharacters = _d === void 0 ? OPEN_CLOSED_CHARACTERS : _d;

  var openClosedText = openCloseCharacters.map(function (_a) {
    var open = _a.open,
        close = _a.close;

    if (open === close) {
      return open;
    }

    return open + "|" + close;
  }).join("|");
  var regexText = "(\\s*" + separator + "\\s*|" + openClosedText + "|\\s+)";
  var regex = new RegExp(regexText, "g");
  var texts = text.split(regex).filter(Boolean);
  var length = texts.length;
  var values = [];
  var tempValues = [];

  function resetTemp() {
    if (tempValues.length) {
      values.push(tempValues.join(""));
      tempValues = [];
      return true;
    }

    return false;
  }

  var _loop_2 = function (i) {
    var character = texts[i].trim();
    var nextIndex = i;
    var openCharacter = find(openCloseCharacters, function (_a) {
      var open = _a.open;
      return open === character;
    });
    var closeCharacter = find(openCloseCharacters, function (_a) {
      var close = _a.close;
      return close === character;
    });

    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);

      if (nextIndex !== -1 && isSeparateOpenClose) {
        if (resetTemp() && isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        values.push(texts.slice(i, nextIndex + 1).join(""));
        i = nextIndex;

        if (isSeparateFirst) {
          return out_i_2 = i, "break";
        }

        return out_i_2 = i, "continue";
      }
    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {
      throw new Error("invalid format: " + closeCharacter.close);
    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {
      resetTemp();

      if (isSeparateFirst) {
        return out_i_2 = i, "break";
      }

      return out_i_2 = i, "continue";
    }

    if (nextIndex === -1) {
      nextIndex = length - 1;
    }

    tempValues.push(texts.slice(i, nextIndex + 1).join(""));
    i = nextIndex;
    out_i_2 = i;
  };

  var out_i_2;

  for (var i = 0; i < length; ++i) {
    var state_2 = _loop_2(i);

    i = out_i_2;
    if (state_2 === "break") break;
  }

  if (tempValues.length) {
    values.push(tempValues.join(""));
  }

  return values;
}
/**
* divide text by space.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {spliceSpace} from "@daybrush/utils";

console.log(splitSpace("a b c d e f g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitSpace("'a,b' c 'd,e' f g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitSpace(text) {
  // divide comma(space)
  return splitText(text, "");
}
/**
* divide text by comma.
* @memberof Utils
* @param {string} text - text to divide
* @return {Array} divided texts
* @example
import {splitComma} from "@daybrush/utils";

console.log(splitComma("a,b,c,d,e,f,g"));
// ["a", "b", "c", "d", "e", "f", "g"]
console.log(splitComma("'a,b',c,'d,e',f,g"));
// ["'a,b'", "c", "'d,e'", "f", "g"]
*/

function splitComma(text) {
  // divide comma(,)
  // "[^"]*"|'[^']*'
  return splitText(text, ",");
}
/**
* divide text by bracket "(", ")".
* @memberof Utils
* @param {string} text - text to divide
* @return {object} divided texts
* @example
import {splitBracket} from "@daybrush/utils";

console.log(splitBracket("a(1, 2)"));
// {prefix: "a", value: "1, 2", suffix: ""}
console.log(splitBracket("a(1, 2)b"));
// {prefix: "a", value: "1, 2", suffix: "b"}
*/

function splitBracket(text) {
  var matches = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(text);

  if (!matches || matches.length < 4) {
    return {};
  } else {
    return {
      prefix: matches[1],
      value: matches[2],
      suffix: matches[3]
    };
  }
}
/**
* divide text by number and unit.
* @memberof Utils
* @param {string} text - text to divide
* @return {} divided texts
* @example
import {splitUnit} from "@daybrush/utils";

console.log(splitUnit("10px"));
// {prefix: "", value: 10, unit: "px"}
console.log(splitUnit("-10px"));
// {prefix: "", value: -10, unit: "px"}
console.log(splitUnit("a10%"));
// {prefix: "a", value: 10, unit: "%"}
*/

function splitUnit(text) {
  var matches = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(text);

  if (!matches) {
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  }

  var prefix = matches[1];
  var value = matches[2];
  var unit = matches[3];
  return {
    prefix: prefix,
    unit: unit,
    value: parseFloat(value)
  };
}
/**
* transform strings to camel-case
* @memberof Utils
* @param {String} text - string
* @return {String} camel-case string
* @example
import {camelize} from "@daybrush/utils";

console.log(camelize("transform-origin")); // transformOrigin
console.log(camelize("abcd_efg")); // abcdEfg
console.log(camelize("abcd efg")); // abcdEfg
*/

function camelize(str) {
  return str.replace(/[\s-_]([a-z])/g, function (all, letter) {
    return letter.toUpperCase();
  });
}
/**
* transform a camelized string into a lowercased string.
* @memberof Utils
* @param {string} text - a camel-cased string
* @param {string} [separator="-"] - a separator
* @return {string}  a lowercased string
* @example
import {decamelize} from "@daybrush/utils";

console.log(decamelize("transformOrigin")); // transform-origin
console.log(decamelize("abcdEfg", "_")); // abcd_efg
*/

function decamelize(str, separator) {
  if (separator === void 0) {
    separator = "-";
  }

  return str.replace(/([a-z])([A-Z])/g, function (all, letter, letter2) {
    return "" + letter + separator + letter2.toLowerCase();
  });
}
/**
* transforms something in an array into an array.
* @memberof Utils
* @param - Array form
* @return an array
* @example
import {toArray} from "@daybrush/utils";

const arr1 = toArray(document.querySelectorAll(".a")); // Element[]
const arr2 = toArray(document.querySelectorAll<HTMLElement>(".a")); // HTMLElement[]
*/

function toArray(value) {
  return [].slice.call(value);
}
/**
* Date.now() method
* @memberof CrossBrowser
* @return {number} milliseconds
* @example
import {now} from "@daybrush/utils";

console.log(now()); // 12121324241(milliseconds)
*/

function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
/**
* Returns the index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findIndex } from "@daybrush/utils";

findIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the reverse direction index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findLastIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findLastIndex } from "@daybrush/utils";

findLastIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findLastIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = length - 1; i >= 0; --i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Returns the value of the reverse direction element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findLast` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function findLast(arr, callback, defalutValue) {
  var index = findLastIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* Returns the value of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `find` was called upon.
* @param - A function to execute on each value in the array,
* @param - Returns defalutValue if not found by the function.
* @example
import { find } from "@daybrush/utils";

find([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}
*/

function find(arr, callback, defalutValue) {
  var index = findIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
/**
* window.requestAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.
* @return {number} id
* @example
import {requestAnimationFrame} from "@daybrush/utils";

requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});
*/

var requestAnimationFrame = /*#__PURE__*/function () {
  var firstTime = now();
  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return raf ? raf.bind(window) : function (callback) {
    var currTime = now();
    var id = window.setTimeout(function () {
      callback(currTime - firstTime);
    }, 1000 / 60);
    return id;
  };
}();
/**
* window.cancelAnimationFrame() method with cross browser.
* @function
* @memberof CrossBrowser
* @param {number} handle - the id obtained through requestAnimationFrame method
* @return {void}
* @example
import { requestAnimationFrame, cancelAnimationFrame } from "@daybrush/utils";

const id = requestAnimationFrame((timestamp) => {
  console.log(timestamp);
});

cancelAnimationFrame(id);
*/

var cancelAnimationFrame = /*#__PURE__*/function () {
  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return caf ? caf.bind(window) : function (handle) {
    clearTimeout(handle);
  };
}();
/**
* @function
* @memberof Utils
*/

function getKeys(obj) {
  if (Object.keys) {
    return Object.keys(obj);
  }

  var keys = [];

  for (var name in keys) {
    keys.push(name);
  }

  return keys;
}
/**
* @function
* @memberof Utils
*/

function sortOrders(keys, orders) {
  if (orders === void 0) {
    orders = [];
  }

  keys.sort(function (a, b) {
    var index1 = orders.indexOf(a);
    var index2 = orders.indexOf(b);

    if (index2 === -1 && index1 === -1) {
      return 0;
    }

    if (index1 === -1) {
      return 1;
    }

    if (index2 === -1) {
      return -1;
    }

    return index1 - index2;
  });
}
/**
* convert unit size to px size
* @function
* @memberof Utils
*/

function convertUnitSize(pos, size) {
  var _a = splitUnit(pos),
      value = _a.value,
      unit = _a.unit;

  if (isObject(size)) {
    var sizeFunction = size[unit];

    if (sizeFunction) {
      if (isFunction(sizeFunction)) {
        return sizeFunction(value);
      } else if (DEFAULT_UNIT_PRESETS[unit]) {
        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);
      }
    }
  } else if (unit === "%") {
    return value * size / 100;
  }

  if (DEFAULT_UNIT_PRESETS[unit]) {
    return DEFAULT_UNIT_PRESETS[unit](value);
  }

  return value;
}
/**
* calculate between min, max
* @function
* @memberof Utils
*/

function between(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
function checkBoundSize(targetSize, compareSize, isMax) {
  return [[throttle(compareSize[0], TINY_NUM), throttle(compareSize[0] * targetSize[1] / targetSize[0], TINY_NUM)], [throttle(compareSize[1] * targetSize[0] / targetSize[1], TINY_NUM), throttle(compareSize[1], TINY_NUM)]].filter(function (size) {
    return size.every(function (value, i) {
      return isMax ? value <= compareSize[i] : value >= compareSize[i];
    });
  })[0] || targetSize;
}
/**
* calculate bound size
* @function
* @memberof Utils
*/

function calculateBoundSize(size, minSize, maxSize, keepRatio) {
  if (!keepRatio) {
    return size.map(function (value, i) {
      return between(value, minSize[i], maxSize[i]);
    });
  }

  var width = size[0],
      height = size[1]; // width : height = minWidth : minHeight;

  var _a = checkBoundSize(size, minSize, false),
      minWidth = _a[0],
      minHeight = _a[1];

  var _b = checkBoundSize(size, maxSize, true),
      maxWidth = _b[0],
      maxHeight = _b[1];

  if (width < minWidth || height < minHeight) {
    width = minWidth;
    height = minHeight;
  } else if (width > maxWidth || height > maxHeight) {
    width = maxWidth;
    height = maxHeight;
  }

  return [width, height];
}
/**
* Add all the numbers.
* @function
* @memberof Utils
*/

function sum(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return total;
}
/**
* Average all numbers.
* @function
* @memberof Utils
*/

function average(nums) {
  var length = nums.length;
  var total = 0;

  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }

  return length ? total / length : 0;
}
/**
* Get the angle of two points. (0 <= rad < 359)
* @function
* @memberof Utils
*/

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
/**
* Get the average point of all points.
* @function
* @memberof Utils
*/

function getCenterPoint(points) {
  return [0, 1].map(function (i) {
    return average(points.map(function (pos) {
      return pos[i];
    }));
  });
}
/**
* Gets the direction of the shape.
* @function
* @memberof Utils
*/

function getShapeDirection(points) {
  var center = getCenterPoint(points);
  var pos1Rad = getRad(center, points[0]);
  var pos2Rad = getRad(center, points[1]);
  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;
}
/**
* Get the distance between two points.
* @function
* @memberof Utils
*/

function getDist(a, b) {
  return Math.sqrt(Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2));
}
/**
* throttle number depending on the unit.
* @function
* @memberof Utils
*/

function throttle(num, unit) {
  if (!unit) {
    return num;
  }

  return Math.round(num / unit) * unit;
}
/**
* throttle number array depending on the unit.
* @function
* @memberof Utils
*/

function throttleArray(nums, unit) {
  nums.forEach(function (_, i) {
    nums[i] = throttle(nums[i], unit);
  });
  return nums;
}
/**
* @function
* @memberof Utils
*/

function counter(num) {
  var nums = [];

  for (var i = 0; i < num; ++i) {
    nums.push(i);
  }

  return nums;
}
/**
* @function
* @memberof Utils
*/

function replaceOnce(text, fromText, toText) {
  var isOnce = false;
  return text.replace(fromText, function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (isOnce) {
      return args[0];
    }

    isOnce = true;
    return isString(toText) ? toText : toText.apply(void 0, args);
  });
}

/**
* @namespace
* @name Color
*/

/**
* Remove the # from the hex color.
* @memberof Color
* @param {} hex - hex color
* @return {} hex color
* @example
import {cutHex} from "@daybrush/utils";

console.log(cutHex("#000000")) // "000000"
*/

function cutHex(hex) {
  return hex.replace("#", "");
}
/**
* convert hex color to rgb color.
* @memberof Color
* @param {} hex - hex color
* @return {} rgb color
* @example
import {hexToRGBA} from "@daybrush/utils";

console.log(hexToRGBA("#00000005"));
// [0, 0, 0, 1]
console.log(hexToRGBA("#201045"));
// [32, 16, 69, 1]
*/

function hexToRGBA(hex) {
  var h = cutHex(hex);
  var r = parseInt(h.substring(0, 2), 16);
  var g = parseInt(h.substring(2, 4), 16);
  var b = parseInt(h.substring(4, 6), 16);
  var a = parseInt(h.substring(6, 8), 16) / 255;

  if (isNaN(a)) {
    a = 1;
  }

  return [r, g, b, a];
}
/**
* convert 3(or 4)-digit hex color to 6(or 8)-digit hex color.
* @memberof Color
* @param {} hex - 3(or 4)-digit hex color
* @return {} 6(or 8)-digit hex color
* @example
import {toFullHex} from "@daybrush/utils";

console.log(toFullHex("#123")); // "#112233"
console.log(toFullHex("#123a")); // "#112233aa"
*/

function toFullHex(h) {
  var r = h.charAt(1);
  var g = h.charAt(2);
  var b = h.charAt(3);
  var a = h.charAt(4);
  var arr = ["#", r, r, g, g, b, b, a, a];
  return arr.join("");
}
/**
* convert hsl color to rgba color.
* @memberof Color
* @param {} hsl - hsl color(hue: 0 ~ 360, saturation: 0 ~ 1, lightness: 0 ~ 1, alpha: 0 ~ 1)
* @return {} rgba color
* @example
import {hslToRGBA} from "@daybrush/utils";

console.log(hslToRGBA([150, 0.5, 0.4]));
// [51, 153, 102, 1]
*/

function hslToRGBA(hsl) {
  var _a;

  var h = hsl[0];
  var s = hsl[1];
  var l = hsl[2];

  if (h < 0) {
    h += Math.floor((Math.abs(h) + 360) / 360) * 360;
  }

  h %= 360;
  var c = (1 - Math.abs(2 * l - 1)) * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = l - c / 2;
  var rgb;

  if (h < 60) {
    rgb = [c, x, 0];
  } else if (h < 120) {
    rgb = [x, c, 0];
  } else if (h < 180) {
    rgb = [0, c, x];
  } else if (h < 240) {
    rgb = [0, x, c];
  } else if (h < 300) {
    rgb = [x, 0, c];
  } else if (h < 360) {
    rgb = [c, 0, x];
  } else {
    rgb = [0, 0, 0];
  }

  return [Math.round((rgb[0] + m) * 255), Math.round((rgb[1] + m) * 255), Math.round((rgb[2] + m) * 255), (_a = hsl[3]) !== null && _a !== void 0 ? _a : 1];
}
/**
* convert string to rgba color.
* @memberof Color
* @param {} - 3-hex(#000), 4-hex(#0000) 6-hex(#000000), 8-hex(#00000000) or RGB(A), or HSL(A)
* @return {} rgba color
* @example
import {stringToRGBA} from "@daybrush/utils";

console.log(stringToRGBA("#000000")); // [0, 0, 0, 1]
console.log(stringToRGBA("rgb(100, 100, 100)")); // [100, 100, 100, 1]
console.log(stringToRGBA("hsl(150, 0.5, 0.4)")); // [51, 153, 102, 1]
*/

function stringToRGBA(color) {
  if (color.charAt(0) === "#") {
    if (color.length === 4 || color.length === 5) {
      return hexToRGBA(toFullHex(color));
    } else {
      return hexToRGBA(color);
    }
  } else if (color.indexOf("(") !== -1) {
    // in bracket.
    var _a = splitBracket(color),
        prefix = _a.prefix,
        value = _a.value;

    if (!prefix || !value) {
      return undefined;
    }

    var arr = splitComma(value);
    var colorArr = [0, 0, 0, 1];
    var length = arr.length;

    switch (prefix) {
      case RGB:
      case RGBA:
        for (var i = 0; i < length; ++i) {
          colorArr[i] = parseFloat(arr[i]);
        }

        return colorArr;

      case HSL:
      case HSLA:
        for (var i = 0; i < length; ++i) {
          if (arr[i].indexOf("%") !== -1) {
            colorArr[i] = parseFloat(arr[i]) / 100;
          } else {
            colorArr[i] = parseFloat(arr[i]);
          }
        } // hsl, hsla to rgba


        return hslToRGBA(colorArr);
    }
  }

  return undefined;
}

/**
 * Returns all element descendants of node that
 * match selectors.
 */

/**
 * Checks if the specified class value exists in the element's class attribute.
 * @memberof DOM
 * @param - A DOMString containing one or more selectors to match
 * @param - If multi is true, a DOMString containing one or more selectors to match against.
 * @example
import {$} from "@daybrush/utils";

console.log($("div")); // div element
console.log($("div", true)); // [div, div] elements
*/

function $(selectors, multi) {
  return multi ? doc.querySelectorAll(selectors) : doc.querySelector(selectors);
}
/**
* Checks if the specified class value exists in the element's class attribute.
* @memberof DOM
* @param element - target
* @param className - the class name to search
* @return {boolean} return false if the class is not found.
* @example
import {hasClass} from "@daybrush/utils";

console.log(hasClass(element, "start")); // true or false
*/

function hasClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  }

  return !!element.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
}
/**
* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.
* @memberof DOM
* @param element - target
* @param className - the class name to add
* @example
import {addClass} from "@daybrush/utils";

addClass(element, "start");
*/

function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    element.className += " " + className;
  }
}
/**
* Removes the specified class value.
* @memberof DOM
* @param element - target
* @param className - the class name to remove
* @example
import {removeClass} from "@daybrush/utils";

removeClass(element, "start");
*/

function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    element.className = element.className.replace(reg, " ");
  }
}
/**
* Gets the CSS properties from the element.
* @memberof DOM
* @param elements - elements
* @param properites - the CSS properties
* @return returns CSS properties and values.
* @example
import {fromCSS} from "@daybrush/utils";

console.log(fromCSS(element, ["left", "opacity", "top"])); // {"left": "10px", "opacity": 1, "top": "10px"}
*/

function fromCSS(elements, properties) {
  if (!elements || !properties || !properties.length) {
    return {};
  }

  var element;

  if (elements instanceof Element) {
    element = elements;
  } else if (elements.length) {
    element = elements[0];
  } else {
    return {};
  }

  var cssObject = {};
  var styles = window.getComputedStyle(element);
  var length = properties.length;

  for (var i = 0; i < length; ++i) {
    cssObject[properties[i]] = styles[properties[i]];
  }

  return cssObject;
}
/**
* Sets up a function that will be called whenever the specified event is delivered to the target
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent} from "@daybrush/utils";

addEvent(el, "click", e => {
  console.log(e);
});
*/

function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
/**
* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The EventListener function of the event handler to remove from the event target.
* @param - An options object that specifies characteristics about the event listener.
* @example
import {addEvent, removeEvent} from "@daybrush/utils";
const listener = e => {
  console.log(e);
};
addEvent(el, "click", listener);
removeEvent(el, "click", listener);
*/

function removeEvent(el, type, listener, options) {
  el.removeEventListener(type, listener, options);
}


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-agent-npm-2.3.0-e88ca0eec2-2506e8feff.zip/node_modules/@egjs/agent/dist/agent.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getAccurateAgent": () => (/* binding */ getAccurateAgent)
/* harmony export */ });
/*
Copyright (c) 2015 NAVER Corp.
name: @egjs/agent
license: MIT
author: NAVER Corp.
repository: git+https://github.com/naver/agent.git
version: 2.3.0
*/
function some(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return true;
    }
  }

  return false;
}
function find(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }

  return null;
}
function getUserAgent(agent) {
  var userAgent = agent;

  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }

    userAgent = navigator.userAgent || "";
  }

  return userAgent.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }

  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version = "-1";
  some(presets, function (preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);

    if (!result || preset.brand) {
      return false;
    }

    userPreset = preset;
    version = result[3] || "-1";

    if (preset.versionAlias) {
      version = preset.versionAlias;
    } else if (preset.versionTest) {
      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;
    }

    version = convertVersion(version);
    return true;
  });
  return {
    preset: userPreset,
    version: version
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function (preset) {
    var result = findBrand(brands, preset);

    if (!result) {
      return false;
    }

    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function (_a) {
    var brand = _a.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}

var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}]; // chromium's engine(blink) is based on applewebkit 537.36.

var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "mac os x",
  id: "mac"
}, {
  test: "android",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];

function parseUserAgentData(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;

  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }

  if (osData) {
    var platform_1 = osData.platform.toLowerCase();
    var result = find(OS_PRESETS, function (preset) {
      return new RegExp("" + preset.test, "g").exec(platform_1);
    });
    os.name = result ? result.id : platform_1;
    os.version = osData.platformVersion;
  }

  var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);

  if (browserBrand.brand) {
    browser.name = browserBrand.brand;
    browser.version = osData ? osData.uaFullVersion : browserBrand.version;
  }

  if (navigator.platform === "Linux armv8l") {
    os.name = "android";
  } else if (browser.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }

  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }

  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: true
  };
}

function parseUserAgent(userAgent) {
  var nextAgent = getUserAgent(userAgent);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: !!findPreset(WEBVIEW_PRESETS, nextAgent).preset,
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };

  var _a = findPreset(BROWSER_PRESETS, nextAgent),
      browserPreset = _a.preset,
      browserVersion = _a.version;

  var _b = findPreset(OS_PRESETS, nextAgent),
      osPreset = _b.preset,
      osVersion = _b.version;

  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;

  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }

  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }

  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion;

    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }

  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: false
  };
}

/**
 * @namespace eg.agent
 */

/**
* Extracts accuate browser and operating system information from the user agent string or client hints.
* @ko     client hints     .
* @function eg.agent#getAccurateAgent
* @param - Callback function to get the accuate agent <ko>    callback </ko>
* @return - get the accuate agent promise. If Promise are not supported, null is returned. <ko>   promise . Promise    , null . </ko>
* @example
import { getAccurateAgent } from "@egjs/agent";
// eg.agent.getAccurateAgent()
getAccurateAgent().then(agent => {
   const { os, browser, isMobile } = agent;
});
getAccurateAgent(agent => {
    const { os, browser, isMobile } = agent;
});
*/

function getAccurateAgent(callback) {
  if (hasUserAgentData()) {
    return navigator.userAgentData.getHighEntropyValues(["architecture", "model", "platform", "platformVersion", "uaFullVersion"]).then(function (info) {
      var agentInfo = parseUserAgentData(info);
      callback && callback(agentInfo);
      return agentInfo;
    });
  }

  callback && callback(agent());

  if (typeof Promise === "undefined" || !Promise) {
    return null;
  }

  return Promise.resolve(agent());
}
/**
 * Extracts browser and operating system information from the user agent string.
 * @ko       .
 * @function eg.agent#agent
 * @param - user agent string to parse <ko>  </ko>
 * @return - agent Info <ko>   </ko>
 * @example
import agent from "@egjs/agent";
// eg.agent();
const { os, browser, isMobile } = agent();
 */

function agent(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return parseUserAgentData();
  } else {
    return parseUserAgent(userAgent);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (agent);

//# sourceMappingURL=agent.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "diff": () => (/* binding */ diff)
/* harmony export */ });
/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js");
/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/children-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-children-differ
version: 1.0.1
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var findKeyCallback = typeof Map === "function" ? undefined : function () {
  var childrenCount = 0;
  return function (el) {
    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);
  };
}();

/**
 * A module that checks diff when child are added, removed, or changed .
 * @ko           .
 * @memberof eg
 * @extends eg.ListDiffer
 */

var ChildrenDiffer =
/*#__PURE__*/
function (_super) {
  __extends(ChildrenDiffer, _super);
  /**
   * @param - Initializing Children <ko>    </ko>
   */


  function ChildrenDiffer(list) {
    if (list === void 0) {
      list = [];
    }

    return _super.call(this, list, findKeyCallback) || this;
  }

  return ChildrenDiffer;
}(_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__["default"]);

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
/**
 *
 * @memberof eg.ChildrenDiffer
 * @static
 * @function
 * @param - Previous List <ko>   </ko>
 * @param - List to Update <ko>    </ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>
 * @example
 * import { diff } from "@egjs/children-differ";
 * // script => eg.ChildrenDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list) {
  return (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(prevList, list, findKeyCallback);
}

/*
egjs-children-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChildrenDiffer);

//# sourceMappingURL=children-differ.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "diff": () => (/* binding */ diff)
/* harmony export */ });
/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/list-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-list-differ
version: 1.0.0
*/
/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var PolyMap =
/*#__PURE__*/
function () {
  function PolyMap() {
    this.keys = [];
    this.values = [];
  }

  var __proto = PolyMap.prototype;

  __proto.get = function (key) {
    return this.values[this.keys.indexOf(key)];
  };

  __proto.set = function (key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };

  return PolyMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var HashMap =
/*#__PURE__*/
function () {
  function HashMap() {
    this.object = {};
  }

  var __proto = HashMap.prototype;

  __proto.get = function (key) {
    return this.object[key];
  };

  __proto.set = function (key, value) {
    this.object[key] = value;
  };

  return HashMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var SUPPORT_MAP = typeof Map === "function";

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var Link =
/*#__PURE__*/
function () {
  function Link() {}

  var __proto = Link.prototype;

  __proto.connect = function (prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };

  __proto.disconnect = function () {
    // In double linked list, diconnect the interconnected relationship.
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };

  __proto.getIndex = function () {
    var link = this;
    var index = -1;

    while (link) {
      link = link.prev;
      ++index;
    }

    return index;
  };

  return Link;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

function orderChanged(changed, fixed) {
  // It is roughly in the order of these examples.
  // 4, 6, 0, 2, 1, 3, 5, 7
  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7

  var toLinks = [];
  changed.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  }); // `fromLinks` are connected to each other by double linked list.

  fromLinks.forEach(function (link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function (_, i) {
    return !fixed[i];
  }).map(function (_a, i) {
    var from = _a[0],
        to = _a[1];

    if (from === to) {
      return [0, 0];
    }

    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.

    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.

    if (!toLink) {
      fromLink.connect(undefined, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }

    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}

var Result =
/*#__PURE__*/
function () {
  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }

  var __proto = Result.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function () {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }

      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function () {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }

      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });

  __proto.caculateOrdered = function () {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function (_a, i) {
      var from = _a[0],
          to = _a[1];
      var _b = changed[i],
          fromBefore = _b[0],
          toBefore = _b[1];

      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };

  return Result;
}();

/**
 *
 * @memberof eg.ListDiffer
 * @static
 * @function
 * @param - Previous List <ko>   </ko>
 * @param - List to Update <ko>    </ko>
 * @param - This callback function returns the key of the item. <ko>     .</ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>
 * @example
 * import { diff } from "@egjs/list-differ";
 * // script => eg.ListDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;

  var callback = findKeyCallback || function (e) {
    return e;
  };

  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0; // Add prevKeys and keys to the hashmap.

  prevKeys.forEach(function (key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function (key, listIndex) {
    keyMap.set(key, listIndex);
  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.

  prevKeys.forEach(function (key, prevListIndex) {
    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.

    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.

  keys.forEach(function (key, listIndex) {
    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.

    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);

      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  }); // Sort by ascending order of 'to(list's index).

  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}

/**
 * A module that checks diff when values are added, removed, or changed in an array.
 * @ko          .
 * @memberof eg
 */

var ListDiffer =
/*#__PURE__*/
function () {
  /**
   * @param - Initializing Data Array. <ko>    .</ko>
   * @param - This callback function returns the key of the item. <ko>     .</ko>
   * @example
   * import ListDiffer from "@egjs/list-differ";
   * // script => eg.ListDiffer
   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);
   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);
   * // List before update
   * // [1, 2, 3, 4, 5]
   * console.log(result.prevList);
   * // Updated list
   * // [4, 3, 6, 2, 1]
   * console.log(result.list);
   * // Index array of values added to `list`.
   * // [0, 1, 5]
   * console.log(result.added);
   * // Index array of values removed in `prevList`.
   * // [5]
   * console.log(result.removed);
   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.changed);
   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
   * // [[4, 3], [3, 4], [2, 6]]
   * console.log(result.pureChanged);
   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
   * // [[4, 1], [4, 2], [4, 3]]
   * console.log(result.ordered);
   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.maintained);
   */
  function ListDiffer(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }

    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  /**
   * Update list.
   * @ko   .
   * @param - List to update <ko>   </ko>
   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList` `list`   . </ko>
   */


  var __proto = ListDiffer.prototype;

  __proto.update = function (list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };

  return ListDiffer;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListDiffer);

//# sourceMappingURL=list-differ.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: @scena/dragscroll
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/dragscroll.git
version: 1.1.1
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function getDefaultScrollPosition(e) {
  var container = e.container;

  if (container === document.body) {
    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];
  }

  return [container.scrollLeft, container.scrollTop];
}

var DragScroll =
/*#__PURE__*/
function (_super) {
  __extends(DragScroll, _super);

  function DragScroll() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._startRect = null;
    _this._startPos = [];
    _this._prevTime = 0;
    _this._timer = 0;
    _this._prevScrollPos = [0, 0];
    _this._isWait = false;
    return _this;
  }

  var __proto = DragScroll.prototype;

  __proto.dragStart = function (e, options) {
    var container = options.container;
    var top = 0;
    var left = 0;
    var width = 0;
    var height = 0;

    if (container === document.body) {
      width = window.innerWidth;
      height = window.innerHeight;
    } else {
      var rect = container.getBoundingClientRect();
      top = rect.top;
      left = rect.left;
      width = rect.width;
      height = rect.height;
    }

    this._startPos = [e.clientX, e.clientY];
    this._startRect = {
      top: top,
      left: left,
      width: width,
      height: height
    };
    this._prevScrollPos = this._getScrollPosition([0, 0], options);
  };

  __proto.drag = function (e, options) {
    var clientX = e.clientX,
        clientY = e.clientY;
    var _a = options.threshold,
        threshold = _a === void 0 ? 0 : _a;

    var _b = this,
        _startRect = _b._startRect,
        _startPos = _b._startPos;

    var direction = [0, 0];

    if (_startRect.top > clientY - threshold) {
      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {
        direction[1] = -1;
      }
    } else if (_startRect.top + _startRect.height < clientY + threshold) {
      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {
        direction[1] = 1;
      }
    }

    if (_startRect.left > clientX - threshold) {
      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {
        direction[0] = -1;
      }
    } else if (_startRect.left + _startRect.width < clientX + threshold) {
      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {
        direction[0] = 1;
      }
    }

    clearTimeout(this._timer);

    if (!direction[0] && !direction[1]) {
      return false;
    }

    return this._continueDrag(__assign(__assign({}, options), {
      direction: direction,
      inputEvent: e,
      isDrag: true
    }));
  };

  __proto.checkScroll = function (options) {
    var _this = this;

    if (this._isWait) {
      return false;
    }

    var _a = options.prevScrollPos,
        prevScrollPos = _a === void 0 ? this._prevScrollPos : _a,
        direction = options.direction,
        _b = options.throttleTime,
        throttleTime = _b === void 0 ? 0 : _b,
        inputEvent = options.inputEvent,
        isDrag = options.isDrag;

    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);

    var offsetX = nextScrollPos[0] - prevScrollPos[0];
    var offsetY = nextScrollPos[1] - prevScrollPos[1];
    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];
    this._prevScrollPos = nextScrollPos;

    if (!offsetX && !offsetY) {
      return false;
    }

    this.trigger("move", {
      offsetX: nextDirection[0] ? offsetX : 0,
      offsetY: nextDirection[1] ? offsetY : 0,
      inputEvent: inputEvent
    });

    if (throttleTime && isDrag) {
      this._timer = window.setTimeout(function () {
        _this._continueDrag(options);
      }, throttleTime);
    }

    return true;
  };

  __proto.dragEnd = function () {
    clearTimeout(this._timer);
  };

  __proto._getScrollPosition = function (direction, options) {
    var container = options.container,
        _a = options.getScrollPosition,
        getScrollPosition = _a === void 0 ? getDefaultScrollPosition : _a;
    return getScrollPosition({
      container: container,
      direction: direction
    });
  };

  __proto._continueDrag = function (options) {
    var _this = this;

    var container = options.container,
        direction = options.direction,
        throttleTime = options.throttleTime,
        useScroll = options.useScroll,
        isDrag = options.isDrag,
        inputEvent = options.inputEvent;

    if (isDrag && this._isWait) {
      return;
    }

    var nowTime = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)();
    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);

    if (distTime > 0) {
      this._timer = window.setTimeout(function () {
        _this._continueDrag(options);
      }, distTime);
      return false;
    }

    this._prevTime = nowTime;

    var prevScrollPos = this._getScrollPosition(direction, options);

    this._prevScrollPos = prevScrollPos;

    if (isDrag) {
      this._isWait = true;
    }

    this.trigger("scroll", {
      container: container,
      direction: direction,
      inputEvent: inputEvent
    });
    this._isWait = false;
    return useScroll || this.checkScroll(__assign(__assign({}, options), {
      prevScrollPos: prevScrollPos,
      direction: direction,
      inputEvent: inputEvent
    }));
  };

  return DragScroll;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragScroll);
//# sourceMappingURL=dragscroll.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.5
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventEmitter);
//# sourceMappingURL=event-emitter.esm.js.map


/***/ }),

/***/ "./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculate": () => (/* binding */ calculate),
/* harmony export */   "convertCSStoMatrix": () => (/* binding */ convertCSStoMatrix),
/* harmony export */   "convertDimension": () => (/* binding */ convertDimension),
/* harmony export */   "convertMatrixtoCSS": () => (/* binding */ convertMatrixtoCSS),
/* harmony export */   "convertPositionMatrix": () => (/* binding */ convertPositionMatrix),
/* harmony export */   "createIdentityMatrix": () => (/* binding */ createIdentityMatrix),
/* harmony export */   "createOriginMatrix": () => (/* binding */ createOriginMatrix),
/* harmony export */   "createRotateMatrix": () => (/* binding */ createRotateMatrix),
/* harmony export */   "createScaleMatrix": () => (/* binding */ createScaleMatrix),
/* harmony export */   "createWarpMatrix": () => (/* binding */ createWarpMatrix),
/* harmony export */   "fromTranslation": () => (/* binding */ fromTranslation),
/* harmony export */   "getCenter": () => (/* binding */ getCenter),
/* harmony export */   "getOrigin": () => (/* binding */ getOrigin),
/* harmony export */   "ignoreDimension": () => (/* binding */ ignoreDimension),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "matrix3d": () => (/* binding */ matrix3d),
/* harmony export */   "minus": () => (/* binding */ minus),
/* harmony export */   "multiplies": () => (/* binding */ multiplies),
/* harmony export */   "multiply": () => (/* binding */ multiply),
/* harmony export */   "plus": () => (/* binding */ plus),
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "rotateX3d": () => (/* binding */ rotateX3d),
/* harmony export */   "rotateY3d": () => (/* binding */ rotateY3d),
/* harmony export */   "rotateZ3d": () => (/* binding */ rotateZ3d),
/* harmony export */   "scale3d": () => (/* binding */ scale3d),
/* harmony export */   "translate3d": () => (/* binding */ translate3d),
/* harmony export */   "transpose": () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2020 Daybrush
name: @scena/matrix
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/matrix
version: 1.1.1
*/


function add(matrix, inverseMatrix, startIndex, fromIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    matrix[x] += matrix[fromX] * k;
    inverseMatrix[x] += inverseMatrix[fromX] * k;
  }
}

function swap(matrix, inverseMatrix, startIndex, fromIndex, n) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    var v = matrix[x];
    var iv = inverseMatrix[x];
    matrix[x] = matrix[fromX];
    matrix[fromX] = v;
    inverseMatrix[x] = inverseMatrix[fromX];
    inverseMatrix[fromX] = iv;
  }
}

function divide(matrix, inverseMatrix, startIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    matrix[x] /= k;
    inverseMatrix[x] /= k;
  }
}
/**
 *
 * @namespace Matrix
 */

/**
 * @memberof Matrix
 */


function ignoreDimension(matrix, m, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = matrix.slice();

  for (var i = 0; i < n; ++i) {
    newMatrix[i * n + m - 1] = 0;
    newMatrix[(m - 1) * n + i] = 0;
  }

  newMatrix[(m - 1) * (n + 1)] = 1;
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function invert(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = matrix.slice();
  var inverseMatrix = createIdentityMatrix(n);

  for (var i = 0; i < n; ++i) {
    // diagonal
    var identityIndex = n * i + i;

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(newMatrix[identityIndex], _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM)) {
      // newMatrix[identityIndex] = 0;
      for (var j = i + 1; j < n; ++j) {
        if (newMatrix[n * i + j]) {
          swap(newMatrix, inverseMatrix, i, j, n);
          break;
        }
      }
    }

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(newMatrix[identityIndex], _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM)) {
      // no inverse matrix
      return [];
    }

    divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);

    for (var j = 0; j < n; ++j) {
      var targetStartIndex = j;
      var targetIndex = j + i * n;
      var target = newMatrix[targetIndex];

      if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.throttle)(target, _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.TINY_NUM) || i === j) {
        continue;
      }

      add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);
    }
  }

  return inverseMatrix;
}
/**
 * @memberof Matrix
 */

function transpose(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = [];

  for (var i = 0; i < n; ++i) {
    for (var j = 0; j < n; ++j) {
      newMatrix[j * n + i] = matrix[n * i + j];
    }
  }

  return newMatrix;
}
/**
 * @memberof Matrix
 */

function getOrigin(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var originMatrix = [];
  var w = matrix[n * n - 1];

  for (var i = 0; i < n - 1; ++i) {
    originMatrix[i] = matrix[n * (n - 1) + i] / w;
  }

  originMatrix[n - 1] = 0;
  return originMatrix;
}
/**
 * @memberof Matrix
 */

function fromTranslation(pos, n) {
  var newMatrix = createIdentityMatrix(n);

  for (var i = 0; i < n - 1; ++i) {
    newMatrix[n * (n - 1) + i] = pos[i] || 0;
  }

  return newMatrix;
}
/**
 * @memberof Matrix
 */

function convertPositionMatrix(matrix, n) {
  var newMatrix = matrix.slice();

  for (var i = matrix.length; i < n - 1; ++i) {
    newMatrix[i] = 0;
  }

  newMatrix[n - 1] = 1;
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function convertDimension(matrix, n, m) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  } // n < m


  if (n === m) {
    return matrix;
  }

  var newMatrix = createIdentityMatrix(m);
  var length = Math.min(n, m);

  for (var i = 0; i < length - 1; ++i) {
    for (var j = 0; j < length - 1; ++j) {
      newMatrix[i * m + j] = matrix[i * n + j];
    }

    newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];
    newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];
  }

  newMatrix[m * m - 1] = matrix[n * n - 1];
  return newMatrix;
}
/**
 * @memberof Matrix
 */

function multiplies(n) {
  var matrixes = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    matrixes[_i - 1] = arguments[_i];
  }

  var m = createIdentityMatrix(n);
  matrixes.forEach(function (matrix) {
    m = multiply(m, matrix, n);
  });
  return m;
}
/**
 * @memberof Matrix
 */

function multiply(matrix, matrix2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }

  var newMatrix = []; // 1 y: n
  // 1 x: m
  // 2 x: m
  // 2 y: k
  // n * m X m * k

  var m = matrix.length / n;
  var k = matrix2.length / m;

  if (!m) {
    return matrix2;
  } else if (!k) {
    return matrix;
  }

  for (var i = 0; i < n; ++i) {
    for (var j = 0; j < k; ++j) {
      newMatrix[j * n + i] = 0;

      for (var l = 0; l < m; ++l) {
        // m1 x: m(l), y: n(i)
        // m2 x: k(j):  y: m(l)
        // nw x: n(i), y: k(j)
        newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];
      }
    }
  } // n * k


  return newMatrix;
}
/**
 * @memberof Matrix
 */

function plus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();

  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] + pos2[i];
  }

  return nextPos;
}
/**
 * @memberof Matrix
 */

function minus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();

  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] - pos2[i];
  }

  return nextPos;
}
/**
 * @memberof Matrix
 */

function convertCSStoMatrix(a, is2d) {
  if (is2d === void 0) {
    is2d = a.length === 6;
  }

  if (is2d) {
    return [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1];
  }

  return a;
}
/**
 * @memberof Matrix
 */

function convertMatrixtoCSS(a, is2d) {
  if (is2d === void 0) {
    is2d = a.length === 9;
  }

  if (is2d) {
    return [a[0], a[1], a[3], a[4], a[6], a[7]];
  }

  return a;
}
/**
 * @memberof Matrix
 */

function calculate(matrix, matrix2, n) {
  if (n === void 0) {
    n = matrix2.length;
  }

  var result = multiply(matrix, matrix2, n);
  var k = result[n - 1];
  return result.map(function (v) {
    return v / k;
  });
}
/**
 * @memberof Matrix
 */

function rotateX3d(matrix, rad) {
  return multiply(matrix, [1, 0, 0, 0, 0, Math.cos(rad), Math.sin(rad), 0, 0, -Math.sin(rad), Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotateY3d(matrix, rad) {
  return multiply(matrix, [Math.cos(rad), 0, -Math.sin(rad), 0, 0, 1, 0, 0, Math.sin(rad), 0, Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotateZ3d(matrix, rad) {
  return multiply(matrix, createRotateMatrix(rad, 4));
}
/**
 * @memberof Matrix
 */

function scale3d(matrix, _a) {
  var _b = _a[0],
      sx = _b === void 0 ? 1 : _b,
      _c = _a[1],
      sy = _c === void 0 ? 1 : _c,
      _d = _a[2],
      sz = _d === void 0 ? 1 : _d;
  return multiply(matrix, [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1], 4);
}
/**
 * @memberof Matrix
 */

function rotate(pos, rad) {
  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));
}
/**
 * @memberof Matrix
 */

function translate3d(matrix, _a) {
  var _b = _a[0],
      tx = _b === void 0 ? 0 : _b,
      _c = _a[1],
      ty = _c === void 0 ? 0 : _c,
      _d = _a[2],
      tz = _d === void 0 ? 0 : _d;
  return multiply(matrix, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1], 4);
}
/**
 * @memberof Matrix
 */

function matrix3d(matrix1, matrix2) {
  return multiply(matrix1, matrix2, 4);
}
/**
 * @memberof Matrix
 */

function createRotateMatrix(rad, n) {
  var cos = Math.cos(rad);
  var sin = Math.sin(rad);
  var m = createIdentityMatrix(n); // cos -sin
  // sin cos

  m[0] = cos;
  m[1] = sin;
  m[n] = -sin;
  m[n + 1] = cos;
  return m;
}
/**
 * @memberof Matrix
 */

function createIdentityMatrix(n) {
  var length = n * n;
  var matrix = [];

  for (var i = 0; i < length; ++i) {
    matrix[i] = i % (n + 1) ? 0 : 1;
  }

  return matrix;
}
/**
 * @memberof Matrix
 */

function createScaleMatrix(scale, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(scale.length, n - 1);

  for (var i = 0; i < length; ++i) {
    m[(n + 1) * i] = scale[i];
  }

  return m;
}
/**
 * @memberof Matrix
 */

function createOriginMatrix(origin, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(origin.length, n - 1);

  for (var i = 0; i < length; ++i) {
    m[n * (n - 1) + i] = origin[i];
  }

  return m;
}
/**
 * @memberof Matrix
 */

function createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {
  var x0 = pos0[0],
      y0 = pos0[1];
  var x1 = pos1[0],
      y1 = pos1[1];
  var x2 = pos2[0],
      y2 = pos2[1];
  var x3 = pos3[0],
      y3 = pos3[1];
  var u0 = nextPos0[0],
      v0 = nextPos0[1];
  var u1 = nextPos1[0],
      v1 = nextPos1[1];
  var u2 = nextPos2[0],
      v2 = nextPos2[1];
  var u3 = nextPos3[0],
      v3 = nextPos3[1];
  var matrix = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];
  var inverseMatrix = invert(matrix, 8);

  if (!inverseMatrix.length) {
    return [];
  }

  var h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);
  h[8] = 1;
  return convertDimension(transpose(h), 3, 4);
}
/**
 * @memberof Matrix
 */

function getCenter(points) {
  return [0, 1].map(function (i) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.average)(points.map(function (pos) {
      return pos[i];
    }));
  });
}


//# sourceMappingURL=matrix.esm.js.map


/***/ }),

/***/ "./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calculateMatrixDist": () => (/* binding */ calculateMatrixDist),
/* harmony export */   "createMatrix": () => (/* binding */ createMatrix),
/* harmony export */   "getDistElementMatrix": () => (/* binding */ getDistElementMatrix),
/* harmony export */   "getElementMatrix": () => (/* binding */ getElementMatrix),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parseMat": () => (/* binding */ parseMat),
/* harmony export */   "toMat": () => (/* binding */ toMat)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _scena_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@scena-matrix-npm-1.1.1-da964f6b3a-e96aeab712.zip/node_modules/@scena/matrix/dist/matrix.esm.js");
/*
Copyright (c) 2019 Daybrush
name: css-to-mat
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-to-mat.git
version: 1.0.3
*/



function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(transform) {
  return toMat(parse(transform));
}
function getElementMatrix(el) {
  return parseMat(getComputedStyle(el).transform);
}
function calculateMatrixDist(matrix, pos) {
  var res = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.calculate)(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);
  var w = res[3] || 1;
  return [res[0] / w, res[1] / w, res[2] / w];
}
function getDistElementMatrix(el, container) {
  if (container === void 0) {
    container = document.body;
  }

  var target = el;
  var matrix = createMatrix();

  while (target) {
    var transform = getComputedStyle(target).transform;
    matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d)(parseMat(transform), matrix);

    if (target === container) {
      break;
    }

    target = target.parentElement;
  }

  matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_0__.invert)(matrix, 4);
  matrix[12] = 0;
  matrix[13] = 0;
  matrix[14] = 0;
  return matrix;
}
function toMat(matrixInfos) {
  var target = createMatrix();
  matrixInfos.forEach(function (info) {
    var matrixFunction = info.matrixFunction,
        functionValue = info.functionValue;

    if (!matrixFunction) {
      return;
    }

    target = matrixFunction(target, functionValue);
  });
  return target;
}
function parse(transform) {
  var transforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitSpace)(transform);
  return transforms.map(function (t) {
    var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitBracket)(t),
        name = _a.prefix,
        value = _a.value;

    var matrixFunction = null;
    var functionName = name;
    var functionValue = "";

    if (name === "translate" || name === "translateX" || name === "translate3d") {
      var _b = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      }),
          posX = _b[0],
          _c = _b[1],
          posY = _c === void 0 ? 0 : _c,
          _d = _b[2],
          posZ = _d === void 0 ? 0 : _d;

      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [posX, posY, posZ];
    } else if (name === "translateY") {
      var posY = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [0, posY, 0];
    } else if (name === "translateZ") {
      var posZ = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.translate3d;
      functionValue = [0, 0, posZ];
    } else if (name === "scale" || name === "scale3d") {
      var _e = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      }),
          sx = _e[0],
          _f = _e[1],
          sy = _f === void 0 ? sx : _f,
          _g = _e[2],
          sz = _g === void 0 ? 1 : _g;

      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [sx, sy, sz];
    } else if (name === "scaleX") {
      var sx = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [sx, 1, 1];
    } else if (name === "scaleY") {
      var sy = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [1, sy, 1];
    } else if (name === "scaleZ") {
      var sz = parseFloat(value);
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.scale3d;
      functionValue = [1, 1, sz];
    } else if (name === "rotate" || name === "rotateZ" || name === "rotateX" || name === "rotateY") {
      var _h = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitUnit)(value),
          unit = _h.unit,
          unitValue = _h.value;

      var rad = unit === "rad" ? unitValue : unitValue * Math.PI / 180;

      if (name === "rotate" || name === "rotateZ") {
        functionName = "rotateZ";
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateZ3d;
      } else if (name === "rotateX") {
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateX3d;
      } else if (name === "rotateY") {
        matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.rotateY3d;
      }

      functionValue = rad;
    } else if (name === "matrix3d") {
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d;
      functionValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      });
    } else if (name === "matrix") {
      var m = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.splitComma)(value).map(function (v) {
        return parseFloat(v);
      });
      matrixFunction = _scena_matrix__WEBPACK_IMPORTED_MODULE_0__.matrix3d;
      functionValue = [m[0], m[1], 0, 0, m[2], m[3], 0, 0, 0, 0, 1, 0, m[4], m[5], 0, 1];
    } else {
      functionName = "";
    }

    return {
      name: name,
      functionName: functionName,
      value: value,
      matrixFunction: matrixFunction,
      functionValue: functionValue
    };
  });
}


//# sourceMappingURL=css-to-mat.esm.js.map


/***/ }),

/***/ "./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Properties": () => (/* binding */ Properties),
/* harmony export */   "prefixCSS": () => (/* binding */ prefixCSS),
/* harmony export */   "prefixNames": () => (/* binding */ prefixNames),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "refs": () => (/* binding */ refs),
/* harmony export */   "withMethods": () => (/* binding */ withMethods)
/* harmony export */ });
/*
Copyright (c) 2019 Daybrush
name: framework-utils
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/framework-utils.git
version: 1.1.0
*/
function prefixNames(prefix) {
  var classNames = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    classNames[_i - 1] = arguments[_i];
  }

  return classNames.map(function (className) {
    return className.split(" ").map(function (name) {
      return name ? "" + prefix + name : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(prefix, css) {
  return css.replace(/([^}{]*){/gm, function (_, selector) {
    return selector.replace(/\.([^{,\s\d.]+)/g, "." + prefix + "$1") + "{";
  });
}
/* react */

function ref(target, name) {
  return function (e) {
    e && (target[name] = e);
  };
}
function refs(target, name, i) {
  return function (e) {
    e && (target[name][i] = e);
  };
}
/* Class Decorator */

function Properties(properties, action) {
  return function (component) {
    var prototype = component.prototype;
    properties.forEach(function (property) {
      action(prototype, property);
    });
  };
}
/* Property Decorator */

function withMethods(methods, duplicate) {
  if (duplicate === void 0) {
    duplicate = {};
  }

  return function (prototype, propertyName) {
    methods.forEach(function (name) {
      var methodName = duplicate[name] || name;

      if (methodName in prototype) {
        return;
      }

      prototype[methodName] = function () {
        var _a;

        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        var result = (_a = this[propertyName])[name].apply(_a, args);

        if (result === this[propertyName]) {
          return this;
        } else {
          return result;
        }
      };
    });
  };
}


//# sourceMappingURL=utils.esm.js.map


/***/ }),

/***/ "./.yarn/cache/gesto-npm-1.7.0-7d5440000b-f2a66bcf0f.zip/node_modules/gesto/dist/gesto.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: gesto
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesto.git
version: 1.7.0
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getRotatiion(touches) {
  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;
}
function isMultiTouch(e) {
  return e.touches && e.touches.length >= 2;
}
function getEventClients(e) {
  if (e.touches) {
    return getClients(e.touches);
  } else {
    return [getClient(e)];
  }
}
function getPosition(clients, prevClients, startClients) {
  var length = startClients.length;

  var _a = getAverageClient(clients, length),
      clientX = _a.clientX,
      clientY = _a.clientY,
      originalClientX = _a.originalClientX,
      originalClientY = _a.originalClientY;

  var _b = getAverageClient(prevClients, length),
      prevX = _b.clientX,
      prevY = _b.clientY;

  var _c = getAverageClient(startClients, length),
      startX = _c.clientX,
      startY = _c.clientY;

  var deltaX = clientX - prevX;
  var deltaY = clientY - prevY;
  var distX = clientX - startX;
  var distY = clientY - startY;
  return {
    clientX: originalClientX,
    clientY: originalClientY,
    deltaX: deltaX,
    deltaY: deltaY,
    distX: distX,
    distY: distY
  };
}
function getDist(clients) {
  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));
}
function getClients(touches) {
  var length = Math.min(touches.length, 2);
  var clients = [];

  for (var i = 0; i < length; ++i) {
    clients.push(getClient(touches[i]));
  }

  return clients;
}
function getClient(e) {
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function getAverageClient(clients, length) {
  if (length === void 0) {
    length = clients.length;
  }

  var sumClient = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  };

  for (var i = 0; i < length; ++i) {
    var client = clients[i];
    sumClient.originalClientX += "originalClientX" in client ? client.originalClientX : client.clientX;
    sumClient.originalClientY += "originalClientY" in client ? client.originalClientY : client.clientY;
    sumClient.clientX += client.clientX;
    sumClient.clientY += client.clientY;
  }

  if (!length) {
    return sumClient;
  }

  return {
    clientX: sumClient.clientX / length,
    clientY: sumClient.clientY / length,
    originalClientX: sumClient.originalClientX / length,
    originalClientY: sumClient.originalClientY / length
  };
}

var ClientStore =
/*#__PURE__*/
function () {
  function ClientStore(clients) {
    this.prevClients = [];
    this.startClients = [];
    this.movement = 0;
    this.length = 0;
    this.startClients = clients;
    this.prevClients = clients;
    this.length = clients.length;
  }

  var __proto = ClientStore.prototype;

  __proto.getAngle = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients);
  };

  __proto.getRotation = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getRotatiion(clients) - getRotatiion(this.startClients);
  };

  __proto.getPosition = function (clients, isAdd) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);
    var deltaX = position.deltaX,
        deltaY = position.deltaY;
    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    this.prevClients = clients;
    return position;
  };

  __proto.getPositions = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    var prevClients = this.prevClients;
    return this.startClients.map(function (startClient, i) {
      return getPosition([clients[i]], [prevClients[i]], [startClient]);
    });
  };

  __proto.getMovement = function (clients) {
    var movement = this.movement;

    if (!clients) {
      return movement;
    }

    var currentClient = getAverageClient(clients, this.length);
    var prevClient = getAverageClient(this.prevClients, this.length);
    var deltaX = currentClient.clientX - prevClient.clientX;
    var deltaY = currentClient.clientY - prevClient.clientY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;
  };

  __proto.getDistance = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist(clients);
  };

  __proto.getScale = function (clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }

    return getDist(clients) / getDist(this.startClients);
  };

  __proto.move = function (deltaX, deltaY) {
    this.startClients.forEach(function (client) {
      client.clientX -= deltaX;
      client.clientY -= deltaY;
    });
  };

  return ClientStore;
}();

var INPUT_TAGNAMES = ["textarea", "input"];
/**
 * You can set up drag, pinch events in any browser.
 */

var Gesto =
/*#__PURE__*/
function (_super) {
  __extends(Gesto, _super);
  /**
   *
   */


  function Gesto(targets, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.options = {};
    _this.flag = false;
    _this.pinchFlag = false;
    _this.datas = {};
    _this.isDrag = false;
    _this.isPinch = false;
    _this.isMouse = false;
    _this.isTouch = false;
    _this.clientStores = [];
    _this.targets = [];
    _this.prevTime = 0;
    _this.doubleFlag = false;
    _this._dragFlag = false;

    _this.onDragStart = function (e, isTrusted) {
      if (isTrusted === void 0) {
        isTrusted = true;
      }

      if (!_this.flag && e.cancelable === false) {
        return;
      }

      var _a = _this.options,
          container = _a.container,
          pinchOutside = _a.pinchOutside,
          preventRightClick = _a.preventRightClick,
          preventDefault = _a.preventDefault,
          checkInput = _a.checkInput;
      var isTouch = _this.isTouch;
      var isDragStart = !_this.flag;

      if (isDragStart) {
        var activeElement = document.activeElement;
        var target = e.target;
        var tagName = target.tagName.toLowerCase();
        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;
        var hasContentEditable = target.isContentEditable;

        if (hasInput || hasContentEditable) {
          if (checkInput || activeElement === target) {
            // force false or already focused.
            return false;
          } // no focus


          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {
            return false;
          }
        } else if ((preventDefault || e.type === "touchstart") && activeElement) {
          var activeTagName = activeElement.tagName;

          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {
            activeElement.blur();
          }
        }

        _this.clientStores = [new ClientStore(getEventClients(e))];
        _this.flag = true;
        _this.isDrag = false;
        _this._dragFlag = true;
        _this.datas = {};

        if (preventRightClick && (e.which === 3 || e.button === 2)) {
          _this.initDrag();

          return false;
        }

        _this.doubleFlag = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)() - _this.prevTime < 200;

        var result = _this.emit("dragStart", __assign({
          datas: _this.datas,
          inputEvent: e,
          isTrusted: isTrusted,
          isDouble: _this.doubleFlag
        }, _this.getCurrentStore().getPosition(), {
          preventDefault: function () {
            e.preventDefault();
          },
          preventDrag: function () {
            _this._dragFlag = false;
          }
        }));

        if (result === false) {
          _this.initDrag();
        }

        _this.flag && preventDefault && e.preventDefault();
      }

      if (!_this.flag) {
        return false;
      }

      var timer = 0;

      if (isDragStart && isTouch && pinchOutside) {
        timer = setTimeout(function () {
          (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchstart", _this.onDragStart, {
            passive: false
          });
        });
      }

      if (!isDragStart && isTouch && pinchOutside) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", _this.onDragStart);
      }

      if (_this.flag && isMultiTouch(e)) {
        clearTimeout(timer);

        if (isDragStart && e.touches.length !== e.changedTouches.length) {
          return;
        }

        if (!_this.pinchFlag) {
          _this.onPinchStart(e);
        }
      }
    };

    _this.onDrag = function (e, isScroll) {
      if (!_this.flag) {
        return;
      }

      var clients = getEventClients(e);

      var result = _this.moveClients(clients, e, false);

      if (_this._dragFlag) {
        if (_this.pinchFlag || result.deltaX || result.deltaY) {
          var dragResult = _this.emit("drag", __assign({}, result, {
            isScroll: !!isScroll,
            inputEvent: e
          }));

          if (dragResult === false) {
            _this.stop();

            return;
          }
        }

        if (_this.pinchFlag) {
          _this.onPinch(e, clients);
        }
      }

      _this.getCurrentStore().getPosition(clients, true);
    };

    _this.onDragEnd = function (e) {
      if (!_this.flag) {
        return;
      }

      var _a = _this.options,
          pinchOutside = _a.pinchOutside,
          container = _a.container;

      if (_this.isTouch && pinchOutside) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", _this.onDragStart);
      }

      _this.flag = false;

      var position = _this._getPosition();

      var currentTime = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.now)();
      var isDouble = !_this.isDrag && _this.doubleFlag;
      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;

      _this.emit("dragEnd", __assign({
        datas: _this.datas,
        isDouble: isDouble,
        isDrag: _this.isDrag,
        isClick: !_this.isDrag,
        inputEvent: e
      }, position));

      if (_this.pinchFlag) {
        _this.onPinchEnd(e);
      }

      _this.clientStores = [];
    };

    _this.onBlur = function () {
      _this.onDragEnd();
    };

    var elements = [].concat(targets);
    _this.options = __assign({
      checkInput: false,
      container: elements.length > 1 ? window : elements[0],
      preventRightClick: true,
      preventDefault: true,
      checkWindowBlur: false,
      pinchThreshold: 0,
      events: ["touch", "mouse"]
    }, options);
    var _a = _this.options,
        container = _a.container,
        events = _a.events,
        checkWindowBlur = _a.checkWindowBlur;
    _this.isTouch = events.indexOf("touch") > -1;
    _this.isMouse = events.indexOf("mouse") > -1;
    _this.targets = elements;

    if (_this.isMouse) {
      elements.forEach(function (el) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(el, "mousedown", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "mousemove", _this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "mouseup", _this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "contextmenu", _this.onDragEnd);
    }

    if (checkWindowBlur) {
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(window, "blur", _this.onBlur);
    }

    if (_this.isTouch) {
      var passive_1 = {
        passive: false
      };
      elements.forEach(function (el) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(el, "touchstart", _this.onDragStart, passive_1);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchmove", _this.onDrag, passive_1);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchend", _this.onDragEnd, passive_1);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(container, "touchcancel", _this.onDragEnd, passive_1);
    }

    return _this;
  }
  /**
   * Stop Gesto's drag events.
   */


  var __proto = Gesto.prototype;

  __proto.stop = function () {
    this.isDrag = false;
    this.flag = false;
    this.clientStores = [];
    this.datas = {};
  };
  /**
   * The total moved distance
   */


  __proto.getMovement = function (clients) {
    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function (prev, cur) {
      return prev + cur.movement;
    }, 0);
  };
  /**
   * Whether to drag
   */


  __proto.isDragging = function () {
    return this.isDrag;
  };
  /**
   * Whether to start drag
   */


  __proto.isFlag = function () {
    return this.flag;
  };
  /**
   * Whether to start pinch
   */


  __proto.isPinchFlag = function () {
    return this.pinchFlag;
  };
  /**
  * Whether to start double click
  */


  __proto.isDoubleFlag = function () {
    return this.doubleFlag;
  };
  /**
   * Whether to pinch
   */


  __proto.isPinching = function () {
    return this.isPinch;
  };
  /**
   * If a scroll event occurs, it is corrected by the scroll distance.
   */


  __proto.scrollBy = function (deltaX, deltaY, e, isCallDrag) {
    if (isCallDrag === void 0) {
      isCallDrag = true;
    }

    if (!this.flag) {
      return;
    }

    this.clientStores[0].move(deltaX, deltaY);
    isCallDrag && this.onDrag(e, true);
  };
  /**
   * Create a virtual drag event.
   */


  __proto.move = function (_a, inputEvent) {
    var deltaX = _a[0],
        deltaY = _a[1];
    var store = this.getCurrentStore();
    var nextClients = store.prevClients;
    return this.moveClients(nextClients.map(function (_a) {
      var clientX = _a.clientX,
          clientY = _a.clientY;
      return {
        clientX: clientX + deltaX,
        clientY: clientY + deltaY,
        originalClientX: clientX,
        originalClientY: clientY
      };
    }), inputEvent, true);
  };
  /**
   * The dragStart event is triggered by an external event.
   */


  __proto.triggerDragStart = function (e) {
    this.onDragStart(e, false);
  };
  /**
   * Set the event data while dragging.
   */


  __proto.setEventDatas = function (datas) {
    var currentDatas = this.datas;

    for (var name in datas) {
      currentDatas[name] = datas[name];
    }

    return this;
  };
  /**
   * Get the current event state while dragging.
   */


  __proto.getCurrentEvent = function (inputEvent) {
    return __assign({
      datas: this.datas
    }, this._getPosition(), {
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };
  /**
   * Get & Set the event data while dragging.
   */


  __proto.getEventDatas = function () {
    return this.datas;
  };
  /**
   * Unset Gesto
   */


  __proto.unset = function () {
    var _this = this;

    var targets = this.targets;
    var container = this.options.container;
    this.off();
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(window, "blur", this.onBlur);

    if (this.isMouse) {
      targets.forEach(function (target) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(target, "mousedown", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "mousemove", this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "mouseup", this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "contextmenu", this.onDragEnd);
    }

    if (this.isTouch) {
      targets.forEach(function (target) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(target, "touchstart", _this.onDragStart);
      });
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchstart", this.onDragStart);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchmove", this.onDrag);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchend", this.onDragEnd);
      (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(container, "touchcancel", this.onDragEnd);
    }
  };

  __proto.onPinchStart = function (e) {
    var pinchThreshold = this.options.pinchThreshold;

    if (this.isDrag && this.getMovement() > pinchThreshold) {
      return;
    }

    var store = new ClientStore(getEventClients(e));
    this.pinchFlag = true;
    this.clientStores.splice(0, 0, store);
    var result = this.emit("pinchStart", __assign({
      datas: this.datas,
      angle: store.getAngle(),
      touches: this.getCurrentStore().getPositions()
    }, store.getPosition(), {
      inputEvent: e
    }));

    if (result === false) {
      this.pinchFlag = false;
    }
  };

  __proto.onPinch = function (e, clients) {
    if (!this.flag || !this.pinchFlag || clients.length < 2) {
      return;
    }

    var store = this.getCurrentStore();
    this.isPinch = true;
    this.emit("pinch", __assign({
      datas: this.datas,
      movement: this.getMovement(clients),
      angle: store.getAngle(clients),
      rotation: store.getRotation(clients),
      touches: store.getPositions(clients),
      scale: store.getScale(clients),
      distance: store.getDistance(clients)
    }, store.getPosition(clients), {
      inputEvent: e
    }));
  };

  __proto.onPinchEnd = function (e) {
    if (!this.pinchFlag) {
      return;
    }

    var isPinch = this.isPinch;
    this.isPinch = false;
    this.pinchFlag = false;
    var store = this.getCurrentStore();
    this.emit("pinchEnd", __assign({
      datas: this.datas,
      isPinch: isPinch,
      touches: store.getPositions()
    }, store.getPosition(), {
      inputEvent: e
    }));
    this.isPinch = false;
    this.pinchFlag = false;
  };

  __proto.initDrag = function () {
    this.clientStores = [];
    this.pinchFlag = false;
    this.doubleFlag = false;
    this.prevTime = 0;
    this.flag = false;
  };

  __proto.getCurrentStore = function () {
    return this.clientStores[0];
  };

  __proto.moveClients = function (clients, inputEvent, isAdd) {
    var position = this._getPosition(clients, isAdd);

    if (position.deltaX || position.deltaY) {
      this.isDrag = true;
    }

    return __assign({
      datas: this.datas
    }, position, {
      movement: this.getMovement(clients),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent: inputEvent
    });
  };

  __proto._getPosition = function (clients, isAdd) {
    var store = this.getCurrentStore();
    var position = store.getPosition(clients, isAdd);

    var _a = this.clientStores.slice(1).reduce(function (prev, cur) {
      var storePosition = cur.getPosition();
      prev.distX += storePosition.distX;
      prev.distY += storePosition.distY;
      return prev;
    }, position),
        distX = _a.distX,
        distY = _a.distY;

    return __assign({}, position, {
      distX: distX,
      distY: distY
    });
  };

  return Gesto;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Gesto);
//# sourceMappingURL=gesto.esm.js.map


/***/ }),

/***/ "./.yarn/cache/keycon-npm-1.1.2-47bb5048df-7be74aaf83.zip/node_modules/keycon/dist/keycon.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getCombi": () => (/* binding */ getCombi),
/* harmony export */   "getKey": () => (/* binding */ getKey),
/* harmony export */   "getModifierCombi": () => (/* binding */ getModifierCombi)
/* harmony export */ });
/*
Copyright (c) Daybrush
name: keycon
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/keycon.git
version: 1.1.2
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/*
Copyright (c) 2018 Daybrush
@name: @daybrush/utils
license: MIT
author: Daybrush
repository: https://github.com/daybrush/utils
@version 1.0.0
*/
/**
* get string "object"
* @memberof Consts
* @example
import {OBJECT} from "@daybrush/utils";

console.log(OBJECT); // "object"
*/

var OBJECT = "object";
/**
* get string "string"
* @memberof Consts
* @example
import {STRING} from "@daybrush/utils";

console.log(STRING); // "string"
*/

var STRING = "string";
/**
* Check the type that the value is object.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isObject} from "@daybrush/utils";

console.log(isObject({})); // true
console.log(isObject(undefined)); // false
console.log(isObject("")); // false
console.log(isObject(null)); // false
*/

function isObject(value) {
  return value && typeof value === OBJECT;
}
/**
* Check the type that the value is isArray.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isArray} from "@daybrush/utils";

console.log(isArray([])); // true
console.log(isArray({})); // false
console.log(isArray(undefined)); // false
console.log(isArray(null)); // false
*/

function isArray(value) {
  return Array.isArray(value);
}
/**
* Check the type that the value is string.
* @memberof Utils
* @param {string} value - Value to check the type
* @return {} true if the type is correct, false otherwise
* @example
import {isString} from "@daybrush/utils";

console.log(isString("1234")); // true
console.log(isString(undefined)); // false
console.log(isString(1)); // false
console.log(isString(null)); // false
*/

function isString(value) {
  return typeof value === STRING;
}
/**
* Returns the index of the first element in the array that satisfies the provided testing function.
* @function
* @memberof CrossBrowser
* @param - The array `findIndex` was called upon.
* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.
* @param - Returns defaultIndex if not found by the function.
* @example
import { findIndex } from "@daybrush/utils";

findIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1
*/

function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }

  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i, arr)) {
      return i;
    }
  }

  return defaultIndex;
}
/**
* Sets up a function that will be called whenever the specified event is delivered to the target
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs
* @param - An options object that specifies characteristics about the event listener. The available options are:
* @example
import {addEvent} from "@daybrush/utils";

addEvent(el, "click", e => {
  console.log(e);
});
*/

function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
/**
* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()
* @memberof DOM
* @param - event target
* @param - A case-sensitive string representing the event type to listen for.
* @param - The EventListener function of the event handler to remove from the event target.
* @example
import {addEvent, removeEvent} from "@daybrush/utils";
const listener = e => {
  console.log(e);
};
addEvent(el, "click", listener);
removeEvent(el, "click", listener);
*/

function removeEvent(el, type, listener) {
  el.removeEventListener(type, listener);
}

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.2
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if (isObject(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = findIndex(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var keycode = createCommonjsModule(function (module, exports) {
// Source: http://jsfiddle.net/vWx8V/
// http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes

/**
 * Conenience method returns corresponding value for given keyName or keyCode.
 *
 * @param {Mixed} keyCode {Number} or keyName {String}
 * @return {Mixed}
 * @api public
 */

function keyCode(searchInput) {
  // Keyboard Events
  if (searchInput && 'object' === typeof searchInput) {
    var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
    if (hasKeyCode) searchInput = hasKeyCode;
  }

  // Numbers
  if ('number' === typeof searchInput) return names[searchInput]

  // Everything else (cast to string)
  var search = String(searchInput);

  // check codes
  var foundNamedKey = codes[search.toLowerCase()];
  if (foundNamedKey) return foundNamedKey

  // check aliases
  var foundNamedKey = aliases[search.toLowerCase()];
  if (foundNamedKey) return foundNamedKey

  // weird character?
  if (search.length === 1) return search.charCodeAt(0)

  return undefined
}

/**
 * Compares a keyboard event with a given keyCode or keyName.
 *
 * @param {Event} event Keyboard event that should be tested
 * @param {Mixed} keyCode {Number} or keyName {String}
 * @return {Boolean}
 * @api public
 */
keyCode.isEventKey = function isEventKey(event, nameOrCode) {
  if (event && 'object' === typeof event) {
    var keyCode = event.which || event.keyCode || event.charCode;
    if (keyCode === null || keyCode === undefined) { return false; }
    if (typeof nameOrCode === 'string') {
      // check codes
      var foundNamedKey = codes[nameOrCode.toLowerCase()];
      if (foundNamedKey) { return foundNamedKey === keyCode; }
    
      // check aliases
      var foundNamedKey = aliases[nameOrCode.toLowerCase()];
      if (foundNamedKey) { return foundNamedKey === keyCode; }
    } else if (typeof nameOrCode === 'number') {
      return nameOrCode === keyCode;
    }
    return false;
  }
};

exports = module.exports = keyCode;

/**
 * Get by name
 *
 *   exports.code['enter'] // => 13
 */

var codes = exports.code = exports.codes = {
  'backspace': 8,
  'tab': 9,
  'enter': 13,
  'shift': 16,
  'ctrl': 17,
  'alt': 18,
  'pause/break': 19,
  'caps lock': 20,
  'esc': 27,
  'space': 32,
  'page up': 33,
  'page down': 34,
  'end': 35,
  'home': 36,
  'left': 37,
  'up': 38,
  'right': 39,
  'down': 40,
  'insert': 45,
  'delete': 46,
  'command': 91,
  'left command': 91,
  'right command': 93,
  'numpad *': 106,
  'numpad +': 107,
  'numpad -': 109,
  'numpad .': 110,
  'numpad /': 111,
  'num lock': 144,
  'scroll lock': 145,
  'my computer': 182,
  'my calculator': 183,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  "'": 222
};

// Helper aliases

var aliases = exports.aliases = {
  'windows': 91,
  '': 16,
  '': 18,
  '': 17,
  '': 91,
  'ctl': 17,
  'control': 17,
  'option': 18,
  'pause': 19,
  'break': 19,
  'caps': 20,
  'return': 13,
  'escape': 27,
  'spc': 32,
  'spacebar': 32,
  'pgup': 33,
  'pgdn': 34,
  'ins': 45,
  'del': 46,
  'cmd': 91
};

/*!
 * Programatically add the following
 */

// lower case chars
for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;

// numbers
for (var i = 48; i < 58; i++) codes[i - 48] = i;

// function keys
for (i = 1; i < 13; i++) codes['f'+i] = i + 111;

// numpad keys
for (i = 0; i < 10; i++) codes['numpad '+i] = i + 96;

/**
 * Get by code
 *
 *   exports.name[13] // => 'Enter'
 */

var names = exports.names = exports.title = {}; // title for backward compat

// Create reverse mapping
for (i in codes) names[codes[i]] = i;

// Add aliases
for (var alias in aliases) {
  codes[alias] = aliases[alias];
}
});
var keycode_1 = keycode.code;
var keycode_2 = keycode.codes;
var keycode_3 = keycode.aliases;
var keycode_4 = keycode.names;
var keycode_5 = keycode.title;

var codeData = {
  "+": "plus",
  "left command": "meta",
  "right command": "meta"
};
var keysSort = {
  shift: 1,
  ctrl: 2,
  alt: 3,
  meta: 4
};
/**
 * @memberof KeyController
 */

function getKey(keyCode) {
  var key = keycode_4[keyCode] || "";

  for (var name in codeData) {
    key = key.replace(name, codeData[name]);
  }

  return key.replace(/\s/g, "");
}
/**
 * @memberof KeyController
 */

function getCombi(e, key) {
  if (key === void 0) {
    key = getKey(e.keyCode);
  }

  var keys = getModifierCombi(e);
  keys.indexOf(key) === -1 && keys.push(key);
  return keys.filter(Boolean);
}
/**
 * @memberof KeyController
 */

function getModifierCombi(e) {
  var keys = [e.shiftKey && "shift", e.ctrlKey && "ctrl", e.altKey && "alt", e.metaKey && "meta"];
  return keys.filter(Boolean);
}

function getArrangeCombi(keys) {
  var arrangeKeys = keys.slice();
  arrangeKeys.sort(function (prev, next) {
    var prevScore = keysSort[prev] || 5;
    var nextScore = keysSort[next] || 5;
    return prevScore - nextScore;
  });
  return arrangeKeys;
}

var globalKeyController;
/**
 */

var KeyController =
/*#__PURE__*/
function (_super) {
  __extends(KeyController, _super);
  /**
   *
   */


  function KeyController(container) {
    if (container === void 0) {
      container = window;
    }

    var _this = _super.call(this) || this;

    _this.container = container;
    /**
     */

    _this.ctrlKey = false;
    /**
     */

    _this.altKey = false;
    /**
     *
     */

    _this.shiftKey = false;
    /**
     *
     */

    _this.metaKey = false;

    _this.clear = function () {
      _this.ctrlKey = false;
      _this.altKey = false;
      _this.shiftKey = false;
      _this.metaKey = false;
      return _this;
    };

    _this.keydownEvent = function (e) {
      _this.triggerEvent("keydown", e);
    };

    _this.keyupEvent = function (e) {
      _this.triggerEvent("keyup", e);
    };

    _this.blur = function () {
      _this.clear();

      _this.trigger("blur");
    };

    addEvent(container, "blur", _this.blur);
    addEvent(container, "keydown", _this.keydownEvent);
    addEvent(container, "keyup", _this.keyupEvent);
    return _this;
  }

  var __proto = KeyController.prototype;
  Object.defineProperty(KeyController, "global", {
    /**
     */
    get: function () {
      return globalKeyController || (globalKeyController = new KeyController());
    },
    enumerable: false,
    configurable: true
  });

  KeyController.setGlobal = function () {
    return this.global;
  };
  /**
   *
   */


  __proto.destroy = function () {
    var container = this.container;
    this.clear();
    this.off();
    removeEvent(container, "blur", this.blur);
    removeEvent(container, "keydown", this.keydownEvent);
    removeEvent(container, "keyup", this.keyupEvent);
  };
  /**
   *
   */


  __proto.keydown = function (comb, callback) {
    return this.addEvent("keydown", comb, callback);
  };
  /**
   *
   */


  __proto.offKeydown = function (comb, callback) {
    return this.removeEvent("keydown", comb, callback);
  };
  /**
   *
   */


  __proto.offKeyup = function (comb, callback) {
    return this.removeEvent("keyup", comb, callback);
  };
  /**
   *
   */


  __proto.keyup = function (comb, callback) {
    return this.addEvent("keyup", comb, callback);
  };

  __proto.addEvent = function (type, comb, callback) {
    if (isArray(comb)) {
      this.on(type + "." + getArrangeCombi(comb).join("."), callback);
    } else if (isString(comb)) {
      this.on(type + "." + comb, callback);
    } else {
      this.on(type, comb);
    }

    return this;
  };

  __proto.removeEvent = function (type, comb, callback) {
    if (isArray(comb)) {
      this.off(type + "." + getArrangeCombi(comb).join("."), callback);
    } else if (isString(comb)) {
      this.off(type + "." + comb, callback);
    } else {
      this.off(type, comb);
    }

    return this;
  };

  __proto.triggerEvent = function (type, e) {
    this.ctrlKey = e.ctrlKey;
    this.shiftKey = e.shiftKey;
    this.altKey = e.altKey;
    this.metaKey = e.metaKey;
    var key = getKey(e.keyCode);
    var isToggle = key === "ctrl" || key === "shift" || key === "meta" || key === "alt";
    var param = {
      key: key,
      isToggle: isToggle,
      inputEvent: e,
      keyCode: e.keyCode,
      ctrlKey: e.ctrlKey,
      altKey: e.altKey,
      shiftKey: e.shiftKey,
      metaKey: e.metaKey
    };
    this.trigger(type, param);
    this.trigger(type + "." + key, param);
    var combi = getCombi(e, key);
    combi.length > 1 && this.trigger(type + "." + combi.join("."), param);
  };

  return KeyController;
}(EventEmitter);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyController);

//# sourceMappingURL=keycon.esm.js.map


/***/ }),

/***/ "./.yarn/cache/moveable-npm-0.28.0-32d066096a-1fee85a8c7.zip/node_modules/moveable/dist/moveable.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EVENTS": () => (/* binding */ EVENTS),
/* harmony export */   "METHODS": () => (/* binding */ METHODS),
/* harmony export */   "PROPERTIES": () => (/* binding */ PROPERTIES),
/* harmony export */   "PROPS_MAP": () => (/* binding */ PROPS_MAP),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getElementInfo": () => (/* binding */ getElementInfo),
/* harmony export */   "makeAble": () => (/* binding */ makeAble)
/* harmony export */ });
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.1-d35db08ba4-07a47e750f.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/react-compat-moveable-virtual-81b7a42abb/0/cache/react-compat-moveable-npm-0.16.0-395b3c92e9-b20bd91698.zip/node_modules/react-compat-moveable/dist/moveable.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2019 Daybrush
name: moveable
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/moveable.git
version: 0.28.0
*/





/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

var InnerMoveable =
/*#__PURE__*/
function (_super) {
  __extends(InnerMoveable, _super);

  function InnerMoveable(props) {
    var _this = _super.call(this, props) || this;

    _this.state = {};
    _this.state = _this.props;
    return _this;
  }

  var __proto = InnerMoveable.prototype;

  __proto.render = function () {
    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createPortal)((0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__["default"], __assign({
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.ref)(this, "moveable")
    }, this.state)), this.state.parentElement);
  };

  return InnerMoveable;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.Component);

var PROPERTIES = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_PROPS;
var METHODS = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_METHODS;
var EVENTS = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_EVENTS;
var PROPS_MAP = react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.MOVEABLE_PROPS_MAP;

/*
Copyright (c) 2019 Daybrush
name: @scena/event-emitter
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/gesture.git
version: 1.0.3
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1 = function () {
  __assign$1 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$1.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * Implement EventEmitter on object or component.
 */

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * Add a listener to the registered event.
   * @param - Name of the event to be added
   * @param - listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add listener in "a" event
   * emitter.on("a", () => {
   * });
   * // Add listeners
   * emitter.on({
   *  a: () => {},
   *  b: () => {},
   * });
   */


  var __proto = EventEmitter.prototype;

  __proto.on = function (eventName, listener) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(eventName)) {
      for (var name in eventName) {
        this.on(name, eventName[name]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }

    return this;
  };
  /**
   * Remove listeners registered in the event target.
   * @param - Name of the event to be removed
   * @param - listener function of the event to be removed
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Remove all listeners.
   * emitter.off();
   *
   * // Remove all listeners in "A" event.
   * emitter.off("a");
   *
   *
   * // Remove "listener" listener in "a" event.
   * emitter.off("a", listener);
   */


  __proto.off = function (eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(eventName)) {
      for (var name in eventName) {
        this.off(name);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];

      if (events) {
        var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(events, function (e) {
          return e.listener === listener;
        });

        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }

    return this;
  };
  /**
   * Add a disposable listener and Use promise to the registered event.
   * @param - Name of the event to be added
   * @param - disposable listener function of the event to be added
   * @example
   * import EventEmitter from "@scena/event-emitter";
   * cosnt emitter = new EventEmitter();
   *
   * // Add a disposable listener in "a" event
   * emitter.once("a", () => {
   * });
   *
   * // Use Promise
   * emitter.once("a").then(e => {
   * });
   */


  __proto.once = function (eventName, listener) {
    var _this = this;

    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }

    return new Promise(function (resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */


  __proto.emit = function (eventName, param) {
    var _this = this;

    if (param === void 0) {
      param = {};
    }

    var events = this._events[eventName];

    if (!eventName || !events) {
      return true;
    }

    var isStop = false;
    param.eventType = eventName;

    param.stop = function () {
      isStop = true;
    };

    param.currentTarget = this;

    __spreadArrays(events).forEach(function (info) {
      info.listener(param);

      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });

    return !isStop;
  };
  /**
   * Fires an event to call listeners.
   * @param - Event name
   * @param - Event parameter
   * @return If false, stop the event.
   * @example
   *
   * import EventEmitter from "@scena/event-emitter";
   *
   *
   * const emitter = new EventEmitter();
   *
   * emitter.on("a", e => {
   * });
   *
   *
   * emitter.emit("a", {
   *   a: 1,
   * });
   */

  /**
  * Fires an event to call listeners.
  * @param - Event name
  * @param - Event parameter
  * @return If false, stop the event.
  * @example
  *
  * import EventEmitter from "@scena/event-emitter";
  *
  *
  * const emitter = new EventEmitter();
  *
  * emitter.on("a", e => {
  * });
  *
  * // emit
  * emitter.trigger("a", {
  *   a: 1,
  * });
  */


  __proto.trigger = function (eventName, param) {
    if (param === void 0) {
      param = {};
    }

    return this.emit(eventName, param);
  };

  __proto._addEvent = function (eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign$1({
      listener: listener
    }, options));
  };

  return EventEmitter;
}();

/**
 * Moveable is Draggable! Resizable! Scalable! Rotatable!
 * @sort 1
 * @alias Moveable
 * @extends EventEmitter
 */

var MoveableManager =
/*#__PURE__*/
function (_super) {
  __extends(MoveableManager, _super);
  /**
   *
   */


  function MoveableManager(parentElement, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.tempElement = document.createElement("div");

    var nextOptions = __assign({}, options);

    var events = {};
    EVENTS.forEach(function (name) {
      events[(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.camelize)("on " + name)] = function (e) {
        return _this.trigger(name, e);
      };
    });
    (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.render)((0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerMoveable, __assign({
      ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.ref)(_this, "innerMoveable"),
      parentElement: parentElement
    }, nextOptions, events)), _this.tempElement);
    var target = nextOptions.target;

    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target) && target.length > 1) {
      _this.updateRect();
    }

    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.setState = function (state, callback) {
    this.innerMoveable.setState(state, callback);
  };

  __proto.destroy = function () {
    (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.render)(null, this.tempElement);
    this.off();
    this.tempElement = null;
    this.innerMoveable = null;
  };

  __proto.getMoveable = function () {
    return this.innerMoveable.moveable;
  };

  MoveableManager = __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.Properties)(METHODS, function (prototype, property) {
    if (prototype[property]) {
      return;
    }

    prototype[property] = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var self = this.getMoveable();

      if (!self || !self[property]) {
        return;
      }

      return self[property].apply(self, args);
    };
  }), (0,framework_utils__WEBPACK_IMPORTED_MODULE_2__.Properties)(PROPERTIES, function (prototype, property) {
    Object.defineProperty(prototype, property, {
      get: function () {
        return this.getMoveable().props[property];
      },
      set: function (value) {
        var _a;

        this.setState((_a = {}, _a[property] = value, _a));
      },
      enumerable: true,
      configurable: true
    });
  })], MoveableManager);
  return MoveableManager;
}(EventEmitter);

var Moveable =
/*#__PURE__*/
function (_super) {
  __extends(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return Moveable;
}(MoveableManager);

function getElementInfo(target, container, rootContainer) {
  return (0,react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.getElementInfo)(target, container, rootContainer);
}
function makeAble(name, able) {
  return (0,react_compat_moveable__WEBPACK_IMPORTED_MODULE_1__.makeAble)(name, able);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Moveable);

//# sourceMappingURL=moveable.esm.js.map


/***/ }),

/***/ "./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertLines": () => (/* binding */ convertLines),
/* harmony export */   "fitPoints": () => (/* binding */ fitPoints),
/* harmony export */   "getAreaSize": () => (/* binding */ getAreaSize),
/* harmony export */   "getIntersectionPoints": () => (/* binding */ getIntersectionPoints),
/* harmony export */   "getIntersectionPointsByConstants": () => (/* binding */ getIntersectionPointsByConstants),
/* harmony export */   "getLinearConstants": () => (/* binding */ getLinearConstants),
/* harmony export */   "getMinMaxs": () => (/* binding */ getMinMaxs),
/* harmony export */   "getOverlapPoints": () => (/* binding */ getOverlapPoints),
/* harmony export */   "getOverlapSize": () => (/* binding */ getOverlapSize),
/* harmony export */   "getPointsOnLines": () => (/* binding */ getPointsOnLines),
/* harmony export */   "isInside": () => (/* binding */ isInside)
/* harmony export */ });
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) 2020 Daybrush
name: overlap-area
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/overlap-area.git
version: 1.0.0
*/


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/**
 * @namespace OverlapArea
 */

/**
 * Gets the size of a shape (polygon) made of points.
 * @memberof OverlapArea
 */

function getAreaSize(points) {
  if (points.length < 3) {
    return 0;
  }

  return Math.abs((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.sum)(points.map(function (point, i) {
    var nextPoint = points[i + 1] || points[0];
    return point[0] * nextPoint[1] - nextPoint[0] * point[1];
  }))) / 2;
}
/**
 * Get points that fit the rect,
 * @memberof OverlapArea
 */

function fitPoints(points, rect) {
  var width = rect.width,
      height = rect.height,
      left = rect.left,
      top = rect.top;

  var _a = getMinMaxs(points),
      minX = _a.minX,
      minY = _a.minY,
      maxX = _a.maxX,
      maxY = _a.maxY;

  var ratioX = width / (maxX - minX);
  var ratioY = height / (maxY - minY);
  return points.map(function (point) {
    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];
  });
}
/**
 * Get the minimum and maximum points of the points.
 * @memberof OverlapArea
 */

function getMinMaxs(points) {
  var xs = points.map(function (point) {
    return point[0];
  });
  var ys = points.map(function (point) {
    return point[1];
  });
  return {
    minX: Math.min.apply(Math, xs),
    minY: Math.min.apply(Math, ys),
    maxX: Math.max.apply(Math, xs),
    maxY: Math.max.apply(Math, ys)
  };
}
/**
 * Whether the point is in shape
 * @param - point pos
 * @param - shape points
 * @param - whether to check except line
 * @memberof OverlapArea
 */

function isInside(pos, points, excludeLine) {
  var x = pos[0],
      y = pos[1];

  var _a = getMinMaxs(points),
      minX = _a.minX,
      minY = _a.minY,
      maxX = _a.maxX,
      maxY = _a.maxY;

  var xLine = [[minX, y], [maxX, y]];
  var yLine = [[x, minY], [x, maxY]];
  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);
  var yLinearConstants = getLinearConstants(yLine[0], yLine[1]);
  var lines = convertLines(points);
  var intersectionXPoints = [];
  var intersectionYPoints = [];
  lines.forEach(function (line) {
    var linearConstants = getLinearConstants(line[0], line[1]);
    var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);
    var yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);

    if (xPoints.length === 1 ? line[0][1] !== y : true) {
      intersectionXPoints.push.apply(intersectionXPoints, xPoints);
    }

    if (yPoints.length === 1 ? line[0][0] !== x : true) {
      intersectionYPoints.push.apply(intersectionYPoints, yPoints);
    }

    if (!linearConstants[0]) {
      intersectionXPoints.push.apply(intersectionXPoints, xPoints);
    }

    if (!linearConstants[1]) {
      intersectionYPoints.push.apply(intersectionYPoints, yPoints);
    }
  });

  if (!excludeLine) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(intersectionXPoints, function (p) {
      return p[0] === x;
    }) > -1 || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(intersectionYPoints, function (p) {
      return p[1] === y;
    }) > -1) {
      return true;
    }
  }

  if (intersectionXPoints.filter(function (p) {
    return p[0] > x;
  }).length % 2 && intersectionYPoints.filter(function (p) {
    return p[1] > y;
  }).length % 2) {
    return true;
  }

  return false;
}
/**
 * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)
 * @return [a, b, c]
 * @memberof OverlapArea
 */

function getLinearConstants(point1, point2) {
  var x1 = point1[0],
      y1 = point1[1];
  var x2 = point2[0],
      y2 = point2[1]; // ax + by + c = 0

  if (x1 === x2 && y1 === y2) {
    return [0, 0, 0];
  }

  if (x1 === x2) {
    // x = x1
    return [1, 0, -x1];
  } else if (y1 === y2) {
    // y = y1
    return [0, 1, -y1];
  } else {
    // x1 + a * y1 + b = 0
    // x2 + a * y2 + b = 0
    // (x1 -x2) + (y1 - y2) * a = 0
    // a = (x2 - x1) / (y1 - y2)
    // x1 + (x2 - x1) / (y1 - y2)
    var a_1 = (x2 - x1) / (y1 - y2);
    var b_1 = -x1 - a_1 * y1;
    return [1, a_1, b_1];
  }
}
/**
 * Get intersection points with linear functions.
 * @memberof OverlapArea
 */

function getIntersectionPointsByConstants(linearConstants1, linearConstants2) {
  var a1 = linearConstants1[0],
      b1 = linearConstants1[1],
      c1 = linearConstants1[2];
  var a2 = linearConstants2[0],
      b2 = linearConstants2[1],
      c2 = linearConstants2[2];
  var isZeroA = a1 === 0 && a2 === 0;
  var isZeroB = b1 === 0 && b2 === 0;

  if (isZeroA && isZeroB) {
    return [];
  } else if (isZeroA) {
    // b1 * y + c1 = 0
    // b2 * y + c2 = 0
    var y1 = -c1 / b1;
    var y2 = -c2 / b2;

    if (y1 !== y2) {
      return [];
    } else {
      return [[-Infinity, y1], [Infinity, y1]];
    }
  } else if (isZeroB) {
    // a1 * x + c1 = 0
    // a2 * x + c2 = 0
    var x1 = -c1 / a1;
    var x2 = -c2 / a2;

    if (x1 !== x2) {
      return [];
    } else {
      return [[x1, -Infinity], [x1, Infinity]];
    }
  } else if (a1 === 0) {
    // b1 * y + c1 = 0
    // y = - c1 / b1;
    // a2 * x + b2 * y + c2 = 0
    var y = -c1 / b1;
    var x = -(b2 * y + c2) / a2;
    return [[x, y]];
  } else if (a2 === 0) {
    // b2 * y + c2 = 0
    // y = - c2 / b2;
    // a1 * x + b1 * y + c1 = 0
    var y = -c2 / b2;
    var x = -(b1 * y + c1) / a1;
    return [[x, y]];
  } else if (b1 === 0) {
    // a1 * x + c1 = 0
    // x = - c1 / a1;
    // a2 * x + b2 * y + c2 = 0
    var x = -c1 / a1;
    var y = -(a2 * x + c2) / b2;
    return [[x, y]];
  } else if (b2 === 0) {
    // a2 * x + c2 = 0
    // x = - c2 / a2;
    // a1 * x + b1 * y + c1 = 0
    var x = -c2 / a2;
    var y = -(a1 * x + c1) / b1;
    return [[x, y]];
  } else {
    // a1 * x + b1 * y + c1 = 0
    // a2 * x + b2 * y + c2 = 0
    // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0
    // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0
    // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)
    var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);
    var y = -(a1 * x + c1) / b1;
    return [[x, y]];
  }
}
/**
 * Get intersection points to the two lines.
 * @memberof OverlapArea
 */

function getIntersectionPoints(line1, line2, isLimit) {
  var points = getIntersectionPointsByConstants(getLinearConstants(line1[0], line1[1]), getLinearConstants(line2[0], line2[1]));

  if (isLimit) {
    return getPointsOnLines(points, [line1, line2]);
  }

  return points;
}
/**
 * Get the points on the lines (between two points).
 * @memberof OverlapArea
 */

function getPointsOnLines(points, lines) {
  var minMaxs = lines.map(function (line) {
    return [0, 1].map(function (order) {
      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];
    });
  });

  if (points.length === 2) {
    var _a = points[0],
        x = _a[0],
        y = _a[1];

    if (x === points[1][0]) {
      /// Math.max(minY1, minY2)
      var top = Math.max.apply(Math, minMaxs.map(function (minMax) {
        return minMax[1][0];
      })); /// Math.min(maxY1, miax2)

      var bottom = Math.min.apply(Math, minMaxs.map(function (minMax) {
        return minMax[1][1];
      }));

      if (top > bottom) {
        return [];
      }

      return [[x, top], [x, bottom]];
    } else if (y === points[1][1]) {
      /// Math.max(minY1, minY2)
      var left = Math.max.apply(Math, minMaxs.map(function (minMax) {
        return minMax[0][0];
      })); /// Math.min(maxY1, miax2)

      var right = Math.min.apply(Math, minMaxs.map(function (minMax) {
        return minMax[0][1];
      }));

      if (left > right) {
        return [];
      }

      return [[left, y], [right, y]];
    }
  }

  return points.filter(function (point) {
    return minMaxs.every(function (minMax) {
      return minMax[0][0] <= point[0] && point[0] <= minMax[0][1] && minMax[1][0] <= point[1] && point[1] <= minMax[1][1];
    });
  });
}
/**
* Convert two points into lines.
* @function
* @memberof OverlapArea
*/

function convertLines(points) {
  return __spreadArrays(points.slice(1), [points[0]]).map(function (point, i) {
    return [points[i], point];
  });
}
/**
* Get the points of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/

function getOverlapPoints(points1, points2) {
  var targetPoints1 = points1.slice();
  var targetPoints2 = points2.slice();

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(targetPoints1) === -1) {
    targetPoints1.reverse();
  }

  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getShapeDirection)(targetPoints2) === -1) {
    targetPoints2.reverse();
  }

  var lines1 = convertLines(targetPoints1);
  var lines2 = convertLines(targetPoints2);
  var linearConstantss1 = lines1.map(function (line1) {
    return getLinearConstants(line1[0], line1[1]);
  });
  var linearConstantss2 = lines2.map(function (line2) {
    return getLinearConstants(line2[0], line2[1]);
  });
  var overlapInfos = [];
  linearConstantss1.forEach(function (linearConstants1, i) {
    var line1 = lines1[i];
    var linePointInfos = [];
    linearConstantss2.forEach(function (linearConstants2, j) {
      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);
      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);
      linePointInfos.push.apply(linePointInfos, points.map(function (pos) {
        return {
          index1: i,
          index2: j,
          pos: pos
        };
      }));
    });
    linePointInfos.sort(function (a, b) {
      return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(line1[0], a.pos) - (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(line1[0], b.pos);
    });
    overlapInfos.push.apply(overlapInfos, linePointInfos);

    if (isInside(line1[1], targetPoints2)) {
      overlapInfos.push({
        index1: i,
        index2: -1,
        pos: line1[1]
      });
    }
  });
  lines2.forEach(function (line2, i) {
    if (isInside(line2[1], targetPoints1)) {
      var isNext_1 = false;
      var index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(overlapInfos, function (_a) {
        var index2 = _a.index2;

        if (index2 === i) {
          isNext_1 = true;
          return false;
        }

        if (isNext_1) {
          return true;
        }

        return false;
      });

      if (index === -1) {
        isNext_1 = false;
        index = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.findIndex)(overlapInfos, function (_a) {
          var index1 = _a.index1,
              index2 = _a.index2;

          if (index1 === -1 && index2 + 1 === i) {
            isNext_1 = true;
            return false;
          }

          if (isNext_1) {
            return true;
          }

          return false;
        });
      }

      if (index === -1) {
        overlapInfos.push({
          index1: -1,
          index2: i,
          pos: line2[1]
        });
      } else {
        overlapInfos.splice(index, 0, {
          index1: -1,
          index2: i,
          pos: line2[1]
        });
      }
    }
  }); // console.log(overlapInfos);

  var overlapPoints = overlapInfos.map(function (_a) {
    var pos = _a.pos;
    return pos;
  });
  var pointMap = {};
  return overlapPoints.filter(function (point) {
    var key = point[0] + "x" + point[1];

    if (pointMap[key]) {
      return false;
    }

    pointMap[key] = true;
    return true;
  });
}
/**
* Gets the size of the overlapped part of two shapes.
* @function
* @memberof OverlapArea
*/

function getOverlapSize(points1, points2) {
  var points = getOverlapPoints(points1, points2);
  return getAreaSize(points);
}


//# sourceMappingURL=overlap-area.esm.js.map


/***/ }),

/***/ "./.yarn/cache/react-compat-css-styled-npm-1.0.8-52211d26f8-7a8e51849e.zip/node_modules/react-compat-css-styled/dist/styled.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StyledElement": () => (/* binding */ StyledElement),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var css_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js");
/* harmony import */ var react_simple_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-simple-compat-npm-1.2.1-d35db08ba4-07a47e750f.zip/node_modules/react-simple-compat/dist/compat.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/*
Copyright (c) Daybrush
name: react-compat-css-styled
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/css-styled.git
version: 1.0.8
*/




/*
Copyright (c) 2019 Daybrush
name: react-css-styled
license: MIT
author: Daybrush
repository: https://github.com/daybrush/css-styled/tree/master/packages/react-css-styled
version: 1.0.3
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

var StyledElement =
/*#__PURE__*/
function (_super) {
  __extends(StyledElement, _super);

  function StyledElement() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.injectResult = null;
    _this.tag = "div";
    return _this;
  }

  var __proto = StyledElement.prototype;

  __proto.render = function () {
    var _a = this.props,
        _b = _a.className,
        className = _b === void 0 ? "" : _b,
        cspNonce = _a.cspNonce,
        portalContainer = _a.portalContainer,
        attributes = __rest(_a, ["className", "cspNonce", "portalContainer"]);

    var cssId = this.injector.className;
    var Tag = this.tag;
    var portalAttributes = {};

    if ((react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.version || "").indexOf("simple") > -1 && portalContainer) {
      portalAttributes = {
        portalContainer: portalContainer
      };
    }

    return (0,react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.createElement)(Tag, __assign({
      "ref": (0,framework_utils__WEBPACK_IMPORTED_MODULE_1__.ref)(this, "element"),
      "data-styled-id": cssId,
      "className": className + " " + cssId
    }, portalAttributes, attributes));
  };

  __proto.componentDidMount = function () {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  };

  __proto.componentWillUnmount = function () {
    this.injectResult.destroy();
    this.injectResult = null;
  };

  __proto.getElement = function () {
    return this.element;
  };

  return StyledElement;
}(react_simple_compat__WEBPACK_IMPORTED_MODULE_0__.Component);

function styled(tag, css) {
  var injector = (0,css_styled__WEBPACK_IMPORTED_MODULE_2__["default"])(css);
  return (
    /*#__PURE__*/
    function (_super) {
      __extends(Styled, _super);

      function Styled() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.injector = injector;
        _this.tag = tag;
        return _this;
      }

      return Styled;
    }(StyledElement)
  );
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styled);



/***/ }),

/***/ "./.yarn/cache/react-simple-compat-npm-1.2.1-d35db08ba4-07a47e750f.zip/node_modules/react-simple-compat/dist/compat.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ Component),
/* harmony export */   "PureComponent": () => (/* binding */ PureComponent),
/* harmony export */   "createElement": () => (/* binding */ createElement),
/* harmony export */   "createPortal": () => (/* binding */ createPortal),
/* harmony export */   "findDOMNode": () => (/* binding */ findDOMNode),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@egjs-list-differ-npm-1.0.0-f4b91781db-d1827d134d.zip/node_modules/@egjs/list-differ/dist/list-differ.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/*
Copyright (c) Daybrush
name: react-simple-compat
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/react-simple-compat.git
version: 1.2.1
*/



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function isDiff(a, b) {
  if (a === b) {
    return false;
  }

  for (var i in a) {
    if (!(i in b)) {
      return true;
    }
  }

  for (var i in b) {
    if (a[i] !== b[i]) {
      return true;
    }
  }

  return false;
}

function diffObject(a, b) {
  var keys1 = Object.keys(a);
  var keys2 = Object.keys(b);
  var result = (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(keys1, keys2, function (key) {
    return key;
  });
  var added = {};
  var removed = {};
  var changed = {};
  result.added.forEach(function (index) {
    var name = keys2[index];
    added[name] = b[name];
  });
  result.removed.forEach(function (index) {
    var name = keys1[index];
    removed[name] = a[name];
  });
  result.maintained.forEach(function (_a) {
    var index = _a[0];
    var name = keys1[index];
    var values = [a[name], b[name]];

    if (a[name] !== b[name]) {
      changed[name] = values;
    }
  });
  return {
    added: added,
    removed: removed,
    changed: changed
  };
}

function executeHooks(hooks) {
  hooks.forEach(function (hook) {
    hook();
  });
}

function fillKeys(keys) {
  var index = 0;
  return keys.map(function (key) {
    return key == null ? "$compat" + ++index : "" + key;
  });
}

function createProvider(el, key, index, container) {
  if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(el) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(el)) {
    return new TextProvider("text_" + el, key, index, container, null, {});
  }

  var providerClass = typeof el.type === "string" ? ElementProvider : el.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new providerClass(el.type, key, index, container, el.ref, el.props);
}

function flat(arr) {
  var arr2 = [];
  arr.forEach(function (el) {
    arr2 = arr2.concat((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(el) ? flat(el) : el);
  });
  return arr2;
}

function getAttributes(props) {
  var className = props.className,
      otherProps = __rest(props, ["className"]);

  if (className != null) {
    otherProps.class = className;
  }

  delete otherProps.style;
  delete otherProps.children;
  return otherProps;
}

function fillProps(props, defaultProps) {
  if (!defaultProps) {
    return props;
  }

  for (var name in defaultProps) {
    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(props[name])) {
      props[name] = defaultProps[name];
    }
  }

  return props;
}

function createElement(type, props) {
  var children = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }

  var _a = props || {},
      key = _a.key,
      ref = _a.ref,
      otherProps = __rest(_a, ["key", "ref"]);

  return {
    type: type,
    key: key,
    ref: ref,
    props: __assign(__assign({}, otherProps), {
      children: flat(children).filter(function (child) {
        return child != null && child !== false;
      })
    })
  };
}

var Provider =
/*#__PURE__*/
function () {
  function Provider(type, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }

    this.type = type;
    this.key = key;
    this.index = index;
    this.container = container;
    this.ref = ref;
    this.props = props;
    this._providers = [];
  }

  var __proto = Provider.prototype;

  __proto._should = function (nextProps, nextState) {
    return true;
  };

  __proto._update = function (hooks, nextElement, nextState, isForceUpdate) {
    if (this.base && !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(nextElement) && !isForceUpdate && !this._should(nextElement.props, nextState)) {
      return false;
    }

    this.original = nextElement;

    this._setState(nextState); // render


    var prevProps = this.props;

    if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(nextElement)) {
      this.props = nextElement.props;
      this.ref = nextElement.ref;
    }

    this._render(hooks, this.base ? prevProps : {}, nextState);

    return true;
  };

  __proto._mounted = function () {
    var ref = this.ref;
    ref && ref(this.base);
  };

  __proto._setState = function (nextstate) {
    return;
  };

  __proto._updated = function () {
    var ref = this.ref;
    ref && ref(this.base);
  };

  __proto._destroy = function () {
    var ref = this.ref;
    ref && ref(null);
  };

  return Provider;
}();

function diffAttributes(attrs1, attrs2, el) {
  var _a = diffObject(attrs1, attrs2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var name in added) {
    el.setAttribute(name, added[name]);
  }

  for (var name in changed) {
    el.setAttribute(name, changed[name][1]);
  }

  for (var name in removed) {
    el.removeAttribute(name);
  }
}

function diffEvents(events1, events2, provier) {
  var _a = diffObject(events1, events2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var name in removed) {
    provier.removeEventListener(name);
  }

  for (var name in added) {
    provier.addEventListener(name, added[name]);
  }

  for (var name in changed) {
    provier.removeEventListener(name);
    provier.addEventListener(name, changed[name][1]);
  }

  for (var name in removed) {
    provier.removeEventListener(name);
  }
}

function diffStyle(style1, style2, el) {
  var style = el.style;

  var _a = diffObject(style1, style2),
      added = _a.added,
      removed = _a.removed,
      changed = _a.changed;

  for (var beforeName in added) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.setProperty) {
      style.setProperty(name, added[beforeName]);
    } else {
      style[name] = added[beforeName];
    }
  }

  for (var beforeName in changed) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.setProperty) {
      style.setProperty(name, changed[beforeName][1]);
    } else {
      style[name] = changed[beforeName][1];
    }
  }

  for (var beforeName in removed) {
    var name = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.decamelize)(beforeName, "-");

    if (style.removeProperty) {
      style.removeProperty(name);
    } else {
      style[name] = "";
    }
  }
}

function splitProps(props) {
  var attributes = {};
  var events = {};

  for (var name in props) {
    if (name.indexOf("on") === 0) {
      events[name.replace("on", "").toLowerCase()] = props[name];
    } else {
      attributes[name] = props[name];
    }
  }

  return {
    attributes: attributes,
    events: events
  };
}

var TextProvider =
/*#__PURE__*/
function (_super) {
  __extends(TextProvider, _super);

  function TextProvider() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = TextProvider.prototype;

  __proto._render = function (hooks) {
    var _this = this;

    var isMount = !this.base;

    if (isMount) {
      this.base = document.createTextNode(this.type.replace("text_", ""));
    }

    hooks.push(function () {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };

  __proto._unmount = function () {
    this.base.parentNode.removeChild(this.base);
  };

  return TextProvider;
}(Provider);

var ElementProvider =
/*#__PURE__*/
function (_super) {
  __extends(ElementProvider, _super);

  function ElementProvider() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.events = {};
    _this._isSVG = false;
    return _this;
  }

  var __proto = ElementProvider.prototype;

  __proto.addEventListener = function (name, callback) {
    var events = this.events;

    events[name] = function (e) {
      e.nativeEvent = e;
      callback(e);
    };

    this.base.addEventListener(name, events[name]);
  };

  __proto.removeEventListener = function (name) {
    var events = this.events;
    this.base.removeEventListener(name, events[name]);
    delete events[name];
  };

  __proto._should = function (nextProps) {
    return isDiff(this.props, nextProps);
  };

  __proto._render = function (hooks, prevProps) {
    var _this = this;

    var isMount = !this.base;

    if (isMount) {
      var isSVG = this._hasSVG();

      this._isSVG = isSVG;
      var element = this.props.portalContainer;

      if (!element) {
        var type = this.type;

        if (isSVG) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
      }

      this.base = element;
    }

    renderProviders(this, this._providers, this.props.children, hooks, null);
    var base = this.base;

    var _a = splitProps(prevProps),
        prevAttributes = _a.attributes,
        prevEvents = _a.events;

    var _b = splitProps(this.props),
        nextAttributes = _b.attributes,
        nextEvents = _b.events;

    diffAttributes(getAttributes(prevAttributes), getAttributes(nextAttributes), base);
    diffEvents(prevEvents, nextEvents, this);
    diffStyle(prevProps.style || {}, this.props.style || {}, base);
    hooks.push(function () {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };

  __proto._unmount = function () {
    var events = this.events;
    var base = this.base;

    for (var name in events) {
      base.removeEventListener(name, events[name]);
    }

    this._providers.forEach(function (provider) {
      provider._unmount();
    });

    this.events = {};

    if (!this.props.portalContainer) {
      base.parentNode.removeChild(base);
    }
  };

  __proto._hasSVG = function () {
    if (this._isSVG || this.type === "svg") {
      return true;
    }

    var containerNode = findContainerNode(this.container);
    return containerNode && "ownerSVGElement" in containerNode;
  };

  return ElementProvider;
}(Provider);

function findContainerNode(provider) {
  if (!provider) {
    return null;
  }

  var base = provider.base;

  if (base instanceof Node) {
    return base;
  }

  return findContainerNode(provider.container);
}

function findDOMNode(comp) {
  if (!comp) {
    return null;
  }

  if (comp instanceof Node) {
    return comp;
  }

  var providers = comp.$_provider._providers;

  if (!providers.length) {
    return null;
  }

  return findDOMNode(providers[0].base);
}

var FunctionProvider =
/*#__PURE__*/
function (_super) {
  __extends(FunctionProvider, _super);

  function FunctionProvider() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = FunctionProvider.prototype;

  __proto._render = function (hooks) {
    var template = this.type(this.props);
    renderProviders(this, this._providers, template ? [template] : [], hooks);
    return true;
  };

  __proto._unmount = function () {
    this._providers.forEach(function (provider) {
      provider._unmount();
    });
  };

  return FunctionProvider;
}(Provider);

var ContainerProvider =
/*#__PURE__*/
function (_super) {
  __extends(ContainerProvider, _super);

  function ContainerProvider(base) {
    var _this = _super.call(this, "container", "container", 0, null) || this;

    _this.base = base;
    return _this;
  }

  var __proto = ContainerProvider.prototype;

  __proto._render = function () {
    return true;
  };

  __proto._unmount = function () {
    return;
  };

  return ContainerProvider;
}(Provider);

var ComponentProvider =
/*#__PURE__*/
function (_super) {
  __extends(ComponentProvider, _super);

  function ComponentProvider(type, key, index, container, ref, props) {
    if (props === void 0) {
      props = {};
    }

    return _super.call(this, type, key, index, container, ref, fillProps(props, type.defaultProps)) || this;
  }

  var __proto = ComponentProvider.prototype;

  __proto._should = function (nextProps, nextState) {
    return this.base.shouldComponentUpdate(fillProps(nextProps, this.type.defaultProps), nextState || this.base.state);
  };

  __proto._render = function (hooks, prevProps, nextState) {
    var _this = this;

    this.props = fillProps(this.props, this.type.defaultProps);
    var isMount = !this.base;

    if (isMount) {
      this.base = new this.type(this.props);
      this.base.$_provider = this;
    } else {
      this.base.props = this.props;
    }

    var base = this.base;
    var prevState = base.state;
    var template = base.render();

    if (template && template.props && !template.props.children.length) {
      template.props.children = this.props.children;
    }

    renderProviders(this, this._providers, template ? [template] : [], hooks, nextState, null);
    hooks.push(function () {
      if (isMount) {
        _this._mounted();

        base.componentDidMount();
      } else {
        _this._updated();

        base.componentDidUpdate(prevProps, prevState);
      }
    });
  };

  __proto._setState = function (nextState) {
    if (!nextState) {
      return;
    }

    var base = this.base;
    base.state = nextState;
  };

  __proto._unmount = function () {
    this._providers.forEach(function (provider) {
      provider._unmount();
    });

    clearTimeout(this.base.$_timer);
    this.base.componentWillUnmount();
  };

  return ComponentProvider;
}(Provider);

var Component =
/*#__PURE__*/
function () {
  function Component(props) {
    if (props === void 0) {
      props = {};
    }

    this.props = props;
    this.state = {};
    this.$_timer = 0;
    this.$_state = {};
  }

  var __proto = Component.prototype;

  __proto.shouldComponentUpdate = function (props, state) {
    return true;
  };

  __proto.render = function () {
    return null;
  };

  __proto.setState = function (state, callback, isForceUpdate) {
    var _this = this;

    if (!this.$_timer) {
      this.$_state = {};
    }

    clearTimeout(this.$_timer);
    this.$_timer = 0;
    this.$_state = __assign(__assign({}, this.$_state), state);

    if (!isForceUpdate) {
      this.$_timer = setTimeout(function () {
        _this.$_timer = 0;

        _this.$_setState(callback, isForceUpdate);
      });
    } else {
      this.$_setState(callback, isForceUpdate);
    }

    return;
  };

  __proto.forceUpdate = function (callback) {
    this.setState({}, callback, true);
  };

  __proto.componentDidMount = function () {};

  __proto.componentDidUpdate = function (prevProps, prevState) {};

  __proto.componentWillUnmount = function () {};

  __proto.$_setState = function (callback, isForceUpdate) {
    var hooks = [];
    var provider = this.$_provider;
    var isUpdate = renderProviders(provider.container, [provider], [provider.original], hooks, __assign(__assign({}, this.state), this.$_state), isForceUpdate);

    if (isUpdate) {
      if (callback) {
        hooks.push(callback);
      }

      executeHooks(hooks);
    }
  };

  return Component;
}();

var PureComponent =
/*#__PURE__*/
function (_super) {
  __extends(PureComponent, _super);

  function PureComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = PureComponent.prototype;

  __proto.shouldComponentUpdate = function (props, state) {
    return isDiff(this.props, props) || isDiff(this.state, state);
  };

  return PureComponent;
}(Component);

var _Portal =
/*#__PURE__*/
function (_super) {
  __extends(_Portal, _super);

  function _Portal() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = _Portal.prototype;

  __proto.componentDidMount = function () {
    var _a = this.props,
        element = _a.element,
        container = _a.container;
    this._portalProvider = new ContainerProvider(container);
    renderProvider(element, container, this._portalProvider);
  };

  __proto.componentDidUpdate = function () {
    var _a = this.props,
        element = _a.element,
        container = _a.container;
    renderProvider(element, container, this._portalProvider);
  };

  __proto.componentWillUnmount = function () {
    var container = this.props.container;
    renderProvider(null, container, this._portalProvider);
    this._portalProvider = null;
  };

  return _Portal;
}(PureComponent);

function updateProvider(provider, children, nextState) {
  var hooks = [];
  renderProviders(provider, provider._providers, children, hooks, nextState);
  executeHooks(hooks);
}

function getNextSibiling(provider, childProvider) {
  var childProviders = provider._providers;
  var length = childProviders.length;

  for (var i = childProvider.index + 1; i < length; ++i) {
    var el = findDOMNode(childProviders[i].base);

    if (el) {
      return el;
    }
  }

  return null;
}

function diffProviders(containerProvider, providers, children) {
  var childrenKeys = children.map(function (p) {
    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(p) ? null : p.key;
  });
  var keys1 = fillKeys(providers.map(function (p) {
    return p.key;
  }));
  var keys2 = fillKeys(childrenKeys);
  var result = (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(keys1, keys2, function (key) {
    return key;
  });
  result.removed.forEach(function (index) {
    providers.splice(index, 1)[0]._unmount();
  });
  result.ordered.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var childrenProvider = providers.splice(from, 1)[0];
    providers.splice(to, 0, childrenProvider);
    var el = findDOMNode(childrenProvider.base);
    var next = findDOMNode(providers[to + 1] && providers[to + 1].base);

    if (el) {
      el.parentNode.insertBefore(el, next);
    }
  });
  result.added.forEach(function (index) {
    providers.splice(index, 0, createProvider(children[index], childrenKeys[index], index, containerProvider));
  });
  var changed = result.maintained.filter(function (_a) {
    var _ = _a[0],
        to = _a[1];
    var el = children[to];
    var childProvider = providers[to];
    var type = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_1__.isString)(el) ? "text_" + el : el.type;

    if (type !== childProvider.type) {
      childProvider._unmount();

      providers.splice(to, 1, createProvider(el, childrenKeys[to], to, containerProvider));
      return true;
    }

    childProvider.index = to;
    return false;
  });
  return __spreadArrays(result.added, changed.map(function (_a) {
    var _ = _a[0],
        to = _a[1];
    return to;
  }));
}

function renderProviders(containerProvider, providers, children, updatedHooks, nextState, isForceUpdate) {
  var result = diffProviders(containerProvider, providers, children);
  var updated = providers.filter(function (childProvider, i) {
    return childProvider._update(updatedHooks, children[i], nextState, isForceUpdate);
  });
  var containerNode = findContainerNode(containerProvider);

  if (containerNode) {
    result.reverse().forEach(function (index) {
      var childProvider = providers[index];
      var el = findDOMNode(childProvider.base);

      if (!el) {
        return;
      }

      if (containerNode !== el && !el.parentNode) {
        var nextElement = getNextSibiling(containerProvider, childProvider);
        containerNode.insertBefore(el, nextElement);
      }
    });
  }

  return updated.length > 0;
}

function renderProvider(element, container, provider) {
  if (provider === void 0) {
    provider = container.__REACT_COMPAT__;
  }

  var isProvider = !!provider;

  if (!provider) {
    provider = new ContainerProvider(container);
  }

  updateProvider(provider, element ? [element] : []);

  if (!isProvider) {
    container.__REACT_COMPAT__ = provider;
  }

  return provider;
}

function render(element, container, callback) {
  var provider = container.__REACT_COMPAT__;

  if (element && !provider) {
    container.innerHTML = "";
  }

  renderProvider(element, container, provider);
  callback && callback();
}
function createPortal(el, container) {
  return createElement(_Portal, {
    element: el,
    container: container
  });
}
var version = "simple-1.1.0";


//# sourceMappingURL=compat.esm.js.map


/***/ }),

/***/ "./.yarn/cache/selecto-npm-1.15.0-eb84959df5-ae19513c77.zip/node_modules/selecto/dist/selecto.esm.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CLASS_NAME": () => (/* binding */ CLASS_NAME),
/* harmony export */   "EVENTS": () => (/* binding */ EVENTS),
/* harmony export */   "METHODS": () => (/* binding */ METHODS),
/* harmony export */   "OPTIONS": () => (/* binding */ OPTIONS),
/* harmony export */   "OPTION_TYPES": () => (/* binding */ OPTION_TYPES),
/* harmony export */   "PROPERTIES": () => (/* binding */ PROPERTIES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/@scena-event-emitter-npm-1.0.5-7ebf361d17-400e0f6ab8.zip/node_modules/@scena/event-emitter/dist/event-emitter.esm.js");
/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/gesto-npm-1.7.0-7d5440000b-f2a66bcf0f.zip/node_modules/gesto/dist/gesto.esm.js");
/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/framework-utils-npm-1.1.0-37a54a069c-01b61ead17.zip/node_modules/framework-utils/dist/utils.esm.js");
/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@daybrush-utils-npm-1.6.0-547486bf79-2579bc17e0.zip/node_modules/@daybrush/utils/dist/utils.esm.js");
/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/@egjs-children-differ-npm-1.0.1-37f45ddf97-087f286822.zip/node_modules/@egjs/children-differ/dist/children-differ.esm.js");
/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/@scena-dragscroll-npm-1.1.1-8fe60775f9-aacb335870.zip/node_modules/@scena/dragscroll/dist/dragscroll.esm.js");
/* harmony import */ var keycon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/keycon-npm-1.1.2-47bb5048df-7be74aaf83.zip/node_modules/keycon/dist/keycon.esm.js");
/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/overlap-area-npm-1.0.0-ece5a4fc6a-37d82ea4ea.zip/node_modules/overlap-area/dist/overlap-area.esm.js");
/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/css-to-mat-npm-1.0.3-8a69ed71de-a3fc98bfad.zip/node_modules/css-to-mat/dist/css-to-mat.esm.js");
/* harmony import */ var css_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/css-styled-virtual-9ef8f05de2/0/cache/css-styled-npm-1.0.0-5104a882d5-3f2f995938.zip/node_modules/css-styled/dist/styled.esm.js");
/*
Copyright (c) 2020 Daybrush
name: selecto
license: MIT
author: Daybrush
repository: git+https://github.com/daybrush/selecto.git
version: 1.15.0
*/











/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function getClient(e) {
  if ("touches" in e) {
    var touch = e.touches[0] || e.changedTouches[0];
    return {
      clientX: touch.clientX,
      clientY: touch.clientY
    };
  } else {
    return {
      clientX: e.clientX,
      clientY: e.clientY
    };
  }
}
function createElement(jsx, prevTarget, container) {
  var tag = jsx.tag,
      children = jsx.children,
      attributes = jsx.attributes,
      className = jsx.className,
      style = jsx.style;
  var el = prevTarget || document.createElement(tag);

  for (var name in attributes) {
    el.setAttribute(name, attributes[name]);
  }

  var elChildren = el.children;
  children.forEach(function (child, i) {
    createElement(child, elChildren[i], el);
  });

  if (className) {
    className.split(" ").forEach(function (name) {
      if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(el, name)) {
        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addClass)(el, name);
      }
    });
  }

  if (style) {
    var elStyle = el.style;

    for (var name in style) {
      elStyle[name] = style[name];
    }
  }

  if (!prevTarget && container) {
    container.appendChild(el);
  }

  return el;
}
function h(tag, attrs) {
  var children = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }

  var _a = attrs || {},
      _b = _a.className,
      className = _b === void 0 ? "" : _b,
      _c = _a.style,
      style = _c === void 0 ? {} : _c,
      attributes = __rest(_a, ["className", "style"]);

  return {
    tag: tag,
    className: className,
    style: style,
    attributes: attributes,
    children: children
  };
}
function diffValue(prev, cur, func) {
  if (prev !== cur) {
    func(prev, cur);
  }
}
function getRect(e, ratio, boundArea) {
  var _a;

  if (boundArea === void 0) {
    boundArea = e.datas.boundArea;
  }

  var _b = e.distX,
      distX = _b === void 0 ? 0 : _b,
      _c = e.distY,
      distY = _c === void 0 ? 0 : _c;
  var _d = e.datas,
      startX = _d.startX,
      startY = _d.startY;

  if (ratio > 0) {
    var nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));
    var nextWidth = ratio * nextHeight;
    distX = (distX >= 0 ? 1 : -1) * nextWidth;
    distY = (distY >= 0 ? 1 : -1) * nextHeight;
  }

  var width = Math.abs(distX);
  var height = Math.abs(distY);
  var maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;
  var maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;
  _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.calculateBoundSize)([width, height], [0, 0], [maxWidth, maxHeight], !!ratio), width = _a[0], height = _a[1];
  distX = (distX >= 0 ? 1 : -1) * width;
  distY = (distY >= 0 ? 1 : -1) * height;
  var tx = Math.min(0, distX);
  var ty = Math.min(0, distY);
  var left = startX + tx;
  var top = startY + ty;
  return {
    left: left,
    top: top,
    right: left + width,
    bottom: top + height,
    width: width,
    height: height
  };
}
function getDefaultElementRect(el) {
  var rect = el.getBoundingClientRect();
  var left = rect.left,
      top = rect.top,
      width = rect.width,
      height = rect.height;
  return {
    pos1: [left, top],
    pos2: [left + width, top],
    pos3: [left, top + height],
    pos4: [left + width, top + height]
  };
}
function passTargets(beforeTargets, afterTargets) {
  var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(beforeTargets, afterTargets),
      list = _a.list,
      prevList = _a.prevList,
      added = _a.added,
      removed = _a.removed;

  return added.map(function (index) {
    return list[index];
  }).concat(removed.map(function (index) {
    return prevList[index];
  }));
}

var injector = (0,css_styled__WEBPACK_IMPORTED_MODULE_2__["default"])("\n:host {\n    position: fixed;\n    display: none;\n    border: 1px solid #4af;\n    background: rgba(68, 170, 255, 0.5);\n    z-index: 100;\n}\n:host {\n    position: absolute;\n}\n");
/**
 * @memberof Selecto
 */

var CLASS_NAME = "selecto-selection " + injector.className;
var PROPERTIES = ["boundContainer", "selectableTargets", "selectByClick", "selectFromInside", "continueSelect", "toggleContinueSelect", "keyContainer", "hitRate", "scrollOptions", "checkInput", "preventDefault", "ratio", "getElementRect", "preventDragFromInside", "rootContainer", "dragCondition", "clickBySelectEnd"];
/**
 * @memberof Selecto
 */

var OPTIONS = __spreadArrays([// ignore target, container,
"dragContainer", "cspNonce"], PROPERTIES);
var OPTION_TYPES = {
  boundContainer: null,
  portalContainer: null,
  container: null,
  dragContainer: null,
  selectableTargets: Array,
  selectByClick: Boolean,
  selectFromInside: Boolean,
  continueSelect: Boolean,
  toggleContinueSelect: Array,
  keyContainer: null,
  hitRate: Number,
  scrollOptions: Object,
  checkInput: Boolean,
  preventDefault: Boolean,
  cspNonce: String,
  ratio: Number,
  getElementRect: Function,
  preventDragFromInside: Boolean,
  rootContainer: Object,
  dragCondition: Function,
  clickBySelectEnd: Boolean
};
/**
 * @memberof Selecto
 */

var EVENTS = ["dragStart", "drag", "dragEnd", "selectStart", "select", "selectEnd", "keydown", "keyup", "scroll"];
/**
 * @memberof Selecto
 */

var METHODS = ["clickTarget", "getSelectableElements", "setSelectedTargets", "getElementPoints", "getSelectedTargets", "findSelectableTargets", "triggerDragStart", "checkScroll"];

/**
 * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.
 * @sort 1
 * @extends EventEmitter
 */

var Selecto =
/*#__PURE__*/
function (_super) {
  __extends(Selecto, _super);
  /**
   *
   */


  function Selecto(options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.selectedTargets = [];
    _this.dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__["default"]();

    _this._onDragStart = function (e, clickedTarget) {
      var datas = e.datas,
          clientX = e.clientX,
          clientY = e.clientY,
          inputEvent = e.inputEvent;
      var _a = _this.options,
          continueSelect = _a.continueSelect,
          selectFromInside = _a.selectFromInside,
          selectByClick = _a.selectByClick,
          rootContainer = _a.rootContainer,
          boundContainer = _a.boundContainer,
          _b = _a.preventDragFromInside,
          preventDragFromInside = _b === void 0 ? true : _b,
          clickBySelectEnd = _a.clickBySelectEnd,
          dragCondition = _a.dragCondition;

      if (dragCondition && !dragCondition(e)) {
        e.stop();
        return;
      }

      _this.findSelectableTargets(datas);

      datas.startSelectedTargets = _this.selectedTargets;
      datas.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.createMatrix)();
      datas.containerX = 0;
      datas.containerY = 0;
      var boundArea = {
        left: -Infinity,
        top: -Infinity,
        right: Infinity,
        bottom: Infinity
      };

      if (rootContainer) {
        var containerRect = _this.container.getBoundingClientRect();

        datas.containerX = containerRect.left;
        datas.containerY = containerRect.top;
        datas.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.getDistElementMatrix)(_this.container, rootContainer);
      }

      if (boundContainer) {
        var boundInfo = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(boundContainer) && "element" in boundContainer ? __assign({
          left: true,
          top: true,
          bottom: true,
          right: true
        }, boundContainer) : {
          element: boundContainer,
          left: true,
          top: true,
          bottom: true,
          right: true
        };
        var boundElement = boundInfo.element;
        var rectElement = void 0;

        if (boundElement) {
          if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(boundElement)) {
            rectElement = document.querySelector(boundElement);
          } else if (boundElement === true) {
            rectElement = _this.container;
          } else {
            rectElement = boundElement;
          }

          var rect = rectElement.getBoundingClientRect();

          if (boundInfo.left) {
            boundArea.left = rect.left;
          }

          if (boundInfo.top) {
            boundArea.top = rect.top;
          }

          if (boundInfo.right) {
            boundArea.right = rect.right;
          }

          if (boundInfo.bottom) {
            boundArea.bottom = rect.bottom;
          }
        }
      }

      datas.boundArea = boundArea;
      var hitRect = {
        left: clientX,
        top: clientY,
        right: clientX,
        bottom: clientY,
        width: 0,
        height: 0
      };
      var firstPassedTargets = [];

      if (selectByClick && !clickBySelectEnd) {
        var pointTarget = _this._findElement(clickedTarget || document.elementFromPoint(clientX, clientY), datas.selectableTargets);

        firstPassedTargets = pointTarget ? [pointTarget] : [];
      }

      var hasInsideTargets = firstPassedTargets.length > 0;
      var isPreventSelect = !selectFromInside && hasInsideTargets; // prevent drag from inside when selectByClick is false

      if (isPreventSelect && !selectByClick) {
        e.stop();
        return false;
      }

      var type = inputEvent.type;
      var isTrusted = type === "mousedown" || type === "touchstart";
      /**
       * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.
       * Call the stop () function if you have a specific element or don't want to raise a select
       * @memberof Selecto
       * @event dragStart
       * @param {OnDragStart} - Parameters for the dragStart event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("dragStart", e => {
       *   if (e.inputEvent.target.tagName === "SPAN") {
       *     e.stop();
       *   }
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      var result = !e.isClick && isTrusted ? _this.emit("dragStart", __assign({}, e)) : true;

      if (!result) {
        e.stop();
        return false;
      }

      if (!continueSelect) {
        datas.startPassedTargets = [];
      } else {
        firstPassedTargets = passTargets(_this.selectedTargets, firstPassedTargets);
        datas.startPassedTargets = _this.selectedTargets;
      }

      _this.select(_this.selectedTargets, firstPassedTargets, hitRect, inputEvent, true);

      datas.startX = clientX;
      datas.startY = clientY;
      datas.selectFlag = false;
      datas.preventDragFromInside = false;
      var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(datas.scaleMatrix, [clientX - datas.containerX, clientY - datas.containerY]);
      datas.boundsArea = _this.target.style.cssText += "position: " + (rootContainer ? "absolute" : "fixed") + ";" + "left:0px;top:0px;" + ("transform: translate(" + offsetPos[0] + "px, " + offsetPos[1] + "px)");

      if (isPreventSelect && selectByClick && !clickBySelectEnd) {
        inputEvent.preventDefault(); // prevent drag from inside when selectByClick is true and force call `selectEnd`

        if (preventDragFromInside) {
          _this.selectEnd(datas.startSelectedTargets, datas.startPassedTargets, hitRect, e);

          datas.preventDragFromInside = true;
        }
      } else {
        datas.selectFlag = true;

        if (type === "touchstart") {
          inputEvent.preventDefault();
        }

        var scrollOptions = _this.options.scrollOptions;

        if (scrollOptions && scrollOptions.container) {
          _this.dragScroll.dragStart(e, scrollOptions);
        }

        if (clickBySelectEnd) {
          datas.selectFlag = false;
          e.preventDrag();
        }
      }

      return true;
    };

    _this._onDrag = function (e) {
      var _a;

      if (e.datas.selectFlag) {
        var scrollOptions = _this.scrollOptions; // If it is a scrolling position, pass drag

        if (((_a = scrollOptions) === null || _a === void 0 ? void 0 : _a.container) && _this.dragScroll.drag(e, scrollOptions)) {
          return;
        }
      }

      _this._checkSelected(e);
    };

    _this._onDragEnd = function (e) {
      var datas = e.datas,
          inputEvent = e.inputEvent;
      var rect = getRect(e, _this.options.ratio);
      var selectFlag = datas.selectFlag;
      /**
       * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.
       * @memberof Selecto
       * @event dragEnd
       * @param {_OnDragEnd} - Parameters for the dragEnd event
       */

      if (inputEvent && !e.isClick) {
        _this.emit("dragEnd", __assign(__assign({
          isDouble: !!e.isDouble,
          isDrag: false,
          isSelect: selectFlag
        }, e), {
          isClick: !!e.isClick,
          rect: rect
        }));
      }

      _this.target.style.cssText += "display: none;";

      if (selectFlag) {
        datas.selectFlag = false;

        _this.dragScroll.dragEnd();
      } else if (_this.selectByClick && _this.clickBySelectEnd) {
        // only clickBySelectEnd
        var pointTarget = _this._findElement(document.elementFromPoint(e.clientX, e.clientY), datas.selectableTargets);

        _this.select(_this.selectedTargets, pointTarget ? [pointTarget] : [], rect, inputEvent);
      }

      if (!datas.preventDragFromInside) {
        _this.selectEnd(datas.startSelectedTargets, datas.startPassedTargets, rect, e);
      }
    };

    _this._onKeyDown = function (e) {
      if (!_this._sameCombiKey(e)) {
        return;
      }

      _this.continueSelect = true;
      /**
       * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.
       * @memberof Selecto
       * @event keydown
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   toggleContinueSelect: "shift";
       *   keyContainer: window,
       * });
       *
       * selecto.on("keydown", () => {
       *   document.querySelector(".button").classList.add("selected");
       * }).on("keyup", () => {
       *   document.querySelector(".button").classList.remove("selected");
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      _this.emit("keydown", {});
    };

    _this._onKeyUp = function (e) {
      if (!_this._sameCombiKey(e, true)) {
        return;
      }

      _this.continueSelect = false;
      /**
       * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.
       * @memberof Selecto
       * @event keyup
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   toggleContinueSelect: "shift";
       *   keyContainer: window,
       * });
       *
       * selecto.on("keydown", () => {
       *   document.querySelector(".button").classList.add("selected");
       * }).on("keyup", () => {
       *   document.querySelector(".button").classList.remove("selected");
       * }).on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */

      _this.emit("keyup", {});
    };

    _this._onBlur = function () {
      if (_this.toggleContinueSelect && _this.continueSelect) {
        _this.continueSelect = false;

        _this.emit("keyup", {});
      }
    };

    _this._onDocumentSelectStart = function (e) {
      if (!_this.gesto.isFlag()) {
        return;
      }

      var dragContainer = _this.dragContainer;

      if (dragContainer === window) {
        dragContainer = document.documentElement;
      }

      var containers = dragContainer instanceof Element ? [dragContainer] : [].slice.call(dragContainer);
      var target = e.target;
      containers.some(function (container) {
        if (container === target || container.contains(target)) {
          e.preventDefault();
          return true;
        }
      });
    };

    _this.target = options.portalContainer;
    _this.container = options.container || document.body;
    _this.options = __assign({
      portalContainer: null,
      container: null,
      dragContainer: null,
      selectableTargets: [],
      selectByClick: true,
      selectFromInside: true,
      clickBySelectEnd: false,
      hitRate: 100,
      continueSelect: false,
      toggleContinueSelect: null,
      keyContainer: null,
      scrollOptions: undefined,
      checkInput: false,
      preventDefault: false,
      boundContainer: false,
      preventDragFromInside: true,
      dragCondition: null,
      rootContainer: null,
      getElementRect: getDefaultElementRect,
      cspNonce: "",
      ratio: 0
    }, options);

    _this.initElement();

    _this.initDragScroll();

    _this.setKeyController();

    return _this;
  }
  /**
   * You can set the currently selected targets.
   *
   */


  var __proto = Selecto.prototype;

  __proto.setSelectedTargets = function (selectedTargets) {
    this.selectedTargets = selectedTargets;
    return this;
  };
  /**
   * You can get the currently selected targets.
   */


  __proto.getSelectedTargets = function () {
    return this.selectedTargets;
  };

  __proto.setKeyContainer = function (keyContainer) {
    var _this = this;

    var options = this.options;
    diffValue(options.keyContainer, keyContainer, function () {
      options.keyContainer = keyContainer;

      _this.setKeyController();
    });
  };

  __proto.setToggleContinueSelect = function (toggleContinueSelect) {
    var _this = this;

    var options = this.options;
    diffValue(options.toggleContinueSelect, toggleContinueSelect, function () {
      options.toggleContinueSelect = toggleContinueSelect;

      _this.setKeyEvent();
    });
  };

  __proto.setPreventDefault = function (value) {
    this.gesto.options.preventDefault = value;
  };

  __proto.setCheckInput = function (value) {
    this.gesto.options.checkInput = value;
  };
  /**
   * `OnDragStart` is triggered by an external event.
   * @param - external event
   * @example
   * import Selecto from "selecto";
   *
   * const selecto = new Selecto();
   *
   * window.addEventListener("mousedown", e => {
   *   selecto.triggerDragStart(e);
   * });
   */


  __proto.triggerDragStart = function (e) {
    this.gesto.triggerDragStart(e);
    return this;
  };
  /**
   * Destroy elements, properties, and events.
   */


  __proto.destroy = function () {
    this.off();
    this.keycon && this.keycon.destroy();
    this.gesto.unset();
    this.injectResult.destroy();
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(document, "selectstart", this._onDocumentSelectStart);
    this.keycon = null;
    this.gesto = null;
    this.injectResult = null;
    this.target = null;
    this.container = null;
    this.options = null;
  };

  __proto.getElementPoints = function (target) {
    var getElementRect = this.getElementRect || getDefaultElementRect;
    var info = getElementRect(target);
    var points = [info.pos1, info.pos2, info.pos4, info.pos3];

    if (getElementRect !== getDefaultElementRect) {
      var rect = target.getBoundingClientRect();
      return (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)(points, rect);
    }

    return points;
  };
  /**
   * Get all elements set in `selectableTargets`.
   */


  __proto.getSelectableElements = function () {
    var selectableElements = [];
    this.options.selectableTargets.forEach(function (target) {
      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        selectableElements.push(target);
      } else {
        var elements = [].slice.call(document.querySelectorAll(target));
        elements.forEach(function (el) {
          selectableElements.push(el);
        });
      }
    });
    return selectableElements;
  };
  /**
   * If scroll occurs during dragging, you can manually call this method to check the position again.
   */


  __proto.checkScroll = function () {
    var _a;

    if (!this.gesto.isFlag()) {
      return;
    }

    var scrollOptions = this.scrollOptions; // If it is a scrolling position, pass drag

    ((_a = scrollOptions) === null || _a === void 0 ? void 0 : _a.container) && this.dragScroll.checkScroll(__assign({
      inputEvent: this.gesto.getCurrentEvent()
    }, scrollOptions));
  };
  /**
   * Find for selectableTargets again during drag event
   */


  __proto.findSelectableTargets = function (datas) {
    var _this = this;

    if (datas === void 0) {
      datas = this.gesto.getEventDatas();
    }

    var selectableTargets = this.getSelectableElements();
    var selectablePoints = selectableTargets.map(function (target) {
      return _this.getElementPoints(target);
    });
    datas.selectableTargets = selectableTargets;
    datas.selectablePoints = selectablePoints;
  };
  /**
   * External click or mouse events can be applied to the selecto.
   * @params - Extenal click or mouse event
   * @params - Specify the clicked target directly.
   */


  __proto.clickTarget = function (e, clickedTarget) {
    var _a = getClient(e),
        clientX = _a.clientX,
        clientY = _a.clientY;

    var dragEvent = {
      datas: {
        selectFlag: false
      },
      clientX: clientX,
      clientY: clientY,
      inputEvent: e,
      isClick: true,
      stop: function () {
        return false;
      }
    };

    if (this._onDragStart(dragEvent, clickedTarget)) {
      this._onDragEnd(dragEvent);
    }

    return this;
  };

  __proto.setKeyController = function () {
    var _a = this.options,
        keyContainer = _a.keyContainer,
        toggleContinueSelect = _a.toggleContinueSelect;

    if (this.keycon) {
      this.keycon.destroy();
      this.keycon = null;
    }

    if (toggleContinueSelect) {
      this.keycon = new keycon__WEBPACK_IMPORTED_MODULE_6__["default"](keyContainer || window);
      this.keycon.keydown(this._onKeyDown).keyup(this._onKeyUp).on("blur", this._onBlur);
    }
  };

  __proto.setKeyEvent = function () {
    var toggleContinueSelect = this.options.toggleContinueSelect;

    if (!toggleContinueSelect || this.keycon) {
      return;
    }

    this.setKeyController();
  };

  __proto.initElement = function () {
    this.target = createElement(h("div", {
      className: CLASS_NAME
    }), this.target, this.container);
    var target = this.target;
    var _a = this.options,
        dragContainer = _a.dragContainer,
        checkInput = _a.checkInput,
        preventDefault = _a.preventDefault;
    this.dragContainer = typeof dragContainer === "string" ? [].slice.call(document.querySelectorAll(dragContainer)) : dragContainer || this.target.parentNode;
    this.gesto = new gesto__WEBPACK_IMPORTED_MODULE_7__["default"](this.dragContainer, {
      checkWindowBlur: true,
      container: window,
      checkInput: checkInput,
      preventDefault: preventDefault
    }).on({
      dragStart: this._onDragStart,
      drag: this._onDrag,
      dragEnd: this._onDragEnd
    });
    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(document, "selectstart", this._onDocumentSelectStart);
    this.injectResult = injector.inject(target, {
      nonce: this.options.cspNonce
    });
  };

  __proto.hitTest = function (selectRect, clientX, clientY, targets, selectablePoints) {
    var _a = this.options,
        hitRate = _a.hitRate,
        selectByClick = _a.selectByClick;
    var left = selectRect.left,
        top = selectRect.top,
        right = selectRect.right,
        bottom = selectRect.bottom;
    var rectPoints = [[left, top], [right, top], [right, bottom], [left, bottom]];
    return targets.filter(function (_, i) {
      var points = selectablePoints[i];
      var inArea = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.isInside)([clientX, clientY], points);

      if (selectByClick && inArea) {
        return true;
      }

      var overlapPoints = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapPoints)(rectPoints, points);

      if (!overlapPoints.length) {
        return false;
      }

      var overlapSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(overlapPoints);
      var targetSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points);
      var hitRateValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)("" + hitRate);

      if (hitRateValue.unit === "px") {
        return overlapSize >= hitRateValue.value;
      } else {
        var rate = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.between)(Math.round(overlapSize / targetSize * 100), 0, 100);
        return rate >= Math.min(100, hitRateValue.value);
      }
    });
  };

  __proto.initDragScroll = function () {
    var _this = this;

    this.dragScroll.on("scroll", function (_a) {
      var container = _a.container,
          direction = _a.direction;

      _this.emit("scroll", {
        container: container,
        direction: direction
      });
    }).on("move", function (_a) {
      var offsetX = _a.offsetX,
          offsetY = _a.offsetY,
          inputEvent = _a.inputEvent;
      var gesto = _this.gesto;

      if (!gesto || !gesto.isFlag()) {
        return;
      }

      var datas = _this.gesto.getEventDatas();

      var boundArea = datas.boundArea;
      datas.startX -= offsetX;
      datas.startY -= offsetY;
      datas.selectablePoints.forEach(function (points) {
        points.forEach(function (pos) {
          pos[0] -= offsetX;
          pos[1] -= offsetY;
        });
      });
      boundArea.left -= offsetX;
      boundArea.right -= offsetX;
      boundArea.top -= offsetY;
      boundArea.bottom -= offsetY;

      _this.gesto.scrollBy(offsetX, offsetY, inputEvent.inputEvent, false);

      _this._checkSelected(_this.gesto.getCurrentEvent());
    });
  };

  __proto.select = function (prevSelectedTargets, selectedTargets, rect, inputEvent, isStart) {
    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(prevSelectedTargets, selectedTargets),
        added = _a.added,
        removed = _a.removed,
        prevList = _a.prevList,
        list = _a.list;

    this.selectedTargets = selectedTargets;

    if (isStart) {
      /**
       * When the select(drag) starts, the selectStart event is called.
       * @memberof Selecto
       * @event selectStart
       * @param {Selecto.OnSelect} - Parameters for the selectStart event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("selectStart", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * }).on("selectEnd", e => {
       *   e.afterAdded.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.afterRemoved.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */
      this.emit("selectStart", {
        selected: selectedTargets,
        added: added.map(function (index) {
          return list[index];
        }),
        removed: removed.map(function (index) {
          return prevList[index];
        }),
        rect: rect,
        inputEvent: inputEvent
      });
    }

    if (added.length || removed.length) {
      /**
       * When the select in real time, the select event is called.
       * @memberof Selecto
       * @event select
       * @param {Selecto.OnSelect} - Parameters for the select event
       * @example
       * import Selecto from "selecto";
       *
       * const selecto = new Selecto({
       *   container: document.body,
       *   selectByClick: true,
       *   selectFromInside: false,
       * });
       *
       * selecto.on("select", e => {
       *   e.added.forEach(el => {
       *     el.classList.add("selected");
       *   });
       *   e.removed.forEach(el => {
       *     el.classList.remove("selected");
       *   });
       * });
       */
      this.emit("select", {
        selected: selectedTargets,
        added: added.map(function (index) {
          return list[index];
        }),
        removed: removed.map(function (index) {
          return prevList[index];
        }),
        rect: rect,
        inputEvent: inputEvent
      });
    }
  };

  __proto.selectEnd = function (startSelectedTargets, startPassedTargets, rect, e) {
    var inputEvent = e.inputEvent,
        isDouble = e.isDouble;

    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startSelectedTargets, this.selectedTargets),
        added = _a.added,
        removed = _a.removed,
        prevList = _a.prevList,
        list = _a.list;

    var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startPassedTargets, this.selectedTargets),
        afterAdded = _b.added,
        afterRemoved = _b.removed,
        afterPrevList = _b.prevList,
        afterList = _b.list;

    var type = inputEvent && inputEvent.type;
    var isDragStart = type === "mousedown" || type === "touchstart";
    /**
     * When the select(dragEnd or click) ends, the selectEnd event is called.
     * @memberof Selecto
     * @event selectEnd
     * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event
     * @example
     * import Selecto from "selecto";
     *
     * const selecto = new Selecto({
     *   container: document.body,
     *   selectByClick: true,
     *   selectFromInside: false,
     * });
     *
     * selecto.on("selectStart", e => {
     *   e.added.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.removed.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * }).on("selectEnd", e => {
     *   e.afterAdded.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.afterRemoved.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * });
     */

    this.emit("selectEnd", {
      selected: this.selectedTargets,
      added: added.map(function (index) {
        return list[index];
      }),
      removed: removed.map(function (index) {
        return prevList[index];
      }),
      afterAdded: afterAdded.map(function (index) {
        return afterList[index];
      }),
      afterRemoved: afterRemoved.map(function (index) {
        return afterPrevList[index];
      }),
      isDragStart: isDragStart,
      isClick: !!e.isClick,
      isDouble: !!isDouble,
      rect: rect,
      inputEvent: inputEvent
    });
  };

  __proto._checkSelected = function (e, rect) {
    if (rect === void 0) {
      rect = getRect(e, this.options.ratio);
    }

    var datas = e.datas,
        inputEvent = e.inputEvent;
    var top = rect.top,
        left = rect.left,
        width = rect.width,
        height = rect.height;
    var selectFlag = datas.selectFlag;
    var containerX = datas.containerX,
        containerY = datas.containerY,
        scaleMatrix = datas.scaleMatrix;
    var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [left - containerX, top - containerY]);
    var offsetSize = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [width, height]);
    var prevSelectedTargets = [];
    var selectedTargets = [];

    if (selectFlag) {
      this.target.style.cssText += "display: block;" + "left:0px;top:0px;pointer-events: none;" + ("transform: translate(" + offsetPos[0] + "px, " + offsetPos[1] + "px);") + ("width:" + offsetSize[0] + "px;height:" + offsetSize[1] + "px;");
      var passedTargets = this.hitTest(rect, datas.startX, datas.startY, datas.selectableTargets, datas.selectablePoints);
      prevSelectedTargets = this.selectedTargets;
      selectedTargets = passTargets(datas.startPassedTargets, passedTargets);
      this.selectedTargets = selectedTargets;
    }
    /**
     * When the drag, the drag event is called.
     * Call the stop () function if you have a specific element or don't want to raise a select
     * @memberof Selecto
     * @event drag
     * @param {OnDrag} - Parameters for the drag event
     * @example
     * import Selecto from "selecto";
     *
     * const selecto = new Selecto({
     *   container: document.body,
     *   selectByClick: true,
     *   selectFromInside: false,
     * });
     *
     * selecto.on("drag", e => {
     *   e.stop();
     * }).on("select", e => {
     *   e.added.forEach(el => {
     *     el.classList.add("selected");
     *   });
     *   e.removed.forEach(el => {
     *     el.classList.remove("selected");
     *   });
     * });
     */


    var result = this.emit("drag", __assign(__assign({}, e), {
      isSelect: selectFlag,
      rect: rect
    }));

    if (result === false) {
      this.target.style.cssText += "display: none;";
      e.stop();
      return;
    }

    if (selectFlag) {
      this.select(prevSelectedTargets, selectedTargets, rect, inputEvent);
    }
  };

  __proto._sameCombiKey = function (e, isKeyup) {
    var toggleContinueSelect = [].concat(this.options.toggleContinueSelect);
    var combi = (0,keycon__WEBPACK_IMPORTED_MODULE_6__.getCombi)(e.inputEvent, e.key);
    var toggleKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(toggleContinueSelect[0]) ? toggleContinueSelect : [toggleContinueSelect];

    if (isKeyup) {
      var singleKey_1 = e.key;
      return toggleKeys.some(function (keys) {
        return keys.some(function (key) {
          return key === singleKey_1;
        });
      });
    }

    return toggleKeys.some(function (keys) {
      return keys.every(function (key) {
        return combi.indexOf(key) > -1;
      });
    });
  };

  __proto._findElement = function (clickedTarget, selectableTargets) {
    var pointTarget = clickedTarget;

    while (pointTarget) {
      if (selectableTargets.indexOf(pointTarget) > -1) {
        break;
      }

      pointTarget = pointTarget.parentElement;
    }

    return pointTarget;
  };

  Selecto = __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_8__.Properties)(PROPERTIES, function (prototype, property) {
    var attributes = {
      enumerable: true,
      configurable: true,
      get: function () {
        return this.options[property];
      }
    };
    var setter = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.camelize)("set " + property);

    if (prototype[setter]) {
      attributes.set = function set(value) {
        this[setter](value);
      };
    } else {
      attributes.set = function set(value) {
        this.options[property] = value;
      };
    }

    Object.defineProperty(prototype, property, attributes);
  })], Selecto);
  return Selecto;
}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__["default"]);

var Selecto$1 =
/*#__PURE__*/
function (_super) {
  __extends(Selecto, _super);

  function Selecto() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return Selecto;
}(Selecto);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Selecto$1);

//# sourceMappingURL=selecto.esm.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG9EQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBUTtBQUNwQztBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtB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SUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7OztBQUd2QztBQUNBLCtGQUErRjs7QUFFL0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLG9EQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1B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QUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFEQUFVO0FBQy9CO0FBQ0E7O0FBRUEscUJBQXFCLHFEQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx5REFBUTtBQUNyQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsa0RBQWtEO0FBQ3ZIO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBLGdFQUFnRSxrREFBa0Q7QUFDbEg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFDQUFxQyxFQUFFO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1REFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBUztBQUM5QixzQkFBc0Isd0RBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsd0RBQVMsZUFBZSx3REFBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdFQUFlO0FBQzVCLEtBQUs7QUFDTCxhQUFhLGdFQUFlO0FBQzVCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcs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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG9EQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsbURBQUk7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsbUNBQW1DLG1FQUFvQixrQkFBa0IsbUVBQW9CO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGlFQUFrQjtBQUN0RztBQUNBLDRFQUE0RSwyREFBVTtBQUN0RixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3REFBTywwQkFBMEIsMkRBQVU7QUFDN0UsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKLHlEQUFRLGtDQUFrQyx5REFBUTtBQUNuTTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkNBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw0REFBVztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLHFFQUFvQjtBQUMxQiwwQkFBMEIsc0VBQXFCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsa0VBQWE7QUFDeEI7QUFDQSxXQUFXLG9EQUFHO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixvRUFBTTtBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVztBQUNYO0FBQ0EsU0FBUyw4Q0FBOEM7O0FBRXZEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxREFBcUQ7QUFDckQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxDQUFDO0FBQ0Q7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQyxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxLQUFLLEVBQUM7QUFDTztBQUM1Qjs7Ozs7Ozs7Ozs7Ozs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRDs7QUFFL0Q7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLENBQUMseURBQVU7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHVEQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxjQUFjLEVBQUM7QUFDZDtBQUNoQjs7Ozs7Ozs7Ozs7OztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsVUFBVSxFQUFDO0FBQ1Y7QUFDaEI7Ozs7Ozs7Ozs7Ozs7O0FDalpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDVjs7QUFFdEM7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9EQUFHO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDLENBQUMsNERBQVk7O0FBRWQsaUVBQWUsVUFBVSxFQUFDO0FBQzFCOzs7Ozs7Ozs7Ozs7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFROztBQUV4RCx1Q0FBdUMsUUFBUSxzREFBc0QsUUFBUTs7QUFFN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHdEQUFPO0FBQ2xCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFZ1k7QUFDaFk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkY7QUFDd0I7O0FBRW5IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHVEQUFROztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLHFEQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQU8sMEJBQTBCLDJEQUFVO0FBQzlEO0FBQ0EsYUFBYSw2REFBWTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsMkRBQVU7QUFDekI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsc0RBQVc7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUIsc0RBQVc7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUIsc0RBQVc7QUFDbEM7QUFDQSxNQUFNO0FBQ04sZUFBZSwyREFBVTtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixrREFBTztBQUM5QjtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1QixrREFBTztBQUM5QjtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1QixrREFBTztBQUM5QjtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1QixrREFBTztBQUM5QjtBQUNBLE1BQU07QUFDTixlQUFlLDBEQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixvREFBUztBQUNsQyxRQUFRO0FBQ1IseUJBQXlCLG9EQUFTO0FBQ2xDLFFBQVE7QUFDUix5QkFBeUIsb0RBQVM7QUFDbEM7O0FBRUE7QUFDQSxNQUFNO0FBQ04sdUJBQXVCLG1EQUFRO0FBQy9CLHNCQUFzQiwyREFBVTtBQUNoQztBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sY0FBYywyREFBVTtBQUN4QjtBQUNBLE9BQU87QUFDUCx1QkFBdUIsbURBQVE7QUFDL0I7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFNkc7QUFDN0c7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQixtQ0FBbUMsc0NBQXNDO0FBQ3pFLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVzRTtBQUN0RTs7Ozs7Ozs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNhOztBQUU3RDtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLG9EQUFHOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUMsQ0FBQyw0REFBWTs7QUFFZCxpRUFBZSxLQUFLLEVBQUM7QUFDckI7Ozs7Ozs7Ozs7Ozs7OztBQzd5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxRQUFROztBQUVoQixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBUTs7QUFFaEIscUJBQXFCO0FB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TTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLFNBQVMsUUFBUSxZQUFZO0FBQy9DLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTyxTQUFTLFFBQVEsWUFBWTtBQUMvQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTOztBQUV0QjtBQUNBLGlCQUFpQixRQUFROztBQUV6QjtBQUNBLFlBQVksUUFBUTs7QUFFcEI7QUFDQSxZQUFZLFFBQVE7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELGlFQUFlLGFBQWEsRUFBQztBQUNpQjtBQUM5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2g0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRDtBQUNtQztBQUNpRztBQUM3Rzs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsaUVBQVksQ0FBQyxrRUFBYSxDQUFDLDZEQUFVO0FBQ2hELFdBQVcsb0RBQUc7QUFDZCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDLENBQUMsMERBQVM7O0FBRVgsaUJBQWlCLGlFQUFjO0FBQy9CLGNBQWMsbUVBQWdCO0FBQzlCLGFBQWEsa0VBQWU7QUFDNUIsZ0JBQWdCLHFFQUFrQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTs7QUFFeEQsdUNBQXVDLFFBQVEsc0RBQXNELFFBQVE7O0FBRTdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTjs7O0FBR0E7O0FBRUE7QUFDQSxRQUFRLHlEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLHlEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLG9CQUFvQiwwREFBUztBQUM3QjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7O0FBRVg7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTs7QUFFWDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IOztBQUVuSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsdURBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBUTtBQUNsQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNB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QUMxRSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2NvcmUvY29tcG9uZW50cy9MYXllcnMvQWRkTGF5ZXJCdXR0b24udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2NvcmUvY29tcG9uZW50cy9MYXllcnMvTGF5ZXJEcmFnRHJvcExpc3QudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2NvcmUvY29tcG9uZW50cy9MYXllcnMvTGF5ZXJOYW1lLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvYnV0dG9uLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvZHJvbmVGcm9udC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL2Ryb25lU2lkZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL2Ryb25lVG9wLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvaWNvbi50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL25vdEZvdW5kLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvdGV4dEJveC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL3dpbmRUdXJiaW5lLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL3JlZ2lzdHJ5LnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2VsZW1lbnQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2dyb3VwLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9yb290LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9zY2VuZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvZmVhdHVyZXMvY2FudmFzL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL0NhbnZhc1BhbmVsLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3IvQVBJRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy9lZGl0b3IvTGF5ZXJFbGVtZW50TGlzdEVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvZWRpdG9yL1BsYWNlbWVudEVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvZWRpdG9yL2VsZW1lbnRFZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL2VkaXRvci9sYXllckVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvZWRpdG9yL29wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvbW9kdWxlLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL3BhbmVsL2NhbnZhcy90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vY3NzLXN0eWxlZC12aXJ0dWFsLTllZjhmMDVkZTIvMC9jYWNoZS9jc3Mtc3R5bGVkLW5wbS0xLjAuMC01MTA0YTg4MmQ1LTNmMmY5OTU5MzguemlwL25vZGVfbW9kdWxlcy9jc3Mtc3R5bGVkL2Rpc3Qvc3R5bGVkLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtY29tcGF0LW1vdmVhYmxlLXZpcnR1YWwtODFiN2E0MmFiYi8wL2NhY2hlL3JlYWN0LWNvbXBhdC1tb3ZlYWJsZS1ucG0tMC4xNi4wLTM5NWIzYzkyZTktYjIwYmQ5MTY5OC56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LWNvbXBhdC1tb3ZlYWJsZS9kaXN0L21vdmVhYmxlLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vcmVhY3QtdXNlLXZpcnR1YWwtMDAzMjZlNzBiYS8wL2NhY2hlL3JlYWN0LXVzZS1ucG0tMTcuMy4yLWEwMzJjYmViMDEtNzM3OTQ2MGY1MS56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LXVzZS9lc20vdXNlT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGRheWJydXNoLXV0aWxzLW5wbS0xLjYuMC01NDc0ODZiZjc5LTI1NzliYzE3ZTAuemlwL25vZGVfbW9kdWxlcy9AZGF5YnJ1c2gvdXRpbHMvZGlzdC91dGlscy5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BlZ2pzLWFnZW50LW5wbS0yLjMuMC1lODhjYTBlZWMyLTI1MDZlOGZlZmYuemlwL25vZGVfbW9kdWxlcy9AZWdqcy9hZ2VudC9kaXN0L2FnZW50LmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGVnanMtY2hpbGRyZW4tZGlmZmVyLW5wbS0xLjAuMS0zN2Y0NWRkZjk3LTA4N2YyODY4MjIuemlwL25vZGVfbW9kdWxlcy9AZWdqcy9jaGlsZHJlbi1kaWZmZXIvZGlzdC9jaGlsZHJlbi1kaWZmZXIuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AZWdqcy1saXN0LWRpZmZlci1ucG0tMS4wLjAtZjRiOTE3ODFkYi1kMTgyN2QxMzRkLnppcC9ub2RlX21vZHVsZXMvQGVnanMvbGlzdC1kaWZmZXIvZGlzdC9saXN0LWRpZmZlci5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BzY2VuYS1kcmFnc2Nyb2xsLW5wbS0xLjEuMS04ZmU2MDc3NWY5LWFhY2IzMzU4NzAuemlwL25vZGVfbW9kdWxlcy9Ac2NlbmEvZHJhZ3Njcm9sbC9kaXN0L2RyYWdzY3JvbGwuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9Ac2NlbmEtZXZlbnQtZW1pdHRlci1ucG0tMS4wLjUtN2ViZjM2MWQxNy00MDBlMGY2YWI4LnppcC9ub2RlX21vZHVsZXMvQHNjZW5hL2V2ZW50LWVtaXR0ZXIvZGlzdC9ldmVudC1lbWl0dGVyLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQHNjZW5hLW1hdHJpeC1ucG0tMS4xLjEtZGE5NjRmNmIzYS1lOTZhZWFiNzEyLnppcC9ub2RlX21vZHVsZXMvQHNjZW5hL21hdHJpeC9kaXN0L21hdHJpeC5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2Nzcy10by1tYXQtbnBtLTEuMC4zLThhNjllZDcxZGUtYTNmYzk4YmZhZC56aXAvbm9kZV9tb2R1bGVzL2Nzcy10by1tYXQvZGlzdC9jc3MtdG8tbWF0LmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvZnJhbWV3b3JrLXV0aWxzLW5wbS0xLjEuMC0zN2E1NGEwNjljLTAxYjYxZWFkMTcuemlwL25vZGVfbW9kdWxlcy9mcmFtZXdvcmstdXRpbHMvZGlzdC91dGlscy5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2dlc3RvLW5wbS0xLjcuMC03ZDU0NDAwMDBiLWYyYTY2YmNmMGYuemlwL25vZGVfbW9kdWxlcy9nZXN0by9kaXN0L2dlc3RvLmVzbS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUva2V5Y29uLW5wbS0xLjEuMi00N2JiNTA0OGRmLTdiZTc0YWFmODMuemlwL25vZGVfbW9kdWxlcy9rZXljb24vZGlzdC9rZXljb24uZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9tb3ZlYWJsZS1ucG0tMC4yOC4wLTMyZDA2NjA5NmEtMWZlZTg1YThjNy56aXAvbm9kZV9tb2R1bGVzL21vdmVhYmxlL2Rpc3QvbW92ZWFibGUuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9vdmVybGFwLWFyZWEtbnBtLTEuMC4wLWVjZTVhNGZjNmEtMzdkODJlYTRlYS56aXAvbm9kZV9tb2R1bGVzL292ZXJsYXAtYXJlYS9kaXN0L292ZXJsYXAtYXJlYS5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3JlYWN0LWNvbXBhdC1jc3Mtc3R5bGVkLW5wbS0xLjAuOC01MjIxMWQyNmY4LTdhOGU1MTg0OWUuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1jb21wYXQtY3NzLXN0eWxlZC9kaXN0L3N0eWxlZC5lc20uanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3JlYWN0LXNpbXBsZS1jb21wYXQtbnBtLTEuMi4xLWQzNWRiMDhiYTQtMDdhNDdlNzUwZi56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LXNpbXBsZS1jb21wYXQvZGlzdC9jb21wYXQuZXNtLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9zZWxlY3RvLW5wbS0xLjE1LjAtZWI4NDk1OWRmNS1hZTE5NTEzYzc3LnppcC9ub2RlX21vZHVsZXMvc2VsZWN0by9kaXN0L3NlbGVjdG8uZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFZhbHVlUGlja2VyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbnR5cGUgQWRkTGF5ZXJCdXR0b25Qcm9wcyA9IHtcbiAgb25DaGFuZ2U6IChzZWw6IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+KSA9PiB2b2lkO1xuICBvcHRpb25zOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPj47XG4gIGxhYmVsOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY29uc3QgQWRkTGF5ZXJCdXR0b24gPSAoeyBvbkNoYW5nZSwgb3B0aW9ucywgbGFiZWwgfTogQWRkTGF5ZXJCdXR0b25Qcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxWYWx1ZVBpY2tlclxuICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgbGFiZWw9e2xhYmVsfVxuICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICBvcHRpb25zPXtvcHRpb25zfVxuICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgaXNGdWxsV2lkdGg9e3RydWV9XG4gICAgLz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRHJhZ0Ryb3BDb250ZXh0LCBEcmFnZ2FibGUsIERyb3BwYWJsZSwgRHJvcFJlc3VsdCB9IGZyb20gJ3JlYWN0LWJlYXV0aWZ1bC1kbmQnO1xuaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBJY29uLCBJY29uQnV0dG9uLCBzdHlsZXNGYWN0b3J5IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IHsgTGF5ZXJOYW1lIH0gZnJvbSAnLi9MYXllck5hbWUnO1xuaW1wb3J0IHsgTGF5ZXJFbGVtZW50IH0gZnJvbSAnLi90eXBlcyc7XG5cbnR5cGUgTGF5ZXJEcmFnRHJvcExpc3RQcm9wczxUIGV4dGVuZHMgTGF5ZXJFbGVtZW50PiA9IHtcbiAgbGF5ZXJzOiBUW107XG4gIGdldExheWVySW5mbzogKGVsZW1lbnQ6IFQpID0+IHN0cmluZztcbiAgb25EcmFnRW5kOiAocmVzdWx0OiBEcm9wUmVzdWx0KSA9PiB2b2lkO1xuICBvblNlbGVjdDogKGVsZW1lbnQ6IFQpID0+IGFueTtcbiAgb25EZWxldGU6IChlbGVtZW50OiBUKSA9PiBhbnk7XG4gIG9uRHVwbGljYXRlPzogKGVsZW1lbnQ6IFQpID0+IGFueTtcbiAgaXNHcm91cD86IChlbGVtZW50OiBUKSA9PiBib29sZWFuO1xuICBzZWxlY3Rpb24/OiBzdHJpbmdbXTsgLy8gbGlzdCBvZiB1bmlxdWUgaWRzIChuYW1lcylcbiAgZXhjbHVkZUJhc2VMYXllcj86IGJvb2xlYW47XG4gIG9uTmFtZUNoYW5nZTogKGVsZW1lbnQ6IFQsIG5ld05hbWU6IHN0cmluZykgPT4gYW55O1xuICB2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzPzogKG5hbWVUb0NoZWNrOiBzdHJpbmcpID0+IGJvb2xlYW47XG59O1xuXG5leHBvcnQgY29uc3QgTGF5ZXJEcmFnRHJvcExpc3QgPSA8VCBleHRlbmRzIExheWVyRWxlbWVudD4oe1xuICBsYXllcnMsXG4gIGdldExheWVySW5mbyxcbiAgb25EcmFnRW5kLFxuICBvblNlbGVjdCxcbiAgb25EZWxldGUsXG4gIG9uRHVwbGljYXRlLFxuICBpc0dyb3VwLFxuICBzZWxlY3Rpb24sXG4gIGV4Y2x1ZGVCYXNlTGF5ZXIsXG4gIG9uTmFtZUNoYW5nZSxcbiAgdmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcyxcbn06IExheWVyRHJhZ0Ryb3BMaXN0UHJvcHM8VD4pID0+IHtcbiAgY29uc3Qgc3R5bGUgPSBzdHlsZXMoY29uZmlnLnRoZW1lKTtcblxuICBjb25zdCBnZXRSb3dTdHlsZSA9IChpc1NlbGVjdGVkOiBib29sZWFuKSA9PiB7XG4gICAgcmV0dXJuIGlzU2VsZWN0ZWQgPyBgJHtzdHlsZS5yb3d9ICR7c3R5bGUuc2VsfWAgOiBzdHlsZS5yb3c7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8RHJhZ0Ryb3BDb250ZXh0IG9uRHJhZ0VuZD17b25EcmFnRW5kfT5cbiAgICAgIDxEcm9wcGFibGUgZHJvcHBhYmxlSWQ9XCJkcm9wcGFibGVcIj5cbiAgICAgICAgeyhwcm92aWRlZCwgc25hcHNob3QpID0+IChcbiAgICAgICAgICA8ZGl2IHsuLi5wcm92aWRlZC5kcm9wcGFibGVQcm9wc30gcmVmPXtwcm92aWRlZC5pbm5lclJlZn0+XG4gICAgICAgICAgICB7KCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gcmV2ZXJzZSBvcmRlclxuICAgICAgICAgICAgICBjb25zdCByb3dzOiBhbnkgPSBbXTtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdExheWVySW5kZXggPSBleGNsdWRlQmFzZUxheWVyID8gMSA6IDA7XG4gICAgICAgICAgICAgIGNvbnN0IHNob3VsZFJlbmRlckRyYWdJY29uTGVuZ3RoVGhyZXNob2xkID0gZXhjbHVkZUJhc2VMYXllciA/IDIgOiAxO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gbGFzdExheWVySW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBsYXllcnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdWlkID0gZWxlbWVudC5nZXROYW1lKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gQm9vbGVhbihzZWxlY3Rpb24/LmluY2x1ZGVzKHVpZCkpO1xuICAgICAgICAgICAgICAgIHJvd3MucHVzaChcbiAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGUga2V5PXt1aWR9IGRyYWdnYWJsZUlkPXt1aWR9IGluZGV4PXtyb3dzLmxlbmd0aH0+XG4gICAgICAgICAgICAgICAgICAgIHsocHJvdmlkZWQsIHNuYXBzaG90KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtnZXRSb3dTdHlsZShpc1NlbGVjdGVkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4ucHJvdmlkZWQuZHJhZ2dhYmxlUHJvcHN9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4ucHJvdmlkZWQuZHJhZ0hhbmRsZVByb3BzfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd249eygpID0+IG9uU2VsZWN0KGVsZW1lbnQpfVxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMYXllck5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17dWlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KHYpID0+IG9uTmFtZUNoYW5nZShlbGVtZW50LCB2KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcz17dmVyaWZ5TGF5ZXJOYW1lVW5pcXVlbmVzcyA/PyB1bmRlZmluZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlLnRleHRXcmFwcGVyfT4mbmJzcDsge2dldExheWVySW5mbyhlbGVtZW50KX08L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgeyFpc0dyb3VwIShlbGVtZW50KSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge29uRHVwbGljYXRlID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25CdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImNvcHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17J0R1cGxpY2F0ZSd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGUuYWN0aW9uSWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb25EdXBsaWNhdGUoZWxlbWVudCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cmZhY2U9XCJoZWFkZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIDogbnVsbH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwidHJhc2gtYWx0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXsncmVtb3ZlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3goc3R5bGUuYWN0aW9uSWNvbiwgc3R5bGUuZHJhZ0ljb24pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gb25EZWxldGUoZWxlbWVudCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXJmYWNlPVwiaGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsYXllcnMubGVuZ3RoID4gc2hvdWxkUmVuZGVyRHJhZ0ljb25MZW5ndGhUaHJlc2hvbGQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCJEcmFnIGFuZCBkcm9wIHRvIHJlb3JkZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiZHJhZ2dhYmxlZG90c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU9XCJsZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGUuZHJhZ0ljb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcm93cztcbiAgICAgICAgICAgIH0pKCl9XG5cbiAgICAgICAgICAgIHtwcm92aWRlZC5wbGFjZWhvbGRlcn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvRHJvcHBhYmxlPlxuICAgIDwvRHJhZ0Ryb3BDb250ZXh0PlxuICApO1xufTtcblxuTGF5ZXJEcmFnRHJvcExpc3QuZGVmYXVsdFByb3BzID0ge1xuICBpc0dyb3VwOiAoKSA9PiBmYWxzZSxcbn07XG5cbmNvbnN0IHN0eWxlcyA9IHN0eWxlc0ZhY3RvcnkoKHRoZW1lOiBHcmFmYW5hVGhlbWUpID0+ICh7XG4gIHdyYXBwZXI6IGNzc2BcbiAgICBtYXJnaW4tYm90dG9tOiAke3RoZW1lLnNwYWNpbmcubWR9O1xuICBgLFxuICByb3c6IGNzc2BcbiAgICBwYWRkaW5nOiAke3RoZW1lLnNwYWNpbmcueHN9ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gICAgYm9yZGVyLXJhZGl1czogJHt0aGVtZS5ib3JkZXIucmFkaXVzLnNtfTtcbiAgICBiYWNrZ3JvdW5kOiAke3RoZW1lLmNvbG9ycy5iZzJ9O1xuICAgIG1pbi1oZWlnaHQ6ICR7dGhlbWUuc3BhY2luZy5mb3JtSW5wdXRIZWlnaHR9cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBtYXJnaW4tYm90dG9tOiAzcHg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgYm9yZGVyOiAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuZm9ybUlucHV0Qm9yZGVyfTtcbiAgICAmOmhvdmVyIHtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmZvcm1JbnB1dEJvcmRlckhvdmVyfTtcbiAgICB9XG4gIGAsXG4gIHNlbDogY3NzYFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmZvcm1JbnB1dEJvcmRlckFjdGl2ZX07XG4gICAgJjpob3ZlciB7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5mb3JtSW5wdXRCb3JkZXJBY3RpdmV9O1xuICAgIH1cbiAgYCxcbiAgZHJhZ0ljb246IGNzc2BcbiAgICBjdXJzb3I6IGRyYWc7XG4gIGAsXG4gIGFjdGlvbkljb246IGNzc2BcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMudGV4dFdlYWt9O1xuICAgICY6aG92ZXIge1xuICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHR9O1xuICAgIH1cbiAgYCxcbiAgdHlwZVdyYXBwZXI6IGNzc2BcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMudGV4dEJsdWV9O1xuICAgIG1hcmdpbi1yaWdodDogNXB4O1xuICBgLFxuICB0ZXh0V3JhcHBlcjogY3NzYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmbGV4LWdyb3c6IDE7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBtYXJnaW4tcmlnaHQ6ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gIGAsXG59KSk7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEljb24sIElucHV0LCBGaWVsZFZhbGlkYXRpb25NZXNzYWdlLCB1c2VTdHlsZXMgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuZXhwb3J0IGludGVyZmFjZSBMYXllck5hbWVQcm9wcyB7XG4gIG5hbWU6IHN0cmluZztcbiAgb25DaGFuZ2U6ICh2OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3M/OiAobmFtZVRvQ2hlY2s6IHN0cmluZykgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IExheWVyTmFtZSA9ICh7IG5hbWUsIG9uQ2hhbmdlLCB2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzIH06IExheWVyTmFtZVByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlcyhnZXRTdHlsZXMpO1xuXG4gIGNvbnN0IFtpc0VkaXRpbmcsIHNldElzRWRpdGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFt2YWxpZGF0aW9uRXJyb3IsIHNldFZhbGlkYXRpb25FcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBvbkVkaXRMYXllciA9IChldmVudDogUmVhY3QuU3ludGhldGljRXZlbnQpID0+IHtcbiAgICBzZXRJc0VkaXRpbmcodHJ1ZSk7XG4gIH07XG5cbiAgY29uc3Qgb25FbmRFZGl0TmFtZSA9IChuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBzZXRJc0VkaXRpbmcoZmFsc2UpO1xuXG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgc2V0VmFsaWRhdGlvbkVycm9yKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuYW1lICE9PSBuZXdOYW1lKSB7XG4gICAgICBvbkNoYW5nZShuZXdOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25JbnB1dENoYW5nZSA9IChldmVudDogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBuZXdOYW1lID0gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZS50cmltKCk7XG5cbiAgICBpZiAobmV3TmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldFZhbGlkYXRpb25FcnJvcignQW4gZW1wdHkgbGF5ZXIgbmFtZSBpcyBub3QgYWxsb3dlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzICYmICF2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzKG5ld05hbWUpICYmIG5ld05hbWUgIT09IG5hbWUpIHtcbiAgICAgIHNldFZhbGlkYXRpb25FcnJvcignTGF5ZXIgbmFtZSBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIHNldFZhbGlkYXRpb25FcnJvcihudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25FZGl0TGF5ZXJCbHVyID0gKGV2ZW50OiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIG9uRW5kRWRpdE5hbWUoZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZS50cmltKCkpO1xuICB9O1xuXG4gIGNvbnN0IG9uS2V5RG93biA9IChldmVudDogUmVhY3QuS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIG9uRW5kRWRpdE5hbWUoKGV2ZW50LnRhcmdldCBhcyBhbnkpLnZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25Gb2N1cyA9IChldmVudDogUmVhY3QuRm9jdXNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGV2ZW50LnRhcmdldC5zZWxlY3QoKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9PlxuICAgICAgICB7IWlzRWRpdGluZyAmJiAoXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMubGF5ZXJOYW1lV3JhcHBlcn1cbiAgICAgICAgICAgIHRpdGxlPVwiRWRpdCBsYXllciBuYW1lXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e29uRWRpdExheWVyfVxuICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJsYXllci1uYW1lLWRpdlwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMubGF5ZXJOYW1lfT57bmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8SWNvbiBuYW1lPVwicGVuXCIgY2xhc3NOYW1lPXtzdHlsZXMubGF5ZXJFZGl0SWNvbn0gc2l6ZT1cInNtXCIgLz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKX1cblxuICAgICAgICB7aXNFZGl0aW5nICYmIChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtuYW1lfVxuICAgICAgICAgICAgICBvbkJsdXI9e29uRWRpdExheWVyQmx1cn1cbiAgICAgICAgICAgICAgYXV0b0ZvY3VzXG4gICAgICAgICAgICAgIG9uS2V5RG93bj17b25LZXlEb3dufVxuICAgICAgICAgICAgICBvbkZvY3VzPXtvbkZvY3VzfVxuICAgICAgICAgICAgICBpbnZhbGlkPXt2YWxpZGF0aW9uRXJyb3IgIT09IG51bGx9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbklucHV0Q2hhbmdlfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5sYXllck5hbWVJbnB1dH1cbiAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJsYXllci1uYW1lLWlucHV0XCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7dmFsaWRhdGlvbkVycm9yICYmIDxGaWVsZFZhbGlkYXRpb25NZXNzYWdlIGhvcml6b250YWw+e3ZhbGlkYXRpb25FcnJvcn08L0ZpZWxkVmFsaWRhdGlvbk1lc3NhZ2U+fVxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC8+XG4gICk7XG59O1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZSkgPT4ge1xuICByZXR1cm4ge1xuICAgIHdyYXBwZXI6IGNzc2BcbiAgICAgIGxhYmVsOiBXcmFwcGVyO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5zcGFjaW5nLnhzfTtcbiAgICBgLFxuICAgIGxheWVyTmFtZVdyYXBwZXI6IGNzc2BcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgICAgIGJvcmRlci1yYWRpdXM6ICR7dGhlbWUuYm9yZGVyLnJhZGl1cy5tZH07XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgcGFkZGluZzogMCAwIDAgJHt0aGVtZS5zcGFjaW5nLnhzfTtcbiAgICAgIG1hcmdpbjogMDtcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXG4gICAgICAmOmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZDogJHt0aGVtZS5jb2xvcnMuYmczfTtcbiAgICAgICAgYm9yZGVyOiAxcHggZGFzaGVkICR7dGhlbWUuY29sb3JzLmJvcmRlcjN9O1xuICAgICAgfVxuXG4gICAgICAmOmZvY3VzIHtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgJHt0aGVtZS5jb2xvcnMuZm9ybUlucHV0Qm9yZGVyQWN0aXZlfTtcbiAgICAgIH1cblxuICAgICAgJjpob3ZlcixcbiAgICAgICY6Zm9jdXMge1xuICAgICAgICAucXVlcnktbmFtZS1lZGl0LWljb24ge1xuICAgICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgLFxuICAgIGxheWVyTmFtZTogY3NzYFxuICAgICAgZm9udC13ZWlnaHQ6ICR7dGhlbWUudHlwb2dyYXBoeS53ZWlnaHQuc2VtaWJvbGR9O1xuICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHRCbHVlfTtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5zcGFjaW5nLnhzfTtcbiAgICBgLFxuICAgIGxheWVyRWRpdEljb246IGN4KFxuICAgICAgY3NzYFxuICAgICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5zcGFjaW5nLm1kfTtcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgYCxcbiAgICAgICdxdWVyeS1uYW1lLWVkaXQtaWNvbidcbiAgICApLFxuICAgIGxheWVyTmFtZUlucHV0OiBjc3NgXG4gICAgICBtYXgtd2lkdGg6IDMwMHB4O1xuICAgICAgbWFyZ2luOiAtNHB4IDA7XG4gICAgYCxcbiAgfTtcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2NvbnRleHQnO1xuaW1wb3J0IHsgVGV4dERpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMvVGV4dERpbWVuc2lvbkVkaXRvcic7XG5pbXBvcnQgeyBUZXh0RGltZW5zaW9uQ29uZmlnIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvdHlwZXMnO1xuaW1wb3J0IHsgQ2FudmFzRWxlbWVudEl0ZW0sIENhbnZhc0VsZW1lbnRQcm9wcyB9IGZyb20gJy4uL2VsZW1lbnQnO1xuaW1wb3J0IHsgQVBJRWRpdG9yLCBBUElFZGl0b3JDb25maWcsIGNhbGxBcGkgfSBmcm9tICdhcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvZWRpdG9yL0FQSUVkaXRvcic7XG5cbmludGVyZmFjZSBCdXR0b25EYXRhIHtcbiAgdGV4dD86IHN0cmluZztcbiAgYXBpPzogQVBJRWRpdG9yQ29uZmlnO1xufVxuXG5pbnRlcmZhY2UgQnV0dG9uQ29uZmlnIHtcbiAgdGV4dD86IFRleHREaW1lbnNpb25Db25maWc7XG4gIGFwaT86IEFQSUVkaXRvckNvbmZpZztcbn1cblxuY2xhc3MgQnV0dG9uRGlzcGxheSBleHRlbmRzIFB1cmVDb21wb25lbnQ8Q2FudmFzRWxlbWVudFByb3BzPEJ1dHRvbkNvbmZpZywgQnV0dG9uRGF0YT4+IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRhdGE/LmFwaSkge1xuICAgICAgICBjYWxsQXBpKGRhdGEuYXBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIDxCdXR0b24gb25DbGljaz17b25DbGlja30+e2RhdGE/LnRleHR9PC9CdXR0b24+O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBidXR0b25JdGVtOiBDYW52YXNFbGVtZW50SXRlbTxCdXR0b25Db25maWcsIEJ1dHRvbkRhdGE+ID0ge1xuICBpZDogJ2J1dHRvbicsXG4gIG5hbWU6ICdCdXR0b24nLFxuICBkZXNjcmlwdGlvbjogJ0J1dHRvbicsXG5cbiAgZGlzcGxheTogQnV0dG9uRGlzcGxheSxcblxuICBkZWZhdWx0U2l6ZToge1xuICAgIHdpZHRoOiAyMDAsXG4gICAgaGVpZ2h0OiA1MCxcbiAgfSxcblxuICBnZXROZXdPcHRpb25zOiAob3B0aW9ucykgPT4gKHtcbiAgICAuLi5vcHRpb25zLFxuICB9KSxcblxuICAvLyBDYWxsZWQgd2hlbiBkYXRhIGNoYW5nZXNcbiAgcHJlcGFyZURhdGE6IChjdHg6IERpbWVuc2lvbkNvbnRleHQsIGNmZzogQnV0dG9uQ29uZmlnKSA9PiB7XG4gICAgY29uc3QgZGF0YTogQnV0dG9uRGF0YSA9IHtcbiAgICAgIHRleHQ6IGNmZz8udGV4dCA/IGN0eC5nZXRUZXh0KGNmZy50ZXh0KS52YWx1ZSgpIDogJycsXG4gICAgICBhcGk6IGNmZz8uYXBpID8/IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgLy8gSGVhdG1hcCBvdmVybGF5IG9wdGlvbnNcbiAgcmVnaXN0ZXJPcHRpb25zVUk6IChidWlsZGVyKSA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBbJ0J1dHRvbiddO1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICd0ZXh0U2VsZWN0b3InLFxuICAgICAgICBwYXRoOiAnY29uZmlnLnRleHQnLFxuICAgICAgICBuYW1lOiAnVGV4dCcsXG4gICAgICAgIGVkaXRvcjogVGV4dERpbWVuc2lvbkVkaXRvcixcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnYXBpU2VsZWN0b3InLFxuICAgICAgICBwYXRoOiAnY29uZmlnLmFwaScsXG4gICAgICAgIG5hbWU6ICdBUEknLFxuICAgICAgICBlZGl0b3I6IEFQSUVkaXRvcixcbiAgICAgIH0pO1xuICB9LFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyBGQyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBTY2FsYXJEaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzJztcbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9lbGVtZW50JztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQsIFNjYWxhckRpbWVuc2lvbkNvbmZpZyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcblxuaW50ZXJmYWNlIERyb25lRnJvbnREYXRhIHtcbiAgcm9sbEFuZ2xlPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRHJvbmVGcm9udENvbmZpZyB7XG4gIHJvbGxBbmdsZT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbn1cblxuY29uc3QgRHJvbmVGcm9udERpc3BsYXk6IEZDPENhbnZhc0VsZW1lbnRQcm9wczxEcm9uZUZyb250Q29uZmlnLCBEcm9uZUZyb250RGF0YT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICBjb25zdCB7IGRhdGEgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGRyb25lRnJvbnRUcmFuc2Zvcm1TdHlsZSA9IGByb3RhdGUoJHtkYXRhPy5yb2xsQW5nbGUgPyBkYXRhLnJvbGxBbmdsZSA6IDB9ZGVnKWA7XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBjbGFzc05hbWU9e3N0eWxlcy5kcm9uZUZyb250fVxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB4bWxuc1hsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiXG4gICAgICB2aWV3Qm94PVwiMCAwIDEzMDAgMjkwXCJcbiAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogZHJvbmVGcm9udFRyYW5zZm9ybVN0eWxlIH19XG4gICAgPlxuICAgICAgPGcgY2xhc3NOYW1lPVwiYXJtc1wiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlV2lkdGg9XCIyOHB4XCI+XG4gICAgICAgIDxsaW5lIHgxPVwiNTEwXCIgeDI9XCIzMjBcIiB5MT1cIjEwMFwiIHkyPVwiMTUwXCIgLz5cbiAgICAgICAgPGxpbmUgeDE9XCI1MTBcIiB4Mj1cIjMyMFwiIHkxPVwiMTkwXCIgeTI9XCIyMTBcIiAvPlxuICAgICAgICA8bGluZSB4MT1cIjc5MFwiIHgyPVwiOTgwXCIgeTE9XCIxOTBcIiB5Mj1cIjIxMFwiIC8+XG4gICAgICAgIDxsaW5lIHgxPVwiNzkwXCIgeDI9XCI5ODBcIiB5MT1cIjEwMFwiIHkyPVwiMTUwXCIgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGNsYXNzTmFtZT1cImJvZHlcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZVdpZHRoPVwiMjhweFwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBkPVwiIE0gNTEwIDEzMCBDIDUxMCAxMjQgNTEwIDExMCA1MTAgMTAwIEMgNTEwIDkwIDUzMCA3MSA1NDAgNzAgQyA2NDAgNjEgNjcwIDYwIDc2MCA3MCBDIDc3MCA3MSA3OTAgOTAgNzkwIDEwMCBRIDc5MCAxMjAgNzkwIDEzMCBMIDc5MCAxMzAgUSA3OTAgMTc3IDc5MCAxOTYgQyA3OTAgMjA3IDc3MCAyMjUgNzYwIDIyNiBDIDY3MCAyMzYgNjQwIDIzNiA1NDAgMjI2IEMgNTMwIDIyNiA1MTAgMjA2IDUxMCAxOTYgUSA1MTAgMTc3IDUxMCAxMzAgUSA1MTAgMTMzIDUxMCAxMzAgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8Y2lyY2xlIGN4PVwiNjUwXCIgY3k9XCIxNjBcIiByPVwiNDBcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBjbGFzc05hbWU9XCJtb3RvcnNcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZVdpZHRoPVwiMjhweFwiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT1cIm1vdG9yXCJcbiAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgZD1cIiBNIDMyMCA2MCBMIDI1MCA2MCBMIDI1MCAyMzAgTCAyNjAgMjkwIEwgMzEwIDI5MCBMIDMyMCAyMzAgTCAzMjAgNjAgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT1cIm1vdG9yXCJcbiAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgZD1cIiBNIDEwNTAgNjAgTCA5ODAgNjAgTCA5ODAgMjMwIEwgOTkwIDI5MCBMIDEwNDAgMjkwIEwgMTA1MCAyMzAgTCAxMDUwIDYwIFogXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGNsYXNzTmFtZT1cInByb3BlbGxlcnNcIiBmaWxsPVwiYmxhY2tcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9XCJwcm9wXCJcbiAgICAgICAgICBkPVwiIE0gMjcwIDYwIEwgMzAwIDYwIEwgMzAwIDIwIFEgMzExIDMwIDMzMCAzMCBRIDM0OSAzMCA1NzAgMTAgTCAzMDAgMTAgUSAzMDAgMCAyOTAgMCBDIDI4NiAwIDI4NCAwIDI4MCAwIFEgMjcwIDAgMjcwIDEwIEwgMCAxMCBRIDIyMCAzMCAyNDAgMzAgUSAyNjAgMzAgMjcwIDIwIEwgMjcwIDYwIFogXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9XCJwcm9wXCJcbiAgICAgICAgICBkPVwiIE0gMTAwMCA2MCBMIDEwMzAgNjAgTCAxMDMwIDIwIFEgMTA0MSAzMCAxMDYwIDMwIFEgMTA3OSAzMCAxMzAwIDEwIEwgMTAzMCAxMCBRIDEwMzAgMCAxMDIwIDAgQyAxMDE2IDAgMTAxNCAwIDEwMTAgMCBRIDEwMDAgMCAxMDAwIDEwIEwgNzMwIDEwIFEgOTUwIDMwIDk3MCAzMCBRIDk5MCAzMCAxMDAwIDIwIEwgMTAwMCA2MCBaIFwiXG4gICAgICAgIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZHJvbmVGcm9udEl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPGFueSwgYW55PiA9IHtcbiAgaWQ6ICdkcm9uZUZyb250JyxcbiAgbmFtZTogJ0Ryb25lIEZyb250JyxcbiAgZGVzY3JpcHRpb246ICdEcm9uZSBmcm9udCcsXG5cbiAgZGlzcGxheTogRHJvbmVGcm9udERpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIC4uLm9wdGlvbnMsXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBEcm9uZUZyb250Q29uZmlnKSA9PiB7XG4gICAgY29uc3QgZGF0YTogRHJvbmVGcm9udERhdGEgPSB7XG4gICAgICByb2xsQW5nbGU6IGNmZz8ucm9sbEFuZ2xlID8gY3R4LmdldFNjYWxhcihjZmcucm9sbEFuZ2xlKS52YWx1ZSgpIDogMCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgcmVnaXN0ZXJPcHRpb25zVUk6IChidWlsZGVyKSA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBbJ0Ryb25lIEZyb250J107XG4gICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgY2F0ZWdvcnksXG4gICAgICBpZDogJ3JvbGxBbmdsZScsXG4gICAgICBwYXRoOiAnY29uZmlnLnJvbGxBbmdsZScsXG4gICAgICBuYW1lOiAnUm9sbCBBbmdsZScsXG4gICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICB9KTtcbiAgfSxcbn07XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgZHJvbmVGcm9udDogY3NzYFxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjRzO1xuICBgLFxufSk7XG4iLCJpbXBvcnQgUmVhY3QsIHsgRkMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgU2NhbGFyRGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycyc7XG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5pbXBvcnQgeyBEaW1lbnNpb25Db250ZXh0LCBTY2FsYXJEaW1lbnNpb25Db25maWcgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucyc7XG5cbmludGVyZmFjZSBEcm9uZVNpZGVEYXRhIHtcbiAgcGl0Y2hBbmdsZT86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIERyb25lU2lkZUNvbmZpZyB7XG4gIHBpdGNoQW5nbGU/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG59XG5cbmNvbnN0IERyb25lU2lkZURpc3BsYXk6IEZDPENhbnZhc0VsZW1lbnRQcm9wczxEcm9uZVNpZGVDb25maWcsIERyb25lU2lkZURhdGE+PiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgY29uc3QgeyBkYXRhIH0gPSBwcm9wcztcblxuICBjb25zdCBkcm9uZVNpZGVQaXRjaFRyYW5zZm9ybVN0eWxlID0gYHJvdGF0ZSgke2RhdGE/LnBpdGNoQW5nbGUgPyBkYXRhLnBpdGNoQW5nbGUgOiAwfWRlZylgO1xuXG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuZHJvbmVTaWRlfVxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB4bWxuc1hsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiXG4gICAgICB2aWV3Qm94PVwiMCAwIDEzMDAgMjkwXCJcbiAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogZHJvbmVTaWRlUGl0Y2hUcmFuc2Zvcm1TdHlsZSB9fVxuICAgID5cbiAgICAgIDxnIGNsYXNzTmFtZT1cImFybXNcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZVdpZHRoPVwiMjhweFwiPlxuICAgICAgICA8bGluZSB4MT1cIjUxMFwiIHgyPVwiMzIwXCIgeTE9XCIxMDBcIiB5Mj1cIjE1MFwiIC8+XG4gICAgICAgIDxsaW5lIHgxPVwiNTEwXCIgeDI9XCIzMjBcIiB5MT1cIjE5MFwiIHkyPVwiMjEwXCIgLz5cbiAgICAgICAgPGxpbmUgeDE9XCI3OTBcIiB4Mj1cIjk4MFwiIHkxPVwiMTkwXCIgeTI9XCIyMTBcIiAvPlxuICAgICAgICA8bGluZSB4MT1cIjc5MFwiIHgyPVwiOTgwXCIgeTE9XCIxMDBcIiB5Mj1cIjE1MFwiIC8+XG4gICAgICA8L2c+XG4gICAgICA8ZyBjbGFzc05hbWU9XCJib2R5XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2VXaWR0aD1cIjI4cHhcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgZD1cIiBNIDUxMCAxMzAgQyA1MTAgMTI0IDUxMCAxMTAgNTEwIDEwMCBDIDUxMCA5MCA1MzAgNzEgNTQwIDcwIEMgNjQwIDYxIDY3MCA2MCA3NjAgNzAgQyA3NzAgNzEgNzkwIDkwIDc5MCAxMDAgUSA3OTAgMTIwIDc5MCAxMzAgTCA3OTAgMTMwIFEgNzkwIDE3NyA3OTAgMTk2IEMgNzkwIDIwNyA3NzAgMjI1IDc2MCAyMjYgQyA2NzAgMjM2IDY0MCAyMzYgNTQwIDIyNiBDIDUzMCAyMjYgNTEwIDIwNiA1MTAgMTk2IFEgNTEwIDE3NyA1MTAgMTMwIFEgNTEwIDEzMyA1MTAgMTMwIFogXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZz5cbiAgICAgIDxnIGNsYXNzTmFtZT1cIm1vdG9yc1wiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlV2lkdGg9XCIyOHB4XCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPVwibW90b3JcIlxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBkPVwiIE0gMzIwIDYwIEwgMjUwIDYwIEwgMjUwIDIzMCBMIDI2MCAyOTAgTCAzMTAgMjkwIEwgMzIwIDIzMCBMIDMyMCA2MCBaIFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3NOYW1lPVwibW90b3JcIlxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBkPVwiIE0gMTA1MCA2MCBMIDk4MCA2MCBMIDk4MCAyMzAgTCA5OTAgMjkwIEwgMTA0MCAyOTAgTCAxMDUwIDIzMCBMIDEwNTAgNjAgWiBcIlxuICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgICAgPGcgY2xhc3NOYW1lPVwicHJvcGVsbGVyc1wiIGZpbGw9XCJibGFja1wiPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT1cInByb3BcIlxuICAgICAgICAgIGQ9XCIgTSAyNzAgNjAgTCAzMDAgNjAgTCAzMDAgMjAgUSAzMTEgMzAgMzMwIDMwIFEgMzQ5IDMwIDU3MCAxMCBMIDMwMCAxMCBRIDMwMCAwIDI5MCAwIEMgMjg2IDAgMjg0IDAgMjgwIDAgUSAyNzAgMCAyNzAgMTAgTCAwIDEwIFEgMjIwIDMwIDI0MCAzMCBRIDI2MCAzMCAyNzAgMjAgTCAyNzAgNjAgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT1cInByb3BcIlxuICAgICAgICAgIGQ9XCIgTSAxMDAwIDYwIEwgMTAzMCA2MCBMIDEwMzAgMjAgUSAxMDQxIDMwIDEwNjAgMzAgUSAxMDc5IDMwIDEzMDAgMTAgTCAxMDMwIDEwIFEgMTAzMCAwIDEwMjAgMCBDIDEwMTYgMCAxMDE0IDAgMTAxMCAwIFEgMTAwMCAwIDEwMDAgMTAgTCA3MzAgMTAgUSA5NTAgMzAgOTcwIDMwIFEgOTkwIDMwIDEwMDAgMjAgTCAxMDAwIDYwIFogXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkcm9uZVNpZGVJdGVtOiBDYW52YXNFbGVtZW50SXRlbTxhbnksIGFueT4gPSB7XG4gIGlkOiAnZHJvbmVTaWRlJyxcbiAgbmFtZTogJ0Ryb25lIFNpZGUnLFxuICBkZXNjcmlwdGlvbjogJ0Ryb25lIFNpZGUnLFxuXG4gIGRpc3BsYXk6IERyb25lU2lkZURpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIC4uLm9wdGlvbnMsXG4gIH0pLFxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgY2hhbmdlc1xuICBwcmVwYXJlRGF0YTogKGN0eDogRGltZW5zaW9uQ29udGV4dCwgY2ZnOiBEcm9uZVNpZGVDb25maWcpID0+IHtcbiAgICBjb25zdCBkYXRhOiBEcm9uZVNpZGVEYXRhID0ge1xuICAgICAgcGl0Y2hBbmdsZTogY2ZnPy5waXRjaEFuZ2xlID8gY3R4LmdldFNjYWxhcihjZmcucGl0Y2hBbmdsZSkudmFsdWUoKSA6IDAsXG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydEcm9uZSBTaWRlJ107XG4gICAgYnVpbGRlci5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgY2F0ZWdvcnksXG4gICAgICBpZDogJ3BpdGNoQW5nbGUnLFxuICAgICAgcGF0aDogJ2NvbmZpZy5waXRjaEFuZ2xlJyxcbiAgICAgIG5hbWU6ICdQaXRjaCBBbmdsZScsXG4gICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICB9KTtcbiAgfSxcbn07XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgZHJvbmVTaWRlOiBjc3NgXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNHM7XG4gIGAsXG59KTtcbiIsImltcG9ydCBSZWFjdCwgeyBGQyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuXG5pbXBvcnQgeyBTY2FsYXJEaW1lbnNpb25FZGl0b3IgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9lZGl0b3JzJztcbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9lbGVtZW50JztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQsIFNjYWxhckRpbWVuc2lvbkNvbmZpZyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcblxuaW50ZXJmYWNlIERyb25lVG9wRGF0YSB7XG4gIGJSaWdodFJvdG9yUlBNPzogbnVtYmVyO1xuICBiTGVmdFJvdG9yUlBNPzogbnVtYmVyO1xuICBmUmlnaHRSb3RvclJQTT86IG51bWJlcjtcbiAgZkxlZnRSb3RvclJQTT86IG51bWJlcjtcbiAgeWF3QW5nbGU/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBEcm9uZVRvcENvbmZpZyB7XG4gIGJSaWdodFJvdG9yUlBNPzogU2NhbGFyRGltZW5zaW9uQ29uZmlnO1xuICBiTGVmdFJvdG9yUlBNPzogU2NhbGFyRGltZW5zaW9uQ29uZmlnO1xuICBmUmlnaHRSb3RvclJQTT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbiAgZkxlZnRSb3RvclJQTT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbiAgeWF3QW5nbGU/OiBTY2FsYXJEaW1lbnNpb25Db25maWc7XG59XG5cbmNvbnN0IERyb25lVG9wRGlzcGxheTogRkM8Q2FudmFzRWxlbWVudFByb3BzPERyb25lVG9wQ29uZmlnLCBEcm9uZVRvcERhdGE+PiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG5cbiAgY29uc3QgeyBkYXRhIH0gPSBwcm9wcztcblxuICBjb25zdCBmUmlnaHRSb3RvckFuaW1hdGlvbiA9IGBzcGluICR7ZGF0YT8uZlJpZ2h0Um90b3JSUE0gPyA2MCAvIE1hdGguYWJzKGRhdGEuZlJpZ2h0Um90b3JSUE0pIDogMH1zIGxpbmVhciBpbmZpbml0ZWA7XG5cbiAgY29uc3QgZkxlZnRSb3RvckFuaW1hdGlvbiA9IGBzcGluICR7ZGF0YT8uZkxlZnRSb3RvclJQTSA/IDYwIC8gTWF0aC5hYnMoZGF0YS5mTGVmdFJvdG9yUlBNKSA6IDB9cyBsaW5lYXIgaW5maW5pdGVgO1xuXG4gIGNvbnN0IGJSaWdodFJvdG9yQW5pbWF0aW9uID0gYHNwaW4gJHtkYXRhPy5iUmlnaHRSb3RvclJQTSA/IDYwIC8gTWF0aC5hYnMoZGF0YS5iUmlnaHRSb3RvclJQTSkgOiAwfXMgbGluZWFyIGluZmluaXRlYDtcblxuICBjb25zdCBiTGVmdFJvdG9yQW5pbWF0aW9uID0gYHNwaW4gJHtkYXRhPy5iTGVmdFJvdG9yUlBNID8gNjAgLyBNYXRoLmFicyhkYXRhLmJMZWZ0Um90b3JSUE0pIDogMH1zIGxpbmVhciBpbmZpbml0ZWA7XG5cbiAgY29uc3QgZHJvbmVUb3BUcmFuc2Zvcm1TdHlsZSA9IGByb3RhdGUoJHtkYXRhPy55YXdBbmdsZSA/IGRhdGEueWF3QW5nbGUgOiAwfWRlZylgO1xuXG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB4bWxuc1hsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiXG4gICAgICB2aWV3Qm94PVwiLTQzIC00MyA2NDAgNjQwXCJcbiAgICAgIHhtbFNwYWNlPVwicHJlc2VydmVcIlxuICAgICAgc3R5bGU9e3sgdHJhbnNmb3JtOiBkcm9uZVRvcFRyYW5zZm9ybVN0eWxlIH19XG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcbiAgICAgICAgZD1cIiBNIDEzNy45NSAxMjcuOTY3IEMgMTM3LjE0IDEyNy4xNTcgMTM2LjE4OSAxMjYuNTggMTM1LjE3OCAxMjYuMjE4IEMgMTM4LjE3MyAxMjEuNTQ1IDEzOS45NjcgMTE2LjAzNiAxNDAuMTI1IDExMC4xMjMgTCAyMTcuNjQgMTUxLjg2MiBDIDIxNC4wNDkgMTU3LjQxMSAyMTEuOCAxNjMuOTIyIDIxMS4zODYgMTcwLjk1IEwgMjA5LjY5NCAxOTkuNzEyIEwgMTM3Ljk1IDEyNy45NjcgTCAxMzcuOTUgMTI3Ljk2NyBMIDEzNy45NSAxMjcuOTY3IEwgMTM3Ljk1IDEyNy45NjcgTCAxMzcuOTUgMTI3Ljk2NyBMIDEzNy45NSAxMjcuOTY3IEwgMTM3Ljk1IDEyNy45NjcgTCAxMzcuOTUgMTI3Ljk2NyBMIDEzNy45NSAxMjcuOTY3IFogIE0gMTM0LjI2OCA0MjYuOTgxIEMgMTMwLjIxMSA0MjEuMzE0IDEyNC4zMjggNDE3LjA0NSAxMTcuNDgyIDQxNS4wNDEgTCAyMDEuOTk5IDMzMC41MjMgTCAyMDEuMzg1IDM0MC45NTUgQyAyMDAuNjcgMzUzLjEwNyAyMDIuODI5IDM2NC45MTQgMjA3LjU2MyAzNzUuNjczIEwgMTM0LjI2OCA0MjYuOTgxIEwgMTM0LjI2OCA0MjYuOTgxIEwgMTM0LjI2OCA0MjYuOTgxIEwgMTM0LjI2OCA0MjYuOTgxIEwgMTM0LjI2OCA0MjYuOTgxIEwgMTM0LjI2OCA0MjYuOTgxIEwgMTM0LjI2OCA0MjYuOTgxIEwgMTM0LjI2OCA0MjYuOTgxIFogIE0gMzI0Ljc2NSAzNzMuNjczIEwgMjI4LjUyNyAzNzMuNjczIFEgMjE1LjM3NCAzNTguNjExIDIxNi4zNjEgMzQxLjgzNSBMIDIyNi4zNjEgMTcxLjgzMiBDIDIyNi44MjUgMTYzLjk0IDIzMS4wMTIgMTU3LjA5NiAyMzcuMTQ2IDE1Mi45NTcgTCAzMTYuMTQ2IDE1Mi45NTcgQyAzMjIuMjggMTU3LjA5NiAzMjYuNDY2IDE2My45NCAzMjYuOTMxIDE3MS44MzIgTCAzMzYuOTMxIDM0MS44MzUgUSAzMzcuOTE4IDM1OC42MTEgMzI0Ljc2NSAzNzMuNjczIEwgMzI0Ljc2NSAzNzMuNjczIEwgMzI0Ljc2NSAzNzMuNjczIEwgMzI0Ljc2NSAzNzMuNjczIEwgMzI0Ljc2NSAzNzMuNjczIEwgMzI0Ljc2NSAzNzMuNjczIEwgMzI0Ljc2NSAzNzMuNjczIFogIE0gNDM1LjgxIDQxNS4wNDEgQyA0MjguOTY0IDQxNy4wNDUgNDIzLjA4MSA0MjEuMzE0IDQxOS4wMjQgNDI2Ljk4MSBMIDM0NS43MjcgMzc1LjY3MyBDIDM1MC40NjEgMzY0LjkxNCAzNTIuNjIgMzUzLjEwNyAzNTEuOTA1IDM0MC45NTUgTCAzNTEuMjkxIDMzMC41MjMgTCA0MzUuODEgNDE1LjA0MSBMIDQzNS44MSA0MTUuMDQxIEwgNDM1LjgxIDQxNS4wNDEgTCA0MzUuODEgNDE1LjA0MSBMIDQzNS44MSA0MTUuMDQxIEwgNDM1LjgxIDQxNS4wNDEgWiAgTSAzNDMuNTk2IDE5OS43MTMgTCAzNDEuOTA0IDE3MC45NTEgQyAzNDEuNDkgMTYzLjkyMyAzMzkuMjQyIDE1Ny40MTEgMzM1LjY1MSAxNTEuODYzIEwgNDEzLjE2NyAxMTAuMTI0IEMgNDEzLjMyNSAxMTYuMDM3IDQxNS4xMTkgMTIxLjU0NiA0MTguMTE0IDEyNi4yMTkgQyA0MTcuMTAzIDEyNi41ODEgNDE2LjE1MiAxMjcuMTU4IDQxNS4zNDIgMTI3Ljk2OCBMIDM0My41OTYgMTk5LjcxMyBMIDM0My41OTYgMTk5LjcxMyBMIDM0My41OTYgMTk5LjcxMyBMIDM0My41OTYgMTk5LjcxMyBMIDM0My41OTYgMTk5LjcxMyBaICBNIDQ0NC42NDYgOTIuNzcxIEMgNDUzLjc0NCA5Mi43NzEgNDYxLjE0NiAxMDAuMTcyIDQ2MS4xNDYgMTA5LjI3MSBDIDQ2MS4xNDYgMTE4LjM2OSA0NTMuNzQ0IDEyNS43NzEgNDQ0LjY0NiAxMjUuNzcxIEMgNDM1LjU0OCAxMjUuNzcxIDQyOC4xNDYgMTE4LjM2OSA0MjguMTQ2IDEwOS4yNzEgQyA0MjguMTQ2IDEwMC4xNzIgNDM1LjU0OCA5Mi43NzEgNDQ0LjY0NiA5Mi43NzEgTCA0NDQuNjQ2IDkyLjc3MSBMIDQ0NC42NDYgOTIuNzcxIEwgNDQ0LjY0NiA5Mi43NzEgWiAgTSAxMDguNjQ3IDkyLjc3MSBDIDExNy43NDUgOTIuNzcxIDEyNS4xNDcgMTAwLjE3MiAxMjUuMTQ3IDEwOS4yNzEgQyAxMjUuMTQ3IDExOC4zNjkgMTE3Ljc0NSAxMjUuNzcxIDEwOC42NDcgMTI1Ljc3MSBDIDk5LjU0OSAxMjUuNzcxIDkyLjE0NyAxMTguMzY5IDkyLjE0NyAxMDkuMjcxIEMgOTIuMTQ3IDEwMC4xNzIgOTkuNTQ5IDkyLjc3MSAxMDguNjQ3IDkyLjc3MSBMIDEwOC42NDcgOTIuNzcxIEwgMTA4LjY0NyA5Mi43NzEgWiAgTSAxMDguNjQ3IDQ2MS43NzEgQyA5OS41NDkgNDYxLjc3MSA5Mi4xNDcgNDU0LjM2OSA5Mi4xNDcgNDQ1LjI3MSBDIDkyLjE0NyA0MzYuMTcyIDk5LjU0OSA0MjguNzcxIDEwOC42NDcgNDI4Ljc3MSBDIDExNy43NDUgNDI4Ljc3MSAxMjUuMTQ3IDQzNi4xNzIgMTI1LjE0NyA0NDUuMjcxIEMgMTI1LjE0NyA0NTQuMzY5IDExNy43NDUgNDYxLjc3MSAxMDguNjQ3IDQ2MS43NzEgTCAxMDguNjQ3IDQ2MS43NzEgWiAgTSA5Mi4zMjIgMTM2LjIwMiBDIDk3LjA4NiAxMzkuMSAxMDIuNjc1IDE0MC43NzEgMTA4LjY0NyAxNDAuNzcxIEMgMTE0Ljg4MyAxNDAuNzcxIDEyMC42OTcgMTM4Ljk0MSAxMjUuNTk0IDEzNS44MDIgQyAxMjUuOTU2IDEzNi44MTMgMTI2LjUzNCAxMzcuNzY0IDEyNy4zNDMgMTM4LjU3MyBMIDIwNy4zNDIgMjE4LjU3MyBDIDIwNy43MTEgMjE4Ljk0MiAyMDguMTA5IDIxOS4yNjQgMjA4LjUyOCAyMTkuNTQgTCAyMDMuMjEyIDMwOS45MDggQyAyMDEuNzk0IDMxMC4xODIgMjAwLjQ0IDMxMC44NjkgMTk5LjM0MiAzMTEuOTY3IEwgOTUuMzQzIDQxNS45NjcgQyA5NC45NTQgNDE2LjM1NiA5NC42MiA0MTYuNzc5IDk0LjMzNSA0MTcuMjI0IEMgOTMuNjUxIDQxNy41NzUgOTIuOTc2IDQxNy45NDIgOTIuMzIyIDQxOC4zNCBRIDg0LjYxNSA0MjQuMTgyIDgxLjcxNiA0MjguOTQ2IEMgNzguODE3IDQzMy43MSA3Ny4xNDcgNDM5LjI5OSA3Ny4xNDcgNDQ1LjI3MSBDIDc3LjE0NyA0NjIuNjQgOTEuMjc4IDQ3Ni43NzEgMTA4LjY0NyA0NzYuNzcxIEMgMTE0LjYxOSA0NzYuNzcxIDEyMC4yMDggNDc1LjEgMTI0Ljk3MiA0NzIuMjAyIEMgMTI5LjczNiA0NjkuMzA0IDEzMi42NzggNDY2LjM2IDEzNS41NzcgNDYxLjU5NiBDIDEzOC40NzYgNDU2LjgzMiAxNDAuMTQ3IDQ1MS4yNDMgMTQwLjE0NyA0NDUuMjcxIEMgMTQwLjE0NyA0NDMuOTQzIDE0MC4wNTUgNDQyLjYzNyAxMzkuODk1IDQ0MS4zNTIgTCAyMTQuOTk3IDM4OC43OCBDIDIxNy4wNSAzOTEuNjc3IDMzNi4yNDIgMzkxLjY3OCAzMzguMjk1IDM4OC43OCBMIDQxMy4zOTggNDQxLjM1MiBDIDQxMy4yMzggNDQyLjYzNyA0MTMuMTQ2IDQ0My45NDMgNDEzLjE0NiA0NDUuMjcxIEMgNDEzLjE0NiA0NTEuMjQzIDQxNC44MTcgNDU2LjgzMiA0MTcuNzE1IDQ2MS41OTYgQyA0MjAuNjEzIDQ2Ni4zNiA0MjMuNTU3IDQ2OS4zMDQgNDI4LjMyMSA0NzIuMjAyIEMgNDMzLjA4NSA0NzUuMSA0MzguNjc0IDQ3Ni43NzEgNDQ0LjY0NiA0NzYuNzcxIEMgNDYyLjAxNSA0NzYuNzcxIDQ3Ni4xNDYgNDYyLjY0IDQ3Ni4xNDYgNDQ1LjI3MSBDIDQ3Ni4xNDYgNDM5LjI5OSA0NzQuNDc1IDQzMy43MSA0NzEuNTc3IDQyOC45NDYgQyA0NjguNjc5IDQyNC4xODIgNDU5LjY0MiA0MTcuNTc1IDQ1OC45NTggNDE3LjIyNCBDIDQ1OC42NzIgNDE2Ljc3OSA0NTguMzM5IDQxNi4zNTYgNDU3Ljk1IDQxNS45NjcgTCAzNTMuOTUgMzExLjk2NyBDIDM1Mi44NTIgMzEwLjg2OSAzNTEuNDk4IDMxMC4xODIgMzUwLjA4IDMwOS45MDggTCAzNDQuNzY0IDIxOS41NCBDIDM0NS4xODMgMjE5LjI2NCAzNDUuNTgxIDIxOC45NDIgMzQ1Ljk1IDIxOC41NzMgTCA0MjUuOTUgMTM4LjU3MyBDIDQyNi43NiAxMzcuNzYzIDQyNy4zMzcgMTM2LjgxMiA0MjcuNjk5IDEzNS44MDIgQyA0MzIuNTk2IDEzOC45NDEgNDM4LjQwOSAxNDAuNzcxIDQ0NC42NDYgMTQwLjc3MSBDIDQ1MC42MTggMTQwLjc3MSA0NTYuMjA3IDEzOS4xIDQ2MC45NzEgMTM2LjIwMiBDIDQ2NS43MzUgMTMzLjMwNCA0NjguNjc5IDEzMC4zNiA0NzEuNTc3IDEyNS41OTYgQyA0NzQuNDc1IDEyMC44MzIgNDc2LjE0NiAxMTUuMjQzIDQ3Ni4xNDYgMTA5LjI3MSBDIDQ3Ni4xNDYgOTEuOTAzIDQ2Mi4wMTUgNzcuNzcyIDQ0NC42NDYgNzcuNzcyIEMgNDM4LjY3NCA3Ny43NzIgNDMzLjA4NSA3OS40NDIgNDI4LjMyMSA4Mi4zNCBMIDQxNi4yMTUgOTEuNDQ2IEwgMzI0Ljc2NSAxNDAuNjg4IEMgMzE4LjQwMiAxMzYuMzI0IDMxMC43MTggMTMzLjc3MSAzMDIuNDczIDEzMy43NzEgTCAyNTAuODE5IDEzMy43NzEgQyAyNDIuNTc0IDEzMy43NzEgMjM0Ljg5IDEzNi4zMjQgMjI4LjUyNyAxNDAuNjg4IEwgMTM3LjA3OCA5MS40NDYgTCAxMjQuOTcyIDgyLjM0IEMgMTIwLjIwOCA3OS40NDIgMTE0LjYxOSA3Ny43NzIgMTA4LjY0NyA3Ny43NzIgQyA5MS4yNzggNzcuNzcyIDc3LjE0NyA5MS45MDMgNzcuMTQ3IDEwOS4yNzEgQyA3Ny4xNDcgMTE1LjI0MyA3OC44MTggMTIwLjgzMiA4MS43MTYgMTI1LjU5NSBDIDg0LjYxNCAxMzAuMzU4IDg3LjU1OCAxMzMuMzA0IDkyLjMyMiAxMzYuMjAyIEwgOTIuMzIyIDEzNi4yMDIgTCA5Mi4zMjIgMTM2LjIwMiBMIDkyLjMyMiAxMzYuMjAyIEwgOTIuMzIyIDEzNi4yMDIgTCA5Mi4zMjIgMTM2LjIwMiBMIDkyLjMyMiAxMzYuMjAyIEwgOTIuMzIyIDEzNi4yMDIgTCA5Mi4zMjIgMTM2LjIwMiBaICBNIDQ0NC42NDYgNDYxLjc3MSBDIDQzNS41NDggNDYxLjc3MSA0MjguMTQ2IDQ1NC4zNjkgNDI4LjE0NiA0NDUuMjcxIEMgNDI4LjE0NiA0MzYuMTcyIDQzNS41NDggNDI4Ljc3MSA0NDQuNjQ2IDQyOC43NzEgQyA0NTMuNzQ0IDQyOC43NzEgNDYxLjE0NiA0MzYuMTcyIDQ2MS4xNDYgNDQ1LjI3MSBDIDQ2MS4xNDYgNDU0LjM2OSA0NTMuNzQ0IDQ2MS43NzEgNDQ0LjY0NiA0NjEuNzcxIFogXCJcbiAgICAgIC8+XG4gICAgICA8cGF0aFxuICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIlxuICAgICAgICBkPVwiIE0gMjU5LjQ1OCAzMzQuMjM1IEwgMjU5LjQ1OCAzMzcuMjExIEwgMjU0LjUxNCAzMzcuMjExIEwgMjU0LjUxNCAzNTAuNzk1IEwgMjUwLjg0MiAzNTAuNzk1IEwgMjUwLjg0MiAzMzcuMjExIEwgMjQ1Ljg5OCAzMzcuMjExIEwgMjQ1Ljg5OCAzMzQuMjM1IEwgMjU5LjQ1OCAzMzQuMjM1IFogIE0gMjY2LjIyNiAzNDcuOTM5IEwgMjcyLjU4NiAzNDcuOTM5IEwgMjcyLjc1NCAzNTAuNjI3IEwgMjcyLjc1NCAzNTAuNjI3IFEgMjcwLjQ5OCAzNTAuODY3IDI2NS4wNzQgMzUwLjg2NyBMIDI2NS4wNzQgMzUwLjg2NyBMIDI2NS4wNzQgMzUwLjg2NyBRIDI2My40MTggMzUwLjg2NyAyNjIuNDM0IDM0OS45NjcgTCAyNjIuNDM0IDM0OS45NjcgTCAyNjIuNDM0IDM0OS45NjcgUSAyNjEuNDUgMzQ5LjA2NyAyNjEuNDI2IDM0Ny41MzEgTCAyNjEuNDI2IDM0Ny41MzEgTCAyNjEuNDI2IDMzNy40OTkgTCAyNjEuNDI2IDMzNy40OTkgUSAyNjEuNDUgMzM1Ljk2MyAyNjIuNDM0IDMzNS4wNjMgTCAyNjIuNDM0IDMzNS4wNjMgTCAyNjIuNDM0IDMzNS4wNjMgUSAyNjMuNDE4IDMzNC4xNjMgMjY1LjA3NCAzMzQuMTYzIEwgMjY1LjA3NCAzMzQuMTYzIEwgMjY1LjA3NCAzMzQuMTYzIFEgMjcwLjQ5OCAzMzQuMTYzIDI3Mi43NTQgMzM0LjQwMyBMIDI3Mi43NTQgMzM0LjQwMyBMIDI3Mi41ODYgMzM3LjExNSBMIDI2Ni4yMjYgMzM3LjExNSBMIDI2Ni4yMjYgMzM3LjExNSBRIDI2NS42MjYgMzM3LjExNSAyNjUuMzYyIDMzNy40MDMgTCAyNjUuMzYyIDMzNy40MDMgTCAyNjUuMzYyIDMzNy40MDMgUSAyNjUuMDk4IDMzNy42OTEgMjY1LjA5OCAzMzguMzM5IEwgMjY1LjA5OCAzMzguMzM5IEwgMjY1LjA5OCAzNDAuODU5IEwgMjcxLjY5OCAzNDAuODU5IEwgMjcxLjY5OCAzNDMuNDk5IEwgMjY1LjA5OCAzNDMuNDk5IEwgMjY1LjA5OCAzNDYuNjkxIEwgMjY1LjA5OCAzNDYuNjkxIFEgMjY1LjA5OCAzNDcuMzYzIDI2NS4zNjIgMzQ3LjY1MSBMIDI2NS4zNjIgMzQ3LjY1MSBMIDI2NS4zNjIgMzQ3LjY1MSBRIDI2NS42MjYgMzQ3LjkzOSAyNjYuMjI2IDM0Ny45MzkgTCAyNjYuMjI2IDM0Ny45MzkgWiAgTSAyNzUuMjAyIDMzMy45OTUgTCAyNzguNzMgMzMzLjk5NSBMIDI3OC43MyAzNDYuOTMxIEwgMjc4LjczIDM0Ni45MzEgUSAyNzguNzMgMzQ4LjEzMSAyODAuMDc0IDM0OC4xMzEgTCAyODAuMDc0IDM0OC4xMzEgTCAyODEuMDM0IDM0OC4xMzEgTCAyODEuNDQyIDM1MC42MDMgTCAyODEuNDQyIDM1MC42MDMgUSAyODAuNTMgMzUxLjA4MyAyNzguNjEgMzUxLjA4MyBMIDI3OC42MSAzNTEuMDgzIEwgMjc4LjYxIDM1MS4wODMgUSAyNzcuMDI2IDM1MS4wODMgMjc2LjExNCAzNTAuMjMxIEwgMjc2LjExNCAzNTAuMjMxIEwgMjc2LjExNCAzNTAuMjMxIFEgMjc1LjIwMiAzNDkuMzc5IDI3NS4yMDIgMzQ3LjgxOSBMIDI3NS4yMDIgMzQ3LjgxOSBMIDI3NS4yMDIgMzMzLjk5NSBaICBNIDI4My4wNSAzMzMuOTk1IEwgMjg2LjU3OCAzMzMuOTk1IEwgMjg2LjU3OCAzNDYuOTMxIEwgMjg2LjU3OCAzNDYuOTMxIFEgMjg2LjU3OCAzNDguMTMxIDI4Ny45MjIgMzQ4LjEzMSBMIDI4Ny45MjIgMzQ4LjEzMSBMIDI4OC44ODIgMzQ4LjEzMSBMIDI4OS4yOSAzNTAuNjAzIEwgMjg5LjI5IDM1MC42MDMgUSAyODguMzc4IDM1MS4wODMgMjg2LjQ1OCAzNTEuMDgzIEwgMjg2LjQ1OCAzNTEuMDgzIEwgMjg2LjQ1OCAzNTEuMDgzIFEgMjg0Ljg3NCAzNTEuMDgzIDI4My45NjIgMzUwLjIzMSBMIDI4My45NjIgMzUwLjIzMSBMIDI4My45NjIgMzUwLjIzMSBRIDI4My4wNSAzNDkuMzc5IDI4My4wNSAzNDcuODE5IEwgMjgzLjA1IDM0Ny44MTkgTCAyODMuMDUgMzMzLjk5NSBaICBNIDI5Mi4wODYgMzM1Ljc1OSBMIDI5Mi4wODYgMzM1Ljc1OSBMIDI5Mi4wODYgMzM1Ljc1OSBRIDI5My42MzQgMzMzLjkyMyAyOTcuNjE4IDMzMy45MjMgTCAyOTcuNjE4IDMzMy45MjMgTCAyOTcuNjE4IDMzMy45MjMgUSAzMDEuNjAyIDMzMy45MjMgMzAzLjE2MiAzMzUuNzU5IEwgMzAzLjE2MiAzMzUuNzU5IEwgMzAzLjE2MiAzMzUuNzU5IFEgMzA0LjcyMiAzMzcuNTk1IDMwNC43MjIgMzQyLjUxNSBMIDMwNC43MjIgMzQyLjUxNSBMIDMwNC43MjIgMzQyLjUxNSBRIDMwNC43MjIgMzQ3LjQzNSAzMDMuMTYyIDM0OS4yNzEgTCAzMDMuMTYyIDM0OS4yNzEgTCAzMDMuMTYyIDM0OS4yNzEgUSAzMDEuNjAyIDM1MS4xMDcgMjk3LjYxOCAzNTEuMTA3IEwgMjk3LjYxOCAzNTEuMTA3IEwgMjk3LjYxOCAzNTEuMTA3IFEgMjkzLjYzNCAzNTEuMTA3IDI5Mi4wODYgMzQ5LjI3MSBMIDI5Mi4wODYgMzQ5LjI3MSBMIDI5Mi4wODYgMzQ5LjI3MSBRIDI5MC41MzggMzQ3LjQzNSAyOTAuNTM4IDM0Mi41MTUgTCAyOTAuNTM4IDM0Mi41MTUgTCAyOTAuNTM4IDM0Mi41MTUgUSAyOTAuNTM4IDMzNy41OTUgMjkyLjA4NiAzMzUuNzU5IFogIE0gMzAwLjE3NCAzMzguMDUxIEwgMzAwLjE3NCAzMzguMDUxIEwgMzAwLjE3NCAzMzguMDUxIFEgMjk5LjQ5IDMzNi44NzUgMjk3LjYxOCAzMzYuODc1IEwgMjk3LjYxOCAzMzYuODc1IEwgMjk3LjYxOCAzMzYuODc1IFEgMjk1Ljc0NiAzMzYuODc1IDI5NS4wNjIgMzM4LjA1MSBMIDI5NS4wNjIgMzM4LjA1MSBMIDI5NS4wNjIgMzM4LjA1MSBRIDI5NC4zNzggMzM5LjIyNyAyOTQuMzc4IDM0Mi41MTUgTCAyOTQuMzc4IDM0Mi41MTUgTCAyOTQuMzc4IDM0Mi41MTUgUSAyOTQuMzc4IDM0NS44MDMgMjk1LjA2MiAzNDYuOTc5IEwgMjk1LjA2MiAzNDYuOTc5IEwgMjk1LjA2MiAzNDYuOTc5IFEgMjk1Ljc0NiAzNDguMTU1IDI5Ny42MTggMzQ4LjE1NSBMIDI5Ny42MTggMzQ4LjE1NSBMIDI5Ny42MTggMzQ4LjE1NSBRIDI5OS40OSAzNDguMTU1IDMwMC4xNzQgMzQ2Ljk3OSBMIDMwMC4xNzQgMzQ2Ljk3OSBMIDMwMC4xNzQgMzQ2Ljk3OSBRIDMwMC44NTggMzQ1LjgwMyAzMDAuODU4IDM0Mi41MTUgTCAzMDAuODU4IDM0Mi41MTUgTCAzMDAuODU4IDM0Mi41MTUgUSAzMDAuODU4IDMzOS4yMjcgMzAwLjE3NCAzMzguMDUxIFogXCJcbiAgICAgIC8+XG4gICAgICA8ZyBjbGFzc05hbWU9XCJwcm9wZWxsZXItZ3JvdXBcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5wcm9wZWxsZXJ9ICR7c3R5bGVzLnByb3BlbGxlckNXfWB9XG4gICAgICAgICAgc3R5bGU9e3sgYW5pbWF0aW9uOiBiUmlnaHRSb3RvckFuaW1hdGlvbiB9fVxuICAgICAgICAgIGQ9XCIgTSA0NjEuNTYzIDQxOC43NyBMIDQ2My45OTIgNDE2LjM0IFEgNDY1LjQ5NSA0MDcuMTE2IDQ2Ni40NjEgNDAwLjM5NSBDIDQ2Ny40MjYgMzkzLjY3NSA0NjkuMzYzIDM4OC4wODcgNDc0LjczMSAzODMuMjg0IFEgNTMzLjg2MiAzNDEuNTE0IDUzOC4xOTYgMzM4Ljg1OSBDIDU0Mi41MjkgMzM2LjIwMyA1NDguMzQ1IDMzNC4yOTkgNTUxLjQ5MiAzMzguMjkgQyA1NTQuNjM5IDM0Mi4yODIgNTUzLjQ4MSAzNDYuMDIgNTQ5LjQxOSAzNTAuMDgyIEwgNDcxLjE0NyA0MjguMzU0IEwgNDYxLjU2MyA0MTguNzcgWiAgTSA0MjcuNzI5IDQ3MS43NzIgTCA0MjUuMjk5IDQ3NC4yMDIgUSA0MjMuNzk3IDQ4My40MjYgNDIyLjgzMSA0OTAuMTQ2IEMgNDIxLjg2NiA0OTYuODY3IDQxOS45MjkgNTAyLjQ1NCA0MTQuNTYxIDUwNy4yNTcgUSAzNTUuNDMgNTQ5LjAyOCAzNTEuMDk2IDU1MS42ODMgQyAzNDYuNzYzIDU1NC4zMzggMzQwLjk0NyA1NTYuMjQzIDMzNy44IDU1Mi4yNTEgQyAzMzQuNjUzIDU0OC4yNiAzMzUuODExIDU0NC41MjIgMzM5Ljg3MyA1NDAuNDYgTCA0MTguMTQ1IDQ2Mi4xODcgTCA0MjcuNzI5IDQ3MS43NzIgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7c3R5bGVzLnByb3BlbGxlcn0gJHtzdHlsZXMucHJvcGVsbGVyQ0NXfWB9XG4gICAgICAgICAgc3R5bGU9e3sgYW5pbWF0aW9uOiBmUmlnaHRSb3RvckFuaW1hdGlvbiB9fVxuICAgICAgICAgIGQ9XCIgTSA0NjEuNTYzIDEzNS43NzMgTCA0NjMuOTkyIDEzOC4yMDMgUSA0NjUuNDk1IDE0Ny40MjYgNDY2LjQ2MSAxNTQuMTQ3IEMgNDY3LjQyNiAxNjAuODY4IDQ2OS4zNjMgMTY2LjQ1NSA0NzQuNzMxIDE3MS4yNTggUSA1MzMuODYyIDIxMy4wMjggNTM4LjE5NiAyMTUuNjg0IEMgNTQyLjUyOSAyMTguMzM5IDU0OC4zNDUgMjIwLjI0NCA1NTEuNDkyIDIxNi4yNTIgQyA1NTQuNjM5IDIxMi4yNiA1NTMuNDgxIDIwOC41MjMgNTQ5LjQxOSAyMDQuNDYgTCA0NzEuMTQ3IDEyNi4xODggTCA0NjEuNTYzIDEzNS43NzMgWiAgTSA0MjcuNzI5IDgyLjc3IEwgNDI1LjI5OSA4MC4zNCBRIDQyMy43OTcgNzEuMTE3IDQyMi44MzEgNjQuMzk2IEMgNDIxLjg2NiA1Ny42NzUgNDE5LjkyOSA1Mi4wODggNDE0LjU2MSA0Ny4yODUgUSAzNTUuNDMgNS41MTUgMzUxLjA5NiAyLjg1OSBDIDM0Ni43NjMgMC4yMDQgMzQwLjk0NyAtMS43MDEgMzM3LjggMi4yOTEgQyAzMzQuNjUzIDYuMjgyIDMzNS44MTEgMTAuMDIgMzM5Ljg3MyAxNC4wODIgTCA0MTguMTQ1IDkyLjM1NSBMIDQyNy43MjkgODIuNzcgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7c3R5bGVzLnByb3BlbGxlcn0gJHtzdHlsZXMucHJvcGVsbGVyQ0NXfWB9XG4gICAgICAgICAgc3R5bGU9e3sgYW5pbWF0aW9uOiBiTGVmdFJvdG9yQW5pbWF0aW9uIH19XG4gICAgICAgICAgZD1cIiBNIDEyNS41NjMgNDcxLjc3MiBMIDEyNy45OTMgNDc0LjIwMiBRIDEyOS40OTYgNDgzLjQyNiAxMzAuNDYxIDQ5MC4xNDYgQyAxMzEuNDI3IDQ5Ni44NjcgMTMzLjM2MyA1MDIuNDU0IDEzOC43MzEgNTA3LjI1NyBRIDE5Ny44NjMgNTQ5LjAyOCAyMDIuMTk2IDU1MS42ODMgQyAyMDYuNTMgNTU0LjMzOCAyMTIuMzQ1IDU1Ni4yNDMgMjE1LjQ5MiA1NTIuMjUxIEMgMjE4LjYzOSA1NDguMjYgMjE3LjQ4MiA1NDQuNTIyIDIxMy40MTkgNTQwLjQ2IEwgMTM1LjE0OCA0NjIuMTg3IEwgMTI1LjU2MyA0NzEuNzcyIFogIE0gOTEuNzMgNDE4Ljc3IEwgODkuMyA0MTYuMzQgUSA4Ny43OTcgNDA3LjExNiA4Ni44MzIgNDAwLjM5NSBDIDg1Ljg2NiAzOTMuNjc1IDgzLjkzIDM4OC4wODcgNzguNTYyIDM4My4yODQgUSAxOS40MzEgMzQxLjUxNCAxNS4wOTcgMzM4Ljg1OSBDIDEwLjc2MyAzMzYuMjAzIDQuOTQ4IDMzNC4yOTkgMS44MDEgMzM4LjI5IEMgLTEuMzQ2IDM0Mi4yODIgLTAuMTg5IDM0Ni4wMiAzLjg3NCAzNTAuMDgyIEwgODIuMTQ2IDQyOC4zNTQgTCA5MS43MyA0MTguNzcgWiBcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7c3R5bGVzLnByb3BlbGxlcn0gJHtzdHlsZXMucHJvcGVsbGVyQ1d9YH1cbiAgICAgICAgICBzdHlsZT17eyBhbmltYXRpb246IGZMZWZ0Um90b3JBbmltYXRpb24gfX1cbiAgICAgICAgICBkPVwiIE0gMTI1LjU2MyA4Mi43NyBMIDEyNy45OTMgODAuMzQgUSAxMjkuNDk2IDcxLjExNyAxMzAuNDYxIDY0LjM5NiBDIDEzMS40MjcgNTcuNjc1IDEzMy4zNjMgNTIuMDg4IDEzOC43MzEgNDcuMjg1IFEgMTk3Ljg2MyA1LjUxNSAyMDIuMTk2IDIuODU5IEMgMjA2LjUzIDAuMjA0IDIxMi4zNDUgLTEuNzAxIDIxNS40OTIgMi4yOTEgQyAyMTguNjM5IDYuMjgyIDIxNy40ODIgMTAuMDIgMjEzLjQxOSAxNC4wODMgTCAxMzUuMTQ3IDkyLjM1NSBMIDEyNS41NjMgODIuNzcgWiAgTSA5MS43MyAxMzUuNzczIEwgODkuMyAxMzguMjAzIFEgODcuNzk3IDE0Ny40MjYgODYuODMyIDE1NC4xNDcgQyA4NS44NjYgMTYwLjg2OCA4My45MyAxNjYuNDU1IDc4LjU2MiAxNzEuMjU4IFEgMTkuNDMxIDIxMy4wMjggMTUuMDk3IDIxNS42ODQgQyAxMC43NjMgMjE4LjMzOSA0Ljk0OCAyMjAuMjQzIDEuODAxIDIxNi4yNTIgQyAtMS4zNDYgMjEyLjI2IC0wLjE4OSAyMDguNTIzIDMuODc0IDIwNC40NiBMIDgyLjE0NiAxMjYuMTg4IEwgOTEuNzMgMTM1Ljc3MyBaIFwiXG4gICAgICAgIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZHJvbmVUb3BJdGVtOiBDYW52YXNFbGVtZW50SXRlbTxhbnksIGFueT4gPSB7XG4gIGlkOiAnZHJvbmVUb3AnLFxuICBuYW1lOiAnRHJvbmUgVG9wJyxcbiAgZGVzY3JpcHRpb246ICdEcm9uZSB0b3AnLFxuXG4gIGRpc3BsYXk6IERyb25lVG9wRGlzcGxheSxcblxuICBkZWZhdWx0U2l6ZToge1xuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiAxMDAsXG4gIH0sXG5cbiAgZ2V0TmV3T3B0aW9uczogKG9wdGlvbnMpID0+ICh7XG4gICAgLi4ub3B0aW9ucyxcbiAgfSksXG5cbiAgLy8gQ2FsbGVkIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHByZXBhcmVEYXRhOiAoY3R4OiBEaW1lbnNpb25Db250ZXh0LCBjZmc6IERyb25lVG9wQ29uZmlnKSA9PiB7XG4gICAgY29uc3QgZGF0YTogRHJvbmVUb3BEYXRhID0ge1xuICAgICAgYlJpZ2h0Um90b3JSUE06IGNmZz8uYlJpZ2h0Um90b3JSUE0gPyBjdHguZ2V0U2NhbGFyKGNmZy5iUmlnaHRSb3RvclJQTSkudmFsdWUoKSA6IDAsXG4gICAgICBiTGVmdFJvdG9yUlBNOiBjZmc/LmJMZWZ0Um90b3JSUE0gPyBjdHguZ2V0U2NhbGFyKGNmZy5iTGVmdFJvdG9yUlBNKS52YWx1ZSgpIDogMCxcbiAgICAgIGZSaWdodFJvdG9yUlBNOiBjZmc/LmZSaWdodFJvdG9yUlBNID8gY3R4LmdldFNjYWxhcihjZmcuZlJpZ2h0Um90b3JSUE0pLnZhbHVlKCkgOiAwLFxuICAgICAgZkxlZnRSb3RvclJQTTogY2ZnPy5mTGVmdFJvdG9yUlBNID8gY3R4LmdldFNjYWxhcihjZmcuZkxlZnRSb3RvclJQTSkudmFsdWUoKSA6IDAsXG4gICAgICB5YXdBbmdsZTogY2ZnPy55YXdBbmdsZSA/IGN0eC5nZXRTY2FsYXIoY2ZnLnlhd0FuZ2xlKS52YWx1ZSgpIDogMCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgcmVnaXN0ZXJPcHRpb25zVUk6IChidWlsZGVyKSA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBbJ0Ryb25lIFRvcCddO1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICd5YXdBbmdsZScsXG4gICAgICAgIHBhdGg6ICdjb25maWcueWF3QW5nbGUnLFxuICAgICAgICBuYW1lOiAnWWF3IEFuZ2xlJyxcbiAgICAgICAgZWRpdG9yOiBTY2FsYXJEaW1lbnNpb25FZGl0b3IsXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2ZSaWdodFJvdG9yUlBNJyxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy5mUmlnaHRSb3RvclJQTScsXG4gICAgICAgIG5hbWU6ICdGcm9udCBSaWdodCBSb3RvciBSUE0nLFxuICAgICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnZkxlZnRSb3RvclJQTScsXG4gICAgICAgIHBhdGg6ICdjb25maWcuZkxlZnRSb3RvclJQTScsXG4gICAgICAgIG5hbWU6ICdGcm9udCBMZWZ0IFJvdG9yIFJQTScsXG4gICAgICAgIGVkaXRvcjogU2NhbGFyRGltZW5zaW9uRWRpdG9yLFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdiUmlnaHRSb3RvclJQTScsXG4gICAgICAgIHBhdGg6ICdjb25maWcuYlJpZ2h0Um90b3JSUE0nLFxuICAgICAgICBuYW1lOiAnQmFjayBSaWdodCBSb3RvciBSUE0nLFxuICAgICAgICBlZGl0b3I6IFNjYWxhckRpbWVuc2lvbkVkaXRvcixcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnYkxlZnRSb3RvclJQTScsXG4gICAgICAgIHBhdGg6ICdjb25maWcuYkxlZnRSb3RvclJQTScsXG4gICAgICAgIG5hbWU6ICdCYWNrIExlZnQgUm90b3IgUlBNJyxcbiAgICAgICAgZWRpdG9yOiBTY2FsYXJEaW1lbnNpb25FZGl0b3IsXG4gICAgICB9KTtcbiAgfSxcbn07XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgcHJvcGVsbGVyOiBjc3NgXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwJTtcbiAgICB0cmFuc2Zvcm0tYm94OiBmaWxsLWJveDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBAa2V5ZnJhbWVzIHNwaW4ge1xuICAgICAgZnJvbSB7XG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICAgICAgfVxuICAgICAgdG8ge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgICAgfVxuICAgIH1cbiAgYCxcbiAgcHJvcGVsbGVyQ1c6IGNzc2BcbiAgICBhbmltYXRpb24tZGlyZWN0aW9uOiBub3JtYWw7XG4gIGAsXG4gIHByb3BlbGxlckNDVzogY3NzYFxuICAgIGFuaW1hdGlvbi1kaXJlY3Rpb246IHJldmVyc2U7XG4gIGAsXG59KTtcbiIsImltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5pbXBvcnQge1xuICBDb2xvckRpbWVuc2lvbkNvbmZpZyxcbiAgUmVzb3VyY2VEaW1lbnNpb25Db25maWcsXG4gIFJlc291cmNlRGltZW5zaW9uTW9kZSxcbiAgZ2V0UHVibGljT3JBYnNvbHV0ZVVybCxcbn0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMnO1xuaW1wb3J0IHsgQ29sb3JEaW1lbnNpb25FZGl0b3IsIFJlc291cmNlRGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycyc7XG5pbXBvcnQgU1ZHIGZyb20gJ3JlYWN0LWlubGluZXN2Zyc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgTGluZUNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IERpbWVuc2lvbkNvbnRleHQgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucy9jb250ZXh0JztcbmltcG9ydCB7IEFQSUVkaXRvciwgQVBJRWRpdG9yQ29uZmlnLCBjYWxsQXBpIH0gZnJvbSAnYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL2VkaXRvci9BUElFZGl0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIEljb25Db25maWcge1xuICBwYXRoPzogUmVzb3VyY2VEaW1lbnNpb25Db25maWc7XG4gIGZpbGw/OiBDb2xvckRpbWVuc2lvbkNvbmZpZztcbiAgc3Ryb2tlPzogTGluZUNvbmZpZztcbiAgYXBpPzogQVBJRWRpdG9yQ29uZmlnO1xufVxuXG5pbnRlcmZhY2UgSWNvbkRhdGEge1xuICBwYXRoOiBzdHJpbmc7XG4gIGZpbGw6IHN0cmluZztcbiAgc3Ryb2tlQ29sb3I/OiBzdHJpbmc7XG4gIHN0cm9rZT86IG51bWJlcjtcbiAgYXBpPzogQVBJRWRpdG9yQ29uZmlnO1xufVxuXG4vLyBXaGVuIGEgc3Rva2UgaXMgZGVmaW5lZCwgd2Ugd2FudCB0aGUgcGF0aCB0byBiZSBpbiBwYWdlIHVuaXRzXG5jb25zdCBzdmdTdHJva2VQYXRoQ2xhc3MgPSBjc3NgXG4gIHBhdGgge1xuICAgIHZlY3Rvci1lZmZlY3Q6IG5vbi1zY2FsaW5nLXN0cm9rZTtcbiAgfVxuYDtcblxuZXhwb3J0IGZ1bmN0aW9uIEljb25EaXNwbGF5KHByb3BzOiBDYW52YXNFbGVtZW50UHJvcHMpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkYXRhIH0gPSBwcm9wcztcbiAgaWYgKCFkYXRhPy5wYXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgIGlmIChkYXRhPy5hcGkpIHtcbiAgICAgIGNhbGxBcGkoZGF0YS5hcGkpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzdmdTdHlsZTogQ1NTUHJvcGVydGllcyA9IHtcbiAgICBmaWxsOiBkYXRhPy5maWxsLFxuICAgIHN0cm9rZTogZGF0YT8uc3Ryb2tlQ29sb3IsXG4gICAgc3Ryb2tlV2lkdGg6IGRhdGE/LnN0cm9rZSxcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTVkdcbiAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICBzcmM9e2RhdGEucGF0aH1cbiAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgc3R5bGU9e3N2Z1N0eWxlfVxuICAgICAgY2xhc3NOYW1lPXtzdmdTdHlsZS5zdHJva2VXaWR0aCA/IHN2Z1N0cm9rZVBhdGhDbGFzcyA6IHVuZGVmaW5lZH1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgY29uc3QgaWNvbkl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPEljb25Db25maWcsIEljb25EYXRhPiA9IHtcbiAgaWQ6ICdpY29uJyxcbiAgbmFtZTogJ0ljb24nLFxuICBkZXNjcmlwdGlvbjogJ1NWRyBJY29uIGRpc3BsYXknLFxuXG4gIGRpc3BsYXk6IEljb25EaXNwbGF5LFxuXG4gIGdldE5ld09wdGlvbnM6IChvcHRpb25zKSA9PiAoe1xuICAgIHBsYWNlbWVudDoge1xuICAgICAgd2lkdGg6IDUwLFxuICAgICAgaGVpZ2h0OiA1MCxcbiAgICB9LFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY29uZmlnOiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIG1vZGU6IFJlc291cmNlRGltZW5zaW9uTW9kZS5GaXhlZCxcbiAgICAgICAgZml4ZWQ6ICdpbWcvaWNvbnMvdW5pY29ucy9xdWVzdGlvbi1jaXJjbGUuc3ZnJyxcbiAgICAgIH0sXG4gICAgICBmaWxsOiB7IGZpeGVkOiAnI0ZGRjg5OScgfSxcbiAgICB9LFxuICB9KSxcblxuICAvLyBDYWxsZWQgd2hlbiBkYXRhIGNoYW5nZXNcbiAgcHJlcGFyZURhdGE6IChjdHg6IERpbWVuc2lvbkNvbnRleHQsIGNmZzogSWNvbkNvbmZpZykgPT4ge1xuICAgIGxldCBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZy5wYXRoKSB7XG4gICAgICBwYXRoID0gY3R4LmdldFJlc291cmNlKGNmZy5wYXRoKS52YWx1ZSgpO1xuICAgIH1cbiAgICBpZiAoIXBhdGggfHwgIWlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICBwYXRoID0gZ2V0UHVibGljT3JBYnNvbHV0ZVVybCgnaW1nL2ljb25zL3VuaWNvbnMvcXVlc3Rpb24tY2lyY2xlLnN2ZycpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGE6IEljb25EYXRhID0ge1xuICAgICAgcGF0aCxcbiAgICAgIGZpbGw6IGNmZy5maWxsID8gY3R4LmdldENvbG9yKGNmZy5maWxsKS52YWx1ZSgpIDogJyNDQ0MnLFxuICAgICAgYXBpOiBjZmc/LmFwaSA/PyB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIGlmIChjZmcuc3Ryb2tlPy53aWR0aCAmJiBjZmcuc3Ryb2tlLmNvbG9yKSB7XG4gICAgICBpZiAoY2ZnLnN0cm9rZS53aWR0aCA+IDApIHtcbiAgICAgICAgZGF0YS5zdHJva2UgPSBjZmcuc3Ryb2tlPy53aWR0aDtcbiAgICAgICAgZGF0YS5zdHJva2VDb2xvciA9IGN0eC5nZXRDb2xvcihjZmcuc3Ryb2tlLmNvbG9yKS52YWx1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICAvLyBIZWF0bWFwIG92ZXJsYXkgb3B0aW9uc1xuICByZWdpc3Rlck9wdGlvbnNVSTogKGJ1aWxkZXIpID0+IHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IFsnSWNvbiddO1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdpY29uU2VsZWN0b3InLFxuICAgICAgICBwYXRoOiAnY29uZmlnLnBhdGgnLFxuICAgICAgICBuYW1lOiAnU1ZHIFBhdGgnLFxuICAgICAgICBlZGl0b3I6IFJlc291cmNlRGltZW5zaW9uRWRpdG9yLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIHJlc291cmNlVHlwZTogJ2ljb24nLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdjb25maWcuZmlsbCcsXG4gICAgICAgIHBhdGg6ICdjb25maWcuZmlsbCcsXG4gICAgICAgIG5hbWU6ICdGaWxsIGNvbG9yJyxcbiAgICAgICAgZWRpdG9yOiBDb2xvckRpbWVuc2lvbkVkaXRvcixcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgICAgICAvLyBDb25maWd1cmVkIHZhbHVlc1xuICAgICAgICAgIGZpeGVkOiAnZ3JleScsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLmFkZFNsaWRlcklucHV0KHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIHBhdGg6ICdjb25maWcuc3Ryb2tlLndpZHRoJyxcbiAgICAgICAgbmFtZTogJ1N0cm9rZScsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMCxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgbWF4OiAxMCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICAuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIGlkOiAnY29uZmlnLnN0cm9rZS5jb2xvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcuc3Ryb2tlLmNvbG9yJyxcbiAgICAgICAgbmFtZTogJ1N0cm9rZSBjb2xvcicsXG4gICAgICAgIGVkaXRvcjogQ29sb3JEaW1lbnNpb25FZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICAgICAgLy8gQ29uZmlndXJlZCB2YWx1ZXNcbiAgICAgICAgICBmaXhlZDogJ2dyZXknLFxuICAgICAgICB9LFxuICAgICAgICBzaG93SWY6IChjZmcpID0+IEJvb2xlYW4oY2ZnPy5jb25maWc/LnN0cm9rZT8ud2lkdGgpLFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdhcGlTZWxlY3RvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcuYXBpJyxcbiAgICAgICAgbmFtZTogJ0FQSScsXG4gICAgICAgIGVkaXRvcjogQVBJRWRpdG9yLFxuICAgICAgfSk7XG4gIH0sXG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtLCBDYW52YXNFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9lbGVtZW50JztcblxuaW50ZXJmYWNlIE5vdEZvdW5kQ29uZmlnIHtcbiAgb3JpZz86IGFueTtcbn1cblxuY2xhc3MgTm90Rm91bmREaXNwbGF5IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxDYW52YXNFbGVtZW50UHJvcHM8Tm90Rm91bmRDb25maWc+PiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGgzPk5PVCBGT1VORDo8L2gzPlxuICAgICAgICA8cHJlPntKU09OLnN0cmluZ2lmeShjb25maWcsIG51bGwsIDIpfTwvcHJlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgbm90Rm91bmRJdGVtOiBDYW52YXNFbGVtZW50SXRlbTxOb3RGb3VuZENvbmZpZz4gPSB7XG4gIGlkOiAnbm90LWZvdW5kJyxcbiAgbmFtZTogJ05vdCBmb3VuZCcsXG4gIGRlc2NyaXB0aW9uOiAnRGlzcGxheSB3aGVuIGVsZW1lbnQgdHlwZSBpcyBub3QgZm91bmQgaW4gdGhlIHJlZ2lzdHJ5JyxcblxuICBkaXNwbGF5OiBOb3RGb3VuZERpc3BsYXksXG5cbiAgZGVmYXVsdFNpemU6IHtcbiAgICB3aWR0aDogMTAwLFxuICAgIGhlaWdodDogMTAwLFxuICB9LFxuXG4gIGdldE5ld09wdGlvbnM6ICgpID0+ICh7XG4gICAgY29uZmlnOiB7fSxcbiAgfSksXG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb2xvckRpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMvQ29sb3JEaW1lbnNpb25FZGl0b3InO1xuaW1wb3J0IHsgVGV4dERpbWVuc2lvbkVkaXRvciB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2VkaXRvcnMvVGV4dERpbWVuc2lvbkVkaXRvcic7XG5pbXBvcnQgeyBDb2xvckRpbWVuc2lvbkNvbmZpZywgVGV4dERpbWVuc2lvbkNvbmZpZyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL3R5cGVzJztcblxuaW1wb3J0IHsgQ2FudmFzRWxlbWVudEl0ZW0sIENhbnZhc0VsZW1lbnRQcm9wcyB9IGZyb20gJy4uL2VsZW1lbnQnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IHN0eWxlc0ZhY3RvcnkgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdhcHAvY29yZS9jb25maWcnO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zL2NvbnRleHQnO1xuXG5leHBvcnQgZW51bSBBbGlnbiB7XG4gIExlZnQgPSAnbGVmdCcsXG4gIENlbnRlciA9ICdjZW50ZXInLFxuICBSaWdodCA9ICdyaWdodCcsXG59XG5cbmV4cG9ydCBlbnVtIFZBbGlnbiB7XG4gIFRvcCA9ICd0b3AnLFxuICBNaWRkbGUgPSAnbWlkZGxlJyxcbiAgQm90dG9tID0gJ2JvdHRvbScsXG59XG5cbmludGVyZmFjZSBUZXh0Qm94RGF0YSB7XG4gIHRleHQ/OiBzdHJpbmc7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBzaXplPzogbnVtYmVyOyAvLyAwIG9yIG1pc3Npbmcgd2lsbCBcImF1dG8gc2l6ZVwiXG4gIGFsaWduOiBBbGlnbjtcbiAgdmFsaWduOiBWQWxpZ247XG59XG5cbmludGVyZmFjZSBUZXh0Qm94Q29uZmlnIHtcbiAgdGV4dD86IFRleHREaW1lbnNpb25Db25maWc7XG4gIGNvbG9yPzogQ29sb3JEaW1lbnNpb25Db25maWc7XG4gIHNpemU/OiBudW1iZXI7IC8vIDAgb3IgbWlzc2luZyB3aWxsIFwiYXV0byBzaXplXCJcbiAgYWxpZ246IEFsaWduO1xuICB2YWxpZ246IFZBbGlnbjtcbn1cblxuY2xhc3MgVGV4dEJveERpc3BsYXkgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PENhbnZhc0VsZW1lbnRQcm9wczxUZXh0Qm94Q29uZmlnLCBUZXh0Qm94RGF0YT4+IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXMoY29uZmlnLnRoZW1lMiwgZGF0YSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMuc3Bhbn0+e2RhdGE/LnRleHR9PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuY29uc3QgZ2V0U3R5bGVzID0gc3R5bGVzRmFjdG9yeSgodGhlbWU6IEdyYWZhbmFUaGVtZTIsIGRhdGEpID0+ICh7XG4gIGNvbnRhaW5lcjogY3NzYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogdGFibGU7XG4gIGAsXG4gIHNwYW46IGNzc2BcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIHZlcnRpY2FsLWFsaWduOiAke2RhdGEudmFsaWdufTtcbiAgICB0ZXh0LWFsaWduOiAke2RhdGEuYWxpZ259O1xuICAgIGZvbnQtc2l6ZTogJHtkYXRhPy5zaXplfXB4O1xuICAgIGNvbG9yOiAke2RhdGE/LmNvbG9yfTtcbiAgYCxcbn0pKTtcbmV4cG9ydCBjb25zdCB0ZXh0Qm94SXRlbTogQ2FudmFzRWxlbWVudEl0ZW08VGV4dEJveENvbmZpZywgVGV4dEJveERhdGE+ID0ge1xuICBpZDogJ3RleHQtYm94JyxcbiAgbmFtZTogJ1RleHQnLFxuICBkZXNjcmlwdGlvbjogJ1RleHQgYm94JyxcblxuICBkaXNwbGF5OiBUZXh0Qm94RGlzcGxheSxcblxuICBkZWZhdWx0U2l6ZToge1xuICAgIHdpZHRoOiAyNDAsXG4gICAgaGVpZ2h0OiAxNjAsXG4gIH0sXG5cbiAgZ2V0TmV3T3B0aW9uczogKG9wdGlvbnMpID0+ICh7XG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgZml4ZWQ6ICdncmV5JyxcbiAgICAgIH0sXG4gICAgfSxcbiAgICAuLi5vcHRpb25zLFxuICAgIGNvbmZpZzoge1xuICAgICAgYWxpZ246IEFsaWduLkxlZnQsXG4gICAgICB2YWxpZ246IFZBbGlnbi5NaWRkbGUsXG4gICAgfSxcbiAgfSksXG5cbiAgLy8gQ2FsbGVkIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHByZXBhcmVEYXRhOiAoY3R4OiBEaW1lbnNpb25Db250ZXh0LCBjZmc6IFRleHRCb3hDb25maWcpID0+IHtcbiAgICBjb25zdCBkYXRhOiBUZXh0Qm94RGF0YSA9IHtcbiAgICAgIHRleHQ6IGNmZy50ZXh0ID8gY3R4LmdldFRleHQoY2ZnLnRleHQpLnZhbHVlKCkgOiAnJyxcbiAgICAgIGFsaWduOiBjZmcuYWxpZ24gPz8gQWxpZ24uQ2VudGVyLFxuICAgICAgdmFsaWduOiBjZmcudmFsaWduID8/IFZBbGlnbi5NaWRkbGUsXG4gICAgICBzaXplOiBjZmcuc2l6ZSxcbiAgICB9O1xuXG4gICAgaWYgKGNmZy5jb2xvcikge1xuICAgICAgZGF0YS5jb2xvciA9IGN0eC5nZXRDb2xvcihjZmcuY29sb3IpLnZhbHVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgLy8gSGVhdG1hcCBvdmVybGF5IG9wdGlvbnNcbiAgcmVnaXN0ZXJPcHRpb25zVUk6IChidWlsZGVyKSA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnkgPSBbJ1RleHQgYm94J107XG4gICAgYnVpbGRlclxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ3RleHRTZWxlY3RvcicsXG4gICAgICAgIHBhdGg6ICdjb25maWcudGV4dCcsXG4gICAgICAgIG5hbWU6ICdUZXh0JyxcbiAgICAgICAgZWRpdG9yOiBUZXh0RGltZW5zaW9uRWRpdG9yLFxuICAgICAgfSlcbiAgICAgIC5hZGRDdXN0b21FZGl0b3Ioe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgaWQ6ICdjb25maWcuY29sb3InLFxuICAgICAgICBwYXRoOiAnY29uZmlnLmNvbG9yJyxcbiAgICAgICAgbmFtZTogJ1RleHQgY29sb3InLFxuICAgICAgICBlZGl0b3I6IENvbG9yRGltZW5zaW9uRWRpdG9yLFxuICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgIGRlZmF1bHRWYWx1ZToge30sXG4gICAgICB9KVxuICAgICAgLmFkZFJhZGlvKHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIHBhdGg6ICdjb25maWcuYWxpZ24nLFxuICAgICAgICBuYW1lOiAnQWxpZ24gdGV4dCcsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgb3B0aW9uczogW1xuICAgICAgICAgICAgeyB2YWx1ZTogQWxpZ24uTGVmdCwgbGFiZWw6ICdMZWZ0JyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogQWxpZ24uQ2VudGVyLCBsYWJlbDogJ0NlbnRlcicgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IEFsaWduLlJpZ2h0LCBsYWJlbDogJ1JpZ2h0JyB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogQWxpZ24uTGVmdCxcbiAgICAgIH0pXG4gICAgICAuYWRkUmFkaW8oe1xuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgcGF0aDogJ2NvbmZpZy52YWxpZ24nLFxuICAgICAgICBuYW1lOiAnVmVydGljYWwgYWxpZ24nLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgIHsgdmFsdWU6IFZBbGlnbi5Ub3AsIGxhYmVsOiAnVG9wJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogVkFsaWduLk1pZGRsZSwgbGFiZWw6ICdNaWRkbGUnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiBWQWxpZ24uQm90dG9tLCBsYWJlbDogJ0JvdHRvbScgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFZBbGlnbi5NaWRkbGUsXG4gICAgICB9KVxuICAgICAgLmFkZE51bWJlcklucHV0KHtcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIHBhdGg6ICdjb25maWcuc2l6ZScsXG4gICAgICAgIG5hbWU6ICdUZXh0IHNpemUnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnQXV0bycsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgfSxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgRkMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHsgU2NhbGFyRGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycyc7XG5pbXBvcnQgeyBDYW52YXNFbGVtZW50SXRlbSwgQ2FudmFzRWxlbWVudFByb3BzIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5pbXBvcnQgeyBEaW1lbnNpb25Db250ZXh0LCBTY2FsYXJEaW1lbnNpb25Db25maWcgfSBmcm9tICdhcHAvZmVhdHVyZXMvZGltZW5zaW9ucyc7XG5cbmludGVyZmFjZSBXaW5kVHVyYmluZURhdGEge1xuICBycG0/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBXaW5kVHVyYmluZUNvbmZpZyB7XG4gIHJwbT86IFNjYWxhckRpbWVuc2lvbkNvbmZpZztcbn1cblxuY29uc3QgV2luZFR1cmJpbmVEaXNwbGF5OiBGQzxDYW52YXNFbGVtZW50UHJvcHM8V2luZFR1cmJpbmVDb25maWcsIFdpbmRUdXJiaW5lRGF0YT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICBjb25zdCB7IGRhdGEgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHdpbmRUdXJiaW5lQW5pbWF0aW9uID0gYHNwaW4gJHtkYXRhPy5ycG0gPyA2MCAvIE1hdGguYWJzKGRhdGEucnBtKSA6IDB9cyBsaW5lYXIgaW5maW5pdGVgO1xuXG4gIHJldHVybiAoXG4gICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDE4OS4zMjYgMjgzLjk4OVwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XG4gICAgICA8c3ltYm9sIGlkPVwiYmxhZGVcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBmaWxsPVwiI2U2ZTZlNlwiXG4gICAgICAgICAgaWQ9XCJibGFkZS1mcm9udFwiXG4gICAgICAgICAgZD1cIk0xNC42NDkxODc5LDEuODUwMTE2MDEgQzE0LjI2ODQ0NTUsLTAuMDUzNTk2Mjg3NyAxMC43MTUwODEyLC0wLjgxNTA4MTIwNiA5LjA2NDczMzE4LDMuMzczMDg1ODUgTDAuNDM0MzM4NzQ3LDcwLjc2NTg5MzMgTDguOTM4MDUxMDQsOTEuOTYwNzg4OSBMMTUuNDEwNjcyOSw5MC40Mzc4MTkgTDE3LjU2ODQ0NTUsNzguMzgwNzQyNSBMMTQuNTIxODA5NywxLjk3Njc5ODE0IEwxNC42NDkxODc5LDEuODUwMTE2MDEgWlwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZmlsbD1cIiNkMGQ2ZDdcIlxuICAgICAgICAgIGlkPVwiYmxhZGUtc2lkZVwiXG4gICAgICAgICAgZD1cIk0xMS4wOTUxMjc2LDAuNTgxMjA2NDk3IEMxMC4zMzM2NDI3LDAuOTYxOTQ4OTU2IDkuNTcyMTU3NzcsMS44NTAxMTYwMSA4LjkzNzM1NDk5LDMuMjQ2NDAzNzEgTDAuMzA2OTYwNTU3LDcwLjYzOTIxMTEgTDguODEwNjcyODUsOTEuODM0MTA2NyBMMy4zNTM1OTYyOSw3MC4wMDQ0MDg0IEwxMS4wOTUxMjc2LDAuNTgxMjA2NDk3IFpcIlxuICAgICAgICAvPlxuICAgICAgPC9zeW1ib2w+XG5cbiAgICAgIDxnPlxuICAgICAgICA8ZyBpZD1cInN0cnVjdHVyZVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg1OC4xMjMsIDgyLjY2NClcIiBmaWxsUnVsZT1cIm5vbnplcm9cIj5cbiAgICAgICAgICA8cG9seWdvbiBpZD1cInRvd2VyXCIgZmlsbD1cIiNlNmU2ZTZcIiBwb2ludHM9XCIzMy4xMTEsMTAuOTg0IDM5Ljk2NSwxMC45ODQgNDQuMjgsMTk2LjE3NiAyOC43OTYsMTk2LjE3NlwiIC8+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGlkPVwieWF3XCJcbiAgICAgICAgICAgIGZpbGw9XCJyZ2JhKDAsMCwwLDAuMjUpXCJcbiAgICAgICAgICAgIGQ9XCJNNDAuMzQ1NDc1NiwyMy4yOTQ4OTU2IEw0MC43MjYyMTgxLDM0Ljg0NDU0NzYgQzM4LjgyMjUwNTgsMzUuMDk4NjA3OSAzNS43NzY1NjYxLDM1LjA5ODYwNzkgMzIuMzQ5ODg0LDM0LjMzNzEyMyBMMzIuNzMwNjI2NSwyMy4yOTU1OTE2IEw0MC4zNDU0NzU2LDIzLjI5NTU5MTYgTDQwLjM0NTQ3NTYsMjMuMjk0ODk1NiBaXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBpZD1cImJhc2VcIlxuICAgICAgICAgICAgZmlsbD1cIiNkMGQ2ZDdcIlxuICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAgNDIpXCJcbiAgICAgICAgICAgIGQ9XCJNMjYuMzg0Njg2OCwxNTAuNTkxNjQ3IEw0Ni41NjQwMzcxLDE1MC41OTE2NDcgQzQ4Ljg0ODQ5MTksMTUwLjU5MTY0NyA1MC43NTIyMDQyLDE1Mi40OTUzNiA1MC43NTIyMDQyLDE1NC43Nzk4MTQgTDUwLjc1MjIwNDIsMTU4Ljk2Nzk4MSBMMjIuMDY5MTQxNSwxNTguOTY3OTgxIEwyMi4wNjkxNDE1LDE1NC43Nzk4MTQgQzIyLjA2OTE0MTUsMTUyLjQ5NTM2IDIzLjk3Mjg1MzgsMTUwLjU5MTY0NyAyNi4yNTczMDg2LDE1MC41OTE2NDcgTDI2LjM4NDY4NjgsMTUwLjU5MTY0NyBaXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxjaXJjbGUgaWQ9XCJuYWNlbGxlXCIgZmlsbD1cIiNlNmU2ZTZcIiBjeD1cIjM2LjU0XCIgY3k9XCIxMlwiIHI9XCIxMS45M1wiIC8+XG4gICAgICAgICAgPGNpcmNsZSBpZD1cImdlYXJib3hcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiNkMGQ2ZDdcIiBzdHJva2VXaWR0aD1cIjIuNzVcIiBjeD1cIjM2LjUzOFwiIGN5PVwiMTEuOTk5XCIgcj1cIjUuOFwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgICAgPGcgY2xhc3NOYW1lPXtzdHlsZXMuYmxhZGV9IHN0eWxlPXt7IGFuaW1hdGlvbjogd2luZFR1cmJpbmVBbmltYXRpb24gfX0+XG4gICAgICAgICAgPHVzZSBpZD1cImJsYWRlMVwiIGhyZWY9XCIjYmxhZGVcIiB4PVwiODMuMjRcIiB5PVwiMFwiIC8+XG4gICAgICAgICAgPHVzZSBpZD1cImJsYWRlMlwiIGhyZWY9XCIjYmxhZGVcIiB4PVwiODMuMjRcIiB5PVwiMFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxMjAgOTQuNjYzIDk0LjY2MylcIiAvPlxuICAgICAgICAgIDx1c2UgaWQ9XCJibGFkZTNcIiBocmVmPVwiI2JsYWRlXCIgeD1cIjgzLjI0XCIgeT1cIjBcIiB0cmFuc2Zvcm09XCJyb3RhdGUoLTEyMCA5NC42NjMgOTQuNjYzKVwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB3aW5kVHVyYmluZUl0ZW06IENhbnZhc0VsZW1lbnRJdGVtPGFueSwgYW55PiA9IHtcbiAgaWQ6ICd3aW5kVHVyYmluZScsXG4gIG5hbWU6ICdXaW5kIFR1cmJpbmUnLFxuICBkZXNjcmlwdGlvbjogJ1NwaW5ueSBzcGlubnknLFxuXG4gIGRpc3BsYXk6IFdpbmRUdXJiaW5lRGlzcGxheSxcblxuICBkZWZhdWx0U2l6ZToge1xuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiAxMDAsXG4gIH0sXG5cbiAgZ2V0TmV3T3B0aW9uczogKG9wdGlvbnMpID0+ICh7XG4gICAgLi4ub3B0aW9ucyxcbiAgfSksXG5cbiAgLy8gQ2FsbGVkIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHByZXBhcmVEYXRhOiAoY3R4OiBEaW1lbnNpb25Db250ZXh0LCBjZmc6IFdpbmRUdXJiaW5lQ29uZmlnKSA9PiB7XG4gICAgY29uc3QgZGF0YTogV2luZFR1cmJpbmVEYXRhID0ge1xuICAgICAgcnBtOiBjZmc/LnJwbSA/IGN0eC5nZXRTY2FsYXIoY2ZnLnJwbSkudmFsdWUoKSA6IDAsXG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIHJlZ2lzdGVyT3B0aW9uc1VJOiAoYnVpbGRlcikgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydXaW5kIFR1cmJpbmUnXTtcbiAgICBidWlsZGVyLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICBjYXRlZ29yeSxcbiAgICAgIGlkOiAncnBtJyxcbiAgICAgIHBhdGg6ICdjb25maWcucnBtJyxcbiAgICAgIG5hbWU6ICdSUE0nLFxuICAgICAgZWRpdG9yOiBTY2FsYXJEaW1lbnNpb25FZGl0b3IsXG4gICAgfSk7XG4gIH0sXG59O1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+ICh7XG4gIGJsYWRlOiBjc3NgXG4gICAgQGtleWZyYW1lcyBzcGluIHtcbiAgICAgIGZyb20ge1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgICAgIH1cbiAgICAgIHRvIHtcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiA5NC42NjNweCA5NC42NjNweDtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxNWRlZyk7XG4gIGAsXG59KTtcbiIsImV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50JztcbmV4cG9ydCB7IENhbnZhc0dyb3VwT3B0aW9ucyB9IGZyb20gJy4vZ3JvdXAnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWdpc3RyeSc7XG4iLCJpbXBvcnQgeyBSZWdpc3RyeSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQ2FudmFzRWxlbWVudEl0ZW0sIENhbnZhc0VsZW1lbnRPcHRpb25zIH0gZnJvbSAnLi9lbGVtZW50JztcbmltcG9ydCB7IGJ1dHRvbkl0ZW0gfSBmcm9tICcuL2VsZW1lbnRzL2J1dHRvbic7XG5pbXBvcnQgeyBkcm9uZUZyb250SXRlbSB9IGZyb20gJy4vZWxlbWVudHMvZHJvbmVGcm9udCc7XG5pbXBvcnQgeyBkcm9uZVNpZGVJdGVtIH0gZnJvbSAnLi9lbGVtZW50cy9kcm9uZVNpZGUnO1xuaW1wb3J0IHsgZHJvbmVUb3BJdGVtIH0gZnJvbSAnLi9lbGVtZW50cy9kcm9uZVRvcCc7XG5pbXBvcnQgeyBpY29uSXRlbSB9IGZyb20gJy4vZWxlbWVudHMvaWNvbic7XG5pbXBvcnQgeyB0ZXh0Qm94SXRlbSB9IGZyb20gJy4vZWxlbWVudHMvdGV4dEJveCc7XG5pbXBvcnQgeyB3aW5kVHVyYmluZUl0ZW0gfSBmcm9tICcuL2VsZW1lbnRzL3dpbmRUdXJiaW5lJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0FOVkFTX0VMRU1FTlRfQ09ORklHOiBDYW52YXNFbGVtZW50T3B0aW9ucyA9IHtcbiAgLi4uaWNvbkl0ZW0uZ2V0TmV3T3B0aW9ucygpLFxuICB0eXBlOiBpY29uSXRlbS5pZCxcbiAgbmFtZTogYEVsZW1lbnQgMWAsXG59O1xuXG5leHBvcnQgY29uc3QgY2FudmFzRWxlbWVudFJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5PENhbnZhc0VsZW1lbnRJdGVtPigoKSA9PiBbXG4gIGljb25JdGVtLCAvLyBkZWZhdWx0IGZvciBub3dcbiAgdGV4dEJveEl0ZW0sXG4gIGJ1dHRvbkl0ZW0sXG4gIGRyb25lVG9wSXRlbSxcbiAgZHJvbmVGcm9udEl0ZW0sXG4gIGRyb25lU2lkZUl0ZW0sXG4gIHdpbmRUdXJiaW5lSXRlbSxcbl0pO1xuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBPbkRyYWcsIE9uUmVzaXplIH0gZnJvbSAncmVhY3QtbW92ZWFibGUvZGVjbGFyYXRpb24vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBCYWNrZ3JvdW5kSW1hZ2VTaXplLFxuICBDYW52YXNFbGVtZW50SXRlbSxcbiAgQ2FudmFzRWxlbWVudE9wdGlvbnMsXG4gIGNhbnZhc0VsZW1lbnRSZWdpc3RyeSxcbiAgUGxhY2VtZW50LFxuICBBbmNob3IsXG59IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcbmltcG9ydCB7IG5vdEZvdW5kSXRlbSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvbm90Rm91bmQnO1xuaW1wb3J0IHsgR3JvdXBTdGF0ZSB9IGZyb20gJy4vZ3JvdXAnO1xuaW1wb3J0IHsgTGF5ZXJFbGVtZW50IH0gZnJvbSAnYXBwL2NvcmUvY29tcG9uZW50cy9MYXllcnMvdHlwZXMnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICcuL3NjZW5lJztcblxubGV0IGNvdW50ZXIgPSAwO1xuXG5leHBvcnQgY2xhc3MgRWxlbWVudFN0YXRlIGltcGxlbWVudHMgTGF5ZXJFbGVtZW50IHtcbiAgLy8gVUlEIG5lY2Vzc2FyeSBmb3IgbW92ZWFibGUgdG8gd29yayAoZm9yIG5vdylcbiAgcmVhZG9ubHkgVUlEID0gY291bnRlcisrO1xuICByZXZJZCA9IDA7XG4gIHNpemVTdHlsZTogQ1NTUHJvcGVydGllcyA9IHt9O1xuICBkYXRhU3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7fTtcblxuICAvLyBGaWxsZWQgaW4gYnkgcmVmXG4gIGRpdj86IEhUTUxEaXZFbGVtZW50O1xuXG4gIC8vIENhbGN1bGF0ZWRcbiAgd2lkdGggPSAxMDA7XG4gIGhlaWdodCA9IDEwMDtcbiAgZGF0YT86IGFueTsgLy8gZGVwZW5kcyBvbiB0aGUgdHlwZVxuXG4gIC8vIEZyb20gb3B0aW9ucywgYnV0IGFsd2F5cyBzZXQgYW5kIGFsd2F5cyB2YWxpZFxuICBhbmNob3I6IEFuY2hvcjtcbiAgcGxhY2VtZW50OiBQbGFjZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGl0ZW06IENhbnZhc0VsZW1lbnRJdGVtLCBwdWJsaWMgb3B0aW9uczogQ2FudmFzRWxlbWVudE9wdGlvbnMsIHB1YmxpYyBwYXJlbnQ/OiBHcm91cFN0YXRlKSB7XG4gICAgY29uc3QgZmFsbGJhY2tOYW1lID0gYEVsZW1lbnQgJHtEYXRlLm5vdygpfWA7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7IHR5cGU6IGl0ZW0uaWQsIG5hbWU6IGZhbGxiYWNrTmFtZSB9O1xuICAgIH1cbiAgICB0aGlzLmFuY2hvciA9IG9wdGlvbnMuYW5jaG9yID8/IHt9O1xuICAgIHRoaXMucGxhY2VtZW50ID0gb3B0aW9ucy5wbGFjZW1lbnQgPz8ge307XG4gICAgb3B0aW9ucy5hbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICBvcHRpb25zLnBsYWNlbWVudCA9IHRoaXMucGxhY2VtZW50O1xuXG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLmdldFNjZW5lKCk7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgIGNvbnN0IG5ld05hbWUgPSBzY2VuZT8uZ2V0TmV4dEVsZW1lbnROYW1lKCk7XG4gICAgICBvcHRpb25zLm5hbWUgPSBuZXdOYW1lID8/IGZhbGxiYWNrTmFtZTtcbiAgICB9XG4gICAgc2NlbmU/LmJ5TmFtZS5zZXQob3B0aW9ucy5uYW1lLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U2NlbmUoKTogU2NlbmUgfCB1bmRlZmluZWQge1xuICAgIGxldCB0cmF2ID0gdGhpcy5wYXJlbnQ7XG4gICAgd2hpbGUgKHRyYXYpIHtcbiAgICAgIGlmICh0cmF2LmlzUm9vdCgpKSB7XG4gICAgICAgIHJldHVybiB0cmF2LnNjZW5lO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYXYgPSB0cmF2LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5hbWU7XG4gIH1cblxuICB2YWxpZGF0ZVBsYWNlbWVudCgpIHtcbiAgICBjb25zdCB7IGFuY2hvciwgcGxhY2VtZW50IH0gPSB0aGlzO1xuICAgIGlmICghKGFuY2hvci5sZWZ0IHx8IGFuY2hvci5yaWdodCkpIHtcbiAgICAgIGFuY2hvci5sZWZ0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEoYW5jaG9yLnRvcCB8fCBhbmNob3IuYm90dG9tKSkge1xuICAgICAgYW5jaG9yLnRvcCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgdyA9IHBsYWNlbWVudC53aWR0aCA/PyAxMDA7IC8vIHRoaXMuZGl2ID8gdGhpcy5kaXYuY2xpZW50V2lkdGggOiB0aGlzLndpZHRoO1xuICAgIGNvbnN0IGggPSBwbGFjZW1lbnQuaGVpZ2h0ID8/IDEwMDsgLy8gdGhpcy5kaXYgPyB0aGlzLmRpdi5jbGllbnRIZWlnaHQgOiB0aGlzLmhlaWdodDtcblxuICAgIGlmIChhbmNob3IudG9wKSB7XG4gICAgICBpZiAoIXBsYWNlbWVudC50b3ApIHtcbiAgICAgICAgcGxhY2VtZW50LnRvcCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoYW5jaG9yLmJvdHRvbSkge1xuICAgICAgICBkZWxldGUgcGxhY2VtZW50LmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBsYWNlbWVudC5oZWlnaHQgPSBoO1xuICAgICAgICBkZWxldGUgcGxhY2VtZW50LmJvdHRvbTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFuY2hvci5ib3R0b20pIHtcbiAgICAgIGlmICghcGxhY2VtZW50LmJvdHRvbSkge1xuICAgICAgICBwbGFjZW1lbnQuYm90dG9tID0gMDtcbiAgICAgIH1cbiAgICAgIHBsYWNlbWVudC5oZWlnaHQgPSBoO1xuICAgICAgZGVsZXRlIHBsYWNlbWVudC50b3A7XG4gICAgfVxuXG4gICAgaWYgKGFuY2hvci5sZWZ0KSB7XG4gICAgICBpZiAoIXBsYWNlbWVudC5sZWZ0KSB7XG4gICAgICAgIHBsYWNlbWVudC5sZWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChhbmNob3IucmlnaHQpIHtcbiAgICAgICAgZGVsZXRlIHBsYWNlbWVudC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBsYWNlbWVudC53aWR0aCA9IHc7XG4gICAgICAgIGRlbGV0ZSBwbGFjZW1lbnQucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbmNob3IucmlnaHQpIHtcbiAgICAgIGlmICghcGxhY2VtZW50LnJpZ2h0KSB7XG4gICAgICAgIHBsYWNlbWVudC5yaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBwbGFjZW1lbnQud2lkdGggPSB3O1xuICAgICAgZGVsZXRlIHBsYWNlbWVudC5sZWZ0O1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSB3O1xuICAgIHRoaXMuaGVpZ2h0ID0gaDtcblxuICAgIHRoaXMub3B0aW9ucy5hbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID0gdGhpcy5wbGFjZW1lbnQ7XG4gIH1cblxuICAvLyBUaGUgcGFyZW50IHNpemUsIG5lZWQgdG8gc2V0IG91ciBvd24gc2l6ZSBiYXNlZCBvbiBvZmZzZXRzXG4gIHVwZGF0ZVNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy52YWxpZGF0ZVBsYWNlbWVudCgpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBDU1MgcG9zaXRpb25cbiAgICB0aGlzLnNpemVTdHlsZSA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlRGF0YShjdHg6IERpbWVuc2lvbkNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5pdGVtLnByZXBhcmVEYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSB0aGlzLml0ZW0ucHJlcGFyZURhdGEoY3R4LCB0aGlzLm9wdGlvbnMuY29uZmlnKTtcbiAgICAgIHRoaXMucmV2SWQrKzsgLy8gcmVyZW5kZXJcbiAgICB9XG5cbiAgICBjb25zdCB7IGJhY2tncm91bmQsIGJvcmRlciB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNzczogQ1NTUHJvcGVydGllcyA9IHt9O1xuICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICBpZiAoYmFja2dyb3VuZC5jb2xvcikge1xuICAgICAgICBjb25zdCBjb2xvciA9IGN0eC5nZXRDb2xvcihiYWNrZ3JvdW5kLmNvbG9yKTtcbiAgICAgICAgY3NzLmJhY2tncm91bmRDb2xvciA9IGNvbG9yLnZhbHVlKCk7XG4gICAgICB9XG4gICAgICBpZiAoYmFja2dyb3VuZC5pbWFnZSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGN0eC5nZXRSZXNvdXJjZShiYWNrZ3JvdW5kLmltYWdlKTtcbiAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgY29uc3QgdiA9IGltYWdlLnZhbHVlKCk7XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKFwiJHt2fVwiKWA7XG4gICAgICAgICAgICBzd2l0Y2ggKGJhY2tncm91bmQuc2l6ZSA/PyBCYWNrZ3JvdW5kSW1hZ2VTaXplLkNvbnRhaW4pIHtcbiAgICAgICAgICAgICAgY2FzZSBCYWNrZ3JvdW5kSW1hZ2VTaXplLkNvbnRhaW46XG4gICAgICAgICAgICAgICAgY3NzLmJhY2tncm91bmRTaXplID0gJ2NvbnRhaW4nO1xuICAgICAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmFja2dyb3VuZEltYWdlU2l6ZS5Db3ZlcjpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFNpemUgPSAnY292ZXInO1xuICAgICAgICAgICAgICAgIGNzcy5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmFja2dyb3VuZEltYWdlU2l6ZS5PcmlnaW5hbDpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFJlcGVhdCA9ICduby1yZXBlYXQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJhY2tncm91bmRJbWFnZVNpemUuVGlsZTpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFJlcGVhdCA9ICdyZXBlYXQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJhY2tncm91bmRJbWFnZVNpemUuRmlsbDpcbiAgICAgICAgICAgICAgICBjc3MuYmFja2dyb3VuZFNpemUgPSAnMTAwJSAxMDAlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm9yZGVyICYmIGJvcmRlci5jb2xvciAmJiBib3JkZXIud2lkdGgpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gY3R4LmdldENvbG9yKGJvcmRlci5jb2xvcik7XG4gICAgICBjc3MuYm9yZGVyV2lkdGggPSBib3JkZXIud2lkdGg7XG4gICAgICBjc3MuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICAgICAgY3NzLmJvcmRlckNvbG9yID0gY29sb3IudmFsdWUoKTtcblxuICAgICAgLy8gTW92ZSB0aGUgaW1hZ2UgdG8gaW5zaWRlIHRoZSBib3JkZXJcbiAgICAgIGlmIChjc3MuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgIGNzcy5iYWNrZ3JvdW5kT3JpZ2luID0gJ3BhZGRpbmctYm94JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRhdGFTdHlsZSA9IGNzcztcbiAgfVxuXG4gIC8qKiBSZWN1cnNpdmVseSB2aXNpdCBhbGwgbm9kZXMgKi9cbiAgdmlzaXQodmlzaXRvcjogKHY6IEVsZW1lbnRTdGF0ZSkgPT4gdm9pZCkge1xuICAgIHZpc2l0b3IodGhpcyk7XG4gIH1cblxuICBvbkNoYW5nZShvcHRpb25zOiBDYW52YXNFbGVtZW50T3B0aW9ucykge1xuICAgIGlmICh0aGlzLml0ZW0uaWQgIT09IG9wdGlvbnMudHlwZSkge1xuICAgICAgdGhpcy5pdGVtID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LmdldElmRXhpc3RzKG9wdGlvbnMudHlwZSkgPz8gbm90Rm91bmRJdGVtO1xuICAgIH1cblxuICAgIC8vIHJlbmFtZSBoYW5kbGluZ1xuICAgIGNvbnN0IG9sZE5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICBjb25zdCBuZXdOYW1lID0gb3B0aW9ucy5uYW1lO1xuXG4gICAgdGhpcy5yZXZJZCsrO1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIGxldCB0cmF2ID0gdGhpcy5wYXJlbnQ7XG4gICAgd2hpbGUgKHRyYXYpIHtcbiAgICAgIGlmICh0cmF2LmlzUm9vdCgpKSB7XG4gICAgICAgIHRyYXYuc2NlbmUuc2F2ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYXYucmV2SWQrKztcbiAgICAgIHRyYXYgPSB0cmF2LnBhcmVudDtcbiAgICB9XG5cbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICBpZiAob2xkTmFtZSAhPT0gbmV3TmFtZSAmJiBzY2VuZSkge1xuICAgICAgc2NlbmUuYnlOYW1lLmRlbGV0ZShvbGROYW1lKTtcbiAgICAgIHNjZW5lLmJ5TmFtZS5zZXQobmV3TmFtZSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U2F2ZU1vZGVsKCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMub3B0aW9ucyB9O1xuICB9XG5cbiAgaW5pdEVsZW1lbnQgPSAodGFyZ2V0OiBIVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMuZGl2ID0gdGFyZ2V0O1xuICB9O1xuXG4gIGFwcGx5RHJhZyA9IChldmVudDogT25EcmFnKSA9PiB7XG4gICAgY29uc3QgeyBwbGFjZW1lbnQsIGFuY2hvciB9ID0gdGhpcztcblxuICAgIGNvbnN0IGRlbHRhWCA9IGV2ZW50LmRlbHRhWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IGV2ZW50LmRlbHRhWzFdO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBldmVudC50YXJnZXQuc3R5bGU7XG4gICAgaWYgKGFuY2hvci50b3ApIHtcbiAgICAgIHBsYWNlbWVudC50b3AhICs9IGRlbHRhWTtcbiAgICAgIHN0eWxlLnRvcCA9IGAke3BsYWNlbWVudC50b3B9cHhgO1xuICAgIH1cbiAgICBpZiAoYW5jaG9yLmJvdHRvbSkge1xuICAgICAgcGxhY2VtZW50LmJvdHRvbSEgLT0gZGVsdGFZO1xuICAgICAgc3R5bGUuYm90dG9tID0gYCR7cGxhY2VtZW50LmJvdHRvbX1weGA7XG4gICAgfVxuICAgIGlmIChhbmNob3IubGVmdCkge1xuICAgICAgcGxhY2VtZW50LmxlZnQhICs9IGRlbHRhWDtcbiAgICAgIHN0eWxlLmxlZnQgPSBgJHtwbGFjZW1lbnQubGVmdH1weGA7XG4gICAgfVxuICAgIGlmIChhbmNob3IucmlnaHQpIHtcbiAgICAgIHBsYWNlbWVudC5yaWdodCEgLT0gZGVsdGFYO1xuICAgICAgc3R5bGUucmlnaHQgPSBgJHtwbGFjZW1lbnQucmlnaHR9cHhgO1xuICAgIH1cbiAgfTtcblxuICAvLyBraW5kYSBsaWtlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hLWVkZ2UtYXBwL2Jsb2IvbWFpbi9zcmMvcGFuZWxzL2RyYXcvV3JhcEl0ZW0udHN4I0w0NFxuICBhcHBseVJlc2l6ZSA9IChldmVudDogT25SZXNpemUpID0+IHtcbiAgICBjb25zdCB7IHBsYWNlbWVudCwgYW5jaG9yIH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBldmVudC50YXJnZXQuc3R5bGU7XG4gICAgY29uc3QgZGVsdGFYID0gZXZlbnQuZGVsdGFbMF07XG4gICAgY29uc3QgZGVsdGFZID0gZXZlbnQuZGVsdGFbMV07XG4gICAgY29uc3QgZGlyTFIgPSBldmVudC5kaXJlY3Rpb25bMF07XG4gICAgY29uc3QgZGlyVEIgPSBldmVudC5kaXJlY3Rpb25bMV07XG4gICAgaWYgKGRpckxSID09PSAxKSB7XG4gICAgICAvLyBSSUdIVFxuICAgICAgaWYgKGFuY2hvci5yaWdodCkge1xuICAgICAgICBwbGFjZW1lbnQucmlnaHQhIC09IGRlbHRhWDtcbiAgICAgICAgc3R5bGUucmlnaHQgPSBgJHtwbGFjZW1lbnQucmlnaHR9cHhgO1xuICAgICAgICBpZiAoIWFuY2hvci5sZWZ0KSB7XG4gICAgICAgICAgcGxhY2VtZW50LndpZHRoID0gZXZlbnQud2lkdGg7XG4gICAgICAgICAgc3R5bGUud2lkdGggPSBgJHtwbGFjZW1lbnQud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGFjZW1lbnQud2lkdGghID0gZXZlbnQud2lkdGg7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7cGxhY2VtZW50LndpZHRofXB4YDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpckxSID09PSAtMSkge1xuICAgICAgLy8gTEVGVFxuICAgICAgaWYgKGFuY2hvci5sZWZ0KSB7XG4gICAgICAgIHBsYWNlbWVudC5sZWZ0ISAtPSBkZWx0YVg7XG4gICAgICAgIHBsYWNlbWVudC53aWR0aCEgPSBldmVudC53aWR0aDtcbiAgICAgICAgc3R5bGUubGVmdCA9IGAke3BsYWNlbWVudC5sZWZ0fXB4YDtcbiAgICAgICAgc3R5bGUud2lkdGggPSBgJHtwbGFjZW1lbnQud2lkdGh9cHhgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGxhY2VtZW50LndpZHRoISArPSBkZWx0YVg7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7cGxhY2VtZW50LndpZHRofXB4YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyVEIgPT09IC0xKSB7XG4gICAgICAvLyBUT1BcbiAgICAgIGlmIChhbmNob3IudG9wKSB7XG4gICAgICAgIHBsYWNlbWVudC50b3AhIC09IGRlbHRhWTtcbiAgICAgICAgcGxhY2VtZW50LmhlaWdodCA9IGV2ZW50LmhlaWdodDtcbiAgICAgICAgc3R5bGUudG9wID0gYCR7cGxhY2VtZW50LnRvcH1weGA7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGAke3BsYWNlbWVudC5oZWlnaHR9cHhgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGxhY2VtZW50LmhlaWdodCA9IGV2ZW50LmhlaWdodDtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7cGxhY2VtZW50LmhlaWdodH1weGA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJUQiA9PT0gMSkge1xuICAgICAgLy8gQk9UVE9NXG4gICAgICBpZiAoYW5jaG9yLmJvdHRvbSkge1xuICAgICAgICBwbGFjZW1lbnQuYm90dG9tISAtPSBkZWx0YVk7XG4gICAgICAgIHBsYWNlbWVudC5oZWlnaHQhID0gZXZlbnQuaGVpZ2h0O1xuICAgICAgICBzdHlsZS5ib3R0b20gPSBgJHtwbGFjZW1lbnQuYm90dG9tfXB4YDtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7cGxhY2VtZW50LmhlaWdodH1weGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGFjZW1lbnQuaGVpZ2h0ISA9IGV2ZW50LmhlaWdodDtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7cGxhY2VtZW50LmhlaWdodH1weGA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IGV2ZW50LndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gZXZlbnQuaGVpZ2h0O1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGl0ZW0gfSA9IHRoaXM7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYga2V5PXtgJHt0aGlzLlVJRH1gfSBzdHlsZT17eyAuLi50aGlzLnNpemVTdHlsZSwgLi4udGhpcy5kYXRhU3R5bGUgfX0gcmVmPXt0aGlzLmluaXRFbGVtZW50fT5cbiAgICAgICAgPGl0ZW0uZGlzcGxheVxuICAgICAgICAgIGtleT17YCR7dGhpcy5VSUR9LyR7dGhpcy5yZXZJZH1gfVxuICAgICAgICAgIGNvbmZpZz17dGhpcy5vcHRpb25zLmNvbmZpZ31cbiAgICAgICAgICB3aWR0aD17dGhpcy53aWR0aH1cbiAgICAgICAgICBoZWlnaHQ9e3RoaXMuaGVpZ2h0fVxuICAgICAgICAgIGRhdGE9e3RoaXMuZGF0YX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDYW52YXNHcm91cE9wdGlvbnMsIGNhbnZhc0VsZW1lbnRSZWdpc3RyeSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuaW1wb3J0IHsgRGltZW5zaW9uQ29udGV4dCB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kaW1lbnNpb25zJztcbmltcG9ydCB7IG5vdEZvdW5kSXRlbSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvZWxlbWVudHMvbm90Rm91bmQnO1xuaW1wb3J0IHsgRWxlbWVudFN0YXRlIH0gZnJvbSAnLi9lbGVtZW50JztcbmltcG9ydCB7IENhbnZhc0VsZW1lbnRJdGVtIH0gZnJvbSAnLi4vZWxlbWVudCc7XG5pbXBvcnQgeyBMYXllckFjdGlvbklEIH0gZnJvbSAnYXBwL3BsdWdpbnMvcGFuZWwvY2FudmFzL3R5cGVzJztcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJy4vc2NlbmUnO1xuaW1wb3J0IHsgUm9vdEVsZW1lbnQgfSBmcm9tICcuL3Jvb3QnO1xuXG5leHBvcnQgY29uc3QgZ3JvdXBJdGVtRHVtbXk6IENhbnZhc0VsZW1lbnRJdGVtID0ge1xuICBpZDogJ2dyb3VwJyxcbiAgbmFtZTogJ0dyb3VwJyxcbiAgZGVzY3JpcHRpb246ICdHcm91cCcsXG5cbiAgZ2V0TmV3T3B0aW9uczogKCkgPT4gKHtcbiAgICBjb25maWc6IHt9LFxuICB9KSxcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gIGRpc3BsYXk6ICgpID0+IHtcbiAgICByZXR1cm4gPGRpdj5HUk9VUCE8L2Rpdj47XG4gIH0sXG59O1xuXG5leHBvcnQgY2xhc3MgR3JvdXBTdGF0ZSBleHRlbmRzIEVsZW1lbnRTdGF0ZSB7XG4gIGVsZW1lbnRzOiBFbGVtZW50U3RhdGVbXSA9IFtdO1xuICBzY2VuZTogU2NlbmU7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG9wdGlvbnM6IENhbnZhc0dyb3VwT3B0aW9ucywgc2NlbmU6IFNjZW5lLCBwdWJsaWMgcGFyZW50PzogR3JvdXBTdGF0ZSkge1xuICAgIHN1cGVyKGdyb3VwSXRlbUR1bW15LCBvcHRpb25zLCBwYXJlbnQpO1xuXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuXG4gICAgLy8gbXV0YXRlIG9wdGlvbnMgb2JqZWN0XG4gICAgbGV0IHsgZWxlbWVudHMgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudHMgPSBlbGVtZW50cyA9IFtdO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYyBvZiBlbGVtZW50cykge1xuICAgICAgaWYgKGMudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2gobmV3IEdyb3VwU3RhdGUoYyBhcyBDYW52YXNHcm91cE9wdGlvbnMsIHNjZW5lLCB0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpdGVtID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LmdldElmRXhpc3RzKGMudHlwZSkgPz8gbm90Rm91bmRJdGVtO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2gobmV3IEVsZW1lbnRTdGF0ZShpdGVtLCBjLCB0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNSb290KCk6IHRoaXMgaXMgUm9vdEVsZW1lbnQge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZSBwYXJlbnQgc2l6ZSwgbmVlZCB0byBzZXQgb3VyIG93biBzaXplIGJhc2VkIG9uIG9mZnNldHNcbiAgdXBkYXRlU2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHN1cGVyLnVwZGF0ZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLnNpemVTdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5zaXplU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjaGlsZHJlbiB3aXRoIGNhbGN1bGF0ZWQgc2l6ZVxuICAgIGZvciAoY29uc3QgZWxlbSBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICBlbGVtLnVwZGF0ZVNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIFRoZSBncm91cCBmb3JjZWQgdG8gZnVsbCB3aWR0aCAoZm9yIG5vdylcbiAgICB0aGlzLnNpemVTdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuc2l6ZVN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNpemVTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIH1cblxuICB1cGRhdGVEYXRhKGN0eDogRGltZW5zaW9uQ29udGV4dCkge1xuICAgIHN1cGVyLnVwZGF0ZURhdGEoY3R4KTtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbS51cGRhdGVEYXRhKGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlZCBpbiB0aGUgbGF5ZXIgZWRpdG9yXG4gIHJlb3JkZXIoc3RhcnRJbmRleDogbnVtYmVyLCBlbmRJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnRzKTtcbiAgICBjb25zdCBbcmVtb3ZlZF0gPSByZXN1bHQuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgIHJlc3VsdC5zcGxpY2UoZW5kSW5kZXgsIDAsIHJlbW92ZWQpO1xuICAgIHRoaXMuZWxlbWVudHMgPSByZXN1bHQ7XG5cbiAgICB0aGlzLnJlaW5pdGlhbGl6ZU1vdmVhYmxlKCk7XG4gIH1cblxuICByZWluaXRpYWxpemVNb3ZlYWJsZSgpIHtcbiAgICAvLyBOZWVkIHRvIGZpcnN0IGNsZWFyIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCB0aGVuIHJlLWluaXQgbW92ZWFibGUgd2l0aCBzbGlnaHQgZGVsYXlcbiAgICB0aGlzLnNjZW5lLmNsZWFyQ3VycmVudFNlbGVjdGlvbigpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zY2VuZS5pbml0TW92ZWFibGUodHJ1ZSksIDEwMCk7XG4gIH1cblxuICAvLyA/Pz8gb3Igc2hvdWxkIHRoaXMgYmUgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHk/XG4gIC8vIGFyZSBhY3Rpb25zIHNjb3BlZCB0byBsYXllcnM/XG4gIGRvQWN0aW9uID0gKGFjdGlvbjogTGF5ZXJBY3Rpb25JRCwgZWxlbWVudDogRWxlbWVudFN0YXRlLCB1cGRhdGVOYW1lID0gdHJ1ZSkgPT4ge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIExheWVyQWN0aW9uSUQuRGVsZXRlOlxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5maWx0ZXIoKGUpID0+IGUgIT09IGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNjZW5lLmJ5TmFtZS5kZWxldGUoZWxlbWVudC5vcHRpb25zLm5hbWUpO1xuICAgICAgICB0aGlzLnNjZW5lLnNhdmUoKTtcbiAgICAgICAgdGhpcy5yZWluaXRpYWxpemVNb3ZlYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGF5ZXJBY3Rpb25JRC5EdXBsaWNhdGU6XG4gICAgICAgIGlmIChlbGVtZW50Lml0ZW0uaWQgPT09ICdncm91cCcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2FuIG5vdCBkdXBsaWNhdGUgZ3JvdXBzICh5ZXQpJywgYWN0aW9uLCBlbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IGNsb25lRGVlcChlbGVtZW50Lm9wdGlvbnMpO1xuICAgICAgICBpZiAoZWxlbWVudC5hbmNob3IudG9wKSB7XG4gICAgICAgICAgb3B0cy5wbGFjZW1lbnQhLnRvcCEgKz0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuYW5jaG9yLmxlZnQpIHtcbiAgICAgICAgICBvcHRzLnBsYWNlbWVudCEubGVmdCEgKz0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuYW5jaG9yLmJvdHRvbSkge1xuICAgICAgICAgIG9wdHMucGxhY2VtZW50IS5ib3R0b20hICs9IDEwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LmFuY2hvci5yaWdodCkge1xuICAgICAgICAgIG9wdHMucGxhY2VtZW50IS5yaWdodCEgKz0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IEVsZW1lbnRTdGF0ZShlbGVtZW50Lml0ZW0sIG9wdHMsIHRoaXMpO1xuICAgICAgICBjb3B5LnVwZGF0ZVNpemUoZWxlbWVudC53aWR0aCwgZWxlbWVudC5oZWlnaHQpO1xuICAgICAgICBjb3B5LnVwZGF0ZURhdGEodGhpcy5zY2VuZS5jb250ZXh0KTtcbiAgICAgICAgaWYgKHVwZGF0ZU5hbWUpIHtcbiAgICAgICAgICBjb3B5Lm9wdGlvbnMubmFtZSA9IHRoaXMuc2NlbmUuZ2V0TmV4dEVsZW1lbnROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKGNvcHkpO1xuICAgICAgICB0aGlzLnNjZW5lLmJ5TmFtZS5zZXQoY29weS5vcHRpb25zLm5hbWUsIGNvcHkpO1xuICAgICAgICB0aGlzLnNjZW5lLnNhdmUoKTtcbiAgICAgICAgdGhpcy5yZWluaXRpYWxpemVNb3ZlYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUubG9nKCdETyBhY3Rpb24nLCBhY3Rpb24sIGVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBrZXk9e2Ake3RoaXMuVUlEfS8ke3RoaXMucmV2SWR9YH0gc3R5bGU9e3sgLi4udGhpcy5zaXplU3R5bGUsIC4uLnRoaXMuZGF0YVN0eWxlIH19PlxuICAgICAgICB7dGhpcy5lbGVtZW50cy5tYXAoKHYpID0+IHYucmVuZGVyKCkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8qKiBSZWN1cnNpdmVseSB2aXNpdCBhbGwgbm9kZXMgKi9cbiAgdmlzaXQodmlzaXRvcjogKHY6IEVsZW1lbnRTdGF0ZSkgPT4gdm9pZCkge1xuICAgIHN1cGVyLnZpc2l0KHZpc2l0b3IpO1xuICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICB2aXNpdG9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIGdldFNhdmVNb2RlbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMubWFwKCh2KSA9PiB2LmdldFNhdmVNb2RlbCgpKSxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBDYW52YXNHcm91cE9wdGlvbnMsIENhbnZhc0VsZW1lbnRPcHRpb25zIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQgeyBHcm91cFN0YXRlIH0gZnJvbSAnLi9ncm91cCc7XG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJy4vc2NlbmUnO1xuXG5leHBvcnQgY2xhc3MgUm9vdEVsZW1lbnQgZXh0ZW5kcyBHcm91cFN0YXRlIHtcbiAgY29uc3RydWN0b3IocHVibGljIG9wdGlvbnM6IENhbnZhc0dyb3VwT3B0aW9ucywgcHVibGljIHNjZW5lOiBTY2VuZSwgcHJpdmF0ZSBjaGFuZ2VDYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICAgIHN1cGVyKG9wdGlvbnMsIHNjZW5lKTtcbiAgfVxuXG4gIGlzUm9vdCgpOiB0aGlzIGlzIFJvb3RFbGVtZW50IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRoZSBwYXJlbnQgc2l6ZSBpcyBhbHdheXMgZnVsbHNpemVcbiAgdXBkYXRlU2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHN1cGVyLnVwZGF0ZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2l6ZVN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5zaXplU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgLy8gcm9vdCB0eXBlIGNhbiBub3QgY2hhbmdlXG4gIG9uQ2hhbmdlKG9wdGlvbnM6IENhbnZhc0VsZW1lbnRPcHRpb25zKSB7XG4gICAgdGhpcy5yZXZJZCsrO1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9IGFzIENhbnZhc0dyb3VwT3B0aW9ucztcbiAgICB0aGlzLmNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cblxuICBnZXRTYXZlTW9kZWwoKTogQ2FudmFzR3JvdXBPcHRpb25zIHtcbiAgICBjb25zdCB7IHBsYWNlbWVudCwgYW5jaG9yLCAuLi5yZXN0IH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdCwgLy8gZXZlcnl0aGluZyBleGNlcHQgcGxhY2VtZW50ICYgYW5jaG9yXG4gICAgICBlbGVtZW50czogdGhpcy5lbGVtZW50cy5tYXAoKHYpID0+IHYuZ2V0U2F2ZU1vZGVsKCkpLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IFJlcGxheVN1YmplY3QsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IE1vdmVhYmxlIGZyb20gJ21vdmVhYmxlJztcbmltcG9ydCBTZWxlY3RvIGZyb20gJ3NlbGVjdG8nO1xuXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdhcHAvY29yZS9jb25maWcnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgUGFuZWxEYXRhIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBzdHlsZXNGYWN0b3J5IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgQW5jaG9yLCBDYW52YXNHcm91cE9wdGlvbnMsIERFRkFVTFRfQ0FOVkFTX0VMRU1FTlRfQ09ORklHLCBQbGFjZW1lbnQgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCB7XG4gIENvbG9yRGltZW5zaW9uQ29uZmlnLFxuICBSZXNvdXJjZURpbWVuc2lvbkNvbmZpZyxcbiAgU2NhbGVEaW1lbnNpb25Db25maWcsXG4gIFRleHREaW1lbnNpb25Db25maWcsXG4gIERpbWVuc2lvbkNvbnRleHQsXG4gIFNjYWxhckRpbWVuc2lvbkNvbmZpZyxcbn0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMnO1xuaW1wb3J0IHtcbiAgZ2V0Q29sb3JEaW1lbnNpb25Gcm9tRGF0YSxcbiAgZ2V0U2NhbGVEaW1lbnNpb25Gcm9tRGF0YSxcbiAgZ2V0UmVzb3VyY2VEaW1lbnNpb25Gcm9tRGF0YSxcbiAgZ2V0VGV4dERpbWVuc2lvbkZyb21EYXRhLFxuICBnZXRTY2FsYXJEaW1lbnNpb25Gcm9tRGF0YSxcbn0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvdXRpbHMnO1xuaW1wb3J0IHsgRWxlbWVudFN0YXRlIH0gZnJvbSAnLi9lbGVtZW50JztcbmltcG9ydCB7IFJvb3RFbGVtZW50IH0gZnJvbSAnLi9yb290JztcbmltcG9ydCB7IEdyb3VwU3RhdGUgfSBmcm9tICcuL2dyb3VwJztcbmltcG9ydCB7IExheWVyQWN0aW9uSUQgfSBmcm9tICdhcHAvcGx1Z2lucy9wYW5lbC9jYW52YXMvdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvblBhcmFtcyB7XG4gIHRhcmdldHM6IEFycmF5PEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD47XG4gIGdyb3VwPzogR3JvdXBTdGF0ZTtcbn1cblxuZXhwb3J0IGNsYXNzIFNjZW5lIHtcbiAgc3R5bGVzID0gZ2V0U3R5bGVzKGNvbmZpZy50aGVtZTIpO1xuICByZWFkb25seSBzZWxlY3Rpb24gPSBuZXcgUmVwbGF5U3ViamVjdDxFbGVtZW50U3RhdGVbXT4oMSk7XG4gIHJlYWRvbmx5IG1vdmVkID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpOyAvLyBjYWxsZWQgYWZ0ZXIgcmVzaXplL2RyYWcgZm9yIGVkaXRvciB1cGRhdGVzXG4gIHJlYWRvbmx5IGJ5TmFtZSA9IG5ldyBNYXA8c3RyaW5nLCBFbGVtZW50U3RhdGU+KCk7XG4gIHJvb3Q6IFJvb3RFbGVtZW50O1xuXG4gIHJldklkID0gMDtcblxuICB3aWR0aCA9IDA7XG4gIGhlaWdodCA9IDA7XG4gIHN0eWxlOiBDU1NQcm9wZXJ0aWVzID0ge307XG4gIGRhdGE/OiBQYW5lbERhdGE7XG4gIHNlbGVjdG8/OiBTZWxlY3RvO1xuICBtb3ZlYWJsZT86IE1vdmVhYmxlO1xuICBkaXY/OiBIVE1MRGl2RWxlbWVudDtcbiAgY3VycmVudExheWVyPzogR3JvdXBTdGF0ZTtcblxuICBjb25zdHJ1Y3RvcihjZmc6IENhbnZhc0dyb3VwT3B0aW9ucywgZW5hYmxlRWRpdGluZzogYm9vbGVhbiwgcHVibGljIG9uU2F2ZTogKGNmZzogQ2FudmFzR3JvdXBPcHRpb25zKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5yb290ID0gdGhpcy5sb2FkKGNmZywgZW5hYmxlRWRpdGluZyk7XG4gIH1cblxuICBnZXROZXh0RWxlbWVudE5hbWUgPSAoaXNHcm91cCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSBpc0dyb3VwID8gJ0dyb3VwJyA6ICdFbGVtZW50JztcbiAgICBsZXQgaWR4ID0gdGhpcy5ieU5hbWUuc2l6ZSArIDE7XG5cbiAgICBjb25zdCBtYXggPSBpZHggKyAxMDA7XG4gICAgd2hpbGUgKHRydWUgJiYgaWR4IDwgbWF4KSB7XG4gICAgICBjb25zdCBuYW1lID0gYCR7bGFiZWx9ICR7aWR4Kyt9YDtcbiAgICAgIGlmICghdGhpcy5ieU5hbWUuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBgJHtsYWJlbH0gJHtEYXRlLm5vdygpfWA7XG4gIH07XG5cbiAgY2FuUmVuYW1lID0gKHY6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiAhdGhpcy5ieU5hbWUuaGFzKHYpO1xuICB9O1xuXG4gIGxvYWQoY2ZnOiBDYW52YXNHcm91cE9wdGlvbnMsIGVuYWJsZUVkaXRpbmc6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdEVsZW1lbnQoXG4gICAgICBjZmcgPz8ge1xuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuICAgICAgICBlbGVtZW50czogW0RFRkFVTFRfQ0FOVkFTX0VMRU1FTlRfQ09ORklHXSxcbiAgICAgIH0sXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5zYXZlIC8vIGNhbGxiYWNrIHdoZW4gY2hhbmdlcyBhcmUgbWFkZVxuICAgICk7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAvLyBJZiBlZGl0aW5nIGlzIGVuYWJsZWQsIGNsZWFyIHNlbGVjdG8gaW5zdGFuY2VcbiAgICAgICAgY29uc3QgZGVzdHJveVNlbGVjdG8gPSBlbmFibGVFZGl0aW5nO1xuICAgICAgICB0aGlzLmluaXRNb3ZlYWJsZShkZXN0cm95U2VsZWN0bywgZW5hYmxlRWRpdGluZyk7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgICByZXR1cm4gdGhpcy5yb290O1xuICB9XG5cbiAgY29udGV4dDogRGltZW5zaW9uQ29udGV4dCA9IHtcbiAgICBnZXRDb2xvcjogKGNvbG9yOiBDb2xvckRpbWVuc2lvbkNvbmZpZykgPT4gZ2V0Q29sb3JEaW1lbnNpb25Gcm9tRGF0YSh0aGlzLmRhdGEsIGNvbG9yKSxcbiAgICBnZXRTY2FsZTogKHNjYWxlOiBTY2FsZURpbWVuc2lvbkNvbmZpZykgPT4gZ2V0U2NhbGVEaW1lbnNpb25Gcm9tRGF0YSh0aGlzLmRhdGEsIHNjYWxlKSxcbiAgICBnZXRTY2FsYXI6IChzY2FsYXI6IFNjYWxhckRpbWVuc2lvbkNvbmZpZykgPT4gZ2V0U2NhbGFyRGltZW5zaW9uRnJvbURhdGEodGhpcy5kYXRhLCBzY2FsYXIpLFxuICAgIGdldFRleHQ6ICh0ZXh0OiBUZXh0RGltZW5zaW9uQ29uZmlnKSA9PiBnZXRUZXh0RGltZW5zaW9uRnJvbURhdGEodGhpcy5kYXRhLCB0ZXh0KSxcbiAgICBnZXRSZXNvdXJjZTogKHJlczogUmVzb3VyY2VEaW1lbnNpb25Db25maWcpID0+IGdldFJlc291cmNlRGltZW5zaW9uRnJvbURhdGEodGhpcy5kYXRhLCByZXMpLFxuICB9O1xuXG4gIHVwZGF0ZURhdGEoZGF0YTogUGFuZWxEYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnJvb3QudXBkYXRlRGF0YSh0aGlzLmNvbnRleHQpO1xuICB9XG5cbiAgdXBkYXRlU2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnN0eWxlID0geyB3aWR0aCwgaGVpZ2h0IH07XG4gICAgdGhpcy5yb290LnVwZGF0ZVNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAodGhpcy5zZWxlY3RvPy5nZXRTZWxlY3RlZFRhcmdldHMoKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2xlYXJDdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgZ3JvdXBTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24ucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRzKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50TGF5ZXIgPSBjdXJyZW50U2VsZWN0ZWRFbGVtZW50c1swXS5wYXJlbnQhO1xuXG4gICAgICBjb25zdCBuZXdMYXllciA9IG5ldyBHcm91cFN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgICBuYW1lOiB0aGlzLmdldE5leHRFbGVtZW50TmFtZSh0cnVlKSxcbiAgICAgICAgICBlbGVtZW50czogW10sXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGN1cnJlbnRTZWxlY3RlZEVsZW1lbnRzWzBdLnBhcmVudFxuICAgICAgKTtcblxuICAgICAgY3VycmVudFNlbGVjdGVkRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudDogRWxlbWVudFN0YXRlKSA9PiB7XG4gICAgICAgIGN1cnJlbnRMYXllci5kb0FjdGlvbihMYXllckFjdGlvbklELkRlbGV0ZSwgZWxlbWVudCk7XG4gICAgICAgIG5ld0xheWVyLmRvQWN0aW9uKExheWVyQWN0aW9uSUQuRHVwbGljYXRlLCBlbGVtZW50LCBmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgY3VycmVudExheWVyLmVsZW1lbnRzLnB1c2gobmV3TGF5ZXIpO1xuXG4gICAgICB0aGlzLmJ5TmFtZS5zZXQobmV3TGF5ZXIuZ2V0TmFtZSgpLCBuZXdMYXllcik7XG5cbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJDdXJyZW50U2VsZWN0aW9uKCkge1xuICAgIGxldCBldmVudDogTW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KCdjbGljaycpO1xuICAgIHRoaXMuc2VsZWN0bz8uY2xpY2tUYXJnZXQoZXZlbnQsIHRoaXMuZGl2KTtcbiAgfVxuXG4gIHVwZGF0ZUN1cnJlbnRMYXllcihuZXdMYXllcjogR3JvdXBTdGF0ZSkge1xuICAgIHRoaXMuY3VycmVudExheWVyID0gbmV3TGF5ZXI7XG4gICAgdGhpcy5jbGVhckN1cnJlbnRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnNhdmUoKTtcbiAgfVxuXG4gIHRvZ2dsZUFuY2hvcihlbGVtZW50OiBFbGVtZW50U3RhdGUsIGs6IGtleW9mIEFuY2hvcikge1xuICAgIGNvbnN0IHsgZGl2IH0gPSBlbGVtZW50O1xuICAgIGlmICghZGl2KSB7XG4gICAgICBjb25zb2xlLmxvZygnTm90IHJlYWR5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdyA9IGVsZW1lbnQucGFyZW50Py53aWR0aCA/PyAxMDA7XG4gICAgY29uc3QgaCA9IGVsZW1lbnQucGFyZW50Py5oZWlnaHQgPz8gMTAwO1xuXG4gICAgLy8gR2V0IGNvbXB1dGVkIHBvc2l0aW9uLi4uLlxuICAgIGNvbnN0IGluZm8gPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIGdldEVsZW1lbnRJbmZvKGRpdiwgZWxlbWVudC5wYXJlbnQ/LmRpdik7XG4gICAgY29uc29sZS5sb2coJ0RJViBpbmZvJywgZGl2KTtcblxuICAgIGNvbnN0IHBsYWNlbWVudDogUGxhY2VtZW50ID0ge1xuICAgICAgdG9wOiBpbmZvLnRvcCxcbiAgICAgIGxlZnQ6IGluZm8ubGVmdCxcbiAgICAgIHdpZHRoOiBpbmZvLndpZHRoLFxuICAgICAgaGVpZ2h0OiBpbmZvLmhlaWdodCxcbiAgICAgIGJvdHRvbTogaCAtIGluZm8uYm90dG9tLFxuICAgICAgcmlnaHQ6IHcgLSBpbmZvLnJpZ2h0LFxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZygnUFBQJywgcGxhY2VtZW50KTtcblxuICAgIC8vIC8vIFRPRE86IG5lZWRzIHRvIHJlY2FsY3VsYXRlIHBsYWNlbWVudCBiYXNlZCBvbiBhYnNvbHV0ZSB2YWx1ZXMuLi5cbiAgICAvLyBlbGVtZW50LmFuY2hvcltrXSA9ICFCb29sZWFuKGVsZW1lbnQuYW5jaG9yW2tdKTtcbiAgICAvLyBlbGVtZW50LnBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAvLyBlbGVtZW50LnZhbGlkYXRlUGxhY2VtZW50KCk7XG4gICAgLy8gZWxlbWVudC5yZXZJZCsrO1xuICAgIC8vIHRoaXMucmV2SWQrKztcbiAgICAvLyAgICB0aGlzLnNhdmUoKTtcblxuICAgIHRoaXMubW92ZWQubmV4dChEYXRlLm5vdygpKTtcbiAgfVxuXG4gIHNhdmUgPSAoKSA9PiB7XG4gICAgdGhpcy5vblNhdmUodGhpcy5yb290LmdldFNhdmVNb2RlbCgpKTtcbiAgfTtcblxuICBwcml2YXRlIGZpbmRFbGVtZW50QnlUYXJnZXQgPSAodGFyZ2V0OiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpOiBFbGVtZW50U3RhdGUgfCB1bmRlZmluZWQgPT4ge1xuICAgIC8vIFdlIHdpbGwgcHJvYmFibHkgd2FudCB0byBhZGQgbWVtb2l6YXRpb24gdG8gdGhpcyBhcyB3ZSBhcmUgY2FsbGluZyBvbiBkcmFnIC8gcmVzaXplXG5cbiAgICBjb25zdCBzdGFjayA9IFsuLi50aGlzLnJvb3QuZWxlbWVudHNdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IHN0YWNrLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChjdXJyZW50RWxlbWVudCAmJiBjdXJyZW50RWxlbWVudC5kaXYgJiYgY3VycmVudEVsZW1lbnQuZGl2ID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXN0ZWRFbGVtZW50cyA9IGN1cnJlbnRFbGVtZW50IGluc3RhbmNlb2YgR3JvdXBTdGF0ZSA/IGN1cnJlbnRFbGVtZW50LmVsZW1lbnRzIDogW107XG4gICAgICBmb3IgKGNvbnN0IG5lc3RlZEVsZW1lbnQgb2YgbmVzdGVkRWxlbWVudHMpIHtcbiAgICAgICAgc3RhY2sudW5zaGlmdChuZXN0ZWRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHNldFJlZiA9IChzY2VuZUNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICB0aGlzLmRpdiA9IHNjZW5lQ29udGFpbmVyO1xuICB9O1xuXG4gIHNlbGVjdCA9IChzZWxlY3Rpb246IFNlbGVjdGlvblBhcmFtcykgPT4ge1xuICAgIGlmICh0aGlzLnNlbGVjdG8pIHtcbiAgICAgIHRoaXMuc2VsZWN0by5zZXRTZWxlY3RlZFRhcmdldHMoc2VsZWN0aW9uLnRhcmdldHMpO1xuICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSB1cGRhdGVTZWxlY3Rpb24gPSAoc2VsZWN0aW9uOiBTZWxlY3Rpb25QYXJhbXMpID0+IHtcbiAgICB0aGlzLm1vdmVhYmxlIS50YXJnZXQgPSBzZWxlY3Rpb24udGFyZ2V0cztcblxuICAgIGlmIChzZWxlY3Rpb24uZ3JvdXApIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLm5leHQoW3NlbGVjdGlvbi5ncm91cF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzID0gc2VsZWN0aW9uLnRhcmdldHMubWFwKCh0KSA9PiB0aGlzLmZpbmRFbGVtZW50QnlUYXJnZXQodCkhKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLm5leHQocyk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgZ2VuZXJhdGVUYXJnZXRFbGVtZW50cyA9IChyb290RWxlbWVudHM6IEVsZW1lbnRTdGF0ZVtdKTogSFRNTERpdkVsZW1lbnRbXSA9PiB7XG4gICAgbGV0IHRhcmdldEVsZW1lbnRzOiBIVE1MRGl2RWxlbWVudFtdID0gW107XG5cbiAgICBjb25zdCBzdGFjayA9IFsuLi5yb290RWxlbWVudHNdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IHN0YWNrLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChjdXJyZW50RWxlbWVudCAmJiBjdXJyZW50RWxlbWVudC5kaXYpIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudHMucHVzaChjdXJyZW50RWxlbWVudC5kaXYpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXN0ZWRFbGVtZW50cyA9IGN1cnJlbnRFbGVtZW50IGluc3RhbmNlb2YgR3JvdXBTdGF0ZSA/IGN1cnJlbnRFbGVtZW50LmVsZW1lbnRzIDogW107XG4gICAgICBmb3IgKGNvbnN0IG5lc3RlZEVsZW1lbnQgb2YgbmVzdGVkRWxlbWVudHMpIHtcbiAgICAgICAgc3RhY2sudW5zaGlmdChuZXN0ZWRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0RWxlbWVudHM7XG4gIH07XG5cbiAgaW5pdE1vdmVhYmxlID0gKGRlc3Ryb3lTZWxlY3RvID0gZmFsc2UsIGFsbG93Q2hhbmdlcyA9IHRydWUpID0+IHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50cyA9IHRoaXMuZ2VuZXJhdGVUYXJnZXRFbGVtZW50cyh0aGlzLnJvb3QuZWxlbWVudHMpO1xuXG4gICAgaWYgKGRlc3Ryb3lTZWxlY3RvKSB7XG4gICAgICB0aGlzLnNlbGVjdG8/LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICBjb250YWluZXI6IHRoaXMuZGl2LFxuICAgICAgc2VsZWN0YWJsZVRhcmdldHM6IHRhcmdldEVsZW1lbnRzLFxuICAgICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICB9KTtcblxuICAgIHRoaXMubW92ZWFibGUgPSBuZXcgTW92ZWFibGUodGhpcy5kaXYhLCB7XG4gICAgICBkcmFnZ2FibGU6IGFsbG93Q2hhbmdlcyxcbiAgICAgIHJlc2l6YWJsZTogYWxsb3dDaGFuZ2VzLFxuICAgICAgb3JpZ2luOiBmYWxzZSxcbiAgICB9KVxuICAgICAgLm9uKCdjbGlja0dyb3VwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0byEuY2xpY2tUYXJnZXQoZXZlbnQuaW5wdXRFdmVudCwgZXZlbnQuaW5wdXRUYXJnZXQpO1xuICAgICAgfSlcbiAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRlZEVsZW1lbnQgPSB0aGlzLmZpbmRFbGVtZW50QnlUYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0ZWRFbGVtZW50IS5hcHBseURyYWcoZXZlbnQpO1xuICAgICAgICB0aGlzLm1vdmVkLm5leHQoRGF0ZS5ub3coKSk7IC8vIFRPRE8gb25seSBvbiBlbmRcbiAgICAgIH0pXG4gICAgICAub24oJ2RyYWdHcm91cCcsIChlKSA9PiB7XG4gICAgICAgIGUuZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgdGFyZ2V0ZWRFbGVtZW50IS5hcHBseURyYWcoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb3ZlZC5uZXh0KERhdGUubm93KCkpOyAvLyBUT0RPIG9ubHkgb24gZW5kXG4gICAgICB9KVxuICAgICAgLm9uKCdkcmFnRW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldGVkRWxlbWVudCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhcmdldChldmVudC50YXJnZXQpO1xuXG4gICAgICAgIGlmICh0YXJnZXRlZEVsZW1lbnQgJiYgdGFyZ2V0ZWRFbGVtZW50LnBhcmVudCkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRhcmdldGVkRWxlbWVudC5wYXJlbnQ7XG4gICAgICAgICAgdGFyZ2V0ZWRFbGVtZW50LnVwZGF0ZVNpemUocGFyZW50LndpZHRoLCBwYXJlbnQuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbigncmVzaXplJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldGVkRWxlbWVudCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhcmdldChldmVudC50YXJnZXQpO1xuICAgICAgICB0YXJnZXRlZEVsZW1lbnQhLmFwcGx5UmVzaXplKGV2ZW50KTtcbiAgICAgICAgdGhpcy5tb3ZlZC5uZXh0KERhdGUubm93KCkpOyAvLyBUT0RPIG9ubHkgb24gZW5kXG4gICAgICB9KVxuICAgICAgLm9uKCdyZXNpemVHcm91cCcsIChlKSA9PiB7XG4gICAgICAgIGUuZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ZWRFbGVtZW50ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgdGFyZ2V0ZWRFbGVtZW50IS5hcHBseVJlc2l6ZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vdmVkLm5leHQoRGF0ZS5ub3coKSk7IC8vIFRPRE8gb25seSBvbiBlbmRcbiAgICAgIH0pO1xuXG4gICAgbGV0IHRhcmdldHM6IEFycmF5PEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD4gPSBbXTtcbiAgICB0aGlzLnNlbGVjdG8hLm9uKCdkcmFnU3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVGFyZ2V0ID0gZXZlbnQuaW5wdXRFdmVudC50YXJnZXQ7XG5cbiAgICAgIGNvbnN0IGlzVGFyZ2V0TW92ZWFibGVFbGVtZW50ID1cbiAgICAgICAgdGhpcy5tb3ZlYWJsZSEuaXNNb3ZlYWJsZUVsZW1lbnQoc2VsZWN0ZWRUYXJnZXQpIHx8XG4gICAgICAgIHRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQgPT09IHNlbGVjdGVkVGFyZ2V0IHx8IHRhcmdldC5jb250YWlucyhzZWxlY3RlZFRhcmdldCkpO1xuXG4gICAgICBpZiAoaXNUYXJnZXRNb3ZlYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBkcmF3aW5nIHNlbGVjdGlvbiBib3ggd2hlbiBzZWxlY3RlZCB0YXJnZXQgaXMgYSBtb3ZlYWJsZSBlbGVtZW50XG4gICAgICAgIGV2ZW50LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9KS5vbignc2VsZWN0RW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICB0YXJnZXRzID0gZXZlbnQuc2VsZWN0ZWQ7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbih7IHRhcmdldHMgfSk7XG5cbiAgICAgIGlmIChldmVudC5pc0RyYWdTdGFydCkge1xuICAgICAgICBldmVudC5pbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubW92ZWFibGUhLmRyYWdTdGFydChldmVudC5pbnB1dEV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT17dGhpcy5yZXZJZH0gY2xhc3NOYW1lPXt0aGlzLnN0eWxlcy53cmFwfSBzdHlsZT17dGhpcy5zdHlsZX0gcmVmPXt0aGlzLnNldFJlZn0+XG4gICAgICAgIHt0aGlzLnJvb3QucmVuZGVyKCl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9IHN0eWxlc0ZhY3RvcnkoKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICB3cmFwOiBjc3NgXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGAsXG5cbiAgdG9vbGJhcjogY3NzYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDA7XG4gICAgbWFyZ2luOiAxMHB4O1xuICBgLFxufSkpO1xuIiwiaW1wb3J0IHsgQ29sb3JEaW1lbnNpb25Db25maWcsIFJlc291cmNlRGltZW5zaW9uQ29uZmlnIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlbWVudCB7XG4gIHRvcD86IG51bWJlcjtcbiAgbGVmdD86IG51bWJlcjtcbiAgcmlnaHQ/OiBudW1iZXI7XG4gIGJvdHRvbT86IG51bWJlcjtcblxuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuY2hvciB7XG4gIHRvcD86IGJvb2xlYW47XG4gIGxlZnQ/OiBib29sZWFuO1xuICByaWdodD86IGJvb2xlYW47XG4gIGJvdHRvbT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBlbnVtIEJhY2tncm91bmRJbWFnZVNpemUge1xuICBPcmlnaW5hbCA9ICdvcmlnaW5hbCcsXG4gIENvbnRhaW4gPSAnY29udGFpbicsXG4gIENvdmVyID0gJ2NvdmVyJyxcbiAgRmlsbCA9ICdmaWxsJyxcbiAgVGlsZSA9ICd0aWxlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYWNrZ3JvdW5kQ29uZmlnIHtcbiAgY29sb3I/OiBDb2xvckRpbWVuc2lvbkNvbmZpZztcbiAgaW1hZ2U/OiBSZXNvdXJjZURpbWVuc2lvbkNvbmZpZztcbiAgc2l6ZT86IEJhY2tncm91bmRJbWFnZVNpemU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNvbmZpZyB7XG4gIGNvbG9yPzogQ29sb3JEaW1lbnNpb25Db25maWc7XG4gIHdpZHRoPzogbnVtYmVyO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUGFuZWxQcm9wcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgUGFuZWxPcHRpb25zIH0gZnJvbSAnLi9tb2RlbHMuZ2VuJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUGFuZWxFZGl0RW50ZXJlZEV2ZW50LCBQYW5lbEVkaXRFeGl0ZWRFdmVudCB9IGZyb20gJ2FwcC90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHsgQ2FudmFzR3JvdXBPcHRpb25zIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcyc7XG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9zY2VuZSc7XG5pbXBvcnQgeyBQYW5lbENvbnRleHQsIFBhbmVsQ29udGV4dFJvb3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBFbGVtZW50U3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZWxlbWVudCc7XG5cbmludGVyZmFjZSBQcm9wcyBleHRlbmRzIFBhbmVsUHJvcHM8UGFuZWxPcHRpb25zPiB7fVxuXG5pbnRlcmZhY2UgU3RhdGUge1xuICByZWZyZXNoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFuY2VTdGF0ZSB7XG4gIHNjZW5lOiBTY2VuZTtcbiAgc2VsZWN0ZWQ6IEVsZW1lbnRTdGF0ZVtdO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzUGFuZWwgZXh0ZW5kcyBDb21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBjb250ZXh0VHlwZSA9IFBhbmVsQ29udGV4dFJvb3Q7XG4gIHBhbmVsQ29udGV4dDogUGFuZWxDb250ZXh0ID0ge30gYXMgUGFuZWxDb250ZXh0O1xuXG4gIHJlYWRvbmx5IHNjZW5lOiBTY2VuZTtcbiAgcHJpdmF0ZSBzdWJzID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICBuZWVkc1JlbG9hZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgcmVmcmVzaDogMCxcbiAgICB9O1xuXG4gICAgLy8gT25seSB0aGUgaW5pdGlhbCBvcHRpb25zIGFyZSBldmVyIHVzZWQuXG4gICAgLy8gbGF0ZXIgY2hhbmdlcyBhcmUgYWxsIGNvbnRyb2xsZWQgYnkgdGhlIHNjZW5lXG4gICAgdGhpcy5zY2VuZSA9IG5ldyBTY2VuZSh0aGlzLnByb3BzLm9wdGlvbnMucm9vdCwgdGhpcy5wcm9wcy5vcHRpb25zLmlubGluZUVkaXRpbmcsIHRoaXMub25VcGRhdGVTY2VuZSk7XG4gICAgdGhpcy5zY2VuZS51cGRhdGVTaXplKHByb3BzLndpZHRoLCBwcm9wcy5oZWlnaHQpO1xuICAgIHRoaXMuc2NlbmUudXBkYXRlRGF0YShwcm9wcy5kYXRhKTtcblxuICAgIHRoaXMuc3Vicy5hZGQoXG4gICAgICB0aGlzLnByb3BzLmV2ZW50QnVzLnN1YnNjcmliZShQYW5lbEVkaXRFbnRlcmVkRXZlbnQsIChldnQpID0+IHtcbiAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbnQgc2VsZWN0aW9uIHdoZW4gZW50ZXJpbmcgZWRpdCBtb2RlIGZvciBhbnkgcGFuZWwgaW4gZGFzaGJvYXJkXG4gICAgICAgIHRoaXMuc2NlbmUuY2xlYXJDdXJyZW50U2VsZWN0aW9uKCk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnMuYWRkKFxuICAgICAgdGhpcy5wcm9wcy5ldmVudEJ1cy5zdWJzY3JpYmUoUGFuZWxFZGl0RXhpdGVkRXZlbnQsIChldnQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaWQgPT09IGV2dC5wYXlsb2FkKSB7XG4gICAgICAgICAgdGhpcy5uZWVkc1JlbG9hZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMucGFuZWxDb250ZXh0ID0gdGhpcy5jb250ZXh0IGFzIFBhbmVsQ29udGV4dDtcbiAgICBpZiAodGhpcy5wYW5lbENvbnRleHQub25JbnN0YW5jZVN0YXRlQ2hhbmdlKSB7XG4gICAgICB0aGlzLnBhbmVsQ29udGV4dC5vbkluc3RhbmNlU3RhdGVDaGFuZ2Uoe1xuICAgICAgICBzY2VuZTogdGhpcy5zY2VuZSxcbiAgICAgICAgbGF5ZXI6IHRoaXMuc2NlbmUucm9vdCxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN1YnMuYWRkKFxuICAgICAgICB0aGlzLnNjZW5lLnNlbGVjdGlvbi5zdWJzY3JpYmUoe1xuICAgICAgICAgIG5leHQ6ICh2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmVsQ29udGV4dC5vbkluc3RhbmNlU3RhdGVDaGFuZ2UhKHtcbiAgICAgICAgICAgICAgc2NlbmU6IHRoaXMuc2NlbmUsXG4gICAgICAgICAgICAgIHNlbGVjdGVkOiB2LFxuICAgICAgICAgICAgICBsYXllcjogdGhpcy5zY2VuZS5yb290LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zdWJzLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvLyBOT1RFLCBhbGwgY2hhbmdlcyB0byB0aGUgc2NlbmUgZmxvdyB0aHJvdWdoIHRoaXMgZnVuY3Rpb25cbiAgLy8gZXZlbiB0aGUgZWRpdG9yIGdldHMgY3VycmVudCBzdGF0ZSBmcm9tIHRoZSBzYW1lIHNjZW5lIGluc3RhbmNlIVxuICBvblVwZGF0ZVNjZW5lID0gKHJvb3Q6IENhbnZhc0dyb3VwT3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgb25PcHRpb25zQ2hhbmdlLCBvcHRpb25zIH0gPSB0aGlzLnByb3BzO1xuICAgIG9uT3B0aW9uc0NoYW5nZSh7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcm9vdCxcbiAgICB9KTtcbiAgICB0aGlzLnNldFN0YXRlKHsgcmVmcmVzaDogdGhpcy5zdGF0ZS5yZWZyZXNoICsgMSB9KTtcbiAgICAvLyBjb25zb2xlLmxvZygnc2VuZCBjaGFuZ2VzJywgcm9vdCk7XG4gIH07XG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wczogUHJvcHMsIG5leHRTdGF0ZTogU3RhdGUpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGRhdGEgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgIGlmICh3aWR0aCAhPT0gbmV4dFByb3BzLndpZHRoIHx8IGhlaWdodCAhPT0gbmV4dFByb3BzLmhlaWdodCkge1xuICAgICAgdGhpcy5zY2VuZS51cGRhdGVTaXplKG5leHRQcm9wcy53aWR0aCwgbmV4dFByb3BzLmhlaWdodCk7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IG5leHRQcm9wcy5kYXRhKSB7XG4gICAgICB0aGlzLnNjZW5lLnVwZGF0ZURhdGEobmV4dFByb3BzLmRhdGEpO1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUucmVmcmVzaCAhPT0gbmV4dFN0YXRlLnJlZnJlc2gpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFmdGVyIGVkaXRpbmcsIHRoZSBvcHRpb25zIGFyZSB2YWxpZCwgYnV0IHRoZSBzY2VuZSB3YXMgaW4gYSBkaWZmZXJlbnQgcGFuZWwgb3IgaW5saW5lIGVkaXRpbmcgbW9kZSBoYXMgY2hhbmdlZFxuICAgIGNvbnN0IHNob3VsZFVwZGF0ZVNjZW5lQW5kUGFuZWwgPVxuICAgICAgKHRoaXMubmVlZHNSZWxvYWQgJiYgdGhpcy5wcm9wcy5vcHRpb25zICE9PSBuZXh0UHJvcHMub3B0aW9ucykgfHxcbiAgICAgIHRoaXMucHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nICE9PSBuZXh0UHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nO1xuICAgIGlmIChzaG91bGRVcGRhdGVTY2VuZUFuZFBhbmVsKSB7XG4gICAgICB0aGlzLm5lZWRzUmVsb2FkID0gZmFsc2U7XG4gICAgICB0aGlzLnNjZW5lLmxvYWQobmV4dFByb3BzLm9wdGlvbnMucm9vdCwgbmV4dFByb3BzLm9wdGlvbnMuaW5saW5lRWRpdGluZyk7XG4gICAgICB0aGlzLnNjZW5lLnVwZGF0ZVNpemUobmV4dFByb3BzLndpZHRoLCBuZXh0UHJvcHMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuc2NlbmUudXBkYXRlRGF0YShuZXh0UHJvcHMuZGF0YSk7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMucHJvcHMub3B0aW9ucy5pbmxpbmVFZGl0aW5nKSB7XG4gICAgICAgIHRoaXMuc2NlbmUuc2VsZWN0bz8uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnNjZW5lLnJlbmRlcigpO1xuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgRkMsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQnV0dG9uLCBJbmxpbmVGaWVsZCwgSW5saW5lRmllbGRSb3csIEpTT05Gb3JtYXR0ZXIsIFN0cmluZ1ZhbHVlRWRpdG9yIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgQXBwRXZlbnRzLCBTdGFuZGFyZEVkaXRvclByb3BzLCBTdGFuZGFyZEVkaXRvcnNSZWdpc3RyeUl0ZW0sIFN0cmluZ0ZpZWxkQ29uZmlnU2V0dGluZ3MgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGNvbmZpZywgZ2V0QmFja2VuZFNydiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgYXBwRXZlbnRzIH0gZnJvbSAnYXBwL2NvcmUvY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQVBJRWRpdG9yQ29uZmlnIHtcbiAgZW5kcG9pbnQ6IHN0cmluZztcbiAgZGF0YT86IHN0cmluZztcbn1cblxuY29uc3QgZHVtbXlTdHJpbmdTZXR0aW5nczogU3RhbmRhcmRFZGl0b3JzUmVnaXN0cnlJdGVtPHN0cmluZywgU3RyaW5nRmllbGRDb25maWdTZXR0aW5ncz4gPSB7XG4gIHNldHRpbmdzOiB7fSxcbn0gYXMgYW55O1xuXG5leHBvcnQgY29uc3QgY2FsbEFwaSA9IChhcGk6IEFQSUVkaXRvckNvbmZpZywgaXNUZXN0ID0gZmFsc2UpID0+IHtcbiAgaWYgKGFwaSkge1xuICAgIGdldEJhY2tlbmRTcnYoKVxuICAgICAgLmZldGNoKHtcbiAgICAgICAgdXJsOiBhcGkuZW5kcG9pbnQhLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgZGF0YTogYXBpLmRhdGEgPz8ge30sXG4gICAgICB9KVxuICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgIGVycm9yOiAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgICAgIGlmIChpc1Rlc3QpIHtcbiAgICAgICAgICAgIGFwcEV2ZW50cy5lbWl0KEFwcEV2ZW50cy5hbGVydEVycm9yLCBbJ0Vycm9yIGhhcyBvY2N1cnJlZDogJywgSlNPTi5zdHJpbmdpZnkoZXJyb3IpXSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzVGVzdCkge1xuICAgICAgICAgICAgYXBwRXZlbnRzLmVtaXQoQXBwRXZlbnRzLmFsZXJ0U3VjY2VzcywgWydUZXN0IHN1Y2Nlc3NmdWwnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBBUElFZGl0b3I6IEZDPFN0YW5kYXJkRWRpdG9yUHJvcHM8QVBJRWRpdG9yQ29uZmlnLCBhbnksIGFueT4+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgdmFsdWUsIGNvbnRleHQsIG9uQ2hhbmdlIH0gPSBwcm9wcztcbiAgY29uc3QgbGFiZWxXaWR0aCA9IDk7XG5cbiAgY29uc3Qgb25FbmRwb2ludENoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChlbmRwb2ludCkgPT4ge1xuICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgZW5kcG9pbnQsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtvbkNoYW5nZSwgdmFsdWVdXG4gICk7XG5cbiAgY29uc3Qgb25EYXRhQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgKGRhdGEpID0+IHtcbiAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIGRhdGEsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtvbkNoYW5nZSwgdmFsdWVdXG4gICk7XG5cbiAgY29uc3QgcmVuZGVySlNPTiA9IChkYXRhOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICByZXR1cm4gPEpTT05Gb3JtYXR0ZXIganNvbj17anNvbn0gLz47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBgSW52YWxpZCBKU09OIHByb3ZpZGVkOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVuZGVyVGVzdEFQSUJ1dHRvbiA9IChhcGk6IEFQSUVkaXRvckNvbmZpZykgPT4ge1xuICAgIGlmIChhcGkgJiYgYXBpLmVuZHBvaW50KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9eygpID0+IGNhbGxBcGkoYXBpLCB0cnVlKX0gdGl0bGU9eydUZXN0IEFQSSd9PlxuICAgICAgICAgIFRlc3QgQVBJXG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgcmV0dXJuIGNvbmZpZy5kaXNhYmxlU2FuaXRpemVIdG1sID8gKFxuICAgIDw+XG4gICAgICA8SW5saW5lRmllbGRSb3c+XG4gICAgICAgIDxJbmxpbmVGaWVsZCBsYWJlbD17J0VuZHBvaW50J30gbGFiZWxXaWR0aD17bGFiZWxXaWR0aH0gZ3Jvdz17dHJ1ZX0+XG4gICAgICAgICAgPFN0cmluZ1ZhbHVlRWRpdG9yXG4gICAgICAgICAgICBjb250ZXh0PXtjb250ZXh0fVxuICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5lbmRwb2ludH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkVuZHBvaW50Q2hhbmdlfVxuICAgICAgICAgICAgaXRlbT17ZHVtbXlTdHJpbmdTZXR0aW5nc31cbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgPC9JbmxpbmVGaWVsZFJvdz5cbiAgICAgIDxJbmxpbmVGaWVsZFJvdz5cbiAgICAgICAgPElubGluZUZpZWxkIGxhYmVsPXsnRGF0YSd9IGxhYmVsV2lkdGg9e2xhYmVsV2lkdGh9IGdyb3c9e3RydWV9PlxuICAgICAgICAgIDxTdHJpbmdWYWx1ZUVkaXRvclxuICAgICAgICAgICAgY29udGV4dD17Y29udGV4dH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZT8uZGF0YSA/PyAne30nfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uRGF0YUNoYW5nZX1cbiAgICAgICAgICAgIGl0ZW09e2R1bW15U3RyaW5nU2V0dGluZ3N9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9JbmxpbmVGaWVsZD5cbiAgICAgIDwvSW5saW5lRmllbGRSb3c+XG4gICAgICB7cmVuZGVyVGVzdEFQSUJ1dHRvbih2YWx1ZSl9XG4gICAgICA8YnIgLz5cbiAgICAgIHtyZW5kZXJKU09OKHZhbHVlPy5kYXRhID8/ICd7fScpfVxuICAgIDwvPlxuICApIDogKFxuICAgIDw+TXVzdCBlbmFibGUgZGlzYWJsZVNhbml0aXplSHRtbCBmZWF0dXJlIGZsYWcgdG8gYWNjZXNzPC8+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBCdXR0b24sIEhvcml6b250YWxHcm91cCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IEFwcEV2ZW50cywgU2VsZWN0YWJsZVZhbHVlLCBTdGFuZGFyZEVkaXRvclByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBEcm9wUmVzdWx0IH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5cbmltcG9ydCB7IFBhbmVsT3B0aW9ucyB9IGZyb20gJy4uL21vZGVscy5nZW4nO1xuaW1wb3J0IHsgTGF5ZXJBY3Rpb25JRCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IENhbnZhc0VsZW1lbnRPcHRpb25zLCBjYW52YXNFbGVtZW50UmVnaXN0cnkgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCBhcHBFdmVudHMgZnJvbSAnYXBwL2NvcmUvYXBwX2V2ZW50cyc7XG5pbXBvcnQgeyBFbGVtZW50U3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZWxlbWVudCc7XG5pbXBvcnQgeyBub3RGb3VuZEl0ZW0gfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL2VsZW1lbnRzL25vdEZvdW5kJztcbmltcG9ydCB7IEdyb3VwU3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZ3JvdXAnO1xuaW1wb3J0IHsgTGF5ZXJFZGl0b3JQcm9wcyB9IGZyb20gJy4vbGF5ZXJFZGl0b3InO1xuaW1wb3J0IHsgU2VsZWN0aW9uUGFyYW1zIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL3NjZW5lJztcbmltcG9ydCB7IFNob3dDb25maXJtTW9kYWxFdmVudCB9IGZyb20gJ2FwcC90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHsgTGF5ZXJEcmFnRHJvcExpc3QgfSBmcm9tICdhcHAvY29yZS9jb21wb25lbnRzL0xheWVycy9MYXllckRyYWdEcm9wTGlzdCc7XG5pbXBvcnQgeyBBZGRMYXllckJ1dHRvbiB9IGZyb20gJ2FwcC9jb3JlL2NvbXBvbmVudHMvTGF5ZXJzL0FkZExheWVyQnV0dG9uJztcblxudHlwZSBQcm9wcyA9IFN0YW5kYXJkRWRpdG9yUHJvcHM8YW55LCBMYXllckVkaXRvclByb3BzLCBQYW5lbE9wdGlvbnM+O1xuXG5leHBvcnQgY2xhc3MgTGF5ZXJFbGVtZW50TGlzdEVkaXRvciBleHRlbmRzIFB1cmVDb21wb25lbnQ8UHJvcHM+IHtcbiAgZ2V0U2NlbmUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5wcm9wcy5pdGVtO1xuICAgIGlmICghc2V0dGluZ3M/LmxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBzZXR0aW5ncy5sYXllci5zY2VuZTtcbiAgfTtcblxuICBvbkFkZEl0ZW0gPSAoc2VsOiBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPikgPT4ge1xuICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXMucHJvcHMuaXRlbTtcbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGxheWVyIH0gPSBzZXR0aW5ncztcblxuICAgIGNvbnN0IGl0ZW0gPSBjYW52YXNFbGVtZW50UmVnaXN0cnkuZ2V0SWZFeGlzdHMoc2VsLnZhbHVlKSA/PyBub3RGb3VuZEl0ZW07XG4gICAgY29uc3QgbmV3RWxlbWVudE9wdGlvbnMgPSBpdGVtLmdldE5ld09wdGlvbnMoKSBhcyBDYW52YXNFbGVtZW50T3B0aW9ucztcbiAgICBuZXdFbGVtZW50T3B0aW9ucy50eXBlID0gaXRlbS5pZDtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gbmV3IEVsZW1lbnRTdGF0ZShpdGVtLCBuZXdFbGVtZW50T3B0aW9ucywgbGF5ZXIpO1xuICAgIG5ld0VsZW1lbnQudXBkYXRlU2l6ZShuZXdFbGVtZW50LndpZHRoLCBuZXdFbGVtZW50LmhlaWdodCk7XG4gICAgbmV3RWxlbWVudC51cGRhdGVEYXRhKGxheWVyLnNjZW5lLmNvbnRleHQpO1xuICAgIGxheWVyLmVsZW1lbnRzLnB1c2gobmV3RWxlbWVudCk7XG4gICAgbGF5ZXIuc2NlbmUuc2F2ZSgpO1xuXG4gICAgbGF5ZXIucmVpbml0aWFsaXplTW92ZWFibGUoKTtcbiAgfTtcblxuICBvblNlbGVjdCA9IChpdGVtOiBhbnkpID0+IHtcbiAgICBjb25zdCB7IHNldHRpbmdzIH0gPSB0aGlzLnByb3BzLml0ZW07XG5cbiAgICBpZiAoc2V0dGluZ3M/LnNjZW5lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uOiBTZWxlY3Rpb25QYXJhbXMgPSB7IHRhcmdldHM6IFtdIH07XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXBTdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRzOiBIVE1MRGl2RWxlbWVudFtdID0gW107XG4gICAgICAgICAgaXRlbS5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50OiBFbGVtZW50U3RhdGUpID0+IHtcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnRzLnB1c2goZWxlbWVudC5kaXYhKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNlbGVjdGlvbi50YXJnZXRzID0gdGFyZ2V0RWxlbWVudHM7XG4gICAgICAgICAgc2VsZWN0aW9uLmdyb3VwID0gaXRlbTtcbiAgICAgICAgICBzZXR0aW5ncy5zY2VuZS5zZWxlY3Qoc2VsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgRWxlbWVudFN0YXRlKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IFtpdGVtPy5kaXYhXTtcbiAgICAgICAgICBzZWxlY3Rpb24udGFyZ2V0cyA9IHRhcmdldEVsZW1lbnQ7XG4gICAgICAgICAgc2V0dGluZ3Muc2NlbmUuc2VsZWN0KHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFwcEV2ZW50cy5lbWl0KEFwcEV2ZW50cy5hbGVydEVycm9yLCBbJ1VuYWJsZSB0byBzZWxlY3QgZWxlbWVudCwgdHJ5IHNlbGVjdGluZyBlbGVtZW50IGluIHBhbmVsIGluc3RlYWQnXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG9uQ2xlYXJTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5wcm9wcy5pdGVtO1xuXG4gICAgaWYgKCFzZXR0aW5ncz8ubGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxheWVyIH0gPSBzZXR0aW5ncztcblxuICAgIGxheWVyLnNjZW5lLmNsZWFyQ3VycmVudFNlbGVjdGlvbigpO1xuICB9O1xuXG4gIG9uRHJhZ0VuZCA9IChyZXN1bHQ6IERyb3BSZXN1bHQpID0+IHtcbiAgICBpZiAoIXJlc3VsdC5kZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXMucHJvcHMuaXRlbTtcbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNldHRpbmdzO1xuXG4gICAgY29uc3QgY291bnQgPSBsYXllci5lbGVtZW50cy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IHNyYyA9IChyZXN1bHQuc291cmNlLmluZGV4IC0gY291bnQpICogLTE7XG4gICAgY29uc3QgZHN0ID0gKHJlc3VsdC5kZXN0aW5hdGlvbi5pbmRleCAtIGNvdW50KSAqIC0xO1xuXG4gICAgbGF5ZXIucmVvcmRlcihzcmMsIGRzdCk7XG4gIH07XG5cbiAgZ29VcExheWVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5wcm9wcy5pdGVtLnNldHRpbmdzO1xuXG4gICAgaWYgKCFzZXR0aW5ncz8ubGF5ZXIgfHwgIXNldHRpbmdzPy5zY2VuZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc2NlbmUsIGxheWVyIH0gPSBzZXR0aW5ncztcblxuICAgIGlmIChsYXllci5wYXJlbnQpIHtcbiAgICAgIHNjZW5lLnVwZGF0ZUN1cnJlbnRMYXllcihsYXllci5wYXJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGRlY291cGxlR3JvdXAgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnByb3BzLml0ZW0uc2V0dGluZ3M7XG5cbiAgICBpZiAoIXNldHRpbmdzPy5sYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNldHRpbmdzO1xuXG4gICAgdGhpcy5kZWxldGVHcm91cCgpO1xuICAgIGxheWVyLmVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSkgPT4ge1xuICAgICAgbGF5ZXIucGFyZW50Py5kb0FjdGlvbihMYXllckFjdGlvbklELkR1cGxpY2F0ZSwgZWxlbWVudCwgZmFsc2UpO1xuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgb25EZWNvdXBsZUdyb3VwID0gKCkgPT4ge1xuICAgIGFwcEV2ZW50cy5wdWJsaXNoKFxuICAgICAgbmV3IFNob3dDb25maXJtTW9kYWxFdmVudCh7XG4gICAgICAgIHRpdGxlOiAnRGVjb3VwbGUgZ3JvdXAnLFxuICAgICAgICB0ZXh0OiBgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlY291cGxlIHRoaXMgZ3JvdXA/YCxcbiAgICAgICAgdGV4dDI6ICdUaGlzIHdpbGwgcmVtb3ZlIHRoZSBncm91cCBhbmQgcHVzaCBuZXN0ZWQgZWxlbWVudHMgaW4gdGhlIG5leHQgbGV2ZWwgdXAuJyxcbiAgICAgICAgY29uZmlybVRleHQ6ICdZZXMnLFxuICAgICAgICB5ZXNUZXh0OiAnRGVjb3VwbGUnLFxuICAgICAgICBvbkNvbmZpcm06IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRlY291cGxlR3JvdXAoKTtcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIGRlbGV0ZUdyb3VwID0gKCkgPT4ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5wcm9wcy5pdGVtLnNldHRpbmdzO1xuXG4gICAgaWYgKCFzZXR0aW5ncz8ubGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxheWVyIH0gPSBzZXR0aW5ncztcblxuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuICAgIHNjZW5lPy5ieU5hbWUuZGVsZXRlKGxheWVyLmdldE5hbWUoKSk7XG4gICAgbGF5ZXIuZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4gc2NlbmU/LmJ5TmFtZS5kZWxldGUoZWxlbWVudC5nZXROYW1lKCkpKTtcbiAgICBsYXllci5wYXJlbnQ/LmRvQWN0aW9uKExheWVyQWN0aW9uSUQuRGVsZXRlLCBsYXllcik7XG5cbiAgICB0aGlzLmdvVXBMYXllcigpO1xuICB9O1xuXG4gIHByaXZhdGUgb25Hcm91cFNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICBpZiAoc2NlbmUpIHtcbiAgICAgIHNjZW5lLmdyb3VwU2VsZWN0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybignbm8gc2NlbmUhJyk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgb25EZWxldGVHcm91cCA9ICgpID0+IHtcbiAgICBhcHBFdmVudHMucHVibGlzaChcbiAgICAgIG5ldyBTaG93Q29uZmlybU1vZGFsRXZlbnQoe1xuICAgICAgICB0aXRsZTogJ0RlbGV0ZSBncm91cCcsXG4gICAgICAgIHRleHQ6IGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgZ3JvdXA/YCxcbiAgICAgICAgdGV4dDI6ICdUaGlzIHdpbGwgZGVsZXRlIHRoZSBncm91cCBhbmQgYWxsIG5lc3RlZCBlbGVtZW50cy4nLFxuICAgICAgICBpY29uOiAndHJhc2gtYWx0JyxcbiAgICAgICAgY29uZmlybVRleHQ6ICdEZWxldGUnLFxuICAgICAgICB5ZXNUZXh0OiAnRGVsZXRlJyxcbiAgICAgICAgb25Db25maXJtOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kZWxldGVHcm91cCgpO1xuICAgICAgICB9LFxuICAgICAgfSlcbiAgICApO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucHJvcHMuaXRlbS5zZXR0aW5ncztcbiAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICByZXR1cm4gPGRpdj5ObyBzZXR0aW5nczwvZGl2PjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXIgPSBzZXR0aW5ncy5sYXllcjtcbiAgICBpZiAoIWxheWVyKSB7XG4gICAgICByZXR1cm4gPGRpdj5NaXNzaW5nIGxheWVyPzwvZGl2PjtcbiAgICB9XG5cbiAgICBjb25zdCBvbkRlbGV0ZSA9IChlbGVtZW50OiBFbGVtZW50U3RhdGUpID0+IHtcbiAgICAgIGxheWVyLmRvQWN0aW9uKExheWVyQWN0aW9uSUQuRGVsZXRlLCBlbGVtZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25EdXBsaWNhdGUgPSAoZWxlbWVudDogRWxlbWVudFN0YXRlKSA9PiB7XG4gICAgICBsYXllci5kb0FjdGlvbihMYXllckFjdGlvbklELkR1cGxpY2F0ZSwgZWxlbWVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldExheWVySW5mbyA9IChlbGVtZW50OiBFbGVtZW50U3RhdGUpID0+IHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm9wdGlvbnMudHlwZTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25OYW1lQ2hhbmdlID0gKGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSwgbmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBlbGVtZW50Lm9uQ2hhbmdlKHsgLi4uZWxlbWVudC5vcHRpb25zLCBuYW1lIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0dyb3VwID0gKGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBHcm91cFN0YXRlO1xuICAgIH07XG5cbiAgICBjb25zdCB2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzID0gKG5hbWVUb1ZlcmlmeTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcblxuICAgICAgcmV0dXJuIEJvb2xlYW4oc2NlbmU/LmNhblJlbmFtZShuYW1lVG9WZXJpZnkpKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2VsZWN0aW9uOiBzdHJpbmdbXSA9IHNldHRpbmdzLnNlbGVjdGVkID8gc2V0dGluZ3Muc2VsZWN0ZWQubWFwKCh2KSA9PiB2LmdldE5hbWUoKSkgOiBbXTtcbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAgeyFsYXllci5pc1Jvb3QoKSAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxCdXR0b24gaWNvbj1cImFuZ2xlLXVwXCIgc2l6ZT1cInNtXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMuZ29VcExheWVyfT5cbiAgICAgICAgICAgICAgR28gVXAgTGV2ZWxcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwic21cIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17KCkgPT4gdGhpcy5vblNlbGVjdChsYXllcil9PlxuICAgICAgICAgICAgICBTZWxlY3QgR3JvdXBcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwic21cIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17KCkgPT4gdGhpcy5vbkRlY291cGxlR3JvdXAoKX0+XG4gICAgICAgICAgICAgIERlY291cGxlIEdyb3VwXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b24gc2l6ZT1cInNtXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9eygpID0+IHRoaXMub25EZWxldGVHcm91cCgpfT5cbiAgICAgICAgICAgICAgRGVsZXRlIEdyb3VwXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8Lz5cbiAgICAgICAgKX1cbiAgICAgICAgPExheWVyRHJhZ0Ryb3BMaXN0XG4gICAgICAgICAgb25EcmFnRW5kPXt0aGlzLm9uRHJhZ0VuZH1cbiAgICAgICAgICBvblNlbGVjdD17dGhpcy5vblNlbGVjdH1cbiAgICAgICAgICBvbkRlbGV0ZT17b25EZWxldGV9XG4gICAgICAgICAgb25EdXBsaWNhdGU9e29uRHVwbGljYXRlfVxuICAgICAgICAgIGdldExheWVySW5mbz17Z2V0TGF5ZXJJbmZvfVxuICAgICAgICAgIG9uTmFtZUNoYW5nZT17b25OYW1lQ2hhbmdlfVxuICAgICAgICAgIHZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3M9e3ZlcmlmeUxheWVyTmFtZVVuaXF1ZW5lc3N9XG4gICAgICAgICAgaXNHcm91cD17aXNHcm91cH1cbiAgICAgICAgICBsYXllcnM9e2xheWVyLmVsZW1lbnRzfVxuICAgICAgICAgIHNlbGVjdGlvbj17c2VsZWN0aW9ufVxuICAgICAgICAvPlxuICAgICAgICA8YnIgLz5cblxuICAgICAgICA8SG9yaXpvbnRhbEdyb3VwPlxuICAgICAgICAgIDxBZGRMYXllckJ1dHRvblxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25BZGRJdGVtfVxuICAgICAgICAgICAgb3B0aW9ucz17Y2FudmFzRWxlbWVudFJlZ2lzdHJ5LnNlbGVjdE9wdGlvbnMoKS5vcHRpb25zfVxuICAgICAgICAgICAgbGFiZWw9eydBZGQgaXRlbSd9XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7c2VsZWN0aW9uLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwic21cIiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgb25DbGljaz17dGhpcy5vbkNsZWFyU2VsZWN0aW9ufT5cbiAgICAgICAgICAgICAgQ2xlYXIgU2VsZWN0aW9uXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICAgIHtzZWxlY3Rpb24ubGVuZ3RoID4gMSAmJiAoXG4gICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbVwiIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiBvbkNsaWNrPXt0aGlzLm9uR3JvdXBTZWxlY3Rpb259PlxuICAgICAgICAgICAgICBHcm91cCBpdGVtc1xuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9Ib3Jpem9udGFsR3JvdXA+XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgRkMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBCdXR0b24sIEZpZWxkLCBIb3Jpem9udGFsR3JvdXAsIElubGluZUZpZWxkLCBJbmxpbmVGaWVsZFJvdyB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IFN0YW5kYXJkRWRpdG9yUHJvcHMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUGFuZWxPcHRpb25zIH0gZnJvbSAnLi4vbW9kZWxzLmdlbic7XG5pbXBvcnQgeyB1c2VPYnNlcnZhYmxlIH0gZnJvbSAncmVhY3QtdXNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENhbnZhc0VkaXRvck9wdGlvbnMgfSBmcm9tICcuL2VsZW1lbnRFZGl0b3InO1xuaW1wb3J0IHsgQW5jaG9yLCBQbGFjZW1lbnQgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzJztcbmltcG9ydCB7IE51bWJlcklucHV0IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycy9OdW1iZXJJbnB1dCc7XG5cbmNvbnN0IGFuY2hvcnM6IEFycmF5PGtleW9mIEFuY2hvcj4gPSBbJ3RvcCcsICdsZWZ0JywgJ2JvdHRvbScsICdyaWdodCddO1xuY29uc3QgcGxhY2VzOiBBcnJheTxrZXlvZiBQbGFjZW1lbnQ+ID0gWyd0b3AnLCAnbGVmdCcsICdib3R0b20nLCAncmlnaHQnLCAnd2lkdGgnLCAnaGVpZ2h0J107XG5cbmV4cG9ydCBjb25zdCBQbGFjZW1lbnRFZGl0b3I6IEZDPFN0YW5kYXJkRWRpdG9yUHJvcHM8YW55LCBDYW52YXNFZGl0b3JPcHRpb25zLCBQYW5lbE9wdGlvbnM+PiA9ICh7IGl0ZW0gfSkgPT4ge1xuICBjb25zdCBzZXR0aW5ncyA9IGl0ZW0uc2V0dGluZ3M7XG5cbiAgLy8gV2lsbCBmb3JjZSBhIHJlcmVuZGVyIHdoZW5ldmVyIHRoZSBzdWJqZWN0IGNoYW5nZXNcbiAgdXNlT2JzZXJ2YWJsZShzZXR0aW5ncz8uc2NlbmUgPyBzZXR0aW5ncy5zY2VuZS5tb3ZlZCA6IG5ldyBTdWJqZWN0KCkpO1xuXG4gIGlmICghc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gPGRpdj5Mb2FkaW5nLi4uPC9kaXY+O1xuICB9XG5cbiAgY29uc3QgZWxlbWVudCA9IHNldHRpbmdzLmVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiA8ZGl2Pj8/PzwvZGl2PjtcbiAgfVxuICBjb25zdCB7IHBsYWNlbWVudCB9ID0gZWxlbWVudDtcblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8SG9yaXpvbnRhbEdyb3VwPlxuICAgICAgICB7YW5jaG9ycy5tYXAoKGEpID0+IChcbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICBrZXk9e2F9XG4gICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgdmFyaWFudD17ZWxlbWVudC5hbmNob3JbYV0gPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5J31cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldHRpbmdzLnNjZW5lLnRvZ2dsZUFuY2hvcihlbGVtZW50LCBhKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7YX1cbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgKSl9XG4gICAgICA8L0hvcml6b250YWxHcm91cD5cbiAgICAgIDxiciAvPlxuXG4gICAgICA8RmllbGQgbGFiZWw9XCJQb3NpdGlvblwiPlxuICAgICAgICA8PlxuICAgICAgICAgIHtwbGFjZXMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ID0gcGxhY2VtZW50W3BdO1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxJbmxpbmVGaWVsZFJvdyBrZXk9e3B9PlxuICAgICAgICAgICAgICAgIDxJbmxpbmVGaWVsZCBsYWJlbD17cH0gbGFiZWxXaWR0aD17OH0gZ3Jvdz17dHJ1ZX0+XG4gICAgICAgICAgICAgICAgICA8TnVtYmVySW5wdXQgdmFsdWU9e3Z9IG9uQ2hhbmdlPXsodikgPT4gY29uc29sZS5sb2coJ1RPRE8sIGVkaXQhISEnLCBwLCB2KX0gLz5cbiAgICAgICAgICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgICAgICAgICA8L0lubGluZUZpZWxkUm93PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC8+XG4gICAgICA8L0ZpZWxkPlxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsImltcG9ydCB7IGdldCBhcyBsb2Rhc2hHZXQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgb3B0aW9uQnVpbGRlciB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBDYW52YXNFbGVtZW50T3B0aW9ucywgY2FudmFzRWxlbWVudFJlZ2lzdHJ5LCBERUZBVUxUX0NBTlZBU19FTEVNRU5UX0NPTkZJRyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuaW1wb3J0IHsgTmVzdGVkUGFuZWxPcHRpb25zLCBOZXN0ZWRWYWx1ZUFjY2VzcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjL3V0aWxzL09wdGlvbnNVSUJ1aWxkZXJzJztcbmltcG9ydCB7IHNldE9wdGlvbkltbXV0YWJseSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvY29tcG9uZW50cy9QYW5lbEVkaXRvci91dGlscyc7XG5pbXBvcnQgeyBFbGVtZW50U3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZWxlbWVudCc7XG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMvcnVudGltZS9zY2VuZSc7XG5pbXBvcnQgeyBQbGFjZW1lbnRFZGl0b3IgfSBmcm9tICcuL1BsYWNlbWVudEVkaXRvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FudmFzRWRpdG9yT3B0aW9ucyB7XG4gIGVsZW1lbnQ6IEVsZW1lbnRTdGF0ZTtcbiAgc2NlbmU6IFNjZW5lO1xuICBjYXRlZ29yeT86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudEVkaXRvcihvcHRzOiBDYW52YXNFZGl0b3JPcHRpb25zKTogTmVzdGVkUGFuZWxPcHRpb25zPENhbnZhc0VsZW1lbnRPcHRpb25zPiB7XG4gIHJldHVybiB7XG4gICAgY2F0ZWdvcnk6IG9wdHMuY2F0ZWdvcnksXG4gICAgcGF0aDogJy0tJywgLy8gbm90IHVzZWQhXG5cbiAgICAvLyBOb3RlIHRoYXQgY2FudmFzIGVkaXRvciB3cml0ZXMgdGhpbmdzIHRvIHRoZSBzY2VuZSFcbiAgICB2YWx1ZXM6IChwYXJlbnQ6IE5lc3RlZFZhbHVlQWNjZXNzKSA9PiAoe1xuICAgICAgZ2V0VmFsdWU6IChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGxvZGFzaEdldChvcHRzLmVsZW1lbnQub3B0aW9ucywgcGF0aCk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IChwYXRoOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBvcHRzLmVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgaWYgKHBhdGggPT09ICd0eXBlJyAmJiB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGxheWVyID0gY2FudmFzRWxlbWVudFJlZ2lzdHJ5LmdldElmRXhpc3RzKHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2xheWVyIGRvZXMgbm90IGV4aXN0JywgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIC4uLmxheWVyLmdldE5ld09wdGlvbnMob3B0aW9ucyksXG4gICAgICAgICAgICB0eXBlOiBsYXllci5pZCxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBzZXRPcHRpb25JbW11dGFibHkob3B0aW9ucywgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuZWxlbWVudC5vbkNoYW5nZShvcHRpb25zKTtcbiAgICAgICAgb3B0cy5lbGVtZW50LnVwZGF0ZURhdGEob3B0cy5zY2VuZS5jb250ZXh0KTtcbiAgICAgIH0sXG4gICAgfSksXG5cbiAgICAvLyBEeW5hbWljYWxseSBmaWxsIHRoZSBzZWxlY3RlZCBlbGVtZW50XG4gICAgYnVpbGQ6IChidWlsZGVyLCBjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9wdHMuZWxlbWVudDtcbiAgICAgIGNvbnN0IGxheWVyVHlwZXMgPSBjYW52YXNFbGVtZW50UmVnaXN0cnkuc2VsZWN0T3B0aW9ucyhcbiAgICAgICAgb3B0aW9ucz8udHlwZSAvLyB0aGUgc2VsZWN0ZWQgdmFsdWVcbiAgICAgICAgICA/IFtvcHRpb25zLnR5cGVdIC8vIGFzIGFuIGFycmF5XG4gICAgICAgICAgOiBbREVGQVVMVF9DQU5WQVNfRUxFTUVOVF9DT05GSUcudHlwZV1cbiAgICAgICk7XG5cbiAgICAgIGJ1aWxkZXIuYWRkU2VsZWN0KHtcbiAgICAgICAgcGF0aDogJ3R5cGUnLFxuICAgICAgICBuYW1lOiB1bmRlZmluZWQgYXMgYW55LCAvLyByZXF1aXJlZCwgYnV0IGhpZGUgc3BhY2VcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBvcHRpb25zOiBsYXllclR5cGVzLm9wdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gZm9yY2UgY2xlYW4gbGF5ZXIgY29uZmlndXJhdGlvblxuICAgICAgY29uc3QgbGF5ZXIgPSBjYW52YXNFbGVtZW50UmVnaXN0cnkuZ2V0SWZFeGlzdHMob3B0aW9ucz8udHlwZSA/PyBERUZBVUxUX0NBTlZBU19FTEVNRU5UX0NPTkZJRy50eXBlKSE7XG4gICAgICBsZXQgY3VycmVudE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKCFjdXJyZW50T3B0aW9ucykge1xuICAgICAgICBjdXJyZW50T3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5sYXllci5nZXROZXdPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgICAgIHR5cGU6IGxheWVyLmlkLFxuICAgICAgICAgIG5hbWU6IGBFbGVtZW50ICR7RGF0ZS5ub3coKX0uJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApfWAsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjdHggPSB7IC4uLmNvbnRleHQsIG9wdGlvbnM6IGN1cnJlbnRPcHRpb25zIH07XG5cbiAgICAgIGlmIChsYXllcj8ucmVnaXN0ZXJPcHRpb25zVUkpIHtcbiAgICAgICAgbGF5ZXIucmVnaXN0ZXJPcHRpb25zVUkoYnVpbGRlciwgY3R4KTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uQnVpbGRlci5hZGRCYWNrZ3JvdW5kKGJ1aWxkZXIsIGN0eCk7XG4gICAgICBvcHRpb25CdWlsZGVyLmFkZEJvcmRlcihidWlsZGVyLCBjdHgpO1xuXG4gICAgICBidWlsZGVyLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5OiBbJ0xheW91dCddLFxuICAgICAgICBpZDogJ2NvbnRlbnQnLFxuICAgICAgICBwYXRoOiAnX18nLCAvLyBub3QgdXNlZFxuICAgICAgICBuYW1lOiAnQW5jaG9yJyxcbiAgICAgICAgZWRpdG9yOiBQbGFjZW1lbnRFZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiBvcHRzLFxuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGdldCBhcyBsb2Rhc2hHZXQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgb3B0aW9uQnVpbGRlciB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBOZXN0ZWRQYW5lbE9wdGlvbnMsIE5lc3RlZFZhbHVlQWNjZXNzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YS9zcmMvdXRpbHMvT3B0aW9uc1VJQnVpbGRlcnMnO1xuaW1wb3J0IHsgc2V0T3B0aW9uSW1tdXRhYmx5IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9jb21wb25lbnRzL1BhbmVsRWRpdG9yL3V0aWxzJztcbmltcG9ydCB7IEluc3RhbmNlU3RhdGUgfSBmcm9tICcuLi9DYW52YXNQYW5lbCc7XG5pbXBvcnQgeyBMYXllckVsZW1lbnRMaXN0RWRpdG9yIH0gZnJvbSAnLi9MYXllckVsZW1lbnRMaXN0RWRpdG9yJztcbmltcG9ydCB7IEdyb3VwU3RhdGUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvZ3JvdXAnO1xuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICdhcHAvZmVhdHVyZXMvY2FudmFzL3J1bnRpbWUvc2NlbmUnO1xuaW1wb3J0IHsgRWxlbWVudFN0YXRlIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2VsZW1lbnQnO1xuaW1wb3J0IHsgUGxhY2VtZW50RWRpdG9yIH0gZnJvbSAnLi9QbGFjZW1lbnRFZGl0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIExheWVyRWRpdG9yUHJvcHMge1xuICBzY2VuZTogU2NlbmU7XG4gIGxheWVyOiBHcm91cFN0YXRlO1xuICBzZWxlY3RlZDogRWxlbWVudFN0YXRlW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXllckVkaXRvcihvcHRzOiBJbnN0YW5jZVN0YXRlKTogTmVzdGVkUGFuZWxPcHRpb25zPExheWVyRWRpdG9yUHJvcHM+IHtcbiAgY29uc3QgeyBzZWxlY3RlZCwgc2NlbmUgfSA9IG9wdHM7XG5cbiAgaWYgKCFzY2VuZS5jdXJyZW50TGF5ZXIpIHtcbiAgICBzY2VuZS5jdXJyZW50TGF5ZXIgPSBzY2VuZS5yb290IGFzIEdyb3VwU3RhdGU7XG4gIH1cblxuICBpZiAoc2VsZWN0ZWQpIHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2Ygc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgR3JvdXBTdGF0ZSkge1xuICAgICAgICBzY2VuZS5jdXJyZW50TGF5ZXIgPSBlbGVtZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQucGFyZW50KSB7XG4gICAgICAgIHNjZW5lLmN1cnJlbnRMYXllciA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gc2NlbmUuY3VycmVudExheWVyLm9wdGlvbnMgfHwgeyBlbGVtZW50czogW10gfTtcblxuICByZXR1cm4ge1xuICAgIGNhdGVnb3J5OiBbJ0xheWVyJ10sXG4gICAgcGF0aDogJy0tJywgLy8gbm90IHVzZWQhXG5cbiAgICAvLyBOb3RlIHRoYXQgY2FudmFzIGVkaXRvciB3cml0ZXMgdGhpbmdzIHRvIHRoZSBzY2VuZSFcbiAgICB2YWx1ZXM6IChwYXJlbnQ6IE5lc3RlZFZhbHVlQWNjZXNzKSA9PiAoe1xuICAgICAgZ2V0VmFsdWU6IChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGxvZGFzaEdldChvcHRpb25zLCBwYXRoKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogKHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSkgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gJ3R5cGUnICYmIHZhbHVlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCd1bmFibGUgdG8gY2hhbmdlIGxheWVyIHR5cGUnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHNldE9wdGlvbkltbXV0YWJseShvcHRpb25zLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIHNjZW5lLmN1cnJlbnRMYXllcj8ub25DaGFuZ2UoYyk7XG4gICAgICB9LFxuICAgIH0pLFxuXG4gICAgLy8gRHluYW1pY2FsbHkgZmlsbCB0aGUgc2VsZWN0ZWQgZWxlbWVudFxuICAgIGJ1aWxkOiAoYnVpbGRlciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudExheWVyID0gc2NlbmUuY3VycmVudExheWVyO1xuICAgICAgaWYgKGN1cnJlbnRMYXllciAmJiAhY3VycmVudExheWVyLmlzUm9vdCgpKSB7XG4gICAgICAgIC8vIFRPRE86IHRoZSBub24tcm9vdCBuYXYgb3B0aW9uXG4gICAgICB9XG5cbiAgICAgIGJ1aWxkZXIuYWRkQ3VzdG9tRWRpdG9yKHtcbiAgICAgICAgaWQ6ICdjb250ZW50JyxcbiAgICAgICAgcGF0aDogJ3Jvb3QnLFxuICAgICAgICBuYW1lOiAnRWxlbWVudHMnLFxuICAgICAgICBlZGl0b3I6IExheWVyRWxlbWVudExpc3RFZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7IHNjZW5lLCBsYXllcjogc2NlbmUuY3VycmVudExheWVyLCBzZWxlY3RlZCB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGN0eCA9IHsgLi4uY29udGV4dCwgb3B0aW9ucyB9O1xuICAgICAgb3B0aW9uQnVpbGRlci5hZGRCYWNrZ3JvdW5kKGJ1aWxkZXIgYXMgYW55LCBjdHgpO1xuICAgICAgb3B0aW9uQnVpbGRlci5hZGRCb3JkZXIoYnVpbGRlciBhcyBhbnksIGN0eCk7XG5cbiAgICAgIGlmIChjdXJyZW50TGF5ZXIgJiYgIWN1cnJlbnRMYXllci5pc1Jvb3QoKSkge1xuICAgICAgICBidWlsZGVyLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgICAgY2F0ZWdvcnk6IFsnTGF5b3V0J10sXG4gICAgICAgICAgaWQ6ICdjb250ZW50JyxcbiAgICAgICAgICBwYXRoOiAnX18nLCAvLyBub3QgdXNlZFxuICAgICAgICAgIG5hbWU6ICdBbmNob3InLFxuICAgICAgICAgIGVkaXRvcjogUGxhY2VtZW50RWRpdG9yLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBzY2VuZTogb3B0cy5zY2VuZSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGN1cnJlbnRMYXllcixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgUGFuZWxPcHRpb25zU3VwcGxpZXIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhL3NyYy9wYW5lbC9QYW5lbFBsdWdpbic7XG5pbXBvcnQgeyBCYWNrZ3JvdW5kSW1hZ2VTaXplLCBDYW52YXNFbGVtZW50T3B0aW9ucyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9jYW52YXMnO1xuaW1wb3J0IHsgQ29sb3JEaW1lbnNpb25FZGl0b3IsIFJlc291cmNlRGltZW5zaW9uRWRpdG9yIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2RpbWVuc2lvbnMvZWRpdG9ycyc7XG5cbmludGVyZmFjZSBPcHRpb25TdXBwbGllcnMge1xuICBhZGRCYWNrZ3JvdW5kOiBQYW5lbE9wdGlvbnNTdXBwbGllcjxDYW52YXNFbGVtZW50T3B0aW9ucz47XG4gIGFkZEJvcmRlcjogUGFuZWxPcHRpb25zU3VwcGxpZXI8Q2FudmFzRWxlbWVudE9wdGlvbnM+O1xufVxuXG5leHBvcnQgY29uc3Qgb3B0aW9uQnVpbGRlcjogT3B0aW9uU3VwcGxpZXJzID0ge1xuICBhZGRCYWNrZ3JvdW5kOiAoYnVpbGRlciwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gWydCYWNrZ3JvdW5kJ107XG4gICAgYnVpbGRlclxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2JhY2tncm91bmQuY29sb3InLFxuICAgICAgICBwYXRoOiAnYmFja2dyb3VuZC5jb2xvcicsXG4gICAgICAgIG5hbWU6ICdDb2xvcicsXG4gICAgICAgIGVkaXRvcjogQ29sb3JEaW1lbnNpb25FZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7fSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICAgICAgLy8gQ29uZmlndXJlZCB2YWx1ZXNcbiAgICAgICAgICBmaXhlZDogJycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2JhY2tncm91bmQuaW1hZ2UnLFxuICAgICAgICBwYXRoOiAnYmFja2dyb3VuZC5pbWFnZScsXG4gICAgICAgIG5hbWU6ICdJbWFnZScsXG4gICAgICAgIGVkaXRvcjogUmVzb3VyY2VEaW1lbnNpb25FZGl0b3IsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgcmVzb3VyY2VUeXBlOiAnaW1hZ2UnLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIC5hZGRSYWRpbyh7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBwYXRoOiAnYmFja2dyb3VuZC5zaXplJyxcbiAgICAgICAgbmFtZTogJ0ltYWdlIHNpemUnLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgIHsgdmFsdWU6IEJhY2tncm91bmRJbWFnZVNpemUuT3JpZ2luYWwsIGxhYmVsOiAnT3JpZ2luYWwnIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiBCYWNrZ3JvdW5kSW1hZ2VTaXplLkNvbnRhaW4sIGxhYmVsOiAnQ29udGFpbicgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IEJhY2tncm91bmRJbWFnZVNpemUuQ292ZXIsIGxhYmVsOiAnQ292ZXInIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiBCYWNrZ3JvdW5kSW1hZ2VTaXplLkZpbGwsIGxhYmVsOiAnRmlsbCcgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6IEJhY2tncm91bmRJbWFnZVNpemUuVGlsZSwgbGFiZWw6ICdUaWxlJyB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogQmFja2dyb3VuZEltYWdlU2l6ZS5Db3ZlcixcbiAgICAgIH0pO1xuICB9LFxuXG4gIGFkZEJvcmRlcjogKGJ1aWxkZXIsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IFsnQm9yZGVyJ107XG4gICAgYnVpbGRlci5hZGRTbGlkZXJJbnB1dCh7XG4gICAgICBjYXRlZ29yeSxcbiAgICAgIHBhdGg6ICdib3JkZXIud2lkdGgnLFxuICAgICAgbmFtZTogJ1dpZHRoJyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogMixcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAyMCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoY29udGV4dC5vcHRpb25zPy5ib3JkZXI/LndpZHRoKSB7XG4gICAgICBidWlsZGVyLmFkZEN1c3RvbUVkaXRvcih7XG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBpZDogJ2JvcmRlci5jb2xvcicsXG4gICAgICAgIHBhdGg6ICdib3JkZXIuY29sb3InLFxuICAgICAgICBuYW1lOiAnQ29sb3InLFxuICAgICAgICBlZGl0b3I6IENvbG9yRGltZW5zaW9uRWRpdG9yLFxuICAgICAgICBzZXR0aW5nczoge30sXG4gICAgICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAgICAgIC8vIENvbmZpZ3VyZWQgdmFsdWVzXG4gICAgICAgICAgZml4ZWQ6ICcnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxufTtcbiIsImltcG9ydCB7IFBhbmVsUGx1Z2luIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmltcG9ydCB7IENhbnZhc1BhbmVsLCBJbnN0YW5jZVN0YXRlIH0gZnJvbSAnLi9DYW52YXNQYW5lbCc7XG5pbXBvcnQgeyBQYW5lbE9wdGlvbnMgfSBmcm9tICcuL21vZGVscy5nZW4nO1xuaW1wb3J0IHsgZ2V0RWxlbWVudEVkaXRvciB9IGZyb20gJy4vZWRpdG9yL2VsZW1lbnRFZGl0b3InO1xuaW1wb3J0IHsgZ2V0TGF5ZXJFZGl0b3IgfSBmcm9tICcuL2VkaXRvci9sYXllckVkaXRvcic7XG5pbXBvcnQgeyBHcm91cFN0YXRlIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2NhbnZhcy9ydW50aW1lL2dyb3VwJztcblxuZXhwb3J0IGNvbnN0IHBsdWdpbiA9IG5ldyBQYW5lbFBsdWdpbjxQYW5lbE9wdGlvbnM+KENhbnZhc1BhbmVsKVxuICAuc2V0Tm9QYWRkaW5nKCkgLy8gZXh0ZW5kIHRvIHBhbmVsIGVkZ2VzXG4gIC51c2VGaWVsZENvbmZpZygpXG4gIC5zZXRQYW5lbE9wdGlvbnMoKGJ1aWxkZXIsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBzdGF0ZTogSW5zdGFuY2VTdGF0ZSA9IGNvbnRleHQuaW5zdGFuY2VTdGF0ZTtcblxuICAgIGJ1aWxkZXIuYWRkQm9vbGVhblN3aXRjaCh7XG4gICAgICBwYXRoOiAnaW5saW5lRWRpdGluZycsXG4gICAgICBuYW1lOiAnSW5saW5lIGVkaXRpbmcnLFxuICAgICAgZGVzY3JpcHRpb246ICdFbmFibGUgZWRpdGluZyB0aGUgcGFuZWwgZGlyZWN0bHknLFxuICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBidWlsZGVyLmFkZE5lc3RlZE9wdGlvbnMoZ2V0TGF5ZXJFZGl0b3Ioc3RhdGUpKTtcblxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0ZWQ7XG4gICAgICBpZiAoc2VsZWN0aW9uPy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdGlvblswXTtcbiAgICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEdyb3VwU3RhdGUpKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGROZXN0ZWRPcHRpb25zKFxuICAgICAgICAgICAgZ2V0RWxlbWVudEVkaXRvcih7XG4gICAgICAgICAgICAgIGNhdGVnb3J5OiBbYFNlbGVjdGVkIGVsZW1lbnQgKCR7ZWxlbWVudC5vcHRpb25zLm5hbWV9KWBdLFxuICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICBzY2VuZTogc3RhdGUuc2NlbmUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuIiwiZXhwb3J0IGVudW0gTGF5ZXJBY3Rpb25JRCB7XG4gIERlbGV0ZSA9ICdkZWxldGUnLFxuICBEdXBsaWNhdGUgPSAnZHVwbGljYXRlJyxcbiAgTW92ZVRvcCA9ICdtb3ZlLXRvcCcsXG4gIE1vdmVCb3R0b20gPSAnbW92ZS1ib3R0b20nLFxufVxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogY3NzLXN0eWxlZFxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2Nzcy1zdHlsZWQuZ2l0XG52ZXJzaW9uOiAxLjAuMFxuKi9cbmltcG9ydCB7IHNwbGl0Q29tbWEgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICB2YXIgaGFzaCA9IDUzODEsXG4gICAgICBpICAgID0gc3RyLmxlbmd0aDtcblxuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuXG4gIC8qIEphdmFTY3JpcHQgZG9lcyBiaXR3aXNlIG9wZXJhdGlvbnMgKGxpa2UgWE9SLCBhYm92ZSkgb24gMzItYml0IHNpZ25lZFxuICAgKiBpbnRlZ2Vycy4gU2luY2Ugd2Ugd2FudCB0aGUgcmVzdWx0cyB0byBiZSBhbHdheXMgcG9zaXRpdmUsIGNvbnZlcnQgdGhlXG4gICAqIHNpZ25lZCBpbnQgdG8gYW4gdW5zaWduZWQgYnkgZG9pbmcgYW4gdW5zaWduZWQgYml0c2hpZnQuICovXG4gIHJldHVybiBoYXNoID4+PiAwO1xufVxuXG52YXIgc3RyaW5nSGFzaCA9IGhhc2g7XG5cbmZ1bmN0aW9uIGdldEhhc2goc3RyKSB7XG4gIHJldHVybiBzdHJpbmdIYXNoKHN0cikudG9TdHJpbmcoMzYpO1xufVxuZnVuY3Rpb24gZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSB7XG4gIGlmIChwYXJlbnRFbGVtZW50ICYmIHBhcmVudEVsZW1lbnQuZ2V0Um9vdE5vZGUpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBwYXJlbnRFbGVtZW50LmdldFJvb3ROb2RlKCk7XG5cbiAgICBpZiAocm9vdE5vZGUubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICByZXR1cm4gcm9vdE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuO1xufVxuZnVuY3Rpb24gcmVwbGFjZVN0eWxlKGNsYXNzTmFtZSwgY3NzLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLm9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHJldHVybiBjc3MucmVwbGFjZSgvKFtefTt7XFxzfV1bXn07e10qfF5cXHMqKXsvbWcsIGZ1bmN0aW9uIChfLCBzZWxlY3Rvcikge1xuICAgIHZhciB0cmltbWVkU2VsZWN0b3IgPSBzZWxlY3Rvci50cmltKCk7XG4gICAgcmV0dXJuICh0cmltbWVkU2VsZWN0b3IgPyBzcGxpdENvbW1hKHRyaW1tZWRTZWxlY3RvcikgOiBbXCJcIl0pLm1hcChmdW5jdGlvbiAoc3ViU2VsZWN0b3IpIHtcbiAgICAgIHZhciB0cmltbWVkU3ViU2VsZWN0b3IgPSBzdWJTZWxlY3Rvci50cmltKCk7XG5cbiAgICAgIGlmICh0cmltbWVkU3ViU2VsZWN0b3IuaW5kZXhPZihcIkBcIikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRyaW1tZWRTdWJTZWxlY3RvcjtcbiAgICAgIH0gZWxzZSBpZiAodHJpbW1lZFN1YlNlbGVjdG9yLmluZGV4T2YoXCI6Z2xvYmFsXCIpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRyaW1tZWRTdWJTZWxlY3Rvci5yZXBsYWNlKC9cXDpnbG9iYWwvZywgXCJcIik7XG4gICAgICB9IGVsc2UgaWYgKHRyaW1tZWRTdWJTZWxlY3Rvci5pbmRleE9mKFwiOmhvc3RcIikgPiAtMSkge1xuICAgICAgICByZXR1cm4gXCJcIiArIHRyaW1tZWRTdWJTZWxlY3Rvci5yZXBsYWNlKC9cXDpob3N0L2csIFwiLlwiICsgY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAodHJpbW1lZFN1YlNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBcIi5cIiArIGNsYXNzTmFtZSArIFwiIFwiICsgdHJpbW1lZFN1YlNlbGVjdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiLlwiICsgY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiIHtcIjtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmplY3RTdHlsZShjbGFzc05hbWUsIGNzcywgb3B0aW9ucywgc2hhZG93Um9vdCkge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKTtcbiAgc3R5bGUuc2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZWQtaWRcIiwgY2xhc3NOYW1lKTtcblxuICBpZiAob3B0aW9ucy5ub25jZSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG9wdGlvbnMubm9uY2UpO1xuICB9XG5cbiAgc3R5bGUuaW5uZXJIVE1MID0gcmVwbGFjZVN0eWxlKGNsYXNzTmFtZSwgY3NzLCBvcHRpb25zKTtcbiAgKHNoYWRvd1Jvb3QgfHwgZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gc3R5bGVkIG9iamVjdCB0aGF0IGNhbiBiZSBkZWZpbmVkIGFuZCBpbnNlcnRlZCBpbnRvIHRoZSBjc3MuXG4gKiBAcGFyYW0gLSBjc3Mgc3R5bGVzXG4gKi9cblxuZnVuY3Rpb24gc3R5bGVkKGNzcykge1xuICB2YXIgaW5qZWN0Q2xhc3NOYW1lID0gXCJyQ1NcIiArIGdldEhhc2goY3NzKTtcbiAgdmFyIGluamVjdENvdW50ID0gMDtcbiAgdmFyIGluamVjdEVsZW1lbnQ7XG4gIHJldHVybiB7XG4gICAgY2xhc3NOYW1lOiBpbmplY3RDbGFzc05hbWUsXG4gICAgaW5qZWN0OiBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGdldFNoYWRvd1Jvb3QoZWwpO1xuICAgICAgdmFyIGZpcnN0TW91bnQgPSBpbmplY3RDb3VudCA9PT0gMDtcbiAgICAgIHZhciBzdHlsZUVsZW1lbnQ7XG5cbiAgICAgIGlmIChzaGFkb3dSb290IHx8IGZpcnN0TW91bnQpIHtcbiAgICAgICAgc3R5bGVFbGVtZW50ID0gaW5qZWN0U3R5bGUoaW5qZWN0Q2xhc3NOYW1lLCBjc3MsIG9wdGlvbnMsIHNoYWRvd1Jvb3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RNb3VudCkge1xuICAgICAgICBpbmplY3RFbGVtZW50ID0gc3R5bGVFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgKytpbmplY3RDb3VudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluamVjdENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAtLWluamVjdENvdW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5qZWN0Q291bnQgPT09IDAgJiYgaW5qZWN0RWxlbWVudCkge1xuICAgICAgICAgICAgICBpbmplY3RFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5qZWN0RWxlbWVudCk7XG4gICAgICAgICAgICAgIGluamVjdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlZC5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiByZWFjdC1jb21wYXQtbW92ZWFibGVcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL21vdmVhYmxlL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3JlYWN0LWNvbXBhdC1tb3ZlYWJsZVxudmVyc2lvbjogMC4xNi4wXG4qL1xuaW1wb3J0IGdldEFnZW50IGZyb20gJ0BlZ2pzL2FnZW50JztcbmltcG9ydCB7IHByZWZpeE5hbWVzLCByZWYsIHdpdGhNZXRob2RzLCByZWZzLCBwcmVmaXhDU1MgfSBmcm9tICdmcmFtZXdvcmstdXRpbHMnO1xuaW1wb3J0IHsgdGhyb3R0bGUsIGhhc0NsYXNzLCBnZXRSYWQsIGlzQXJyYXksIHNwbGl0U3BhY2UsIHRocm90dGxlQXJyYXksIGNvbnZlcnRVbml0U2l6ZSwgaXNTdHJpbmcsIGF2ZXJhZ2UsIGNhbGN1bGF0ZUJvdW5kU2l6ZSwgZ2V0RGlzdCBhcyBnZXREaXN0JDEsIGRvdCwgYWRkRXZlbnQsIGZpbmRJbmRleCwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCByZW1vdmVFdmVudCwgaXNVbmRlZmluZWQsIGdldFNoYXBlRGlyZWN0aW9uLCBhZGRDbGFzcywgc3BsaXRCcmFja2V0LCBzcGxpdENvbW1hLCBzcGxpdFVuaXQsIGNhbmNlbEFuaW1hdGlvbkZyYW1lLCBnZXRLZXlzLCBpc09iamVjdCwgaXNGdW5jdGlvbiwgVElOWV9OVU0gYXMgVElOWV9OVU0kMSwgcmVtb3ZlQ2xhc3MgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlSWRlbnRpdHlNYXRyaXgsIHBsdXMsIG1pbnVzLCBjYWxjdWxhdGUsIGNvbnZlcnRQb3NpdGlvbk1hdHJpeCwgY29udmVydERpbWVuc2lvbiwgaWdub3JlRGltZW5zaW9uLCBpbnZlcnQsIGNyZWF0ZVdhcnBNYXRyaXgsIG11bHRpcGx5LCBjb252ZXJ0TWF0cml4dG9DU1MsIGNyZWF0ZU9yaWdpbk1hdHJpeCwgbXVsdGlwbGllcywgZnJvbVRyYW5zbGF0aW9uLCByb3RhdGUsIGNyZWF0ZVJvdGF0ZU1hdHJpeCwgY29udmVydENTU3RvTWF0cml4LCBjcmVhdGVTY2FsZU1hdHJpeCwgZ2V0T3JpZ2luIH0gZnJvbSAnQHNjZW5hL21hdHJpeCc7XG5pbXBvcnQgeyB0b01hdCwgcGFyc2UsIGNhbGN1bGF0ZU1hdHJpeERpc3QsIHBhcnNlTWF0IH0gZnJvbSAnY3NzLXRvLW1hdCc7XG5pbXBvcnQgQ2hpbGRyZW5EaWZmZXIsIHsgZGlmZiB9IGZyb20gJ0BlZ2pzL2NoaWxkcmVuLWRpZmZlcic7XG5pbXBvcnQgeyBmaXRQb2ludHMsIGdldE92ZXJsYXBTaXplLCBnZXRBcmVhU2l6ZSwgaXNJbnNpZGUsIGdldE1pbk1heHMgfSBmcm9tICdvdmVybGFwLWFyZWEnO1xuaW1wb3J0IERyYWdTY3JvbGwgZnJvbSAnQHNjZW5hL2RyYWdzY3JvbGwnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0LXNpbXBsZS1jb21wYXQnO1xuaW1wb3J0IEdlc3RvIGZyb20gJ2dlc3RvJztcbmltcG9ydCBzdHlsZWQgZnJvbSAncmVhY3QtY29tcGF0LWNzcy1zdHlsZWQnO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiByZWFjdC1tb3ZlYWJsZVxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvbW92ZWFibGUvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcmVhY3QtbW92ZWFibGVcbnZlcnNpb246IDAuMzEuMFxuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuXG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcblxuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYyxcbiAgICAgIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cblxuZnVuY3Rpb24gbWFrZUFibGUobmFtZSwgYWJsZSkge1xuICB2YXIgX2E7XG5cbiAgcmV0dXJuIF9fYXNzaWduKHtcbiAgICBldmVudHM6IHt9LFxuICAgIHByb3BzOiAoX2EgPSB7fSwgX2FbbmFtZV0gPSBCb29sZWFuLCBfYSksXG4gICAgbmFtZTogbmFtZVxuICB9LCBhYmxlKTtcbn1cblxuZnVuY3Rpb24gZ2V0U1ZHQ3Vyc29yKHNjYWxlLCBkZWdyZWUpIHtcbiAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCJcIiArIDMyICogc2NhbGUgKyBcInB4XFxcIiBoZWlnaHQ9XFxcIlwiICsgMzIgKiBzY2FsZSArIFwicHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgPjxwYXRoIGQ9XFxcIk0gMTYsNSBMIDEyLDEwIEwgMTQuNSwxMCBMIDE0LjUsMjIgTCAxMiwyMiBMIDE2LDI3IEwgMjAsMjIgTCAxNy41LDIyIEwgMTcuNSwxMCBMIDIwLCAxMCBMIDE2LDUgWlxcXCIgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGZpbGw9XFxcImJsYWNrXFxcIiBzdHJva2U9XFxcIndoaXRlXFxcIiBzdHlsZT1cXFwidHJhbnNmb3JtOnJvdGF0ZShcIiArIGRlZ3JlZSArIFwiZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOiAxNnB4IDE2cHhcXFwiPjwvcGF0aD48L3N2Zz5cIjtcbn1cblxuZnVuY3Rpb24gZ2V0Q3Vyc29yQ1NTKGRlZ3JlZSkge1xuICB2YXIgeDEgPSBnZXRTVkdDdXJzb3IoMSwgZGVncmVlKTsgLy8gY29uc3QgeDIgPSBnZXRTVkdDdXJzb3IoMiwgZGVncmVlKTtcblxuICB2YXIgZGVncmVlNDUgPSBNYXRoLnJvdW5kKGRlZ3JlZSAvIDQ1KSAqIDQ1ICUgMTgwO1xuICB2YXIgZGVmYXVsdEN1cnNvciA9IFwibnMtcmVzaXplXCI7XG5cbiAgaWYgKGRlZ3JlZTQ1ID09PSAxMzUpIHtcbiAgICBkZWZhdWx0Q3Vyc29yID0gXCJud3NlLXJlc2l6ZVwiO1xuICB9IGVsc2UgaWYgKGRlZ3JlZTQ1ID09PSA0NSkge1xuICAgIGRlZmF1bHRDdXJzb3IgPSBcIm5lc3ctcmVzaXplXCI7XG4gIH0gZWxzZSBpZiAoZGVncmVlNDUgPT09IDkwKSB7XG4gICAgZGVmYXVsdEN1cnNvciA9IFwiZXctcmVzaXplXCI7XG4gIH0gLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcblxuXG4gIHJldHVybiBcImN1cnNvcjpcIiArIGRlZmF1bHRDdXJzb3IgKyBcIjtjdXJzb3I6IHVybCgnXCIgKyB4MSArIFwiJykgMTYgMTYsIFwiICsgZGVmYXVsdEN1cnNvciArIFwiO1wiO1xufVxuXG52YXIgYWdlbnQgPSBnZXRBZ2VudCgpO1xudmFyIElTX1dFQktJVCA9IGFnZW50LmJyb3dzZXIud2Via2l0O1xudmFyIElTX1dFQktJVDYwNSA9IElTX1dFQktJVCAmJiBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYXZpID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHtcbiAgICB1c2VyQWdlbnQ6IFwiXCJcbiAgfSA6IHdpbmRvdy5uYXZpZ2F0b3I7XG4gIHZhciByZXMgPSAvYXBwbGV3ZWJraXRcXC8oW15cXHNdKykvZy5leGVjKG5hdmkudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuICByZXR1cm4gcmVzID8gcGFyc2VGbG9hdChyZXNbMV0pIDwgNjA1IDogZmFsc2U7XG59KCk7XG52YXIgUFJFRklYID0gXCJtb3ZlYWJsZS1cIjtcbnZhciBNT1ZFQUJMRV9DU1MgPSBcIlxcbntcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0d2lkdGg6IDFweDtcXG5cXHRoZWlnaHQ6IDFweDtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG4gICAgei1pbmRleDogMzAwMDtcXG4gICAgLS1tb3ZlYWJsZS1jb2xvcjogIzRhZjtcXG4gICAgLS16b29tOiAxO1xcbiAgICAtLXpvb21weDogMXB4O1xcbiAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG4uY29udHJvbC1ib3gge1xcbiAgICB6LWluZGV4OiAwO1xcbn1cXG4ubGluZSwgLmNvbnRyb2wge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0bGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG4uY29udHJvbCB7XFxuXFx0d2lkdGg6IDE0cHg7XFxuXFx0aGVpZ2h0OiAxNHB4O1xcblxcdGJvcmRlci1yYWRpdXM6IDUwJTtcXG5cXHRib3JkZXI6IDJweCBzb2xpZCAjZmZmO1xcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGJhY2tncm91bmQ6ICM0YWY7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcXG5cXHRtYXJnaW4tdG9wOiAtN3B4O1xcbiAgICBtYXJnaW4tbGVmdDogLTdweDtcXG4gICAgYm9yZGVyOiAycHggc29saWQgI2ZmZjtcXG4gICAgei1pbmRleDogMTA7XFxufVxcbi5wYWRkaW5nIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDBweDtcXG4gICAgbGVmdDogMHB4O1xcbiAgICB3aWR0aDogMTAwcHg7XFxuICAgIGhlaWdodDogMTAwcHg7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXG59XFxuLmxpbmUge1xcblxcdHdpZHRoOiAxcHg7XFxuICAgIGhlaWdodDogMXB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjNGFmO1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxuXFx0dHJhbnNmb3JtLW9yaWdpbjogMHB4IDUwJTtcXG59XFxuLmxpbmUuZGFzaGVkIHtcXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxufVxcbi5saW5lLmRhc2hlZC5ob3Jpem9udGFsIHtcXG4gICAgYm9yZGVyLXRvcDogMXB4IGRhc2hlZCAjNGFmO1xcbiAgICBib3JkZXItdG9wLWNvbG9yOiAjNGFmO1xcbiAgICBib3JkZXItdG9wLWNvbG9yOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxufVxcbi5saW5lLmRhc2hlZC52ZXJ0aWNhbCB7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggZGFzaGVkICM0YWY7XFxuICAgIGJvcmRlci1sZWZ0LWNvbG9yOiAjNGFmO1xcbiAgICBib3JkZXItbGVmdC1jb2xvcjogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xcbn1cXG4ubGluZS52ZXJ0aWNhbCB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG59XFxuLmxpbmUuaG9yaXpvbnRhbCB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuLmxpbmUudmVydGljYWwuYm9sZCB7XFxuICAgIHdpZHRoOiAycHg7XFxufVxcbi5saW5lLmhvcml6b250YWwuYm9sZCB7XFxuICAgIGhlaWdodDogMnB4O1xcbn1cXG5cXG4uY29udHJvbC5vcmlnaW4ge1xcblxcdGJvcmRlci1jb2xvcjogI2Y1NTtcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcblxcdHdpZHRoOiAxMnB4O1xcblxcdGhlaWdodDogMTJweDtcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICBtYXJnaW4tbGVmdDogLTZweDtcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXCIgKyBbMCwgMTUsIDMwLCA0NSwgNjAsIDc1LCA5MCwgMTA1LCAxMjAsIDEzNSwgMTUwLCAxNjVdLm1hcChmdW5jdGlvbiAoZGVncmVlKSB7XG4gIHJldHVybiBcIlxcbi5kaXJlY3Rpb25bZGF0YS1yb3RhdGlvbj1cXFwiXCIgKyBkZWdyZWUgKyBcIlxcXCJdIHtcXG5cXHRcIiArIGdldEN1cnNvckNTUyhkZWdyZWUpICsgXCJcXG59XFxuXCI7XG59KS5qb2luKFwiXFxuXCIpICsgXCJcXG4uZ3JvdXAge1xcbiAgICB6LWluZGV4OiAtMTtcXG59XFxuLmFyZWEge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5hcmVhLXBpZWNlcyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBkaXNwbGF5OiBub25lO1xcbn1cXG4uYXJlYS5hdm9pZCwgLmFyZWEucGFzcyB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG4uYXJlYS5hdm9pZCsuYXJlYS1waWVjZXMge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmFyZWEtcGllY2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcblwiICsgKElTX1dFQktJVDYwNSA/IFwiOmdsb2JhbCBzdmcgKjpiZWZvcmUge1xcblxcdGNvbnRlbnQ6XFxcIlxcXCI7XFxuXFx0dHJhbnNmb3JtLW9yaWdpbjogaW5oZXJpdDtcXG59XCIgOiBcIlwiKSArIFwiXFxuXCI7XG52YXIgTkVBUkJZX1BPUyA9IFtbMCwgMSwgMl0sIFsxLCAwLCAzXSwgWzIsIDAsIDNdLCBbMywgMSwgMl1dO1xudmFyIEZMT0FUX1BPSU5UX05VTSA9IDAuMDAwMTtcbnZhciBUSU5ZX05VTSA9IDAuMDAwMDAwMTtcbnZhciBNSU5fU0NBTEUgPSAwLjAwMDAwMDAwMTtcbnZhciBNQVhfTlVNID0gTWF0aC5wb3coMTAsIDEwKTtcbnZhciBNSU5fTlVNID0gLU1BWF9OVU07XG52YXIgRElSRUNUSU9OUyA9IFtcIm5cIiwgXCJ3XCIsIFwic1wiLCBcImVcIiwgXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXTtcbnZhciBESVJFQ1RJT05fSU5ERVhFUyA9IHtcbiAgbjogWzAsIDFdLFxuICBzOiBbMiwgM10sXG4gIHc6IFsyLCAwXSxcbiAgZTogWzEsIDNdLFxuICBudzogWzBdLFxuICBuZTogWzFdLFxuICBzdzogWzJdLFxuICBzZTogWzNdXG59O1xudmFyIERJUkVDVElPTl9ST1RBVElPTlMgPSB7XG4gIG46IDAsXG4gIHM6IDE4MCxcbiAgdzogMjcwLFxuICBlOiA5MCxcbiAgbnc6IDMxNSxcbiAgbmU6IDQ1LFxuICBzdzogMjI1LFxuICBzZTogMTM1XG59O1xudmFyIE1PVkVBQkxFX01FVEhPRFMgPSBbXCJpc01vdmVhYmxlRWxlbWVudFwiLCBcInVwZGF0ZVJlY3RcIiwgXCJ1cGRhdGVUYXJnZXRcIiwgXCJkZXN0cm95XCIsIFwiZHJhZ1N0YXJ0XCIsIFwiaXNJbnNpZGVcIiwgXCJoaXRUZXN0XCIsIFwic2V0U3RhdGVcIiwgXCJnZXRSZWN0XCIsIFwicmVxdWVzdFwiLCBcImlzRHJhZ2dpbmdcIiwgXCJnZXRNYW5hZ2VyXCIsIFwiZm9yY2VVcGRhdGVcIl07XG5cbmZ1bmN0aW9uIG11bHRpcGx5Mihwb3MxLCBwb3MyKSB7XG4gIHJldHVybiBbcG9zMVswXSAqIHBvczJbMF0sIHBvczFbMV0gKiBwb3MyWzFdXTtcbn1cbmZ1bmN0aW9uIHByZWZpeCgpIHtcbiAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGNsYXNzTmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHJldHVybiBwcmVmaXhOYW1lcy5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW1BSRUZJWF0sIGNsYXNzTmFtZXMpKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybU1hdHJpeCh0cmFuc2Zvcm0pIHtcbiAgaWYgKCF0cmFuc2Zvcm0gfHwgdHJhbnNmb3JtID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiBbMSwgMCwgMCwgMSwgMCwgMF07XG4gIH1cblxuICBpZiAoaXNPYmplY3QodHJhbnNmb3JtKSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH1cblxuICB2YXIgdmFsdWUgPSBzcGxpdEJyYWNrZXQodHJhbnNmb3JtKS52YWx1ZTtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC9zKixcXHMqL2cpLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHYpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFic29sdXRlTWF0cml4KG1hdHJpeCwgbiwgb3JpZ2luKSB7XG4gIHJldHVybiBtdWx0aXBsaWVzKG4sIGNyZWF0ZU9yaWdpbk1hdHJpeChvcmlnaW4sIG4pLCBtYXRyaXgsIGNyZWF0ZU9yaWdpbk1hdHJpeChvcmlnaW4ubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIC1hO1xuICB9KSwgbikpO1xufVxuZnVuY3Rpb24gbWVhc3VyZVNWR1NpemUoZWwsIHVuaXQsIGlzSG9yaXpvbnRhbCkge1xuICBpZiAodW5pdCA9PT0gXCIlXCIpIHtcbiAgICB2YXIgdmlld0JveCA9IGdldFNWR1ZpZXdCb3goZWwub3duZXJTVkdFbGVtZW50KTtcbiAgICByZXR1cm4gdmlld0JveFtpc0hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSAvIDEwMDtcbiAgfVxuXG4gIHJldHVybiAxO1xufVxuZnVuY3Rpb24gZ2V0QmVmb3JlVHJhbnNmb3JtT3JpZ2luKGVsKSB7XG4gIHZhciByZWxhdGl2ZU9yaWdpbiA9IGdldFRyYW5zZm9ybU9yaWdpbihnZXRDb21wdXRlZFN0eWxlKGVsLCBcIjpiZWZvcmVcIikpO1xuICByZXR1cm4gcmVsYXRpdmVPcmlnaW4ubWFwKGZ1bmN0aW9uIChvLCBpKSB7XG4gICAgdmFyIF9hID0gc3BsaXRVbml0KG8pLFxuICAgICAgICB2YWx1ZSA9IF9hLnZhbHVlLFxuICAgICAgICB1bml0ID0gX2EudW5pdDtcblxuICAgIHJldHVybiB2YWx1ZSAqIG1lYXN1cmVTVkdTaXplKGVsLCB1bml0LCBpID09PSAwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1PcmlnaW4oc3R5bGUpIHtcbiAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLnRyYW5zZm9ybU9yaWdpbjtcbiAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpbiA/IHRyYW5zZm9ybU9yaWdpbi5zcGxpdChcIiBcIikgOiBbXCIwXCIsIFwiMFwiXTtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldEluZm8oZWwsIGxhc3RQYXJlbnQsIGlzUGFyZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIHRhcmdldCA9ICFlbCB8fCBpc1BhcmVudCA/IGVsIDogZWwucGFyZW50RWxlbWVudDtcbiAgdmFyIGlzRW5kID0gZWwgPT09IGxhc3RQYXJlbnQgfHwgdGFyZ2V0ID09PSBsYXN0UGFyZW50O1xuICB2YXIgcG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cbiAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGJvZHkpIHtcbiAgICBpZiAobGFzdFBhcmVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICBpc0VuZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm07XG4gICAgcG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbjtcblxuICAgIGlmICh0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiIHx8IHBvc2l0aW9uICE9PSBcInN0YXRpY1wiIHx8IHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0gIT09IFwibm9uZVwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICBwb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNTdGF0aWM6IHBvc2l0aW9uID09PSBcInN0YXRpY1wiLFxuICAgIGlzRW5kOiBpc0VuZCB8fCAhdGFyZ2V0IHx8IHRhcmdldCA9PT0gYm9keSxcbiAgICBvZmZzZXRQYXJlbnQ6IHRhcmdldCB8fCBib2R5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRPZmZzZXRQb3NJbmZvKGVsLCBjb250YWluZXIsIHN0eWxlLCBpc0ZpeGVkKSB7XG4gIHZhciBfYTtcblxuICB2YXIgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIG9mZnNldExlZnQgPSBlbC5vZmZzZXRMZWZ0O1xuICB2YXIgb2Zmc2V0VG9wID0gZWwub2Zmc2V0VG9wO1xuXG4gIGlmIChpc0ZpeGVkKSB7XG4gICAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSAoY29udGFpbmVyIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgb2Zmc2V0TGVmdCAtPSBjb250YWluZXJDbGllbnRSZWN0LmxlZnQ7XG4gICAgb2Zmc2V0VG9wIC09IGNvbnRhaW5lckNsaWVudFJlY3QudG9wO1xuICB9IC8vIHN2Z1xuXG5cbiAgdmFyIGlzU1ZHID0gaXNVbmRlZmluZWQob2Zmc2V0TGVmdCk7XG4gIHZhciBoYXNPZmZzZXQgPSAhaXNTVkc7XG4gIHZhciBvcmlnaW47XG4gIHZhciB0YXJnZXRPcmlnaW47IC8vIGlubmVyIHN2ZyBlbGVtZW50XG5cbiAgaWYgKCFoYXNPZmZzZXQgJiYgdGFnTmFtZSAhPT0gXCJzdmdcIikge1xuICAgIG9yaWdpbiA9IElTX1dFQktJVDYwNSA/IGdldEJlZm9yZVRyYW5zZm9ybU9yaWdpbihlbCkgOiBnZXRUcmFuc2Zvcm1PcmlnaW4oc3R5bGUpLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChwb3MpO1xuICAgIH0pO1xuICAgIHRhcmdldE9yaWdpbiA9IG9yaWdpbi5zbGljZSgpO1xuICAgIGhhc09mZnNldCA9IHRydWU7XG4gICAgX2EgPSBnZXRTVkdHcmFwaGljc09mZnNldChlbCwgb3JpZ2luKSwgb2Zmc2V0TGVmdCA9IF9hWzBdLCBvZmZzZXRUb3AgPSBfYVsxXSwgb3JpZ2luWzBdID0gX2FbMl0sIG9yaWdpblsxXSA9IF9hWzNdO1xuICB9IGVsc2Uge1xuICAgIG9yaWdpbiA9IGdldFRyYW5zZm9ybU9yaWdpbihzdHlsZSkubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBvcyk7XG4gICAgfSk7XG4gICAgdGFyZ2V0T3JpZ2luID0gb3JpZ2luLnNsaWNlKCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgaXNTVkc6IGlzU1ZHLFxuICAgIGhhc09mZnNldDogaGFzT2Zmc2V0LFxuICAgIG9mZnNldDogW29mZnNldExlZnQgfHwgMCwgb2Zmc2V0VG9wIHx8IDBdLFxuICAgIG9yaWdpbjogb3JpZ2luLFxuICAgIHRhcmdldE9yaWdpbjogdGFyZ2V0T3JpZ2luXG4gIH07XG59XG5mdW5jdGlvbiBnZXRCb2R5T2Zmc2V0KGVsLCBpc1NWRywgc3R5bGUpIHtcbiAgaWYgKHN0eWxlID09PSB2b2lkIDApIHtcbiAgICBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB9XG5cbiAgdmFyIGJvZHlTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gIHZhciBib2R5UG9zaXRpb24gPSBib2R5U3R5bGUucG9zaXRpb247XG5cbiAgaWYgKCFpc1NWRyAmJiAoIWJvZHlQb3NpdGlvbiB8fCBib2R5UG9zaXRpb24gPT09IFwic3RhdGljXCIpKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuXG4gIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VJbnQoYm9keVN0eWxlLm1hcmdpbkxlZnQsIDEwKTtcbiAgdmFyIG1hcmdpblRvcCA9IHBhcnNlSW50KGJvZHlTdHlsZS5tYXJnaW5Ub3AsIDEwKTtcblxuICBpZiAoc3R5bGUucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIikge1xuICAgIGlmIChzdHlsZS50b3AgIT09IFwiYXV0b1wiIHx8IHN0eWxlLmJvdHRvbSAhPT0gXCJhdXRvXCIpIHtcbiAgICAgIG1hcmdpblRvcCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLmxlZnQgIT09IFwiYXV0b1wiIHx8IHN0eWxlLnJpZ2h0ICE9PSBcImF1dG9cIikge1xuICAgICAgbWFyZ2luTGVmdCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttYXJnaW5MZWZ0LCBtYXJnaW5Ub3BdO1xufVxuZnVuY3Rpb24gY29udmVydDNETWF0cml4ZXMobWF0cml4ZXMpIHtcbiAgbWF0cml4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgIHZhciBtYXRyaXggPSBpbmZvLm1hdHJpeDtcblxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIGluZm8ubWF0cml4ID0gY29udmVydERpbWVuc2lvbihtYXRyaXgsIDMsIDQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRNYXRyaXhTdGFja0luZm8odGFyZ2V0LCBjb250YWluZXIsIGNoZWNrQ29udGFpbmVyKSB7XG4gIHZhciBlbCA9IHRhcmdldDtcbiAgdmFyIG1hdHJpeGVzID0gW107XG4gIHZhciByZXF1ZXN0RW5kID0gIWNoZWNrQ29udGFpbmVyICYmIHRhcmdldCA9PT0gY29udGFpbmVyO1xuICB2YXIgaXNFbmQgPSByZXF1ZXN0RW5kO1xuICB2YXIgaXMzZCA9IGZhbHNlO1xuICB2YXIgbiA9IDM7XG4gIHZhciB0cmFuc2Zvcm1PcmlnaW47XG4gIHZhciB0YXJnZXRUcmFuc2Zvcm1PcmlnaW47XG4gIHZhciB0YXJnZXRNYXRyaXg7XG4gIHZhciBvZmZzZXRDb250YWluZXIgPSBnZXRPZmZzZXRJbmZvKGNvbnRhaW5lciwgY29udGFpbmVyLCB0cnVlKS5vZmZzZXRQYXJlbnQ7XG5cbiAgd2hpbGUgKGVsICYmICFpc0VuZCkge1xuICAgIGlzRW5kID0gcmVxdWVzdEVuZDtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICB2YXIgcG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbjtcbiAgICB2YXIgaXNGaXhlZCA9IHBvc2l0aW9uID09PSBcImZpeGVkXCI7XG4gICAgdmFyIG1hdHJpeCA9IGNvbnZlcnRDU1N0b01hdHJpeChnZXRUcmFuc2Zvcm1NYXRyaXgoc3R5bGUudHJhbnNmb3JtKSk7IC8vIGNvbnZlcnQgMyB0byA0XG5cbiAgICB2YXIgbGVuZ3RoID0gbWF0cml4Lmxlbmd0aDtcblxuICAgIGlmICghaXMzZCAmJiBsZW5ndGggPT09IDE2KSB7XG4gICAgICBpczNkID0gdHJ1ZTtcbiAgICAgIG4gPSA0O1xuICAgICAgY29udmVydDNETWF0cml4ZXMobWF0cml4ZXMpO1xuXG4gICAgICBpZiAodGFyZ2V0TWF0cml4KSB7XG4gICAgICAgIHRhcmdldE1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24odGFyZ2V0TWF0cml4LCAzLCA0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXMzZCAmJiBsZW5ndGggPT09IDkpIHtcbiAgICAgIG1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24obWF0cml4LCAzLCA0KTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBnZXRPZmZzZXRQb3NJbmZvKGVsLCBjb250YWluZXIsIHN0eWxlLCBpc0ZpeGVkKSxcbiAgICAgICAgdGFnTmFtZSA9IF9hLnRhZ05hbWUsXG4gICAgICAgIGhhc09mZnNldCA9IF9hLmhhc09mZnNldCxcbiAgICAgICAgaXNTVkcgPSBfYS5pc1NWRyxcbiAgICAgICAgb3JpZ2luID0gX2Eub3JpZ2luLFxuICAgICAgICB0YXJnZXRPcmlnaW4gPSBfYS50YXJnZXRPcmlnaW4sXG4gICAgICAgIG9mZnNldFBvcyA9IF9hLm9mZnNldDtcblxuICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0UG9zWzBdLFxuICAgICAgICBvZmZzZXRUb3AgPSBvZmZzZXRQb3NbMV07XG5cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJzdmdcIiAmJiB0YXJnZXRNYXRyaXgpIHtcbiAgICAgIC8vIHNjYWxlIG1hdHJpeCBmb3Igc3ZnJ3MgU1ZHRWxlbWVudHMuXG4gICAgICBtYXRyaXhlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0YXJnZXRcIixcbiAgICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgICAgbWF0cml4OiBnZXRTVkdNYXRyaXgoZWwsIG4pXG4gICAgICB9KTtcbiAgICAgIG1hdHJpeGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBcIm9mZnNldFwiLFxuICAgICAgICB0YXJnZXQ6IGVsLFxuICAgICAgICBtYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09IFwiZ1wiICYmIHRhcmdldCAhPT0gZWwpIHtcbiAgICAgIG9mZnNldExlZnQgPSAwO1xuICAgICAgb2Zmc2V0VG9wID0gMDtcbiAgICB9XG5cbiAgICB2YXIgX2IgPSBnZXRPZmZzZXRJbmZvKGVsLCBjb250YWluZXIpLFxuICAgICAgICBvZmZzZXRQYXJlbnQgPSBfYi5vZmZzZXRQYXJlbnQsXG4gICAgICAgIGlzT2Zmc2V0RW5kID0gX2IuaXNFbmQsXG4gICAgICAgIGlzU3RhdGljID0gX2IuaXNTdGF0aWM7XG5cbiAgICBpZiAoSVNfV0VCS0lUICYmIGhhc09mZnNldCAmJiAhaXNTVkcgJiYgaXNTdGF0aWMgJiYgKHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcG9zaXRpb24gPT09IFwic3RhdGljXCIpKSB7XG4gICAgICBvZmZzZXRMZWZ0IC09IG9mZnNldFBhcmVudC5vZmZzZXRMZWZ0O1xuICAgICAgb2Zmc2V0VG9wIC09IG9mZnNldFBhcmVudC5vZmZzZXRUb3A7XG4gICAgICByZXF1ZXN0RW5kID0gcmVxdWVzdEVuZCB8fCBpc09mZnNldEVuZDtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50Q2xpZW50TGVmdCA9IDA7XG4gICAgdmFyIHBhcmVudENsaWVudFRvcCA9IDA7XG5cbiAgICBpZiAoaGFzT2Zmc2V0ICYmIG9mZnNldENvbnRhaW5lciAhPT0gb2Zmc2V0UGFyZW50KSB7XG4gICAgICAvLyBib3JkZXJcbiAgICAgIHBhcmVudENsaWVudExlZnQgPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIHBhcmVudENsaWVudFRvcCA9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfVxuXG4gICAgaWYgKGhhc09mZnNldCAmJiBvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIHZhciBtYXJnaW4gPSBnZXRCb2R5T2Zmc2V0KGVsLCBmYWxzZSwgc3R5bGUpO1xuICAgICAgb2Zmc2V0TGVmdCArPSBtYXJnaW5bMF07XG4gICAgICBvZmZzZXRUb3AgKz0gbWFyZ2luWzFdO1xuICAgIH1cblxuICAgIG1hdHJpeGVzLnB1c2goe1xuICAgICAgdHlwZTogXCJ0YXJnZXRcIixcbiAgICAgIHRhcmdldDogZWwsXG4gICAgICBtYXRyaXg6IGdldEFic29sdXRlTWF0cml4KG1hdHJpeCwgbiwgb3JpZ2luKVxuICAgIH0pO1xuXG4gICAgaWYgKGhhc09mZnNldCkge1xuICAgICAgbWF0cml4ZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwib2Zmc2V0XCIsXG4gICAgICAgIHRhcmdldDogZWwsXG4gICAgICAgIG1hdHJpeDogY3JlYXRlT3JpZ2luTWF0cml4KFtvZmZzZXRMZWZ0IC0gZWwuc2Nyb2xsTGVmdCArIHBhcmVudENsaWVudExlZnQsIG9mZnNldFRvcCAtIGVsLnNjcm9sbFRvcCArIHBhcmVudENsaWVudFRvcF0sIG4pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3ZnXG4gICAgICBtYXRyaXhlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJvZmZzZXRcIixcbiAgICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgICAgb3JpZ2luOiBvcmlnaW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0TWF0cml4KSB7XG4gICAgICB0YXJnZXRNYXRyaXggPSBtYXRyaXg7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldFRyYW5zZm9ybU9yaWdpbikge1xuICAgICAgdGFyZ2V0VHJhbnNmb3JtT3JpZ2luID0gdGFyZ2V0T3JpZ2luO1xuICAgIH1cblxuICAgIGlmIChpc0VuZCB8fCBpc0ZpeGVkKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgZWwgPSBvZmZzZXRQYXJlbnQ7XG4gICAgICByZXF1ZXN0RW5kID0gaXNPZmZzZXRFbmQ7XG4gICAgfVxuXG4gICAgaWYgKCFjaGVja0NvbnRhaW5lciB8fCBlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgaXNFbmQgPSByZXF1ZXN0RW5kO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGFyZ2V0TWF0cml4KSB7XG4gICAgdGFyZ2V0TWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIH1cblxuICBpZiAoIXRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRyYW5zZm9ybU9yaWdpbiA9IFswLCAwXTtcbiAgfVxuXG4gIGlmICghdGFyZ2V0VHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdGFyZ2V0VHJhbnNmb3JtT3JpZ2luID0gWzAsIDBdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvZmZzZXRDb250YWluZXI6IG9mZnNldENvbnRhaW5lcixcbiAgICBtYXRyaXhlczogbWF0cml4ZXMsXG4gICAgdGFyZ2V0TWF0cml4OiB0YXJnZXRNYXRyaXgsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXG4gICAgdGFyZ2V0T3JpZ2luOiB0YXJnZXRUcmFuc2Zvcm1PcmlnaW4sXG4gICAgaXMzZDogaXMzZFxuICB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRWxlbWVudEluZm8odGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIGlzQWJzb2x1dGUzZCkge1xuICB2YXIgX2E7XG5cbiAgaWYgKHJvb3RDb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgIHJvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gIH1cblxuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgdmFyIHJvdGF0aW9uID0gMDtcbiAgdmFyIGFsbFJlc3VsdCA9IHt9O1xuXG4gIGlmICh0YXJnZXQpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgd2lkdGggPSB0YXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gdGFyZ2V0Lm9mZnNldEhlaWdodDtcblxuICAgIGlmIChpc1VuZGVmaW5lZCh3aWR0aCkpIHtcbiAgICAgIF9hID0gZ2V0U2l6ZSh0YXJnZXQsIHN0eWxlLCB0cnVlKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhcmdldCkge1xuICAgIHZhciByZXN1bHQgPSBjYWxjdWxhdGVNYXRyaXhTdGFjayh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgaXNBYnNvbHV0ZTNkKTtcbiAgICB2YXIgcG9zaXRpb24gPSBjYWxjdWxhdGVNb3ZlYWJsZVBvc2l0aW9uKHJlc3VsdC5hbGxNYXRyaXgsIHJlc3VsdC50cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQpO1xuICAgIGFsbFJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCBwb3NpdGlvbik7XG4gICAgdmFyIHJvdGF0aW9uUG9zaXRpb24gPSBjYWxjdWxhdGVNb3ZlYWJsZVBvc2l0aW9uKHJlc3VsdC5hbGxNYXRyaXgsIFs1MCwgNTBdLCAxMDAsIDEwMCk7XG4gICAgcm90YXRpb24gPSBnZXRSb3RhdGlvblJhZChbcm90YXRpb25Qb3NpdGlvbi5wb3MxLCByb3RhdGlvblBvc2l0aW9uLnBvczJdLCByb3RhdGlvblBvc2l0aW9uLmRpcmVjdGlvbik7XG4gIH1cblxuICB2YXIgbiA9IGlzQWJzb2x1dGUzZCA/IDQgOiAzO1xuICByZXR1cm4gX19hc3NpZ24oe1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgLy8gcm9vdE1hdHJpeDogbnVtYmVyW107XG4gICAgLy8gYmVmb3JlTWF0cml4OiBudW1iZXJbXTtcbiAgICAvLyBvZmZzZXRNYXRyaXg6IG51bWJlcltdO1xuICAgIC8vIGFsbE1hdHJpeDogbnVtYmVyW107XG4gICAgLy8gdGFyZ2V0TWF0cml4OiBudW1iZXJbXTtcbiAgICAvLyB0YXJnZXRUcmFuc2Zvcm06IHN0cmluZztcbiAgICAvLyB0cmFuc2Zvcm1PcmlnaW46IG51bWJlcltdO1xuICAgIC8vIHRhcmdldE9yaWdpbjogbnVtYmVyW107XG4gICAgLy8gaXMzZDogYm9vbGVhbjtcbiAgICByb290TWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSxcbiAgICBiZWZvcmVNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLFxuICAgIG9mZnNldE1hdHJpeDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobiksXG4gICAgYWxsTWF0cml4OiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSxcbiAgICB0YXJnZXRNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLFxuICAgIHRhcmdldFRyYW5zZm9ybTogXCJcIixcbiAgICB0cmFuc2Zvcm1PcmlnaW46IFswLCAwXSxcbiAgICB0YXJnZXRPcmlnaW46IFswLCAwXSxcbiAgICBpczNkOiAhIWlzQWJzb2x1dGUzZCxcbiAgICAvLyBsZWZ0OiBudW1iZXI7XG4gICAgLy8gdG9wOiBudW1iZXI7XG4gICAgLy8gcmlnaHQ6IG51bWJlcjtcbiAgICAvLyBib3R0b206IG51bWJlcjtcbiAgICAvLyBvcmlnaW46IG51bWJlcltdO1xuICAgIC8vIHBvczE6IG51bWJlcltdO1xuICAgIC8vIHBvczI6IG51bWJlcltdO1xuICAgIC8vIHBvczM6IG51bWJlcltdO1xuICAgIC8vIHBvczQ6IG51bWJlcltdO1xuICAgIC8vIGRpcmVjdGlvbjogMSB8IC0xO1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBvcmlnaW46IFswLCAwXSxcbiAgICBwb3MxOiBbMCwgMF0sXG4gICAgcG9zMjogWzAsIDBdLFxuICAgIHBvczM6IFswLCAwXSxcbiAgICBwb3M0OiBbMCwgMF0sXG4gICAgZGlyZWN0aW9uOiAxXG4gIH0sIGFsbFJlc3VsdCk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50SW5mbyh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lcikge1xuICBpZiAocm9vdENvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgcm9vdENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIHJldHVybiBjYWxjdWxhdGVFbGVtZW50SW5mbyh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVNYXRyaXhTdGFjayh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgaXNBYnNvbHV0ZTNkKSB7XG4gIHZhciBfYTtcblxuICBpZiAocm9vdENvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgcm9vdENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIHZhciBfYiA9IGdldE1hdHJpeFN0YWNrSW5mbyh0YXJnZXQsIGNvbnRhaW5lciksXG4gICAgICBtYXRyaXhlcyA9IF9iLm1hdHJpeGVzLFxuICAgICAgaXMzZCA9IF9iLmlzM2QsXG4gICAgICBwcmV2VGFyZ2V0TWF0cml4ID0gX2IudGFyZ2V0TWF0cml4LFxuICAgICAgdHJhbnNmb3JtT3JpZ2luID0gX2IudHJhbnNmb3JtT3JpZ2luLFxuICAgICAgdGFyZ2V0T3JpZ2luID0gX2IudGFyZ2V0T3JpZ2luLFxuICAgICAgb2Zmc2V0Q29udGFpbmVyID0gX2Iub2Zmc2V0Q29udGFpbmVyOyAvLyBwcmV2TWF0cml4XG5cblxuICB2YXIgX2MgPSBnZXRNYXRyaXhTdGFja0luZm8ob2Zmc2V0Q29udGFpbmVyLCByb290Q29udGFpbmVyLCB0cnVlKSxcbiAgICAgIHJvb3RNYXRyaXhlcyA9IF9jLm1hdHJpeGVzLFxuICAgICAgaXNSb290M2QgPSBfYy5pczNkOyAvLyBwcmV2Um9vdE1hdHJpeFxuICAvLyBpZiAocm9vdENvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAvLyAgICAgY29uc29sZS5sb2cob2Zmc2V0Q29udGFpbmVyLCByb290Q29udGFpbmVyLCByb290TWF0cml4ZXMpO1xuICAvLyB9XG5cblxuICB2YXIgaXNOZXh0M2QgPSBpc0Fic29sdXRlM2QgfHwgaXNSb290M2QgfHwgaXMzZDtcbiAgdmFyIG4gPSBpc05leHQzZCA/IDQgOiAzO1xuICB2YXIgaXNTVkdHcmFwaGljRWxlbWVudCA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwic3ZnXCIgJiYgXCJvd25lclNWR0VsZW1lbnRcIiBpbiB0YXJnZXQ7XG4gIHZhciB0YXJnZXRNYXRyaXggPSBwcmV2VGFyZ2V0TWF0cml4OyAvLyBsZXQgYWxsTWF0cml4ID0gcHJldk1hdHJpeCA/IGNvbnZlcnREaW1lbnNpb24ocHJldk1hdHJpeCwgcHJldk4hLCBuKSA6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICAvLyBsZXQgcm9vdE1hdHJpeCA9IHByZXZSb290TWF0cml4ID8gY29udmVydERpbWVuc2lvbihwcmV2Um9vdE1hdHJpeCwgcHJldk4hLCBuKSA6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICAvLyBsZXQgYmVmb3JlTWF0cml4ID0gcHJldk1hdHJpeCA/IGNvbnZlcnREaW1lbnNpb24ocHJldk1hdHJpeCwgcHJldk4hLCBuKSA6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuXG4gIHZhciBhbGxNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcbiAgdmFyIHJvb3RNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcbiAgdmFyIGJlZm9yZU1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuICB2YXIgb2Zmc2V0TWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIHZhciBsZW5ndGggPSBtYXRyaXhlcy5sZW5ndGg7XG4gIHJvb3RNYXRyaXhlcy5yZXZlcnNlKCk7XG4gIG1hdHJpeGVzLnJldmVyc2UoKTtcblxuICBpZiAoIWlzM2QgJiYgaXNOZXh0M2QpIHtcbiAgICB0YXJnZXRNYXRyaXggPSBjb252ZXJ0RGltZW5zaW9uKHRhcmdldE1hdHJpeCwgMywgNCk7XG4gICAgY29udmVydDNETWF0cml4ZXMobWF0cml4ZXMpO1xuICB9XG5cbiAgaWYgKCFpc1Jvb3QzZCAmJiBpc05leHQzZCkge1xuICAgIGNvbnZlcnQzRE1hdHJpeGVzKHJvb3RNYXRyaXhlcyk7XG4gIH0gLy8gcm9vdE1hdHJpeCA9ICguLi4pIC0+IGNvbnRhaW5lciAtPiBvZmZzZXQgLT4gYWJzb2x1dGUgLT4gb2Zmc2V0IC0+IGFic29sdXRlKHRhcmdldE1hdHJpeClcbiAgLy8gcm9vdE1hdHJpeEJlZm9yZU9mZnNldCA9IGxhc3RPZmZzZXRNYXRyaXggLT4gKC4uLikgLT4gY29udGFpbmVyXG4gIC8vIGJlZm9yZU1hdHJpeCA9ICguLi4gLT4gY29udGFpbmVyIC0+IG9mZnNldCAtPiBhYnNvbHV0ZSkgLT4gb2Zmc2V0IC0+IGFic29sdXRlKHRhcmdldE1hdHJpeClcbiAgLy8gb2Zmc2V0TWF0cml4ID0gKC4uLiAtPiBjb250YWluZXIgLT4gb2Zmc2V0IC0+IGFic29sdXRlIC0+IG9mZnNldCkgLT4gYWJzb2x1dGUodGFyZ2V0TWF0cml4KVxuXG5cbiAgcm9vdE1hdHJpeGVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICByb290TWF0cml4ID0gbXVsdGlwbHkocm9vdE1hdHJpeCwgaW5mby5tYXRyaXgsIG4pO1xuICB9KTtcbiAgdmFyIG9yaWdpbmFsUm9vdENvbnRhaW5lciA9IHJvb3RDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgdmFyIGVuZENvbnRhaW5lciA9ICgoX2EgPSByb290TWF0cml4ZXNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXQpIHx8IGdldE9mZnNldEluZm8ob3JpZ2luYWxSb290Q29udGFpbmVyLCBvcmlnaW5hbFJvb3RDb250YWluZXIsIHRydWUpLm9mZnNldFBhcmVudDtcbiAgdmFyIHJvb3RNYXRyaXhCZWZvcmVPZmZzZXQgPSByb290TWF0cml4ZXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uIChtYXRyaXgsIGluZm8pIHtcbiAgICByZXR1cm4gbXVsdGlwbHkobWF0cml4LCBpbmZvLm1hdHJpeCwgbik7XG4gIH0sIGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pKTtcbiAgbWF0cml4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbywgaSkge1xuICAgIGlmIChsZW5ndGggLSAyID09PSBpKSB7XG4gICAgICAvLyBsZW5ndGggLSAzXG4gICAgICBiZWZvcmVNYXRyaXggPSBhbGxNYXRyaXguc2xpY2UoKTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoIC0gMSA9PT0gaSkge1xuICAgICAgLy8gbGVuZ3RoIC0gMlxuICAgICAgb2Zmc2V0TWF0cml4ID0gYWxsTWF0cml4LnNsaWNlKCk7XG4gICAgfSAvLyBjYWxjdWxhdGUgZm9yIFNWR0VsZW1lbnRcblxuXG4gICAgaWYgKCFpbmZvLm1hdHJpeCkge1xuICAgICAgdmFyIG5leHRJbmZvID0gbWF0cml4ZXNbaSArIDFdO1xuICAgICAgdmFyIG9mZnNldCA9IGdldFNWR09mZnNldChpbmZvLCBuZXh0SW5mbywgZW5kQ29udGFpbmVyLCBuLCBtdWx0aXBseShyb290TWF0cml4QmVmb3JlT2Zmc2V0LCBhbGxNYXRyaXgsIG4pKTtcbiAgICAgIGluZm8ubWF0cml4ID0gY3JlYXRlT3JpZ2luTWF0cml4KG9mZnNldCwgbik7XG4gICAgfVxuXG4gICAgYWxsTWF0cml4ID0gbXVsdGlwbHkoYWxsTWF0cml4LCBpbmZvLm1hdHJpeCwgbik7XG4gIH0pO1xuICB2YXIgaXNNYXRyaXgzZCA9ICFpc1NWR0dyYXBoaWNFbGVtZW50ICYmIGlzM2Q7XG5cbiAgaWYgKCF0YXJnZXRNYXRyaXgpIHtcbiAgICB0YXJnZXRNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChpc01hdHJpeDNkID8gNCA6IDMpO1xuICB9XG5cbiAgdmFyIHRhcmdldFRyYW5zZm9ybSA9IG1ha2VNYXRyaXhDU1MoaXNTVkdHcmFwaGljRWxlbWVudCAmJiB0YXJnZXRNYXRyaXgubGVuZ3RoID09PSAxNiA/IGNvbnZlcnREaW1lbnNpb24odGFyZ2V0TWF0cml4LCA0LCAzKSA6IHRhcmdldE1hdHJpeCwgaXNNYXRyaXgzZCk7XG4gIHJvb3RNYXRyaXggPSBpZ25vcmVEaW1lbnNpb24ocm9vdE1hdHJpeCwgbiwgbik7XG4gIHJldHVybiB7XG4gICAgcm9vdE1hdHJpeDogcm9vdE1hdHJpeCxcbiAgICBiZWZvcmVNYXRyaXg6IGJlZm9yZU1hdHJpeCxcbiAgICBvZmZzZXRNYXRyaXg6IG9mZnNldE1hdHJpeCxcbiAgICBhbGxNYXRyaXg6IGFsbE1hdHJpeCxcbiAgICB0YXJnZXRNYXRyaXg6IHRhcmdldE1hdHJpeCxcbiAgICB0YXJnZXRUcmFuc2Zvcm06IHRhcmdldFRyYW5zZm9ybSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcbiAgICB0YXJnZXRPcmlnaW46IHRhcmdldE9yaWdpbixcbiAgICBpczNkOiBpc05leHQzZFxuICB9O1xufVxuZnVuY3Rpb24gbWFrZU1hdHJpeENTUyhtYXRyaXgsIGlzM2QpIHtcbiAgaWYgKGlzM2QgPT09IHZvaWQgMCkge1xuICAgIGlzM2QgPSBtYXRyaXgubGVuZ3RoID4gOTtcbiAgfVxuXG4gIHJldHVybiAoaXMzZCA/IFwibWF0cml4M2RcIiA6IFwibWF0cml4XCIpICsgXCIoXCIgKyBjb252ZXJ0TWF0cml4dG9DU1MobWF0cml4LCAhaXMzZCkuam9pbihcIixcIikgKyBcIilcIjtcbn1cbmZ1bmN0aW9uIGdldFNWR1ZpZXdCb3goZWwpIHtcbiAgdmFyIGNsaWVudFdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gIHZhciBjbGllbnRIZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG5cbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgY2xpZW50V2lkdGg6IGNsaWVudFdpZHRoLFxuICAgICAgY2xpZW50SGVpZ2h0OiBjbGllbnRIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgdmFyIHZpZXdCb3ggPSBlbC52aWV3Qm94O1xuICB2YXIgYmFzZVZhbCA9IHZpZXdCb3ggJiYgdmlld0JveC5iYXNlVmFsIHx8IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIHJldHVybiB7XG4gICAgeDogYmFzZVZhbC54LFxuICAgIHk6IGJhc2VWYWwueSxcbiAgICB3aWR0aDogYmFzZVZhbC53aWR0aCB8fCBjbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGJhc2VWYWwuaGVpZ2h0IHx8IGNsaWVudEhlaWdodCxcbiAgICBjbGllbnRXaWR0aDogY2xpZW50V2lkdGgsXG4gICAgY2xpZW50SGVpZ2h0OiBjbGllbnRIZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNWR01hdHJpeChlbCwgbikge1xuICB2YXIgX2EgPSBnZXRTVkdWaWV3Qm94KGVsKSxcbiAgICAgIHZpZXdCb3hXaWR0aCA9IF9hLndpZHRoLFxuICAgICAgdmlld0JveEhlaWdodCA9IF9hLmhlaWdodCxcbiAgICAgIGNsaWVudFdpZHRoID0gX2EuY2xpZW50V2lkdGgsXG4gICAgICBjbGllbnRIZWlnaHQgPSBfYS5jbGllbnRIZWlnaHQ7XG5cbiAgdmFyIHNjYWxlWCA9IGNsaWVudFdpZHRoIC8gdmlld0JveFdpZHRoO1xuICB2YXIgc2NhbGVZID0gY2xpZW50SGVpZ2h0IC8gdmlld0JveEhlaWdodDtcbiAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbC5wcmVzZXJ2ZUFzcGVjdFJhdGlvLmJhc2VWYWw7IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvcHJlc2VydmVBc3BlY3RSYXRpb1xuXG4gIHZhciBhbGlnbiA9IHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ247IC8vIDEgOiBtZWV0IDI6IHNsaWNlXG5cbiAgdmFyIG1lZXRPclNsaWNlID0gcHJlc2VydmVBc3BlY3RSYXRpby5tZWV0T3JTbGljZTtcbiAgdmFyIHN2Z09yaWdpbiA9IFswLCAwXTtcbiAgdmFyIHNjYWxlID0gW3NjYWxlWCwgc2NhbGVZXTtcbiAgdmFyIHRyYW5zbGF0ZSA9IFswLCAwXTtcblxuICBpZiAoYWxpZ24gIT09IDEpIHtcbiAgICB2YXIgeEFsaWduID0gKGFsaWduIC0gMikgJSAzO1xuICAgIHZhciB5QWxpZ24gPSBNYXRoLmZsb29yKChhbGlnbiAtIDIpIC8gMyk7XG4gICAgc3ZnT3JpZ2luWzBdID0gdmlld0JveFdpZHRoICogeEFsaWduIC8gMjtcbiAgICBzdmdPcmlnaW5bMV0gPSB2aWV3Qm94SGVpZ2h0ICogeUFsaWduIC8gMjtcbiAgICB2YXIgc2NhbGVEaW1lbnNpb24gPSBtZWV0T3JTbGljZSA9PT0gMiA/IE1hdGgubWF4KHNjYWxlWSwgc2NhbGVYKSA6IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICBzY2FsZVswXSA9IHNjYWxlRGltZW5zaW9uO1xuICAgIHNjYWxlWzFdID0gc2NhbGVEaW1lbnNpb247XG4gICAgdHJhbnNsYXRlWzBdID0gKGNsaWVudFdpZHRoIC0gdmlld0JveFdpZHRoKSAvIDIgKiB4QWxpZ247XG4gICAgdHJhbnNsYXRlWzFdID0gKGNsaWVudEhlaWdodCAtIHZpZXdCb3hIZWlnaHQpIC8gMiAqIHlBbGlnbjtcbiAgfVxuXG4gIHZhciBzY2FsZU1hdHJpeCA9IGNyZWF0ZVNjYWxlTWF0cml4KHNjYWxlLCBuKTtcbiAgc2NhbGVNYXRyaXhbbiAqIChuIC0gMSldID0gdHJhbnNsYXRlWzBdLCBzY2FsZU1hdHJpeFtuICogKG4gLSAxKSArIDFdID0gdHJhbnNsYXRlWzFdO1xuICByZXR1cm4gZ2V0QWJzb2x1dGVNYXRyaXgoc2NhbGVNYXRyaXgsIG4sIHN2Z09yaWdpbik7XG59XG5mdW5jdGlvbiBnZXRTVkdHcmFwaGljc09mZnNldChlbCwgb3JpZ2luKSB7XG4gIGlmICghZWwuZ2V0QkJveCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cblxuICB2YXIgYmJveCA9IGVsLmdldEJCb3goKTtcbiAgdmFyIHZpZXdCb3ggPSBnZXRTVkdWaWV3Qm94KGVsLm93bmVyU1ZHRWxlbWVudCk7XG4gIHZhciBsZWZ0ID0gYmJveC54IC0gdmlld0JveC54O1xuICB2YXIgdG9wID0gYmJveC55IC0gdmlld0JveC55O1xuICByZXR1cm4gW2xlZnQsIHRvcCwgb3JpZ2luWzBdIC0gbGVmdCwgb3JpZ2luWzFdIC0gdG9wXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgcG9zLCBuKSB7XG4gIHJldHVybiBjYWxjdWxhdGUobWF0cml4LCBjb252ZXJ0UG9zaXRpb25NYXRyaXgocG9zLCBuKSwgbik7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pIHtcbiAgcmV0dXJuIFtbMCwgMF0sIFt3aWR0aCwgMF0sIFswLCBoZWlnaHRdLCBbd2lkdGgsIGhlaWdodF1dLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgcG9zLCBuKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZWN0KHBvc2VzKSB7XG4gIHZhciBwb3Nlc1ggPSBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3NbMF07XG4gIH0pO1xuICB2YXIgcG9zZXNZID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zWzFdO1xuICB9KTtcbiAgdmFyIGxlZnQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBwb3Nlc1gpO1xuICB2YXIgdG9wID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgcG9zZXNZKTtcbiAgdmFyIHJpZ2h0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcG9zZXNYKTtcbiAgdmFyIGJvdHRvbSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHBvc2VzWSk7XG4gIHZhciByZWN0V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIHZhciByZWN0SGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgdG9wOiB0b3AsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIHdpZHRoOiByZWN0V2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0SGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWN0KG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbikge1xuICB2YXIgcG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pO1xuICByZXR1cm4gZ2V0UmVjdChwb3Nlcyk7XG59XG5mdW5jdGlvbiBnZXRTVkdPZmZzZXQob2Zmc2V0SW5mbywgdGFyZ2V0SW5mbywgY29udGFpbmVyLCBuLCBiZWZvcmVNYXRyaXgpIHtcbiAgdmFyIF9hO1xuXG4gIHZhciB0YXJnZXQgPSBvZmZzZXRJbmZvLnRhcmdldDtcbiAgdmFyIG9yaWdpbiA9IG9mZnNldEluZm8ub3JpZ2luO1xuICB2YXIgdGFyZ2V0TWF0cml4ID0gdGFyZ2V0SW5mby5tYXRyaXg7XG5cbiAgdmFyIF9iID0gZ2V0U2l6ZSh0YXJnZXQsIHVuZGVmaW5lZCwgdHJ1ZSksXG4gICAgICB3aWR0aCA9IF9iWzBdLFxuICAgICAgaGVpZ2h0ID0gX2JbMV07XG5cbiAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBtYXJnaW4gPSBbMCwgMF07XG5cbiAgaWYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIG1hcmdpbiA9IGdldEJvZHlPZmZzZXQodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgcmVjdExlZnQgPSByZWN0LmxlZnQgLSBjb250YWluZXJDbGllbnRSZWN0LmxlZnQgKyBjb250YWluZXIuc2Nyb2xsTGVmdCAtIChjb250YWluZXIuY2xpZW50TGVmdCB8fCAwKSArIG1hcmdpblswXTtcbiAgdmFyIHJlY3RUb3AgPSByZWN0LnRvcCAtIGNvbnRhaW5lckNsaWVudFJlY3QudG9wICsgY29udGFpbmVyLnNjcm9sbFRvcCAtIChjb250YWluZXIuY2xpZW50VG9wIHx8IDApICsgbWFyZ2luWzFdO1xuICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIG1hdCA9IG11bHRpcGxpZXMobiwgYmVmb3JlTWF0cml4LCB0YXJnZXRNYXRyaXgpO1xuXG4gIHZhciBfYyA9IGNhbGN1bGF0ZVJlY3QobWF0LCB3aWR0aCwgaGVpZ2h0LCBuKSxcbiAgICAgIHByZXZMZWZ0ID0gX2MubGVmdCxcbiAgICAgIHByZXZUb3AgPSBfYy50b3AsXG4gICAgICBwcmV2V2lkdGggPSBfYy53aWR0aCxcbiAgICAgIHByZXZIZWlnaHQgPSBfYy5oZWlnaHQ7XG5cbiAgdmFyIHBvc09yaWdpbiA9IGNhbGN1bGF0ZVBvc2l0aW9uKG1hdCwgb3JpZ2luLCBuKTtcbiAgdmFyIHByZXZPcmlnaW4gPSBtaW51cyhwb3NPcmlnaW4sIFtwcmV2TGVmdCwgcHJldlRvcF0pO1xuICB2YXIgcmVjdE9yaWdpbiA9IFtyZWN0TGVmdCArIHByZXZPcmlnaW5bMF0gKiByZWN0V2lkdGggLyBwcmV2V2lkdGgsIHJlY3RUb3AgKyBwcmV2T3JpZ2luWzFdICogcmVjdEhlaWdodCAvIHByZXZIZWlnaHRdO1xuICB2YXIgb2Zmc2V0ID0gWzAsIDBdO1xuICB2YXIgY291bnQgPSAwO1xuXG4gIHdoaWxlICgrK2NvdW50IDwgMTApIHtcbiAgICB2YXIgaW52ZXJzZUJlZm9yZU1hdHJpeCA9IGludmVydChiZWZvcmVNYXRyaXgsIG4pO1xuICAgIF9hID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oaW52ZXJzZUJlZm9yZU1hdHJpeCwgcmVjdE9yaWdpbiwgbiksIGNhbGN1bGF0ZVBvc2l0aW9uKGludmVyc2VCZWZvcmVNYXRyaXgsIHBvc09yaWdpbiwgbikpLCBvZmZzZXRbMF0gPSBfYVswXSwgb2Zmc2V0WzFdID0gX2FbMV07XG4gICAgdmFyIG1hdDIgPSBtdWx0aXBsaWVzKG4sIGJlZm9yZU1hdHJpeCwgY3JlYXRlT3JpZ2luTWF0cml4KG9mZnNldCwgbiksIHRhcmdldE1hdHJpeCk7XG5cbiAgICB2YXIgX2QgPSBjYWxjdWxhdGVSZWN0KG1hdDIsIHdpZHRoLCBoZWlnaHQsIG4pLFxuICAgICAgICBuZXh0TGVmdCA9IF9kLmxlZnQsXG4gICAgICAgIG5leHRUb3AgPSBfZC50b3A7XG5cbiAgICB2YXIgZGlzdExlZnQgPSBuZXh0TGVmdCAtIHJlY3RMZWZ0O1xuICAgIHZhciBkaXN0VG9wID0gbmV4dFRvcCAtIHJlY3RUb3A7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGlzdExlZnQpIDwgMiAmJiBNYXRoLmFicyhkaXN0VG9wKSA8IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJlY3RPcmlnaW5bMF0gLT0gZGlzdExlZnQ7XG4gICAgcmVjdE9yaWdpblsxXSAtPSBkaXN0VG9wO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldC5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVNb3ZlYWJsZVBvc2l0aW9uKG1hdHJpeCwgb3JpZ2luLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBpczNkID0gbWF0cml4Lmxlbmd0aCA9PT0gMTY7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICB2YXIgcG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pO1xuICB2YXIgX2EgPSBwb3Nlc1swXSxcbiAgICAgIHgxID0gX2FbMF0sXG4gICAgICB5MSA9IF9hWzFdLFxuICAgICAgX2IgPSBwb3Nlc1sxXSxcbiAgICAgIHgyID0gX2JbMF0sXG4gICAgICB5MiA9IF9iWzFdLFxuICAgICAgX2MgPSBwb3Nlc1syXSxcbiAgICAgIHgzID0gX2NbMF0sXG4gICAgICB5MyA9IF9jWzFdLFxuICAgICAgX2QgPSBwb3Nlc1szXSxcbiAgICAgIHg0ID0gX2RbMF0sXG4gICAgICB5NCA9IF9kWzFdO1xuXG4gIHZhciBfZSA9IGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgb3JpZ2luLCBuKSxcbiAgICAgIG9yaWdpblggPSBfZVswXSxcbiAgICAgIG9yaWdpblkgPSBfZVsxXTtcblxuICB2YXIgbGVmdCA9IE1hdGgubWluKHgxLCB4MiwgeDMsIHg0KTtcbiAgdmFyIHRvcCA9IE1hdGgubWluKHkxLCB5MiwgeTMsIHk0KTtcbiAgdmFyIHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyLCB4MywgeDQpO1xuICB2YXIgYm90dG9tID0gTWF0aC5tYXgoeTEsIHkyLCB5MywgeTQpO1xuICB4MSA9IHgxIC0gbGVmdCB8fCAwO1xuICB4MiA9IHgyIC0gbGVmdCB8fCAwO1xuICB4MyA9IHgzIC0gbGVmdCB8fCAwO1xuICB4NCA9IHg0IC0gbGVmdCB8fCAwO1xuICB5MSA9IHkxIC0gdG9wIHx8IDA7XG4gIHkyID0geTIgLSB0b3AgfHwgMDtcbiAgeTMgPSB5MyAtIHRvcCB8fCAwO1xuICB5NCA9IHk0IC0gdG9wIHx8IDA7XG4gIG9yaWdpblggPSBvcmlnaW5YIC0gbGVmdCB8fCAwO1xuICBvcmlnaW5ZID0gb3JpZ2luWSAtIHRvcCB8fCAwO1xuICB2YXIgZGlyZWN0aW9uID0gZ2V0U2hhcGVEaXJlY3Rpb24ocG9zZXMpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgdG9wOiB0b3AsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIG9yaWdpbjogW29yaWdpblgsIG9yaWdpblldLFxuICAgIHBvczE6IFt4MSwgeTFdLFxuICAgIHBvczI6IFt4MiwgeTJdLFxuICAgIHBvczM6IFt4MywgeTNdLFxuICAgIHBvczQ6IFt4NCwgeTRdLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBnZXREaXN0U2l6ZSh2ZWMpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh2ZWNbMF0gKiB2ZWNbMF0gKyB2ZWNbMV0gKiB2ZWNbMV0pO1xufVxuZnVuY3Rpb24gZ2V0RGlhZ29uYWxTaXplKHBvczEsIHBvczIpIHtcbiAgcmV0dXJuIGdldERpc3RTaXplKFtwb3MyWzBdIC0gcG9zMVswXSwgcG9zMlsxXSAtIHBvczFbMV1dKTtcbn1cbmZ1bmN0aW9uIGdldExpbmVTdHlsZShwb3MxLCBwb3MyLCB6b29tLCByYWQpIHtcbiAgaWYgKHpvb20gPT09IHZvaWQgMCkge1xuICAgIHpvb20gPSAxO1xuICB9XG5cbiAgaWYgKHJhZCA9PT0gdm9pZCAwKSB7XG4gICAgcmFkID0gZ2V0UmFkKHBvczEsIHBvczIpO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gZ2V0RGlhZ29uYWxTaXplKHBvczEsIHBvczIpO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZShcIiArIHBvczFbMF0gKyBcInB4LCBcIiArIHBvczFbMV0gKyBcInB4KSByb3RhdGUoXCIgKyByYWQgKyBcInJhZCkgc2NhbGVZKFwiICsgem9vbSArIFwiKVwiLFxuICAgIHdpZHRoOiB3aWR0aCArIFwicHhcIlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29udHJvbFRyYW5zZm9ybShyb3RhdGlvbiwgem9vbSkge1xuICB2YXIgcG9zZXMgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIHBvc2VzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHBvc2VzLmxlbmd0aDtcbiAgdmFyIHggPSBwb3Nlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHBvcykge1xuICAgIHJldHVybiBwcmV2ICsgcG9zWzBdO1xuICB9LCAwKSAvIGxlbmd0aDtcbiAgdmFyIHkgPSBwb3Nlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHBvcykge1xuICAgIHJldHVybiBwcmV2ICsgcG9zWzFdO1xuICB9LCAwKSAvIGxlbmd0aDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWigwcHgpIHRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KSByb3RhdGUoXCIgKyByb3RhdGlvbiArIFwicmFkKSBzY2FsZShcIiArIHpvb20gKyBcIilcIlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q1NTU2l6ZSh0YXJnZXQpIHtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICByZXR1cm4gW3BhcnNlRmxvYXQoc3R5bGUud2lkdGgpLCBwYXJzZUZsb2F0KHN0eWxlLmhlaWdodCldO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZSh0YXJnZXQsIHN0eWxlLCBpc09mZnNldCwgaXNCb3hTaXppbmcpIHtcbiAgaWYgKHN0eWxlID09PSB2b2lkIDApIHtcbiAgICBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgfVxuXG4gIGlmIChpc0JveFNpemluZyA9PT0gdm9pZCAwKSB7XG4gICAgaXNCb3hTaXppbmcgPSBpc09mZnNldCB8fCBzdHlsZS5ib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gdGFyZ2V0Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgdmFyIGhhc09mZnNldCA9ICFpc1VuZGVmaW5lZCh3aWR0aCk7XG5cbiAgaWYgKChpc09mZnNldCB8fCBpc0JveFNpemluZykgJiYgaGFzT2Zmc2V0KSB7XG4gICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgfVxuXG4gIGlmICghaGFzT2Zmc2V0ICYmIHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwic3ZnXCIpIHtcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XG4gICAgcmV0dXJuIFtiYm94LndpZHRoLCBiYm94LmhlaWdodF07XG4gIH1cblxuICB3aWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgaGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcblxuICBpZiAoaXNPZmZzZXQgfHwgaXNCb3hTaXppbmcpIHtcbiAgICB2YXIgYm9yZGVyTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO1xuICAgIHZhciBib3JkZXJSaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCkgfHwgMDtcbiAgICB2YXIgYm9yZGVyVG9wID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMDtcbiAgICB2YXIgYm9yZGVyQm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCkgfHwgMDtcbiAgICByZXR1cm4gW3dpZHRoICsgYm9yZGVyTGVmdCArIGJvcmRlclJpZ2h0LCBoZWlnaHQgKyBib3JkZXJUb3AgKyBib3JkZXJCb3R0b21dO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0xlZnQpIHx8IDA7XG4gICAgdmFyIHBhZGRpbmdSaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1JpZ2h0KSB8fCAwO1xuICAgIHZhciBwYWRkaW5nVG9wID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwO1xuICAgIHZhciBwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwO1xuICAgIHJldHVybiBbd2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodCwgaGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b21dO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSb3RhdGlvblJhZChwb3NlcywgZGlyZWN0aW9uKSB7XG4gIHJldHVybiBnZXRSYWQoZGlyZWN0aW9uID4gMCA/IHBvc2VzWzBdIDogcG9zZXNbMV0sIGRpcmVjdGlvbiA+IDAgPyBwb3Nlc1sxXSA6IHBvc2VzWzBdKTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldEluZm8obW92ZWFibGVFbGVtZW50LCB0YXJnZXQsIGNvbnRhaW5lciwgcGFyZW50Q29udGFpbmVyLCByb290Q29udGFpbmVyKSB7XG4gIHZhciBiZWZvcmVEaXJlY3Rpb24gPSAxO1xuICB2YXIgYmVmb3JlT3JpZ2luID0gWzAsIDBdO1xuICB2YXIgdGFyZ2V0Q2xpZW50UmVjdCA9IHJlc2V0Q2xpZW50UmVjdCgpO1xuICB2YXIgY29udGFpbmVyQ2xpZW50UmVjdCA9IHJlc2V0Q2xpZW50UmVjdCgpO1xuICB2YXIgbW92ZWFibGVDbGllbnRSZWN0ID0gcmVzZXRDbGllbnRSZWN0KCk7XG4gIHZhciByZXN1bHQgPSBjYWxjdWxhdGVFbGVtZW50SW5mbyh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgZmFsc2UpO1xuXG4gIGlmICh0YXJnZXQpIHtcbiAgICB2YXIgbiA9IHJlc3VsdC5pczNkID8gNCA6IDM7XG4gICAgdmFyIGJlZm9yZVBvc2l0aW9uID0gY2FsY3VsYXRlTW92ZWFibGVQb3NpdGlvbihyZXN1bHQub2Zmc2V0TWF0cml4LCBwbHVzKHJlc3VsdC50cmFuc2Zvcm1PcmlnaW4sIGdldE9yaWdpbihyZXN1bHQudGFyZ2V0TWF0cml4LCBuKSksIHJlc3VsdC53aWR0aCwgcmVzdWx0LmhlaWdodCk7XG4gICAgYmVmb3JlRGlyZWN0aW9uID0gYmVmb3JlUG9zaXRpb24uZGlyZWN0aW9uO1xuICAgIGJlZm9yZU9yaWdpbiA9IHBsdXMoYmVmb3JlUG9zaXRpb24ub3JpZ2luLCBbYmVmb3JlUG9zaXRpb24ubGVmdCAtIHJlc3VsdC5sZWZ0LCBiZWZvcmVQb3NpdGlvbi50b3AgLSByZXN1bHQudG9wXSk7XG4gICAgdGFyZ2V0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3QodGFyZ2V0KTtcbiAgICBjb250YWluZXJDbGllbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdChnZXRPZmZzZXRJbmZvKHBhcmVudENvbnRhaW5lciwgcGFyZW50Q29udGFpbmVyLCB0cnVlKS5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuYm9keSwgdHJ1ZSk7XG5cbiAgICBpZiAobW92ZWFibGVFbGVtZW50KSB7XG4gICAgICBtb3ZlYWJsZUNsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0KG1vdmVhYmxlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9fYXNzaWduKHtcbiAgICB0YXJnZXRDbGllbnRSZWN0OiB0YXJnZXRDbGllbnRSZWN0LFxuICAgIGNvbnRhaW5lckNsaWVudFJlY3Q6IGNvbnRhaW5lckNsaWVudFJlY3QsXG4gICAgbW92ZWFibGVDbGllbnRSZWN0OiBtb3ZlYWJsZUNsaWVudFJlY3QsXG4gICAgYmVmb3JlRGlyZWN0aW9uOiBiZWZvcmVEaXJlY3Rpb24sXG4gICAgYmVmb3JlT3JpZ2luOiBiZWZvcmVPcmlnaW4sXG4gICAgb3JpZ2luYWxCZWZvcmVPcmlnaW46IGJlZm9yZU9yaWdpbixcbiAgICB0YXJnZXQ6IHRhcmdldFxuICB9LCByZXN1bHQpO1xufVxuZnVuY3Rpb24gcmVzZXRDbGllbnRSZWN0KCkge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgY2xpZW50TGVmdDogMCxcbiAgICBjbGllbnRUb3A6IDAsXG4gICAgY2xpZW50V2lkdGg6IDAsXG4gICAgY2xpZW50SGVpZ2h0OiAwLFxuICAgIHNjcm9sbFdpZHRoOiAwLFxuICAgIHNjcm9sbEhlaWdodDogMFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChlbCwgaXNFeHRlbmRzKSB7XG4gIHZhciBsZWZ0ID0gMDtcbiAgdmFyIHRvcCA9IDA7XG4gIHZhciB3aWR0aCA9IDA7XG4gIHZhciBoZWlnaHQgPSAwO1xuXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGVmdCA9IC0oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KTtcbiAgICB0b3AgPSAtKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApO1xuICB9IGVsc2Uge1xuICAgIHZhciBjbGllbnRSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGVmdCA9IGNsaWVudFJlY3QubGVmdDtcbiAgICB0b3AgPSBjbGllbnRSZWN0LnRvcDtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICB2YXIgcmVjdCA9IHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiBsZWZ0ICsgd2lkdGgsXG4gICAgdG9wOiB0b3AsXG4gICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgaWYgKGlzRXh0ZW5kcykge1xuICAgIHJlY3QuY2xpZW50TGVmdCA9IGVsLmNsaWVudExlZnQ7XG4gICAgcmVjdC5jbGllbnRUb3AgPSBlbC5jbGllbnRUb3A7XG4gICAgcmVjdC5jbGllbnRXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgIHJlY3QuY2xpZW50SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgIHJlY3Quc2Nyb2xsV2lkdGggPSBlbC5zY3JvbGxXaWR0aDtcbiAgICByZWN0LnNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodDtcbiAgICByZWN0Lm92ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkub3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiO1xuICB9XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5mdW5jdGlvbiBnZXREaXJlY3Rpb24odGFyZ2V0KSB7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRpcmVjaXRvbiA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRpcmVjdGlvblwiKTtcblxuICBpZiAoIWRpcmVjaXRvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkaXIgPSBbMCwgMF07XG4gIGRpcmVjaXRvbi5pbmRleE9mKFwid1wiKSA+IC0xICYmIChkaXJbMF0gPSAtMSk7XG4gIGRpcmVjaXRvbi5pbmRleE9mKFwiZVwiKSA+IC0xICYmIChkaXJbMF0gPSAxKTtcbiAgZGlyZWNpdG9uLmluZGV4T2YoXCJuXCIpID4gLTEgJiYgKGRpclsxXSA9IC0xKTtcbiAgZGlyZWNpdG9uLmluZGV4T2YoXCJzXCIpID4gLTEgJiYgKGRpclsxXSA9IDEpO1xuICByZXR1cm4gZGlyO1xufVxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVQb3Nlcyhwb3NlcywgZGlzdCkge1xuICByZXR1cm4gW3BsdXMoZGlzdCwgcG9zZXNbMF0pLCBwbHVzKGRpc3QsIHBvc2VzWzFdKSwgcGx1cyhkaXN0LCBwb3Nlc1syXSksIHBsdXMoZGlzdCwgcG9zZXNbM10pXTtcbn1cbmZ1bmN0aW9uIGdldEFic29sdXRlUG9zZXNCeVN0YXRlKF9hKSB7XG4gIHZhciBsZWZ0ID0gX2EubGVmdCxcbiAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgIHBvczEgPSBfYS5wb3MxLFxuICAgICAgcG9zMiA9IF9hLnBvczIsXG4gICAgICBwb3MzID0gX2EucG9zMyxcbiAgICAgIHBvczQgPSBfYS5wb3M0O1xuICByZXR1cm4gZ2V0QWJzb2x1dGVQb3NlcyhbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0sIFtsZWZ0LCB0b3BdKTtcbn1cbmZ1bmN0aW9uIHJvdW5kU2lnbihudW0pIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICUgMSA9PT0gLTAuNSA/IG51bSAtIDEgOiBudW0pO1xufVxuZnVuY3Rpb24gdW5zZXQoc2VsZiwgbmFtZSkge1xuICB2YXIgX2E7XG5cbiAgKF9hID0gc2VsZltuYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVuc2V0KCk7XG4gIHNlbGZbbmFtZV0gPSBudWxsO1xufVxuZnVuY3Rpb24gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgcGFyYW1zKSB7XG4gIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgaWYgKCFkYXRhcy5kYXRhcykge1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gIH1cblxuICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7XG4gICAgdGFyZ2V0OiBtb3ZlYWJsZS5zdGF0ZS50YXJnZXQsXG4gICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICBpbnB1dEV2ZW50OiBlLmlucHV0RXZlbnQsXG4gICAgY3VycmVudFRhcmdldDogbW92ZWFibGUsXG4gICAgbW92ZWFibGU6IG1vdmVhYmxlLFxuICAgIGRhdGFzOiBkYXRhcy5kYXRhc1xuICB9KTtcblxuICBpZiAoZGF0YXMuaXNTdGFydEV2ZW50KSB7XG4gICAgZGF0YXMubGFzdEV2ZW50ID0gbmV4dFBhcmFtcztcbiAgfSBlbHNlIHtcbiAgICBkYXRhcy5pc1N0YXJ0RXZlbnQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG5leHRQYXJhbXM7XG59XG5mdW5jdGlvbiBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCBwYXJhbXMpIHtcbiAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgdmFyIGlzRHJhZyA9IFwiaXNEcmFnXCIgaW4gcGFyYW1zID8gcGFyYW1zLmlzRHJhZyA6IGUuaXNEcmFnO1xuXG4gIGlmICghZGF0YXMuZGF0YXMpIHtcbiAgICBkYXRhcy5kYXRhcyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICBpc0RyYWc6IGlzRHJhZ1xuICB9LCBwYXJhbXMpLCB7XG4gICAgbW92ZWFibGU6IG1vdmVhYmxlLFxuICAgIHRhcmdldDogbW92ZWFibGUuc3RhdGUudGFyZ2V0LFxuICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgaW5wdXRFdmVudDogZS5pbnB1dEV2ZW50LFxuICAgIGN1cnJlbnRUYXJnZXQ6IG1vdmVhYmxlLFxuICAgIGxhc3RFdmVudDogZGF0YXMubGFzdEV2ZW50LFxuICAgIGlzRG91YmxlOiBlLmlzRG91YmxlLFxuICAgIGRhdGFzOiBkYXRhcy5kYXRhc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgbmFtZSwgcGFyYW1zLCBpc01hbmFnZXIpIHtcbiAgcmV0dXJuIG1vdmVhYmxlLnRyaWdnZXJFdmVudChuYW1lLCBwYXJhbXMsIGlzTWFuYWdlcik7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsLCBwc2V1ZG9FbHQpIHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBwc2V1ZG9FbHQpO1xufVxuZnVuY3Rpb24gZmlsdGVyQWJsZXMoYWJsZXMsIG1ldGhvZHMsIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5KSB7XG4gIHZhciBlbmFibGVkQWJsZXMgPSB7fTtcbiAgdmFyIGFibGVHcm91cHMgPSB7fTtcbiAgcmV0dXJuIGFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgIHZhciBuYW1lID0gYWJsZS5uYW1lO1xuXG4gICAgaWYgKGVuYWJsZWRBYmxlc1tuYW1lXSB8fCAhbWV0aG9kcy5zb21lKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHJldHVybiBhYmxlW21ldGhvZF07XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5ICYmIGFibGUuYWJsZUdyb3VwKSB7XG4gICAgICBpZiAoYWJsZUdyb3Vwc1thYmxlLmFibGVHcm91cF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBhYmxlR3JvdXBzW2FibGUuYWJsZUdyb3VwXSA9IHRydWU7XG4gICAgfVxuXG4gICAgZW5hYmxlZEFibGVzW25hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlcXVhbHMoYTEsIGEyKSB7XG4gIHJldHVybiBhMSA9PT0gYTIgfHwgYTEgPT0gbnVsbCAmJiBhMiA9PSBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0VmFsdWUoKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIHZhbHVlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGggLSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXNbbGVuZ3RoXTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnkoYXJyLCBmdW5jKSB7XG4gIHZhciBncm91cHMgPSBbXTtcbiAgdmFyIGdyb3VwS2V5cyA9IFtdO1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgdmFyIGdyb3VwS2V5ID0gZnVuYyhlbCwgaW5kZXgsIGFycik7XG4gICAgdmFyIGtleUluZGV4ID0gZ3JvdXBLZXlzLmluZGV4T2YoZ3JvdXBLZXkpO1xuICAgIHZhciBncm91cCA9IGdyb3Vwc1trZXlJbmRleF0gfHwgW107XG5cbiAgICBpZiAoa2V5SW5kZXggPT09IC0xKSB7XG4gICAgICBncm91cEtleXMucHVzaChncm91cEtleSk7XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgfVxuXG4gICAgZ3JvdXAucHVzaChlbCk7XG4gIH0pO1xuICByZXR1cm4gZ3JvdXBzO1xufVxuZnVuY3Rpb24gZ3JvdXBCeU1hcChhcnIsIGZ1bmMpIHtcbiAgdmFyIGdyb3VwcyA9IFtdO1xuICB2YXIgZ3JvdXBLZXlzID0ge307XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICB2YXIgZ3JvdXBLZXkgPSBmdW5jKGVsLCBpbmRleCwgYXJyKTtcbiAgICB2YXIgZ3JvdXAgPSBncm91cEtleXNbZ3JvdXBLZXldO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgZ3JvdXAgPSBbXTtcbiAgICAgIGdyb3VwS2V5c1tncm91cEtleV0gPSBncm91cDtcbiAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICB9XG5cbiAgICBncm91cC5wdXNoKGVsKTtcbiAgfSk7XG4gIHJldHVybiBncm91cHM7XG59XG5mdW5jdGlvbiBmbGF0KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYuY29uY2F0KGN1cik7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIG1heE9mZnNldCgpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIGFyZ3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhiKSAtIE1hdGguYWJzKGEpO1xuICB9KTtcbiAgcmV0dXJuIGFyZ3NbMF07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24obWF0cml4LCBwb3MsIG4pIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZShpbnZlcnQobWF0cml4LCBuKSwgY29udmVydFBvc2l0aW9uTWF0cml4KHBvcywgbiksIG4pO1xufVxuZnVuY3Rpb24gY29udmVydERyYWdEaXN0KHN0YXRlLCBlKSB7XG4gIHZhciBfYTtcblxuICB2YXIgaXMzZCA9IHN0YXRlLmlzM2QsXG4gICAgICByb290TWF0cml4ID0gc3RhdGUucm9vdE1hdHJpeDtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gIF9hID0gY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtlLmRpc3RYLCBlLmRpc3RZXSwgbiksIGUuZGlzdFggPSBfYVswXSwgZS5kaXN0WSA9IF9hWzFdO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBhZGRpbmcobWF0cml4LCBwb3MsIHRyYW5zZm9ybU9yaWdpbiwgb3JpZ2luLCBuKSB7XG4gIHJldHVybiBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihtYXRyaXgsIHBsdXModHJhbnNmb3JtT3JpZ2luLCBwb3MpLCBuKSwgb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDU1NTaXplKHZhbHVlLCBzaXplLCBpc1JlbGF0aXZlKSB7XG4gIHJldHVybiBpc1JlbGF0aXZlID8gdmFsdWUgLyBzaXplICogMTAwICsgXCIlXCIgOiB2YWx1ZSArIFwicHhcIjtcbn1cbmZ1bmN0aW9uIG1vdmVDb250cm9sUG9zKGNvbnRyb2xQb3NlcywgaW5kZXgsIGRpc3QsIGlzUmVjdCkge1xuICB2YXIgX2EgPSBjb250cm9sUG9zZXNbaW5kZXhdLFxuICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uLFxuICAgICAgc3ViID0gX2Euc3ViO1xuICB2YXIgZGlzdHMgPSBjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9KTtcbiAgdmFyIGRpcmVjdGlvbnMgPSBkaXJlY3Rpb24gPyBkaXJlY3Rpb24uc3BsaXQoXCJcIikgOiBbXTtcblxuICBpZiAoaXNSZWN0ICYmIGluZGV4IDwgOCkge1xuICAgIHZhciB2ZXJ0aWNhbERpcmVjdGlvbl8xID0gZGlyZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRpcikge1xuICAgICAgcmV0dXJuIGRpciA9PT0gXCJ3XCIgfHwgZGlyID09PSBcImVcIjtcbiAgICB9KVswXTtcbiAgICB2YXIgaG9yaXpvbnRhbERpcmVjdGlvbl8xID0gZGlyZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRpcikge1xuICAgICAgcmV0dXJuIGRpciA9PT0gXCJuXCIgfHwgZGlyID09PSBcInNcIjtcbiAgICB9KVswXTtcbiAgICBkaXN0c1tpbmRleF0gPSBkaXN0O1xuICAgIGNvbnRyb2xQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sUG9zZSwgaSkge1xuICAgICAgdmFyIGNvbnRyb2xEaXIgPSBjb250cm9sUG9zZS5kaXJlY3Rpb247XG5cbiAgICAgIGlmICghY29udHJvbERpcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250cm9sRGlyLmluZGV4T2YodmVydGljYWxEaXJlY3Rpb25fMSkgPiAtMSkge1xuICAgICAgICBkaXN0c1tpXVswXSA9IGRpc3RbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250cm9sRGlyLmluZGV4T2YoaG9yaXpvbnRhbERpcmVjdGlvbl8xKSA+IC0xKSB7XG4gICAgICAgIGRpc3RzW2ldWzFdID0gZGlzdFsxXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh2ZXJ0aWNhbERpcmVjdGlvbl8xKSB7XG4gICAgICBkaXN0c1sxXVswXSA9IGRpc3RbMF0gLyAyO1xuICAgICAgZGlzdHNbNV1bMF0gPSBkaXN0WzBdIC8gMjtcbiAgICB9XG5cbiAgICBpZiAoaG9yaXpvbnRhbERpcmVjdGlvbl8xKSB7XG4gICAgICBkaXN0c1szXVsxXSA9IGRpc3RbMV0gLyAyO1xuICAgICAgZGlzdHNbN11bMV0gPSBkaXN0WzFdIC8gMjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYmICFzdWIpIHtcbiAgICBkaXJlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgICAgdmFyIGlzVmVydGljYWwgPSBkaXIgPT09IFwiblwiIHx8IGRpciA9PT0gXCJzXCI7XG4gICAgICBjb250cm9sUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbFBvc2UsIGkpIHtcbiAgICAgICAgdmFyIGRpckRpciA9IGNvbnRyb2xQb3NlLmRpcmVjdGlvbixcbiAgICAgICAgICAgIGRpckhvcml6b250YWwgPSBjb250cm9sUG9zZS5ob3Jpem9udGFsLFxuICAgICAgICAgICAgZGlyVmVydGljYWwgPSBjb250cm9sUG9zZS52ZXJ0aWNhbDtcblxuICAgICAgICBpZiAoIWRpckRpciB8fCBkaXJEaXIuaW5kZXhPZihkaXIpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RzW2ldID0gW2lzVmVydGljYWwgfHwgIWRpckhvcml6b250YWwgPyAwIDogZGlzdFswXSwgIWlzVmVydGljYWwgfHwgIWRpclZlcnRpY2FsID8gMCA6IGRpc3RbMV1dO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGlzdHNbaW5kZXhdID0gZGlzdDtcbiAgfVxuXG4gIHJldHVybiBkaXN0cztcbn1cbmZ1bmN0aW9uIGdldFRpbnlEaXN0KHYpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHYpIDw9IFRJTllfTlVNID8gMCA6IHY7XG59XG5mdW5jdGlvbiBkaXJlY3Rpb25Db25kaXRpb24obW92ZWFibGUsIGUpIHtcbiAgaWYgKGUuaXNSZXF1ZXN0KSB7XG4gICAgaWYgKGUucmVxdWVzdEFibGUgPT09IFwicmVzaXphYmxlXCIgfHwgZS5yZXF1ZXN0QWJsZSA9PT0gXCJzY2FsYWJsZVwiKSB7XG4gICAgICByZXR1cm4gZS5wYXJlbnREaXJlY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGFzQ2xhc3MoZS5pbnB1dEV2ZW50LnRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKTtcbn1cbmZ1bmN0aW9uIGludmVydE9iamVjdChvYmopIHtcbiAgdmFyIG5leHRPYmogPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIG9iaikge1xuICAgIG5leHRPYmpbb2JqW25hbWVdXSA9IG5hbWU7XG4gIH1cblxuICByZXR1cm4gbmV4dE9iajtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybSh0cmFuc2Zvcm1zLCBpbmRleCkge1xuICB2YXIgYmVmb3JlRnVuY3Rpb25UZXh0cyA9IHRyYW5zZm9ybXMuc2xpY2UoMCwgaW5kZXggPCAwID8gdW5kZWZpbmVkIDogaW5kZXgpO1xuICB2YXIgYmVmb3JlRnVuY3Rpb25UZXh0czIgPSB0cmFuc2Zvcm1zLnNsaWNlKDAsIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4ICsgMSk7XG4gIHZhciB0YXJnZXRGdW5jdGlvblRleHQgPSB0cmFuc2Zvcm1zW2luZGV4XSB8fCBcIlwiO1xuICB2YXIgYWZ0ZXJGdW5jdGlvblRleHRzID0gaW5kZXggPCAwID8gW10gOiB0cmFuc2Zvcm1zLnNsaWNlKGluZGV4KTtcbiAgdmFyIGFmdGVyRnVuY3Rpb25UZXh0czIgPSBpbmRleCA8IDAgPyBbXSA6IHRyYW5zZm9ybXMuc2xpY2UoaW5kZXggKyAxKTtcbiAgdmFyIGJlZm9yZUZ1bmN0aW9ucyA9IHBhcnNlKGJlZm9yZUZ1bmN0aW9uVGV4dHMpO1xuICB2YXIgYmVmb3JlRnVuY3Rpb25zMiA9IHBhcnNlKGJlZm9yZUZ1bmN0aW9uVGV4dHMyKTtcbiAgdmFyIHRhcmdldEZ1bmN0aW9ucyA9IHBhcnNlKFt0YXJnZXRGdW5jdGlvblRleHRdKTtcbiAgdmFyIGFmdGVyRnVuY3Rpb25zID0gcGFyc2UoYWZ0ZXJGdW5jdGlvblRleHRzKTtcbiAgdmFyIGFmdGVyRnVuY3Rpb25zMiA9IHBhcnNlKGFmdGVyRnVuY3Rpb25UZXh0czIpO1xuICB2YXIgYmVmb3JlRnVuY3Rpb25NYXRyaXggPSB0b01hdChiZWZvcmVGdW5jdGlvbnMpO1xuICB2YXIgYmVmb3JlRnVuY3Rpb25NYXRyaXgyID0gdG9NYXQoYmVmb3JlRnVuY3Rpb25zMik7XG4gIHZhciBhZnRlckZ1bmN0aW9uTWF0cml4ID0gdG9NYXQoYWZ0ZXJGdW5jdGlvbnMpO1xuICB2YXIgYWZ0ZXJGdW5jdGlvbk1hdHJpeDIgPSB0b01hdChhZnRlckZ1bmN0aW9uczIpO1xuICB2YXIgYWxsRnVuY3Rpb25NYXRyaXggPSBtdWx0aXBseShiZWZvcmVGdW5jdGlvbk1hdHJpeCwgYWZ0ZXJGdW5jdGlvbk1hdHJpeCwgNCk7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtczogdHJhbnNmb3JtcyxcbiAgICBiZWZvcmVGdW5jdGlvbk1hdHJpeDogYmVmb3JlRnVuY3Rpb25NYXRyaXgsXG4gICAgYmVmb3JlRnVuY3Rpb25NYXRyaXgyOiBiZWZvcmVGdW5jdGlvbk1hdHJpeDIsXG4gICAgdGFyZ2V0RnVuY3Rpb25NYXRyaXg6IHRvTWF0KHRhcmdldEZ1bmN0aW9ucyksXG4gICAgYWZ0ZXJGdW5jdGlvbk1hdHJpeDogYWZ0ZXJGdW5jdGlvbk1hdHJpeCxcbiAgICBhZnRlckZ1bmN0aW9uTWF0cml4MjogYWZ0ZXJGdW5jdGlvbk1hdHJpeDIsXG4gICAgYWxsRnVuY3Rpb25NYXRyaXg6IGFsbEZ1bmN0aW9uTWF0cml4LFxuICAgIGJlZm9yZUZ1bmN0aW9uczogYmVmb3JlRnVuY3Rpb25zLFxuICAgIGJlZm9yZUZ1bmN0aW9uczI6IGJlZm9yZUZ1bmN0aW9uczIsXG4gICAgdGFyZ2V0RnVuY3Rpb246IHRhcmdldEZ1bmN0aW9uc1swXSxcbiAgICBhZnRlckZ1bmN0aW9uczogYWZ0ZXJGdW5jdGlvbnMsXG4gICAgYWZ0ZXJGdW5jdGlvbnMyOiBhZnRlckZ1bmN0aW9uczIsXG4gICAgYmVmb3JlRnVuY3Rpb25UZXh0czogYmVmb3JlRnVuY3Rpb25UZXh0cyxcbiAgICBiZWZvcmVGdW5jdGlvblRleHRzMjogYmVmb3JlRnVuY3Rpb25UZXh0czIsXG4gICAgdGFyZ2V0RnVuY3Rpb25UZXh0OiB0YXJnZXRGdW5jdGlvblRleHQsXG4gICAgYWZ0ZXJGdW5jdGlvblRleHRzOiBhZnRlckZ1bmN0aW9uVGV4dHMsXG4gICAgYWZ0ZXJGdW5jdGlvblRleHRzMjogYWZ0ZXJGdW5jdGlvblRleHRzMlxuICB9O1xufVxuZnVuY3Rpb24gaXNBcnJheUZvcm1hdChhcnIpIHtcbiAgaWYgKCFhcnIgfHwgIWlzT2JqZWN0KGFycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheShhcnIpIHx8IFwibGVuZ3RoXCIgaW4gYXJyO1xufVxuZnVuY3Rpb24gZ2V0UmVmVGFyZ2V0KHRhcmdldCwgaXNTZWxlY3Rvcikge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcbiAgICBpZiAoaXNTZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQoKTtcbiAgfVxuXG4gIGlmIChcImN1cnJlbnRcIiBpbiB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmN1cnJlbnQ7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZ2V0UmVmVGFyZ2V0cyh0YXJnZXRzLCBpc1NlbGVjdG9yKSB7XG4gIGlmICghdGFyZ2V0cykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciB1c2VyVGFyZ2V0cyA9IGlzQXJyYXlGb3JtYXQodGFyZ2V0cykgPyBbXS5zbGljZS5jYWxsKHRhcmdldHMpIDogW3RhcmdldHNdO1xuICByZXR1cm4gdXNlclRhcmdldHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCB0YXJnZXQpIHtcbiAgICBpZiAoaXNTdHJpbmcodGFyZ2V0KSAmJiBpc1NlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2KSwgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCkpKTtcbiAgICB9XG5cbiAgICBwcmV2LnB1c2goZ2V0UmVmVGFyZ2V0KHRhcmdldCwgaXNTZWxlY3RvcikpO1xuICAgIHJldHVybiBwcmV2O1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50VGFyZ2V0cyh0YXJnZXRzLCBzZWxlY3Rvck1hcCkge1xuICB2YXIgZWxlbWVudFRhcmdldHMgPSBbXTtcbiAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgICBpZiAoc2VsZWN0b3JNYXBbdGFyZ2V0XSkge1xuICAgICAgICBlbGVtZW50VGFyZ2V0cy5wdXNoLmFwcGx5KGVsZW1lbnRUYXJnZXRzLCBzZWxlY3Rvck1hcFt0YXJnZXRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnRUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgfSk7XG4gIHJldHVybiBlbGVtZW50VGFyZ2V0cztcbn1cbmZ1bmN0aW9uIGdldEFic29sdXRlUm90YXRpb24ocG9zMSwgcG9zMiwgZGlyZWN0aW9uKSB7XG4gIHZhciBkZWcgPSBnZXRSYWQocG9zMSwgcG9zMikgLyBNYXRoLlBJICogMTgwO1xuICBkZWcgPSBkaXJlY3Rpb24gPj0gMCA/IGRlZyA6IDE4MCAtIGRlZztcbiAgZGVnID0gZGVnID49IDAgPyBkZWcgOiAzNjAgKyBkZWc7XG4gIHJldHVybiBkZWc7XG59XG5mdW5jdGlvbiBnZXREcmFnRGlzdEJ5U3RhdGUoc3RhdGUsIGRpc3QpIHtcbiAgdmFyIHJvb3RNYXRyaXggPSBzdGF0ZS5yb290TWF0cml4LFxuICAgICAgaXMzZCA9IHN0YXRlLmlzM2Q7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICB2YXIgaW52ZXJzZU1hdHJpeCA9IGludmVydChyb290TWF0cml4LCBuKTtcblxuICBpZiAoIWlzM2QpIHtcbiAgICBpbnZlcnNlTWF0cml4ID0gY29udmVydERpbWVuc2lvbihpbnZlcnNlTWF0cml4LCAzLCA0KTtcbiAgfVxuXG4gIGludmVyc2VNYXRyaXhbMTJdID0gMDtcbiAgaW52ZXJzZU1hdHJpeFsxM10gPSAwO1xuICBpbnZlcnNlTWF0cml4WzE0XSA9IDA7XG4gIHJldHVybiBjYWxjdWxhdGVNYXRyaXhEaXN0KGludmVyc2VNYXRyaXgsIGRpc3QpO1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuUGluY2hhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBwaW5jaGVkIHdpdGggZHJhZ2dhYmxlLCByZXNpemFibGUsIHNjYWxhYmxlLCByb3RhdGFibGUgKGRlZmF1bHQ6IGZhbHNlKVxuICovXG5cbnZhciBQaW5jaGFibGUgPSBtYWtlQWJsZShcInBpbmNoYWJsZVwiLCB7XG4gIGV2ZW50czoge1xuICAgIG9uUGluY2hTdGFydDogXCJwaW5jaFN0YXJ0XCIsXG4gICAgb25QaW5jaDogXCJwaW5jaFwiLFxuICAgIG9uUGluY2hFbmQ6IFwicGluY2hFbmRcIixcbiAgICBvblBpbmNoR3JvdXBTdGFydDogXCJwaW5jaEdyb3VwU3RhcnRcIixcbiAgICBvblBpbmNoR3JvdXA6IFwicGluY2hHcm91cFwiLFxuICAgIG9uUGluY2hHcm91cEVuZDogXCJwaW5jaEdyb3VwRW5kXCJcbiAgfSxcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHBpbmNoU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIHRhcmdldHMgPSBlLnRhcmdldHMsXG4gICAgICAgIGFuZ2xlID0gZS5hbmdsZSxcbiAgICAgICAgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcztcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgcGluY2hhYmxlID0gX2EucGluY2hhYmxlLFxuICAgICAgICBhYmxlcyA9IF9hLmFibGVzO1xuXG4gICAgaWYgKCFwaW5jaGFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnROYW1lID0gXCJvblBpbmNoXCIgKyAodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIpICsgXCJTdGFydFwiO1xuICAgIHZhciBjb250cm9sRXZlbnROYW1lID0gXCJkcmFnXCIgKyAodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIpICsgXCJDb250cm9sU3RhcnRcIjtcbiAgICB2YXIgcGluY2hBYmxlcyA9IChwaW5jaGFibGUgPT09IHRydWUgPyBtb3ZlYWJsZS5jb250cm9sQWJsZXMgOiBhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgIHJldHVybiBwaW5jaGFibGUuaW5kZXhPZihhYmxlLm5hbWUpID4gLTE7XG4gICAgfSkpLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgcmV0dXJuIGFibGUuY2FuUGluY2ggJiYgYWJsZVtjb250cm9sRXZlbnROYW1lXTtcbiAgICB9KTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xuXG4gICAgaWYgKHRhcmdldHMpIHtcbiAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBldmVudE5hbWUsIHBhcmFtcyk7XG4gICAgZGF0YXMuaXNQaW5jaCA9IHJlc3VsdCAhPT0gZmFsc2U7XG4gICAgZGF0YXMuYWJsZXMgPSBwaW5jaEFibGVzO1xuICAgIHZhciBpc1BpbmNoID0gZGF0YXMuaXNQaW5jaDtcblxuICAgIGlmICghaXNQaW5jaCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHBpbmNoQWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdID0gb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdIHx8IHt9O1xuXG4gICAgICBpZiAoIWFibGVbY29udHJvbEV2ZW50TmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWJsZUV2ZW50ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICAgIGRhdGFzOiBvcmlnaW5hbERhdGFzW2FibGUubmFtZV0sXG4gICAgICAgIHBhcmVudFJvdGF0ZTogYW5nbGUsXG4gICAgICAgIGlzUGluY2g6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBhYmxlW2NvbnRyb2xFdmVudE5hbWVdKG1vdmVhYmxlLCBhYmxlRXZlbnQpO1xuICAgIH0pO1xuICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXG4gICAgICBkaXJlY3Rpb246IFswLCAwXVxuICAgIH07XG4gICAgcmV0dXJuIGlzUGluY2g7XG4gIH0sXG4gIHBpbmNoOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBwaW5jaFNjYWxlID0gZS5zY2FsZSxcbiAgICAgICAgZGlzdGFuY2UgPSBlLmRpc3RhbmNlLFxuICAgICAgICBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLFxuICAgICAgICBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LFxuICAgICAgICB0YXJnZXRzID0gZS50YXJnZXRzLFxuICAgICAgICBhbmdsZSA9IGUuYW5nbGU7XG5cbiAgICBpZiAoIWRhdGFzLmlzUGluY2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50RGlzdGFuY2UgPSBkaXN0YW5jZSAqICgxIC0gMSAvIHBpbmNoU2NhbGUpO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XG5cbiAgICBpZiAodGFyZ2V0cykge1xuICAgICAgcGFyYW1zLnRhcmdldHMgPSB0YXJnZXRzO1xuICAgIH1cblxuICAgIHZhciBldmVudE5hbWUgPSBcIm9uUGluY2hcIiArICh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIik7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBldmVudE5hbWUsIHBhcmFtcyk7XG4gICAgdmFyIGFibGVzID0gZGF0YXMuYWJsZXM7XG4gICAgdmFyIGNvbnRyb2xFdmVudE5hbWUgPSBcImRyYWdcIiArICh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIikgKyBcIkNvbnRyb2xcIjtcbiAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICBpZiAoIWFibGVbY29udHJvbEV2ZW50TmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhYmxlW2NvbnRyb2xFdmVudE5hbWVdKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgICAgZGF0YXM6IG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSxcbiAgICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgICAgcGFyZW50RGlzdGFuY2U6IHBhcmVudERpc3RhbmNlLFxuICAgICAgICBwYXJlbnRSb3RhdGU6IGFuZ2xlLFxuICAgICAgICBpc1BpbmNoOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgcGluY2hFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIHRhcmdldHMgPSBlLnRhcmdldHMsXG4gICAgICAgIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUGluY2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnROYW1lID0gXCJvblBpbmNoXCIgKyAodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIpICsgXCJFbmRcIjtcbiAgICB2YXIgcGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNEcmFnOiBpc1BpbmNoXG4gICAgfSk7XG5cbiAgICBpZiAodGFyZ2V0cykge1xuICAgICAgcGFyYW1zLnRhcmdldHMgPSB0YXJnZXRzO1xuICAgIH1cblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xuICAgIHZhciBhYmxlcyA9IGRhdGFzLmFibGVzO1xuICAgIHZhciBjb250cm9sRXZlbnROYW1lID0gXCJkcmFnXCIgKyAodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIpICsgXCJDb250cm9sRW5kXCI7XG4gICAgYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgaWYgKCFhYmxlW2NvbnRyb2xFdmVudE5hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYWJsZVtjb250cm9sRXZlbnROYW1lXShtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICAgIGlzRHJhZzogaXNQaW5jaCxcbiAgICAgICAgZGF0YXM6IG9yaWdpbmFsRGF0YXNbYWJsZS5uYW1lXSxcbiAgICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgICAgaXNQaW5jaDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBpc1BpbmNoO1xuICB9LFxuICBwaW5jaEdyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLnBpbmNoU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfSxcbiAgcGluY2hHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMucGluY2gobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfSxcbiAgcGluY2hHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMucGluY2hFbmQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfVxufSk7XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgcGluY2hlZCB3aXRoIGRyYWdnYWJsZSwgcmVzaXphYmxlLCBzY2FsYWJsZSwgcm90YXRhYmxlIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlBpbmNoYWJsZSNwaW5jaGFibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUucGluY2hhYmxlID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHBpbmNoIHN0YXJ0cywgdGhlIHBpbmNoU3RhcnQgZXZlbnQgaXMgY2FsbGVkIHdpdGggcGFydCBvZiBzY2FsZVN0YXJ0LCByb3RhdGVTdGFydCwgcmVzaXplU3RhcnRcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcbiAqIEBldmVudCBwaW5jaFN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHBpbmNoU3RhcnQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdGF0YWJsZTogdHJ1ZSxcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcbiAqICAgICBwaW5jaGFibGU6IHRydWUsIC8vIFtcInJvdGF0YWJsZVwiLCBcInNjYWxhYmxlXCJdXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHBpbmNoaW5nLCB0aGUgcGluY2ggZXZlbnQgaXMgY2FsbGVkIHdpdGggcGFydCBvZiBzY2FsZSwgcm90YXRlLCByZXNpemVcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcbiAqIEBldmVudCBwaW5jaFxuICogQHBhcmFtIHtNb3ZlYWJsZS5QaW5jaGFibGUuT25QaW5jaH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcGluY2ggZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdGF0YWJsZTogdHJ1ZSxcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcbiAqICAgICBwaW5jaGFibGU6IHRydWUsIC8vIFtcInJvdGF0YWJsZVwiLCBcInNjYWxhYmxlXCJdXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZVwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBwaW5jaCBmaW5pc2hlcywgdGhlIHBpbmNoRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcbiAqIEBldmVudCBwaW5jaEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5QaW5jaGFibGUuT25QaW5jaEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcGluY2hFbmQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdGF0YWJsZTogdHJ1ZSxcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcbiAqICAgICBwaW5jaGFibGU6IHRydWUsIC8vIFtcInJvdGF0YWJsZVwiLCBcInNjYWxhYmxlXCJdXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hFbmRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUVuZFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVFbmRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCBwaW5jaCBzdGFydHMsIHRoZSBgcGluY2hHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXG4gKiBAZXZlbnQgcGluY2hHcm91cFN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHBpbmNoR3JvdXBTdGFydGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25QaW5jaEdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGdyb3VwIHBpbmNoLCB0aGUgYHBpbmNoR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcbiAqIEBldmVudCBwaW5jaEdyb3VwXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBwaW5jaEdyb3VwYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICBwaW5jaGFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJwaW5jaEdyb3VwXCIsICh7IHRhcmdldHMsIGV2ZW50cyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblBpbmNoR3JvdXBcIiwgdGFyZ2V0cyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGdyb3VwIHBpbmNoIGZpbmlzaGVzLCB0aGUgYHBpbmNoR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcbiAqIEBldmVudCBwaW5jaEdyb3VwRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlBpbmNoYWJsZS5PblBpbmNoR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBwaW5jaEdyb3VwRW5kYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICBwaW5jaGFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJwaW5jaEdyb3VwRW5kXCIsICh7IHRhcmdldHMsIGlzRHJhZyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblBpbmNoR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbmZ1bmN0aW9uIHNldEN1c3RvbURyYWcoZSwgc3RhdGUsIGRlbHRhLCBpc1BpbmNoLCBpc0NvbnZlcnQpIHtcbiAgdmFyIHJlc3VsdCA9IHN0YXRlLmdlc3RvLm1vdmUoZGVsdGEsIGUuaW5wdXRFdmVudCk7XG4gIHZhciBkYXRhcyA9IHJlc3VsdC5vcmlnaW5hbERhdGFzIHx8IHJlc3VsdC5kYXRhcztcbiAgdmFyIGRyYWdnYWJsZURhdGFzID0gZGF0YXMuZHJhZ2dhYmxlIHx8IChkYXRhcy5kcmFnZ2FibGUgPSB7fSk7XG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaXNDb252ZXJ0ID8gY29udmVydERyYWdEaXN0KHN0YXRlLCByZXN1bHQpIDogcmVzdWx0KSwge1xuICAgIGlzRHJhZzogdHJ1ZSxcbiAgICBpc1BpbmNoOiAhIWlzUGluY2gsXG4gICAgcGFyZW50RXZlbnQ6IHRydWUsXG4gICAgZGF0YXM6IGRyYWdnYWJsZURhdGFzLFxuICAgIG9yaWdpbmFsRGF0YXM6IGUub3JpZ2luYWxEYXRhc1xuICB9KTtcbn1cblxudmFyIEN1c3RvbUdlc3RvID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3VzdG9tR2VzdG8oKSB7XG4gICAgdGhpcy5wcmV2WCA9IDA7XG4gICAgdGhpcy5wcmV2WSA9IDA7XG4gICAgdGhpcy5zdGFydFggPSAwO1xuICAgIHRoaXMuc3RhcnRZID0gMDtcbiAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5kYXRhcyA9IHtcbiAgICAgIGRyYWdnYWJsZToge31cbiAgICB9O1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBDdXN0b21HZXN0by5wcm90b3R5cGU7XG5cbiAgX19wcm90by5kcmFnU3RhcnQgPSBmdW5jdGlvbiAoY2xpZW50LCBlKSB7XG4gICAgdGhpcy5pc0RyYWcgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmxhZyA9IGZhbHNlO1xuICAgIHZhciBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzO1xuICAgIHRoaXMuZGF0YXMgPSBvcmlnaW5hbERhdGFzO1xuXG4gICAgaWYgKCFvcmlnaW5hbERhdGFzLmRyYWdnYWJsZSkge1xuICAgICAgb3JpZ2luYWxEYXRhcy5kcmFnZ2FibGUgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMubW92ZShjbGllbnQsIGUuaW5wdXRFdmVudCkpLCB7XG4gICAgICB0eXBlOiBcImRyYWdzdGFydFwiXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5kcmFnID0gZnVuY3Rpb24gKGNsaWVudCwgaW5wdXRFdmVudCkge1xuICAgIHJldHVybiB0aGlzLm1vdmUoW2NsaWVudFswXSAtIHRoaXMucHJldlgsIGNsaWVudFsxXSAtIHRoaXMucHJldlldLCBpbnB1dEV2ZW50KTtcbiAgfTtcblxuICBfX3Byb3RvLm1vdmUgPSBmdW5jdGlvbiAoZGVsdGEsIGlucHV0RXZlbnQpIHtcbiAgICB2YXIgY2xpZW50WDtcbiAgICB2YXIgY2xpZW50WTtcblxuICAgIGlmICghdGhpcy5pc0ZsYWcpIHtcbiAgICAgIHRoaXMucHJldlggPSBkZWx0YVswXTtcbiAgICAgIHRoaXMucHJldlkgPSBkZWx0YVsxXTtcbiAgICAgIHRoaXMuc3RhcnRYID0gZGVsdGFbMF07XG4gICAgICB0aGlzLnN0YXJ0WSA9IGRlbHRhWzFdO1xuICAgICAgY2xpZW50WCA9IGRlbHRhWzBdO1xuICAgICAgY2xpZW50WSA9IGRlbHRhWzFdO1xuICAgICAgdGhpcy5pc0ZsYWcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRYID0gdGhpcy5wcmV2WCArIGRlbHRhWzBdO1xuICAgICAgY2xpZW50WSA9IHRoaXMucHJldlkgKyBkZWx0YVsxXTtcbiAgICAgIHRoaXMuaXNEcmFnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZYID0gY2xpZW50WDtcbiAgICB0aGlzLnByZXZZID0gY2xpZW50WTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkcmFnXCIsXG4gICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgY2xpZW50WTogY2xpZW50WSxcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICBpc0RyYWc6IHRoaXMuaXNEcmFnLFxuICAgICAgZGlzdFg6IGNsaWVudFggLSB0aGlzLnN0YXJ0WCxcbiAgICAgIGRpc3RZOiBjbGllbnRZIC0gdGhpcy5zdGFydFksXG4gICAgICBkZWx0YVg6IGRlbHRhWzBdLFxuICAgICAgZGVsdGFZOiBkZWx0YVsxXSxcbiAgICAgIGRhdGFzOiB0aGlzLmRhdGFzLmRyYWdnYWJsZSxcbiAgICAgIG9yaWdpbmFsRGF0YXM6IHRoaXMuZGF0YXMsXG4gICAgICBwYXJlbnRFdmVudDogdHJ1ZSxcbiAgICAgIHBhcmVudEdlc3RvOiB0aGlzXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQ3VzdG9tR2VzdG87XG59KCk7XG5cbmZ1bmN0aW9uIGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgbmFtZSwgZSkge1xuICB2YXIgZGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XG4gIGRhdGFzLmdyb3VwYWJsZSA9IGRhdGFzLmdyb3VwYWJsZSB8fCB7fTtcbiAgdmFyIGdyb3VwYWJsZURhdGFzID0gZGF0YXMuZ3JvdXBhYmxlO1xuICBncm91cGFibGVEYXRhcy5jaGlsZERhdGFzID0gZ3JvdXBhYmxlRGF0YXMuY2hpbGREYXRhcyB8fCBbXTtcbiAgdmFyIGNoaWxkRGF0YXMgPSBncm91cGFibGVEYXRhcy5jaGlsZERhdGFzO1xuICByZXR1cm4gbW92ZWFibGUubW92ZWFibGVzLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgIGNoaWxkRGF0YXNbaV0gPSBjaGlsZERhdGFzW2ldIHx8IHt9O1xuICAgIGNoaWxkRGF0YXNbaV1bbmFtZV0gPSBjaGlsZERhdGFzW2ldW25hbWVdIHx8IHt9O1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIGRhdGFzOiBjaGlsZERhdGFzW2ldW25hbWVdLFxuICAgICAgb3JpZ2luYWxEYXRhczogY2hpbGREYXRhc1tpXVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJDaGlsZEdlc3RvKG1vdmVhYmxlLCBhYmxlLCB0eXBlLCBkZWx0YSwgZSwgaXNDb252ZXJ0KSB7XG4gIHZhciBpc1N0YXJ0ID0gISF0eXBlLm1hdGNoKC9TdGFydCQvZyk7XG4gIHZhciBpc0VuZCA9ICEhdHlwZS5tYXRjaCgvRW5kJC9nKTtcbiAgdmFyIGlzUGluY2ggPSBlLmlzUGluY2g7XG4gIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIGFibGUubmFtZSwgZSk7XG4gIHZhciBtb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXM7XG4gIHZhciBjaGlsZHMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChldiwgaSkge1xuICAgIHZhciBjaGlsZE1vdmVhYmxlID0gbW92ZWFibGVzW2ldO1xuICAgIHZhciBjaGlsZEV2ZW50ID0gZXY7XG5cbiAgICBpZiAoaXNTdGFydCkge1xuICAgICAgY2hpbGRFdmVudCA9IG5ldyBDdXN0b21HZXN0bygpLmRyYWdTdGFydChkZWx0YSwgZXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNoaWxkTW92ZWFibGUuc3RhdGUuZ2VzdG8pIHtcbiAgICAgICAgY2hpbGRNb3ZlYWJsZS5zdGF0ZS5nZXN0byA9IGRhdGFzLmNoaWxkR2VzdG9zW2ldO1xuICAgICAgfVxuXG4gICAgICBjaGlsZEV2ZW50ID0gc2V0Q3VzdG9tRHJhZyhldiwgY2hpbGRNb3ZlYWJsZS5zdGF0ZSwgZGVsdGEsIGlzUGluY2gsIGlzQ29udmVydCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGFibGVbdHlwZV0oY2hpbGRNb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGNoaWxkRXZlbnQpLCB7XG4gICAgICBwYXJlbnRGbGFnOiB0cnVlXG4gICAgfSkpO1xuXG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICBjaGlsZE1vdmVhYmxlLnN0YXRlLmdlc3RvID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICBpZiAoaXNTdGFydCkge1xuICAgIGRhdGFzLmNoaWxkR2VzdG9zID0gbW92ZWFibGVzLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5zdGF0ZS5nZXN0bztcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHM7XG59XG5mdW5jdGlvbiB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgYWJsZSwgdHlwZSwgZSwgZWFjaEV2ZW50LCBjYWxsYmFjaykge1xuICBpZiAoZWFjaEV2ZW50ID09PSB2b2lkIDApIHtcbiAgICBlYWNoRXZlbnQgPSBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgIHJldHVybiBldjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGlzRW5kID0gISF0eXBlLm1hdGNoKC9FbmQkL2cpO1xuICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBhYmxlLm5hbWUsIGUpO1xuICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xuICB2YXIgY2hpbGRzID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYsIGkpIHtcbiAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcbiAgICB2YXIgY2hpbGRFdmVudCA9IGV2O1xuICAgIGNoaWxkRXZlbnQgPSBlYWNoRXZlbnQoY2hpbGRNb3ZlYWJsZSwgZXYpO1xuICAgIHZhciByZXN1bHQgPSBhYmxlW3R5cGVdKGNoaWxkTW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGlsZEV2ZW50KSwge1xuICAgICAgcGFyZW50RmxhZzogdHJ1ZVxuICAgIH0pKTtcbiAgICByZXN1bHQgJiYgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2hpbGRNb3ZlYWJsZSwgZXYsIHJlc3VsdCwgaSk7XG5cbiAgICBpZiAoaXNFbmQpIHtcbiAgICAgIGNoaWxkTW92ZWFibGUuc3RhdGUuZ2VzdG8gPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gY2hpbGRzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb2ludGVyRGlzdChtb3ZlYWJsZSwgZSkge1xuICB2YXIgY2xpZW50WCA9IGUuY2xpZW50WCxcbiAgICAgIGNsaWVudFkgPSBlLmNsaWVudFksXG4gICAgICBkYXRhcyA9IGUuZGF0YXM7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgbW92ZWFibGVDbGllbnRSZWN0ID0gX2EubW92ZWFibGVDbGllbnRSZWN0LFxuICAgICAgcm9vdE1hdHJpeCA9IF9hLnJvb3RNYXRyaXgsXG4gICAgICBpczNkID0gX2EuaXMzZCxcbiAgICAgIHBvczEgPSBfYS5wb3MxO1xuICB2YXIgbGVmdCA9IG1vdmVhYmxlQ2xpZW50UmVjdC5sZWZ0LFxuICAgICAgdG9wID0gbW92ZWFibGVDbGllbnRSZWN0LnRvcDtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG5cbiAgdmFyIF9iID0gbWludXMoY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtjbGllbnRYIC0gbGVmdCwgY2xpZW50WSAtIHRvcF0sIG4pLCBwb3MxKSxcbiAgICAgIHBvc1ggPSBfYlswXSxcbiAgICAgIHBvc1kgPSBfYlsxXTtcblxuICB2YXIgX2MgPSBnZXREcmFnRGlzdCh7XG4gICAgZGF0YXM6IGRhdGFzLFxuICAgIGRpc3RYOiBwb3NYLFxuICAgIGRpc3RZOiBwb3NZXG4gIH0pLFxuICAgICAgZGlzdFggPSBfY1swXSxcbiAgICAgIGRpc3RZID0gX2NbMV07XG5cbiAgcmV0dXJuIFtkaXN0WCwgZGlzdFldO1xufVxuZnVuY3Rpb24gc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBfYSkge1xuICB2YXIgZGF0YXMgPSBfYS5kYXRhcztcbiAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICBhbGxNYXRyaXggPSBfYi5hbGxNYXRyaXgsXG4gICAgICBiZWZvcmVNYXRyaXggPSBfYi5iZWZvcmVNYXRyaXgsXG4gICAgICBpczNkID0gX2IuaXMzZCxcbiAgICAgIGxlZnQgPSBfYi5sZWZ0LFxuICAgICAgdG9wID0gX2IudG9wLFxuICAgICAgb3JpZ2luID0gX2Iub3JpZ2luLFxuICAgICAgb2Zmc2V0TWF0cml4ID0gX2Iub2Zmc2V0TWF0cml4LFxuICAgICAgdGFyZ2V0TWF0cml4ID0gX2IudGFyZ2V0TWF0cml4LFxuICAgICAgdHJhbnNmb3JtT3JpZ2luID0gX2IudHJhbnNmb3JtT3JpZ2luO1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgZGF0YXMuaXMzZCA9IGlzM2Q7XG4gIGRhdGFzLm1hdHJpeCA9IGFsbE1hdHJpeDtcbiAgZGF0YXMudGFyZ2V0TWF0cml4ID0gdGFyZ2V0TWF0cml4O1xuICBkYXRhcy5iZWZvcmVNYXRyaXggPSBiZWZvcmVNYXRyaXg7XG4gIGRhdGFzLm9mZnNldE1hdHJpeCA9IG9mZnNldE1hdHJpeDtcbiAgZGF0YXMudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtT3JpZ2luO1xuICBkYXRhcy5pbnZlcnNlTWF0cml4ID0gaW52ZXJ0KGFsbE1hdHJpeCwgbik7XG4gIGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXggPSBpbnZlcnQoYmVmb3JlTWF0cml4LCBuKTtcbiAgZGF0YXMuYWJzb2x1dGVPcmlnaW4gPSBjb252ZXJ0UG9zaXRpb25NYXRyaXgocGx1cyhbbGVmdCwgdG9wXSwgb3JpZ2luKSwgbik7XG4gIGRhdGFzLnN0YXJ0RHJhZ0JlZm9yZURpc3QgPSBjYWxjdWxhdGUoZGF0YXMuaW52ZXJzZUJlZm9yZU1hdHJpeCwgZGF0YXMuYWJzb2x1dGVPcmlnaW4sIG4pO1xuICBkYXRhcy5zdGFydERyYWdEaXN0ID0gY2FsY3VsYXRlKGRhdGFzLmludmVyc2VNYXRyaXgsIGRhdGFzLmFic29sdXRlT3JpZ2luLCBuKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybURpcmVjdGlvbihlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVNb3ZlYWJsZVBvc2l0aW9uKGUuZGF0YXMuYmVmb3JlVHJhbnNmb3JtLCBbNTAsIDUwXSwgMTAwLCAxMDApLmRpcmVjdGlvbjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2Zvcm1FdmVudChldmVudCwgZnVuY3Rpb25OYW1lKSB7XG4gIHZhciBkYXRhcyA9IGV2ZW50LmRhdGFzLFxuICAgICAgb3JpZ2luYWxEYXRhcyA9IGV2ZW50Lm9yaWdpbmFsRGF0YXMuYmVmb3JlUmVuZGVyYWJsZTtcbiAgdmFyIGluZGV4ID0gZGF0YXMudHJhbnNmb3JtSW5kZXg7XG4gIHZhciBuZXh0VHJhbnNmb3JtcyA9IG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybXM7XG4gIHZhciBuZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzID0gb3JpZ2luYWxEYXRhcy5uZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzO1xuICB2YXIgbmV4dEluZGV4ID0gMDtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgbmV4dEluZGV4ID0gbmV4dFRyYW5zZm9ybXMubGVuZ3RoO1xuICAgIGRhdGFzLnRyYW5zZm9ybUluZGV4ID0gbmV4dEluZGV4O1xuICB9IGVsc2Uge1xuICAgIG5leHRJbmRleCA9IGluZGV4ICsgbmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpIDwgaW5kZXg7XG4gICAgfSkubGVuZ3RoO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGdldFRyYW5zZm9ybShuZXh0VHJhbnNmb3JtcywgbmV4dEluZGV4KTtcbiAgdmFyIHRhcmdldEZ1bmN0aW9uID0gcmVzdWx0LnRhcmdldEZ1bmN0aW9uO1xuICB2YXIgbWF0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lID09PSBcInJvdGF0ZVwiID8gXCJyb3RhdGVaXCIgOiBmdW5jdGlvbk5hbWU7XG4gIGRhdGFzLmJlZm9yZUZ1bmN0aW9uVGV4dHMgPSByZXN1bHQuYmVmb3JlRnVuY3Rpb25UZXh0cztcbiAgZGF0YXMuYWZ0ZXJGdW5jdGlvblRleHRzID0gcmVzdWx0LmFmdGVyRnVuY3Rpb25UZXh0cztcbiAgZGF0YXMuYmVmb3JlVHJhbnNmb3JtID0gcmVzdWx0LmJlZm9yZUZ1bmN0aW9uTWF0cml4O1xuICBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0yID0gcmVzdWx0LmJlZm9yZUZ1bmN0aW9uTWF0cml4MjtcbiAgZGF0YXMudGFyZ2V0VGFuc2Zvcm0gPSByZXN1bHQudGFyZ2V0RnVuY3Rpb25NYXRyaXg7XG4gIGRhdGFzLmFmdGVyVHJhbnNmb3JtID0gcmVzdWx0LmFmdGVyRnVuY3Rpb25NYXRyaXg7XG4gIGRhdGFzLmFmdGVyVHJhbnNmb3JtMiA9IHJlc3VsdC5hZnRlckZ1bmN0aW9uTWF0cml4MjtcbiAgZGF0YXMudGFyZ2V0QWxsVHJhbnNmb3JtID0gcmVzdWx0LmFsbEZ1bmN0aW9uTWF0cml4O1xuXG4gIGlmICh0YXJnZXRGdW5jdGlvbi5mdW5jdGlvbk5hbWUgPT09IG1hdEZ1bmN0aW9uTmFtZSkge1xuICAgIGRhdGFzLmFmdGVyRnVuY3Rpb25UZXh0cy5zcGxpY2UoMCwgMSk7XG4gICAgZGF0YXMuaXNBcHBlbmRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhcy5pc0FwcGVuZFRyYW5zZm9ybSA9IHRydWU7XG4gICAgb3JpZ2luYWxEYXRhcy5uZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBuZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzKSwgW25leHRJbmRleF0pO1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCB2YWx1ZSwgZGlzdCkge1xuICByZXR1cm4gZGF0YXMuYmVmb3JlRnVuY3Rpb25UZXh0cy5qb2luKFwiIFwiKSArIFwiIFwiICsgKGRhdGFzLmlzQXBwZW5kVHJhbnNmb3JtID8gZGlzdCA6IHZhbHVlKSArIFwiIFwiICsgZGF0YXMuYWZ0ZXJGdW5jdGlvblRleHRzLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRGlzdChfYSkge1xuICB2YXIgZGF0YXMgPSBfYS5kYXRhcyxcbiAgICAgIGRpc3RYID0gX2EuZGlzdFgsXG4gICAgICBkaXN0WSA9IF9hLmRpc3RZO1xuXG4gIHZhciBfYiA9IGdldEJlZm9yZURyYWdEaXN0KHtcbiAgICBkYXRhczogZGF0YXMsXG4gICAgZGlzdFg6IGRpc3RYLFxuICAgIGRpc3RZOiBkaXN0WVxuICB9KSxcbiAgICAgIGJ4ID0gX2JbMF0sXG4gICAgICBieSA9IF9iWzFdOyAvLyBCICogW3R4LCB0eV0gKiBBID0gW2J4LCBieV0gKiB0YXJnZXRNYXRyaXg7XG4gIC8vIFt0eCwgdHldID0gQi0xICogW2J4LCBieV0gKiB0YXJnZXRNYXRyaXggKiBBLTEgKiBbMCwgMF07XG5cblxuICB2YXIgcmVzID0gZ2V0VHJhbnNmcm9tTWF0cml4KGRhdGFzLCBmcm9tVHJhbnNsYXRpb24oW2J4LCBieV0sIDQpKTtcbiAgcmV0dXJuIGNhbGN1bGF0ZShyZXMsIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChbMCwgMCwgMF0sIDQpLCA0KTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zZnJvbU1hdHJpeChkYXRhcywgdGFyZ2V0TWF0cml4LCBpc0FmdGVyKSB7XG4gIHZhciBiZWZvcmVUcmFuc2Zvcm0gPSBkYXRhcy5iZWZvcmVUcmFuc2Zvcm0sXG4gICAgICBhZnRlclRyYW5zZm9ybSA9IGRhdGFzLmFmdGVyVHJhbnNmb3JtLFxuICAgICAgYmVmb3JlVHJhbnNmb3JtMiA9IGRhdGFzLmJlZm9yZVRyYW5zZm9ybTIsXG4gICAgICBhZnRlclRyYW5zZm9ybTIgPSBkYXRhcy5hZnRlclRyYW5zZm9ybTIsXG4gICAgICB0YXJnZXRBbGxUcmFuc2Zvcm0gPSBkYXRhcy50YXJnZXRBbGxUcmFuc2Zvcm07IC8vIEIgKiBhZnRlclRhcmdldE1hdHJpeCAqIEEgPSAodGFyZ2V0TWF0cml4ICogdGFyZ2V0QWxsVHJhbnNmb3JtKVxuICAvLyBhZnRlclRhcmdldE1hdHJpeCA9IEItMSAqIHRhcmdldE1hdHJpeCAqIHRhcmdldEFsbFRyYW5zZm9ybSAqIEEtMVxuICAvLyBuZXh0VGFyZ2V0TWF0cml4ID0gKHRhcmdldE1hdHJpeCAqIHRhcmdldEFsbFRyYW5zZm9ybSlcblxuICB2YXIgbmV4dFRhcmdldE1hdHJpeCA9IGlzQWZ0ZXIgPyBtdWx0aXBseSh0YXJnZXRBbGxUcmFuc2Zvcm0sIHRhcmdldE1hdHJpeCwgNCkgOiBtdWx0aXBseSh0YXJnZXRNYXRyaXgsIHRhcmdldEFsbFRyYW5zZm9ybSwgNCk7IC8vIHJlczEgPSBCLTEgKiBuZXh0VGFyZ2V0TWF0cml4XG5cbiAgdmFyIHJlczEgPSBtdWx0aXBseShpbnZlcnQoaXNBZnRlciA/IGJlZm9yZVRyYW5zZm9ybTIgOiBiZWZvcmVUcmFuc2Zvcm0sIDQpLCBuZXh0VGFyZ2V0TWF0cml4LCA0KTsgLy8gcmVzMyA9IHJlczIgKiBBLTFcblxuICB2YXIgYWZ0ZXJUYXJnZXRNYXRyaXggPSBtdWx0aXBseShyZXMxLCBpbnZlcnQoaXNBZnRlciA/IGFmdGVyVHJhbnNmb3JtMiA6IGFmdGVyVHJhbnNmb3JtLCA0KSwgNCk7XG4gIHJldHVybiBhZnRlclRhcmdldE1hdHJpeDtcbn1cbmZ1bmN0aW9uIGdldEJlZm9yZURyYWdEaXN0KF9hKSB7XG4gIHZhciBkYXRhcyA9IF9hLmRhdGFzLFxuICAgICAgZGlzdFggPSBfYS5kaXN0WCxcbiAgICAgIGRpc3RZID0gX2EuZGlzdFk7IC8vIFRUID0gQlRcblxuICB2YXIgaW52ZXJzZUJlZm9yZU1hdHJpeCA9IGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXgsXG4gICAgICBpczNkID0gZGF0YXMuaXMzZCxcbiAgICAgIHN0YXJ0RHJhZ0JlZm9yZURpc3QgPSBkYXRhcy5zdGFydERyYWdCZWZvcmVEaXN0LFxuICAgICAgYWJzb2x1dGVPcmlnaW4gPSBkYXRhcy5hYnNvbHV0ZU9yaWdpbjtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7IC8vIEFCU19PUklHSU4gKiBbZGlzdFgsIGRpc3RZXSA9IEJNICogKE9SSUdJTiArIFt0eCwgdHldKVxuICAvLyBCTSAtMSAqIEFCU19PUklHSU4gKiBbZGlzdFgsIGRpc3RZXSAtIE9SSUdJTiA9IFt0eCwgdHldXG5cbiAgcmV0dXJuIG1pbnVzKGNhbGN1bGF0ZShpbnZlcnNlQmVmb3JlTWF0cml4LCBwbHVzKGFic29sdXRlT3JpZ2luLCBbZGlzdFgsIGRpc3RZXSksIG4pLCBzdGFydERyYWdCZWZvcmVEaXN0KTtcbn1cbmZ1bmN0aW9uIGdldERyYWdEaXN0KF9hLCBpc0JlZm9yZSkge1xuICB2YXIgZGF0YXMgPSBfYS5kYXRhcyxcbiAgICAgIGRpc3RYID0gX2EuZGlzdFgsXG4gICAgICBkaXN0WSA9IF9hLmRpc3RZO1xuICB2YXIgaW52ZXJzZUJlZm9yZU1hdHJpeCA9IGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXgsXG4gICAgICBpbnZlcnNlTWF0cml4ID0gZGF0YXMuaW52ZXJzZU1hdHJpeCxcbiAgICAgIGlzM2QgPSBkYXRhcy5pczNkLFxuICAgICAgc3RhcnREcmFnQmVmb3JlRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0JlZm9yZURpc3QsXG4gICAgICBzdGFydERyYWdEaXN0ID0gZGF0YXMuc3RhcnREcmFnRGlzdCxcbiAgICAgIGFic29sdXRlT3JpZ2luID0gZGF0YXMuYWJzb2x1dGVPcmlnaW47XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICByZXR1cm4gbWludXMoY2FsY3VsYXRlKGlzQmVmb3JlID8gaW52ZXJzZUJlZm9yZU1hdHJpeCA6IGludmVyc2VNYXRyaXgsIHBsdXMoYWJzb2x1dGVPcmlnaW4sIFtkaXN0WCwgZGlzdFldKSwgbiksIGlzQmVmb3JlID8gc3RhcnREcmFnQmVmb3JlRGlzdCA6IHN0YXJ0RHJhZ0Rpc3QpO1xufVxuZnVuY3Rpb24gZ2V0SW52ZXJzZURyYWdEaXN0KF9hLCBpc0JlZm9yZSkge1xuICB2YXIgZGF0YXMgPSBfYS5kYXRhcyxcbiAgICAgIGRpc3RYID0gX2EuZGlzdFgsXG4gICAgICBkaXN0WSA9IF9hLmRpc3RZO1xuICB2YXIgYmVmb3JlTWF0cml4ID0gZGF0YXMuYmVmb3JlTWF0cml4LFxuICAgICAgbWF0cml4ID0gZGF0YXMubWF0cml4LFxuICAgICAgaXMzZCA9IGRhdGFzLmlzM2QsXG4gICAgICBzdGFydERyYWdCZWZvcmVEaXN0ID0gZGF0YXMuc3RhcnREcmFnQmVmb3JlRGlzdCxcbiAgICAgIHN0YXJ0RHJhZ0Rpc3QgPSBkYXRhcy5zdGFydERyYWdEaXN0LFxuICAgICAgYWJzb2x1dGVPcmlnaW4gPSBkYXRhcy5hYnNvbHV0ZU9yaWdpbjtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gIHJldHVybiBtaW51cyhjYWxjdWxhdGUoaXNCZWZvcmUgPyBiZWZvcmVNYXRyaXggOiBtYXRyaXgsIHBsdXMoaXNCZWZvcmUgPyBzdGFydERyYWdCZWZvcmVEaXN0IDogc3RhcnREcmFnRGlzdCwgW2Rpc3RYLCBkaXN0WV0pLCBuKSwgYWJzb2x1dGVPcmlnaW4pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNmb3JtT3JpZ2luKHRyYW5zZm9ybU9yaWdpbiwgd2lkdGgsIGhlaWdodCwgcHJldldpZHRoLCBwcmV2SGVpZ2h0LCBwcmV2T3JpZ2luKSB7XG4gIGlmIChwcmV2V2lkdGggPT09IHZvaWQgMCkge1xuICAgIHByZXZXaWR0aCA9IHdpZHRoO1xuICB9XG5cbiAgaWYgKHByZXZIZWlnaHQgPT09IHZvaWQgMCkge1xuICAgIHByZXZIZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBpZiAocHJldk9yaWdpbiA9PT0gdm9pZCAwKSB7XG4gICAgcHJldk9yaWdpbiA9IFswLCAwXTtcbiAgfVxuXG4gIGlmICghdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgcmV0dXJuIHByZXZPcmlnaW47XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtT3JpZ2luLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgdmFyIF9hID0gc3BsaXRVbml0KHBvcyksXG4gICAgICAgIHZhbHVlID0gX2EudmFsdWUsXG4gICAgICAgIHVuaXQgPSBfYS51bml0O1xuXG4gICAgdmFyIHByZXZTaXplID0gaSA/IHByZXZIZWlnaHQgOiBwcmV2V2lkdGg7XG4gICAgdmFyIHNpemUgPSBpID8gaGVpZ2h0IDogd2lkdGg7XG5cbiAgICBpZiAocG9zID09PSBcIiVcIiB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIC8vIG5vIHZhbHVlIGJ1dCAlXG4gICAgICB2YXIgbWVhc3VyZVJhdGlvID0gcHJldlNpemUgPyBwcmV2T3JpZ2luW2ldIC8gcHJldlNpemUgOiAwO1xuICAgICAgcmV0dXJuIHNpemUgKiBtZWFzdXJlUmF0aW87XG4gICAgfSBlbHNlIGlmICh1bml0ICE9PSBcIiVcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBzaXplICogdmFsdWUgLyAxMDA7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UG9zSW5kZXhlc0J5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gIGlmIChkaXJlY3Rpb25bMV0gPj0gMCkge1xuICAgIGlmIChkaXJlY3Rpb25bMF0gPj0gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKDMpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb25bMF0gPD0gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKDIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJlY3Rpb25bMV0gPD0gMCkge1xuICAgIGlmIChkaXJlY3Rpb25bMF0gPj0gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKDEpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb25bMF0gPD0gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKDApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleGVzO1xufVxuZnVuY3Rpb24gZ2V0UG9zZXNCeURpcmVjdGlvbihwb3NlcywgZGlyZWN0aW9uKSB7XG4gIC8qXG4gIFstMSwgLTFdKHBvczEpICAgICAgIFswLCAtMV0ocG9zMSxwb3MyKSAgICAgICBbMSwgLTFdKHBvczIpXG4gIFstMSwgMF0ocG9zMSwgcG9zMykgICAgICAgICAgICAgICAgICAgICAgICAgICBbMSwgMF0ocG9zMiwgcG9zNClcbiAgWy0xLCAxXShwb3MzKSAgICAgICAgWzAsIDFdKHBvczMsIHBvczQpICAgICAgIFsxLCAxXShwb3M0KVxuICAqL1xuICByZXR1cm4gZ2V0UG9zSW5kZXhlc0J5RGlyZWN0aW9uKGRpcmVjdGlvbikubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBwb3Nlc1tpbmRleF07XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbikge1xuICAvKlxuICBbLTEsIC0xXShwb3MxKSAgICAgICBbMCwgLTFdKHBvczEscG9zMikgICAgICAgWzEsIC0xXShwb3MyKVxuICBbLTEsIDBdKHBvczEsIHBvczMpICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEsIDBdKHBvczIsIHBvczQpXG4gIFstMSwgMV0ocG9zMykgICAgICAgIFswLCAxXShwb3MzLCBwb3M0KSAgICAgICBbMSwgMV0ocG9zNClcbiAgKi9cbiAgdmFyIG5leHRQb3NlcyA9IGdldFBvc2VzQnlEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbik7XG4gIHJldHVybiBbYXZlcmFnZShuZXh0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zWzBdO1xuICB9KSksIGF2ZXJhZ2UobmV4dFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvc1sxXTtcbiAgfSkpXTtcbn1cbmZ1bmN0aW9uIGdldFBvc0J5UmV2ZXJzZURpcmVjdGlvbihwb3NlcywgZGlyZWN0aW9uKSB7XG4gIC8qXG4gIFstMSwgLTFdKHBvczQpICAgICAgIFswLCAtMV0ocG9zMyxwb3M0KSAgICAgICBbMSwgLTFdKHBvczMpXG4gIFstMSwgMF0ocG9zMiwgcG9zNCkgICAgICAgICAgICAgICAgICAgICAgICAgICBbMSwgMF0ocG9zMywgcG9zMSlcbiAgWy0xLCAxXShwb3MyKSAgICAgICAgWzAsIDFdKHBvczEsIHBvczIpICAgICAgIFsxLCAxXShwb3MxKVxuICAqL1xuICByZXR1cm4gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbi5tYXAoZnVuY3Rpb24gKGRpcikge1xuICAgIHJldHVybiAtZGlyO1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3Qoc3RhcnRQb3MsIG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbiwgZml4ZWREaXJlY3Rpb24pIHtcbiAgdmFyIHBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKTtcbiAgdmFyIGZpeGVkUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGZpeGVkRGlyZWN0aW9uKTtcbiAgdmFyIGRpc3RYID0gc3RhcnRQb3NbMF0gLSBmaXhlZFBvc1swXTtcbiAgdmFyIGRpc3RZID0gc3RhcnRQb3NbMV0gLSBmaXhlZFBvc1sxXTtcbiAgcmV0dXJuIFtkaXN0WCwgZGlzdFldO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4LCBvcmlnaW4sIG4pIHtcbiAgcmV0dXJuIG11bHRpcGx5KG9mZnNldE1hdHJpeCwgZ2V0QWJzb2x1dGVNYXRyaXgodGFyZ2V0TWF0cml4LCBuLCBvcmlnaW4pLCBuKTtcbn1cbmZ1bmN0aW9uIGdldE5leHRUcmFuc2Zvcm1NYXRyaXgoc3RhdGUsIGRhdGFzLCB0cmFuc2Zvcm0pIHtcbiAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHN0YXRlLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgIG9mZnNldE1hdHJpeCA9IHN0YXRlLm9mZnNldE1hdHJpeCxcbiAgICAgIGlzM2QgPSBzdGF0ZS5pczNkO1xuICB2YXIgYmVmb3JlVHJhbnNmb3JtID0gZGF0YXMuYmVmb3JlVHJhbnNmb3JtLFxuICAgICAgYWZ0ZXJUcmFuc2Zvcm0gPSBkYXRhcy5hZnRlclRyYW5zZm9ybTtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gIHZhciB0YXJnZXRUcmFuc2Zvcm0gPSBwYXJzZU1hdChbdHJhbnNmb3JtXSk7XG4gIHJldHVybiBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgY29udmVydERpbWVuc2lvbihtdWx0aXBseShtdWx0aXBseShiZWZvcmVUcmFuc2Zvcm0sIHRhcmdldFRyYW5zZm9ybSwgNCksIGFmdGVyVHJhbnNmb3JtLCA0KSwgNCwgbiksIHRyYW5zZm9ybU9yaWdpbiwgbik7XG59XG5mdW5jdGlvbiBzY2FsZU1hdHJpeChzdGF0ZSwgc2NhbGUpIHtcbiAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHN0YXRlLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgIG9mZnNldE1hdHJpeCA9IHN0YXRlLm9mZnNldE1hdHJpeCxcbiAgICAgIGlzM2QgPSBzdGF0ZS5pczNkLFxuICAgICAgdGFyZ2V0TWF0cml4ID0gc3RhdGUudGFyZ2V0TWF0cml4O1xuICB2YXIgbiA9IGlzM2QgPyA0IDogMztcbiAgcmV0dXJuIGdldE5leHRNYXRyaXgob2Zmc2V0TWF0cml4LCBtdWx0aXBseSh0YXJnZXRNYXRyaXgsIGNyZWF0ZVNjYWxlTWF0cml4KHNjYWxlLCBuKSwgbiksIHRyYW5zZm9ybU9yaWdpbiwgbik7XG59XG5mdW5jdGlvbiBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChlKSB7XG4gIHZhciBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLmJlZm9yZVJlbmRlcmFibGU7XG4gIHJldHVybiB7XG4gICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAodHJhbnNmb3JtLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luYWxEYXRhcy5zdGFydFRyYW5zZm9ybXMgPSBpc0FycmF5KHRyYW5zZm9ybSkgPyB0cmFuc2Zvcm0gOiBzcGxpdFNwYWNlKHRyYW5zZm9ybSk7XG4gICAgICBzZXRUcmFuc2Zvcm1JbmRleChlLCBpbmRleCk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2Zvcm1JbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBzZXRUcmFuc2Zvcm1JbmRleChlLCBpbmRleCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KGUsIHByb3BlcnR5KSB7XG4gIHZhciBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLmJlZm9yZVJlbmRlcmFibGU7XG4gIHZhciBzdGFydFRyYW5zZm9ybXMgPSBvcmlnaW5hbERhdGFzLnN0YXJ0VHJhbnNmb3JtcztcbiAgc2V0VHJhbnNmb3JtSW5kZXgoZSwgZmluZEluZGV4KHN0YXJ0VHJhbnNmb3JtcywgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYy5pbmRleE9mKHByb3BlcnR5ICsgXCIoXCIpID09PSAwO1xuICB9KSk7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm1JbmRleChlLCBpbmRleCkge1xuICB2YXIgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xuICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuICBkYXRhcy50cmFuc2Zvcm1JbmRleCA9IGluZGV4O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gb3JpZ2luYWxEYXRhcy5zdGFydFRyYW5zZm9ybXNbaW5kZXhdO1xuXG4gIGlmICghdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluZm8gPSBwYXJzZShbdHJhbnNmb3JtXSk7XG4gIGRhdGFzLnN0YXJ0VmFsdWUgPSBpbmZvWzBdLmZ1bmN0aW9uVmFsdWU7XG59XG5mdW5jdGlvbiBmaWxsT3JpZ2luYWxUcmFuc2Zvcm0oZSwgdHJhbnNmb3JtKSB7XG4gIHZhciBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLmJlZm9yZVJlbmRlcmFibGU7XG4gIG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybXMgPSBzcGxpdFNwYWNlKHRyYW5zZm9ybSk7XG59XG5mdW5jdGlvbiBnZXROZXh0VHJhbnNmb3JtVGV4dChlKSB7XG4gIHZhciBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLmJlZm9yZVJlbmRlcmFibGU7XG4gIHJldHVybiBvcmlnaW5hbERhdGFzLm5leHRUcmFuc2Zvcm1zLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gZmlsbFRyYW5zZm9ybUV2ZW50KG1vdmVhYmxlLCBuZXh0VHJhbnNmb3JtLCBkZWx0YSwgaXNQaW5jaCwgZSkge1xuICBmaWxsT3JpZ2luYWxUcmFuc2Zvcm0oZSwgbmV4dFRyYW5zZm9ybSk7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBuZXh0VHJhbnNmb3JtLFxuICAgIGRyYWc6IERyYWdnYWJsZS5kcmFnKG1vdmVhYmxlLCBzZXRDdXN0b21EcmFnKGUsIG1vdmVhYmxlLnN0YXRlLCBkZWx0YSwgaXNQaW5jaCwgZmFsc2UpKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlRGlzdChtb3ZlYWJsZSwgdHJhbnNmb3JtLCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpIHtcbiAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gIHZhciBsZWZ0ID0gc3RhdGUubGVmdCxcbiAgICAgIHRvcCA9IHN0YXRlLnRvcDtcbiAgdmFyIGdyb3VwYWJsZSA9IG1vdmVhYmxlLnByb3BzLmdyb3VwYWJsZTtcbiAgdmFyIG5leHRNYXRyaXggPSBnZXROZXh0VHJhbnNmb3JtTWF0cml4KG1vdmVhYmxlLnN0YXRlLCBkYXRhcywgdHJhbnNmb3JtKTtcbiAgdmFyIGdyb3VwTGVmdCA9IGdyb3VwYWJsZSA/IGxlZnQgOiAwO1xuICB2YXIgZ3JvdXBUb3AgPSBncm91cGFibGUgPyB0b3AgOiAwO1xuICB2YXIgbmV4dEZpeGVkUG9zaXRpb24gPSBnZXREaXJlY3Rpb25PZmZzZXQobW92ZWFibGUsIGZpeGVkRGlyZWN0aW9uLCBuZXh0TWF0cml4KTtcbiAgdmFyIGRpc3QgPSBtaW51cyhmaXhlZFBvc2l0aW9uLCBuZXh0Rml4ZWRQb3NpdGlvbik7XG4gIHJldHVybiBtaW51cyhkaXN0LCBbZ3JvdXBMZWZ0LCBncm91cFRvcF0pO1xufVxuZnVuY3Rpb24gZ2V0U2NhbGVEaXN0KG1vdmVhYmxlLCBzY2FsZURpc3QsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcykge1xuICByZXR1cm4gZ2V0VHJhbnNsYXRlRGlzdChtb3ZlYWJsZSwgXCJzY2FsZShcIiArIHNjYWxlRGlzdC5qb2luKFwiLCBcIikgKyBcIilcIiwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzKTtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbkRpcmVjdGlvbihtb3ZlYWJsZSkge1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfYS5oZWlnaHQsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBfYS50cmFuc2Zvcm1PcmlnaW47XG4gIHJldHVybiBbLTEgKyB0cmFuc2Zvcm1PcmlnaW5bMF0gLyAod2lkdGggLyAyKSwgLTEgKyB0cmFuc2Zvcm1PcmlnaW5bMV0gLyAoaGVpZ2h0IC8gMildO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uT2Zmc2V0KG1vdmVhYmxlLCBkaXJlY3Rpb24sIG5leHRNYXRyaXgpIHtcbiAgaWYgKG5leHRNYXRyaXggPT09IHZvaWQgMCkge1xuICAgIG5leHRNYXRyaXggPSBtb3ZlYWJsZS5zdGF0ZS5hbGxNYXRyaXg7XG4gIH1cblxuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfYS5oZWlnaHQsXG4gICAgICBpczNkID0gX2EuaXMzZDtcbiAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gIHZhciBuZXh0Rml4ZWRPZmZzZXQgPSBbd2lkdGggLyAyICogKDEgKyBkaXJlY3Rpb25bMF0pLCBoZWlnaHQgLyAyICogKDEgKyBkaXJlY3Rpb25bMV0pXTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVBvc2l0aW9uKG5leHRNYXRyaXgsIG5leHRGaXhlZE9mZnNldCwgbik7XG59XG5mdW5jdGlvbiBnZXRSb3RhdGVEaXN0KG1vdmVhYmxlLCByb3RhdGVEaXN0LCBmaXhlZFBvc2l0aW9uLCBkYXRhcykge1xuICB2YXIgZml4ZWREaXJlY3Rpb24gPSBnZXRPcmlnaW5EaXJlY3Rpb24obW92ZWFibGUpO1xuICByZXR1cm4gZ2V0VHJhbnNsYXRlRGlzdChtb3ZlYWJsZSwgXCJyb3RhdGUoXCIgKyByb3RhdGVEaXN0ICsgXCJkZWcpXCIsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcyk7XG59XG5mdW5jdGlvbiBnZXRSZXNpemVEaXN0KG1vdmVhYmxlLCB3aWR0aCwgaGVpZ2h0LCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gIHZhciBncm91cGFibGUgPSBtb3ZlYWJsZS5wcm9wcy5ncm91cGFibGU7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgcHJldk9yaWdpbiA9IF9hLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgIHRhcmdldE1hdHJpeCA9IF9hLnRhcmdldE1hdHJpeCxcbiAgICAgIG9mZnNldE1hdHJpeCA9IF9hLm9mZnNldE1hdHJpeCxcbiAgICAgIGlzM2QgPSBfYS5pczNkLFxuICAgICAgcHJldldpZHRoID0gX2Eud2lkdGgsXG4gICAgICBwcmV2SGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgbGVmdCA9IF9hLmxlZnQsXG4gICAgICB0b3AgPSBfYS50b3A7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICB2YXIgbmV4dE9yaWdpbiA9IGNhbGN1bGF0ZVRyYW5zZm9ybU9yaWdpbih0cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgcHJldk9yaWdpbik7XG4gIHZhciBncm91cExlZnQgPSBncm91cGFibGUgPyBsZWZ0IDogMDtcbiAgdmFyIGdyb3VwVG9wID0gZ3JvdXBhYmxlID8gdG9wIDogMDtcbiAgdmFyIG5leHRNYXRyaXggPSBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4LCBuZXh0T3JpZ2luLCBuKTtcbiAgdmFyIGRpc3QgPSBnZXREaXN0KGZpeGVkUG9zaXRpb24sIG5leHRNYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4sIGZpeGVkRGlyZWN0aW9uKTtcbiAgcmV0dXJuIG1pbnVzKGRpc3QsIFtncm91cExlZnQsIGdyb3VwVG9wXSk7XG59XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVBvc2l0aW9uKG1vdmVhYmxlLCBkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIGdldFBvc0J5RGlyZWN0aW9uKGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKSwgZGlyZWN0aW9uKTtcbn1cblxudmFyIFZFUlRJQ0FMX05BTUVTID0gW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCJdO1xudmFyIEhPUklaT05UQUxfTkFNRVMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJtaWRkbGVcIl07XG52YXIgVkVSVElDQUxfTkFNRVNfTUFQID0ge1xuICBzdGFydDogXCJsZWZ0XCIsXG4gIGVuZDogXCJyaWdodFwiLFxuICBjZW50ZXI6IFwiY2VudGVyXCJcbn07XG52YXIgSE9SSVpPTlRBTF9OQU1FU19NQVAgPSB7XG4gIHN0YXJ0OiBcInRvcFwiLFxuICBlbmQ6IFwiYm90dG9tXCIsXG4gIGNlbnRlcjogXCJtaWRkbGVcIlxufTtcbmZ1bmN0aW9uIGhhc0d1aWRlbGluZXMobW92ZWFibGUsIGFibGVOYW1lKSB7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgc25hcHBhYmxlID0gX2Euc25hcHBhYmxlLFxuICAgICAgYm91bmRzID0gX2EuYm91bmRzLFxuICAgICAgaW5uZXJCb3VuZHMgPSBfYS5pbm5lckJvdW5kcyxcbiAgICAgIHZlcnRpY2FsR3VpZGVsaW5lcyA9IF9hLnZlcnRpY2FsR3VpZGVsaW5lcyxcbiAgICAgIGhvcml6b250YWxHdWlkZWxpbmVzID0gX2EuaG9yaXpvbnRhbEd1aWRlbGluZXMsXG4gICAgICBzbmFwR3JpZFdpZHRoID0gX2Euc25hcEdyaWRXaWR0aCxcbiAgICAgIHNuYXBHcmlkSGVpZ2h0ID0gX2Euc25hcEdyaWRIZWlnaHQsXG4gICAgICBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgZ3VpZGVsaW5lcyA9IF9iLmd1aWRlbGluZXMsXG4gICAgICBlbmFibGVTbmFwID0gX2IuZW5hYmxlU25hcDtcblxuICBpZiAoIXNuYXBwYWJsZSB8fCAhZW5hYmxlU25hcCB8fCBhYmxlTmFtZSAmJiBzbmFwcGFibGUgIT09IHRydWUgJiYgc25hcHBhYmxlLmluZGV4T2YoYWJsZU5hbWUpIDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzbmFwR3JpZFdpZHRoIHx8IHNuYXBHcmlkSGVpZ2h0IHx8IGJvdW5kcyB8fCBpbm5lckJvdW5kcyB8fCBndWlkZWxpbmVzICYmIGd1aWRlbGluZXMubGVuZ3RoIHx8IHZlcnRpY2FsR3VpZGVsaW5lcyAmJiB2ZXJ0aWNhbEd1aWRlbGluZXMubGVuZ3RoIHx8IGhvcml6b250YWxHdWlkZWxpbmVzICYmIGhvcml6b250YWxHdWlkZWxpbmVzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U25hcERpcmVjdGlvbnMoc25hcERpcmVjdGlvbnMpIHtcbiAgaWYgKHNuYXBEaXJlY3Rpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiB7fTtcbiAgfSBlbHNlIGlmIChzbmFwRGlyZWN0aW9ucyA9PT0gdHJ1ZSB8fCAhc25hcERpcmVjdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgIHJpZ2h0OiB0cnVlLFxuICAgICAgdG9wOiB0cnVlLFxuICAgICAgYm90dG9tOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzbmFwRGlyZWN0aW9ucztcbn1cbmZ1bmN0aW9uIG1hcFNuYXBEaXJlY3Rpb25Qb3NlcyhzbmFwRGlyZWN0aW9ucywgc25hcFBvc2VzKSB7XG4gIHZhciBuZXh0U25hcERpcmVjdGlvbnMgPSBnZXRTbmFwRGlyZWN0aW9ucyhzbmFwRGlyZWN0aW9ucyk7XG4gIHZhciBuZXh0U25hcFBvc2VzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBuZXh0U25hcERpcmVjdGlvbnMpIHtcbiAgICBpZiAobmFtZSBpbiBzbmFwUG9zZXMgJiYgbmV4dFNuYXBEaXJlY3Rpb25zW25hbWVdKSB7XG4gICAgICBuZXh0U25hcFBvc2VzW25hbWVdID0gc25hcFBvc2VzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0U25hcFBvc2VzO1xufVxuZnVuY3Rpb24gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMoc25hcERpcmVjdGlvbnMsIHNuYXBQb3Nlcykge1xuICB2YXIgbmV4dFNuYXBQb3NlcyA9IG1hcFNuYXBEaXJlY3Rpb25Qb3NlcyhzbmFwRGlyZWN0aW9ucywgc25hcFBvc2VzKTtcbiAgdmFyIGhvcml6b250YWxOYW1lcyA9IEhPUklaT05UQUxfTkFNRVMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gbmV4dFNuYXBQb3NlcztcbiAgfSk7XG4gIHZhciB2ZXJ0aWNhbE5hbWVzID0gVkVSVElDQUxfTkFNRVMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gbmV4dFNuYXBQb3NlcztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5leHRTbmFwUG9zZXNbbmFtZV07XG4gICAgfSksXG4gICAgdmVydGljYWw6IHZlcnRpY2FsTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmV4dFNuYXBQb3Nlc1tuYW1lXTtcbiAgICB9KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0R2FwR3VpZGVsaW5lcyhtb3ZlYWJsZSwgdGFyZ2V0UmVjdCwgc25hcFRocmVzaG9sZCkge1xuICB2YXIgZWxlbWVudFJlY3RzID0gbW92ZWFibGUuc3RhdGUuZWxlbWVudFJlY3RzO1xuICB2YXIgZ2FwR3VpZGVsaW5lcyA9IFtdO1xuICBbW1widmVydGljYWxcIiwgVkVSVElDQUxfTkFNRVNfTUFQLCBIT1JJWk9OVEFMX05BTUVTX01BUF0sIFtcImhvcml6b250YWxcIiwgSE9SSVpPTlRBTF9OQU1FU19NQVAsIFZFUlRJQ0FMX05BTUVTX01BUF1dLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHR5cGUgPSBfYVswXSxcbiAgICAgICAgbWFpbk5hbWVzID0gX2FbMV0sXG4gICAgICAgIHNpZGVOYW1lcyA9IF9hWzJdO1xuICAgIHZhciB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLnN0YXJ0XTtcbiAgICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuZW5kXTtcbiAgICB2YXIgdGFyZ2V0Q2VudGVyID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuY2VudGVyXTtcbiAgICB2YXIgdGFyZ2V0U3RhcnQyID0gdGFyZ2V0UmVjdFtzaWRlTmFtZXMuc3RhcnRdO1xuICAgIHZhciB0YXJnZXRFbmQyID0gdGFyZ2V0UmVjdFtzaWRlTmFtZXMuZW5kXTsgLy8gZWxlbWVudCA6IG1vdmVhYmxlXG5cbiAgICBmdW5jdGlvbiBnZXREaXN0KGVsZW1lbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IGVsZW1lbnRSZWN0LnJlY3Q7XG5cbiAgICAgIGlmIChyZWN0W21haW5OYW1lcy5lbmRdIDwgdGFyZ2V0U3RhcnQgKyBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRTdGFydCAtIHJlY3RbbWFpbk5hbWVzLmVuZF07XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldEVuZCAtIHNuYXBUaHJlc2hvbGQgPCByZWN0W21haW5OYW1lcy5zdGFydF0pIHtcbiAgICAgICAgcmV0dXJuIHJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIHRhcmdldEVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dEVsZW1lbnRSZWN0cyA9IGVsZW1lbnRSZWN0cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IGVsZW1lbnRSZWN0LnJlY3Q7XG5cbiAgICAgIGlmIChyZWN0W3NpZGVOYW1lcy5zdGFydF0gPiB0YXJnZXRFbmQyIHx8IHJlY3Rbc2lkZU5hbWVzLmVuZF0gPCB0YXJnZXRTdGFydDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0RGlzdChlbGVtZW50UmVjdCkgPiAwO1xuICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBnZXREaXN0KGEpIC0gZ2V0RGlzdChiKTtcbiAgICB9KTtcbiAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgbmV4dEVsZW1lbnRSZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzbmFwUmVjdDEpIHtcbiAgICAgIG5leHRFbGVtZW50UmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc25hcFJlY3QyKSB7XG4gICAgICAgIGlmIChzbmFwUmVjdDEgPT09IHNuYXBSZWN0Mikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0MSA9IHNuYXBSZWN0MS5yZWN0O1xuICAgICAgICB2YXIgcmVjdDIgPSBzbmFwUmVjdDIucmVjdDtcbiAgICAgICAgdmFyIHJlY3QxU3RhcnQgPSByZWN0MVtzaWRlTmFtZXMuc3RhcnRdO1xuICAgICAgICB2YXIgcmVjdDFFbmQgPSByZWN0MVtzaWRlTmFtZXMuZW5kXTtcbiAgICAgICAgdmFyIHJlY3QyU3RhcnQgPSByZWN0MltzaWRlTmFtZXMuc3RhcnRdO1xuICAgICAgICB2YXIgcmVjdDJFbmQgPSByZWN0MltzaWRlTmFtZXMuZW5kXTtcblxuICAgICAgICBpZiAocmVjdDFTdGFydCA+IHJlY3QyRW5kIHx8IHJlY3QyU3RhcnQgPiByZWN0MUVuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3Vwcy5wdXNoKFtzbmFwUmVjdDEsIHNuYXBSZWN0Ml0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgc25hcFJlY3QxID0gX2FbMF0sXG4gICAgICAgICAgc25hcFJlY3QyID0gX2FbMV07XG4gICAgICB2YXIgcmVjdDEgPSBzbmFwUmVjdDEucmVjdDtcbiAgICAgIHZhciByZWN0MiA9IHNuYXBSZWN0Mi5yZWN0O1xuICAgICAgdmFyIHJlY3QxU3RhcnQgPSByZWN0MVttYWluTmFtZXMuc3RhcnRdO1xuICAgICAgdmFyIHJlY3QxRW5kID0gcmVjdDFbbWFpbk5hbWVzLmVuZF07XG4gICAgICB2YXIgcmVjdDJTdGFydCA9IHJlY3QyW21haW5OYW1lcy5zdGFydF07XG4gICAgICB2YXIgcmVjdDJFbmQgPSByZWN0MlttYWluTmFtZXMuZW5kXTtcbiAgICAgIHZhciBnYXAgPSAwO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB2YXIgaXNTdGFydCA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ2VudGVyID0gZmFsc2U7XG4gICAgICB2YXIgaXNFbmQgPSBmYWxzZTtcblxuICAgICAgaWYgKHJlY3QxRW5kIDw9IHRhcmdldFN0YXJ0ICYmIHRhcmdldEVuZCA8PSByZWN0MlN0YXJ0KSB7XG4gICAgICAgIC8vIChsKWVsZW1lbnQxKHIpIDogKGwpdGFyZ2V0KHIpIDogKGwpZWxlbWVudDIocilcbiAgICAgICAgaXNDZW50ZXIgPSB0cnVlO1xuICAgICAgICBnYXAgPSAocmVjdDJTdGFydCAtIHJlY3QxRW5kIC0gKHRhcmdldEVuZCAtIHRhcmdldFN0YXJ0KSkgLyAyO1xuICAgICAgICBwb3MgPSByZWN0MUVuZCArIGdhcCArICh0YXJnZXRFbmQgLSB0YXJnZXRTdGFydCkgLyAyO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhwb3MgLSB0YXJnZXRDZW50ZXIpID4gc25hcFRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWN0MUVuZCA8IHJlY3QyU3RhcnQgJiYgcmVjdDJFbmQgPCB0YXJnZXRTdGFydCArIHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgLy8gKGwpZWxlbWVudDEocikgOiAobCllbGVtZW50MihyKSA6IChsKXRhcmdldFxuICAgICAgICBpc1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgZ2FwID0gcmVjdDJTdGFydCAtIHJlY3QxRW5kO1xuICAgICAgICBwb3MgPSByZWN0MkVuZCArIGdhcDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMocG9zIC0gdGFyZ2V0U3RhcnQpID4gc25hcFRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWN0MUVuZCA8IHJlY3QyU3RhcnQgJiYgdGFyZ2V0RW5kIC0gc25hcFRocmVzaG9sZCA8IHJlY3QxU3RhcnQpIHtcbiAgICAgICAgLy8gdGFyZ2V0KHIpIDogKGwpZWxlbWVudDEocikgOiAobCllbGVtZW50MihyKVxuICAgICAgICBpc0VuZCA9IHRydWU7XG4gICAgICAgIGdhcCA9IHJlY3QyU3RhcnQgLSByZWN0MUVuZDtcbiAgICAgICAgcG9zID0gcmVjdDFTdGFydCAtIGdhcDtcblxuICAgICAgICBpZiAoTWF0aC5hYnMocG9zIC0gdGFyZ2V0RW5kKSA+IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBnYXBHdWlkZWxpbmVzLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwb3M6IHR5cGUgPT09IFwidmVydGljYWxcIiA/IFtwb3MsIDBdIDogWzAsIHBvc10sXG4gICAgICAgIGVsZW1lbnQ6IHNuYXBSZWN0Mi5lbGVtZW50LFxuICAgICAgICBzaXplOiAwLFxuICAgICAgICBjbGFzc05hbWU6IHNuYXBSZWN0Mi5jbGFzc05hbWUsXG4gICAgICAgIGlzU3RhcnQ6IGlzU3RhcnQsXG4gICAgICAgIGlzQ2VudGVyOiBpc0NlbnRlcixcbiAgICAgICAgaXNFbmQ6IGlzRW5kLFxuICAgICAgICBnYXA6IGdhcCxcbiAgICAgICAgaGlkZTogdHJ1ZSxcbiAgICAgICAgZ2FwUmVjdHM6IFtzbmFwUmVjdDEsIHNuYXBSZWN0Ml1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGdhcEd1aWRlbGluZXM7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0R3VpZGVsaW5lcyhob3Jpem9udGFsR3VpZGVsaW5lcywgdmVydGljYWxHdWlkZWxpbmVzLCB3aWR0aCwgaGVpZ2h0LCBjbGllbnRMZWZ0LCBjbGllbnRUb3AsIHNuYXBPZmZzZXQpIHtcbiAgaWYgKGNsaWVudExlZnQgPT09IHZvaWQgMCkge1xuICAgIGNsaWVudExlZnQgPSAwO1xuICB9XG5cbiAgaWYgKGNsaWVudFRvcCA9PT0gdm9pZCAwKSB7XG4gICAgY2xpZW50VG9wID0gMDtcbiAgfVxuXG4gIGlmIChzbmFwT2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICBzbmFwT2Zmc2V0ID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBndWlkZWxpbmVzID0gW107XG4gIHZhciBzbmFwT2Zmc2V0TGVmdCA9IHNuYXBPZmZzZXQubGVmdCxcbiAgICAgIHNuYXBPZmZzZXRUb3AgPSBzbmFwT2Zmc2V0LnRvcCxcbiAgICAgIHNuYXBPZmZzZXRCb3R0b20gPSBzbmFwT2Zmc2V0LmJvdHRvbSxcbiAgICAgIHNuYXBPZmZzZXRSaWdodCA9IHNuYXBPZmZzZXQucmlnaHQ7XG4gIHZhciBzbmFwV2lkdGggPSB3aWR0aCArIHNuYXBPZmZzZXRSaWdodCAtIHNuYXBPZmZzZXRMZWZ0O1xuICB2YXIgc25hcEhlaWdodCA9IGhlaWdodCArIHNuYXBPZmZzZXRCb3R0b20gLSBzbmFwT2Zmc2V0VG9wO1xuICBob3Jpem9udGFsR3VpZGVsaW5lcyAmJiBob3Jpem9udGFsR3VpZGVsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICBndWlkZWxpbmVzLnB1c2goe1xuICAgICAgdHlwZTogXCJob3Jpem9udGFsXCIsXG4gICAgICBwb3M6IFtzbmFwT2Zmc2V0TGVmdCwgdGhyb3R0bGUocG9zIC0gY2xpZW50VG9wICsgc25hcE9mZnNldFRvcCwgMC4xKV0sXG4gICAgICBzaXplOiBzbmFwV2lkdGhcbiAgICB9KTtcbiAgfSk7XG4gIHZlcnRpY2FsR3VpZGVsaW5lcyAmJiB2ZXJ0aWNhbEd1aWRlbGluZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgZ3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwidmVydGljYWxcIixcbiAgICAgIHBvczogW3Rocm90dGxlKHBvcyAtIGNsaWVudExlZnQgKyBzbmFwT2Zmc2V0TGVmdCwgMC4xKSwgc25hcE9mZnNldFRvcF0sXG4gICAgICBzaXplOiBzbmFwSGVpZ2h0XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZ3VpZGVsaW5lcztcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRhaW5lclBvcyhyb290TWF0cml4LCBjb250YWluZXJSZWN0LCBuKSB7XG4gIHZhciBjbGllbnRQb3MgPSBjYWxjdWxhdGVQb3NpdGlvbihyb290TWF0cml4LCBbY29udGFpbmVyUmVjdC5jbGllbnRMZWZ0LCBjb250YWluZXJSZWN0LmNsaWVudFRvcF0sIG4pO1xuICByZXR1cm4gW2NvbnRhaW5lclJlY3QubGVmdCArIGNsaWVudFBvc1swXSwgY29udGFpbmVyUmVjdC50b3AgKyBjbGllbnRQb3NbMV1dO1xufVxuZnVuY3Rpb24gZ2V0U25hcEVsZW1lbnRSZWN0cyhtb3ZlYWJsZSwgdmFsdWVzKSB7XG4gIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICB2YXIgY29udGFpbmVyQ2xpZW50UmVjdCA9IHN0YXRlLmNvbnRhaW5lckNsaWVudFJlY3QsXG4gICAgICBfYSA9IHN0YXRlLnRhcmdldENsaWVudFJlY3QsXG4gICAgICBjbGllbnRUb3AgPSBfYS50b3AsXG4gICAgICBjbGllbnRMZWZ0ID0gX2EubGVmdCxcbiAgICAgIHJvb3RNYXRyaXggPSBzdGF0ZS5yb290TWF0cml4LFxuICAgICAgaXMzZCA9IHN0YXRlLmlzM2Q7XG4gIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuXG4gIHZhciBfYiA9IGNhbGN1bGF0ZUNvbnRhaW5lclBvcyhyb290TWF0cml4LCBjb250YWluZXJDbGllbnRSZWN0LCBuKSxcbiAgICAgIGNvbnRhaW5lckxlZnQgPSBfYlswXSxcbiAgICAgIGNvbnRhaW5lclRvcCA9IF9iWzFdO1xuXG4gIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKHN0YXRlKTtcblxuICB2YXIgX2MgPSBnZXRNaW5NYXhzKHBvc2VzKSxcbiAgICAgIHRhcmdldExlZnQgPSBfYy5taW5YLFxuICAgICAgdGFyZ2V0VG9wID0gX2MubWluWTtcblxuICB2YXIgX2QgPSBtaW51cyhbdGFyZ2V0TGVmdCwgdGFyZ2V0VG9wXSwgY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtjbGllbnRMZWZ0IC0gY29udGFpbmVyTGVmdCwgY2xpZW50VG9wIC0gY29udGFpbmVyVG9wXSwgbikpLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHJvdW5kU2lnbihwb3MpO1xuICB9KSxcbiAgICAgIGRpc3RMZWZ0ID0gX2RbMF0sXG4gICAgICBkaXN0VG9wID0gX2RbMV07XG5cbiAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlY3QgPSB2YWx1ZS5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0IC0gY29udGFpbmVyTGVmdDtcbiAgICB2YXIgdG9wID0gcmVjdC50b3AgLSBjb250YWluZXJUb3A7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIHJlY3QuaGVpZ2h0O1xuICAgIHZhciByaWdodCA9IGxlZnQgKyByZWN0LndpZHRoO1xuXG4gICAgdmFyIF9hID0gY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtsZWZ0LCB0b3BdLCBuKSxcbiAgICAgICAgZWxlbWVudExlZnQgPSBfYVswXSxcbiAgICAgICAgZWxlbWVudFRvcCA9IF9hWzFdO1xuXG4gICAgdmFyIF9iID0gY2FsY3VsYXRlSW52ZXJzZVBvc2l0aW9uKHJvb3RNYXRyaXgsIFtyaWdodCwgYm90dG9tXSwgbiksXG4gICAgICAgIGVsZW1lbnRSaWdodCA9IF9iWzBdLFxuICAgICAgICBlbGVtZW50Qm90dG9tID0gX2JbMV07XG5cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHZhbHVlKSwge1xuICAgICAgcmVjdDoge1xuICAgICAgICBsZWZ0OiBlbGVtZW50TGVmdCArIGRpc3RMZWZ0LFxuICAgICAgICByaWdodDogZWxlbWVudFJpZ2h0ICsgZGlzdExlZnQsXG4gICAgICAgIHRvcDogZWxlbWVudFRvcCArIGRpc3RUb3AsXG4gICAgICAgIGJvdHRvbTogZWxlbWVudEJvdHRvbSArIGRpc3RUb3AsXG4gICAgICAgIGNlbnRlcjogKGVsZW1lbnRMZWZ0ICsgZWxlbWVudFJpZ2h0KSAvIDIgKyBkaXN0TGVmdCxcbiAgICAgICAgbWlkZGxlOiAoZWxlbWVudFRvcCArIGVsZW1lbnRCb3R0b20pIC8gMiArIGRpc3RUb3BcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50R3VpZGVsaW5lcyhtb3ZlYWJsZSkge1xuICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMuZWxlbWVudEd1aWRlbGluZXMsXG4gICAgICBlbGVtZW50R3VpZGVsaW5lcyA9IF9hID09PSB2b2lkIDAgPyBbXSA6IF9hO1xuXG4gIGlmICghZWxlbWVudEd1aWRlbGluZXMubGVuZ3RoKSB7XG4gICAgc3RhdGUuZWxlbWVudFJlY3RzID0gW107XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHByZXZWYWx1ZXMgPSAoc3RhdGUuZWxlbWVudFJlY3RzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKHNuYXBSZWN0KSB7XG4gICAgcmV0dXJuICFzbmFwUmVjdC5yZWZyZXNoO1xuICB9KTtcbiAgdmFyIG5leHRFbGVtZW50R3VpZGVsaW5lcyA9IGVsZW1lbnRHdWlkZWxpbmVzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoaXNPYmplY3QoZWwpICYmIFwiZWxlbWVudFwiIGluIGVsKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IGdldFJlZlRhcmdldChlbCwgdHJ1ZSlcbiAgICB9O1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmVsZW1lbnQ7XG4gIH0pO1xuXG4gIHZhciBfYiA9IGRpZmYocHJldlZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdi5lbGVtZW50O1xuICB9KSwgbmV4dEVsZW1lbnRHdWlkZWxpbmVzLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2LmVsZW1lbnQ7XG4gIH0pKSxcbiAgICAgIG1haW50YWluZWQgPSBfYi5tYWludGFpbmVkLFxuICAgICAgYWRkZWQgPSBfYi5hZGRlZDtcblxuICB2YXIgbmV4dFZhbHVlcyA9IFtdO1xuICBtYWludGFpbmVkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHByZXZJbmRleCA9IF9hWzBdLFxuICAgICAgICBuZXh0SW5kZXggPSBfYVsxXTtcbiAgICBuZXh0VmFsdWVzW25leHRJbmRleF0gPSBwcmV2VmFsdWVzW3ByZXZJbmRleF07XG4gIH0pO1xuICBnZXRTbmFwRWxlbWVudFJlY3RzKG1vdmVhYmxlLCBhZGRlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIG5leHRFbGVtZW50R3VpZGVsaW5lc1tpbmRleF07XG4gIH0pKS5tYXAoZnVuY3Rpb24gKHJlY3QsIGkpIHtcbiAgICBuZXh0VmFsdWVzW2FkZGVkW2ldXSA9IHJlY3Q7XG4gIH0pO1xuICBzdGF0ZS5lbGVtZW50UmVjdHMgPSBuZXh0VmFsdWVzO1xuICB2YXIgZWxlbWVudFNuYXBEaXJlY3Rpb25zID0gZ2V0U25hcERpcmVjdGlvbnMobW92ZWFibGUucHJvcHMuZWxlbWVudFNuYXBEaXJlY3Rpb25zKTtcbiAgdmFyIG5leHRHdWlkZWxpbmVzID0gW107XG4gIG5leHRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoc25hcFJlY3QpIHtcbiAgICB2YXIgZWxlbWVudCA9IHNuYXBSZWN0LmVsZW1lbnQsXG4gICAgICAgIF9hID0gc25hcFJlY3QudG9wLFxuICAgICAgICB0b3BWYWx1ZSA9IF9hID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMudG9wIDogX2EsXG4gICAgICAgIF9iID0gc25hcFJlY3QubGVmdCxcbiAgICAgICAgbGVmdFZhbHVlID0gX2IgPT09IHZvaWQgMCA/IGVsZW1lbnRTbmFwRGlyZWN0aW9ucy5sZWZ0IDogX2IsXG4gICAgICAgIF9jID0gc25hcFJlY3QucmlnaHQsXG4gICAgICAgIHJpZ2h0VmFsdWUgPSBfYyA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLnJpZ2h0IDogX2MsXG4gICAgICAgIF9kID0gc25hcFJlY3QuYm90dG9tLFxuICAgICAgICBib3R0b21WYWx1ZSA9IF9kID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMuYm90dG9tIDogX2QsXG4gICAgICAgIF9lID0gc25hcFJlY3QuY2VudGVyLFxuICAgICAgICBjZW50ZXJWYWx1ZSA9IF9lID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMuY2VudGVyIDogX2UsXG4gICAgICAgIF9mID0gc25hcFJlY3QubWlkZGxlLFxuICAgICAgICBtaWRkbGVWYWx1ZSA9IF9mID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMubWlkZGxlIDogX2YsXG4gICAgICAgIGNsYXNzTmFtZSA9IHNuYXBSZWN0LmNsYXNzTmFtZSxcbiAgICAgICAgcmVjdCA9IHNuYXBSZWN0LnJlY3Q7XG5cbiAgICB2YXIgX2cgPSBzcGxpdFNuYXBEaXJlY3Rpb25Qb3Nlcyh7XG4gICAgICB0b3A6IHRvcFZhbHVlLFxuICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUsXG4gICAgICBsZWZ0OiBsZWZ0VmFsdWUsXG4gICAgICBib3R0b206IGJvdHRvbVZhbHVlLFxuICAgICAgY2VudGVyOiBjZW50ZXJWYWx1ZSxcbiAgICAgIG1pZGRsZTogbWlkZGxlVmFsdWVcbiAgICB9LCByZWN0KSxcbiAgICAgICAgaG9yaXpvbnRhbCA9IF9nLmhvcml6b250YWwsXG4gICAgICAgIHZlcnRpY2FsID0gX2cudmVydGljYWw7XG5cbiAgICB2YXIgcmVjdFRvcCA9IHJlY3QudG9wO1xuICAgIHZhciByZWN0TGVmdCA9IHJlY3QubGVmdDtcbiAgICB2YXIgd2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdExlZnQ7XG4gICAgdmFyIGhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdFRvcDtcbiAgICB2YXIgc2l6ZXMgPSBbd2lkdGgsIGhlaWdodF07XG4gICAgdmVydGljYWwuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICBuZXh0R3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBwb3M6IFt0aHJvdHRsZShwb3MsIDAuMSksIHJlY3RUb3BdLFxuICAgICAgICBzaXplOiBoZWlnaHQsXG4gICAgICAgIHNpemVzOiBzaXplcyxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIGVsZW1lbnRSZWN0OiBzbmFwUmVjdFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaG9yaXpvbnRhbC5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIG5leHRHdWlkZWxpbmVzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImhvcml6b250YWxcIixcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgcG9zOiBbcmVjdExlZnQsIHRocm90dGxlKHBvcywgMC4xKV0sXG4gICAgICAgIHNpemU6IHdpZHRoLFxuICAgICAgICBzaXplczogc2l6ZXMsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBlbGVtZW50UmVjdDogc25hcFJlY3RcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG5leHRHdWlkZWxpbmVzO1xufVxuZnVuY3Rpb24gZ2V0VG90YWxHdWlkZWxpbmVzKG1vdmVhYmxlKSB7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgc25hcE9mZnNldCA9IF9hLnNuYXBPZmZzZXQsXG4gICAgICBfYiA9IF9hLmNvbnRhaW5lckNsaWVudFJlY3QsXG4gICAgICBvdmVyZmxvdyA9IF9iLm92ZXJmbG93LFxuICAgICAgY29udGFpbmVySGVpZ2h0ID0gX2Iuc2Nyb2xsSGVpZ2h0LFxuICAgICAgY29udGFpbmVyV2lkdGggPSBfYi5zY3JvbGxXaWR0aCxcbiAgICAgIGNvbnRhaW5lckNsaWVudEhlaWdodCA9IF9iLmNsaWVudEhlaWdodCxcbiAgICAgIGNvbnRhaW5lckNsaWVudFdpZHRoID0gX2IuY2xpZW50V2lkdGgsXG4gICAgICBjbGllbnRMZWZ0ID0gX2IuY2xpZW50TGVmdCxcbiAgICAgIGNsaWVudFRvcCA9IF9iLmNsaWVudFRvcDtcbiAgdmFyIF9jID0gbW92ZWFibGUucHJvcHMsXG4gICAgICBfZCA9IF9jLnNuYXBHYXAsXG4gICAgICBzbmFwR2FwID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCxcbiAgICAgIHZlcnRpY2FsR3VpZGVsaW5lcyA9IF9jLnZlcnRpY2FsR3VpZGVsaW5lcyxcbiAgICAgIGhvcml6b250YWxHdWlkZWxpbmVzID0gX2MuaG9yaXpvbnRhbEd1aWRlbGluZXMsXG4gICAgICBfZSA9IF9jLnNuYXBUaHJlc2hvbGQsXG4gICAgICBzbmFwVGhyZXNob2xkID0gX2UgPT09IHZvaWQgMCA/IDUgOiBfZSxcbiAgICAgIF9mID0gX2Muc25hcEdyaWRXaWR0aCxcbiAgICAgIHNuYXBHcmlkV2lkdGggPSBfZiA9PT0gdm9pZCAwID8gMCA6IF9mLFxuICAgICAgX2cgPSBfYy5zbmFwR3JpZEhlaWdodCxcbiAgICAgIHNuYXBHcmlkSGVpZ2h0ID0gX2cgPT09IHZvaWQgMCA/IDAgOiBfZztcbiAgdmFyIGVsZW1lbnRHdWlkZWxpbmVzID0gZ2V0RWxlbWVudEd1aWRlbGluZXMobW92ZWFibGUpO1xuXG4gIHZhciB0b3RhbEd1aWRlbGluZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBlbGVtZW50R3VpZGVsaW5lcyk7XG5cbiAgaWYgKHNuYXBHYXApIHtcbiAgICB2YXIgX2ggPSBnZXRSZWN0KGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKSksXG4gICAgICAgIHRvcCA9IF9oLnRvcCxcbiAgICAgICAgbGVmdCA9IF9oLmxlZnQsXG4gICAgICAgIGJvdHRvbSA9IF9oLmJvdHRvbSxcbiAgICAgICAgcmlnaHQgPSBfaC5yaWdodDtcblxuICAgIHRvdGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KHRvdGFsR3VpZGVsaW5lcywgZ2V0R2FwR3VpZGVsaW5lcyhtb3ZlYWJsZSwge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICByaWdodDogcmlnaHQsXG4gICAgICBjZW50ZXI6IChsZWZ0ICsgcmlnaHQpIC8gMixcbiAgICAgIG1pZGRsZTogKHRvcCArIGJvdHRvbSkgLyAyXG4gICAgfSwgc25hcFRocmVzaG9sZCkpO1xuICB9XG5cbiAgdG90YWxHdWlkZWxpbmVzLnB1c2guYXBwbHkodG90YWxHdWlkZWxpbmVzLCBnZXRHcmlkR3VpZGVsaW5lcyhzbmFwR3JpZFdpZHRoLCBzbmFwR3JpZEhlaWdodCwgb3ZlcmZsb3cgPyBjb250YWluZXJXaWR0aCA6IGNvbnRhaW5lckNsaWVudFdpZHRoLCBvdmVyZmxvdyA/IGNvbnRhaW5lckhlaWdodCA6IGNvbnRhaW5lckNsaWVudEhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wKSk7XG4gIHRvdGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KHRvdGFsR3VpZGVsaW5lcywgZ2V0RGVmYXVsdEd1aWRlbGluZXMoaG9yaXpvbnRhbEd1aWRlbGluZXMgfHwgZmFsc2UsIHZlcnRpY2FsR3VpZGVsaW5lcyB8fCBmYWxzZSwgb3ZlcmZsb3cgPyBjb250YWluZXJXaWR0aCA6IGNvbnRhaW5lckNsaWVudFdpZHRoLCBvdmVyZmxvdyA/IGNvbnRhaW5lckhlaWdodCA6IGNvbnRhaW5lckNsaWVudEhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0KSk7XG4gIHJldHVybiB0b3RhbEd1aWRlbGluZXM7XG59XG5mdW5jdGlvbiBnZXRHcmlkR3VpZGVsaW5lcyhzbmFwR3JpZFdpZHRoLCBzbmFwR3JpZEhlaWdodCwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wKSB7XG4gIGlmIChjbGllbnRMZWZ0ID09PSB2b2lkIDApIHtcbiAgICBjbGllbnRMZWZ0ID0gMDtcbiAgfVxuXG4gIGlmIChjbGllbnRUb3AgPT09IHZvaWQgMCkge1xuICAgIGNsaWVudFRvcCA9IDA7XG4gIH1cblxuICB2YXIgZ3VpZGVsaW5lcyA9IFtdO1xuXG4gIGlmIChzbmFwR3JpZEhlaWdodCkge1xuICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8PSBjb250YWluZXJIZWlnaHQ7IHBvcyArPSBzbmFwR3JpZEhlaWdodCkge1xuICAgICAgZ3VpZGVsaW5lcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIHBvczogWzAsIHRocm90dGxlKHBvcyAtIGNsaWVudFRvcCwgMC4xKV0sXG4gICAgICAgIHNpemU6IGNvbnRhaW5lcldpZHRoLFxuICAgICAgICBoaWRlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc25hcEdyaWRXaWR0aCkge1xuICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8PSBjb250YWluZXJXaWR0aDsgcG9zICs9IHNuYXBHcmlkV2lkdGgpIHtcbiAgICAgIGd1aWRlbGluZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidmVydGljYWxcIixcbiAgICAgICAgcG9zOiBbdGhyb3R0bGUocG9zIC0gY2xpZW50TGVmdCwgMC4xKSwgMF0sXG4gICAgICAgIHNpemU6IGNvbnRhaW5lckhlaWdodCxcbiAgICAgICAgaGlkZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGd1aWRlbGluZXM7XG59XG5cbmZ1bmN0aW9uIGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIHBvc2VzWCwgcG9zZXNZLCBjdXN0b21TbmFwVGhyZXNob2xkKSB7XG4gIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xuICB2YXIgc25hcFRocmVzaG9sZCA9IHNlbGVjdFZhbHVlKGN1c3RvbVNuYXBUaHJlc2hvbGQsIHByb3BzLnNuYXBUaHJlc2hvbGQsIDUpO1xuICByZXR1cm4gY2hlY2tTbmFwUG9zZXMobW92ZWFibGUuc3RhdGUuZ3VpZGVsaW5lcywgcG9zZXNYLCBwb3Nlc1ksIHNuYXBUaHJlc2hvbGQpO1xufVxuZnVuY3Rpb24gY2hlY2tTbmFwUG9zZXMoZ3VpZGVsaW5lcywgcG9zZXNYLCBwb3Nlc1ksIHNuYXBUaHJlc2hvbGQpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbDogY2hlY2tTbmFwKGd1aWRlbGluZXMsIFwidmVydGljYWxcIiwgcG9zZXNYLCBzbmFwVGhyZXNob2xkKSxcbiAgICBob3Jpem9udGFsOiBjaGVja1NuYXAoZ3VpZGVsaW5lcywgXCJob3Jpem9udGFsXCIsIHBvc2VzWSwgc25hcFRocmVzaG9sZClcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrU25hcEtlZXBSYXRpbyhtb3ZlYWJsZSwgc3RhcnRQb3MsIGVuZFBvcykge1xuICB2YXIgZW5kWCA9IGVuZFBvc1swXSxcbiAgICAgIGVuZFkgPSBlbmRQb3NbMV07XG4gIHZhciBzdGFydFggPSBzdGFydFBvc1swXSxcbiAgICAgIHN0YXJ0WSA9IHN0YXJ0UG9zWzFdO1xuXG4gIHZhciBfYSA9IG1pbnVzKGVuZFBvcywgc3RhcnRQb3MpLFxuICAgICAgZHggPSBfYVswXSxcbiAgICAgIGR5ID0gX2FbMV07XG5cbiAgdmFyIGlzQm90dG9tID0gZHkgPiAwO1xuICB2YXIgaXNSaWdodCA9IGR4ID4gMDtcbiAgZHggPSBnZXRUaW55RGlzdChkeCk7XG4gIGR5ID0gZ2V0VGlueURpc3QoZHkpO1xuICB2YXIgdmVydGljYWxJbmZvID0ge1xuICAgIGlzU25hcDogZmFsc2UsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHBvczogMFxuICB9O1xuICB2YXIgaG9yaXpvbnRhbEluZm8gPSB7XG4gICAgaXNTbmFwOiBmYWxzZSxcbiAgICBvZmZzZXQ6IDAsXG4gICAgcG9zOiAwXG4gIH07XG5cbiAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEluZm8sXG4gICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsSW5mb1xuICAgIH07XG4gIH1cblxuICB2YXIgX2IgPSBjaGVja01vdmVhYmxlU25hcFBvc2VzKG1vdmVhYmxlLCBkeCA/IFtlbmRYXSA6IFtdLCBkeSA/IFtlbmRZXSA6IFtdKSxcbiAgICAgIHZlcnRpY2FsU25hcEluZm8gPSBfYi52ZXJ0aWNhbCxcbiAgICAgIGhvcml6b250YWxTbmFwSW5mbyA9IF9iLmhvcml6b250YWw7XG5cbiAgdmVydGljYWxTbmFwSW5mby5wb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICByZXR1cm4gaXNSaWdodCA/IHBvcyA+PSBzdGFydFggOiBwb3MgPD0gc3RhcnRYO1xuICB9KTtcbiAgaG9yaXpvbnRhbFNuYXBJbmZvLnBvc0luZm9zLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcG9zID0gX2EucG9zO1xuICAgIHJldHVybiBpc0JvdHRvbSA/IHBvcyA+PSBzdGFydFkgOiBwb3MgPD0gc3RhcnRZO1xuICB9KTtcbiAgdmVydGljYWxTbmFwSW5mby5pc1NuYXAgPSB2ZXJ0aWNhbFNuYXBJbmZvLnBvc0luZm9zLmxlbmd0aCA+IDA7XG4gIGhvcml6b250YWxTbmFwSW5mby5pc1NuYXAgPSBob3Jpem9udGFsU25hcEluZm8ucG9zSW5mb3MubGVuZ3RoID4gMDtcblxuICB2YXIgX2MgPSBnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8odmVydGljYWxTbmFwSW5mbyksXG4gICAgICBpc1ZlcnRpY2FsU25hcCA9IF9jLmlzU25hcCxcbiAgICAgIHZlcnRpY2FsR3VpZGVsaW5lID0gX2MuZ3VpZGVsaW5lO1xuXG4gIHZhciBfZCA9IGdldE5lYXJlc3RTbmFwR3VpZGVsaW5lSW5mbyhob3Jpem9udGFsU25hcEluZm8pLFxuICAgICAgaXNIb3Jpem9udGFsU25hcCA9IF9kLmlzU25hcCxcbiAgICAgIGhvcml6b250YWxHdWlkZWxpbmUgPSBfZC5ndWlkZWxpbmU7XG5cbiAgdmFyIGhvcml6b250YWxQb3MgPSBpc0hvcml6b250YWxTbmFwID8gaG9yaXpvbnRhbEd1aWRlbGluZS5wb3NbMV0gOiAwO1xuICB2YXIgdmVydGljYWxQb3MgPSBpc1ZlcnRpY2FsU25hcCA/IHZlcnRpY2FsR3VpZGVsaW5lLnBvc1swXSA6IDA7XG5cbiAgaWYgKGR4ID09PSAwKSB7XG4gICAgaWYgKGlzSG9yaXpvbnRhbFNuYXApIHtcbiAgICAgIGhvcml6b250YWxJbmZvLmlzU25hcCA9IHRydWU7XG4gICAgICBob3Jpem9udGFsSW5mby5wb3MgPSBob3Jpem9udGFsR3VpZGVsaW5lLnBvc1sxXTtcbiAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSBob3Jpem9udGFsSW5mby5wb3M7XG4gICAgfVxuICB9IGVsc2UgaWYgKGR5ID09PSAwKSB7XG4gICAgaWYgKGlzVmVydGljYWxTbmFwKSB7XG4gICAgICB2ZXJ0aWNhbEluZm8uaXNTbmFwID0gdHJ1ZTtcbiAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSB2ZXJ0aWNhbFBvcztcbiAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0gdmVydGljYWxQb3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHkgLSB5MSA9IGEgKiAoeCAtIHgxKVxuICAgIHZhciBhID0gZHkgLyBkeDtcbiAgICB2YXIgYiA9IGVuZFBvc1sxXSAtIGEgKiBlbmRYO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIGlzU25hcCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzVmVydGljYWxTbmFwKSB7XG4gICAgICB4ID0gdmVydGljYWxQb3M7XG4gICAgICB5ID0gYSAqIHggKyBiO1xuICAgICAgaXNTbmFwID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbFNuYXApIHtcbiAgICAgIHkgPSBob3Jpem9udGFsUG9zO1xuICAgICAgeCA9ICh5IC0gYikgLyBhO1xuICAgICAgaXNTbmFwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNTbmFwKSB7XG4gICAgICB2ZXJ0aWNhbEluZm8uaXNTbmFwID0gdHJ1ZTtcbiAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSB4O1xuICAgICAgdmVydGljYWxJbmZvLm9mZnNldCA9IGVuZFggLSB4O1xuICAgICAgaG9yaXpvbnRhbEluZm8uaXNTbmFwID0gdHJ1ZTtcbiAgICAgIGhvcml6b250YWxJbmZvLnBvcyA9IHk7XG4gICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0geTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEluZm8sXG4gICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEluZm9cbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrU25hcHMobW92ZWFibGUsIHJlY3QsIGN1c3RvbVNuYXBUaHJlc2hvbGQpIHtcbiAgdmFyIHBvc2VzID0gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMobW92ZWFibGUucHJvcHMuc25hcERpcmVjdGlvbnMsIHJlY3QpO1xuICByZXR1cm4gY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgcG9zZXMudmVydGljYWwsIHBvc2VzLmhvcml6b250YWwsIGN1c3RvbVNuYXBUaHJlc2hvbGQpO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdFNuYXBHdWlkZWxpbmVJbmZvKHNuYXBJbmZvKSB7XG4gIHZhciBpc1NuYXAgPSBzbmFwSW5mby5pc1NuYXA7XG5cbiAgaWYgKCFpc1NuYXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNTbmFwOiBmYWxzZSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGRpc3Q6IC0xLFxuICAgICAgcG9zOiAwLFxuICAgICAgZ3VpZGVsaW5lOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwb3NJbmZvID0gc25hcEluZm8ucG9zSW5mb3NbMF07XG4gIHZhciBndWlkZWxpbmVJbmZvID0gcG9zSW5mby5ndWlkZWxpbmVJbmZvc1swXTtcbiAgdmFyIG9mZnNldCA9IGd1aWRlbGluZUluZm8ub2Zmc2V0O1xuICB2YXIgZGlzdCA9IGd1aWRlbGluZUluZm8uZGlzdDtcbiAgdmFyIGd1aWRlbGluZSA9IGd1aWRlbGluZUluZm8uZ3VpZGVsaW5lO1xuICByZXR1cm4ge1xuICAgIGlzU25hcDogaXNTbmFwLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGRpc3Q6IGRpc3QsXG4gICAgcG9zOiBwb3NJbmZvLnBvcyxcbiAgICBndWlkZWxpbmU6IGd1aWRlbGluZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXAoZ3VpZGVsaW5lcywgdGFyZ2V0VHlwZSwgdGFyZ2V0UG9zZXMsIHNuYXBUaHJlc2hvbGQpIHtcbiAgaWYgKCFndWlkZWxpbmVzIHx8ICFndWlkZWxpbmVzLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgaW5kZXg6IC0xLFxuICAgICAgcG9zSW5mb3M6IFtdXG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc1ZlcnRpY2FsID0gdGFyZ2V0VHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICB2YXIgcG9zVHlwZSA9IGlzVmVydGljYWwgPyAwIDogMTtcbiAgdmFyIHNuYXBQb3NJbmZvcyA9IHRhcmdldFBvc2VzLm1hcChmdW5jdGlvbiAodGFyZ2V0UG9zLCBpbmRleCkge1xuICAgIHZhciBndWlkZWxpbmVJbmZvcyA9IGd1aWRlbGluZXMubWFwKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgIHZhciBwb3MgPSBndWlkZWxpbmUucG9zO1xuICAgICAgdmFyIG9mZnNldCA9IHRhcmdldFBvcyAtIHBvc1twb3NUeXBlXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBkaXN0OiBNYXRoLmFicyhvZmZzZXQpLFxuICAgICAgICBndWlkZWxpbmU6IGd1aWRlbGluZVxuICAgICAgfTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgZ3VpZGVsaW5lID0gX2EuZ3VpZGVsaW5lLFxuICAgICAgICAgIGRpc3QgPSBfYS5kaXN0O1xuICAgICAgdmFyIHR5cGUgPSBndWlkZWxpbmUudHlwZTtcblxuICAgICAgaWYgKHR5cGUgIT09IHRhcmdldFR5cGUgfHwgZGlzdCA+IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5kaXN0IC0gYi5kaXN0O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwb3M6IHRhcmdldFBvcyxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGd1aWRlbGluZUluZm9zOiBndWlkZWxpbmVJbmZvc1xuICAgIH07XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoc25hcFBvc0luZm8pIHtcbiAgICByZXR1cm4gc25hcFBvc0luZm8uZ3VpZGVsaW5lSW5mb3MubGVuZ3RoID4gMDtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmd1aWRlbGluZUluZm9zWzBdLmRpc3QgLSBiLmd1aWRlbGluZUluZm9zWzBdLmRpc3Q7XG4gIH0pO1xuICB2YXIgaXNTbmFwID0gc25hcFBvc0luZm9zLmxlbmd0aCA+IDA7XG4gIHJldHVybiB7XG4gICAgaXNTbmFwOiBpc1NuYXAsXG4gICAgaW5kZXg6IGlzU25hcCA/IHNuYXBQb3NJbmZvc1swXS5pbmRleCA6IC0xLFxuICAgIHBvc0luZm9zOiBzbmFwUG9zSW5mb3NcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcEluZm9zQnlEaXJlY3Rpb24obW92ZWFibGUsIHBvc2VzLCBzbmFwRGlyZWN0aW9uKSB7XG4gIHZhciBuZXh0UG9zZXMgPSBbXTtcblxuICBpZiAoc25hcERpcmVjdGlvblswXSAmJiBzbmFwRGlyZWN0aW9uWzFdKSB7XG4gICAgbmV4dFBvc2VzID0gW3NuYXBEaXJlY3Rpb24sIFstc25hcERpcmVjdGlvblswXSwgc25hcERpcmVjdGlvblsxXV0sIFtzbmFwRGlyZWN0aW9uWzBdLCAtc25hcERpcmVjdGlvblsxXV1dLm1hcChmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIXNuYXBEaXJlY3Rpb25bMF0gJiYgIXNuYXBEaXJlY3Rpb25bMV0pIHtcbiAgICB2YXIgYWxpZ25Qb3NlcyA9IFtwb3Nlc1swXSwgcG9zZXNbMV0sIHBvc2VzWzNdLCBwb3Nlc1syXSwgcG9zZXNbMF1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIG5leHRQb3Nlcy5wdXNoKGFsaWduUG9zZXNbaV0pO1xuICAgICAgbmV4dFBvc2VzLnB1c2goWyhhbGlnblBvc2VzW2ldWzBdICsgYWxpZ25Qb3Nlc1tpICsgMV1bMF0pIC8gMiwgKGFsaWduUG9zZXNbaV1bMV0gKyBhbGlnblBvc2VzW2kgKyAxXVsxXSkgLyAyXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChtb3ZlYWJsZS5wcm9wcy5rZWVwUmF0aW8pIHtcbiAgICAgIG5leHRQb3NlcyA9IFtbLTEsIC0xXSwgWy0xLCAxXSwgWzEsIC0xXSwgWzEsIDFdLCBzbmFwRGlyZWN0aW9uXS5tYXAoZnVuY3Rpb24gKGRpcikge1xuICAgICAgICByZXR1cm4gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFBvc2VzID0gZ2V0UG9zZXNCeURpcmVjdGlvbihwb3Nlcywgc25hcERpcmVjdGlvbik7XG5cbiAgICAgIGlmIChuZXh0UG9zZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBuZXh0UG9zZXMucHVzaChbKG5leHRQb3Nlc1swXVswXSArIG5leHRQb3Nlc1sxXVswXSkgLyAyLCAobmV4dFBvc2VzWzBdWzFdICsgbmV4dFBvc2VzWzFdWzFdKSAvIDJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgbmV4dFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvc1swXTtcbiAgfSksIG5leHRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3NbMV07XG4gIH0pLCAxKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU25hcEJvdW5kUHJpb3JpdHkoYSwgYikge1xuICB2YXIgYURpc3QgPSBNYXRoLmFicyhhLm9mZnNldCk7XG4gIHZhciBiRGlzdCA9IE1hdGguYWJzKGIub2Zmc2V0KTtcblxuICBpZiAoYS5pc0JvdW5kICYmIGIuaXNCb3VuZCkge1xuICAgIHJldHVybiBiRGlzdCAtIGFEaXN0O1xuICB9IGVsc2UgaWYgKGEuaXNCb3VuZCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiLmlzQm91bmQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhLmlzU25hcCAmJiBiLmlzU25hcCkge1xuICAgIHJldHVybiBiRGlzdCAtIGFEaXN0O1xuICB9IGVsc2UgaWYgKGEuaXNTbmFwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIuaXNTbmFwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYURpc3QgPCBUSU5ZX05VTSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGJEaXN0IDwgVElOWV9OVU0pIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gYURpc3QgLSBiRGlzdDtcbn1cbmZ1bmN0aW9uIGdldE5lYXJPZmZzZXRJbmZvKG9mZnNldHMsIGluZGV4KSB7XG4gIHJldHVybiBvZmZzZXRzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhU2lnbiA9IGEuc2lnbltpbmRleF07XG4gICAgdmFyIGJTaWduID0gYi5zaWduW2luZGV4XTtcbiAgICB2YXIgYU9mZnNldCA9IGEub2Zmc2V0W2luZGV4XTtcbiAgICB2YXIgYk9mZnNldCA9IGIub2Zmc2V0W2luZGV4XTsgLy8gLTEgVGhlIHBvc2l0aW9ucyBvZiBhIGFuZCBiIGRvIG5vdCBjaGFuZ2UuXG4gICAgLy8gMSBUaGUgcG9zaXRpb25zIG9mIGEgYW5kIGIgYXJlIHJldmVyc2VkLlxuXG4gICAgaWYgKCFhU2lnbikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICghYlNpZ24pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hlY2tTbmFwQm91bmRQcmlvcml0eSh7XG4gICAgICBpc0JvdW5kOiBhLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IGEuaXNTbmFwLFxuICAgICAgb2Zmc2V0OiBhT2Zmc2V0XG4gICAgfSwge1xuICAgICAgaXNCb3VuZDogYi5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiBiLmlzU25hcCxcbiAgICAgIG9mZnNldDogYk9mZnNldFxuICAgIH0pO1xuICB9KVswXTtcbn1cbmZ1bmN0aW9uIGdldENoZWNrU25hcERpcmVjdGlvbnMoZGlyZWN0aW9uLCBrZWVwUmF0aW8pIHtcbiAgdmFyIGRpcmVjdGlvbnMgPSBbXTtcbiAgdmFyIGZpeGVkRGlyZWN0aW9uID0gWy1kaXJlY3Rpb25bMF0sIC1kaXJlY3Rpb25bMV1dO1xuXG4gIGlmIChkaXJlY3Rpb25bMF0gJiYgZGlyZWN0aW9uWzFdKSB7XG4gICAgZGlyZWN0aW9ucy5wdXNoKFtmaXhlZERpcmVjdGlvbiwgW2RpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV1dLCBbZml4ZWREaXJlY3Rpb24sIFstZGlyZWN0aW9uWzBdLCBkaXJlY3Rpb25bMV1dXSk7XG5cbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICAvLyBwYXNzIHR3byBkaXJlY3Rpb24gY29uZGl0aW9uXG4gICAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBkaXJlY3Rpb25dKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uWzBdKSB7XG4gICAgLy8gdmVydGNhbFxuICAgIGlmIChrZWVwUmF0aW8pIHtcbiAgICAgIGRpcmVjdGlvbnMucHVzaChbZml4ZWREaXJlY3Rpb24sIFtmaXhlZERpcmVjdGlvblswXSwgLTFdXSwgW2ZpeGVkRGlyZWN0aW9uLCBbZml4ZWREaXJlY3Rpb25bMF0sIDFdXSwgW2ZpeGVkRGlyZWN0aW9uLCBbZGlyZWN0aW9uWzBdLCAtMV1dLCBbZml4ZWREaXJlY3Rpb24sIGRpcmVjdGlvbl0sIFtmaXhlZERpcmVjdGlvbiwgW2RpcmVjdGlvblswXSwgMV1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlyZWN0aW9ucy5wdXNoKFtbZml4ZWREaXJlY3Rpb25bMF0sIC0xXSwgW2RpcmVjdGlvblswXSwgLTFdXSwgW1tmaXhlZERpcmVjdGlvblswXSwgMF0sIFtkaXJlY3Rpb25bMF0sIDBdXSwgW1tmaXhlZERpcmVjdGlvblswXSwgMV0sIFtkaXJlY3Rpb25bMF0sIDFdXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpcmVjdGlvblsxXSkge1xuICAgIC8vIGhvcml6b250YWxcbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBbLTEsIGZpeGVkRGlyZWN0aW9uWzFdXV0sIFtmaXhlZERpcmVjdGlvbiwgWzEsIGZpeGVkRGlyZWN0aW9uWzFdXV0sIFtmaXhlZERpcmVjdGlvbiwgWy0xLCBkaXJlY3Rpb25bMV1dXSwgW2ZpeGVkRGlyZWN0aW9uLCBbMSwgZGlyZWN0aW9uWzFdXV0sIFtmaXhlZERpcmVjdGlvbiwgZGlyZWN0aW9uXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdGlvbnMucHVzaChbWy0xLCBmaXhlZERpcmVjdGlvblsxXV0sIFstMSwgZGlyZWN0aW9uWzFdXV0sIFtbMCwgZml4ZWREaXJlY3Rpb25bMV1dLCBbMCwgZGlyZWN0aW9uWzFdXV0sIFtbMSwgZml4ZWREaXJlY3Rpb25bMV1dLCBbMSwgZGlyZWN0aW9uWzFdXV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBbMCwgMF0gdG8gYWxsIGRpcmVjdGlvblxuICAgIGRpcmVjdGlvbnMucHVzaChbZml4ZWREaXJlY3Rpb24sIFsxLCAwXV0sIFtmaXhlZERpcmVjdGlvbiwgWy0xLCAwXV0sIFtmaXhlZERpcmVjdGlvbiwgWzAsIC0xXV0sIFtmaXhlZERpcmVjdGlvbiwgWzAsIDFdXSwgW1sxLCAwXSwgWzEsIC0xXV0sIFtbMSwgMF0sIFsxLCAxXV0sIFtbMCwgMV0sIFsxLCAxXV0sIFtbMCwgMV0sIFstMSwgMV1dLCBbWy0xLCAwXSwgWy0xLCAtMV1dLCBbWy0xLCAwXSwgWy0xLCAxXV0sIFtbMCwgLTFdLCBbMSwgLTFdXSwgW1swLCAtMV0sIFstMSwgLTFdXSk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9ucztcbn1cblxuZnVuY3Rpb24gaXNTdGFydExpbmUoZG90LCBsaW5lKSB7XG4gIC8vIGwgICAgbyAgICAgPT4gdHJ1ZVxuICAvLyBvICAgIGwgICAgPT4gZmFsc2VcbiAgdmFyIGN4ID0gYXZlcmFnZShbbGluZVswXVswXSwgbGluZVsxXVswXV0pO1xuICB2YXIgY3kgPSBhdmVyYWdlKFtsaW5lWzBdWzFdLCBsaW5lWzFdWzFdXSk7XG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IGN4IDw9IGRvdFswXSxcbiAgICBob3Jpem9udGFsOiBjeSA8PSBkb3RbMV1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaGl0VGVzdExpbmUoZG90LCBfYSkge1xuICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgcG9zMiA9IF9hWzFdO1xuICB2YXIgZHggPSBwb3MyWzBdIC0gcG9zMVswXTtcbiAgdmFyIGR5ID0gcG9zMlsxXSAtIHBvczFbMV07XG5cbiAgaWYgKE1hdGguYWJzKGR4KSA8IFRJTllfTlVNKSB7XG4gICAgZHggPSAwO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGR5KSA8IFRJTllfTlVNKSB7XG4gICAgZHkgPSAwO1xuICB9XG5cbiAgdmFyIHRlc3QxO1xuICB2YXIgdGVzdDI7XG5cbiAgaWYgKCFkeCkge1xuICAgIHRlc3QxID0gcG9zMVswXTtcbiAgICB0ZXN0MiA9IGRvdFswXTtcbiAgfSBlbHNlIGlmICghZHkpIHtcbiAgICB0ZXN0MSA9IHBvczFbMV07XG4gICAgdGVzdDIgPSBkb3RbMV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBkeSAvIGR4OyAvLyB5ID0gYSAqICh4IC0gcG9zMSkgKyBwb3MxXG5cbiAgICB0ZXN0MSA9IGEgKiAoZG90WzBdIC0gcG9zMVswXSkgKyBwb3MxWzFdO1xuICAgIHRlc3QyID0gZG90WzFdO1xuICB9XG5cbiAgcmV0dXJuIHRlc3QxIC0gdGVzdDI7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZVN0YXJ0TGluZShkb3RzLCBsaW5lLCBlcnJvcikge1xuICBpZiAoZXJyb3IgPT09IHZvaWQgMCkge1xuICAgIGVycm9yID0gVElOWV9OVU07XG4gIH1cblxuICB2YXIgY2VudGVyU2lnbiA9IGhpdFRlc3RMaW5lKGRvdHNbMF0sIGxpbmUpIDw9IDA7XG4gIHJldHVybiBkb3RzLnNsaWNlKDEpLmV2ZXJ5KGZ1bmN0aW9uIChkb3QpIHtcbiAgICB2YXIgdmFsdWUgPSBoaXRUZXN0TGluZShkb3QsIGxpbmUpO1xuICAgIHZhciBzaWduID0gdmFsdWUgPD0gMDtcbiAgICByZXR1cm4gc2lnbiA9PT0gY2VudGVyU2lnbiB8fCBNYXRoLmFicyh2YWx1ZSkgPD0gZXJyb3I7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja0lubmVyQm91bmREb3QocG9zLCBzdGFydCwgZW5kLCBpc1N0YXJ0LCB0aHJlc2hvbGQpIHtcbiAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyZXNob2xkID0gMDtcbiAgfVxuXG4gIGlmIChpc1N0YXJ0ICYmIHN0YXJ0IC0gdGhyZXNob2xkIDw9IHBvcyB8fCAhaXNTdGFydCAmJiBwb3MgPD0gZW5kICsgdGhyZXNob2xkKSB7XG4gICAgLy8gZmFsc2UgNDAyIDU2NSA2MDIgPT4gMzcgKFswLCAzN10pXG4gICAgLy8gdHJ1ZSA0MDAgNTI0Ljk3MTI2MDM1NDAwMzYgNjAwID0+IDEyNCAoWzEyNCwgMF0pXG4gICAgLy8gdHJ1ZSA0MDAgNDEwIDYwMCA9PiAxMCAoWzEwLCAwXSlcbiAgICByZXR1cm4ge1xuICAgICAgaXNCb3VuZDogdHJ1ZSxcbiAgICAgIG9mZnNldDogaXNTdGFydCA/IHN0YXJ0IC0gcG9zIDogZW5kIC0gcG9zXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNCb3VuZDogZmFsc2UsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5uZXJCb3VuZChtb3ZlYWJsZSwgbGluZSwgY2VudGVyKSB7XG4gIHZhciBib3VuZHMgPSBtb3ZlYWJsZS5wcm9wcy5pbm5lckJvdW5kcztcblxuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiB7XG4gICAgICBpc0FsbEJvdW5kOiBmYWxzZSxcbiAgICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgICAgaXNWZXJ0aWNhbEJvdW5kOiBmYWxzZSxcbiAgICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBmYWxzZSxcbiAgICAgIG9mZnNldDogWzAsIDBdXG4gICAgfTtcbiAgfVxuXG4gIHZhciBsZWZ0ID0gYm91bmRzLmxlZnQsXG4gICAgICB0b3AgPSBib3VuZHMudG9wLFxuICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xuICB2YXIgbGVmdExpbmUgPSBbW2xlZnQsIHRvcF0sIFtsZWZ0LCB0b3AgKyBoZWlnaHRdXTtcbiAgdmFyIHRvcExpbmUgPSBbW2xlZnQsIHRvcF0sIFtsZWZ0ICsgd2lkdGgsIHRvcF1dO1xuICB2YXIgcmlnaHRMaW5lID0gW1tsZWZ0ICsgd2lkdGgsIHRvcF0sIFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF1dO1xuICB2YXIgYm90dG9tTGluZSA9IFtbbGVmdCwgdG9wICsgaGVpZ2h0XSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV07XG5cbiAgdmFyIF9hID0gaXNTdGFydExpbmUoY2VudGVyLCBsaW5lKSxcbiAgICAgIGlzSG9yaXpvbnRhbFN0YXJ0ID0gX2EuaG9yaXpvbnRhbCxcbiAgICAgIGlzVmVydGljYWxTdGFydCA9IF9hLnZlcnRpY2FsO1xuXG4gIGlmIChpc1NhbWVTdGFydExpbmUoW2NlbnRlciwgW2xlZnQsIHRvcF0sIFtsZWZ0ICsgd2lkdGgsIHRvcF0sIFtsZWZ0LCB0b3AgKyBoZWlnaHRdLCBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdXSwgbGluZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBbGxCb3VuZDogZmFsc2UsXG4gICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgIGlzVmVydGljYWxCb3VuZDogZmFsc2UsXG4gICAgICBpc0hvcml6b250YWxCb3VuZDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IFswLCAwXVxuICAgIH07XG4gIH0gLy8gdGVzdCB2ZXJ0aWNhbFxuXG5cbiAgdmFyIHRvcEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIHRvcExpbmUsIGlzVmVydGljYWxTdGFydCk7XG4gIHZhciBib3R0b21Cb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBib3R0b21MaW5lLCBpc1ZlcnRpY2FsU3RhcnQpOyAvLyB0ZXN0IGhvcml6b250YWxcblxuICB2YXIgbGVmdEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGxlZnRMaW5lLCBpc0hvcml6b250YWxTdGFydCk7XG4gIHZhciByaWdodEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIHJpZ2h0TGluZSwgaXNIb3Jpem9udGFsU3RhcnQpO1xuICB2YXIgaXNBbGxWZXJ0aWNhbEJvdW5kID0gdG9wQm91bmRJbmZvLmlzQm91bmQgJiYgYm90dG9tQm91bmRJbmZvLmlzQm91bmQ7XG4gIHZhciBpc1ZlcnRpY2FsQm91bmQgPSB0b3BCb3VuZEluZm8uaXNCb3VuZCB8fCBib3R0b21Cb3VuZEluZm8uaXNCb3VuZDtcbiAgdmFyIGlzQWxsSG9yaXpvbnRhbEJvdW5kID0gbGVmdEJvdW5kSW5mby5pc0JvdW5kICYmIHJpZ2h0Qm91bmRJbmZvLmlzQm91bmQ7XG4gIHZhciBpc0hvcml6b250YWxCb3VuZCA9IGxlZnRCb3VuZEluZm8uaXNCb3VuZCB8fCByaWdodEJvdW5kSW5mby5pc0JvdW5kO1xuICB2YXIgdmVydGljYWxPZmZzZXQgPSBtYXhPZmZzZXQodG9wQm91bmRJbmZvLm9mZnNldCwgYm90dG9tQm91bmRJbmZvLm9mZnNldCk7XG4gIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gbWF4T2Zmc2V0KGxlZnRCb3VuZEluZm8ub2Zmc2V0LCByaWdodEJvdW5kSW5mby5vZmZzZXQpO1xuICB2YXIgb2Zmc2V0ID0gWzAsIDBdO1xuICB2YXIgaXNCb3VuZCA9IGZhbHNlO1xuICB2YXIgaXNBbGxCb3VuZCA9IGZhbHNlO1xuXG4gIGlmIChNYXRoLmFicyhob3Jpem9udGFsT2Zmc2V0KSA8IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IFt2ZXJ0aWNhbE9mZnNldCwgMF07XG4gICAgaXNCb3VuZCA9IGlzVmVydGljYWxCb3VuZDtcbiAgICBpc0FsbEJvdW5kID0gaXNBbGxWZXJ0aWNhbEJvdW5kO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IFswLCBob3Jpem9udGFsT2Zmc2V0XTtcbiAgICBpc0JvdW5kID0gaXNIb3Jpem9udGFsQm91bmQ7XG4gICAgaXNBbGxCb3VuZCA9IGlzQWxsSG9yaXpvbnRhbEJvdW5kO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc0FsbEJvdW5kOiBpc0FsbEJvdW5kLFxuICAgIGlzVmVydGljYWxCb3VuZDogaXNWZXJ0aWNhbEJvdW5kLFxuICAgIGlzSG9yaXpvbnRhbEJvdW5kOiBpc0hvcml6b250YWxCb3VuZCxcbiAgICBpc0JvdW5kOiBpc0JvdW5kLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGJvdW5kTGluZSwgaXNTdGFydCwgdGhyZXNob2xkLCBpc1JlbmRlcikge1xuICB2YXIgZG90MSA9IGxpbmVbMF07XG4gIHZhciBkb3QyID0gbGluZVsxXTtcbiAgdmFyIGJvdW5kRG90MSA9IGJvdW5kTGluZVswXTtcbiAgdmFyIGJvdW5kRG90MiA9IGJvdW5kTGluZVsxXTtcbiAgdmFyIGR5MSA9IGdldFRpbnlEaXN0KGRvdDJbMV0gLSBkb3QxWzFdKTtcbiAgdmFyIGR4MSA9IGdldFRpbnlEaXN0KGRvdDJbMF0gLSBkb3QxWzBdKTtcbiAgdmFyIGR5MiA9IGdldFRpbnlEaXN0KGJvdW5kRG90MlsxXSAtIGJvdW5kRG90MVsxXSk7XG4gIHZhciBkeDIgPSBnZXRUaW55RGlzdChib3VuZERvdDJbMF0gLSBib3VuZERvdDFbMF0pOyAvLyBkeDIgb3IgZHkyIGlzIHplcm9cblxuICBpZiAoIWR4Mikge1xuICAgIC8vIHZlcnRpY2FsXG4gICAgaWYgKGlzUmVuZGVyICYmICFkeTEpIHtcbiAgICAgIC8vIDkwZGVnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZHgxKSB7XG4gICAgICAvLyBjb25zdCB5ID0gZHkxID8gZHkxIC8gZHgxICogKGJvdW5kRG90MVswXSAtIGRvdDFbMF0pICsgZG90MVsxXSA6IGRvdDFbMV07XG4gICAgICB2YXIgeSA9IGR5MSAvIGR4MSAqIChib3VuZERvdDFbMF0gLSBkb3QxWzBdKSArIGRvdDFbMV07IC8vIGJvdW5kRG90MVsxXSA8PSB5ICA8PSBib3VuZERvdDJbMV1cblxuICAgICAgcmV0dXJuIGNoZWNrSW5uZXJCb3VuZERvdCh5LCBib3VuZERvdDFbMV0sIGJvdW5kRG90MlsxXSwgaXNTdGFydCwgdGhyZXNob2xkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9mZnNldCA9IGJvdW5kRG90MVswXSAtIGRvdDFbMF07XG4gICAgICB2YXIgaXNCb3VuZCA9IE1hdGguYWJzKG9mZnNldCkgPD0gKHRocmVzaG9sZCB8fCAwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQm91bmQ6IGlzQm91bmQsXG4gICAgICAgIG9mZnNldDogaXNCb3VuZCA/IG9mZnNldCA6IDBcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFkeTIpIHtcbiAgICAvLyBob3Jpem9udGFsXG4gICAgaWYgKGlzUmVuZGVyICYmICFkeDEpIHtcbiAgICAgIC8vIDkwZGVnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZHkxKSB7XG4gICAgICAvLyB5ID0gYSAqICh4IC0geDEpICsgeTFcbiAgICAgIC8vIHggPSAoeSAtIHkxKSAvIGEgKyB4MVxuICAgICAgLy8gY29uc3QgYSA9IGR5MSAvIGR4MTtcbiAgICAgIC8vIGNvbnN0IHggPSBkeDEgPyAoYm91bmREb3QxWzFdIC0gZG90MVsxXSkgLyBhICsgZG90MVswXSA6IGRvdDFbMF07XG4gICAgICB2YXIgeCA9IChib3VuZERvdDFbMV0gLSBkb3QxWzFdKSAvIChkeTEgLyBkeDEpICsgZG90MVswXTsgLy8gYm91bmREb3QxWzBdIDw9IHggJiYgeCA8PSBib3VuZERvdDJbMF1cblxuICAgICAgcmV0dXJuIGNoZWNrSW5uZXJCb3VuZERvdCh4LCBib3VuZERvdDFbMF0sIGJvdW5kRG90MlswXSwgaXNTdGFydCwgdGhyZXNob2xkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9mZnNldCA9IGJvdW5kRG90MVsxXSAtIGRvdDFbMV07XG4gICAgICB2YXIgaXNCb3VuZCA9IE1hdGguYWJzKG9mZnNldCkgPD0gKHRocmVzaG9sZCB8fCAwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQm91bmQ6IGlzQm91bmQsXG4gICAgICAgIG9mZnNldDogaXNCb3VuZCA/IG9mZnNldCA6IDBcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZEluZm8obW92ZWFibGUsIGxpbmVzLCBjZW50ZXIsIGRhdGFzKSB7XG4gIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG11bHRpcGxlID0gX2FbMF0sXG4gICAgICAgIHBvczEgPSBfYVsxXSxcbiAgICAgICAgcG9zMiA9IF9hWzJdO1xuXG4gICAgdmFyIF9iID0gY2hlY2tJbm5lckJvdW5kKG1vdmVhYmxlLCBbcG9zMSwgcG9zMl0sIGNlbnRlciksXG4gICAgICAgIGlzQm91bmQgPSBfYi5pc0JvdW5kLFxuICAgICAgICBvZmZzZXQgPSBfYi5vZmZzZXQsXG4gICAgICAgIGlzVmVydGljYWxCb3VuZCA9IF9iLmlzVmVydGljYWxCb3VuZCxcbiAgICAgICAgaXNIb3Jpem9udGFsQm91bmQgPSBfYi5pc0hvcml6b250YWxCb3VuZDtcblxuICAgIHZhciBzaXplT2Zmc2V0ID0gZ2V0RHJhZ0Rpc3Qoe1xuICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgZGlzdFg6IG9mZnNldFswXSxcbiAgICAgIGRpc3RZOiBvZmZzZXRbMV1cbiAgICB9KS5tYXAoZnVuY3Rpb24gKHNpemUsIGkpIHtcbiAgICAgIHJldHVybiBzaXplICogKG11bHRpcGxlW2ldID8gMiAvIG11bHRpcGxlW2ldIDogMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ246IG11bHRpcGxlLFxuICAgICAgaXNCb3VuZDogaXNCb3VuZCxcbiAgICAgIGlzVmVydGljYWxCb3VuZDogaXNWZXJ0aWNhbEJvdW5kLFxuICAgICAgaXNIb3Jpem9udGFsQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxuICAgICAgaXNTbmFwOiBmYWxzZSxcbiAgICAgIG9mZnNldDogc2l6ZU9mZnNldFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZERyYWdJbmZvKG1vdmVhYmxlLCBwb3NlcywgZGF0YXMpIHtcbiAgdmFyIF9hO1xuXG4gIHZhciBsaW5lcyA9IGdldENoZWNrSW5uZXJCb3VuZExpbmVzKHBvc2VzLCBbMCwgMF0sIGZhbHNlKS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNpZ24gPSBfYVswXSxcbiAgICAgICAgcG9zMSA9IF9hWzFdLFxuICAgICAgICBwb3MyID0gX2FbMl07XG4gICAgcmV0dXJuIFtzaWduLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoZGlyKSAqIDI7XG4gICAgfSksIHBvczEsIHBvczJdO1xuICB9KTtcbiAgdmFyIGlubmVyQm91bmRJbmZvID0gZ2V0SW5uZXJCb3VuZEluZm8obW92ZWFibGUsIGxpbmVzLCBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgWzAsIDBdKSwgZGF0YXMpO1xuICB2YXIgd2lkdGhPZmZzZXRJbmZvID0gZ2V0TmVhck9mZnNldEluZm8oaW5uZXJCb3VuZEluZm8sIDApO1xuICB2YXIgaGVpZ2h0T2Zmc2V0SW5mbyA9IGdldE5lYXJPZmZzZXRJbmZvKGlubmVyQm91bmRJbmZvLCAxKTtcbiAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gMDtcbiAgdmFyIGhvcml6b250YWxPZmZzZXQgPSAwO1xuICB2YXIgaXNWZXJ0aWNhbEJvdW5kID0gd2lkdGhPZmZzZXRJbmZvLmlzVmVydGljYWxCb3VuZCB8fCBoZWlnaHRPZmZzZXRJbmZvLmlzVmVydGljYWxCb3VuZDtcbiAgdmFyIGlzSG9yaXpvbnRhbEJvdW5kID0gd2lkdGhPZmZzZXRJbmZvLmlzSG9yaXpvbnRhbEJvdW5kIHx8IGhlaWdodE9mZnNldEluZm8uaXNIb3Jpem9udGFsQm91bmQ7XG5cbiAgaWYgKGlzVmVydGljYWxCb3VuZCB8fCBpc0hvcml6b250YWxCb3VuZCkge1xuICAgIF9hID0gZ2V0SW52ZXJzZURyYWdEaXN0KHtcbiAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgIGRpc3RYOiAtd2lkdGhPZmZzZXRJbmZvLm9mZnNldFswXSxcbiAgICAgIGRpc3RZOiAtaGVpZ2h0T2Zmc2V0SW5mby5vZmZzZXRbMV1cbiAgICB9KSwgdmVydGljYWxPZmZzZXQgPSBfYVswXSwgaG9yaXpvbnRhbE9mZnNldCA9IF9hWzFdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaXNCb3VuZDogaXNWZXJ0aWNhbEJvdW5kLFxuICAgICAgb2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldFxuICAgIH0sXG4gICAgaG9yaXpvbnRhbDoge1xuICAgICAgaXNCb3VuZDogaXNIb3Jpem9udGFsQm91bmQsXG4gICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXRcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDaGVja1NuYXBMaW5lRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGtlZXBSYXRpbykge1xuICB2YXIgbGluZURpcmVjdGlvbnMgPSBbXTtcbiAgdmFyIHggPSBkaXJlY3Rpb25bMF07XG4gIHZhciB5ID0gZGlyZWN0aW9uWzFdO1xuXG4gIGlmICh4ICYmIHkpIHtcbiAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbMCwgeSAqIDJdLCBkaXJlY3Rpb24sIFsteCwgeV1dLCBbW3ggKiAyLCAwXSwgZGlyZWN0aW9uLCBbeCwgLXldXSk7XG4gIH0gZWxzZSBpZiAoeCkge1xuICAgIC8vIHZlcnRjYWxcbiAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbeCAqIDIsIDBdLCBbeCwgMV0sIFt4LCAtMV1dKTtcblxuICAgIGlmIChrZWVwUmF0aW8pIHtcbiAgICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1swLCAtMV0sIFt4LCAtMV0sIFsteCwgLTFdXSwgW1swLCAxXSwgW3gsIDFdLCBbLXgsIDFdXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHkpIHtcbiAgICAvLyBob3Jpem9udGFsXG4gICAgbGluZURpcmVjdGlvbnMucHVzaChbWzAsIHkgKiAyXSwgWzEsIHldLCBbLTEsIHldXSk7XG5cbiAgICBpZiAoa2VlcFJhdGlvKSB7XG4gICAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbLTEsIDBdLCBbLTEsIHldLCBbLTEsIC15XV0sIFtbMSwgMF0sIFsxLCB5XSwgWzEsIC15XV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBbMCwgMF0gdG8gYWxsIGRpcmVjdGlvblxuICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1stMSwgMF0sIFstMSwgLTFdLCBbLTEsIDFdXSwgW1sxLCAwXSwgWzEsIC0xXSwgWzEsIDFdXSwgW1swLCAtMV0sIFstMSwgLTFdLCBbMSwgLTFdXSwgW1swLCAxXSwgWy0xLCAxXSwgWzEsIDFdXSk7XG4gIH1cblxuICByZXR1cm4gbGluZURpcmVjdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRDaGVja0lubmVyQm91bmRMaW5lcyhwb3NlcywgZGlyZWN0aW9uLCBrZWVwUmF0aW8pIHtcbiAgcmV0dXJuIGdldENoZWNrU25hcExpbmVEaXJlY3Rpb25zKGRpcmVjdGlvbiwga2VlcFJhdGlvKS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNpZ24gPSBfYVswXSxcbiAgICAgICAgZGlyMSA9IF9hWzFdLFxuICAgICAgICBkaXIyID0gX2FbMl07XG4gICAgcmV0dXJuIFtzaWduLCBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZGlyMSksIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXIyKV07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0JvdW5kUm90YXRlKHJlbGF0aXZlUG9zZXMsIGJvdW5kRG90cywgY2VudGVyLCByYWQpIHtcbiAgdmFyIG5leHRQb3NlcyA9IHJhZCA/IHJlbGF0aXZlUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcm90YXRlKHBvcywgcmFkKTtcbiAgfSkgOiByZWxhdGl2ZVBvc2VzO1xuXG4gIHZhciBkb3RzID0gX19zcHJlYWRBcnJheShbY2VudGVyXSwgYm91bmREb3RzKTtcblxuICByZXR1cm4gW1tuZXh0UG9zZXNbMF0sIG5leHRQb3Nlc1sxXV0sIFtuZXh0UG9zZXNbMV0sIG5leHRQb3Nlc1szXV0sIFtuZXh0UG9zZXNbM10sIG5leHRQb3Nlc1syXV0sIFtuZXh0UG9zZXNbMl0sIG5leHRQb3Nlc1swXV1dLnNvbWUoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICByZXR1cm4gIWlzU2FtZVN0YXJ0TGluZShkb3RzLCBsaW5lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3RQb2ludExpbmUoX2EpIHtcbiAgLy8geCA9IDAsIHkgPSAwXG4gIC8vIGQgPSAoYXggKyBieSArIGMpIC8gcm9vdChhMiArIGIyKVxuICB2YXIgcG9zMSA9IF9hWzBdLFxuICAgICAgcG9zMiA9IF9hWzFdO1xuICB2YXIgZHggPSBwb3MyWzBdIC0gcG9zMVswXTtcbiAgdmFyIGR5ID0gcG9zMlsxXSAtIHBvczFbMV07XG5cbiAgaWYgKCFkeCkge1xuICAgIHJldHVybiBNYXRoLmFicyhwb3MxWzBdKTtcbiAgfVxuXG4gIGlmICghZHkpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMocG9zMVsxXSk7XG4gIH0gLy8geSAtIHkxID0gYSh4IC0geDEpXG4gIC8vIDAgPSBheCAteSArIC1hICogeDEgKyB5MVxuXG5cbiAgdmFyIGEgPSBkeSAvIGR4O1xuICByZXR1cm4gTWF0aC5hYnMoKC1hICogcG9zMVswXSArIHBvczFbMV0pIC8gTWF0aC5zcXJ0KE1hdGgucG93KGEsIDIpICsgMSkpO1xufVxuXG5mdW5jdGlvbiBzb2x2ZVJldmVyc2VMaW5lKF9hKSB7XG4gIHZhciBwb3MxID0gX2FbMF0sXG4gICAgICBwb3MyID0gX2FbMV07XG4gIHZhciBkeCA9IHBvczJbMF0gLSBwb3MxWzBdO1xuICB2YXIgZHkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcblxuICBpZiAoIWR4KSB7XG4gICAgcmV0dXJuIFtwb3MxWzBdLCAwXTtcbiAgfVxuXG4gIGlmICghZHkpIHtcbiAgICByZXR1cm4gWzAsIHBvczFbMV1dO1xuICB9XG5cbiAgdmFyIGEgPSBkeSAvIGR4OyAvLyB5IC0geTEgPSBhICh4ICAtIHgxKVxuICAvLyB5ID0gYXggLSBhICogeDEgKyB5MVxuXG4gIHZhciBiID0gLWEgKiBwb3MxWzBdICsgcG9zMVsxXTsgLy8geSA9IGF4ICsgYiA9IC0xL2EgeFxuICAvLyB4ID0gLWIgLyAoYSArIDEgLyBhKVxuICAvLyB5ID0gYiAvICgxICsgMSAvIGFeMilcblxuICByZXR1cm4gWy1iIC8gKGEgKyAxIC8gYSksIGIgLyAoYSAqIGEgKyAxKV07XG59XG5cbmZ1bmN0aW9uIGNoZWNrUm90YXRlSW5uZXJCb3VuZHMobW92ZWFibGUsIHByZXZQb3NlcywgbmV4dFBvc2VzLCBvcmlnaW4sIHJvdGF0aW9uKSB7XG4gIHZhciBib3VuZHMgPSBtb3ZlYWJsZS5wcm9wcy5pbm5lckJvdW5kcztcbiAgdmFyIHJhZCA9IHJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcblxuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZWZ0ID0gYm91bmRzLmxlZnQsXG4gICAgICB0b3AgPSBib3VuZHMudG9wLFxuICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgsXG4gICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xuICB2YXIgcmVsYXRpdmVMZWZ0ID0gbGVmdCAtIG9yaWdpblswXTtcbiAgdmFyIHJlbGF0aXZlUmlnaHQgPSBsZWZ0ICsgd2lkdGggLSBvcmlnaW5bMF07XG4gIHZhciByZWxhdGl2ZVRvcCA9IHRvcCAtIG9yaWdpblsxXTtcbiAgdmFyIHJlbGF0aXZlQm90dG9tID0gdG9wICsgaGVpZ2h0IC0gb3JpZ2luWzFdO1xuICB2YXIgZG90cyA9IFtbcmVsYXRpdmVMZWZ0LCByZWxhdGl2ZVRvcF0sIFtyZWxhdGl2ZVJpZ2h0LCByZWxhdGl2ZVRvcF0sIFtyZWxhdGl2ZUxlZnQsIHJlbGF0aXZlQm90dG9tXSwgW3JlbGF0aXZlUmlnaHQsIHJlbGF0aXZlQm90dG9tXV07XG4gIHZhciBjZW50ZXIgPSBnZXRQb3NCeURpcmVjdGlvbihuZXh0UG9zZXMsIFswLCAwXSk7XG5cbiAgaWYgKCFpc0JvdW5kUm90YXRlKG5leHRQb3NlcywgZG90cywgY2VudGVyLCAwKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGRvdEluZm9zID0gZG90cy5tYXAoZnVuY3Rpb24gKGRvdCkge1xuICAgIHJldHVybiBbZ2V0RGlzdFNpemUoZG90KSwgZ2V0UmFkKFswLCAwXSwgZG90KV07XG4gIH0pO1xuICBbW25leHRQb3Nlc1swXSwgbmV4dFBvc2VzWzFdXSwgW25leHRQb3Nlc1sxXSwgbmV4dFBvc2VzWzNdXSwgW25leHRQb3Nlc1szXSwgbmV4dFBvc2VzWzJdXSwgW25leHRQb3Nlc1syXSwgbmV4dFBvc2VzWzBdXV0uZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIHZhciBsaW5lUmFkID0gZ2V0UmFkKFswLCAwXSwgc29sdmVSZXZlcnNlTGluZShsaW5lKSk7XG4gICAgdmFyIGxpbmVEaXN0ID0gZ2V0RGlzdFBvaW50TGluZShsaW5lKTtcbiAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGRvdEluZm9zLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBkb3REaXN0ID0gX2FbMF07XG4gICAgICByZXR1cm4gZG90RGlzdCAmJiBsaW5lRGlzdCA8PSBkb3REaXN0O1xuICAgIH0pLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBkb3REaXN0ID0gX2FbMF0sXG4gICAgICAgICAgZG90UmFkID0gX2FbMV07XG4gICAgICB2YXIgZGlzdFJhZCA9IE1hdGguYWNvcyhkb3REaXN0ID8gbGluZURpc3QgLyBkb3REaXN0IDogMCk7XG4gICAgICB2YXIgbmV4dFJhZDEgPSBkb3RSYWQgKyBkaXN0UmFkO1xuICAgICAgdmFyIG5leHRSYWQyID0gZG90UmFkIC0gZGlzdFJhZDtcbiAgICAgIHJldHVybiBbcmFkICsgbmV4dFJhZDEgLSBsaW5lUmFkLCByYWQgKyBuZXh0UmFkMiAtIGxpbmVSYWRdO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICBwcmV2LnB1c2guYXBwbHkocHJldiwgY3VyKTtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIFtdKS5maWx0ZXIoZnVuY3Rpb24gKG5leHRSYWQpIHtcbiAgICAgIHJldHVybiAhaXNCb3VuZFJvdGF0ZShwcmV2UG9zZXMsIGRvdHMsIGNlbnRlciwgbmV4dFJhZCk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChuZXh0UmFkKSB7XG4gICAgICByZXR1cm4gdGhyb3R0bGUobmV4dFJhZCAqIDE4MCAvIE1hdGguUEksIFRJTllfTlVNKTtcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hlY2tJbm5lckJvdW5kUG9zZXMobW92ZWFibGUpIHtcbiAgdmFyIGlubmVyQm91bmRzID0gbW92ZWFibGUucHJvcHMuaW5uZXJCb3VuZHM7XG5cbiAgaWYgKCFpbm5lckJvdW5kcykge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNhbDogW10sXG4gICAgICBob3Jpem9udGFsOiBbXVxuICAgIH07XG4gIH1cblxuICB2YXIgX2EgPSBtb3ZlYWJsZS5nZXRSZWN0KCksXG4gICAgICBwb3MxID0gX2EucG9zMSxcbiAgICAgIHBvczIgPSBfYS5wb3MyLFxuICAgICAgcG9zMyA9IF9hLnBvczMsXG4gICAgICBwb3M0ID0gX2EucG9zNDtcblxuICB2YXIgcG9zZXMgPSBbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF07XG4gIHZhciBjZW50ZXIgPSBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgWzAsIDBdKTtcbiAgdmFyIGxlZnQgPSBpbm5lckJvdW5kcy5sZWZ0LFxuICAgICAgdG9wID0gaW5uZXJCb3VuZHMudG9wLFxuICAgICAgd2lkdGggPSBpbm5lckJvdW5kcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IGlubmVyQm91bmRzLmhlaWdodDtcbiAgdmFyIGxlZnRMaW5lID0gW1tsZWZ0LCB0b3BdLCBbbGVmdCwgdG9wICsgaGVpZ2h0XV07XG4gIHZhciB0b3BMaW5lID0gW1tsZWZ0LCB0b3BdLCBbbGVmdCArIHdpZHRoLCB0b3BdXTtcbiAgdmFyIHJpZ2h0TGluZSA9IFtbbGVmdCArIHdpZHRoLCB0b3BdLCBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdXTtcbiAgdmFyIGJvdHRvbUxpbmUgPSBbW2xlZnQsIHRvcCArIGhlaWdodF0sIFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF1dO1xuICB2YXIgbGluZXMgPSBbW3BvczEsIHBvczJdLCBbcG9zMiwgcG9zNF0sIFtwb3M0LCBwb3MzXSwgW3BvczMsIHBvczFdXTtcbiAgdmFyIGhvcml6b250YWxQb3NlcyA9IFtdO1xuICB2YXIgdmVydGljYWxQb3NlcyA9IFtdO1xuICB2YXIgYm91bmRNYXAgPSB7XG4gICAgdG9wOiBmYWxzZSxcbiAgICBib3R0b206IGZhbHNlLFxuICAgIGxlZnQ6IGZhbHNlLFxuICAgIHJpZ2h0OiBmYWxzZVxuICB9O1xuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgdmFyIF9hID0gaXNTdGFydExpbmUoY2VudGVyLCBsaW5lKSxcbiAgICAgICAgaXNIb3Jpem9udGFsU3RhcnQgPSBfYS5ob3Jpem9udGFsLFxuICAgICAgICBpc1ZlcnRpY2FsU3RhcnQgPSBfYS52ZXJ0aWNhbDsgLy8gdGVzdCB2ZXJ0aWNhbFxuXG5cbiAgICB2YXIgdG9wQm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgdG9wTGluZSwgaXNWZXJ0aWNhbFN0YXJ0LCAxLCB0cnVlKTtcbiAgICB2YXIgYm90dG9tQm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgYm90dG9tTGluZSwgaXNWZXJ0aWNhbFN0YXJ0LCAxLCB0cnVlKTsgLy8gdGVzdCBob3Jpem9udGFsXG5cbiAgICB2YXIgbGVmdEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGxlZnRMaW5lLCBpc0hvcml6b250YWxTdGFydCwgMSwgdHJ1ZSk7XG4gICAgdmFyIHJpZ2h0Qm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgcmlnaHRMaW5lLCBpc0hvcml6b250YWxTdGFydCwgMSwgdHJ1ZSk7XG5cbiAgICBpZiAodG9wQm91bmRJbmZvLmlzQm91bmQgJiYgIWJvdW5kTWFwLnRvcCkge1xuICAgICAgaG9yaXpvbnRhbFBvc2VzLnB1c2godG9wKTtcbiAgICAgIGJvdW5kTWFwLnRvcCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGJvdHRvbUJvdW5kSW5mby5pc0JvdW5kICYmICFib3VuZE1hcC5ib3R0b20pIHtcbiAgICAgIGhvcml6b250YWxQb3Nlcy5wdXNoKHRvcCArIGhlaWdodCk7XG4gICAgICBib3VuZE1hcC5ib3R0b20gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsZWZ0Qm91bmRJbmZvLmlzQm91bmQgJiYgIWJvdW5kTWFwLmxlZnQpIHtcbiAgICAgIHZlcnRpY2FsUG9zZXMucHVzaChsZWZ0KTtcbiAgICAgIGJvdW5kTWFwLmxlZnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyaWdodEJvdW5kSW5mby5pc0JvdW5kICYmICFib3VuZE1hcC5yaWdodCkge1xuICAgICAgdmVydGljYWxQb3Nlcy5wdXNoKGxlZnQgKyB3aWR0aCk7XG4gICAgICBib3VuZE1hcC5yaWdodCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiBob3Jpem9udGFsUG9zZXMsXG4gICAgdmVydGljYWw6IHZlcnRpY2FsUG9zZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZFBvc2VzKGJvdW5kcywgdmVydGljYWxQb3NlcywgaG9yaXpvbnRhbFBvc2VzKSB7XG4gIHZhciBfYSA9IGJvdW5kcyB8fCB7fSxcbiAgICAgIF9iID0gX2EucG9zaXRpb24sXG4gICAgICBwb3NpdGlvbiA9IF9iID09PSB2b2lkIDAgPyBcImNsaWVudFwiIDogX2IsXG4gICAgICBfYyA9IF9hLmxlZnQsXG4gICAgICBsZWZ0ID0gX2MgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9jLFxuICAgICAgX2QgPSBfYS50b3AsXG4gICAgICB0b3AgPSBfZCA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2QsXG4gICAgICBfZSA9IF9hLnJpZ2h0LFxuICAgICAgcmlnaHQgPSBfZSA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZSxcbiAgICAgIF9mID0gX2EuYm90dG9tLFxuICAgICAgYm90dG9tID0gX2YgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2Y7XG5cbiAgdmFyIG5leHRCb3VuZHMgPSB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgdG9wOiB0b3AsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGJvdHRvbTogYm90dG9tXG4gIH07XG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IGNoZWNrQm91bmRzKG5leHRCb3VuZHMsIHZlcnRpY2FsUG9zZXMsIHRydWUpLFxuICAgIGhvcml6b250YWw6IGNoZWNrQm91bmRzKG5leHRCb3VuZHMsIGhvcml6b250YWxQb3NlcywgZmFsc2UpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRCb3VuZHMobW92ZWFibGUsIGV4dGVybmFsQm91bmRzKSB7XG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgX2IgPSBfYS5jb250YWluZXJDbGllbnRSZWN0LFxuICAgICAgY29udGFpbmVySGVpZ2h0ID0gX2IuY2xpZW50SGVpZ2h0LFxuICAgICAgY29udGFpbmVyV2lkdGggPSBfYi5jbGllbnRXaWR0aCxcbiAgICAgIGNsaWVudExlZnQgPSBfYi5jbGllbnRMZWZ0LFxuICAgICAgY2xpZW50VG9wID0gX2IuY2xpZW50VG9wLFxuICAgICAgX2MgPSBfYS5zbmFwT2Zmc2V0LFxuICAgICAgc25hcE9mZnNldExlZnQgPSBfYy5sZWZ0LFxuICAgICAgc25hcE9mZnNldFRvcCA9IF9jLnRvcCxcbiAgICAgIHNuYXBPZmZzZXRSaWdodCA9IF9jLnJpZ2h0LFxuICAgICAgc25hcE9mZnNldEJvdHRvbSA9IF9jLmJvdHRvbTtcbiAgdmFyIGJvdW5kcyA9IGV4dGVybmFsQm91bmRzIHx8IG1vdmVhYmxlLnByb3BzLmJvdW5kcyB8fCB7fTtcbiAgdmFyIHBvc2l0aW9uID0gYm91bmRzLnBvc2l0aW9uIHx8IFwiY2xpZW50XCI7XG4gIHZhciBpc0NTUyA9IHBvc2l0aW9uID09PSBcImNzc1wiO1xuICB2YXIgX2QgPSBib3VuZHMubGVmdCxcbiAgICAgIGxlZnQgPSBfZCA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2QsXG4gICAgICBfZSA9IGJvdW5kcy50b3AsXG4gICAgICB0b3AgPSBfZSA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2U7XG4gIHZhciBfZiA9IGJvdW5kcy5yaWdodCxcbiAgICAgIHJpZ2h0ID0gX2YgPT09IHZvaWQgMCA/IGlzQ1NTID8gLUluZmluaXR5IDogSW5maW5pdHkgOiBfZixcbiAgICAgIF9nID0gYm91bmRzLmJvdHRvbSxcbiAgICAgIGJvdHRvbSA9IF9nID09PSB2b2lkIDAgPyBpc0NTUyA/IC1JbmZpbml0eSA6IEluZmluaXR5IDogX2c7XG5cbiAgaWYgKGlzQ1NTKSB7XG4gICAgcmlnaHQgPSBjb250YWluZXJXaWR0aCArIHNuYXBPZmZzZXRSaWdodCAtIHNuYXBPZmZzZXRMZWZ0IC0gcmlnaHQ7XG4gICAgYm90dG9tID0gY29udGFpbmVySGVpZ2h0ICsgc25hcE9mZnNldEJvdHRvbSAtIHNuYXBPZmZzZXRUb3AgLSBib3R0b207XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGxlZnQgKyBzbmFwT2Zmc2V0TGVmdCAtIGNsaWVudExlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0ICsgc25hcE9mZnNldExlZnQgLSBjbGllbnRMZWZ0LFxuICAgIHRvcDogdG9wICsgc25hcE9mZnNldFRvcCAtIGNsaWVudFRvcCxcbiAgICBib3R0b206IGJvdHRvbSArIHNuYXBPZmZzZXRUb3AgLSBjbGllbnRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrQm91bmRLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgdmFyIF9hID0gZ2V0Qm91bmRzKG1vdmVhYmxlKSxcbiAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgcmlnaHQgPSBfYS5yaWdodCxcbiAgICAgIGJvdHRvbSA9IF9hLmJvdHRvbTtcblxuICB2YXIgZW5kWCA9IGVuZFBvc1swXSxcbiAgICAgIGVuZFkgPSBlbmRQb3NbMV07XG5cbiAgdmFyIF9iID0gbWludXMoZW5kUG9zLCBzdGFydFBvcyksXG4gICAgICBkeCA9IF9iWzBdLFxuICAgICAgZHkgPSBfYlsxXTtcblxuICBpZiAoTWF0aC5hYnMoZHgpIDwgVElOWV9OVU0pIHtcbiAgICBkeCA9IDA7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoZHkpIDwgVElOWV9OVU0pIHtcbiAgICBkeSA9IDA7XG4gIH1cblxuICB2YXIgaXNCb3R0b20gPSBkeSA+IDA7XG4gIHZhciBpc1JpZ2h0ID0gZHggPiAwO1xuICB2YXIgdmVydGljYWxJbmZvID0ge1xuICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfTtcbiAgdmFyIGhvcml6b250YWxJbmZvID0ge1xuICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgIG9mZnNldDogMCxcbiAgICBwb3M6IDBcbiAgfTtcblxuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVydGljYWw6IHZlcnRpY2FsSW5mbyxcbiAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxJbmZvXG4gICAgfTtcbiAgfSBlbHNlIGlmIChkeCA9PT0gMCkge1xuICAgIGlmIChpc0JvdHRvbSkge1xuICAgICAgaWYgKGJvdHRvbSA8IGVuZFkpIHtcbiAgICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0gYm90dG9tO1xuICAgICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0gYm90dG9tO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9wID4gZW5kWSkge1xuICAgICAgICBob3Jpem9udGFsSW5mby5wb3MgPSB0b3A7XG4gICAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSB0b3A7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGR5ID09PSAwKSB7XG4gICAgaWYgKGlzUmlnaHQpIHtcbiAgICAgIGlmIChyaWdodCA8IGVuZFgpIHtcbiAgICAgICAgdmVydGljYWxJbmZvLnBvcyA9IHJpZ2h0O1xuICAgICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIHJpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGVmdCA+IGVuZFgpIHtcbiAgICAgICAgdmVydGljYWxJbmZvLnBvcyA9IGxlZnQ7XG4gICAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0gbGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8geSAtIHkxID0gYSAqICh4IC0geDEpXG4gICAgdmFyIGEgPSBkeSAvIGR4O1xuICAgIHZhciBiID0gZW5kUG9zWzFdIC0gYSAqIGVuZFg7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgaXNCb3VuZCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzUmlnaHQgJiYgcmlnaHQgPD0gZW5kWCkge1xuICAgICAgeSA9IGEgKiByaWdodCArIGI7XG4gICAgICB4ID0gcmlnaHQ7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFpc1JpZ2h0ICYmIGVuZFggPD0gbGVmdCkge1xuICAgICAgeSA9IGEgKiBsZWZ0ICsgYjtcbiAgICAgIHggPSBsZWZ0O1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQm91bmQpIHtcbiAgICAgIGlmICh5IDwgdG9wIHx8IHkgPiBib3R0b20pIHtcbiAgICAgICAgaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNCb3VuZCkge1xuICAgICAgaWYgKGlzQm90dG9tICYmIGJvdHRvbSA8PSBlbmRZKSB7XG4gICAgICAgIHkgPSBib3R0b207XG4gICAgICAgIHggPSAoeSAtIGIpIC8gYTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFpc0JvdHRvbSAmJiBlbmRZIDw9IHRvcCkge1xuICAgICAgICB5ID0gdG9wO1xuICAgICAgICB4ID0gKHkgLSBiKSAvIGE7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB2ZXJ0aWNhbEluZm8uaXNCb3VuZCA9IHRydWU7XG4gICAgICB2ZXJ0aWNhbEluZm8ucG9zID0geDtcbiAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0geDtcbiAgICAgIGhvcml6b250YWxJbmZvLmlzQm91bmQgPSB0cnVlO1xuICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0geTtcbiAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSB5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVydGljYWw6IHZlcnRpY2FsSW5mbyxcbiAgICBob3Jpem9udGFsOiBob3Jpem9udGFsSW5mb1xuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyhib3VuZHMsIHBvc2VzLCBpc1ZlcnRpY2FsKSB7XG4gIC8vIDAgICBbMTAwIC0gMjAwXSAgMzAwXG4gIHZhciBzdGFydEJvdW5kUG9zID0gYm91bmRzW2lzVmVydGljYWwgPyBcImxlZnRcIiA6IFwidG9wXCJdO1xuICB2YXIgZW5kQm91bmRQb3MgPSBib3VuZHNbaXNWZXJ0aWNhbCA/IFwicmlnaHRcIiA6IFwiYm90dG9tXCJdOyAvLyA0NTBcblxuICB2YXIgbWluUG9zID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgcG9zZXMpO1xuICB2YXIgbWF4UG9zID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcG9zZXMpO1xuICB2YXIgYm91bmRJbmZvcyA9IFtdO1xuXG4gIGlmIChzdGFydEJvdW5kUG9zICsgMSA+IG1pblBvcykge1xuICAgIGJvdW5kSW5mb3MucHVzaCh7XG4gICAgICBpc0JvdW5kOiB0cnVlLFxuICAgICAgb2Zmc2V0OiBtaW5Qb3MgLSBzdGFydEJvdW5kUG9zLFxuICAgICAgcG9zOiBzdGFydEJvdW5kUG9zXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZW5kQm91bmRQb3MgLSAxIDwgbWF4UG9zKSB7XG4gICAgYm91bmRJbmZvcy5wdXNoKHtcbiAgICAgIGlzQm91bmQ6IHRydWUsXG4gICAgICBvZmZzZXQ6IG1heFBvcyAtIGVuZEJvdW5kUG9zLFxuICAgICAgcG9zOiBlbmRCb3VuZFBvc1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFib3VuZEluZm9zLmxlbmd0aCkge1xuICAgIGJvdW5kSW5mb3MucHVzaCh7XG4gICAgICBpc0JvdW5kOiBmYWxzZSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHBvczogMFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kSW5mb3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhiLm9mZnNldCkgLSBNYXRoLmFicyhhLm9mZnNldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0JvdW5kUm90YXRlJDEocmVsYXRpdmVQb3NlcywgYm91bmRSZWN0LCByYWQpIHtcbiAgdmFyIG5leHRQb3NlcyA9IHJhZCA/IHJlbGF0aXZlUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcm90YXRlKHBvcywgcmFkKTtcbiAgfSkgOiByZWxhdGl2ZVBvc2VzO1xuICByZXR1cm4gbmV4dFBvc2VzLnNvbWUoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3NbMF0gPCBib3VuZFJlY3QubGVmdCAmJiBNYXRoLmFicyhwb3NbMF0gLSBib3VuZFJlY3QubGVmdCkgPiAwLjEgfHwgcG9zWzBdID4gYm91bmRSZWN0LnJpZ2h0ICYmIE1hdGguYWJzKHBvc1swXSAtIGJvdW5kUmVjdC5yaWdodCkgPiAwLjEgfHwgcG9zWzFdIDwgYm91bmRSZWN0LnRvcCAmJiBNYXRoLmFicyhwb3NbMV0gLSBib3VuZFJlY3QudG9wKSA+IDAuMSB8fCBwb3NbMV0gPiBib3VuZFJlY3QuYm90dG9tICYmIE1hdGguYWJzKHBvc1sxXSAtIGJvdW5kUmVjdC5ib3R0b20pID4gMC4xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGJvdW5kUm90YXRlKHZlYywgYm91bmRQb3MsIGluZGV4KSB7XG4gIHZhciByID0gZ2V0RGlzdFNpemUodmVjKTtcbiAgdmFyIG5leHRQb3MgPSBNYXRoLnNxcnQociAqIHIgLSBib3VuZFBvcyAqIGJvdW5kUG9zKSB8fCAwO1xuICByZXR1cm4gW25leHRQb3MsIC1uZXh0UG9zXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSB2ZWNbaW5kZXggPyAwIDogMV0pIC0gTWF0aC5hYnMoYiAtIHZlY1tpbmRleCA/IDAgOiAxXSk7XG4gIH0pLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIGdldFJhZChbMCwgMF0sIGluZGV4ID8gW3BvcywgYm91bmRQb3NdIDogW2JvdW5kUG9zLCBwb3NdKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1JvdGF0ZUJvdW5kcyhtb3ZlYWJsZSwgcHJldlBvc2VzLCBuZXh0UG9zZXMsIG9yaWdpbiwgcm90YXRpb24pIHtcbiAgaWYgKCFtb3ZlYWJsZS5wcm9wcy5ib3VuZHMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgcmFkID0gcm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuXG4gIHZhciBfYSA9IGdldEJvdW5kcyhtb3ZlYWJsZSksXG4gICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgIHJpZ2h0ID0gX2EucmlnaHQsXG4gICAgICBib3R0b20gPSBfYS5ib3R0b207XG5cbiAgdmFyIHJlbGF0aXZlTGVmdCA9IGxlZnQgLSBvcmlnaW5bMF07XG4gIHZhciByZWxhdGl2ZVJpZ2h0ID0gcmlnaHQgLSBvcmlnaW5bMF07XG4gIHZhciByZWxhdGl2ZVRvcCA9IHRvcCAtIG9yaWdpblsxXTtcbiAgdmFyIHJlbGF0aXZlQm90dG9tID0gYm90dG9tIC0gb3JpZ2luWzFdO1xuICB2YXIgYm91bmRSZWN0ID0ge1xuICAgIGxlZnQ6IHJlbGF0aXZlTGVmdCxcbiAgICB0b3A6IHJlbGF0aXZlVG9wLFxuICAgIHJpZ2h0OiByZWxhdGl2ZVJpZ2h0LFxuICAgIGJvdHRvbTogcmVsYXRpdmVCb3R0b21cbiAgfTtcblxuICBpZiAoIWlzQm91bmRSb3RhdGUkMShuZXh0UG9zZXMsIGJvdW5kUmVjdCwgMCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIFtbcmVsYXRpdmVMZWZ0LCAwXSwgW3JlbGF0aXZlUmlnaHQsIDBdLCBbcmVsYXRpdmVUb3AsIDFdLCBbcmVsYXRpdmVCb3R0b20sIDFdXS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBib3VuZFBvcyA9IF9hWzBdLFxuICAgICAgICBpbmRleCA9IF9hWzFdO1xuICAgIG5leHRQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXh0UG9zKSB7XG4gICAgICB2YXIgcmVsYXRpdmVSYWQxID0gZ2V0UmFkKFswLCAwXSwgbmV4dFBvcyk7XG4gICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGJvdW5kUm90YXRlKG5leHRQb3MsIGJvdW5kUG9zLCBpbmRleCkubWFwKGZ1bmN0aW9uIChyZWxhdGl2ZVJhZDIpIHtcbiAgICAgICAgcmV0dXJuIHJhZCArIHJlbGF0aXZlUmFkMiAtIHJlbGF0aXZlUmFkMTtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAobmV4dFJhZCkge1xuICAgICAgICByZXR1cm4gIWlzQm91bmRSb3RhdGUkMShwcmV2UG9zZXMsIGJvdW5kUmVjdCwgbmV4dFJhZCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKG5leHRSYWQpIHtcbiAgICAgICAgcmV0dXJuIHRocm90dGxlKG5leHRSYWQgKiAxODAgLyBNYXRoLlBJLCBUSU5ZX05VTSk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZW5kZXJHdWlkZWxpbmUoaW5mbywgUmVhY3QpIHtcbiAgdmFyIF9hO1xuXG4gIHZhciBkaXJlY3Rpb24gPSBpbmZvLmRpcmVjdGlvbixcbiAgICAgIGNsYXNzTmFtZXMgPSBpbmZvLmNsYXNzTmFtZXMsXG4gICAgICBzaXplID0gaW5mby5zaXplLFxuICAgICAgcG9zID0gaW5mby5wb3MsXG4gICAgICB6b29tID0gaW5mby56b29tLFxuICAgICAga2V5ID0gaW5mby5rZXk7XG4gIHZhciBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICB2YXIgc2NhbGVUeXBlID0gaXNIb3Jpem9udGFsID8gXCJZXCIgOiBcIlhcIjsgLy8gY29uc3Qgc2NhbGVUeXBlMiA9IGlzSG9yaXpvbnRhbCA/IFwiWVwiIDogXCJYXCI7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleToga2V5LFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKFwiIFwiKSxcbiAgICBzdHlsZTogKF9hID0ge30sIF9hW2lzSG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID0gXCJcIiArIHNpemUsIF9hLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgcG9zWzBdICsgXCIsIFwiICsgcG9zWzFdICsgXCIpIHRyYW5zbGF0ZVwiICsgc2NhbGVUeXBlICsgXCIoLTUwJSkgc2NhbGVcIiArIHNjYWxlVHlwZSArIFwiKFwiICsgem9vbSArIFwiKVwiLCBfYSlcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckd1aWRlbGluZShpbmZvLCBSZWFjdCkge1xuICByZXR1cm4gcmVuZGVyR3VpZGVsaW5lKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbmZvKSwge1xuICAgIGNsYXNzTmFtZXM6IF9fc3ByZWFkQXJyYXkoW3ByZWZpeChcImxpbmVcIiwgXCJndWlkZWxpbmVcIiwgaW5mby5kaXJlY3Rpb24pXSwgaW5mby5jbGFzc05hbWVzKS5maWx0ZXIoZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICB9KSxcbiAgICBzaXplOiBpbmZvLnNpemUgfHwgaW5mby5zaXplVmFsdWUgKyBcInB4XCIsXG4gICAgcG9zOiBpbmZvLnBvcyB8fCBpbmZvLnBvc1ZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHRocm90dGxlKHYsIDAuMSkgKyBcInB4XCI7XG4gICAgfSlcbiAgfSksIFJlYWN0KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclNuYXBQb3Nlcyhtb3ZlYWJsZSwgZGlyZWN0aW9uLCBzbmFwUG9zZXMsIG1pblBvcywgdGFyZ2V0UG9zLCBzaXplLCBpbmRleCwgUmVhY3QpIHtcbiAgdmFyIHpvb20gPSBtb3ZlYWJsZS5wcm9wcy56b29tO1xuICByZXR1cm4gc25hcFBvc2VzLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGUsXG4gICAgICAgIHBvcyA9IF9hLnBvcztcbiAgICB2YXIgcmVuZGVyUG9zID0gWzAsIDBdO1xuICAgIHJlbmRlclBvc1tpbmRleF0gPSBtaW5Qb3M7XG4gICAgcmVuZGVyUG9zW2luZGV4ID8gMCA6IDFdID0gLXRhcmdldFBvcyArIHBvcztcbiAgICByZXR1cm4gcmVuZGVySW5uZXJHdWlkZWxpbmUoe1xuICAgICAga2V5OiBkaXJlY3Rpb24gKyBcIlRhcmdldEd1aWRlbGluZVwiICsgaSxcbiAgICAgIGNsYXNzTmFtZXM6IFtwcmVmaXgoXCJ0YXJnZXRcIiwgXCJib2xkXCIsIHR5cGUpXSxcbiAgICAgIHBvc1ZhbHVlOiByZW5kZXJQb3MsXG4gICAgICBzaXplVmFsdWU6IHNpemUsXG4gICAgICB6b29tOiB6b29tLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9LCBSZWFjdCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVuZGVyR3VpZGVsaW5lcyhtb3ZlYWJsZSwgdHlwZSwgZ3VpZGVsaW5lcywgdGFyZ2V0UG9zLCB0YXJnZXRSZWN0LCBSZWFjdCkge1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgIHpvb20gPSBfYS56b29tLFxuICAgICAgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQgPSBfYS5pc0Rpc3BsYXlJbm5lclNuYXBEaWdpdDtcbiAgdmFyIG1haW5OYW1lcyA9IHR5cGUgPT09IFwiaG9yaXpvbnRhbFwiID8gVkVSVElDQUxfTkFNRVNfTUFQIDogSE9SSVpPTlRBTF9OQU1FU19NQVA7XG4gIHZhciB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLnN0YXJ0XTtcbiAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmVuZF07XG4gIHJldHVybiBndWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgaGlkZSA9IF9hLmhpZGUsXG4gICAgICAgIGVsZW1lbnRSZWN0ID0gX2EuZWxlbWVudFJlY3Q7XG5cbiAgICBpZiAoaGlkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCAmJiBlbGVtZW50UmVjdCkge1xuICAgICAgLy8gaW5uZXJcbiAgICAgIHZhciByZWN0ID0gZWxlbWVudFJlY3QucmVjdDtcblxuICAgICAgaWYgKHJlY3RbbWFpbk5hbWVzLnN0YXJ0XSA8PSB0YXJnZXRTdGFydCAmJiB0YXJnZXRFbmQgPD0gcmVjdFttYWluTmFtZXMuZW5kXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pLm1hcChmdW5jdGlvbiAoZ3VpZGVsaW5lLCBpKSB7XG4gICAgdmFyIHBvcyA9IGd1aWRlbGluZS5wb3MsXG4gICAgICAgIHNpemUgPSBndWlkZWxpbmUuc2l6ZSxcbiAgICAgICAgZWxlbWVudCA9IGd1aWRlbGluZS5lbGVtZW50O1xuICAgIHZhciByZW5kZXJQb3MgPSBbLXRhcmdldFBvc1swXSArIHBvc1swXSwgLXRhcmdldFBvc1sxXSArIHBvc1sxXV07XG4gICAgcmV0dXJuIHJlbmRlcklubmVyR3VpZGVsaW5lKHtcbiAgICAgIGtleTogdHlwZSArIFwiLWRlZmF1bHQtZ3VpZGVsaW5lLVwiICsgaSxcbiAgICAgIGNsYXNzTmFtZXM6IGVsZW1lbnQgPyBbcHJlZml4KFwiYm9sZFwiKV0gOiBbXSxcbiAgICAgIGRpcmVjdGlvbjogdHlwZSxcbiAgICAgIHBvc1ZhbHVlOiByZW5kZXJQb3MsXG4gICAgICBzaXplVmFsdWU6IHNpemUsXG4gICAgICB6b29tOiB6b29tXG4gICAgfSwgUmVhY3QpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgbGluZVR5cGUsIGluZGV4LCBnYXAsIHJlbmRlclBvcywgY2xhc3NOYW1lLCBSZWFjdCkge1xuICB2YXIgX2E7XG5cbiAgdmFyIF9iID0gbW92ZWFibGUucHJvcHMsXG4gICAgICBfYyA9IF9iLnNuYXBEaWdpdCxcbiAgICAgIHNuYXBEaWdpdCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICBfZCA9IF9iLmlzRGlzcGxheVNuYXBEaWdpdCxcbiAgICAgIGlzRGlzcGxheVNuYXBEaWdpdCA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsXG4gICAgICBfZSA9IF9iLnNuYXBEaXN0Rm9ybWF0LFxuICAgICAgc25hcERpc3RGb3JtYXQgPSBfZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfSA6IF9lLFxuICAgICAgem9vbSA9IF9iLnpvb207XG4gIHZhciBzY2FsZVR5cGUgPSB0eXBlID09PSBcImhvcml6b250YWxcIiA/IFwiWFwiIDogXCJZXCI7XG4gIHZhciBzaXplTmFtZSA9IHR5cGUgPT09IFwidmVydGljYWxcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gIHZhciBhYnNHYXAgPSBNYXRoLmFicyhnYXApO1xuICB2YXIgc25hcFNpemUgPSBpc0Rpc3BsYXlTbmFwRGlnaXQgPyBwYXJzZUZsb2F0KGFic0dhcC50b0ZpeGVkKHNuYXBEaWdpdCkpIDogMDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleTogdHlwZSArIFwiLVwiICsgbGluZVR5cGUgKyBcIi1ndWlkZWxpbmUtXCIgKyBpbmRleCxcbiAgICBjbGFzc05hbWU6IHByZWZpeChcImd1aWRlbGluZS1ncm91cFwiLCB0eXBlKSxcbiAgICBzdHlsZTogKF9hID0ge1xuICAgICAgbGVmdDogcmVuZGVyUG9zWzBdICsgXCJweFwiLFxuICAgICAgdG9wOiByZW5kZXJQb3NbMV0gKyBcInB4XCJcbiAgICB9LCBfYVtzaXplTmFtZV0gPSBhYnNHYXAgKyBcInB4XCIsIF9hKVxuICB9LCByZW5kZXJJbm5lckd1aWRlbGluZSh7XG4gICAgZGlyZWN0aW9uOiB0eXBlLFxuICAgIGNsYXNzTmFtZXM6IFtwcmVmaXgobGluZVR5cGUpLCBjbGFzc05hbWVdLFxuICAgIHNpemU6IFwiMTAwJVwiLFxuICAgIHBvc1ZhbHVlOiBbMCwgMF0sXG4gICAgc2l6ZVZhbHVlOiBhYnNHYXAsXG4gICAgem9vbTogem9vbVxuICB9LCBSZWFjdCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogcHJlZml4KFwic2l6ZS12YWx1ZVwiLCBcImdhcFwiKSxcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVwiICsgc2NhbGVUeXBlICsgXCIoLTUwJSkgc2NhbGUoXCIgKyB6b29tICsgXCIpXCJcbiAgICB9XG4gIH0sIHNuYXBTaXplID4gMCA/IHNuYXBEaXN0Rm9ybWF0KHNuYXBTaXplKSA6IFwiXCIpKTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnlFbGVtZW50R3VpZGVsaW5lcyh0eXBlLCBndWlkZWxpbmVzLCB0YXJnZXRSZWN0LCBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCkge1xuICB2YXIgaW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAwIDogMTtcbiAgdmFyIG90aGVySW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAxIDogMDtcbiAgdmFyIG5hbWVzID0gaW5kZXggPyBWRVJUSUNBTF9OQU1FU19NQVAgOiBIT1JJWk9OVEFMX05BTUVTX01BUDtcbiAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFtuYW1lcy5zdGFydF07XG4gIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W25hbWVzLmVuZF07XG4gIHJldHVybiBncm91cEJ5KGd1aWRlbGluZXMsIGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICByZXR1cm4gZ3VpZGVsaW5lLnBvc1tpbmRleF07XG4gIH0pLm1hcChmdW5jdGlvbiAobmV4dEd1aWRlbGluZXMpIHtcbiAgICB2YXIgc3RhcnQgPSBbXTtcbiAgICB2YXIgZW5kID0gW107XG4gICAgdmFyIGlubmVyID0gW107XG4gICAgbmV4dEd1aWRlbGluZXMuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuXG4gICAgICB2YXIgZWxlbWVudCA9IGd1aWRlbGluZS5lbGVtZW50O1xuICAgICAgdmFyIHJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcblxuICAgICAgaWYgKHJlY3RbbmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0LnB1c2goZ3VpZGVsaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0RW5kIDwgcmVjdFtuYW1lcy5zdGFydF0pIHtcbiAgICAgICAgZW5kLnB1c2goZ3VpZGVsaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAocmVjdFtuYW1lcy5zdGFydF0gPD0gdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0RW5kIDw9IHJlY3RbbmFtZXMuZW5kXSAmJiBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCkge1xuICAgICAgICB2YXIgcG9zID0gZ3VpZGVsaW5lLnBvcztcbiAgICAgICAgdmFyIGVsZW1lbnRSZWN0MSA9IHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIHJlY3Q6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWN0KSwgKF9hID0ge30sIF9hW25hbWVzLmVuZF0gPSByZWN0W25hbWVzLnN0YXJ0XSwgX2EpKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZWxlbWVudFJlY3QyID0ge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgcmVjdDogX19hc3NpZ24oX19hc3NpZ24oe30sIHJlY3QpLCAoX2IgPSB7fSwgX2JbbmFtZXMuc3RhcnRdID0gcmVjdFtuYW1lcy5lbmRdLCBfYikpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBuZXh0UG9zMSA9IFswLCAwXTtcbiAgICAgICAgdmFyIG5leHRQb3MyID0gWzAsIDBdO1xuICAgICAgICBuZXh0UG9zMVtpbmRleF0gPSBwb3NbaW5kZXhdO1xuICAgICAgICBuZXh0UG9zMVtvdGhlckluZGV4XSA9IHBvc1tvdGhlckluZGV4XTtcbiAgICAgICAgbmV4dFBvczJbaW5kZXhdID0gcG9zW2luZGV4XTtcbiAgICAgICAgbmV4dFBvczJbb3RoZXJJbmRleF0gPSBwb3Nbb3RoZXJJbmRleF0gKyBndWlkZWxpbmUuc2l6ZTtcbiAgICAgICAgc3RhcnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBwb3M6IG5leHRQb3MxLFxuICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgZWxlbWVudFJlY3Q6IGVsZW1lbnRSZWN0MVxuICAgICAgICB9KTtcbiAgICAgICAgZW5kLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgcG9zOiBuZXh0UG9zMixcbiAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgIGVsZW1lbnRSZWN0OiBlbGVtZW50UmVjdDJcbiAgICAgICAgfSk7IC8vIGlubmVyLnB1c2goZ3VpZGVsaW5lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGFydC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5wb3Nbb3RoZXJJbmRleF0gLSBhLnBvc1tvdGhlckluZGV4XTtcbiAgICB9KTtcbiAgICBlbmQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEucG9zW290aGVySW5kZXhdIC0gYi5wb3Nbb3RoZXJJbmRleF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsOiBuZXh0R3VpZGVsaW5lcyxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgaW5uZXI6IGlubmVyXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZW5kZXJEYXNoZWRHdWlkZWxpbmVzKG1vdmVhYmxlLCBndWlkZWxpbmVzLCB0YXJnZXRQb3MsIHRhcmdldFJlY3QsIFJlYWN0KSB7XG4gIHZhciBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCA9IG1vdmVhYmxlLnByb3BzLmlzRGlzcGxheUlubmVyU25hcERpZ2l0O1xuICB2YXIgcmVuZGVyZWQgPSBbXTtcbiAgW1widmVydGljYWxcIiwgXCJob3Jpem9udGFsXCJdLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgbmV4dEd1aWRlbGluZXMgPSBndWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICByZXR1cm4gZ3VpZGVsaW5lLnR5cGUgPT09IHR5cGU7XG4gICAgfSk7XG4gICAgdmFyIGluZGV4ID0gdHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMSA6IDA7XG4gICAgdmFyIG90aGVySW5kZXggPSBpbmRleCA/IDAgOiAxO1xuICAgIHZhciBncm91cHMgPSBncm91cEJ5RWxlbWVudEd1aWRlbGluZXModHlwZSwgbmV4dEd1aWRlbGluZXMsIHRhcmdldFJlY3QsIGlzRGlzcGxheUlubmVyU25hcERpZ2l0KTtcbiAgICB2YXIgbWFpbk5hbWVzID0gaW5kZXggPyBIT1JJWk9OVEFMX05BTUVTX01BUCA6IFZFUlRJQ0FMX05BTUVTX01BUDtcbiAgICB2YXIgc2lkZU5hbWVzID0gaW5kZXggPyBWRVJUSUNBTF9OQU1FU19NQVAgOiBIT1JJWk9OVEFMX05BTUVTX01BUDtcbiAgICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5zdGFydF07XG4gICAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmVuZF07XG4gICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgdG90YWwgPSBfYS50b3RhbCxcbiAgICAgICAgICBzdGFydCA9IF9hLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IF9hLmVuZCxcbiAgICAgICAgICBpbm5lciA9IF9hLmlubmVyO1xuICAgICAgdmFyIHNpZGVQb3MgPSB0YXJnZXRQb3Nbb3RoZXJJbmRleF0gKyB0b3RhbFswXS5wb3Nbb3RoZXJJbmRleF0gLSB0YXJnZXRSZWN0W3NpZGVOYW1lcy5zdGFydF07XG4gICAgICB2YXIgcHJldlJlY3QgPSB0YXJnZXRSZWN0O1xuICAgICAgc3RhcnQuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICAgIHZhciBuZXh0UmVjdCA9IGd1aWRlbGluZS5lbGVtZW50UmVjdC5yZWN0O1xuICAgICAgICB2YXIgc2l6ZSA9IHByZXZSZWN0W21haW5OYW1lcy5zdGFydF0gLSBuZXh0UmVjdFttYWluTmFtZXMuZW5kXTtcblxuICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICB2YXIgcmVuZGVyUG9zID0gWzAsIDBdO1xuICAgICAgICAgIHJlbmRlclBvc1tpbmRleF0gPSB0YXJnZXRQb3NbaW5kZXhdICsgcHJldlJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIHRhcmdldFN0YXJ0IC0gc2l6ZTtcbiAgICAgICAgICByZW5kZXJQb3Nbb3RoZXJJbmRleF0gPSBzaWRlUG9zO1xuICAgICAgICAgIHJlbmRlcmVkLnB1c2gocmVuZGVyRGlnaXRMaW5lKG1vdmVhYmxlLCB0eXBlLCBcImRhc2hlZFwiLCByZW5kZXJlZC5sZW5ndGgsIHNpemUsIHJlbmRlclBvcywgZ3VpZGVsaW5lLmNsYXNzTmFtZSwgUmVhY3QpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZSZWN0ID0gbmV4dFJlY3Q7XG4gICAgICB9KTtcbiAgICAgIHByZXZSZWN0ID0gdGFyZ2V0UmVjdDtcbiAgICAgIGVuZC5mb3JFYWNoKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgICAgdmFyIG5leHRSZWN0ID0gZ3VpZGVsaW5lLmVsZW1lbnRSZWN0LnJlY3Q7XG4gICAgICAgIHZhciBzaXplID0gbmV4dFJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIHByZXZSZWN0W21haW5OYW1lcy5lbmRdO1xuXG4gICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgIHZhciByZW5kZXJQb3MgPSBbMCwgMF07XG4gICAgICAgICAgcmVuZGVyUG9zW2luZGV4XSA9IHRhcmdldFBvc1tpbmRleF0gKyBwcmV2UmVjdFttYWluTmFtZXMuZW5kXSAtIHRhcmdldFN0YXJ0O1xuICAgICAgICAgIHJlbmRlclBvc1tvdGhlckluZGV4XSA9IHNpZGVQb3M7XG4gICAgICAgICAgcmVuZGVyZWQucHVzaChyZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIHR5cGUsIFwiZGFzaGVkXCIsIHJlbmRlcmVkLmxlbmd0aCwgc2l6ZSwgcmVuZGVyUG9zLCBndWlkZWxpbmUuY2xhc3NOYW1lLCBSZWFjdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldlJlY3QgPSBuZXh0UmVjdDtcbiAgICAgIH0pO1xuICAgICAgaW5uZXIuZm9yRWFjaChmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XG4gICAgICAgIHZhciBuZXh0UmVjdCA9IGd1aWRlbGluZS5lbGVtZW50UmVjdC5yZWN0O1xuICAgICAgICB2YXIgc2l6ZTEgPSB0YXJnZXRTdGFydCAtIG5leHRSZWN0W21haW5OYW1lcy5zdGFydF07XG4gICAgICAgIHZhciBzaXplMiA9IG5leHRSZWN0W21haW5OYW1lcy5lbmRdIC0gdGFyZ2V0RW5kO1xuICAgICAgICB2YXIgcmVuZGVyUG9zMSA9IFswLCAwXTtcbiAgICAgICAgdmFyIHJlbmRlclBvczIgPSBbMCwgMF07XG4gICAgICAgIHJlbmRlclBvczFbaW5kZXhdID0gdGFyZ2V0UG9zW2luZGV4XSAtIHNpemUxO1xuICAgICAgICByZW5kZXJQb3MxW290aGVySW5kZXhdID0gc2lkZVBvcztcbiAgICAgICAgcmVuZGVyUG9zMltpbmRleF0gPSB0YXJnZXRQb3NbaW5kZXhdICsgdGFyZ2V0RW5kIC0gdGFyZ2V0U3RhcnQ7XG4gICAgICAgIHJlbmRlclBvczJbb3RoZXJJbmRleF0gPSBzaWRlUG9zO1xuICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgXCJkYXNoZWRcIiwgcmVuZGVyZWQubGVuZ3RoLCBzaXplMSwgcmVuZGVyUG9zMSwgZ3VpZGVsaW5lLmNsYXNzTmFtZSwgUmVhY3QpKTtcbiAgICAgICAgcmVuZGVyZWQucHVzaChyZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIHR5cGUsIFwiZGFzaGVkXCIsIHJlbmRlcmVkLmxlbmd0aCwgc2l6ZTIsIHJlbmRlclBvczIsIGd1aWRlbGluZS5jbGFzc05hbWUsIFJlYWN0KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIHJlbmRlckdhcEd1aWRlbGluZXMobW92ZWFibGUsIGd1aWRlbGluZXMsIHRhcmdldFBvcywgdGFyZ2V0UmVjdCwgUmVhY3QpIHtcbiAgdmFyIHJlbmRlcmVkID0gW107XG4gIFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIG5leHRHdWlkZWxpbmVzID0gZ3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgcmV0dXJuIGd1aWRlbGluZS50eXBlID09PSB0eXBlO1xuICAgIH0pO1xuICAgIHZhciBpbmRleCA9IHR5cGUgPT09IFwidmVydGljYWxcIiA/IDAgOiAxO1xuICAgIHZhciBvdGhlckluZGV4ID0gaW5kZXggPyAwIDogMTtcbiAgICB2YXIgbWFpbk5hbWVzID0gaW5kZXggPyBIT1JJWk9OVEFMX05BTUVTX01BUCA6IFZFUlRJQ0FMX05BTUVTX01BUDtcbiAgICB2YXIgc2lkZU5hbWVzID0gaW5kZXggPyBWRVJUSUNBTF9OQU1FU19NQVAgOiBIT1JJWk9OVEFMX05BTUVTX01BUDtcbiAgICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5zdGFydF07XG4gICAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmVuZF07XG4gICAgdmFyIHRhcmdldFNpZGVTdGFydCA9IHRhcmdldFJlY3Rbc2lkZU5hbWVzLnN0YXJ0XTtcbiAgICB2YXIgdGFyZ2V0U2lkZUVuZCA9IHRhcmdldFJlY3Rbc2lkZU5hbWVzLmVuZF07XG4gICAgbmV4dEd1aWRlbGluZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBnYXAgPSBfYS5nYXAsXG4gICAgICAgICAgZ2FwUmVjdHMgPSBfYS5nYXBSZWN0cyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWU7XG4gICAgICB2YXIgc2lkZVN0YXJ0UG9zID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbdGFyZ2V0U2lkZVN0YXJ0XSwgZ2FwUmVjdHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcmVjdCA9IF9hLnJlY3Q7XG4gICAgICAgIHJldHVybiByZWN0W3NpZGVOYW1lcy5zdGFydF07XG4gICAgICB9KSkpO1xuICAgICAgdmFyIHNpZGVFbmRQb3MgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFt0YXJnZXRTaWRlRW5kXSwgZ2FwUmVjdHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcmVjdCA9IF9hLnJlY3Q7XG4gICAgICAgIHJldHVybiByZWN0W3NpZGVOYW1lcy5lbmRdO1xuICAgICAgfSkpKTtcbiAgICAgIHZhciBzaWRlQ2VudGVyUG9zID0gKHNpZGVTdGFydFBvcyArIHNpZGVFbmRQb3MpIC8gMjtcblxuICAgICAgaWYgKHNpZGVTdGFydFBvcyA9PT0gc2lkZUVuZFBvcyB8fCBzaWRlQ2VudGVyUG9zID09PSAodGFyZ2V0U2lkZVN0YXJ0ICsgdGFyZ2V0U2lkZUVuZCkgLyAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZ2FwUmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBfYS5yZWN0O1xuICAgICAgICB2YXIgcmVuZGVyUG9zID0gW3RhcmdldFBvc1swXSwgdGFyZ2V0UG9zWzFdXTtcblxuICAgICAgICBpZiAocmVjdFttYWluTmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0KSB7XG4gICAgICAgICAgcmVuZGVyUG9zW2luZGV4XSArPSByZWN0W21haW5OYW1lcy5lbmRdIC0gdGFyZ2V0U3RhcnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0RW5kIDwgcmVjdFttYWluTmFtZXMuc3RhcnRdKSB7XG4gICAgICAgICAgcmVuZGVyUG9zW2luZGV4XSArPSByZWN0W21haW5OYW1lcy5zdGFydF0gLSB0YXJnZXRTdGFydCAtIGdhcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJQb3Nbb3RoZXJJbmRleF0gKz0gc2lkZUNlbnRlclBvcyAtIHRhcmdldFNpZGVTdGFydDtcbiAgICAgICAgcmVuZGVyZWQucHVzaChyZW5kZXJEaWdpdExpbmUobW92ZWFibGUsIGluZGV4ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIsIFwiZ2FwXCIsIHJlbmRlcmVkLmxlbmd0aCwgZ2FwLCByZW5kZXJQb3MsIGNsYXNzTmFtZSwgUmVhY3QpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlbmRlcmVkO1xufVxuXG5mdW5jdGlvbiBzb2x2ZUVxdWF0aW9uKHBvczEsIHBvczIsIHNuYXBPZmZzZXQsIGlzVmVydGljYWwpIHtcbiAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuXG4gIGlmIChNYXRoLmFicyhkeCkgPCBUSU5ZX05VTSQxKSB7XG4gICAgZHggPSAwO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGR5KSA8IFRJTllfTlVNJDEpIHtcbiAgICBkeSA9IDA7XG4gIH1cblxuICBpZiAoIWR4KSB7XG4gICAgLy8geSA9IDAgKiB4ICsgYlxuICAgIC8vIG9ubHkgaG9yaXpvbnRhbFxuICAgIGlmICghaXNWZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIFswLCBzbmFwT2Zmc2V0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG5cbiAgaWYgKCFkeSkge1xuICAgIC8vIG9ubHkgdmVydGljYWxcbiAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgcmV0dXJuIFtzbmFwT2Zmc2V0LCAwXTtcbiAgICB9XG5cbiAgICByZXR1cm4gWzAsIDBdO1xuICB9IC8vIHkgPSBheCArIGJcblxuXG4gIHZhciBhID0gZHkgLyBkeDtcbiAgdmFyIGIgPSBwb3MxWzFdIC0gYSAqIHBvczFbMF07XG5cbiAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAvLyB5ID0gYSAqIHggKyBiXG4gICAgdmFyIHkgPSBhICogKHBvczJbMF0gKyBzbmFwT2Zmc2V0KSArIGI7XG4gICAgcmV0dXJuIFtzbmFwT2Zmc2V0LCB5IC0gcG9zMlsxXV07XG4gIH0gZWxzZSB7XG4gICAgLy8geCA9ICh5IC0gYikgLyBhXG4gICAgdmFyIHggPSAocG9zMlsxXSArIHNuYXBPZmZzZXQgLSBiKSAvIGE7XG4gICAgcmV0dXJuIFt4IC0gcG9zMlswXSwgc25hcE9mZnNldF07XG4gIH1cbn1cblxuZnVuY3Rpb24gc29sdmVOZXh0T2Zmc2V0KHBvczEsIHBvczIsIG9mZnNldCwgaXNWZXJ0aWNhbCwgZGF0YXMpIHtcbiAgdmFyIHNpemVPZmZzZXQgPSBzb2x2ZUVxdWF0aW9uKHBvczEsIHBvczIsIG9mZnNldCwgaXNWZXJ0aWNhbCk7XG5cbiAgaWYgKCFzaXplT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzT3V0c2lkZTogZmFsc2UsXG4gICAgICBvZmZzZXQ6IFswLCAwXVxuICAgIH07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGdldERpc3QkMShwb3MxLCBwb3MyKTtcbiAgdmFyIGRpc3QxID0gZ2V0RGlzdCQxKHNpemVPZmZzZXQsIHBvczEpO1xuICB2YXIgZGlzdDIgPSBnZXREaXN0JDEoc2l6ZU9mZnNldCwgcG9zMik7XG4gIHZhciBpc091dHNpZGUgPSBkaXN0MSA+IHNpemUgfHwgZGlzdDIgPiBzaXplO1xuXG4gIHZhciBfYSA9IGdldERyYWdEaXN0KHtcbiAgICBkYXRhczogZGF0YXMsXG4gICAgZGlzdFg6IHNpemVPZmZzZXRbMF0sXG4gICAgZGlzdFk6IHNpemVPZmZzZXRbMV1cbiAgfSksXG4gICAgICB3aWR0aE9mZnNldCA9IF9hWzBdLFxuICAgICAgaGVpZ2h0T2Zmc2V0ID0gX2FbMV07XG5cbiAgcmV0dXJuIHtcbiAgICBvZmZzZXQ6IFt3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0XSxcbiAgICBpc091dHNpZGU6IGlzT3V0c2lkZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTbmFwQm91bmQoYm91bmRJbmZvLCBzbmFwSW5mbykge1xuICBpZiAoYm91bmRJbmZvLmlzQm91bmQpIHtcbiAgICByZXR1cm4gYm91bmRJbmZvLm9mZnNldDtcbiAgfSBlbHNlIGlmIChzbmFwSW5mby5pc1NuYXApIHtcbiAgICByZXR1cm4gZ2V0TmVhcmVzdFNuYXBHdWlkZWxpbmVJbmZvKHNuYXBJbmZvKS5vZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY2hlY2tUaHJvdHRsZURyYWdSb3RhdGUodGhyb3R0bGVEcmFnUm90YXRlLCBfYSwgX2IsIF9jLCBfZCkge1xuICB2YXIgZGlzdFggPSBfYVswXSxcbiAgICAgIGRpc3RZID0gX2FbMV07XG4gIHZhciBpc1ZlcnRpY2FsQm91bmQgPSBfYlswXSxcbiAgICAgIGlzSG9yaXpvbnRhbEJvdW5kID0gX2JbMV07XG4gIHZhciBpc1ZlcnRpY2FsU25hcCA9IF9jWzBdLFxuICAgICAgaXNIb3Jpem9udGFsU25hcCA9IF9jWzFdO1xuICB2YXIgdmVydGljYWxPZmZzZXQgPSBfZFswXSxcbiAgICAgIGhvcml6b250YWxPZmZzZXQgPSBfZFsxXTtcbiAgdmFyIG9mZnNldFggPSAtdmVydGljYWxPZmZzZXQ7XG4gIHZhciBvZmZzZXRZID0gLWhvcml6b250YWxPZmZzZXQ7XG5cbiAgaWYgKHRocm90dGxlRHJhZ1JvdGF0ZSAmJiBkaXN0WCAmJiBkaXN0WSkge1xuICAgIG9mZnNldFggPSAwO1xuICAgIG9mZnNldFkgPSAwO1xuICAgIHZhciBhZGp1c3RQb3NlcyA9IFtdO1xuXG4gICAgaWYgKGlzVmVydGljYWxCb3VuZCAmJiBpc0hvcml6b250YWxCb3VuZCkge1xuICAgICAgYWRqdXN0UG9zZXMucHVzaChbMCwgaG9yaXpvbnRhbE9mZnNldF0sIFt2ZXJ0aWNhbE9mZnNldCwgMF0pO1xuICAgIH0gZWxzZSBpZiAoaXNWZXJ0aWNhbEJvdW5kKSB7XG4gICAgICBhZGp1c3RQb3Nlcy5wdXNoKFt2ZXJ0aWNhbE9mZnNldCwgMF0pO1xuICAgIH0gZWxzZSBpZiAoaXNIb3Jpem9udGFsQm91bmQpIHtcbiAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdKTtcbiAgICB9IGVsc2UgaWYgKGlzVmVydGljYWxTbmFwICYmIGlzSG9yaXpvbnRhbFNuYXApIHtcbiAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdLCBbdmVydGljYWxPZmZzZXQsIDBdKTtcbiAgICB9IGVsc2UgaWYgKGlzVmVydGljYWxTbmFwKSB7XG4gICAgICBhZGp1c3RQb3Nlcy5wdXNoKFt2ZXJ0aWNhbE9mZnNldCwgMF0pO1xuICAgIH0gZWxzZSBpZiAoaXNIb3Jpem9udGFsU25hcCkge1xuICAgICAgYWRqdXN0UG9zZXMucHVzaChbMCwgaG9yaXpvbnRhbE9mZnNldF0pO1xuICAgIH1cblxuICAgIGlmIChhZGp1c3RQb3Nlcy5sZW5ndGgpIHtcbiAgICAgIGFkanVzdFBvc2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc3RTaXplKG1pbnVzKFtkaXN0WCwgZGlzdFldLCBhKSkgLSBnZXREaXN0U2l6ZShtaW51cyhbZGlzdFgsIGRpc3RZXSwgYikpO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWRqdXN0UG9zID0gYWRqdXN0UG9zZXNbMF07XG5cbiAgICAgIGlmIChhZGp1c3RQb3NbMF0gJiYgTWF0aC5hYnMoZGlzdFgpID4gVElOWV9OVU0kMSkge1xuICAgICAgICBvZmZzZXRYID0gLWFkanVzdFBvc1swXTtcbiAgICAgICAgb2Zmc2V0WSA9IGRpc3RZICogTWF0aC5hYnMoZGlzdFggKyBvZmZzZXRYKSAvIE1hdGguYWJzKGRpc3RYKSAtIGRpc3RZO1xuICAgICAgfSBlbHNlIGlmIChhZGp1c3RQb3NbMV0gJiYgTWF0aC5hYnMoZGlzdFkpID4gVElOWV9OVU0kMSkge1xuICAgICAgICB2YXIgcHJldkRpc3RZID0gZGlzdFk7XG4gICAgICAgIG9mZnNldFkgPSAtYWRqdXN0UG9zWzFdO1xuICAgICAgICBvZmZzZXRYID0gZGlzdFggKiBNYXRoLmFicyhkaXN0WSArIG9mZnNldFkpIC8gTWF0aC5hYnMocHJldkRpc3RZKSAtIGRpc3RYO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhyb3R0bGVEcmFnUm90YXRlICYmIGlzSG9yaXpvbnRhbEJvdW5kICYmIGlzVmVydGljYWxCb3VuZCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMob2Zmc2V0WCkgPiBUSU5ZX05VTSQxICYmIE1hdGguYWJzKG9mZnNldFgpIDwgTWF0aC5hYnModmVydGljYWxPZmZzZXQpKSB7XG4gICAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5hYnModmVydGljYWxPZmZzZXQpIC8gTWF0aC5hYnMob2Zmc2V0WCk7XG4gICAgICAgICAgb2Zmc2V0WCAqPSBzY2FsZTtcbiAgICAgICAgICBvZmZzZXRZICo9IHNjYWxlO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKG9mZnNldFkpID4gVElOWV9OVU0kMSAmJiBNYXRoLmFicyhvZmZzZXRZKSA8IE1hdGguYWJzKGhvcml6b250YWxPZmZzZXQpKSB7XG4gICAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5hYnMoaG9yaXpvbnRhbE9mZnNldCkgLyBNYXRoLmFicyhvZmZzZXRZKTtcbiAgICAgICAgICBvZmZzZXRYICo9IHNjYWxlO1xuICAgICAgICAgIG9mZnNldFkgKj0gc2NhbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0WCA9IG1heE9mZnNldCgtdmVydGljYWxPZmZzZXQsIG9mZnNldFgpO1xuICAgICAgICAgIG9mZnNldFkgPSBtYXhPZmZzZXQoLWhvcml6b250YWxPZmZzZXQsIG9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9mZnNldFggPSBkaXN0WCB8fCBpc1ZlcnRpY2FsQm91bmQgPyAtdmVydGljYWxPZmZzZXQgOiAwO1xuICAgIG9mZnNldFkgPSBkaXN0WSB8fCBpc0hvcml6b250YWxCb3VuZCA/IC1ob3Jpem9udGFsT2Zmc2V0IDogMDtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZHNEcmFnKG1vdmVhYmxlLCBkaXN0WCwgZGlzdFksIHRocm90dGxlRHJhZ1JvdGF0ZSwgaXNSZXF1ZXN0LCBkYXRhcykge1xuICBpZiAoIWhhc0d1aWRlbGluZXMobW92ZWFibGUsIFwiZHJhZ2dhYmxlXCIpKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgaXNCb3VuZDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LCB7XG4gICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgaXNCb3VuZDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9XTtcbiAgfVxuXG4gIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXMoZGF0YXMuYWJzb2x1dGVQb3NlcywgW2Rpc3RYLCBkaXN0WV0pO1xuXG4gIHZhciBfYSA9IGdldFJlY3QocG9zZXMpLFxuICAgICAgbGVmdCA9IF9hLmxlZnQsXG4gICAgICByaWdodCA9IF9hLnJpZ2h0LFxuICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgYm90dG9tID0gX2EuYm90dG9tO1xuXG4gIHZhciBib3VuZFBvc2VzID0ge1xuICAgIGhvcml6b250YWw6IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zWzFdO1xuICAgIH0pLFxuICAgIHZlcnRpY2FsOiBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvc1swXTtcbiAgICB9KVxuICB9O1xuICB2YXIgc25hcERpcmVjdGlvbnMgPSBnZXRTbmFwRGlyZWN0aW9ucyhtb3ZlYWJsZS5wcm9wcy5zbmFwRGlyZWN0aW9ucyk7XG4gIHZhciBzbmFwUG9zZXMgPSBzcGxpdFNuYXBEaXJlY3Rpb25Qb3NlcyhzbmFwRGlyZWN0aW9ucywge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIHRvcDogdG9wLFxuICAgIGJvdHRvbTogYm90dG9tLFxuICAgIGNlbnRlcjogKGxlZnQgKyByaWdodCkgLyAyLFxuICAgIG1pZGRsZTogKHRvcCArIGJvdHRvbSkgLyAyXG4gIH0pO1xuXG4gIHZhciBfYiA9IGNoZWNrTW92ZWFibGVTbmFwQm91bmRzKG1vdmVhYmxlLCBpc1JlcXVlc3QsIHNuYXBQb3NlcywgYm91bmRQb3NlcyksXG4gICAgICB2ZXJ0aWNhbFNuYXBCb3VuZEluZm8gPSBfYi52ZXJ0aWNhbCxcbiAgICAgIGhvcml6b250YWxTbmFwQm91bmRJbmZvID0gX2IuaG9yaXpvbnRhbDtcblxuICB2YXIgX2MgPSBnZXRJbm5lckJvdW5kRHJhZ0luZm8obW92ZWFibGUsIHBvc2VzLCBkYXRhcyksXG4gICAgICB2ZXJ0aWNhbElubmVyQm91bmRJbmZvID0gX2MudmVydGljYWwsXG4gICAgICBob3Jpem9udGFsSW5uZXJCb3VuZEluZm8gPSBfYy5ob3Jpem9udGFsO1xuXG4gIHZhciBpc1ZlcnRpY2FsU25hcCA9IHZlcnRpY2FsU25hcEJvdW5kSW5mby5pc1NuYXA7XG4gIHZhciBpc0hvcml6b250YWxTbmFwID0gaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8uaXNTbmFwO1xuICB2YXIgaXNWZXJ0aWNhbEJvdW5kID0gdmVydGljYWxTbmFwQm91bmRJbmZvLmlzQm91bmQgfHwgdmVydGljYWxJbm5lckJvdW5kSW5mby5pc0JvdW5kO1xuICB2YXIgaXNIb3Jpem9udGFsQm91bmQgPSBob3Jpem9udGFsU25hcEJvdW5kSW5mby5pc0JvdW5kIHx8IGhvcml6b250YWxJbm5lckJvdW5kSW5mby5pc0JvdW5kO1xuICB2YXIgdmVydGljYWxPZmZzZXQgPSBtYXhPZmZzZXQodmVydGljYWxTbmFwQm91bmRJbmZvLm9mZnNldCwgdmVydGljYWxJbm5lckJvdW5kSW5mby5vZmZzZXQpO1xuICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IG1heE9mZnNldChob3Jpem9udGFsU25hcEJvdW5kSW5mby5vZmZzZXQsIGhvcml6b250YWxJbm5lckJvdW5kSW5mby5vZmZzZXQpO1xuXG4gIHZhciBfZCA9IGNoZWNrVGhyb3R0bGVEcmFnUm90YXRlKHRocm90dGxlRHJhZ1JvdGF0ZSwgW2Rpc3RYLCBkaXN0WV0sIFtpc1ZlcnRpY2FsQm91bmQsIGlzSG9yaXpvbnRhbEJvdW5kXSwgW2lzVmVydGljYWxTbmFwLCBpc0hvcml6b250YWxTbmFwXSwgW3ZlcnRpY2FsT2Zmc2V0LCBob3Jpem9udGFsT2Zmc2V0XSksXG4gICAgICBvZmZzZXRYID0gX2RbMF0sXG4gICAgICBvZmZzZXRZID0gX2RbMV07XG5cbiAgcmV0dXJuIFt7XG4gICAgaXNCb3VuZDogaXNWZXJ0aWNhbEJvdW5kLFxuICAgIGlzU25hcDogaXNWZXJ0aWNhbFNuYXAsXG4gICAgb2Zmc2V0OiBvZmZzZXRYXG4gIH0sIHtcbiAgICBpc0JvdW5kOiBpc0hvcml6b250YWxCb3VuZCxcbiAgICBpc1NuYXA6IGlzSG9yaXpvbnRhbFNuYXAsXG4gICAgb2Zmc2V0OiBvZmZzZXRZXG4gIH1dO1xufVxuZnVuY3Rpb24gY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwgcG9zZXMsIGJvdW5kUG9zZXMpIHtcbiAgaWYgKGJvdW5kUG9zZXMgPT09IHZvaWQgMCkge1xuICAgIGJvdW5kUG9zZXMgPSBwb3NlcztcbiAgfVxuXG4gIHZhciBfYSA9IGNoZWNrQm91bmRQb3NlcyhnZXRCb3VuZHMobW92ZWFibGUpLCBib3VuZFBvc2VzLnZlcnRpY2FsLCBib3VuZFBvc2VzLmhvcml6b250YWwpLFxuICAgICAgaG9yaXpvbnRhbEJvdW5kSW5mb3MgPSBfYS5ob3Jpem9udGFsLFxuICAgICAgdmVydGljYWxCb3VuZEluZm9zID0gX2EudmVydGljYWw7XG5cbiAgdmFyIF9iID0gaXNSZXF1ZXN0ID8ge1xuICAgIGhvcml6b250YWw6IHtcbiAgICAgIGlzU25hcDogZmFsc2UsXG4gICAgICBpbmRleDogLTFcbiAgICB9LFxuICAgIHZlcnRpY2FsOiB7XG4gICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgaW5kZXg6IC0xXG4gICAgfVxuICB9IDogY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgcG9zZXMudmVydGljYWwsIHBvc2VzLmhvcml6b250YWwpLFxuICAgICAgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2IuaG9yaXpvbnRhbCxcbiAgICAgIHZlcnRpY2FsU25hcEluZm8gPSBfYi52ZXJ0aWNhbDtcblxuICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IGdldFNuYXBCb3VuZChob3Jpem9udGFsQm91bmRJbmZvc1swXSwgaG9yaXpvbnRhbFNuYXBJbmZvKTtcbiAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gZ2V0U25hcEJvdW5kKHZlcnRpY2FsQm91bmRJbmZvc1swXSwgdmVydGljYWxTbmFwSW5mbyk7XG4gIHZhciBob3Jpem9udGFsRGlzdCA9IE1hdGguYWJzKGhvcml6b250YWxPZmZzZXQpO1xuICB2YXIgdmVydGljYWxEaXN0ID0gTWF0aC5hYnModmVydGljYWxPZmZzZXQpO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWw6IHtcbiAgICAgIGlzQm91bmQ6IGhvcml6b250YWxCb3VuZEluZm9zWzBdLmlzQm91bmQsXG4gICAgICBpc1NuYXA6IGhvcml6b250YWxTbmFwSW5mby5pc1NuYXAsXG4gICAgICBzbmFwSW5kZXg6IGhvcml6b250YWxTbmFwSW5mby5pbmRleCxcbiAgICAgIG9mZnNldDogaG9yaXpvbnRhbE9mZnNldCxcbiAgICAgIGRpc3Q6IGhvcml6b250YWxEaXN0LFxuICAgICAgYm91bmRzOiBob3Jpem9udGFsQm91bmRJbmZvcyxcbiAgICAgIHNuYXA6IGhvcml6b250YWxTbmFwSW5mb1xuICAgIH0sXG4gICAgdmVydGljYWw6IHtcbiAgICAgIGlzQm91bmQ6IHZlcnRpY2FsQm91bmRJbmZvc1swXS5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiB2ZXJ0aWNhbFNuYXBJbmZvLmlzU25hcCxcbiAgICAgIHNuYXBJbmRleDogdmVydGljYWxTbmFwSW5mby5pbmRleCxcbiAgICAgIG9mZnNldDogdmVydGljYWxPZmZzZXQsXG4gICAgICBkaXN0OiB2ZXJ0aWNhbERpc3QsXG4gICAgICBib3VuZHM6IHZlcnRpY2FsQm91bmRJbmZvcyxcbiAgICAgIHNuYXA6IHZlcnRpY2FsU25hcEluZm9cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZHMoZ3VpZGVpbmVzLCBib3VuZHMsIHBvc2VzWCwgcG9zZXNZLCBzbmFwVGhyZXNob2xkKSB7XG4gIHZhciBfYSA9IGNoZWNrQm91bmRQb3Nlcyhib3VuZHMsIHBvc2VzWCwgcG9zZXNZKSxcbiAgICAgIGhvcml6b250YWxCb3VuZEluZm9zID0gX2EuaG9yaXpvbnRhbCxcbiAgICAgIHZlcnRpY2FsQm91bmRJbmZvcyA9IF9hLnZlcnRpY2FsOyAvLyBvcHRpb25zLmlzUmVxdWVzdCA/IHtcbiAgLy8gICAgIGhvcml6b250YWw6IHsgaXNTbmFwOiBmYWxzZSwgaW5kZXg6IC0xIH0gYXMgU25hcEluZm8sXG4gIC8vICAgICB2ZXJ0aWNhbDogeyBpc1NuYXA6IGZhbHNlLCBpbmRleDogLTEgfSBhcyBTbmFwSW5mbyxcbiAgLy8gfSA6XG5cblxuICB2YXIgX2IgPSBjaGVja1NuYXBQb3NlcyhndWlkZWluZXMsIHBvc2VzWCwgcG9zZXNZLCBzbmFwVGhyZXNob2xkKSxcbiAgICAgIGhvcml6b250YWxTbmFwSW5mbyA9IF9iLmhvcml6b250YWwsXG4gICAgICB2ZXJ0aWNhbFNuYXBJbmZvID0gX2IudmVydGljYWw7XG5cbiAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBnZXRTbmFwQm91bmQoaG9yaXpvbnRhbEJvdW5kSW5mb3NbMF0sIGhvcml6b250YWxTbmFwSW5mbyk7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IGdldFNuYXBCb3VuZCh2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0sIHZlcnRpY2FsU25hcEluZm8pO1xuICB2YXIgaG9yaXpvbnRhbERpc3QgPSBNYXRoLmFicyhob3Jpem9udGFsT2Zmc2V0KTtcbiAgdmFyIHZlcnRpY2FsRGlzdCA9IE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0KTtcbiAgcmV0dXJuIHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc0JvdW5kOiBob3Jpem9udGFsQm91bmRJbmZvc1swXS5pc0JvdW5kLFxuICAgICAgaXNTbmFwOiBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwLFxuICAgICAgc25hcEluZGV4OiBob3Jpem9udGFsU25hcEluZm8uaW5kZXgsXG4gICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXG4gICAgICBkaXN0OiBob3Jpem9udGFsRGlzdCxcbiAgICAgIGJvdW5kczogaG9yaXpvbnRhbEJvdW5kSW5mb3MsXG4gICAgICBzbmFwOiBob3Jpem9udGFsU25hcEluZm9cbiAgICB9LFxuICAgIHZlcnRpY2FsOiB7XG4gICAgICBpc0JvdW5kOiB2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0uaXNCb3VuZCxcbiAgICAgIGlzU25hcDogdmVydGljYWxTbmFwSW5mby5pc1NuYXAsXG4gICAgICBzbmFwSW5kZXg6IHZlcnRpY2FsU25hcEluZm8uaW5kZXgsXG4gICAgICBvZmZzZXQ6IHZlcnRpY2FsT2Zmc2V0LFxuICAgICAgZGlzdDogdmVydGljYWxEaXN0LFxuICAgICAgYm91bmRzOiB2ZXJ0aWNhbEJvdW5kSW5mb3MsXG4gICAgICBzbmFwOiB2ZXJ0aWNhbFNuYXBJbmZvXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja1NuYXBSaWdodExpbmUoc3RhcnRQb3MsIGVuZFBvcywgc25hcEJvdW5kSW5mbywga2VlcFJhdGlvKSB7XG4gIHZhciByYWQgPSBnZXRSYWQoc3RhcnRQb3MsIGVuZFBvcykgLyBNYXRoLlBJICogMTgwO1xuICB2YXIgX2EgPSBzbmFwQm91bmRJbmZvLnZlcnRpY2FsLFxuICAgICAgaXNWZXJ0aWNhbEJvdW5kID0gX2EuaXNCb3VuZCxcbiAgICAgIGlzVmVydGljYWxTbmFwID0gX2EuaXNTbmFwLFxuICAgICAgdmVydGljYWxEaXN0ID0gX2EuZGlzdCxcbiAgICAgIF9iID0gc25hcEJvdW5kSW5mby5ob3Jpem9udGFsLFxuICAgICAgaXNIb3Jpem9udGFsQm91bmQgPSBfYi5pc0JvdW5kLFxuICAgICAgaXNIb3Jpem9udGFsU25hcCA9IF9iLmlzU25hcCxcbiAgICAgIGhvcml6b250YWxEaXN0ID0gX2IuZGlzdDtcbiAgdmFyIHJhZDE4MCA9IHJhZCAlIDE4MDtcbiAgdmFyIGlzSG9yaXpvbnRhbExpbmUgPSByYWQxODAgPCAzIHx8IHJhZDE4MCA+IDE3NztcbiAgdmFyIGlzVmVydGljYWxMaW5lID0gcmFkMTgwID4gODcgJiYgcmFkMTgwIDwgOTM7XG5cbiAgaWYgKGhvcml6b250YWxEaXN0IDwgdmVydGljYWxEaXN0KSB7XG4gICAgaWYgKGlzVmVydGljYWxCb3VuZCB8fCBpc1ZlcnRpY2FsU25hcCAmJiAhaXNWZXJ0aWNhbExpbmUgJiYgKCFrZWVwUmF0aW8gfHwgIWlzSG9yaXpvbnRhbExpbmUpKSB7XG4gICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0hvcml6b250YWxCb3VuZCB8fCBpc0hvcml6b250YWxTbmFwICYmICFpc0hvcml6b250YWxMaW5lICYmICgha2VlcFJhdGlvIHx8ICFpc1ZlcnRpY2FsTGluZSkpIHtcbiAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcEJvdW5kSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbnMsIGtlZXBSYXRpbywgaXNSZXF1ZXN0LCBkYXRhcykge1xuICByZXR1cm4gZGlyZWN0aW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHN0YXJ0RGlyZWN0aW9uID0gX2FbMF0sXG4gICAgICAgIGVuZERpcmVjdGlvbiA9IF9hWzFdO1xuICAgIHZhciBvdGhlclN0YXJ0UG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIHN0YXJ0RGlyZWN0aW9uKTtcbiAgICB2YXIgb3RoZXJFbmRQb3MgPSBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZW5kRGlyZWN0aW9uKTtcbiAgICB2YXIgc25hcEJvdW5kSW5mbyA9IGtlZXBSYXRpbyA/IGNoZWNrU25hcEJvdW5kc0tlZXBSYXRpbyhtb3ZlYWJsZSwgb3RoZXJTdGFydFBvcywgb3RoZXJFbmRQb3MsIGlzUmVxdWVzdCkgOiBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaXNSZXF1ZXN0LCB7XG4gICAgICB2ZXJ0aWNhbDogW290aGVyRW5kUG9zWzBdXSxcbiAgICAgIGhvcml6b250YWw6IFtvdGhlckVuZFBvc1sxXV1cbiAgICB9KTtcbiAgICB2YXIgX2IgPSBzbmFwQm91bmRJbmZvLmhvcml6b250YWwsXG4gICAgICAgIC8vIGRpc3Q6IG90aGVySG9yaXpvbnRhbERpc3QsXG4gICAgb3RoZXJIb3Jpem9udGFsT2Zmc2V0ID0gX2Iub2Zmc2V0LFxuICAgICAgICBpc090aGVySG9yaXpvbnRhbEJvdW5kID0gX2IuaXNCb3VuZCxcbiAgICAgICAgaXNPdGhlckhvcml6b250YWxTbmFwID0gX2IuaXNTbmFwLFxuICAgICAgICBfYyA9IHNuYXBCb3VuZEluZm8udmVydGljYWwsXG4gICAgICAgIC8vIGRpc3Q6IG90aGVyVmVydGljYWxEaXN0LFxuICAgIG90aGVyVmVydGljYWxPZmZzZXQgPSBfYy5vZmZzZXQsXG4gICAgICAgIGlzT3RoZXJWZXJ0aWNhbEJvdW5kID0gX2MuaXNCb3VuZCxcbiAgICAgICAgaXNPdGhlclZlcnRpY2FsU25hcCA9IF9jLmlzU25hcDtcbiAgICB2YXIgbXVsdGlwbGUgPSBtaW51cyhlbmREaXJlY3Rpb24sIHN0YXJ0RGlyZWN0aW9uKTtcblxuICAgIGlmICghb3RoZXJWZXJ0aWNhbE9mZnNldCAmJiAhb3RoZXJIb3Jpem9udGFsT2Zmc2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0JvdW5kOiBpc090aGVyVmVydGljYWxCb3VuZCB8fCBpc090aGVySG9yaXpvbnRhbEJvdW5kLFxuICAgICAgICBpc1NuYXA6IGlzT3RoZXJWZXJ0aWNhbFNuYXAgfHwgaXNPdGhlckhvcml6b250YWxTbmFwLFxuICAgICAgICBzaWduOiBtdWx0aXBsZSxcbiAgICAgICAgb2Zmc2V0OiBbMCwgMF1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHNuYXBMaW5lID0gY2hlY2tTbmFwUmlnaHRMaW5lKG90aGVyU3RhcnRQb3MsIG90aGVyRW5kUG9zLCBzbmFwQm91bmRJbmZvLCBrZWVwUmF0aW8pO1xuXG4gICAgaWYgKCFzbmFwTGluZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbjogbXVsdGlwbGUsXG4gICAgICAgIGlzQm91bmQ6IGZhbHNlLFxuICAgICAgICBpc1NuYXA6IGZhbHNlLFxuICAgICAgICBvZmZzZXQ6IFswLCAwXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IHNuYXBMaW5lID09PSBcInZlcnRpY2FsXCI7XG4gICAgdmFyIHNpemVPZmZzZXQgPSBzb2x2ZU5leHRPZmZzZXQob3RoZXJTdGFydFBvcywgb3RoZXJFbmRQb3MsIC0oaXNWZXJ0aWNhbCA/IG90aGVyVmVydGljYWxPZmZzZXQgOiBvdGhlckhvcml6b250YWxPZmZzZXQpLCBpc1ZlcnRpY2FsLCBkYXRhcykub2Zmc2V0Lm1hcChmdW5jdGlvbiAoc2l6ZSwgaSkge1xuICAgICAgcmV0dXJuIHNpemUgKiAobXVsdGlwbGVbaV0gPyAyIC8gbXVsdGlwbGVbaV0gOiAwKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbjogbXVsdGlwbGUsXG4gICAgICBpc0JvdW5kOiBpc1ZlcnRpY2FsID8gaXNPdGhlclZlcnRpY2FsQm91bmQgOiBpc090aGVySG9yaXpvbnRhbEJvdW5kLFxuICAgICAgaXNTbmFwOiBpc1ZlcnRpY2FsID8gaXNPdGhlclZlcnRpY2FsU25hcCA6IGlzT3RoZXJIb3Jpem9udGFsU25hcCxcbiAgICAgIG9mZnNldDogc2l6ZU9mZnNldFxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTbmFwQm91bmRPZmZzZXQoYm91bmRJbmZvLCBzbmFwSW5mbykge1xuICBpZiAoYm91bmRJbmZvLmlzQm91bmQpIHtcbiAgICByZXR1cm4gYm91bmRJbmZvLm9mZnNldDtcbiAgfSBlbHNlIGlmIChzbmFwSW5mby5pc1NuYXApIHtcbiAgICByZXR1cm4gc25hcEluZm8ub2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU25hcEJvdW5kc0tlZXBSYXRpbyhtb3ZlYWJsZSwgc3RhcnRQb3MsIGVuZFBvcywgaXNSZXF1ZXN0KSB7XG4gIHZhciBfYSA9IGNoZWNrQm91bmRLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpLFxuICAgICAgaG9yaXpvbnRhbEJvdW5kSW5mbyA9IF9hLmhvcml6b250YWwsXG4gICAgICB2ZXJ0aWNhbEJvdW5kSW5mbyA9IF9hLnZlcnRpY2FsO1xuXG4gIHZhciBfYiA9IGlzUmVxdWVzdCA/IHtcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICBpc1NuYXA6IGZhbHNlXG4gICAgfSxcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaXNTbmFwOiBmYWxzZVxuICAgIH1cbiAgfSA6IGNoZWNrU25hcEtlZXBSYXRpbyhtb3ZlYWJsZSwgc3RhcnRQb3MsIGVuZFBvcyksXG4gICAgICBob3Jpem9udGFsU25hcEluZm8gPSBfYi5ob3Jpem9udGFsLFxuICAgICAgdmVydGljYWxTbmFwSW5mbyA9IF9iLnZlcnRpY2FsO1xuXG4gIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gZ2V0U25hcEJvdW5kT2Zmc2V0KGhvcml6b250YWxCb3VuZEluZm8sIGhvcml6b250YWxTbmFwSW5mbyk7XG4gIHZhciB2ZXJ0aWNhbE9mZnNldCA9IGdldFNuYXBCb3VuZE9mZnNldCh2ZXJ0aWNhbEJvdW5kSW5mbywgdmVydGljYWxTbmFwSW5mbyk7XG4gIHZhciBob3Jpem9udGFsRGlzdCA9IE1hdGguYWJzKGhvcml6b250YWxPZmZzZXQpO1xuICB2YXIgdmVydGljYWxEaXN0ID0gTWF0aC5hYnModmVydGljYWxPZmZzZXQpO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWw6IHtcbiAgICAgIGlzQm91bmQ6IGhvcml6b250YWxCb3VuZEluZm8uaXNCb3VuZCxcbiAgICAgIGlzU25hcDogaG9yaXpvbnRhbFNuYXBJbmZvLmlzU25hcCxcbiAgICAgIG9mZnNldDogaG9yaXpvbnRhbE9mZnNldCxcbiAgICAgIGRpc3Q6IGhvcml6b250YWxEaXN0XG4gICAgfSxcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgaXNCb3VuZDogdmVydGljYWxCb3VuZEluZm8uaXNCb3VuZCxcbiAgICAgIGlzU25hcDogdmVydGljYWxTbmFwSW5mby5pc1NuYXAsXG4gICAgICBvZmZzZXQ6IHZlcnRpY2FsT2Zmc2V0LFxuICAgICAgZGlzdDogdmVydGljYWxEaXN0XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2hlY2tNYXhCb3VuZHMobW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzKSB7XG4gIHZhciBmaXhlZERpcmVjdGlvbiA9IFstZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXTtcbiAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICB2YXIgYm91bmRzID0gbW92ZWFibGUucHJvcHMuYm91bmRzO1xuICB2YXIgbWF4V2lkdGggPSBJbmZpbml0eTtcbiAgdmFyIG1heEhlaWdodCA9IEluZmluaXR5O1xuXG4gIGlmIChib3VuZHMpIHtcbiAgICB2YXIgZGlyZWN0aW9ucyA9IFtbZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXSwgWy1kaXJlY3Rpb25bMF0sIGRpcmVjdGlvblsxXV1dO1xuICAgIHZhciBfYiA9IGJvdW5kcy5sZWZ0LFxuICAgICAgICBsZWZ0XzEgPSBfYiA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2IsXG4gICAgICAgIF9jID0gYm91bmRzLnRvcCxcbiAgICAgICAgdG9wXzEgPSBfYyA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2MsXG4gICAgICAgIF9kID0gYm91bmRzLnJpZ2h0LFxuICAgICAgICByaWdodF8xID0gX2QgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2QsXG4gICAgICAgIF9lID0gYm91bmRzLmJvdHRvbSxcbiAgICAgICAgYm90dG9tXzEgPSBfZSA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZTtcbiAgICBkaXJlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKG90aGVyRGlyZWN0aW9uKSB7XG4gICAgICB2YXIgaXNDaGVja1ZlcnRpY2FsID0gb3RoZXJEaXJlY3Rpb25bMF0gIT09IGZpeGVkRGlyZWN0aW9uWzBdO1xuICAgICAgdmFyIGlzQ2hlY2tIb3Jpem9udGFsID0gb3RoZXJEaXJlY3Rpb25bMV0gIT09IGZpeGVkRGlyZWN0aW9uWzFdO1xuICAgICAgdmFyIG90aGVyUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIG90aGVyRGlyZWN0aW9uKTtcbiAgICAgIHZhciBkZWcgPSBnZXRSYWQoZml4ZWRQb3NpdGlvbiwgb3RoZXJQb3MpICogMzYwIC8gTWF0aC5QSTtcblxuICAgICAgaWYgKGlzQ2hlY2tIb3Jpem9udGFsKSB7XG4gICAgICAgIHZhciBuZXh0T3RoZXJQb3MgPSBvdGhlclBvcy5zbGljZSgpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkZWcgLSAzNjApIDwgMiB8fCBNYXRoLmFicyhkZWcgLSAxODApIDwgMikge1xuICAgICAgICAgIG5leHRPdGhlclBvc1sxXSA9IGZpeGVkUG9zaXRpb25bMV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2EgPSBzb2x2ZU5leHRPZmZzZXQoZml4ZWRQb3NpdGlvbiwgbmV4dE90aGVyUG9zLCAoZml4ZWRQb3NpdGlvblsxXSA8IG90aGVyUG9zWzFdID8gYm90dG9tXzEgOiB0b3BfMSkgLSBvdGhlclBvc1sxXSwgZmFsc2UsIGRhdGFzKSxcbiAgICAgICAgICAgIF9iID0gX2Eub2Zmc2V0LFxuICAgICAgICAgICAgaGVpZ2h0T2Zmc2V0ID0gX2JbMV0sXG4gICAgICAgICAgICBpc0hlaWdodE91dHNpZGUgPSBfYS5pc091dHNpZGU7XG5cbiAgICAgICAgaWYgKCFpc05hTihoZWlnaHRPZmZzZXQpKSB7XG4gICAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0ICsgKGlzSGVpZ2h0T3V0c2lkZSA/IDEgOiAtMSkgKiBNYXRoLmFicyhoZWlnaHRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0NoZWNrVmVydGljYWwpIHtcbiAgICAgICAgdmFyIG5leHRPdGhlclBvcyA9IG90aGVyUG9zLnNsaWNlKCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRlZyAtIDkwKSA8IDIgfHwgTWF0aC5hYnMoZGVnIC0gMjcwKSA8IDIpIHtcbiAgICAgICAgICBuZXh0T3RoZXJQb3NbMF0gPSBmaXhlZFBvc2l0aW9uWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9jID0gc29sdmVOZXh0T2Zmc2V0KGZpeGVkUG9zaXRpb24sIG5leHRPdGhlclBvcywgKGZpeGVkUG9zaXRpb25bMF0gPCBvdGhlclBvc1swXSA/IHJpZ2h0XzEgOiBsZWZ0XzEpIC0gb3RoZXJQb3NbMF0sIHRydWUsIGRhdGFzKSxcbiAgICAgICAgICAgIHdpZHRoT2Zmc2V0ID0gX2Mub2Zmc2V0WzBdLFxuICAgICAgICAgICAgaXNXaWR0aE91dHNpZGUgPSBfYy5pc091dHNpZGU7XG5cbiAgICAgICAgaWYgKCFpc05hTih3aWR0aE9mZnNldCkpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IHdpZHRoICsgKGlzV2lkdGhPdXRzaWRlID8gMSA6IC0xKSAqIE1hdGguYWJzKHdpZHRoT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXhXaWR0aDogbWF4V2lkdGgsXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gc25hcFN0YXJ0KG1vdmVhYmxlKSB7XG4gIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS5ndWlkZWxpbmVzICYmIHN0YXRlLmd1aWRlbGluZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lciA9IG1vdmVhYmxlLnN0YXRlLmNvbnRhaW5lcjtcbiAgdmFyIHNuYXBDb250YWluZXIgPSBtb3ZlYWJsZS5wcm9wcy5zbmFwQ29udGFpbmVyIHx8IGNvbnRhaW5lcjtcbiAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSBzdGF0ZS5jb250YWluZXJDbGllbnRSZWN0O1xuICB2YXIgc25hcE9mZnNldCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgcmlnaHQ6IDBcbiAgfTtcblxuICBpZiAoY29udGFpbmVyICE9PSBzbmFwQ29udGFpbmVyKSB7XG4gICAgdmFyIHNuYXBDb250YWluZXJUYXJnZXQgPSBnZXRSZWZUYXJnZXQoc25hcENvbnRhaW5lciwgdHJ1ZSk7XG5cbiAgICBpZiAoc25hcENvbnRhaW5lclRhcmdldCkge1xuICAgICAgdmFyIHNuYXBDb250YWluZXJSZWN0ID0gZ2V0Q2xpZW50UmVjdChzbmFwQ29udGFpbmVyVGFyZ2V0KTtcbiAgICAgIHZhciBvZmZzZXQxID0gZ2V0RHJhZ0Rpc3RCeVN0YXRlKHN0YXRlLCBbc25hcENvbnRhaW5lclJlY3QubGVmdCAtIGNvbnRhaW5lckNsaWVudFJlY3QubGVmdCwgc25hcENvbnRhaW5lclJlY3QudG9wIC0gY29udGFpbmVyQ2xpZW50UmVjdC50b3BdKTtcbiAgICAgIHZhciBvZmZzZXQyID0gZ2V0RHJhZ0Rpc3RCeVN0YXRlKHN0YXRlLCBbc25hcENvbnRhaW5lclJlY3QucmlnaHQgLSBjb250YWluZXJDbGllbnRSZWN0LnJpZ2h0LCBzbmFwQ29udGFpbmVyUmVjdC5ib3R0b20gLSBjb250YWluZXJDbGllbnRSZWN0LmJvdHRvbV0pO1xuICAgICAgc25hcE9mZnNldC5sZWZ0ID0gdGhyb3R0bGUob2Zmc2V0MVswXSwgMC4xKTtcbiAgICAgIHNuYXBPZmZzZXQudG9wID0gdGhyb3R0bGUob2Zmc2V0MVsxXSwgMC4xKTtcbiAgICAgIHNuYXBPZmZzZXQucmlnaHQgPSB0aHJvdHRsZShvZmZzZXQyWzBdLCAwLjEpO1xuICAgICAgc25hcE9mZnNldC5ib3R0b20gPSB0aHJvdHRsZShvZmZzZXQyWzFdLCAwLjEpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnNuYXBPZmZzZXQgPSBzbmFwT2Zmc2V0O1xuICBzdGF0ZS5ndWlkZWxpbmVzID0gZ2V0VG90YWxHdWlkZWxpbmVzKG1vdmVhYmxlKTtcbiAgc3RhdGUuZW5hYmxlU25hcCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRGaXhlZFBvc2VzKG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgZml4ZWRQb3MsIGRpcmVjdGlvbiwgaXMzZCkge1xuICB2YXIgbmV4dFBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBpczNkID8gNCA6IDMpO1xuICB2YXIgbmV4dFBvcyA9IGdldFBvc0J5UmV2ZXJzZURpcmVjdGlvbihuZXh0UG9zZXMsIGRpcmVjdGlvbik7XG4gIHJldHVybiBnZXRBYnNvbHV0ZVBvc2VzKG5leHRQb3NlcywgbWludXMoZml4ZWRQb3MsIG5leHRQb3MpKTtcbn1cbmZ1bmN0aW9uIGdldFNpemVPZmZzZXRJbmZvKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9uLCBrZWVwUmF0aW8sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgdmFyIGRpcmVjdGlvbnMgPSBnZXRDaGVja1NuYXBEaXJlY3Rpb25zKGRpcmVjdGlvbiwga2VlcFJhdGlvKTtcbiAgdmFyIGxpbmVzID0gZ2V0Q2hlY2tJbm5lckJvdW5kTGluZXMocG9zZXMsIGRpcmVjdGlvbiwga2VlcFJhdGlvKTtcblxuICB2YXIgb2Zmc2V0cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgZ2V0U25hcEJvdW5kSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbnMsIGtlZXBSYXRpbywgaXNSZXF1ZXN0LCBkYXRhcykpLCBnZXRJbm5lckJvdW5kSW5mbyhtb3ZlYWJsZSwgbGluZXMsIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBbMCwgMF0pLCBkYXRhcykpO1xuXG4gIHZhciB3aWR0aE9mZnNldEluZm8gPSBnZXROZWFyT2Zmc2V0SW5mbyhvZmZzZXRzLCAwKTtcbiAgdmFyIGhlaWdodE9mZnNldEluZm8gPSBnZXROZWFyT2Zmc2V0SW5mbyhvZmZzZXRzLCAxKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDoge1xuICAgICAgaXNCb3VuZDogd2lkdGhPZmZzZXRJbmZvLmlzQm91bmQsXG4gICAgICBvZmZzZXQ6IHdpZHRoT2Zmc2V0SW5mby5vZmZzZXRbMF1cbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgaXNCb3VuZDogaGVpZ2h0T2Zmc2V0SW5mby5pc0JvdW5kLFxuICAgICAgb2Zmc2V0OiBoZWlnaHRPZmZzZXRJbmZvLm9mZnNldFsxXVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY2hlY2tTaXplQnlUd29EaXJlY3Rpb24obW92ZWFibGUsIHBvc2VzLCB3aWR0aCwgaGVpZ2h0LCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBkaXJlY3Rpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgdmFyIHNuYXBQb3MgPSBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZGlyZWN0aW9uKTtcblxuICB2YXIgX2EgPSBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaXNSZXF1ZXN0LCB7XG4gICAgdmVydGljYWw6IFtzbmFwUG9zWzBdXSxcbiAgICBob3Jpem9udGFsOiBbc25hcFBvc1sxXV1cbiAgfSksXG4gICAgICBob3Jpem9udGFsT2Zmc2V0ID0gX2EuaG9yaXpvbnRhbC5vZmZzZXQsXG4gICAgICB2ZXJ0aWNhbE9mZnNldCA9IF9hLnZlcnRpY2FsLm9mZnNldDtcblxuICBpZiAodmVydGljYWxPZmZzZXQgfHwgaG9yaXpvbnRhbE9mZnNldCkge1xuICAgIHZhciBfYiA9IGdldERyYWdEaXN0KHtcbiAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgIGRpc3RYOiAtdmVydGljYWxPZmZzZXQsXG4gICAgICBkaXN0WTogLWhvcml6b250YWxPZmZzZXRcbiAgICB9KSxcbiAgICAgICAgbmV4dFdpZHRoT2Zmc2V0ID0gX2JbMF0sXG4gICAgICAgIG5leHRIZWlnaHRPZmZzZXQgPSBfYlsxXTtcblxuICAgIHZhciBuZXh0V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCB8fCBJbmZpbml0eSwgd2lkdGggKyBkaXJlY3Rpb25bMF0gKiBuZXh0V2lkdGhPZmZzZXQpO1xuICAgIHZhciBuZXh0SGVpZ2h0ID0gTWF0aC5taW4obWF4SGVpZ2h0IHx8IEluZmluaXR5LCBoZWlnaHQgKyBkaXJlY3Rpb25bMV0gKiBuZXh0SGVpZ2h0T2Zmc2V0KTtcbiAgICByZXR1cm4gW25leHRXaWR0aCAtIHdpZHRoLCBuZXh0SGVpZ2h0IC0gaGVpZ2h0XTtcbiAgfVxuXG4gIHJldHVybiBbMCwgMF07XG59XG5mdW5jdGlvbiBjaGVja1NpemVEaXN0KG1vdmVhYmxlLCBnZXROZXh0UG9zZXMsIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcykge1xuICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSk7XG4gIHZhciBrZWVwUmF0aW8gPSBtb3ZlYWJsZS5wcm9wcy5rZWVwUmF0aW87XG4gIHZhciB3aWR0aE9mZnNldCA9IDA7XG4gIHZhciBoZWlnaHRPZmZzZXQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgdmFyIG5leHRQb3NlcyA9IGdldE5leHRQb3Nlcyh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KTtcblxuICAgIHZhciBfYSA9IGdldFNpemVPZmZzZXRJbmZvKG1vdmVhYmxlLCBuZXh0UG9zZXMsIGRpcmVjdGlvbiwga2VlcFJhdGlvLCBpc1JlcXVlc3QsIGRhdGFzKSxcbiAgICAgICAgd2lkdGhPZmZzZXRJbmZvID0gX2Eud2lkdGgsXG4gICAgICAgIGhlaWdodE9mZnNldEluZm8gPSBfYS5oZWlnaHQ7XG5cbiAgICB2YXIgaXNXaWR0aEJvdW5kID0gd2lkdGhPZmZzZXRJbmZvLmlzQm91bmQ7XG4gICAgdmFyIGlzSGVpZ2h0Qm91bmQgPSBoZWlnaHRPZmZzZXRJbmZvLmlzQm91bmQ7XG4gICAgdmFyIG5leHRXaWR0aE9mZnNldCA9IHdpZHRoT2Zmc2V0SW5mby5vZmZzZXQ7XG4gICAgdmFyIG5leHRIZWlnaHRPZmZzZXQgPSBoZWlnaHRPZmZzZXRJbmZvLm9mZnNldDtcblxuICAgIGlmIChpID09PSAxKSB7XG4gICAgICBpZiAoIWlzV2lkdGhCb3VuZCkge1xuICAgICAgICBuZXh0V2lkdGhPZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzSGVpZ2h0Qm91bmQpIHtcbiAgICAgICAgbmV4dEhlaWdodE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IDAgJiYgaXNSZXF1ZXN0ICYmICFpc1dpZHRoQm91bmQgJiYgIWlzSGVpZ2h0Qm91bmQpIHtcbiAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuXG4gICAgaWYgKGtlZXBSYXRpbykge1xuICAgICAgdmFyIHdpZHRoRGlzdCA9IE1hdGguYWJzKG5leHRXaWR0aE9mZnNldCkgKiAod2lkdGggPyAxIC8gd2lkdGggOiAxKTtcbiAgICAgIHZhciBoZWlnaHREaXN0ID0gTWF0aC5hYnMobmV4dEhlaWdodE9mZnNldCkgKiAoaGVpZ2h0ID8gMSAvIGhlaWdodCA6IDEpO1xuICAgICAgdmFyIGlzR2V0V2lkdGhPZmZzZXQgPSBpc1dpZHRoQm91bmQgJiYgaXNIZWlnaHRCb3VuZCA/IHdpZHRoRGlzdCA8IGhlaWdodERpc3QgOiBpc0hlaWdodEJvdW5kIHx8ICFpc1dpZHRoQm91bmQgJiYgd2lkdGhEaXN0IDwgaGVpZ2h0RGlzdDtcblxuICAgICAgaWYgKGlzR2V0V2lkdGhPZmZzZXQpIHtcbiAgICAgICAgLy8gd2lkdGggOiBoZWlnaHQgPSA/IDogaGVpZ2h0T2Zmc2V0XG4gICAgICAgIG5leHRXaWR0aE9mZnNldCA9IHdpZHRoICogbmV4dEhlaWdodE9mZnNldCAvIGhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdpZHRoIDogaGVpZ2h0ID0gd2lkdGhPZmZzZXQgOiA/XG4gICAgICAgIG5leHRIZWlnaHRPZmZzZXQgPSBoZWlnaHQgKiBuZXh0V2lkdGhPZmZzZXQgLyB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aWR0aE9mZnNldCArPSBuZXh0V2lkdGhPZmZzZXQ7XG4gICAgaGVpZ2h0T2Zmc2V0ICs9IG5leHRIZWlnaHRPZmZzZXQ7XG4gIH1cblxuICBpZiAoZGlyZWN0aW9uWzBdICYmIGRpcmVjdGlvblsxXSkge1xuICAgIHZhciBfYiA9IGNoZWNrTWF4Qm91bmRzKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcyksXG4gICAgICAgIG1heFdpZHRoID0gX2IubWF4V2lkdGgsXG4gICAgICAgIG1heEhlaWdodCA9IF9iLm1heEhlaWdodDtcblxuICAgIHZhciBfYyA9IHJlY2hlY2tTaXplQnlUd29EaXJlY3Rpb24obW92ZWFibGUsIGdldE5leHRQb3Nlcyh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHRocm90dGxlKHAsIEZMT0FUX1BPSU5UX05VTSk7XG4gICAgICB9KTtcbiAgICB9KSwgd2lkdGggKyB3aWR0aE9mZnNldCwgaGVpZ2h0ICsgaGVpZ2h0T2Zmc2V0LCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBkaXJlY3Rpb24sIGlzUmVxdWVzdCwgZGF0YXMpLFxuICAgICAgICBuZXh0V2lkdGhPZmZzZXQgPSBfY1swXSxcbiAgICAgICAgbmV4dEhlaWdodE9mZnNldCA9IF9jWzFdO1xuXG4gICAgd2lkdGhPZmZzZXQgKz0gbmV4dFdpZHRoT2Zmc2V0O1xuICAgIGhlaWdodE9mZnNldCArPSBuZXh0SGVpZ2h0T2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIFt3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIGNoZWNrU25hcFJvdGF0ZShtb3ZlYWJsZSwgcmVjdCwgb3JpZ2luLCByb3RhdGlvbikge1xuICBpZiAoIWhhc0d1aWRlbGluZXMobW92ZWFibGUsIFwicm90YXRhYmxlXCIpKSB7XG4gICAgcmV0dXJuIHJvdGF0aW9uO1xuICB9XG5cbiAgdmFyIHBvczEgPSByZWN0LnBvczEsXG4gICAgICBwb3MyID0gcmVjdC5wb3MyLFxuICAgICAgcG9zMyA9IHJlY3QucG9zMyxcbiAgICAgIHBvczQgPSByZWN0LnBvczQ7XG4gIHZhciByYWQgPSByb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG4gIHZhciBwcmV2UG9zZXMgPSBbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gbWludXMocG9zLCBvcmlnaW4pO1xuICB9KTtcbiAgdmFyIG5leHRQb3NlcyA9IHByZXZQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiByb3RhdGUocG9zLCByYWQpO1xuICB9KTtcblxuICB2YXIgcmVzdWx0ID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBjaGVja1JvdGF0ZUJvdW5kcyhtb3ZlYWJsZSwgcHJldlBvc2VzLCBuZXh0UG9zZXMsIG9yaWdpbiwgcm90YXRpb24pKSwgY2hlY2tSb3RhdGVJbm5lckJvdW5kcyhtb3ZlYWJsZSwgcHJldlBvc2VzLCBuZXh0UG9zZXMsIG9yaWdpbiwgcm90YXRpb24pKTtcblxuICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhhIC0gcm90YXRpb24pIC0gTWF0aC5hYnMoYiAtIHJvdGF0aW9uKTtcbiAgfSk7XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tTbmFwUmVzaXplKG1vdmVhYmxlLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcbiAgaWYgKCFoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcInJlc2l6YWJsZVwiKSkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cblxuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIGFsbE1hdHJpeCA9IF9hLmFsbE1hdHJpeCxcbiAgICAgIGlzM2QgPSBfYS5pczNkO1xuICByZXR1cm4gY2hlY2tTaXplRGlzdChtb3ZlYWJsZSwgZnVuY3Rpb24gKHdpZHRoT2Zmc2V0LCBoZWlnaHRPZmZzZXQpIHtcbiAgICByZXR1cm4gZ2V0TmV4dEZpeGVkUG9zZXMoYWxsTWF0cml4LCB3aWR0aCArIHdpZHRoT2Zmc2V0LCBoZWlnaHQgKyBoZWlnaHRPZmZzZXQsIGZpeGVkUG9zaXRpb24sIGRpcmVjdGlvbiwgaXMzZCk7XG4gIH0sIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyk7XG59XG5mdW5jdGlvbiBjaGVja1NuYXBTY2FsZShtb3ZlYWJsZSwgc2NhbGUsIGRpcmVjdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcykge1xuICB2YXIgd2lkdGggPSBkYXRhcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IGRhdGFzLmhlaWdodCxcbiAgICAgIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xuXG4gIGlmICghaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJzY2FsYWJsZVwiKSkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cblxuICB2YXIgaXMzZCA9IGRhdGFzLmlzM2Q7XG4gIHZhciBzaXplRGlzdCA9IGNoZWNrU2l6ZURpc3QobW92ZWFibGUsIGZ1bmN0aW9uICh3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0KSB7XG4gICAgcmV0dXJuIGdldE5leHRGaXhlZFBvc2VzKHNjYWxlTWF0cml4KGRhdGFzLCBwbHVzKHNjYWxlLCBbd2lkdGhPZmZzZXQgLyB3aWR0aCwgaGVpZ2h0T2Zmc2V0IC8gaGVpZ2h0XSkpLCB3aWR0aCwgaGVpZ2h0LCBmaXhlZFBvc2l0aW9uLCBkaXJlY3Rpb24sIGlzM2QpO1xuICB9LCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpO1xuICByZXR1cm4gW3NpemVEaXN0WzBdIC8gd2lkdGgsIHNpemVEaXN0WzFdIC8gaGVpZ2h0XTtcbn1cbmZ1bmN0aW9uIHN0YXJ0Q2hlY2tTbmFwRHJhZyhtb3ZlYWJsZSwgZGF0YXMpIHtcbiAgZGF0YXMuYWJzb2x1dGVQb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcEd1aWRlbGluZXMocG9zSW5mb3MpIHtcbiAgdmFyIGd1aWRlbGluZXMgPSBbXTtcbiAgcG9zSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAocG9zSW5mbykge1xuICAgIHBvc0luZm8uZ3VpZGVsaW5lSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmU7XG5cbiAgICAgIGlmIChndWlkZWxpbmVzLmluZGV4T2YoZ3VpZGVsaW5lKSA+IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZ3VpZGVsaW5lcy5wdXNoKGd1aWRlbGluZSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZ3VpZGVsaW5lcztcbn1cblxuZnVuY3Rpb24gYWRkQm91bmRHdWlkZWxpbmVzKG1vdmVhYmxlLCB2ZXJ0aWNhbFBvc2VzLCBob3Jpem9udGFsUG9zZXMsIHZlcnRpY2FsU25hcFBvc2VzLCBob3Jpem9udGFsU25hcFBvc2VzLCBleHRlcm5hbEJvdW5kcykge1xuICB2YXIgX2EgPSBjaGVja0JvdW5kUG9zZXMoZ2V0Qm91bmRzKG1vdmVhYmxlLCBleHRlcm5hbEJvdW5kcyksIHZlcnRpY2FsUG9zZXMsIGhvcml6b250YWxQb3NlcyksXG4gICAgICB2ZXJ0aWNhbEJvdW5kSW5mb3MgPSBfYS52ZXJ0aWNhbCxcbiAgICAgIGhvcml6b250YWxCb3VuZEluZm9zID0gX2EuaG9yaXpvbnRhbDtcblxuICB2ZXJ0aWNhbEJvdW5kSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgIGlmIChpbmZvLmlzQm91bmQpIHtcbiAgICAgIHZlcnRpY2FsU25hcFBvc2VzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImJvdW5kc1wiLFxuICAgICAgICBwb3M6IGluZm8ucG9zXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBob3Jpem9udGFsQm91bmRJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgaWYgKGluZm8uaXNCb3VuZCkge1xuICAgICAgaG9yaXpvbnRhbFNuYXBQb3Nlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJib3VuZHNcIixcbiAgICAgICAgcG9zOiBpbmZvLnBvc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgX2IgPSBjaGVja0lubmVyQm91bmRQb3Nlcyhtb3ZlYWJsZSksXG4gICAgICB2ZXJ0aWNhbElubmVyQm91bmRQb3NlcyA9IF9iLnZlcnRpY2FsLFxuICAgICAgaG9yaXpvbnRhbElubmVyQm91bmRQb3NlcyA9IF9iLmhvcml6b250YWw7XG5cbiAgdmVydGljYWxJbm5lckJvdW5kUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5uZXJQb3MpIHtcbiAgICBpZiAoZmluZEluZGV4KHZlcnRpY2FsU25hcFBvc2VzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciB0eXBlID0gX2EudHlwZSxcbiAgICAgICAgICBwb3MgPSBfYS5wb3M7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gXCJib3VuZHNcIiAmJiBwb3MgPT09IGlubmVyUG9zO1xuICAgIH0pID49IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2ZXJ0aWNhbFNuYXBQb3Nlcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiYm91bmRzXCIsXG4gICAgICBwb3M6IGlubmVyUG9zXG4gICAgfSk7XG4gIH0pO1xuICBob3Jpem9udGFsSW5uZXJCb3VuZFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGlubmVyUG9zKSB7XG4gICAgaWYgKGZpbmRJbmRleChob3Jpem9udGFsU25hcFBvc2VzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciB0eXBlID0gX2EudHlwZSxcbiAgICAgICAgICBwb3MgPSBfYS5wb3M7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gXCJib3VuZHNcIiAmJiBwb3MgPT09IGlubmVyUG9zO1xuICAgIH0pID49IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBob3Jpem9udGFsU25hcFBvc2VzLnB1c2goe1xuICAgICAgdHlwZTogXCJib3VuZHNcIixcbiAgICAgIHBvczogaW5uZXJQb3NcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuU25hcHBhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBzbmFwcGVkIHRvIHRoZSBndWlkZWxpbmUuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBzb3J0IDJcbiAqL1xuXG5cbnZhciBTbmFwcGFibGUgPSB7XG4gIG5hbWU6IFwic25hcHBhYmxlXCIsXG4gIGRyYWdSZWxhdGlvbjogXCJzdHJvbmdcIixcbiAgcHJvcHM6IHtcbiAgICBzbmFwcGFibGU6IFtCb29sZWFuLCBBcnJheV0sXG4gICAgc25hcENvbnRhaW5lcjogT2JqZWN0LFxuICAgIHNuYXBEaXJlY3Rpb25zOiBbQm9vbGVhbiwgT2JqZWN0XSxcbiAgICBlbGVtZW50U25hcERpcmVjdGlvbnM6IFtCb29sZWFuLCBPYmplY3RdLFxuICAgIHNuYXBHYXA6IEJvb2xlYW4sXG4gICAgc25hcEdyaWRXaWR0aDogTnVtYmVyLFxuICAgIHNuYXBHcmlkSGVpZ2h0OiBOdW1iZXIsXG4gICAgaXNEaXNwbGF5U25hcERpZ2l0OiBCb29sZWFuLFxuICAgIGlzRGlzcGxheUlubmVyU25hcERpZ2l0OiBCb29sZWFuLFxuICAgIHNuYXBEaWdpdDogTnVtYmVyLFxuICAgIHNuYXBUaHJlc2hvbGQ6IE51bWJlcixcbiAgICBob3Jpem9udGFsR3VpZGVsaW5lczogQXJyYXksXG4gICAgdmVydGljYWxHdWlkZWxpbmVzOiBBcnJheSxcbiAgICBlbGVtZW50R3VpZGVsaW5lczogQXJyYXksXG4gICAgYm91bmRzOiBPYmplY3QsXG4gICAgaW5uZXJCb3VuZHM6IE9iamVjdCxcbiAgICBzbmFwRGlzdEZvcm1hdDogRnVuY3Rpb25cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25TbmFwOiBcInNuYXBcIlxuICB9LFxuICBjc3M6IFtcIjpob3N0IHtcXG4gICAgLS1ib3VuZHMtY29sb3I6ICNkNjY7XFxufVxcbi5ndWlkZWxpbmUge1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgei1pbmRleDogMjtcXG59XFxuLmd1aWRlbGluZS5ib3VuZHMge1xcbiAgICBiYWNrZ3JvdW5kOiAjZDY2O1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1ib3VuZHMtY29sb3IpO1xcbn1cXG4uZ3VpZGVsaW5lLWdyb3VwIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxufVxcbi5ndWlkZWxpbmUtZ3JvdXAgLnNpemUtdmFsdWUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGNvbG9yOiAjZjU1O1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4uZ3VpZGVsaW5lLWdyb3VwLmhvcml6b250YWwgLnNpemUtdmFsdWUge1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTAwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIGJvdHRvbTogNXB4O1xcbn1cXG4uZ3VpZGVsaW5lLWdyb3VwLnZlcnRpY2FsIC5zaXplLXZhbHVlIHtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogMCUgNTAlO1xcbiAgICB0b3A6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbiAgICBsZWZ0OiA1cHg7XFxufVxcbi5ndWlkZWxpbmUuZ2FwIHtcXG4gICAgYmFja2dyb3VuZDogI2Y1NTtcXG59XFxuLnNpemUtdmFsdWUuZ2FwIHtcXG4gICAgY29sb3I6ICNmNTU7XFxufVxcblwiXSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgdmFyIHRhcmdldFRvcCA9IHN0YXRlLnRvcCxcbiAgICAgICAgdGFyZ2V0TGVmdCA9IHN0YXRlLmxlZnQsXG4gICAgICAgIHBvczEgPSBzdGF0ZS5wb3MxLFxuICAgICAgICBwb3MyID0gc3RhdGUucG9zMixcbiAgICAgICAgcG9zMyA9IHN0YXRlLnBvczMsXG4gICAgICAgIHBvczQgPSBzdGF0ZS5wb3M0LFxuICAgICAgICBzbmFwUmVuZGVySW5mbyA9IHN0YXRlLnNuYXBSZW5kZXJJbmZvO1xuXG4gICAgaWYgKCFzbmFwUmVuZGVySW5mbyB8fCAhaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJcIikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBzdGF0ZS5ndWlkZWxpbmVzID0gZ2V0VG90YWxHdWlkZWxpbmVzKG1vdmVhYmxlKTtcbiAgICB2YXIgbWluTGVmdCA9IE1hdGgubWluKHBvczFbMF0sIHBvczJbMF0sIHBvczNbMF0sIHBvczRbMF0pO1xuICAgIHZhciBtaW5Ub3AgPSBNYXRoLm1pbihwb3MxWzFdLCBwb3MyWzFdLCBwb3MzWzFdLCBwb3M0WzFdKTtcbiAgICB2YXIgZXh0ZXJuYWxQb3NlcyA9IHNuYXBSZW5kZXJJbmZvLmV4dGVybmFsUG9zZXMgfHwgW107XG4gICAgdmFyIHBvc2VzID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUobW92ZWFibGUuc3RhdGUpO1xuICAgIHZhciB2ZXJ0aWNhbFNuYXBQb3NlcyA9IFtdO1xuICAgIHZhciBob3Jpem9udGFsU25hcFBvc2VzID0gW107XG4gICAgdmFyIHZlcnRpY2FsR3VpZGVsaW5lcyA9IFtdO1xuICAgIHZhciBob3Jpem9udGFsR3VpZGVsaW5lcyA9IFtdO1xuICAgIHZhciBzbmFwSW5mb3MgPSBbXTtcblxuICAgIHZhciBfYSA9IGdldFJlY3QocG9zZXMpLFxuICAgICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYS5oZWlnaHQsXG4gICAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgICAgbGVmdCA9IF9hLmxlZnQsXG4gICAgICAgIGJvdHRvbSA9IF9hLmJvdHRvbSxcbiAgICAgICAgcmlnaHQgPSBfYS5yaWdodDtcblxuICAgIHZhciB0YXJnZXRSZWN0ID0ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICBjZW50ZXI6IChsZWZ0ICsgcmlnaHQpIC8gMixcbiAgICAgIG1pZGRsZTogKHRvcCArIGJvdHRvbSkgLyAyXG4gICAgfTtcbiAgICB2YXIgaGFzRXh0ZXJuYWxQb3NlcyA9IGV4dGVybmFsUG9zZXMubGVuZ3RoID4gMDtcbiAgICB2YXIgZXh0ZXJuYWxSZWN0ID0gaGFzRXh0ZXJuYWxQb3NlcyA/IGdldFJlY3QoZXh0ZXJuYWxQb3NlcykgOiB7fTtcblxuICAgIGlmICghc25hcFJlbmRlckluZm8ucmVxdWVzdCkge1xuICAgICAgaWYgKHNuYXBSZW5kZXJJbmZvLmRpcmVjdGlvbikge1xuICAgICAgICBzbmFwSW5mb3MucHVzaChnZXRTbmFwSW5mb3NCeURpcmVjdGlvbihtb3ZlYWJsZSwgcG9zZXMsIHNuYXBSZW5kZXJJbmZvLmRpcmVjdGlvbikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc25hcFJlbmRlckluZm8uc25hcCkge1xuICAgICAgICB2YXIgcmVjdCA9IGdldFJlY3QocG9zZXMpO1xuXG4gICAgICAgIGlmIChzbmFwUmVuZGVySW5mby5jZW50ZXIpIHtcbiAgICAgICAgICByZWN0Lm1pZGRsZSA9IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDI7XG4gICAgICAgICAgcmVjdC5jZW50ZXIgPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgc25hcEluZm9zLnB1c2goY2hlY2tTbmFwcyhtb3ZlYWJsZSwgcmVjdCwgMSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzRXh0ZXJuYWxQb3Nlcykge1xuICAgICAgICBpZiAoc25hcFJlbmRlckluZm8uY2VudGVyKSB7XG4gICAgICAgICAgZXh0ZXJuYWxSZWN0Lm1pZGRsZSA9IChleHRlcm5hbFJlY3QudG9wICsgZXh0ZXJuYWxSZWN0LmJvdHRvbSkgLyAyO1xuICAgICAgICAgIGV4dGVybmFsUmVjdC5jZW50ZXIgPSAoZXh0ZXJuYWxSZWN0LmxlZnQgKyBleHRlcm5hbFJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNuYXBJbmZvcy5wdXNoKGNoZWNrU25hcHMobW92ZWFibGUsIGV4dGVybmFsUmVjdCwgMSkpO1xuICAgICAgfVxuXG4gICAgICBzbmFwSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoc25hcEluZm8pIHtcbiAgICAgICAgdmFyIHZlcnRpY2FsUG9zSW5mb3MgPSBzbmFwSW5mby52ZXJ0aWNhbC5wb3NJbmZvcyxcbiAgICAgICAgICAgIGhvcml6b250YWxQb3NJbmZvcyA9IHNuYXBJbmZvLmhvcml6b250YWwucG9zSW5mb3M7XG4gICAgICAgIHZlcnRpY2FsU25hcFBvc2VzLnB1c2guYXBwbHkodmVydGljYWxTbmFwUG9zZXMsIHZlcnRpY2FsUG9zSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHZhciBndWlkZWxpbmVJbmZvcyA9IF9hLmd1aWRlbGluZUluZm9zO1xuICAgICAgICAgIHJldHVybiBndWlkZWxpbmVJbmZvcy5zb21lKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGd1aWRlbGluZSA9IF9hLmd1aWRlbGluZTtcbiAgICAgICAgICAgIHJldHVybiAhZ3VpZGVsaW5lLmhpZGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAocG9zSW5mbykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInNuYXBcIixcbiAgICAgICAgICAgIHBvczogcG9zSW5mby5wb3NcbiAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICAgIGhvcml6b250YWxTbmFwUG9zZXMucHVzaC5hcHBseShob3Jpem9udGFsU25hcFBvc2VzLCBob3Jpem9udGFsUG9zSW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHZhciBndWlkZWxpbmVJbmZvcyA9IF9hLmd1aWRlbGluZUluZm9zO1xuICAgICAgICAgIHJldHVybiBndWlkZWxpbmVJbmZvcy5zb21lKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGd1aWRlbGluZSA9IF9hLmd1aWRlbGluZTtcbiAgICAgICAgICAgIHJldHVybiAhZ3VpZGVsaW5lLmhpZGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAocG9zSW5mbykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInNuYXBcIixcbiAgICAgICAgICAgIHBvczogcG9zSW5mby5wb3NcbiAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICAgIHZlcnRpY2FsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KHZlcnRpY2FsR3VpZGVsaW5lcywgZ2V0U25hcEd1aWRlbGluZXModmVydGljYWxQb3NJbmZvcykpO1xuICAgICAgICBob3Jpem9udGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KGhvcml6b250YWxHdWlkZWxpbmVzLCBnZXRTbmFwR3VpZGVsaW5lcyhob3Jpem9udGFsUG9zSW5mb3MpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZEJvdW5kR3VpZGVsaW5lcyhtb3ZlYWJsZSwgW2xlZnQsIHJpZ2h0XSwgW3RvcCwgYm90dG9tXSwgdmVydGljYWxTbmFwUG9zZXMsIGhvcml6b250YWxTbmFwUG9zZXMpO1xuXG4gICAgaWYgKGhhc0V4dGVybmFsUG9zZXMpIHtcbiAgICAgIGFkZEJvdW5kR3VpZGVsaW5lcyhtb3ZlYWJsZSwgW2V4dGVybmFsUmVjdC5sZWZ0LCBleHRlcm5hbFJlY3QucmlnaHRdLCBbZXh0ZXJuYWxSZWN0LnRvcCwgZXh0ZXJuYWxSZWN0LmJvdHRvbV0sIHZlcnRpY2FsU25hcFBvc2VzLCBob3Jpem9udGFsU25hcFBvc2VzLCBzbmFwUmVuZGVySW5mby5leHRlcm5hbEJvdW5kcyk7XG4gICAgfVxuXG4gICAgdmFyIGFsbEd1aWRlbGluZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHZlcnRpY2FsR3VpZGVsaW5lcyksIGhvcml6b250YWxHdWlkZWxpbmVzKTtcblxuICAgIHZhciBlbGVtZW50R3VpZGVsaW5lcyA9IGFsbEd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcbiAgICAgIHJldHVybiBndWlkZWxpbmUuZWxlbWVudCAmJiAhZ3VpZGVsaW5lLmdhcFJlY3RzO1xuICAgIH0pO1xuICAgIHZhciBnYXBHdWlkZWxpbmVzID0gYWxsR3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGd1aWRlbGluZSkge1xuICAgICAgcmV0dXJuIGd1aWRlbGluZS5nYXBSZWN0cztcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TbmFwXCIsIHtcbiAgICAgIGd1aWRlbGluZXM6IGFsbEd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IF9hLmVsZW1lbnQ7XG4gICAgICAgIHJldHVybiAhZWxlbWVudDtcbiAgICAgIH0pLFxuICAgICAgZWxlbWVudHM6IGVsZW1lbnRHdWlkZWxpbmVzLFxuICAgICAgZ2FwczogZ2FwR3VpZGVsaW5lc1xuICAgIH0sIHRydWUpO1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcmVuZGVyRGFzaGVkR3VpZGVsaW5lcyhtb3ZlYWJsZSwgZWxlbWVudEd1aWRlbGluZXMsIFttaW5MZWZ0LCBtaW5Ub3BdLCB0YXJnZXRSZWN0LCBSZWFjdCkpLCByZW5kZXJHYXBHdWlkZWxpbmVzKG1vdmVhYmxlLCBnYXBHdWlkZWxpbmVzLCBbbWluTGVmdCwgbWluVG9wXSwgdGFyZ2V0UmVjdCwgUmVhY3QpKSwgcmVuZGVyR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJob3Jpem9udGFsXCIsIGhvcml6b250YWxHdWlkZWxpbmVzLCBbdGFyZ2V0TGVmdCwgdGFyZ2V0VG9wXSwgdGFyZ2V0UmVjdCwgUmVhY3QpKSwgcmVuZGVyR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJ2ZXJ0aWNhbFwiLCB2ZXJ0aWNhbEd1aWRlbGluZXMsIFt0YXJnZXRMZWZ0LCB0YXJnZXRUb3BdLCB0YXJnZXRSZWN0LCBSZWFjdCkpLCByZW5kZXJTbmFwUG9zZXMobW92ZWFibGUsIFwiaG9yaXpvbnRhbFwiLCBob3Jpem9udGFsU25hcFBvc2VzLCBtaW5MZWZ0LCB0YXJnZXRUb3AsIHdpZHRoLCAwLCBSZWFjdCkpLCByZW5kZXJTbmFwUG9zZXMobW92ZWFibGUsIFwidmVydGljYWxcIiwgdmVydGljYWxTbmFwUG9zZXMsIG1pblRvcCwgdGFyZ2V0TGVmdCwgaGVpZ2h0LCAxLCBSZWFjdCkpO1xuICB9LFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXG4gICAgICBzbmFwOiB0cnVlLFxuICAgICAgY2VudGVyOiB0cnVlXG4gICAgfTtcbiAgICBzbmFwU3RhcnQobW92ZWFibGUpO1xuICB9LFxuICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICBzdGF0ZS5ndWlkZWxpbmVzID0gZ2V0VG90YWxHdWlkZWxpbmVzKG1vdmVhYmxlKTtcbiAgfSxcbiAgcGluY2hTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xuICB9LFxuICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKGRpcmVjdGlvbkNvbmRpdGlvbihtb3ZlYWJsZSwgZSkgfHwgZHJhZ0NvbnRyb2xDb25kaXRpb24obW92ZWFibGUsIGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWUuaXNSZXF1ZXN0ICYmIGUuaW5wdXRFdmVudCkge1xuICAgICAgcmV0dXJuIGhhc0NsYXNzKGUuaW5wdXRFdmVudC50YXJnZXQsIHByZWZpeChcInNuYXAtY29udHJvbFwiKSk7XG4gICAgfVxuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IG51bGw7XG4gICAgc25hcFN0YXJ0KG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHRoaXMuZHJhZyhtb3ZlYWJsZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB0aGlzLnVuc2V0KG1vdmVhYmxlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB0aGlzLmRyYWcobW92ZWFibGUpO1xuICB9LFxuICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0gbnVsbDtcbiAgICBzbmFwU3RhcnQobW92ZWFibGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB0aGlzLmRyYWcobW92ZWFibGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICB0aGlzLnVuc2V0KG1vdmVhYmxlKTtcbiAgfSxcbiAgdW5zZXQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHN0YXRlLmVuYWJsZVNuYXAgPSBmYWxzZTtcbiAgICBzdGF0ZS5ndWlkZWxpbmVzID0gW107XG4gICAgc3RhdGUuc25hcFJlbmRlckluZm8gPSBudWxsO1xuICAgIHN0YXRlLmVsZW1lbnRSZWN0cyA9IFtdO1xuICB9XG59O1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHNuYXBwZWQgdG8gdGhlIGd1aWRlbGluZS4gKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBwYWJsZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5zbmFwcGFibGUgPSB0cnVlO1xuICovXG5cbi8qKlxuICogIEEgc25hcCBjb250YWluZXIgdGhhdCBpcyB0aGUgYmFzaXMgZm9yIHNuYXAsIGJvdW5kcywgYW5kIGlubmVyQm91bmRzLiAoZGVmYXVsdDogbnVsbCA9IGNvbnRhaW5lcilcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwQ29udGFpbmVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY29udGFpbmVyXCIpKTtcbiAqXG4gKiBtb3ZlYWJsZS5zbmFwQ29udGFpbmVyID0gZG9jdW1lbnQuYm9keTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgZGlyZWN0aW9ucyB0byBzbmFwIHRvIHRoZSB0YXJnZXQuIChkZWZhdWx0OiB7IGxlZnQ6IHRydWUsIHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSB9KVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBEaXJlY3Rpb25zXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgc25hcHBhYmxlOiB0cnVlLFxuICogICBzbmFwRGlyZWN0aW9uczogdHJ1ZSxcbiAqIH0pO1xuICogLy8gc25hcCBjZW50ZXJcbiAqIG1vdmVhYmxlLnNuYXBEaXJlY3Rpb25zID0geyBsZWZ0OiB0cnVlLCB0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGNlbnRlcjogdHJ1ZSwgbWlkZGxlOiB0cnVlIH07XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIHNuYXAgZGlyZWN0aW9ucyBvZiBlbGVtZW50cy4gKGRlZmF1bHQ6IHsgbGVmdDogdHJ1ZSwgdG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlIH0pXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjZWxlbWVudFNuYXBEaXJlY3Rpb25zXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgc25hcHBhYmxlOiB0cnVlLFxuICogICBlbGVtZW50U25hcERpcmVjdGlvbnM6IHRydWUsXG4gKiB9KTtcbiAqIC8vIHNuYXAgY2VudGVyXG4gKiBtb3ZlYWJsZS5lbGVtZW50U25hcERpcmVjdGlvbnMgPSB7IGxlZnQ6IHRydWUsIHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgY2VudGVyOiB0cnVlLCBtaWRkbGU6IHRydWUgfTtcbiAqL1xuXG4vKipcbiAqIFdoZW4geW91IGRyYWcsIG1ha2UgdGhlIGdhcCBzbmFwIGluIHRoZSBlbGVtZW50IGd1aWRlbGluZXMuIChkZWZhdWx0OiB0cnVlKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBHYXBcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICBzbmFwcGFibGU6IHRydWUsXG4gKiAgIHNuYXBWZXJ0aWNhbDogdHJ1ZSxcbiAqICAgc25hcEhvcml6b250YWw6IHRydWUsXG4gKiAgIHNuYXBFbGVtZW50OiB0cnVlLFxuICogICBzbmFwR2FwOiB0cnVlLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUuc25hcEdhcCA9IGZhbHNlO1xuICovXG5cbi8qKlxuICogRGlzdGFuY2UgdmFsdWUgdGhhdCBjYW4gc25hcCB0byBndWlkZWxpbmVzLiAoZGVmYXVsdDogNSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwVGhyZXNob2xkXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnNuYXBUaHJlc2hvbGQgPSA1O1xuICovXG5cbi8qKlxuICogQWRkIGd1aWRlbGluZXMgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uLiAoZGVmYXVsdDogW10pXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjaG9yaXpvbnRhbEd1aWRlbGluZXNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuaG9yaXpvbnRhbEd1aWRlbGluZXMgPSBbMTAwLCAyMDAsIDUwMF07XG4gKi9cblxuLyoqXG4gKiBBZGQgZ3VpZGVsaW5lcyBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uLiAoZGVmYXVsdDogW10pXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjdmVydGljYWxHdWlkZWxpbmVzXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnZlcnRpY2FsR3VpZGVsaW5lcyA9IFsxMDAsIDIwMCwgNTAwXTtcbiAqL1xuXG4vKipcbiAqIEFkZCBndWlkZWxpbmVzIGZvciB0aGUgZWxlbWVudC4gKGRlZmF1bHQ6IFtdKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2VsZW1lbnRHdWlkZWxpbmVzXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmVsZW1lbnRHdWlkZWxpbmVzID0gW1xuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmVsZW1lbnRcIiksXG4gKiBdO1xuICovXG5cbi8qKlxuICogWW91IGNhbiBzZXQgdXAgYm91bmRhcmllcy4gKGRlZmF1bHQ6IG51bGwpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjYm91bmRzXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmJvdW5kcyA9IHsgbGVmdDogMCwgcmlnaHQ6IDEwMDAsIHRvcDogMCwgYm90dG9tOiAxMDAwfTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gc2V0IHVwIGlubmVyIGJvdW5kYXJpZXMuIChkZWZhdWx0OiBudWxsKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2lubmVyQm91bmRzXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmlubmVyQm91bmRzID0geyBsZWZ0OiA1MDAsIHRvcDogNTAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH07XG4gKi9cblxuLyoqXG4gKiBzbmFwIGRpc3RhbmNlIGRpZ2l0cyAoZGVmYXVsdDogMClcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwRGlnaXRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuc25hcERpZ2l0ID0gMFxuICovXG5cbi8qKlxuICogSWYgd2lkdGggc2l6ZSBpcyBncmVhdGVyIHRoYW4gMCwgeW91IGNhbiB2ZXJ0aWNhbCBzbmFwIHRvIHRoZSBncmlkLiAoZGVmYXVsdDogMClcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwR3JpZFdpZHRoXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnNuYXBHcmlkV2lkdGggPSA1O1xuICovXG5cbi8qKlxuICogSWYgaGVpZ2h0IHNpemUgaXMgZ3JlYXRlciB0aGFuIDAsIHlvdSBjYW4gaG9yaXpvbnRhbCBzbmFwIHRvIHRoZSBncmlkLiAoZGVmYXVsdDogMClcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwR3JpZEhlaWdodFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5zbmFwR3JpZEhlaWdodCA9IDU7XG4gKi9cblxuLyoqXG4gKiBXaGV0aGVyIHRvIHNob3cgc25hcCBkaXN0YW5jZSAoZGVmYXVsdDogdHJ1ZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNpc0Rpc3BsYXlTbmFwRGlnaXRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUuaXNEaXNwbGF5U25hcERpZ2l0ID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFdoZXRoZXIgdG8gc2hvdyBlbGVtZW50IGlubmVyIHNuYXAgZGlzdGFuY2UgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2lzRGlzcGxheUlubmVyU25hcERpZ2l0XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLmlzRGlzcGxheUlubmVyU25hcERpZ2l0ID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gc2V0IHRoZSB0ZXh0IGZvcm1hdCBvZiB0aGUgZGlzdGFuY2Ugc2hvd24gaW4gdGhlIGd1aWRlbGluZXMuIChkZWZhdWx0OiBzZWxmKVxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBEaXN0Rm9ybWF0XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICBzbmFwcGFibGU6IHRydWUsXG4gKiAgc25hcERpc3RGb3JtYXQ6IHYgPT4gdixcbiAqIH0pO1xuICogbW92ZWFibGUuc25hcERpc3RGb3JtYXQgPSB2ID0+IGAke3Z9cHhgO1xuICovXG5cbi8qKlxuICogV2hlbiB5b3UgZHJhZyBvciBkcmFnQ29udHJvbCwgdGhlIGBzbmFwYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU25hcHBhYmxlXG4gKiBAZXZlbnQgc25hcFxuICogQHBhcmFtIHtNb3ZlYWJsZS5TbmFwcGFibGUuT25TbmFwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc25hcGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHNuYXBwYWJsZTogdHJ1ZVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNuYXBcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblNuYXBcIiwgZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgRHJhZ2dhYmxlXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBkZXNjcmlwdGlvbiBEcmFnZ2FibGUgcmVmZXJzIHRvIHRoZSBhYmlsaXR5IHRvIGRyYWcgYW5kIG1vdmUgdGFyZ2V0cy5cbiAqL1xuXG52YXIgRHJhZ2dhYmxlID0ge1xuICBuYW1lOiBcImRyYWdnYWJsZVwiLFxuICBwcm9wczoge1xuICAgIGRyYWdnYWJsZTogQm9vbGVhbixcbiAgICB0aHJvdHRsZURyYWc6IE51bWJlcixcbiAgICB0aHJvdHRsZURyYWdSb3RhdGU6IE51bWJlcixcbiAgICBzdGFydERyYWdSb3RhdGU6IE51bWJlcixcbiAgICBlZGdlRHJhZ2dhYmxlOiBCb29sZWFuXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uRHJhZ1N0YXJ0OiBcImRyYWdTdGFydFwiLFxuICAgIG9uRHJhZzogXCJkcmFnXCIsXG4gICAgb25EcmFnRW5kOiBcImRyYWdFbmRcIixcbiAgICBvbkRyYWdHcm91cFN0YXJ0OiBcImRyYWdHcm91cFN0YXJ0XCIsXG4gICAgb25EcmFnR3JvdXA6IFwiZHJhZ0dyb3VwXCIsXG4gICAgb25EcmFnR3JvdXBFbmQ6IFwiZHJhZ0dyb3VwRW5kXCJcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIHRocm90dGxlRHJhZ1JvdGF0ZSA9IF9hLnRocm90dGxlRHJhZ1JvdGF0ZSxcbiAgICAgICAgem9vbSA9IF9hLnpvb207XG4gICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIGRyYWdJbmZvID0gX2IuZHJhZ0luZm8sXG4gICAgICAgIGJlZm9yZU9yaWdpbiA9IF9iLmJlZm9yZU9yaWdpbjtcblxuICAgIGlmICghdGhyb3R0bGVEcmFnUm90YXRlIHx8ICFkcmFnSW5mbykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBkaXN0ID0gZHJhZ0luZm8uZGlzdDtcblxuICAgIGlmICghZGlzdFswXSAmJiAhZGlzdFsxXSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGdldERpc3RTaXplKGRpc3QpO1xuICAgIHZhciByYWQgPSBnZXRSYWQoZGlzdCwgWzAsIDBdKTtcbiAgICByZXR1cm4gW1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIsIFwiaG9yaXpvbnRhbFwiLCBcImRyYWdsaW5lXCIsIFwiZGFzaGVkXCIpLFxuICAgICAga2V5OiBcImRyYWdSb3RhdGVHdWlkZWxpbmVcIixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCArIFwicHhcIixcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIGJlZm9yZU9yaWdpblswXSArIFwicHgsIFwiICsgYmVmb3JlT3JpZ2luWzFdICsgXCJweCkgcm90YXRlKFwiICsgcmFkICsgXCJyYWQpIHNjYWxlWShcIiArIHpvb20gKyBcIilcIlxuICAgICAgfVxuICAgIH0pXTtcbiAgfSxcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBwYXJlbnRFdmVudCA9IGUucGFyZW50RXZlbnQsXG4gICAgICAgIHBhcmVudEdlc3RvID0gZS5wYXJlbnRHZXN0bztcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICBnZXN0byA9IHN0YXRlLmdlc3RvO1xuXG4gICAgaWYgKGdlc3RvKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGUuZ2VzdG8gPSBwYXJlbnRHZXN0byB8fCBtb3ZlYWJsZS50YXJnZXRHZXN0bztcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgZGF0YXMuZGF0YXMgPSB7fTtcbiAgICBkYXRhcy5sZWZ0ID0gcGFyc2VGbG9hdChzdHlsZS5sZWZ0IHx8IFwiXCIpIHx8IDA7XG4gICAgZGF0YXMudG9wID0gcGFyc2VGbG9hdChzdHlsZS50b3AgfHwgXCJcIikgfHwgMDtcbiAgICBkYXRhcy5ib3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLmJvdHRvbSB8fCBcIlwiKSB8fCAwO1xuICAgIGRhdGFzLnJpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5yaWdodCB8fCBcIlwiKSB8fCAwO1xuICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBbMCwgMF07XG4gICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgICBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgoZSwgXCJ0cmFuc2xhdGVcIik7XG4gICAgc3RhcnRDaGVja1NuYXBEcmFnKG1vdmVhYmxlLCBkYXRhcyk7XG4gICAgZGF0YXMucHJldkRpc3QgPSBbMCwgMF07XG4gICAgZGF0YXMucHJldkJlZm9yZURpc3QgPSBbMCwgMF07XG4gICAgZGF0YXMuaXNEcmFnID0gZmFsc2U7XG4gICAgZGF0YXMuZGVsdGFPZmZzZXQgPSBbMCwgMF07XG4gICAgZGF0YXMuZGlzdE9mZnNldCA9IFswLCAwXTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oe1xuICAgICAgc2V0OiBmdW5jdGlvbiAodHJhbnNsYXRlKSB7XG4gICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSB0cmFuc2xhdGU7XG4gICAgICB9XG4gICAgfSwgZmlsbFRyYW5zZm9ybVN0YXJ0RXZlbnQoZSkpKTtcbiAgICB2YXIgcmVzdWx0ID0gcGFyZW50RXZlbnQgfHwgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ1N0YXJ0XCIsIHBhcmFtcyk7XG5cbiAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNEcmFnID0gdHJ1ZTtcbiAgICAgIG1vdmVhYmxlLnN0YXRlLmRyYWdJbmZvID0ge1xuICAgICAgICBzdGFydFJlY3Q6IG1vdmVhYmxlLmdldFJlY3QoKSxcbiAgICAgICAgZGlzdDogWzAsIDBdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5nZXN0byA9IG51bGw7XG4gICAgICBkYXRhcy5pc1BpbmNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzLmlzRHJhZyA/IHBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNvbHZlVHJhbnNmb3JtRXZlbnQoZSwgXCJ0cmFuc2xhdGVcIik7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgcGFyZW50RXZlbnQgPSBlLnBhcmVudEV2ZW50LFxuICAgICAgICBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnLFxuICAgICAgICBpc1BpbmNoID0gZS5pc1BpbmNoLFxuICAgICAgICBpc1JlcXVlc3QgPSBlLmlzUmVxdWVzdDtcbiAgICB2YXIgZGlzdFggPSBlLmRpc3RYLFxuICAgICAgICBkaXN0WSA9IGUuZGlzdFk7XG4gICAgdmFyIGlzRHJhZyA9IGRhdGFzLmlzRHJhZyxcbiAgICAgICAgcHJldkRpc3QgPSBkYXRhcy5wcmV2RGlzdCxcbiAgICAgICAgcHJldkJlZm9yZURpc3QgPSBkYXRhcy5wcmV2QmVmb3JlRGlzdCxcbiAgICAgICAgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWUsXG4gICAgICAgIGRpc3RPZmZzZXQgPSBkYXRhcy5kaXN0T2Zmc2V0O1xuXG4gICAgaWYgKCFpc0RyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaXN0WCArPSBkaXN0T2Zmc2V0WzBdO1xuICAgIGRpc3RZICs9IGRpc3RPZmZzZXRbMV07XG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XG4gICAgdmFyIHBhcmVudE1vdmVhYmxlID0gcHJvcHMucGFyZW50TW92ZWFibGU7XG4gICAgdmFyIHRocm90dGxlRHJhZyA9IHBhcmVudEV2ZW50ID8gMCA6IHByb3BzLnRocm90dGxlRHJhZyB8fCAwO1xuICAgIHZhciB0aHJvdHRsZURyYWdSb3RhdGUgPSBwYXJlbnRFdmVudCA/IDAgOiBwcm9wcy50aHJvdHRsZURyYWdSb3RhdGUgfHwgMDtcbiAgICB2YXIgaXNTbmFwID0gZmFsc2U7XG4gICAgdmFyIGRyYWdSb3RhdGVSYWQgPSAwO1xuXG4gICAgaWYgKCFwYXJlbnRFdmVudCAmJiB0aHJvdHRsZURyYWdSb3RhdGUgPiAwICYmIChkaXN0WCB8fCBkaXN0WSkpIHtcbiAgICAgIHZhciBzdGFydERyYWdSb3RhdGUgPSBwcm9wcy5zdGFydERyYWdSb3RhdGUgfHwgMDtcbiAgICAgIHZhciBkZWcgPSB0aHJvdHRsZShzdGFydERyYWdSb3RhdGUgKyBnZXRSYWQoWzAsIDBdLCBbZGlzdFgsIGRpc3RZXSkgKiAxODAgLyBNYXRoLlBJLCB0aHJvdHRsZURyYWdSb3RhdGUpIC0gc3RhcnREcmFnUm90YXRlO1xuICAgICAgdmFyIHJ5ID0gZGlzdFkgKiBNYXRoLmFicyhNYXRoLmNvcygoZGVnIC0gOTApIC8gMTgwICogTWF0aC5QSSkpO1xuICAgICAgdmFyIHJ4ID0gZGlzdFggKiBNYXRoLmFicyhNYXRoLmNvcyhkZWcgLyAxODAgKiBNYXRoLlBJKSk7XG4gICAgICB2YXIgciA9IGdldERpc3RTaXplKFtyeCwgcnldKTtcbiAgICAgIGRyYWdSb3RhdGVSYWQgPSBkZWcgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgZGlzdFggPSByICogTWF0aC5jb3MoZHJhZ1JvdGF0ZVJhZCk7XG4gICAgICBkaXN0WSA9IHIgKiBNYXRoLnNpbihkcmFnUm90YXRlUmFkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGluY2ggJiYgIXBhcmVudEV2ZW50ICYmICFwYXJlbnRGbGFnICYmICghdGhyb3R0bGVEcmFnUm90YXRlIHx8IGRpc3RYIHx8IGRpc3RZKSkge1xuICAgICAgdmFyIF9hID0gY2hlY2tTbmFwQm91bmRzRHJhZyhtb3ZlYWJsZSwgZGlzdFgsIGRpc3RZLCB0aHJvdHRsZURyYWdSb3RhdGUsIGlzUmVxdWVzdCwgZGF0YXMpLFxuICAgICAgICAgIHZlcnRpY2FsSW5mbyA9IF9hWzBdLFxuICAgICAgICAgIGhvcml6b250YWxJbmZvID0gX2FbMV07XG5cbiAgICAgIHZhciBpc1ZlcnRpY2FsU25hcCA9IHZlcnRpY2FsSW5mby5pc1NuYXAsXG4gICAgICAgICAgaXNWZXJ0aWNhbEJvdW5kID0gdmVydGljYWxJbmZvLmlzQm91bmQsXG4gICAgICAgICAgdmVydGljYWxPZmZzZXQgPSB2ZXJ0aWNhbEluZm8ub2Zmc2V0O1xuICAgICAgdmFyIGlzSG9yaXpvbnRhbFNuYXAgPSBob3Jpem9udGFsSW5mby5pc1NuYXAsXG4gICAgICAgICAgaXNIb3Jpem9udGFsQm91bmQgPSBob3Jpem9udGFsSW5mby5pc0JvdW5kLFxuICAgICAgICAgIGhvcml6b250YWxPZmZzZXQgPSBob3Jpem9udGFsSW5mby5vZmZzZXQ7XG4gICAgICBpc1NuYXAgPSBpc1ZlcnRpY2FsU25hcCB8fCBpc0hvcml6b250YWxTbmFwIHx8IGlzVmVydGljYWxCb3VuZCB8fCBpc0hvcml6b250YWxCb3VuZDtcbiAgICAgIGRpc3RYICs9IHZlcnRpY2FsT2Zmc2V0O1xuICAgICAgZGlzdFkgKz0gaG9yaXpvbnRhbE9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlVHJhbnNsYXRlID0gcGx1cyhnZXRCZWZvcmVEcmFnRGlzdCh7XG4gICAgICBkYXRhczogZGF0YXMsXG4gICAgICBkaXN0WDogZGlzdFgsXG4gICAgICBkaXN0WTogZGlzdFlcbiAgICB9KSwgc3RhcnRWYWx1ZSk7XG4gICAgdmFyIHRyYW5zbGF0ZSA9IHBsdXMoZ2V0VHJhbnNmb3JtRGlzdCh7XG4gICAgICBkYXRhczogZGF0YXMsXG4gICAgICBkaXN0WDogZGlzdFgsXG4gICAgICBkaXN0WTogZGlzdFlcbiAgICB9KSwgc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAoIXRocm90dGxlRHJhZ1JvdGF0ZSAmJiAhaXNTbmFwKSB7XG4gICAgICB0aHJvdHRsZUFycmF5KHRyYW5zbGF0ZSwgdGhyb3R0bGVEcmFnKTtcbiAgICAgIHRocm90dGxlQXJyYXkoYmVmb3JlVHJhbnNsYXRlLCB0aHJvdHRsZURyYWcpO1xuICAgIH1cblxuICAgIHZhciBiZWZvcmVEaXN0ID0gbWludXMoYmVmb3JlVHJhbnNsYXRlLCBzdGFydFZhbHVlKTtcbiAgICB2YXIgZGlzdCA9IG1pbnVzKHRyYW5zbGF0ZSwgc3RhcnRWYWx1ZSk7XG4gICAgdmFyIGRlbHRhID0gbWludXMoZGlzdCwgcHJldkRpc3QpO1xuICAgIHZhciBiZWZvcmVEZWx0YSA9IG1pbnVzKGJlZm9yZURpc3QsIHByZXZCZWZvcmVEaXN0KTtcbiAgICBkYXRhcy5wcmV2RGlzdCA9IGRpc3Q7XG4gICAgZGF0YXMucHJldkJlZm9yZURpc3QgPSBiZWZvcmVEaXN0O1xuICAgIGRhdGFzLnBhc3NEZWx0YSA9IGRlbHRhOyAvL2Rpc3RYIC0gKGRhdGFzLnBhc3NEaXN0WCB8fCAwKTtcbiAgICAvLyBkYXRhcy5wYXNzRGVsdGFZID0gZGlzdFkgLSAoZGF0YXMucGFzc0Rpc3RZIHx8IDApO1xuXG4gICAgZGF0YXMucGFzc0Rpc3QgPSBkaXN0OyAvL2Rpc3RYO1xuICAgIC8vIGRhdGFzLnBhc3NEaXN0WSA9IGRpc3RZO1xuXG4gICAgdmFyIGxlZnQgPSBkYXRhcy5sZWZ0ICsgYmVmb3JlRGlzdFswXTtcbiAgICB2YXIgdG9wID0gZGF0YXMudG9wICsgYmVmb3JlRGlzdFsxXTtcbiAgICB2YXIgcmlnaHQgPSBkYXRhcy5yaWdodCAtIGJlZm9yZURpc3RbMF07XG4gICAgdmFyIGJvdHRvbSA9IGRhdGFzLmJvdHRvbSAtIGJlZm9yZURpc3RbMV07XG4gICAgdmFyIG5leHRUcmFuc2Zvcm0gPSBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCBcInRyYW5zbGF0ZShcIiArIHRyYW5zbGF0ZVswXSArIFwicHgsIFwiICsgdHJhbnNsYXRlWzFdICsgXCJweClcIiwgXCJ0cmFuc2xhdGUoXCIgKyBkaXN0WzBdICsgXCJweCwgXCIgKyBkaXN0WzFdICsgXCJweClcIik7XG4gICAgZmlsbE9yaWdpbmFsVHJhbnNmb3JtKGUsIG5leHRUcmFuc2Zvcm0pO1xuICAgIG1vdmVhYmxlLnN0YXRlLmRyYWdJbmZvLmRpc3QgPSBwYXJlbnRFdmVudCA/IFswLCAwXSA6IGRpc3Q7XG5cbiAgICBpZiAoIXBhcmVudEV2ZW50ICYmICFwYXJlbnRNb3ZlYWJsZSAmJiBkZWx0YS5ldmVyeShmdW5jdGlvbiAobnVtKSB7XG4gICAgICByZXR1cm4gIW51bTtcbiAgICB9KSAmJiBiZWZvcmVEZWx0YS5zb21lKGZ1bmN0aW9uIChudW0pIHtcbiAgICAgIHJldHVybiAhbnVtO1xuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHdpZHRoID0gX2Iud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9iLmhlaWdodDtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgdHJhbnNmb3JtOiBuZXh0VHJhbnNmb3JtLFxuICAgICAgZGlzdDogZGlzdCxcbiAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlLFxuICAgICAgYmVmb3JlRGlzdDogYmVmb3JlRGlzdCxcbiAgICAgIGJlZm9yZURlbHRhOiBiZWZvcmVEZWx0YSxcbiAgICAgIGJlZm9yZVRyYW5zbGF0ZTogYmVmb3JlVHJhbnNsYXRlLFxuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGlzUGluY2g6IGlzUGluY2hcbiAgICB9KTtcbiAgICAhcGFyZW50RXZlbnQgJiYgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ1wiLCBwYXJhbXMpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG4gIGRyYWdBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgICB2YXIgX2EgPSBlLmRhdGFzLFxuICAgICAgICBkZWx0YU9mZnNldCA9IF9hLmRlbHRhT2Zmc2V0LFxuICAgICAgICBkaXN0T2Zmc2V0ID0gX2EuZGlzdE9mZnNldDtcblxuICAgIGlmIChkZWx0YU9mZnNldFswXSB8fCBkZWx0YU9mZnNldFsxXSkge1xuICAgICAgZGF0YXMuZGVsdGFPZmZzZXQgPSBbMCwgMF07XG4gICAgICBkaXN0T2Zmc2V0WzBdID0gZGVsdGFPZmZzZXRbMF07XG4gICAgICBkaXN0T2Zmc2V0WzFdID0gZGVsdGFPZmZzZXRbMV07XG4gICAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBwYXJlbnRFdmVudCA9IGUucGFyZW50RXZlbnQsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcbiAgICBtb3ZlYWJsZS5zdGF0ZS5nZXN0byA9IG51bGw7XG4gICAgbW92ZWFibGUuc3RhdGUuZHJhZ0luZm8gPSBudWxsO1xuXG4gICAgaWYgKCFkYXRhcy5pc0RyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhcy5pc0RyYWcgPSBmYWxzZTtcbiAgICB2YXIgcGFyYW0gPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XG4gICAgIXBhcmVudEV2ZW50ICYmIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdFbmRcIiwgcGFyYW0pO1xuICAgIHJldHVybiBwYXJhbTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGNsaWVudFggPSBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBlLmNsaWVudFk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEdlc3RvKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdTdGFydFwiLCBbY2xpZW50WCB8fCAwLCBjbGllbnRZIHx8IDBdLCBlLCBmYWxzZSk7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9KTtcblxuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnR3JvdXBTdGFydFwiLCBuZXh0UGFyYW1zKTtcbiAgICBkYXRhcy5pc0RyYWcgPSByZXN1bHQgIT09IGZhbHNlO1xuICAgIHJldHVybiBkYXRhcy5pc0RyYWcgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc0RyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcbiAgICB2YXIgcGFzc0RlbHRhID0gZS5kYXRhcy5wYXNzRGVsdGE7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEdlc3RvKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdcIiwgcGFzc0RlbHRhLCBlLCBmYWxzZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oe1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSwgcGFyYW1zKTtcblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdHcm91cFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gbmV4dFBhcmFtcztcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgaXNEcmFnID0gZS5pc0RyYWcsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNEcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkR2VzdG8obW92ZWFibGUsIHRoaXMsIFwiZHJhZ0VuZFwiLCBbMCwgMF0sIGUsIGZhbHNlKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnR3JvdXBFbmRcIiwgZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSkpO1xuICAgIHJldHVybiBpc0RyYWc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgTW92ZWFibGUuRHJhZ2dhYmxlI3JlcXVlc3RcbiAgICogQHBhcmFtIHtvYmplY3R9IFtlXSAtIHRoZSBkcmFnZ2FibGUncyByZXF1ZXN0IHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2UueF0gLSB4IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS55XSAtIHkgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWF0gLSBYIG51bWJlciB0byBtb3ZlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVldIC0gWSBudW1iZXIgdG8gbW92ZVxuICAgKiBAcmV0dXJuIHtNb3ZlYWJsZS5SZXF1ZXN0ZXJ9IE1vdmVhYmxlIFJlcXVlc3RlclxuICAgKiBAZXhhbXBsZVxuICAgICogLy8gSW5zdGFudGx5IFJlcXVlc3QgKHJlcXVlc3RTdGFydCAtIHJlcXVlc3QgLSByZXF1ZXN0RW5kKVxuICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcbiAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSwgdHJ1ZSk7XG4gICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIsIHsgeDogMjAwLCB5OiAxMDAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RTdGFydFxuICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIpO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0XG4gICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcbiAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IHg6IDIwMCwgeTogMTAwIH0pO1xuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIsIHsgeDogMjIwLCB5OiAxMDAgfSk7XG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyB4OiAyNDAsIHk6IDEwMCB9KTtcbiAgICpcbiAgICogLy8gcmVxdWVzdEVuZFxuICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xuICAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdmFyIGRhdGFzID0ge307XG4gICAgdmFyIHJlY3QgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XG4gICAgdmFyIGRpc3RYID0gMDtcbiAgICB2YXIgZGlzdFkgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICBpc0NvbnRyb2w6IGZhbHNlLFxuICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKFwieFwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0WCA9IGUueCAtIHJlY3QubGVmdDtcbiAgICAgICAgfSBlbHNlIGlmIChcImRlbHRhWFwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0WCArPSBlLmRlbHRhWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcInlcIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdFkgPSBlLnkgLSByZWN0LnRvcDtcbiAgICAgICAgfSBlbHNlIGlmIChcImRlbHRhWVwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0WSArPSBlLmRlbHRhWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgICAgICBkaXN0WTogZGlzdFlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIGlzRHJhZzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mbyA9IG51bGw7XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgZHJhZ2dlZC4gKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuRHJhZ2dhYmxlI2RyYWdnYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5kcmFnZ2FibGUgPSB0cnVlO1xuICovXG5cbi8qKlxuICogdGhyb3R0bGUgb2YgeCwgeSB3aGVuIGRyYWcuXG4gKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjdGhyb3R0bGVEcmFnXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnRocm90dGxlRHJhZyA9IDE7XG4gKi9cblxuLyoqXG4qIHRocm90dGxlIG9mIGFuZ2xlIG9mIHgsIHkgd2hlbiBkcmFnLlxuKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjdGhyb3R0bGVEcmFnUm90YXRlXG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4qXG4qIG1vdmVhYmxlLnRocm90dGxlRHJhZ1JvdGF0ZSA9IDQ1O1xuKi9cblxuLyoqXG4qIHN0YXJ0IGFuZ2xlIG9mIHRocm90dGxlRHJhZ1JvdGF0ZSBvZiB4LCB5IHdoZW4gZHJhZy5cbiogQG5hbWUgTW92ZWFibGUuRHJhZ2dhYmxlI3N0YXJ0RHJhZ1JvdGF0ZVxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuKlxuKiAvLyA0NSwgMTM1LCAyMjUsIDMxNVxuKiBtb3ZlYWJsZS50aHJvdHRsZURyYWdSb3RhdGUgPSA5MDtcbiogbW92ZWFibGUuc3RhcnREcmFnUm90YXRlID0gNDU7XG4qL1xuXG4vKipcbiAqIFdoZW4gdGhlIGRyYWcgc3RhcnRzLCB0aGUgZHJhZ1N0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcbiAqIEBldmVudCBkcmFnU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ1N0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkcmFnU3RhcnQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBkcmFnZ2FibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcImRyYWdTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gZHJhZ2dpbmcsIHRoZSBkcmFnIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcbiAqIEBldmVudCBkcmFnXG4gKiBAcGFyYW0ge01vdmVhYmxlLkRyYWdnYWJsZS5PbkRyYWd9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGRyYWcgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBkcmFnZ2FibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcImRyYWdcIiwgKHsgdGFyZ2V0LCB0cmFuc2Zvcm0gfSkgPT4ge1xuICogICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGRyYWcgZmluaXNoZXMsIHRoZSBkcmFnRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcbiAqIEBldmVudCBkcmFnRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLkRyYWdnYWJsZS5PbkRyYWdFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGRyYWdFbmQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBkcmFnZ2FibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcImRyYWdFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuKiBXaGVuIHRoZSBncm91cCBkcmFnIHN0YXJ0cywgdGhlIGBkcmFnR3JvdXBTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXG4qIEBldmVudCBkcmFnR3JvdXBTdGFydFxuKiBAcGFyYW0ge01vdmVhYmxlLkRyYWdnYWJsZS5PbkRyYWdHcm91cFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgZHJhZ0dyb3VwU3RhcnRgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIGRyYWdnYWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJkcmFnR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcbiogICAgIGNvbnNvbGUubG9nKFwib25EcmFnR3JvdXBTdGFydFwiLCB0YXJnZXRzKTtcbiogfSk7XG4qL1xuXG4vKipcbiogV2hlbiB0aGUgZ3JvdXAgZHJhZywgdGhlIGBkcmFnR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxuKiBAZXZlbnQgZHJhZ0dyb3VwXG4qIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ0dyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgZHJhZ0dyb3VwYCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4qICAgICBkcmFnZ2FibGU6IHRydWVcbiogfSk7XG4qIG1vdmVhYmxlLm9uKFwiZHJhZ0dyb3VwXCIsICh7IHRhcmdldHMsIGV2ZW50cyB9KSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhcIm9uRHJhZ0dyb3VwXCIsIHRhcmdldHMpO1xuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xuKiAgICAgICAgICAvLyBkcmFnIGV2ZW50XG4qICAgICAgICAgIGNvbnNvbGUubG9nKFwib25EcmFnIGxlZnQsIHRvcFwiLCBldi5sZWZ0LCBldi50b3ApO1xuKiAgICAgICAgICAvLyBldi50YXJnZXQhLnN0eWxlLmxlZnQgPSBgJHtldi5sZWZ0fXB4YDtcbiogICAgICAgICAgLy8gZXYudGFyZ2V0IS5zdHlsZS50b3AgPSBgJHtldi50b3B9cHhgO1xuKiAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uRHJhZyB0cmFuc2xhdGVcIiwgZXYuZGlzdCk7XG4qICAgICAgICAgIGV2LnRhcmdldCEuc3R5bGUudHJhbnNmb3JtID0gZXYudHJhbnNmb3JtOylcbiogICAgIH0pO1xuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiB0aGUgZ3JvdXAgZHJhZyBmaW5pc2hlcywgdGhlIGBkcmFnR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcbiAqIEBldmVudCBkcmFnR3JvdXBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuRHJhZ2dhYmxlLk9uRHJhZ0dyb3VwRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgZHJhZ0dyb3VwRW5kYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICBkcmFnZ2FibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJkcmFnR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uRHJhZ0dyb3VwRW5kXCIsIHRhcmdldHMsIGlzRHJhZyk7XG4gKiB9KTtcbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJEaXJlY3Rpb25Db250cm9scyhtb3ZlYWJsZSwgZGVmYXVsdERpcmVjdGlvbnMsIFJlYWN0LCBhZGRpdGlvbmFsQ2xhc3NOYW1lKSB7XG4gIGlmIChhZGRpdGlvbmFsQ2xhc3NOYW1lID09PSB2b2lkIDApIHtcbiAgICBhZGRpdGlvbmFsQ2xhc3NOYW1lID0gXCJcIjtcbiAgfVxuXG4gIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgcmVuZGVyUG9zZXMgPSBfYS5yZW5kZXJQb3NlcyxcbiAgICAgIHJvdGF0aW9uUmFkID0gX2Eucm90YXRpb24sXG4gICAgICBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb247XG4gIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgX2MgPSBfYi5yZW5kZXJEaXJlY3Rpb25zLFxuICAgICAgZGlyZWN0aW9ucyA9IF9jID09PSB2b2lkIDAgPyBkZWZhdWx0RGlyZWN0aW9ucyA6IF9jLFxuICAgICAgem9vbSA9IF9iLnpvb207XG4gIHZhciBkaXJlY3Rpb25NYXAgPSB7fTtcblxuICBpZiAoIWRpcmVjdGlvbnMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc2lnbiA9IGRpcmVjdGlvbiA+IDAgPyAxIDogLTE7XG4gIHZhciByZW5kZXJEaXJlY3Rpb25zID0gZGlyZWN0aW9ucyA9PT0gdHJ1ZSA/IERJUkVDVElPTlMgOiBkaXJlY3Rpb25zO1xuICB2YXIgZGVnUm90YXRpb24gPSByb3RhdGlvblJhZCAvIE1hdGguUEkgKiAxODA7XG4gIHJlbmRlckRpcmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XG4gICAgZGlyZWN0aW9uTWFwW2Rpcl0gPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlbmRlckRpcmVjdGlvbnMubWFwKGZ1bmN0aW9uIChkaXIpIHtcbiAgICB2YXIgaW5kZXhlcyA9IERJUkVDVElPTl9JTkRFWEVTW2Rpcl07XG5cbiAgICBpZiAoIWluZGV4ZXMgfHwgIWRpcmVjdGlvbk1hcFtkaXJdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZGlyZWN0aW9uUm90YXRpb24gPSAodGhyb3R0bGUoZGVnUm90YXRpb24sIDE1KSArIHNpZ24gKiBESVJFQ1RJT05fUk9UQVRJT05TW2Rpcl0gKyA3MjApICUgMTgwO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcImRpcmVjdGlvblwiLCBkaXIsIGFkZGl0aW9uYWxDbGFzc05hbWUpLFxuICAgICAgXCJkYXRhLXJvdGF0aW9uXCI6IGRpcmVjdGlvblJvdGF0aW9uLFxuICAgICAgXCJkYXRhLWRpcmVjdGlvblwiOiBkaXIsXG4gICAgICBrZXk6IFwiZGlyZWN0aW9uLVwiICsgZGlyLFxuICAgICAgc3R5bGU6IGdldENvbnRyb2xUcmFuc2Zvcm0uYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtyb3RhdGlvblJhZCwgem9vbV0sIGluZGV4ZXMubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gcmVuZGVyUG9zZXNbaW5kZXhdO1xuICAgICAgfSkpKVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbmRlckxpbmUoUmVhY3QsIGRpcmVjdGlvbiwgcG9zMSwgcG9zMiwgem9vbSwga2V5KSB7XG4gIHZhciBjbGFzc05hbWVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSA2OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjbGFzc05hbWVzW19pIC0gNl0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgdmFyIHJhZCA9IGdldFJhZChwb3MxLCBwb3MyKTtcbiAgdmFyIHJvdGF0aW9uID0gZGlyZWN0aW9uID8gdGhyb3R0bGUocmFkIC8gTWF0aC5QSSAqIDE4MCwgMTUpICUgMTgwIDogLTE7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBrZXk6IFwibGluZVwiICsga2V5LFxuICAgIGNsYXNzTmFtZTogcHJlZml4LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXCJsaW5lXCIsIFwiZGlyZWN0aW9uXCIsIGRpcmVjdGlvbl0sIGNsYXNzTmFtZXMpKSxcbiAgICBcImRhdGEtcm90YXRpb25cIjogcm90YXRpb24sXG4gICAgXCJkYXRhLWxpbmUtaW5kZXhcIjoga2V5LFxuICAgIFwiZGF0YS1kaXJlY3Rpb25cIjogZGlyZWN0aW9uLFxuICAgIHN0eWxlOiBnZXRMaW5lU3R5bGUocG9zMSwgcG9zMiwgem9vbSwgcmFkKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbmRlckFsbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KSB7XG4gIHJldHVybiByZW5kZXJEaXJlY3Rpb25Db250cm9scyhtb3ZlYWJsZSwgRElSRUNUSU9OUywgUmVhY3QpO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlhZ29uYWxEaXJlY3Rpb25zKG1vdmVhYmxlLCBSZWFjdCkge1xuICByZXR1cm4gcmVuZGVyRGlyZWN0aW9uQ29udHJvbHMobW92ZWFibGUsIFtcIm53XCIsIFwibmVcIiwgXCJzd1wiLCBcInNlXCJdLCBSZWFjdCk7XG59XG5cbi8qKlxuICogQG5hbWVzcGFjZSBSb3RhdGFibGVcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGRlc2NyaXB0aW9uIFJvdGF0YWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0IGNhbiBiZSByb3RhdGVkLlxuICovXG5cbmZ1bmN0aW9uIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMsIGNsaWVudFgsIGNsaWVudFksIG9yaWdpbiwgcmVjdCkge1xuICB2YXIgbiA9IG1vdmVhYmxlLnN0YXRlLmlzM2QgPyA0IDogMztcbiAgdmFyIG5leHRPcmlnaW4gPSBjYWxjdWxhdGVQb3NpdGlvbihtb3ZlYWJsZS5zdGF0ZS5yb290TWF0cml4LCBvcmlnaW4sIG4pO1xuICB2YXIgc3RhcnRBYnNvbHV0ZU9yaWdpbiA9IHBsdXMoW3JlY3QubGVmdCwgcmVjdC50b3BdLCBuZXh0T3JpZ2luKTtcbiAgZGF0YXMuc3RhcnRBYnNvbHV0ZU9yaWdpbiA9IHN0YXJ0QWJzb2x1dGVPcmlnaW47XG4gIGRhdGFzLnByZXZEZWcgPSBnZXRSYWQoc3RhcnRBYnNvbHV0ZU9yaWdpbiwgW2NsaWVudFgsIGNsaWVudFldKSAvIE1hdGguUEkgKiAxODA7XG4gIGRhdGFzLnByZXZTbmFwRGVnID0gZGF0YXMucHJldkRlZztcbiAgZGF0YXMuc3RhcnREZWcgPSBkYXRhcy5wcmV2RGVnO1xuICBkYXRhcy5sb29wID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50RGVnKG1vdmVhYmxlLCBtb3ZlYWJsZVJlY3QsIGRhdGFzLCBwYXJlbnREaXN0LCBkaXJlY3Rpb24sIHN0YXJ0VmFsdWUpIHtcbiAgdmFyIHByZXZEZWcgPSBkYXRhcy5wcmV2RGVnOyAvLyBjb25zdCBhYnNvbHV0ZURlZyA9IHN0YXJ0VmFsdWUgKyBwYXJlbnREaXN0O1xuXG4gIHZhciBkaXN0ID0gY2hlY2tTbmFwUm90YXRlKG1vdmVhYmxlLCBtb3ZlYWJsZVJlY3QsIGRhdGFzLm9yaWdpbiwgcGFyZW50RGlzdCk7XG4gIGRhdGFzLnByZXZEZWcgPSBkaXN0O1xuICB2YXIgZGVsdGEgPSBkaXN0IC0gcHJldkRlZztcbiAgcmV0dXJuIFtkZWx0YSwgZGlzdCwgc3RhcnRWYWx1ZSArIGRpc3RdO1xufVxuXG5mdW5jdGlvbiBnZXREZWcobW92ZWFibGUsIG1vdmVhYmxlUmVjdCwgZGF0YXMsIGRlZywgZGlyZWN0aW9uLCBzdGFydFZhbHVlLCB0aHJvdHRsZVJvdGF0ZSwgaXNTbmFwKSB7XG4gIHZhciBwcmV2RGVnID0gZGF0YXMucHJldkRlZyxcbiAgICAgIHByZXZTbmFwRGVnID0gZGF0YXMucHJldlNuYXBEZWcsXG4gICAgICBzdGFydERlZyA9IGRhdGFzLnN0YXJ0RGVnLFxuICAgICAgcHJldkxvb3AgPSBkYXRhcy5sb29wO1xuXG4gIGlmIChwcmV2RGVnID4gZGVnICYmIHByZXZEZWcgPiAyNzAgJiYgZGVnIDwgOTApIHtcbiAgICAvLyAzNjAgPT4gMFxuICAgICsrZGF0YXMubG9vcDtcbiAgfSBlbHNlIGlmIChwcmV2RGVnIDwgZGVnICYmIHByZXZEZWcgPCA5MCAmJiBkZWcgPiAyNzApIHtcbiAgICAvLyAwID0+IDM2MFxuICAgIC0tZGF0YXMubG9vcDtcbiAgfVxuXG4gIHZhciBsb29wID0gZGF0YXMubG9vcDtcbiAgdmFyIGFic29sdXRlUHJldlNuYXBEZWcgPSBwcmV2TG9vcCAqIDM2MCArIHByZXZTbmFwRGVnIC0gc3RhcnREZWcgKyBzdGFydFZhbHVlO1xuICB2YXIgYWJzb2x1dGVEZWcgPSBsb29wICogMzYwICsgZGVnIC0gc3RhcnREZWcgKyBzdGFydFZhbHVlO1xuICBkYXRhcy5wcmV2RGVnID0gYWJzb2x1dGVEZWcgLSBsb29wICogMzYwICsgc3RhcnREZWcgLSBzdGFydFZhbHVlO1xuICBhYnNvbHV0ZURlZyA9IHRocm90dGxlKGFic29sdXRlRGVnLCB0aHJvdHRsZVJvdGF0ZSk7XG4gIHZhciBkaXN0ID0gZGlyZWN0aW9uICogKGFic29sdXRlRGVnIC0gc3RhcnRWYWx1ZSk7XG5cbiAgaWYgKGlzU25hcCkge1xuICAgIGRpc3QgPSBjaGVja1NuYXBSb3RhdGUobW92ZWFibGUsIG1vdmVhYmxlUmVjdCwgZGF0YXMub3JpZ2luLCBkaXN0KTtcbiAgICBhYnNvbHV0ZURlZyA9IGRpc3QgLyBkaXJlY3Rpb24gKyBzdGFydFZhbHVlO1xuICB9XG5cbiAgZGF0YXMucHJldlNuYXBEZWcgPSBhYnNvbHV0ZURlZyAtIGxvb3AgKiAzNjAgKyBzdGFydERlZyAtIHN0YXJ0VmFsdWU7XG4gIHZhciBkZWx0YSA9IGRpcmVjdGlvbiAqIChhYnNvbHV0ZURlZyAtIGFic29sdXRlUHJldlNuYXBEZWcpO1xuICByZXR1cm4gW2RlbHRhLCBkaXN0LCBzdGFydFZhbHVlICsgZGlzdF07XG59XG5cbmZ1bmN0aW9uIGdldFJvdGF0ZUluZm8obW92ZWFibGUsIG1vdmVhYmxlUmVjdCwgZGF0YXMsIGRpcmVjdGlvbiwgY2xpZW50WCwgY2xpZW50WSwgc3RhcnRWYWx1ZSwgdGhyb3R0bGVSb3RhdGUpIHtcbiAgcmV0dXJuIGdldERlZyhtb3ZlYWJsZSwgbW92ZWFibGVSZWN0LCBkYXRhcywgZ2V0UmFkKGRhdGFzLnN0YXJ0QWJzb2x1dGVPcmlnaW4sIFtjbGllbnRYLCBjbGllbnRZXSkgLyBNYXRoLlBJICogMTgwLCBkaXJlY3Rpb24sIHN0YXJ0VmFsdWUsIHRocm90dGxlUm90YXRlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdldFJvdGF0aW9uUG9zaXRpb25zKHJvdGF0aW9uUG9zaXRpb24sIF9hLCBkaXJlY3Rpb24pIHtcbiAgdmFyIHBvczEgPSBfYVswXSxcbiAgICAgIHBvczIgPSBfYVsxXSxcbiAgICAgIHBvczMgPSBfYVsyXSxcbiAgICAgIHBvczQgPSBfYVszXTtcblxuICBpZiAocm90YXRpb25Qb3NpdGlvbiA9PT0gXCJub25lXCIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX2IgPSAocm90YXRpb25Qb3NpdGlvbiB8fCBcInRvcFwiKS5zcGxpdChcIi1cIiksXG4gICAgICBkaXIxID0gX2JbMF0sXG4gICAgICBkaXIyID0gX2JbMV07XG5cbiAgdmFyIHJhZFBvc2VzID0gW3BvczEsIHBvczJdOyAvLyBpZiAoc2NhbGVbMF0gPCAwKSB7XG4gIC8vICAgICBkaXIxID0gZ2V0UmV2ZXJzZVBvc2l0aW9uWChkaXIxKTtcbiAgLy8gICAgIGRpcjIgPSBnZXRSZXZlcnNlUG9zaXRpb25YKGRpcjIpO1xuICAvLyB9XG4gIC8vIGlmIChzY2FsZVsxXSA8IDApIHtcbiAgLy8gICAgIGRpcjEgPSBnZXRSZXZlcnNlUG9zaXRpb25ZKGRpcjEpO1xuICAvLyAgICAgZGlyMiA9IGdldFJldmVyc2VQb3NpdGlvblkoZGlyMik7XG4gIC8vIH1cblxuICBpZiAoZGlyMSA9PT0gXCJsZWZ0XCIpIHtcbiAgICByYWRQb3NlcyA9IFtwb3MzLCBwb3MxXTtcbiAgfSBlbHNlIGlmIChkaXIxID09PSBcInJpZ2h0XCIpIHtcbiAgICByYWRQb3NlcyA9IFtwb3MyLCBwb3M0XTtcbiAgfSBlbHNlIGlmIChkaXIxID09PSBcImJvdHRvbVwiKSB7XG4gICAgcmFkUG9zZXMgPSBbcG9zNCwgcG9zM107XG4gIH1cblxuICB2YXIgcG9zID0gWyhyYWRQb3Nlc1swXVswXSArIHJhZFBvc2VzWzFdWzBdKSAvIDIsIChyYWRQb3Nlc1swXVsxXSArIHJhZFBvc2VzWzFdWzFdKSAvIDJdO1xuICB2YXIgcmFkID0gZ2V0Um90YXRpb25SYWQocmFkUG9zZXMsIGRpcmVjdGlvbik7XG5cbiAgaWYgKGRpcjIpIHtcbiAgICB2YXIgaXNTdGFydCA9IGRpcjIgPT09IFwidG9wXCIgfHwgZGlyMiA9PT0gXCJsZWZ0XCI7XG4gICAgdmFyIGlzUmV2ZXJzZSA9IGRpcjEgPT09IFwiYm90dG9tXCIgfHwgZGlyMSA9PT0gXCJsZWZ0XCI7XG4gICAgcG9zID0gcmFkUG9zZXNbaXNTdGFydCAmJiAhaXNSZXZlcnNlIHx8ICFpc1N0YXJ0ICYmIGlzUmV2ZXJzZSA/IDAgOiAxXTtcbiAgfVxuXG4gIHJldHVybiBbcG9zLCByYWRdO1xufVxuZnVuY3Rpb24gZHJhZ0NvbnRyb2xDb25kaXRpb24obW92ZWFibGUsIGUpIHtcbiAgaWYgKGUuaXNSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIGUucmVxdWVzdEFibGUgPT09IFwicm90YXRhYmxlXCI7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gZS5pbnB1dEV2ZW50LnRhcmdldDtcblxuICBpZiAoaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJyb3RhdGlvbi1jb250cm9sXCIpKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHJvdGF0aW9uVGFyZ2V0ID0gbW92ZWFibGUucHJvcHMucm90YXRpb25UYXJnZXQ7XG5cbiAgaWYgKHJvdGF0aW9uVGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdldFJlZlRhcmdldHMocm90YXRpb25UYXJnZXQsIHRydWUpLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQgPT09IGVsZW1lbnQgfHwgdGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFJvdGF0YWJsZSA9IHtcbiAgbmFtZTogXCJyb3RhdGFibGVcIixcbiAgY2FuUGluY2g6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgcm90YXRhYmxlOiBCb29sZWFuLFxuICAgIHJvdGF0aW9uUG9zaXRpb246IFN0cmluZyxcbiAgICB0aHJvdHRsZVJvdGF0ZTogTnVtYmVyLFxuICAgIHJlbmRlckRpcmVjdGlvbnM6IE9iamVjdCxcbiAgICByb3RhdGlvblRhcmdldDogT2JqZWN0XG4gIH0sXG4gIGV2ZW50czoge1xuICAgIG9uUm90YXRlU3RhcnQ6IFwicm90YXRlU3RhcnRcIixcbiAgICBvblJvdGF0ZTogXCJyb3RhdGVcIixcbiAgICBvblJvdGF0ZUVuZDogXCJyb3RhdGVFbmRcIixcbiAgICBvblJvdGF0ZUdyb3VwU3RhcnQ6IFwicm90YXRlR3JvdXBTdGFydFwiLFxuICAgIG9uUm90YXRlR3JvdXA6IFwicm90YXRlR3JvdXBcIixcbiAgICBvblJvdGF0ZUdyb3VwRW5kOiBcInJvdGF0ZUdyb3VwRW5kXCJcbiAgfSxcbiAgY3NzOiBbXCIucm90YXRpb24ge1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICBoZWlnaHQ6IDQwcHg7XFxuICAgICAgICAgICAgd2lkdGg6IDFweDtcXG4gICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTAwJTtcXG4gICAgICAgICAgICBoZWlnaHQ6IGNhbGMoNDBweCAqIHZhcigtLXpvb20pKTtcXG4gICAgICAgICAgICB0b3A6IGF1dG87XFxuICAgICAgICAgICAgbGVmdDogMDtcXG4gICAgICAgICAgICBib3R0b206IDEwMCU7XFxuICAgICAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG4gICAgICAgIH1cXG4gICAgICAgIC5yb3RhdGlvbiAucm90YXRpb24tbGluZSB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxuICAgICAgICB9XFxuICAgICAgICAucm90YXRpb24gLnJvdGF0aW9uLWNvbnRyb2wge1xcbiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogIzRhZjtcXG4gICAgICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiNmZmY7XFxuICAgICAgICAgICAgY3Vyc29yOiBhbGlhcztcXG4gICAgICAgIH1cIl0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICByb3RhdGFibGUgPSBfYS5yb3RhdGFibGUsXG4gICAgICAgIHJvdGF0aW9uUG9zaXRpb24gPSBfYS5yb3RhdGlvblBvc2l0aW9uLFxuICAgICAgICB6b29tID0gX2Euem9vbSxcbiAgICAgICAgcmVuZGVyRGlyZWN0aW9ucyA9IF9hLnJlbmRlckRpcmVjdGlvbnM7XG4gICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHJlbmRlclBvc2VzID0gX2IucmVuZGVyUG9zZXMsXG4gICAgICAgIGRpcmVjdGlvbiA9IF9iLmRpcmVjdGlvbjtcblxuICAgIGlmICghcm90YXRhYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb25zID0gZ2V0Um90YXRpb25Qb3NpdGlvbnMocm90YXRpb25Qb3NpdGlvbiwgcmVuZGVyUG9zZXMsIGRpcmVjdGlvbik7XG4gICAgdmFyIGpzeHMgPSBbXTtcblxuICAgIGlmIChwb3NpdGlvbnMpIHtcbiAgICAgIHZhciBwb3MgPSBwb3NpdGlvbnNbMF0sXG4gICAgICAgICAgcmFkID0gcG9zaXRpb25zWzFdO1xuICAgICAganN4cy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IFwicm90YXRpb25cIixcbiAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJyb3RhdGlvblwiKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG1heC1saW5lLWxlbmd0aFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSkgdHJhbnNsYXRlKFwiICsgcG9zWzBdICsgXCJweCwgXCIgKyBwb3NbMV0gKyBcInB4KSByb3RhdGUoXCIgKyByYWQgKyBcInJhZClcIlxuICAgICAgICB9XG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lIHJvdGF0aW9uLWxpbmVcIiksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlWChcIiArIHpvb20gKyBcIilcIlxuICAgICAgICB9XG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbCByb3RhdGlvbi1jb250cm9sXCIpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMC41cHgpIHNjYWxlKFwiICsgem9vbSArIFwiKVwiXG4gICAgICAgIH1cbiAgICAgIH0pKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlckRpcmVjdGlvbnMpIHtcbiAgICAgIGpzeHMucHVzaC5hcHBseShqc3hzLCByZW5kZXJEaXJlY3Rpb25Db250cm9scyhtb3ZlYWJsZSwgW10sIFJlYWN0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzeHM7XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBkcmFnQ29udHJvbENvbmRpdGlvbixcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgY2xpZW50WCA9IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WSA9IGUuY2xpZW50WSxcbiAgICAgICAgcGFyZW50Um90YXRlID0gZS5wYXJlbnRSb3RhdGUsXG4gICAgICAgIHBhcmVudEZsYWcgPSBlLnBhcmVudEZsYWcsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXG4gICAgICAgIGxlZnQgPSBfYS5sZWZ0LFxuICAgICAgICB0b3AgPSBfYS50b3AsXG4gICAgICAgIG9yaWdpbiA9IF9hLm9yaWdpbixcbiAgICAgICAgYmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luLFxuICAgICAgICBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb24sXG4gICAgICAgIGJlZm9yZURpcmVjdGlvbiA9IF9hLmJlZm9yZURpcmVjdGlvbixcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtID0gX2EudGFyZ2V0VHJhbnNmb3JtLFxuICAgICAgICBtb3ZlYWJsZUNsaWVudFJlY3QgPSBfYS5tb3ZlYWJsZUNsaWVudFJlY3Q7XG5cbiAgICBpZiAoIWlzUmVxdWVzdCAmJiAhdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XG4gICAgZGF0YXMucmVjdCA9IHJlY3Q7XG4gICAgZGF0YXMudHJhbnNmb3JtID0gdGFyZ2V0VHJhbnNmb3JtO1xuICAgIGRhdGFzLmxlZnQgPSBsZWZ0O1xuICAgIGRhdGFzLnRvcCA9IHRvcDtcbiAgICBkYXRhcy5maXhlZFBvc2l0aW9uID0gZ2V0RGlyZWN0aW9uT2Zmc2V0KG1vdmVhYmxlLCBnZXRPcmlnaW5EaXJlY3Rpb24obW92ZWFibGUpKTtcbiAgICBkYXRhcy5hYnNvbHV0ZUluZm8gPSB7XG4gICAgICBvcmlnaW46IHJlY3Qub3JpZ2luLFxuICAgICAgc3RhcnRWYWx1ZTogcmVjdC5yb3RhdGlvblxuICAgIH07XG4gICAgc2V0Um90YXRlU3RhcnRJbmZvKG1vdmVhYmxlLCBkYXRhcy5hYnNvbHV0ZUluZm8sIGNsaWVudFgsIGNsaWVudFksIG9yaWdpbiwgbW92ZWFibGVDbGllbnRSZWN0KTtcblxuICAgIGlmIChpc1JlcXVlc3QgfHwgaXNQaW5jaCB8fCBwYXJlbnRGbGFnKSB7XG4gICAgICB2YXIgZXh0ZXJuYWxSb3RhdGUgPSBwYXJlbnRSb3RhdGUgfHwgMDtcbiAgICAgIGRhdGFzLmJlZm9yZUluZm8gPSB7XG4gICAgICAgIG9yaWdpbjogcmVjdC5iZWZvcmVPcmlnaW4sXG4gICAgICAgIHByZXZEZWc6IGV4dGVybmFsUm90YXRlLFxuICAgICAgICBzdGFydERlZzogZXh0ZXJuYWxSb3RhdGUsXG4gICAgICAgIHByZXZTbmFwRGVnOiBleHRlcm5hbFJvdGF0ZSxcbiAgICAgICAgbG9vcDogMFxuICAgICAgfTtcbiAgICAgIGRhdGFzLmFmdGVySW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOiByZWN0Lm9yaWdpbixcbiAgICAgICAgcHJldkRlZzogZXh0ZXJuYWxSb3RhdGUsXG4gICAgICAgIHN0YXJ0RGVnOiBleHRlcm5hbFJvdGF0ZSxcbiAgICAgICAgcHJldlNuYXBEZWc6IGV4dGVybmFsUm90YXRlLFxuICAgICAgICBsb29wOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhcy5iZWZvcmVJbmZvID0ge1xuICAgICAgICBvcmlnaW46IHJlY3QuYmVmb3JlT3JpZ2luXG4gICAgICB9O1xuICAgICAgZGF0YXMuYWZ0ZXJJbmZvID0ge1xuICAgICAgICBvcmlnaW46IHJlY3Qub3JpZ2luXG4gICAgICB9O1xuICAgICAgc2V0Um90YXRlU3RhcnRJbmZvKG1vdmVhYmxlLCBkYXRhcy5iZWZvcmVJbmZvLCBjbGllbnRYLCBjbGllbnRZLCBiZWZvcmVPcmlnaW4sIG1vdmVhYmxlQ2xpZW50UmVjdCk7XG4gICAgICBzZXRSb3RhdGVTdGFydEluZm8obW92ZWFibGUsIGRhdGFzLmFmdGVySW5mbywgY2xpZW50WCwgY2xpZW50WSwgb3JpZ2luLCBtb3ZlYWJsZUNsaWVudFJlY3QpO1xuICAgIH1cblxuICAgIGRhdGFzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBkYXRhcy5iZWZvcmVEaXJlY3Rpb24gPSBiZWZvcmVEaXJlY3Rpb247XG4gICAgZGF0YXMuc3RhcnRWYWx1ZSA9IDA7XG4gICAgZGF0YXMuZGF0YXMgPSB7fTtcbiAgICBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgoZSwgXCJyb3RhdGVcIik7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgIHNldDogZnVuY3Rpb24gKHJvdGF0YXRpb24pIHtcbiAgICAgICAgZGF0YXMuc3RhcnRWYWx1ZSA9IHJvdGF0YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgfVxuICAgIH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KGUpKSwge1xuICAgICAgZHJhZ1N0YXJ0OiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSlcbiAgICB9KSk7XG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZVN0YXJ0XCIsIHBhcmFtcyk7XG4gICAgZGF0YXMuaXNSb3RhdGUgPSByZXN1bHQgIT09IGZhbHNlO1xuICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3RcbiAgICB9O1xuICAgIHJldHVybiBkYXRhcy5pc1JvdGF0ZSA/IHBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG5cbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBjbGllbnRYID0gZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gZS5jbGllbnRZLFxuICAgICAgICBwYXJlbnRSb3RhdGUgPSBlLnBhcmVudFJvdGF0ZSxcbiAgICAgICAgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZyxcbiAgICAgICAgaXNQaW5jaCA9IGUuaXNQaW5jaCxcbiAgICAgICAgZ3JvdXBEZWx0YSA9IGUuZ3JvdXBEZWx0YTtcbiAgICB2YXIgYmVmb3JlRGlyZWN0aW9uID0gZGF0YXMuYmVmb3JlRGlyZWN0aW9uLFxuICAgICAgICBiZWZvcmVJbmZvID0gZGF0YXMuYmVmb3JlSW5mbyxcbiAgICAgICAgYWZ0ZXJJbmZvID0gZGF0YXMuYWZ0ZXJJbmZvLFxuICAgICAgICBhYnNvbHV0ZUluZm8gPSBkYXRhcy5hYnNvbHV0ZUluZm8sXG4gICAgICAgIGlzUm90YXRlID0gZGF0YXMuaXNSb3RhdGUsXG4gICAgICAgIHN0YXJ0VmFsdWUgPSBkYXRhcy5zdGFydFZhbHVlLFxuICAgICAgICByZWN0ID0gZGF0YXMucmVjdDtcblxuICAgIGlmICghaXNSb3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNvbHZlVHJhbnNmb3JtRXZlbnQoZSwgXCJyb3RhdGVcIik7XG4gICAgdmFyIHRhcmdldERpcmVjdGlvbiA9IGdldFRyYW5zZm9ybURpcmVjdGlvbihlKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gYmVmb3JlRGlyZWN0aW9uICogdGFyZ2V0RGlyZWN0aW9uO1xuICAgIHZhciBfayA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICBfbCA9IF9rLnRocm90dGxlUm90YXRlLFxuICAgICAgICB0aHJvdHRsZVJvdGF0ZSA9IF9sID09PSB2b2lkIDAgPyAwIDogX2wsXG4gICAgICAgIHBhcmVudE1vdmVhYmxlID0gX2sucGFyZW50TW92ZWFibGU7XG4gICAgdmFyIGRlbHRhO1xuICAgIHZhciBkaXN0O1xuICAgIHZhciByb3RhdGU7XG4gICAgdmFyIGJlZm9yZURlbHRhO1xuICAgIHZhciBiZWZvcmVEaXN0O1xuICAgIHZhciBiZWZvcmVSb3RhdGU7XG4gICAgdmFyIGFic29sdXRlRGVsdGE7XG4gICAgdmFyIGFic29sdXRlRGlzdDtcbiAgICB2YXIgYWJzb2x1dGVSb3RhdGU7XG4gICAgdmFyIHN0YXJ0RGVnID0gMTgwIC8gTWF0aC5QSSAqIHN0YXJ0VmFsdWU7XG4gICAgdmFyIGFic29sdXRlU3RhcnREZWcgPSBhYnNvbHV0ZUluZm8uc3RhcnRWYWx1ZTtcblxuICAgIGlmICghcGFyZW50RmxhZyAmJiBcInBhcmVudERpc3RcIiBpbiBlKSB7XG4gICAgICB2YXIgcGFyZW50RGlzdCA9IGUucGFyZW50RGlzdDtcbiAgICAgIF9hID0gZ2V0UGFyZW50RGVnKG1vdmVhYmxlLCByZWN0LCBhZnRlckluZm8sIHBhcmVudERpc3QsIGRpcmVjdGlvbiwgc3RhcnREZWcpLCBkZWx0YSA9IF9hWzBdLCBkaXN0ID0gX2FbMV0sIHJvdGF0ZSA9IF9hWzJdO1xuICAgICAgX2IgPSBnZXRQYXJlbnREZWcobW92ZWFibGUsIHJlY3QsIGJlZm9yZUluZm8sIHBhcmVudERpc3QsIGJlZm9yZURpcmVjdGlvbiwgc3RhcnREZWcpLCBiZWZvcmVEZWx0YSA9IF9iWzBdLCBiZWZvcmVEaXN0ID0gX2JbMV0sIGJlZm9yZVJvdGF0ZSA9IF9iWzJdO1xuICAgICAgX2MgPSBnZXRQYXJlbnREZWcobW92ZWFibGUsIHJlY3QsIGFic29sdXRlSW5mbywgcGFyZW50RGlzdCwgZGlyZWN0aW9uLCBhYnNvbHV0ZVN0YXJ0RGVnKSwgYWJzb2x1dGVEZWx0YSA9IF9jWzBdLCBhYnNvbHV0ZURpc3QgPSBfY1sxXSwgYWJzb2x1dGVSb3RhdGUgPSBfY1syXTtcbiAgICB9IGVsc2UgaWYgKGlzUGluY2ggfHwgcGFyZW50RmxhZykge1xuICAgICAgX2QgPSBnZXREZWcobW92ZWFibGUsIHJlY3QsIGFmdGVySW5mbywgcGFyZW50Um90YXRlLCBkaXJlY3Rpb24sIHN0YXJ0RGVnLCB0aHJvdHRsZVJvdGF0ZSksIGRlbHRhID0gX2RbMF0sIGRpc3QgPSBfZFsxXSwgcm90YXRlID0gX2RbMl07XG4gICAgICBfZSA9IGdldERlZyhtb3ZlYWJsZSwgcmVjdCwgYmVmb3JlSW5mbywgcGFyZW50Um90YXRlLCBiZWZvcmVEaXJlY3Rpb24sIHN0YXJ0RGVnLCB0aHJvdHRsZVJvdGF0ZSksIGJlZm9yZURlbHRhID0gX2VbMF0sIGJlZm9yZURpc3QgPSBfZVsxXSwgYmVmb3JlUm90YXRlID0gX2VbMl07XG4gICAgICBfZiA9IGdldERlZyhtb3ZlYWJsZSwgcmVjdCwgYWJzb2x1dGVJbmZvLCBwYXJlbnRSb3RhdGUsIGRpcmVjdGlvbiwgYWJzb2x1dGVTdGFydERlZywgdGhyb3R0bGVSb3RhdGUpLCBhYnNvbHV0ZURlbHRhID0gX2ZbMF0sIGFic29sdXRlRGlzdCA9IF9mWzFdLCBhYnNvbHV0ZVJvdGF0ZSA9IF9mWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZyA9IGdldFJvdGF0ZUluZm8obW92ZWFibGUsIHJlY3QsIGFmdGVySW5mbywgZGlyZWN0aW9uLCBjbGllbnRYLCBjbGllbnRZLCBzdGFydERlZywgdGhyb3R0bGVSb3RhdGUpLCBkZWx0YSA9IF9nWzBdLCBkaXN0ID0gX2dbMV0sIHJvdGF0ZSA9IF9nWzJdO1xuICAgICAgX2ggPSBnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCByZWN0LCBiZWZvcmVJbmZvLCBiZWZvcmVEaXJlY3Rpb24sIGNsaWVudFgsIGNsaWVudFksIHN0YXJ0RGVnLCB0aHJvdHRsZVJvdGF0ZSksIGJlZm9yZURlbHRhID0gX2hbMF0sIGJlZm9yZURpc3QgPSBfaFsxXSwgYmVmb3JlUm90YXRlID0gX2hbMl07XG4gICAgICBfaiA9IGdldFJvdGF0ZUluZm8obW92ZWFibGUsIHJlY3QsIGFic29sdXRlSW5mbywgZGlyZWN0aW9uLCBjbGllbnRYLCBjbGllbnRZLCBhYnNvbHV0ZVN0YXJ0RGVnLCB0aHJvdHRsZVJvdGF0ZSksIGFic29sdXRlRGVsdGEgPSBfalswXSwgYWJzb2x1dGVEaXN0ID0gX2pbMV0sIGFic29sdXRlUm90YXRlID0gX2pbMl07XG4gICAgfVxuXG4gICAgaWYgKCFhYnNvbHV0ZURlbHRhICYmICFkZWx0YSAmJiAhYmVmb3JlRGVsdGEgJiYgIXBhcmVudE1vdmVhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRUcmFuc2Zvcm0gPSBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCBcInJvdGF0ZShcIiArIHJvdGF0ZSArIFwiZGVnKVwiLCBcInJvdGF0ZShcIiArIGRpc3QgKyBcImRlZylcIik7XG4gICAgdmFyIGludmVyc2VEaXN0ID0gZ2V0Um90YXRlRGlzdChtb3ZlYWJsZSwgZGlzdCwgZGF0YXMuZml4ZWRQb3NpdGlvbiwgZGF0YXMpO1xuICAgIHZhciBpbnZlcnNlRGVsdGEgPSBtaW51cyhwbHVzKGdyb3VwRGVsdGEgfHwgWzAsIDBdLCBpbnZlcnNlRGlzdCksIGRhdGFzLnByZXZJbnZlcnNlRGlzdCB8fCBbMCwgMF0pO1xuICAgIGRhdGFzLnByZXZJbnZlcnNlRGlzdCA9IGludmVyc2VEaXN0O1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7XG4gICAgICBkZWx0YTogZGVsdGEsXG4gICAgICBkaXN0OiBkaXN0LFxuICAgICAgcm90YXRlOiByb3RhdGUsXG4gICAgICBiZWZvcmVEaXN0OiBiZWZvcmVEaXN0LFxuICAgICAgYmVmb3JlRGVsdGE6IGJlZm9yZURlbHRhLFxuICAgICAgYmVmb3JlUm90YXRlOiBiZWZvcmVSb3RhdGUsXG4gICAgICBhYnNvbHV0ZURpc3Q6IGFic29sdXRlRGlzdCxcbiAgICAgIGFic29sdXRlRGVsdGE6IGFic29sdXRlRGVsdGEsXG4gICAgICBhYnNvbHV0ZVJvdGF0ZTogYWJzb2x1dGVSb3RhdGUsXG4gICAgICBpc1BpbmNoOiAhIWlzUGluY2hcbiAgICB9LCBmaWxsVHJhbnNmb3JtRXZlbnQobW92ZWFibGUsIG5leHRUcmFuc2Zvcm0sIGludmVyc2VEZWx0YSwgaXNQaW5jaCwgZSkpKTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVcIiwgcGFyYW1zKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSb3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhcy5pc1JvdGF0ZSA9IGZhbHNlO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm90YXRlRW5kXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZHJhZ0NvbnRyb2xDb25kaXRpb24sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgcGFyZW50TGVmdCA9IF9hLmxlZnQsXG4gICAgICAgIHBhcmVudFRvcCA9IF9hLnRvcCxcbiAgICAgICAgcGFyZW50QmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJhbXMuc2V0KGRhdGFzLmJlZm9yZURpcmVjdGlvbiAqIG1vdmVhYmxlLnJvdGF0aW9uKTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xTdGFydFwiLCBlLCBmdW5jdGlvbiAoY2hpbGQsIGV2KSB7XG4gICAgICB2YXIgX2EgPSBjaGlsZC5zdGF0ZSxcbiAgICAgICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgICB0b3AgPSBfYS50b3AsXG4gICAgICAgICAgYmVmb3JlT3JpZ2luID0gX2EuYmVmb3JlT3JpZ2luO1xuICAgICAgdmFyIGNoaWxkQ2xpZW50ID0gcGx1cyhtaW51cyhbbGVmdCwgdG9wXSwgW3BhcmVudExlZnQsIHBhcmVudFRvcF0pLCBtaW51cyhiZWZvcmVPcmlnaW4sIHBhcmVudEJlZm9yZU9yaWdpbikpO1xuICAgICAgZXYuZGF0YXMuZ3JvdXBDbGllbnQgPSBjaGlsZENsaWVudDtcbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7XG4gICAgICAgIHBhcmVudFJvdGF0ZTogMFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9KTtcblxuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVHcm91cFN0YXJ0XCIsIG5leHRQYXJhbXMpO1xuICAgIGRhdGFzLmlzUm90YXRlID0gcmVzdWx0ICE9PSBmYWxzZTtcbiAgICByZXR1cm4gZGF0YXMuaXNSb3RhdGUgPyBwYXJhbXMgOiBmYWxzZTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSb3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXJlY3Rpb24gPSBkYXRhcy5iZWZvcmVEaXJlY3Rpb247XG4gICAgdmFyIHBhcmVudFJvdGF0ZSA9IHBhcmFtcy5iZWZvcmVEaXN0O1xuICAgIHZhciBkZWcgPSBwYXJhbXMuYmVmb3JlRGVsdGE7XG4gICAgdmFyIHJhZCA9IGRlZyAvIDE4MCAqIE1hdGguUEk7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sXCIsIGUsIGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgdmFyIF9hID0gZXYuZGF0YXMuZ3JvdXBDbGllbnQsXG4gICAgICAgICAgcHJldlggPSBfYVswXSxcbiAgICAgICAgICBwcmV2WSA9IF9hWzFdO1xuXG4gICAgICB2YXIgX2IgPSByb3RhdGUoW3ByZXZYLCBwcmV2WV0sIHJhZCAqIGRpcmVjdGlvbiksXG4gICAgICAgICAgY2xpZW50WCA9IF9iWzBdLFxuICAgICAgICAgIGNsaWVudFkgPSBfYlsxXTtcblxuICAgICAgdmFyIGRlbHRhID0gW2NsaWVudFggLSBwcmV2WCwgY2xpZW50WSAtIHByZXZZXTtcbiAgICAgIGV2LmRhdGFzLmdyb3VwQ2xpZW50ID0gW2NsaWVudFgsIGNsaWVudFldO1xuICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHtcbiAgICAgICAgcGFyZW50Um90YXRlOiBwYXJlbnRSb3RhdGUsXG4gICAgICAgIGdyb3VwRGVsdGE6IGRlbHRhXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtb3ZlYWJsZS5yb3RhdGlvbiA9IGRpcmVjdGlvbiAqIHBhcmFtcy5iZWZvcmVSb3RhdGU7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgIHNldDogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XG4gICAgICAgIG1vdmVhYmxlLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICB9XG4gICAgfSwgcGFyYW1zKTtcblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZUdyb3VwXCIsIG5leHRQYXJhbXMpO1xuICAgIHJldHVybiBuZXh0UGFyYW1zO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgaXNEcmFnID0gZS5pc0RyYWcsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSb3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdDb250cm9sRW5kKG1vdmVhYmxlLCBlKTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xFbmRcIiwgZSk7XG4gICAgdmFyIG5leHRQYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVHcm91cEVuZFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gaXNEcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlLlJvdGF0YWJsZSNyZXF1ZXN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZV0gLSB0aGUgUmVzaXphYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhUm90YXRlPTBdIC0gIGRlbHRhIG51bWJlciBvZiByb3RhdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Uucm90YXRlPTBdIC0gYWJzb2x1dGUgbnVtYmVyIG9mIG1vdmVhYmxlJ3Mgcm90YXRpb25cbiAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcbiAgICogQGV4YW1wbGVcbiAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICogbW92ZWFibGUucmVxdWVzdChcInJvdGF0YWJsZVwiLCB7IGRlbHRhUm90YXRlOiAxMCB9LCB0cnVlKTtcbiAgICpcbiAgICogKiBtb3ZlYWJsZS5yZXF1ZXN0KFwicm90YXRhYmxlXCIsIHsgcm90YXRlOiAxMCB9LCB0cnVlKTtcbiAgICpcbiAgICogLy8gcmVxdWVzdFN0YXJ0XG4gICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJyb3RhdGFibGVcIik7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVJvdGF0ZTogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFSb3RhdGU6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhUm90YXRlOiAxMCB9KTtcbiAgICpcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyByb3RhdGU6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IHJvdGF0ZTogMjAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgcm90YXRlOiAzMCB9KTtcbiAgICpcbiAgICogLy8gcmVxdWVzdEVuZFxuICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xuICAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdmFyIGRhdGFzID0ge307XG4gICAgdmFyIGRpc3RSb3RhdGUgPSAwO1xuICAgIHZhciBzdGFydFJvdGF0aW9uID0gbW92ZWFibGUuZ2V0Um90YXRpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiB0cnVlLFxuICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKFwiZGVsdGFSb3RhdGVcIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdFJvdGF0ZSArPSBlLmRlbHRhUm90YXRlO1xuICAgICAgICB9IGVsc2UgaWYgKFwicm90YXRlXCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RSb3RhdGUgPSBlLnJvdGF0ZSAtIHN0YXJ0Um90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBwYXJlbnREaXN0OiBkaXN0Um90YXRlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBpc0RyYWc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHJvdGF0ZWQuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdGF0YWJsZSNyb3RhdGFibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUucm90YXRhYmxlID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgcG9zaXRpb24gb2YgdGhlIHJvdGF0aW9uLiAoZGVmYXVsdDogXCJ0b3BcIilcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdGF0YWJsZSNyb3RhdGlvblBvc2l0aW9uXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgcm90YXRpb25Qb3NpdGlvbjogXCJ0b3BcIixcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLnJvdGF0aW9uUG9zaXRpb24gPSBcImJvdHRvbVwiXG4gKi9cblxuLyoqXG4gKiB0aHJvdHRsZSBvZiBhbmdsZShkZWdyZWUpIHdoZW4gcm90YXRlLlxuICogQG5hbWUgTW92ZWFibGUuUm90YXRhYmxlI3Rocm90dGxlUm90YXRlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLnRocm90dGxlUm90YXRlID0gMTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHJvdGF0ZSBzdGFydHMsIHRoZSByb3RhdGVTdGFydCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXG4gKiBAZXZlbnQgcm90YXRlU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHJvdGF0ZVN0YXJ0IGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcm90YXRhYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJyb3RhdGVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiogV2hlbiByb3RhdGluZywgdGhlIHJvdGF0ZSBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcbiogQGV2ZW50IHJvdGF0ZVxuKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZX0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcm90YXRlIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByb3RhdGFibGU6IHRydWUgfSk7XG4qIG1vdmVhYmxlLm9uKFwicm90YXRlXCIsICh7IHRhcmdldCwgdHJhbnNmb3JtLCBkaXN0IH0pID0+IHtcbiogICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSByb3RhdGUgZmluaXNoZXMsIHRoZSByb3RhdGVFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdGF0YWJsZVxuICogQGV2ZW50IHJvdGF0ZUVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGVFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHJvdGF0ZUVuZCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJvdGF0YWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlRW5kXCIsICh7IHRhcmdldCwgaXNEcmFnIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQsIGlzRHJhZyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIGdyb3VwIHJvdGF0ZSBzdGFydHMsIHRoZSBgcm90YXRlR3JvdXBTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdGF0YWJsZVxuICogQGV2ZW50IHJvdGF0ZUdyb3VwU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdGF0ZUdyb3VwU3RhcnRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogICAgIHJvdGF0YWJsZTogdHJ1ZVxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUdyb3VwU3RhcnRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblJvdGF0ZUdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiogV2hlbiB0aGUgZ3JvdXAgcm90YXRlLCB0aGUgYHJvdGF0ZUdyb3VwYCBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcbiogQGV2ZW50IHJvdGF0ZUdyb3VwXG4qIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3RhdGVHcm91cGAgZXZlbnRcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuKiAgICAgcm90YXRhYmxlOiB0cnVlXG4qIH0pO1xuKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUdyb3VwXCIsICh7IHRhcmdldHMsIGV2ZW50cyB9KSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhcIm9uUm90YXRlR3JvdXBcIiwgdGFyZ2V0cyk7XG4qICAgICBldmVudHMuZm9yRWFjaChldiA9PiB7XG4qICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuKiAgICAgICAgIC8vIGV2LmRyYWcgaXMgYSBkcmFnIGV2ZW50IHRoYXQgb2NjdXJzIHdoZW4gdGhlIGdyb3VwIHJvdGF0ZS5cbiogICAgICAgICBjb25zdCBsZWZ0ID0gZXYuZHJhZy5iZWZvcmVEaXN0WzBdO1xuKiAgICAgICAgIGNvbnN0IHRvcCA9IGV2LmRyYWcuYmVmb3JlRGlzdFsxXTtcbiogICAgICAgICBjb25zdCBkZWcgPSBldi5iZWZvcmVEaXN0O1xuKiAgICAgfSk7XG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCByb3RhdGUgZmluaXNoZXMsIHRoZSBgcm90YXRlR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcbiAqIEBldmVudCByb3RhdGVHcm91cEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGVHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdGF0ZUdyb3VwRW5kYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICByb3RhdGFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3RhdGVHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25Sb3RhdGVHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFJlc2l6YWJsZVxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZGVzY3JpcHRpb24gUmVzaXphYmxlIGluZGljYXRlcyB3aGV0aGVyIHRoZSB0YXJnZXQncyB3aWR0aCBhbmQgaGVpZ2h0IGNhbiBiZSBpbmNyZWFzZWQgb3IgZGVjcmVhc2VkLlxuICovXG5cbnZhciBSZXNpemFibGUgPSB7XG4gIG5hbWU6IFwicmVzaXphYmxlXCIsXG4gIGFibGVHcm91cDogXCJzaXplXCIsXG4gIGNhblBpbmNoOiB0cnVlLFxuICBwcm9wczoge1xuICAgIHJlc2l6YWJsZTogQm9vbGVhbixcbiAgICB0aHJvdHRsZVJlc2l6ZTogTnVtYmVyLFxuICAgIHJlbmRlckRpcmVjdGlvbnM6IEFycmF5LFxuICAgIGtlZXBSYXRpbzogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvblJlc2l6ZVN0YXJ0OiBcInJlc2l6ZVN0YXJ0XCIsXG4gICAgb25SZXNpemU6IFwicmVzaXplXCIsXG4gICAgb25SZXNpemVFbmQ6IFwicmVzaXplRW5kXCIsXG4gICAgb25SZXNpemVHcm91cFN0YXJ0OiBcInJlc2l6ZUdyb3VwU3RhcnRcIixcbiAgICBvblJlc2l6ZUdyb3VwOiBcInJlc2l6ZUdyb3VwXCIsXG4gICAgb25SZXNpemVHcm91cEVuZDogXCJyZXNpemVHcm91cEVuZFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICByZXNpemFibGUgPSBfYS5yZXNpemFibGUsXG4gICAgICAgIGVkZ2UgPSBfYS5lZGdlO1xuXG4gICAgaWYgKHJlc2l6YWJsZSkge1xuICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckRpYWdvbmFsRGlyZWN0aW9ucyhtb3ZlYWJsZSwgUmVhY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVuZGVyQWxsRGlyZWN0aW9ucyhtb3ZlYWJsZSwgUmVhY3QpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbixcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIHBhcmVudERpcmVjdGlvbiA9IGUucGFyZW50RGlyZWN0aW9uLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIHBhcmVudEZsYWcgPSBlLnBhcmVudEZsYWc7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHBhcmVudERpcmVjdGlvbiB8fCAoaXNQaW5jaCA/IFswLCAwXSA6IGdldERpcmVjdGlvbihpbnB1dEV2ZW50LnRhcmdldCkpO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB0YXJnZXQgPSBfYi50YXJnZXQsXG4gICAgICAgIHdpZHRoID0gX2Iud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9iLmhlaWdodDtcblxuICAgIGlmICghZGlyZWN0aW9uIHx8ICF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAhaXNQaW5jaCAmJiBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGggPSB3aWR0aDtcbiAgICBkYXRhcy5zdGFydE9mZnNldEhlaWdodCA9IGhlaWdodDtcbiAgICBkYXRhcy5wcmV2V2lkdGggPSAwO1xuICAgIGRhdGFzLnByZXZIZWlnaHQgPSAwO1xuICAgIF9hID0gZ2V0Q1NTU2l6ZSh0YXJnZXQpLCBkYXRhcy5zdGFydFdpZHRoID0gX2FbMF0sIGRhdGFzLnN0YXJ0SGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIHBhZGRpbmcgPSBbTWF0aC5tYXgoMCwgd2lkdGggLSBkYXRhcy5zdGFydFdpZHRoKSwgTWF0aC5tYXgoMCwgaGVpZ2h0IC0gZGF0YXMuc3RhcnRIZWlnaHQpXTtcbiAgICBkYXRhcy5taW5TaXplID0gcGFkZGluZztcbiAgICBkYXRhcy5tYXhTaXplID0gW0luZmluaXR5LCBJbmZpbml0eV07XG5cbiAgICBpZiAoIXBhcmVudEZsYWcpIHtcbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHN0eWxlLnBvc2l0aW9uLFxuICAgICAgICAgIG1pbldpZHRoID0gc3R5bGUubWluV2lkdGgsXG4gICAgICAgICAgbWluSGVpZ2h0ID0gc3R5bGUubWluSGVpZ2h0LFxuICAgICAgICAgIG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGgsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gc3R5bGUubWF4SGVpZ2h0O1xuICAgICAgdmFyIGlzUGFyZW50RWxlbWVudCA9IHBvc2l0aW9uID09PSBcInN0YXRpY1wiIHx8IHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCI7XG4gICAgICB2YXIgY29udGFpbmVyID0gaXNQYXJlbnRFbGVtZW50ID8gdGFyZ2V0LnBhcmVudEVsZW1lbnQgOiB0YXJnZXQub2Zmc2V0UGFyZW50O1xuICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG4gICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1BhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICAgICAgY29udGFpbmVyV2lkdGggLT0gcGFyc2VGbG9hdChjb250YWluZXJTdHlsZS5wYWRkaW5nTGVmdCkgfHwgMDtcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQgLT0gcGFyc2VGbG9hdChjb250YWluZXJTdHlsZS5wYWRkaW5nVG9wKSB8fCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRhdGFzLm1pblNpemUgPSBwbHVzKFtjb252ZXJ0VW5pdFNpemUobWluV2lkdGgsIGNvbnRhaW5lcldpZHRoKSB8fCAwLCBjb252ZXJ0VW5pdFNpemUobWluSGVpZ2h0LCBjb250YWluZXJIZWlnaHQpIHx8IDBdLCBwYWRkaW5nKTtcbiAgICAgIGRhdGFzLm1heFNpemUgPSBwbHVzKFtjb252ZXJ0VW5pdFNpemUobWF4V2lkdGgsIGNvbnRhaW5lcldpZHRoKSB8fCBJbmZpbml0eSwgY29udmVydFVuaXRTaXplKG1heEhlaWdodCwgY29udGFpbmVySGVpZ2h0KSB8fCBJbmZpbml0eV0sIHBhZGRpbmcpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBtb3ZlYWJsZS5wcm9wcy50cmFuc2Zvcm1PcmlnaW4gfHwgXCIlICVcIjtcbiAgICBkYXRhcy50cmFuc2Zvcm1PcmlnaW4gPSB0cmFuc2Zvcm1PcmlnaW4gJiYgaXNTdHJpbmcodHJhbnNmb3JtT3JpZ2luKSA/IHRyYW5zZm9ybU9yaWdpbi5zcGxpdChcIiBcIikgOiB0cmFuc2Zvcm1PcmlnaW47XG4gICAgZGF0YXMuaXNXaWR0aCA9ICFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSB8fCBkaXJlY3Rpb25bMF0gfHwgIWRpcmVjdGlvblsxXTtcblxuICAgIGZ1bmN0aW9uIHNldFJhdGlvKHJhdGlvKSB7XG4gICAgICBkYXRhcy5yYXRpbyA9IHJhdGlvICYmIGlzRmluaXRlKHJhdGlvKSA/IHJhdGlvIDogMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbikge1xuICAgICAgZGF0YXMuZml4ZWREaXJlY3Rpb24gPSBmaXhlZERpcmVjdGlvbjtcbiAgICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSBnZXRBYnNvbHV0ZVBvc2l0aW9uKG1vdmVhYmxlLCBmaXhlZERpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgc2V0UmF0aW8od2lkdGggLyBoZWlnaHQpO1xuICAgIHNldEZpeGVkRGlyZWN0aW9uKFstZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXSk7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgc2V0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2lkdGggPSBfYVswXSxcbiAgICAgICAgICAgIHN0YXJ0SGVpZ2h0ID0gX2FbMV07XG4gICAgICAgIGRhdGFzLnN0YXJ0V2lkdGggPSBzdGFydFdpZHRoO1xuICAgICAgICBkYXRhcy5zdGFydEhlaWdodCA9IHN0YXJ0SGVpZ2h0O1xuICAgICAgfSxcbiAgICAgIHNldE1pbjogZnVuY3Rpb24gKG1pblNpemUpIHtcbiAgICAgICAgZGF0YXMubWluU2l6ZSA9IG1pblNpemU7XG4gICAgICB9LFxuICAgICAgc2V0TWF4OiBmdW5jdGlvbiAobWF4U2l6ZSkge1xuICAgICAgICBkYXRhcy5tYXhTaXplID0gW21heFNpemVbMF0gfHwgSW5maW5pdHksIG1heFNpemVbMV0gfHwgSW5maW5pdHldO1xuICAgICAgfSxcbiAgICAgIHNldFJhdGlvOiBzZXRSYXRpbyxcbiAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiBzZXRGaXhlZERpcmVjdGlvbixcbiAgICAgIHNldE9yaWdpbjogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICBkYXRhcy50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICB9LFxuICAgICAgZHJhZ1N0YXJ0OiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSlcbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplU3RhcnRcIiwgcGFyYW1zKTtcblxuICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICBkYXRhcy5pc1Jlc2l6ZSA9IHRydWU7XG4gICAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhcy5pc1Jlc2l6ZSA/IHBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgZGlzdFggPSBlLmRpc3RYLFxuICAgICAgICBkaXN0WSA9IGUuZGlzdFksXG4gICAgICAgIHBhcmVudEZsYWcgPSBlLnBhcmVudEZsYWcsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIHBhcmVudERpc3RhbmNlID0gZS5wYXJlbnREaXN0YW5jZSxcbiAgICAgICAgcGFyZW50U2NhbGUgPSBlLnBhcmVudFNjYWxlLFxuICAgICAgICBwYXJlbnRLZWVwUmF0aW8gPSBlLnBhcmVudEtlZXBSYXRpbyxcbiAgICAgICAgZHJhZ0NsaWVudCA9IGUuZHJhZ0NsaWVudCxcbiAgICAgICAgcGFyZW50RGlzdCA9IGUucGFyZW50RGlzdCxcbiAgICAgICAgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XG4gICAgdmFyIGlzUmVzaXplID0gZGF0YXMuaXNSZXNpemUsXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IGRhdGFzLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgICAgZml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbixcbiAgICAgICAgc3RhcnRXaWR0aCA9IGRhdGFzLnN0YXJ0V2lkdGgsXG4gICAgICAgIHN0YXJ0SGVpZ2h0ID0gZGF0YXMuc3RhcnRIZWlnaHQsXG4gICAgICAgIHByZXZXaWR0aCA9IGRhdGFzLnByZXZXaWR0aCxcbiAgICAgICAgcHJldkhlaWdodCA9IGRhdGFzLnByZXZIZWlnaHQsXG4gICAgICAgIG1pblNpemUgPSBkYXRhcy5taW5TaXplLFxuICAgICAgICBtYXhTaXplID0gZGF0YXMubWF4U2l6ZSxcbiAgICAgICAgcmF0aW8gPSBkYXRhcy5yYXRpbyxcbiAgICAgICAgaXNXaWR0aCA9IGRhdGFzLmlzV2lkdGgsXG4gICAgICAgIHN0YXJ0T2Zmc2V0V2lkdGggPSBkYXRhcy5zdGFydE9mZnNldFdpZHRoLFxuICAgICAgICBzdGFydE9mZnNldEhlaWdodCA9IGRhdGFzLnN0YXJ0T2Zmc2V0SGVpZ2h0O1xuXG4gICAgaWYgKCFpc1Jlc2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICBfYyA9IF9iLnRocm90dGxlUmVzaXplLFxuICAgICAgICB0aHJvdHRsZVJlc2l6ZSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICAgIHBhcmVudE1vdmVhYmxlID0gX2IucGFyZW50TW92ZWFibGUsXG4gICAgICAgIF9kID0gX2Iuc25hcFRocmVzaG9sZCxcbiAgICAgICAgc25hcFRocmVzaG9sZCA9IF9kID09PSB2b2lkIDAgPyA1IDogX2Q7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGRhdGFzLmRpcmVjdGlvbjtcbiAgICB2YXIgc2l6ZURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB2YXIgZGlzdFdpZHRoID0gMDtcbiAgICB2YXIgZGlzdEhlaWdodCA9IDA7XG5cbiAgICBpZiAoIWRpcmVjdGlvblswXSAmJiAhZGlyZWN0aW9uWzFdKSB7XG4gICAgICBzaXplRGlyZWN0aW9uID0gWzEsIDFdO1xuICAgIH1cblxuICAgIHZhciBrZWVwUmF0aW8gPSByYXRpbyAmJiAobW92ZWFibGUucHJvcHMua2VlcFJhdGlvIHx8IHBhcmVudEtlZXBSYXRpbyk7XG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkcmFnQ2xpZW50O1xuXG4gICAgaWYgKCFkcmFnQ2xpZW50KSB7XG4gICAgICBpZiAoIXBhcmVudEZsYWcgJiYgaXNQaW5jaCkge1xuICAgICAgICBmaXhlZFBvc2l0aW9uID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihtb3ZlYWJsZSwgWzAsIDBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJlbnREaXN0KSB7XG4gICAgICBkaXN0V2lkdGggPSBwYXJlbnREaXN0WzBdO1xuICAgICAgZGlzdEhlaWdodCA9IHBhcmVudERpc3RbMV07XG5cbiAgICAgIGlmIChrZWVwUmF0aW8pIHtcbiAgICAgICAgaWYgKCFkaXN0V2lkdGgpIHtcbiAgICAgICAgICBkaXN0V2lkdGggPSBkaXN0SGVpZ2h0ICogcmF0aW87XG4gICAgICAgIH0gZWxzZSBpZiAoIWRpc3RIZWlnaHQpIHtcbiAgICAgICAgICBkaXN0SGVpZ2h0ID0gZGlzdFdpZHRoIC8gcmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmVudFNjYWxlKSB7XG4gICAgICBkaXN0V2lkdGggPSAocGFyZW50U2NhbGVbMF0gLSAxKSAqIHN0YXJ0T2Zmc2V0V2lkdGg7XG4gICAgICBkaXN0SGVpZ2h0ID0gKHBhcmVudFNjYWxlWzFdIC0gMSkgKiBzdGFydE9mZnNldEhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGlzUGluY2gpIHtcbiAgICAgIGlmIChwYXJlbnREaXN0YW5jZSkge1xuICAgICAgICBkaXN0V2lkdGggPSBwYXJlbnREaXN0YW5jZTtcbiAgICAgICAgZGlzdEhlaWdodCA9IHBhcmVudERpc3RhbmNlICogc3RhcnRPZmZzZXRIZWlnaHQgLyBzdGFydE9mZnNldFdpZHRoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlzdCA9IGdldERyYWdEaXN0KHtcbiAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICBkaXN0WDogZGlzdFgsXG4gICAgICAgIGRpc3RZOiBkaXN0WVxuICAgICAgfSk7XG4gICAgICBkaXN0V2lkdGggPSBzaXplRGlyZWN0aW9uWzBdICogZGlzdFswXTtcbiAgICAgIGRpc3RIZWlnaHQgPSBzaXplRGlyZWN0aW9uWzFdICogZGlzdFsxXTtcblxuICAgICAgaWYgKGtlZXBSYXRpbyAmJiBzdGFydE9mZnNldFdpZHRoICYmIHN0YXJ0T2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIHZhciByYWQgPSBnZXRSYWQoWzAsIDBdLCBkaXN0KTtcbiAgICAgICAgdmFyIHN0YW5kYXJkUmFkID0gZ2V0UmFkKFswLCAwXSwgc2l6ZURpcmVjdGlvbik7XG4gICAgICAgIHZhciBzaXplID0gZ2V0RGlzdFNpemUoW2Rpc3RXaWR0aCwgZGlzdEhlaWdodF0pO1xuICAgICAgICB2YXIgc2lnblNpemUgPSBNYXRoLmNvcyhyYWQgLSBzdGFuZGFyZFJhZCkgKiBzaXplO1xuXG4gICAgICAgIGlmICghc2l6ZURpcmVjdGlvblswXSkge1xuICAgICAgICAgIC8vIHRvcCwgYm90dG9tXG4gICAgICAgICAgZGlzdEhlaWdodCA9IHNpZ25TaXplO1xuICAgICAgICAgIGRpc3RXaWR0aCA9IGRpc3RIZWlnaHQgLyByYXRpbztcbiAgICAgICAgfSBlbHNlIGlmICghc2l6ZURpcmVjdGlvblsxXSkge1xuICAgICAgICAgIC8vIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgZGlzdFdpZHRoID0gc2lnblNpemU7XG4gICAgICAgICAgZGlzdEhlaWdodCA9IGRpc3RXaWR0aCAqIHJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHR3by13YXlcbiAgICAgICAgICB2YXIgc3RhcnRXaWR0aFNpemUgPSBzaXplRGlyZWN0aW9uWzBdICogMiAqIHN0YXJ0T2Zmc2V0V2lkdGg7XG4gICAgICAgICAgdmFyIHN0YXJ0SGVpZ2h0U2l6ZSA9IHNpemVEaXJlY3Rpb25bMV0gKiAyICogc3RhcnRPZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgdmFyIGRpc3RTaXplID0gZ2V0RGlzdFNpemUoW3N0YXJ0V2lkdGhTaXplICsgZGlzdFswXSwgc3RhcnRIZWlnaHRTaXplICsgZGlzdFsxXV0pIC0gZ2V0RGlzdFNpemUoW3N0YXJ0V2lkdGhTaXplLCBzdGFydEhlaWdodFNpemVdKTtcbiAgICAgICAgICB2YXIgcmF0aW9SYWQgPSBnZXRSYWQoWzAsIDBdLCBbcmF0aW8sIDFdKTtcbiAgICAgICAgICBkaXN0V2lkdGggPSBNYXRoLmNvcyhyYXRpb1JhZCkgKiBkaXN0U2l6ZTtcbiAgICAgICAgICBkaXN0SGVpZ2h0ID0gTWF0aC5zaW4ocmF0aW9SYWQpICogZGlzdFNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWtlZXBSYXRpbykge1xuICAgICAgICB2YXIgbmV4dERpcmVjdGlvbiA9IF9fc3ByZWFkQXJyYXkoW10sIGRpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKCFzdGFydE9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgaWYgKGRpc3RbMF0gPCAwKSB7XG4gICAgICAgICAgICBuZXh0RGlyZWN0aW9uWzBdID0gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXN0WzBdID4gMCkge1xuICAgICAgICAgICAgbmV4dERpcmVjdGlvblswXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGFydE9mZnNldEhlaWdodCkge1xuICAgICAgICAgIGlmIChkaXN0WzFdIDwgMCkge1xuICAgICAgICAgICAgbmV4dERpcmVjdGlvblsxXSA9IC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdFsxXSA+IDApIHtcbiAgICAgICAgICAgIG5leHREaXJlY3Rpb25bMV0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpcmVjdGlvbiA9IG5leHREaXJlY3Rpb247XG4gICAgICAgIHNpemVEaXJlY3Rpb24gPSBuZXh0RGlyZWN0aW9uO1xuICAgICAgICBkaXN0V2lkdGggPSBzaXplRGlyZWN0aW9uWzBdICogZGlzdFswXTtcbiAgICAgICAgZGlzdEhlaWdodCA9IHNpemVEaXJlY3Rpb25bMV0gKiBkaXN0WzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0V2lkdGggPSBzaXplRGlyZWN0aW9uWzBdIHx8IGtlZXBSYXRpbyA/IE1hdGgubWF4KHN0YXJ0T2Zmc2V0V2lkdGggKyBkaXN0V2lkdGgsIFRJTllfTlVNKSA6IHN0YXJ0T2Zmc2V0V2lkdGg7XG4gICAgdmFyIG5leHRIZWlnaHQgPSBzaXplRGlyZWN0aW9uWzFdIHx8IGtlZXBSYXRpbyA/IE1hdGgubWF4KHN0YXJ0T2Zmc2V0SGVpZ2h0ICsgZGlzdEhlaWdodCwgVElOWV9OVU0pIDogc3RhcnRPZmZzZXRIZWlnaHQ7XG5cbiAgICBpZiAoa2VlcFJhdGlvICYmIHN0YXJ0T2Zmc2V0V2lkdGggJiYgc3RhcnRPZmZzZXRIZWlnaHQpIHtcbiAgICAgIC8vIHN0YXJ0T2Zmc2V0V2lkdGggOiBzdGFydE9mZnNldEhlaWdodCA9IG5leHRXaWR0aCA6IG5leHRIZWlnaHRcbiAgICAgIGlmIChpc1dpZHRoKSB7XG4gICAgICAgIG5leHRIZWlnaHQgPSBuZXh0V2lkdGggLyByYXRpbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRXaWR0aCA9IG5leHRIZWlnaHQgKiByYXRpbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc25hcERpc3QgPSBbMCwgMF07XG5cbiAgICBpZiAoIWlzUGluY2gpIHtcbiAgICAgIHNuYXBEaXN0ID0gY2hlY2tTbmFwUmVzaXplKG1vdmVhYmxlLCBuZXh0V2lkdGgsIG5leHRIZWlnaHQsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudERpc3QpIHtcbiAgICAgICFwYXJlbnREaXN0WzBdICYmIChzbmFwRGlzdFswXSA9IDApO1xuICAgICAgIXBhcmVudERpc3RbMV0gJiYgKHNuYXBEaXN0WzFdID0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGtlZXBSYXRpbykge1xuICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSAmJiBzbmFwRGlzdFswXSAmJiBzbmFwRGlzdFsxXSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoc25hcERpc3RbMF0pID4gTWF0aC5hYnMoc25hcERpc3RbMV0pKSB7XG4gICAgICAgICAgc25hcERpc3RbMV0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNuYXBEaXN0WzBdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNOb1NuYXAgPSAhc25hcERpc3RbMF0gJiYgIXNuYXBEaXN0WzFdO1xuXG4gICAgICBpZiAoaXNOb1NuYXApIHtcbiAgICAgICAgaWYgKGlzV2lkdGgpIHtcbiAgICAgICAgICBuZXh0V2lkdGggPSB0aHJvdHRsZShuZXh0V2lkdGgsIHRocm90dGxlUmVzaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0SGVpZ2h0ID0gdGhyb3R0bGUobmV4dEhlaWdodCwgdGhyb3R0bGVSZXNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplRGlyZWN0aW9uWzBdICYmICFzaXplRGlyZWN0aW9uWzFdIHx8IHNuYXBEaXN0WzBdICYmICFzbmFwRGlzdFsxXSB8fCBpc05vU25hcCAmJiBpc1dpZHRoKSB7XG4gICAgICAgIG5leHRXaWR0aCArPSBzbmFwRGlzdFswXTtcbiAgICAgICAgbmV4dEhlaWdodCA9IG5leHRXaWR0aCAvIHJhdGlvO1xuICAgICAgfSBlbHNlIGlmICghc2l6ZURpcmVjdGlvblswXSAmJiBzaXplRGlyZWN0aW9uWzFdIHx8ICFzbmFwRGlzdFswXSAmJiBzbmFwRGlzdFsxXSB8fCBpc05vU25hcCAmJiAhaXNXaWR0aCkge1xuICAgICAgICBuZXh0SGVpZ2h0ICs9IHNuYXBEaXN0WzFdO1xuICAgICAgICBuZXh0V2lkdGggPSBuZXh0SGVpZ2h0ICogcmF0aW87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydE9mZnNldFdpZHRoICsgZGlzdFdpZHRoIDwgLXNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgc25hcERpc3RbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRPZmZzZXRXaWR0aCArIGRpc3RIZWlnaHQgPCAtc25hcFRocmVzaG9sZCkge1xuICAgICAgICBzbmFwRGlzdFsxXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIG5leHRXaWR0aCArPSBzbmFwRGlzdFswXTtcbiAgICAgIG5leHRIZWlnaHQgKz0gc25hcERpc3RbMV07XG5cbiAgICAgIGlmICghc25hcERpc3RbMF0pIHtcbiAgICAgICAgbmV4dFdpZHRoID0gdGhyb3R0bGUobmV4dFdpZHRoLCB0aHJvdHRsZVJlc2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc25hcERpc3RbMV0pIHtcbiAgICAgICAgbmV4dEhlaWdodCA9IHRocm90dGxlKG5leHRIZWlnaHQsIHRocm90dGxlUmVzaXplKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYSA9IGNhbGN1bGF0ZUJvdW5kU2l6ZShbbmV4dFdpZHRoLCBuZXh0SGVpZ2h0XSwgbWluU2l6ZSwgbWF4U2l6ZSwga2VlcFJhdGlvKSwgbmV4dFdpZHRoID0gX2FbMF0sIG5leHRIZWlnaHQgPSBfYVsxXTtcbiAgICBuZXh0V2lkdGggPSBNYXRoLnJvdW5kKG5leHRXaWR0aCk7XG4gICAgbmV4dEhlaWdodCA9IE1hdGgucm91bmQobmV4dEhlaWdodCk7XG4gICAgZGlzdFdpZHRoID0gbmV4dFdpZHRoIC0gc3RhcnRPZmZzZXRXaWR0aDtcbiAgICBkaXN0SGVpZ2h0ID0gbmV4dEhlaWdodCAtIHN0YXJ0T2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBkZWx0YSA9IFtkaXN0V2lkdGggLSBwcmV2V2lkdGgsIGRpc3RIZWlnaHQgLSBwcmV2SGVpZ2h0XTtcbiAgICBkYXRhcy5wcmV2V2lkdGggPSBkaXN0V2lkdGg7XG4gICAgZGF0YXMucHJldkhlaWdodCA9IGRpc3RIZWlnaHQ7XG4gICAgdmFyIGludmVyc2VEZWx0YSA9IGdldFJlc2l6ZURpc3QobW92ZWFibGUsIG5leHRXaWR0aCwgbmV4dEhlaWdodCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIHRyYW5zZm9ybU9yaWdpbik7XG5cbiAgICBpZiAoIXBhcmVudE1vdmVhYmxlICYmIGRlbHRhLmV2ZXJ5KGZ1bmN0aW9uIChudW0pIHtcbiAgICAgIHJldHVybiAhbnVtO1xuICAgIH0pICYmIGludmVyc2VEZWx0YS5ldmVyeShmdW5jdGlvbiAobnVtKSB7XG4gICAgICByZXR1cm4gIW51bTtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICB3aWR0aDogc3RhcnRXaWR0aCArIGRpc3RXaWR0aCxcbiAgICAgIGhlaWdodDogc3RhcnRIZWlnaHQgKyBkaXN0SGVpZ2h0LFxuICAgICAgb2Zmc2V0V2lkdGg6IG5leHRXaWR0aCxcbiAgICAgIG9mZnNldEhlaWdodDogbmV4dEhlaWdodCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgZGlzdDogW2Rpc3RXaWR0aCwgZGlzdEhlaWdodF0sXG4gICAgICBkZWx0YTogZGVsdGEsXG4gICAgICBpc1BpbmNoOiAhIWlzUGluY2gsXG4gICAgICBkcmFnOiBEcmFnZ2FibGUuZHJhZyhtb3ZlYWJsZSwgc2V0Q3VzdG9tRHJhZyhlLCBtb3ZlYWJsZS5zdGF0ZSwgaW52ZXJzZURlbHRhLCAhIWlzUGluY2gsIGZhbHNlKSlcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZXNpemVcIiwgcGFyYW1zKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LFxuICBkcmFnQ29udHJvbEFmdGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuICAgIHZhciBpc1Jlc2l6ZSA9IGRhdGFzLmlzUmVzaXplLFxuICAgICAgICBzdGFydE9mZnNldFdpZHRoID0gZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCxcbiAgICAgICAgc3RhcnRPZmZzZXRIZWlnaHQgPSBkYXRhcy5zdGFydE9mZnNldEhlaWdodCxcbiAgICAgICAgcHJldldpZHRoID0gZGF0YXMucHJldldpZHRoLFxuICAgICAgICBwcmV2SGVpZ2h0ID0gZGF0YXMucHJldkhlaWdodDtcblxuICAgIGlmICghaXNSZXNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgIHZhciBlcnJvcldpZHRoID0gd2lkdGggLSAoc3RhcnRPZmZzZXRXaWR0aCArIHByZXZXaWR0aCk7XG4gICAgdmFyIGVycm9ySGVpZ2h0ID0gaGVpZ2h0IC0gKHN0YXJ0T2Zmc2V0SGVpZ2h0ICsgcHJldkhlaWdodCk7XG4gICAgdmFyIGlzRXJyb3JXaWR0aCA9IE1hdGguYWJzKGVycm9yV2lkdGgpID4gMztcbiAgICB2YXIgaXNFcnJvckhlaWdodCA9IE1hdGguYWJzKGVycm9ySGVpZ2h0KSA+IDM7XG5cbiAgICBpZiAoaXNFcnJvcldpZHRoKSB7XG4gICAgICBkYXRhcy5zdGFydFdpZHRoICs9IGVycm9yV2lkdGg7XG4gICAgICBkYXRhcy5zdGFydE9mZnNldFdpZHRoICs9IGVycm9yV2lkdGg7XG4gICAgICBkYXRhcy5wcmV2V2lkdGggKz0gZXJyb3JXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoaXNFcnJvckhlaWdodCkge1xuICAgICAgZGF0YXMuc3RhcnRIZWlnaHQgKz0gZXJyb3JIZWlnaHQ7XG4gICAgICBkYXRhcy5zdGFydE9mZnNldEhlaWdodCArPSBlcnJvckhlaWdodDtcbiAgICAgIGRhdGFzLnByZXZIZWlnaHQgKz0gZXJyb3JIZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JXaWR0aCB8fCBpc0Vycm9ySGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XG4gICAgfVxuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSZXNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhcy5pc1Jlc2l6ZSA9IGZhbHNlO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplRW5kXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZGlyZWN0aW9uQ29uZGl0aW9uLFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbEV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJyZXNpemFibGVcIiwgZSk7XG5cbiAgICBmdW5jdGlvbiBzZXREaXN0KGNoaWxkLCBldikge1xuICAgICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb247XG4gICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb247XG4gICAgICB2YXIgcG9zID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihjaGlsZCwgZml4ZWREaXJlY3Rpb24pO1xuXG4gICAgICB2YXIgX2EgPSBjYWxjdWxhdGUoY3JlYXRlUm90YXRlTWF0cml4KC1tb3ZlYWJsZS5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLCBbcG9zWzBdIC0gZml4ZWRQb3NpdGlvblswXSwgcG9zWzFdIC0gZml4ZWRQb3NpdGlvblsxXSwgMV0sIDMpLFxuICAgICAgICAgIG9yaWdpbmFsWCA9IF9hWzBdLFxuICAgICAgICAgIG9yaWdpbmFsWSA9IF9hWzFdO1xuXG4gICAgICBldi5kYXRhcy5vcmlnaW5hbFggPSBvcmlnaW5hbFg7XG4gICAgICBldi5kYXRhcy5vcmlnaW5hbFkgPSBvcmlnaW5hbFk7XG4gICAgICByZXR1cm4gZXY7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sU3RhcnRcIiwgZSwgZnVuY3Rpb24gKGNoaWxkLCBldikge1xuICAgICAgcmV0dXJuIHNldERpc3QoY2hpbGQsIGV2KTtcbiAgICB9KTtcblxuICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtcyksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiBmdW5jdGlvbiAoZml4ZWREaXJlY3Rpb24pIHtcbiAgICAgICAgcGFyYW1zLnNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKTtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2LCBpKSB7XG4gICAgICAgICAgZXYuc2V0Rml4ZWREaXJlY3Rpb24oZml4ZWREaXJlY3Rpb24pO1xuICAgICAgICAgIHNldERpc3QobW92ZWFibGUubW92ZWFibGVzW2ldLCBvcmlnaW5hbEV2ZW50c1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZUdyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XG4gICAgZGF0YXMuaXNSZXNpemUgPSByZXN1bHQgIT09IGZhbHNlO1xuICAgIHJldHVybiBkYXRhcy5pc1Jlc2l6ZSA/IHBhcmFtcyA6IGZhbHNlO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc1Jlc2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sKG1vdmVhYmxlLCBlKTtcblxuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldFdpZHRoID0gcGFyYW1zLm9mZnNldFdpZHRoLFxuICAgICAgICBvZmZzZXRIZWlnaHQgPSBwYXJhbXMub2Zmc2V0SGVpZ2h0LFxuICAgICAgICBkaXN0ID0gcGFyYW1zLmRpc3Q7XG4gICAgdmFyIGtlZXBSYXRpbyA9IG1vdmVhYmxlLnByb3BzLmtlZXBSYXRpbztcbiAgICB2YXIgcGFyZW50U2NhbGUgPSBbb2Zmc2V0V2lkdGggLyAob2Zmc2V0V2lkdGggLSBkaXN0WzBdKSwgb2Zmc2V0SGVpZ2h0IC8gKG9mZnNldEhlaWdodCAtIGRpc3RbMV0pXTtcbiAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb247XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sXCIsIGUsIGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgdmFyIF9hID0gY2FsY3VsYXRlKGNyZWF0ZVJvdGF0ZU1hdHJpeChtb3ZlYWJsZS5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLCBbZXYuZGF0YXMub3JpZ2luYWxYICogcGFyZW50U2NhbGVbMF0sIGV2LmRhdGFzLm9yaWdpbmFsWSAqIHBhcmVudFNjYWxlWzFdLCAxXSwgMyksXG4gICAgICAgICAgY2xpZW50WCA9IF9hWzBdLFxuICAgICAgICAgIGNsaWVudFkgPSBfYVsxXTtcblxuICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHtcbiAgICAgICAgcGFyZW50RGlzdDogbnVsbCxcbiAgICAgICAgcGFyZW50U2NhbGU6IHBhcmVudFNjYWxlLFxuICAgICAgICBkcmFnQ2xpZW50OiBwbHVzKGZpeGVkUG9zaXRpb24sIFtjbGllbnRYLCBjbGllbnRZXSksXG4gICAgICAgIHBhcmVudEtlZXBSYXRpbzoga2VlcFJhdGlvXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oe1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSwgcGFyYW1zKTtcblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJlc2l6ZUdyb3VwXCIsIG5leHRQYXJhbXMpO1xuICAgIHJldHVybiBuZXh0UGFyYW1zO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgaXNEcmFnID0gZS5pc0RyYWcsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNSZXNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdDb250cm9sRW5kKG1vdmVhYmxlLCBlKTtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xFbmRcIiwgZSk7XG4gICAgdmFyIG5leHRQYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZXNpemVHcm91cEVuZFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gaXNEcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlLlJlc2l6YWJsZSNyZXF1ZXN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZV0gLSB0aGUgUmVzaXphYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRpcmVjdGlvbj1bMSwgMV1dIC0gRGlyZWN0aW9uIHRvIHJlc2l6ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFXaWR0aF0gLSBkZWx0YSBudW1iZXIgb2Ygd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhSGVpZ2h0XSAtIGRlbHRhIG51bWJlciBvZiBoZWlnaHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLm9mZnNldFdpZHRoXSAtIG9mZnNldCBudW1iZXIgb2Ygd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLm9mZnNldEhlaWdodF0gLSBvZmZzZXQgbnVtYmVyIG9mIGhlaWdodFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2UuaXNJbnN0YW50XSAtIFdoZXRoZXIgdG8gZXhlY3V0ZSB0aGUgcmVxdWVzdCBpbnN0YW50bHlcbiAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcbiAgICogQGV4YW1wbGVcbiAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0sIHRydWUpO1xuICAgKlxuICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcbiAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMDAsIG9mZnNldEhlaWdodDogMTAwIH0sIHRydWUpO1xuICAgKlxuICAgKiAvLyByZXF1ZXN0U3RhcnRcbiAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiKTtcbiAgICpcbiAgICogLy8gcmVxdWVzdFxuICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICpcbiAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJyZXNpemFibGVcIiwgeyBvZmZzZXRXaWR0aDogMTAwLCBvZmZzZXRIZWlnaHQ6IDEwMCB9KTtcbiAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMTAsIG9mZnNldEhlaWdodDogMTAwIH0pO1xuICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwicmVzaXphYmxlXCIsIHsgb2Zmc2V0V2lkdGg6IDEyMCwgb2Zmc2V0SGVpZ2h0OiAxMDAgfSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RFbmRcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIHZhciBkYXRhcyA9IHt9O1xuICAgIHZhciBkaXN0V2lkdGggPSAwO1xuICAgIHZhciBkaXN0SGVpZ2h0ID0gMDtcbiAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiB0cnVlLFxuICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBwYXJlbnREaXJlY3Rpb246IGUuZGlyZWN0aW9uIHx8IFsxLCAxXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcIm9mZnNldFdpZHRoXCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RXaWR0aCA9IGUub2Zmc2V0V2lkdGggLSByZWN0Lm9mZnNldFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZGVsdGFXaWR0aFwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0V2lkdGggKz0gZS5kZWx0YVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwib2Zmc2V0SGVpZ2h0XCIgaW4gZSkge1xuICAgICAgICAgIGRpc3RIZWlnaHQgPSBlLm9mZnNldEhlaWdodCAtIHJlY3Qub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKFwiZGVsdGFIZWlnaHRcIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdEhlaWdodCArPSBlLmRlbHRhSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgcGFyZW50RGlzdDogW2Rpc3RXaWR0aCwgZGlzdEhlaWdodF1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIGlzRHJhZzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgcmVzaXplZC4gKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI3Jlc2l6YWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcmVzaXphYmxlOiBmYWxzZSxcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLnJlc2l6YWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiB0aHJvdHRsZSBvZiB3aWR0aCwgaGVpZ2h0IHdoZW4gcmVzaXplLlxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI3Rocm90dGxlUmVzaXplXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgcmVzaXphYmxlOiB0cnVlLFxuICogICB0aHJvdHRsZVJlc2l6ZTogMCxcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLnRocm90dGxlUmVzaXplID0gMTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gcmVzaXplIG9yIHNjYWxlLCBrZWVwcyBhIHJhdGlvIG9mIHRoZSB3aWR0aCwgaGVpZ2h0LiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5SZXNpemFibGUja2VlcFJhdGlvXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgcmVzaXphYmxlOiB0cnVlLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUua2VlcFJhdGlvID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFNldCBkaXJlY3Rpb25zIHRvIHNob3cgdGhlIGNvbnRyb2wgYm94LiAoZGVmYXVsdDogW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdKVxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI3JlbmRlckRpcmVjdGlvbnNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICByZXNpemFibGU6IHRydWUsXG4gKiAgIHJlbmRlckRpcmVjdGlvbnM6IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXSxcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLnJlbmRlckRpcmVjdGlvbnMgPSBbXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHJlc2l6ZSBzdGFydHMsIHRoZSByZXNpemVTdGFydCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXG4gKiBAZXZlbnQgcmVzaXplU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHJlc2l6ZVN0YXJ0IGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcmVzaXphYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJyZXNpemVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gcmVzaXppbmcsIHRoZSByZXNpemUgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxuICogQGV2ZW50IHJlc2l6ZVxuICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuT25SZXNpemV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHJlc2l6ZSBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJlc2l6YWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVzaXplXCIsICh7IHRhcmdldCwgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gKiAgICAgdGFyZ2V0LnN0eWxlLndpZHRoID0gYCR7ZS53aWR0aH1weGA7XG4gKiAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IGAke2UuaGVpZ2h0fXB4YDtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgcmVzaXplIGZpbmlzaGVzLCB0aGUgcmVzaXplRW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcbiAqIEBldmVudCByZXNpemVFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByZXNpemVFbmQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByZXNpemFibGU6IHRydWUgfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlc2l6ZUVuZFwiLCAoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIHJlc2l6ZSBzdGFydHMsIHRoZSBgcmVzaXplR3JvdXBTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXG4qIEBldmVudCByZXNpemVHcm91cFN0YXJ0XG4qIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlc2l6ZUdyb3VwU3RhcnRgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHJlc2l6YWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJyZXNpemVHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvblJlc2l6ZUdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XG4qIH0pO1xuKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIHJlc2l6ZSwgdGhlIGByZXNpemVHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXG4qIEBldmVudCByZXNpemVHcm91cFxuKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5vblJlc2l6ZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVzaXplR3JvdXBgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHJlc2l6YWJsZTogdHJ1ZVxuKiB9KTtcbiogbW92ZWFibGUub24oXCJyZXNpemVHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvblJlc2l6ZUdyb3VwXCIsIHRhcmdldHMpO1xuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xuKiAgICAgICAgIGNvbnN0IG9mZnNldCA9IFtcbiogICAgICAgICAgICAgZGlyZWN0aW9uWzBdIDwgMCA/IC1ldi5kZWx0YVswXSA6IDAsXG4qICAgICAgICAgICAgIGRpcmVjdGlvblsxXSA8IDAgPyAtZXYuZGVsdGFbMV0gOiAwLFxuKiAgICAgICAgIF07XG4qICAgICAgICAgLy8gZXYuZHJhZyBpcyBhIGRyYWcgZXZlbnQgdGhhdCBvY2N1cnMgd2hlbiB0aGUgZ3JvdXAgcmVzaXplLlxuKiAgICAgICAgIGNvbnN0IGxlZnQgPSBvZmZzZXRbMF0gKyBldi5kcmFnLmJlZm9yZURpc3RbMF07XG4qICAgICAgICAgY29uc3QgdG9wID0gb2Zmc2V0WzFdICsgZXYuZHJhZy5iZWZvcmVEaXN0WzFdO1xuKiAgICAgICAgIGNvbnN0IHdpZHRoID0gZXYud2lkdGg7XG4qICAgICAgICAgY29uc3QgdG9wID0gZXYudG9wO1xuKiAgICAgfSk7XG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCByZXNpemUgZmluaXNoZXMsIHRoZSBgcmVzaXplR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcbiAqIEBldmVudCByZXNpemVHcm91cEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5SZXNpemFibGUuT25SZXNpemVHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlc2l6ZUdyb3VwRW5kYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqICAgICByZXNpemFibGU6IHRydWVcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyZXNpemVHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25SZXNpemVHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFNjYWxhYmxlXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBkZXNjcmlwdGlvbiBTY2FsYWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0J3MgeCBhbmQgeSBjYW4gYmUgc2NhbGUgb2YgdHJhbnNmb3JtLlxuICovXG5cbnZhciBTY2FsYWJsZSA9IHtcbiAgbmFtZTogXCJzY2FsYWJsZVwiLFxuICBhYmxlR3JvdXA6IFwic2l6ZVwiLFxuICBjYW5QaW5jaDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBzY2FsYWJsZTogQm9vbGVhbixcbiAgICB0aHJvdHRsZVNjYWxlOiBOdW1iZXIsXG4gICAgcmVuZGVyRGlyZWN0aW9uczogU3RyaW5nLFxuICAgIGtlZXBSYXRpbzogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvblNjYWxlU3RhcnQ6IFwic2NhbGVTdGFydFwiLFxuICAgIG9uU2NhbGU6IFwic2NhbGVcIixcbiAgICBvblNjYWxlRW5kOiBcInNjYWxlRW5kXCIsXG4gICAgb25TY2FsZUdyb3VwU3RhcnQ6IFwic2NhbGVHcm91cFN0YXJ0XCIsXG4gICAgb25TY2FsZUdyb3VwOiBcInNjYWxlR3JvdXBcIixcbiAgICBvblNjYWxlR3JvdXBFbmQ6IFwic2NhbGVHcm91cEVuZFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICByZXNpemFibGUgPSBfYS5yZXNpemFibGUsXG4gICAgICAgIHNjYWxhYmxlID0gX2Euc2NhbGFibGUsXG4gICAgICAgIGVkZ2UgPSBfYS5lZGdlO1xuXG4gICAgaWYgKCFyZXNpemFibGUgJiYgc2NhbGFibGUpIHtcbiAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJEaWFnb25hbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbmRlckFsbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KTtcbiAgICB9XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBkaXJlY3Rpb25Db25kaXRpb24sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIHBhcmVudERpcmVjdGlvbiA9IGUucGFyZW50RGlyZWN0aW9uO1xuICAgIHZhciBkaXJlY3Rpb24gPSBwYXJlbnREaXJlY3Rpb24gfHwgKGlzUGluY2ggPyBbMCwgMF0gOiBnZXREaXJlY3Rpb24oaW5wdXRFdmVudC50YXJnZXQpKTtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0gPSBfYS50YXJnZXRUcmFuc2Zvcm0sXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgcG9zMSA9IF9hLnBvczEsXG4gICAgICAgIHBvczIgPSBfYS5wb3MyLFxuICAgICAgICBwb3M0ID0gX2EucG9zNDtcblxuICAgIGlmICghZGlyZWN0aW9uIHx8ICF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGluY2gpIHtcbiAgICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgfVxuXG4gICAgZGF0YXMuZGF0YXMgPSB7fTtcbiAgICBkYXRhcy50cmFuc2Zvcm0gPSB0YXJnZXRUcmFuc2Zvcm07XG4gICAgZGF0YXMucHJldkRpc3QgPSBbMSwgMV07XG4gICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIGRhdGFzLndpZHRoID0gd2lkdGg7XG4gICAgZGF0YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBbMSwgMV07XG4gICAgdmFyIHNjYWxlV2lkdGggPSBnZXREaXN0JDEocG9zMSwgcG9zMik7XG4gICAgdmFyIHNjYWxlSGVpZ2h0ID0gZ2V0RGlzdCQxKHBvczIsIHBvczQpO1xuICAgIHZhciBpc1dpZHRoID0gIWRpcmVjdGlvblswXSAmJiAhZGlyZWN0aW9uWzFdIHx8IGRpcmVjdGlvblswXSB8fCAhZGlyZWN0aW9uWzFdO1xuICAgIGRhdGFzLnNjYWxlV2lkdGggPSBzY2FsZVdpZHRoO1xuICAgIGRhdGFzLnNjYWxlSGVpZ2h0ID0gc2NhbGVIZWlnaHQ7XG4gICAgZGF0YXMuc2NhbGVYUmF0aW8gPSBzY2FsZVdpZHRoIC8gd2lkdGg7XG4gICAgZGF0YXMuc2NhbGVZUmF0aW8gPSBzY2FsZUhlaWdodCAvIGhlaWdodDtcbiAgICBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgoZSwgXCJzY2FsZVwiKTtcbiAgICBkYXRhcy5pc1dpZHRoID0gaXNXaWR0aDtcblxuICAgIGZ1bmN0aW9uIHNldFJhdGlvKHJhdGlvKSB7XG4gICAgICBkYXRhcy5yYXRpbyA9IHJhdGlvICYmIGlzRmluaXRlKHJhdGlvKSA/IHJhdGlvIDogMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbikge1xuICAgICAgZGF0YXMuZml4ZWREaXJlY3Rpb24gPSBmaXhlZERpcmVjdGlvbjtcbiAgICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSBnZXRBYnNvbHV0ZVBvc2l0aW9uKG1vdmVhYmxlLCBmaXhlZERpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgc2V0UmF0aW8oZ2V0RGlzdCQxKHBvczEsIHBvczIpIC8gZ2V0RGlzdCQxKHBvczIsIHBvczQpKTtcbiAgICBzZXRGaXhlZERpcmVjdGlvbihbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV0pO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIHNldDogZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBzY2FsZTtcbiAgICAgIH0sXG4gICAgICBzZXRSYXRpbzogc2V0UmF0aW8sXG4gICAgICBzZXRGaXhlZERpcmVjdGlvbjogc2V0Rml4ZWREaXJlY3Rpb25cbiAgICB9LCBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChlKSksIHtcbiAgICAgIGRyYWdTdGFydDogRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgbmV3IEN1c3RvbUdlc3RvKCkuZHJhZ1N0YXJ0KFswLCAwXSwgZSkpXG4gICAgfSkpO1xuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZVN0YXJ0XCIsIHBhcmFtcyk7XG5cbiAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNTY2FsZSA9IHRydWU7XG4gICAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcbiAgICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhcy5pc1NjYWxlID8gcGFyYW1zIDogZmFsc2U7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXNvbHZlVHJhbnNmb3JtRXZlbnQoZSwgXCJzY2FsZVwiKTtcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICBkaXN0WCA9IGUuZGlzdFgsXG4gICAgICAgIGRpc3RZID0gZS5kaXN0WSxcbiAgICAgICAgcGFyZW50U2NhbGUgPSBlLnBhcmVudFNjYWxlLFxuICAgICAgICBwYXJlbnREaXN0YW5jZSA9IGUucGFyZW50RGlzdGFuY2UsXG4gICAgICAgIHBhcmVudEtlZXBSYXRpbyA9IGUucGFyZW50S2VlcFJhdGlvLFxuICAgICAgICBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnLFxuICAgICAgICBpc1BpbmNoID0gZS5pc1BpbmNoLFxuICAgICAgICBkcmFnQ2xpZW50ID0gZS5kcmFnQ2xpZW50LFxuICAgICAgICBwYXJlbnREaXN0ID0gZS5wYXJlbnREaXN0LFxuICAgICAgICBpc1JlcXVlc3QgPSBlLmlzUmVxdWVzdDtcbiAgICB2YXIgcHJldkRpc3QgPSBkYXRhcy5wcmV2RGlzdCxcbiAgICAgICAgZGlyZWN0aW9uID0gZGF0YXMuZGlyZWN0aW9uLFxuICAgICAgICB3aWR0aCA9IGRhdGFzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBkYXRhcy5oZWlnaHQsXG4gICAgICAgIGlzU2NhbGUgPSBkYXRhcy5pc1NjYWxlLFxuICAgICAgICBzdGFydFZhbHVlID0gZGF0YXMuc3RhcnRWYWx1ZSxcbiAgICAgICAgaXNXaWR0aCA9IGRhdGFzLmlzV2lkdGgsXG4gICAgICAgIHJhdGlvID0gZGF0YXMucmF0aW8sXG4gICAgICAgIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb24sXG4gICAgICAgIHNjYWxlWFJhdGlvID0gZGF0YXMuc2NhbGVYUmF0aW8sXG4gICAgICAgIHNjYWxlWVJhdGlvID0gZGF0YXMuc2NhbGVZUmF0aW87XG5cbiAgICBpZiAoIWlzU2NhbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgdGhyb3R0bGVTY2FsZSA9IF9hLnRocm90dGxlU2NhbGUsXG4gICAgICAgIHBhcmVudE1vdmVhYmxlID0gX2EucGFyZW50TW92ZWFibGU7XG4gICAgdmFyIHNpemVEaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cbiAgICBpZiAoIWRpcmVjdGlvblswXSAmJiAhZGlyZWN0aW9uWzFdKSB7XG4gICAgICBzaXplRGlyZWN0aW9uID0gWzEsIDFdO1xuICAgIH1cblxuICAgIHZhciBrZWVwUmF0aW8gPSByYXRpbyAmJiAobW92ZWFibGUucHJvcHMua2VlcFJhdGlvIHx8IHBhcmVudEtlZXBSYXRpbyk7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgdmFyIHNjYWxlWSA9IDE7XG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkcmFnQ2xpZW50O1xuXG4gICAgaWYgKCFkcmFnQ2xpZW50KSB7XG4gICAgICBpZiAoIXBhcmVudEZsYWcgJiYgaXNQaW5jaCkge1xuICAgICAgICBmaXhlZFBvc2l0aW9uID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihtb3ZlYWJsZSwgWzAsIDBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJlbnREaXN0KSB7XG4gICAgICBzY2FsZVggPSAod2lkdGggKyBwYXJlbnREaXN0WzBdKSAvIHdpZHRoO1xuICAgICAgc2NhbGVZID0gKGhlaWdodCArIHBhcmVudERpc3RbMV0pIC8gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAocGFyZW50U2NhbGUpIHtcbiAgICAgIHNjYWxlWCA9IHBhcmVudFNjYWxlWzBdO1xuICAgICAgc2NhbGVZID0gcGFyZW50U2NhbGVbMV07XG4gICAgfSBlbHNlIGlmIChpc1BpbmNoKSB7XG4gICAgICBpZiAocGFyZW50RGlzdGFuY2UpIHtcbiAgICAgICAgc2NhbGVYID0gKHdpZHRoICsgcGFyZW50RGlzdGFuY2UpIC8gd2lkdGg7XG4gICAgICAgIHNjYWxlWSA9IChoZWlnaHQgKyBwYXJlbnREaXN0YW5jZSAqIGhlaWdodCAvIHdpZHRoKSAvIGhlaWdodDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRyYWdEaXN0ID0gZ2V0RHJhZ0Rpc3Qoe1xuICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgICAgZGlzdFk6IGRpc3RZXG4gICAgICB9KTtcbiAgICAgIHZhciBkaXN0U2NhbGVXaWR0aCA9IHNpemVEaXJlY3Rpb25bMF0gKiBkcmFnRGlzdFswXSAqIHNjYWxlWFJhdGlvO1xuICAgICAgdmFyIGRpc3RTY2FsZUhlaWdodCA9IHNpemVEaXJlY3Rpb25bMV0gKiBkcmFnRGlzdFsxXSAqIHNjYWxlWVJhdGlvO1xuXG4gICAgICBpZiAoa2VlcFJhdGlvICYmIHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICBpZiAoIXNpemVEaXJlY3Rpb25bMF0pIHtcbiAgICAgICAgICAvLyB0b3AsIGJvdHRvbVxuICAgICAgICAgIC8vIGRpc3RIZWlnaHQgPSBzaWduU2l6ZTtcbiAgICAgICAgICBkaXN0U2NhbGVXaWR0aCA9IGRpc3RTY2FsZUhlaWdodCAqIHJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKCFzaXplRGlyZWN0aW9uWzFdKSB7XG4gICAgICAgICAgLy8gbGVmdCwgcmlnaHRcbiAgICAgICAgICAvLyBkaXN0V2lkdGggPSBzaWduU2l6ZTtcbiAgICAgICAgICBkaXN0U2NhbGVIZWlnaHQgPSBkaXN0U2NhbGVXaWR0aCAvIHJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzaXplID0gZ2V0RGlzdFNpemUoW2Rpc3RTY2FsZVdpZHRoLCBkaXN0U2NhbGVIZWlnaHRdKTsgLy8gdHdvLXdheVxuXG4gICAgICAgICAgdmFyIGRyYWdSYWQgPSBnZXRSYWQoWzAsIDBdLCBkcmFnRGlzdCk7XG4gICAgICAgICAgdmFyIHN0YW5kYXJkUmFkID0gZ2V0UmFkKFswLCAwXSwgc2l6ZURpcmVjdGlvbik7XG4gICAgICAgICAgdmFyIHNpZ25TaXplID0gTWF0aC5jb3MoZHJhZ1JhZCAtIHN0YW5kYXJkUmFkKSAqIHNpemU7XG4gICAgICAgICAgdmFyIHJhdGlvUmFkID0gZ2V0UmFkKFswLCAwXSwgW3JhdGlvLCAxXSk7XG4gICAgICAgICAgZGlzdFNjYWxlV2lkdGggPSBNYXRoLmNvcyhyYXRpb1JhZCkgKiBzaWduU2l6ZTtcbiAgICAgICAgICBkaXN0U2NhbGVIZWlnaHQgPSBNYXRoLnNpbihyYXRpb1JhZCkgKiBzaWduU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzY2FsZVggPSAod2lkdGggKyBkaXN0U2NhbGVXaWR0aCAvIHNjYWxlWFJhdGlvKSAvIHdpZHRoO1xuICAgICAgc2NhbGVZID0gKGhlaWdodCArIGRpc3RTY2FsZUhlaWdodCAvIHNjYWxlWVJhdGlvKSAvIGhlaWdodDtcbiAgICB9XG5cbiAgICBzY2FsZVggPSBzaXplRGlyZWN0aW9uWzBdIHx8IGtlZXBSYXRpbyA/IHNjYWxlWCAqIHN0YXJ0VmFsdWVbMF0gOiBzdGFydFZhbHVlWzBdO1xuICAgIHNjYWxlWSA9IHNpemVEaXJlY3Rpb25bMV0gfHwga2VlcFJhdGlvID8gc2NhbGVZICogc3RhcnRWYWx1ZVsxXSA6IHN0YXJ0VmFsdWVbMV07XG5cbiAgICBpZiAoc2NhbGVYID09PSAwKSB7XG4gICAgICBzY2FsZVggPSAocHJldkRpc3RbMF0gPiAwID8gMSA6IC0xKSAqIE1JTl9TQ0FMRTtcbiAgICB9XG5cbiAgICBpZiAoc2NhbGVZID09PSAwKSB7XG4gICAgICBzY2FsZVkgPSAocHJldkRpc3RbMV0gPiAwID8gMSA6IC0xKSAqIE1JTl9TQ0FMRTtcbiAgICB9XG5cbiAgICB2YXIgZGlzdCA9IFtzY2FsZVggLyBzdGFydFZhbHVlWzBdLCBzY2FsZVkgLyBzdGFydFZhbHVlWzFdXTtcbiAgICB2YXIgc2NhbGUgPSBbc2NhbGVYLCBzY2FsZVldO1xuXG4gICAgaWYgKCFpc1BpbmNoICYmIG1vdmVhYmxlLnByb3BzLmdyb3VwYWJsZSkge1xuICAgICAgdmFyIHNuYXBSZW5kZXJJbmZvID0gc3RhdGUuc25hcFJlbmRlckluZm8gfHwge307XG4gICAgICB2YXIgc3RhdGVEaXJlY3Rpb24gPSBzbmFwUmVuZGVySW5mby5kaXJlY3Rpb247XG5cbiAgICAgIGlmIChpc0FycmF5KHN0YXRlRGlyZWN0aW9uKSAmJiAoc3RhdGVEaXJlY3Rpb25bMF0gfHwgc3RhdGVEaXJlY3Rpb25bMV0pKSB7XG4gICAgICAgIHN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNuYXBEaXN0ID0gWzAsIDBdO1xuXG4gICAgaWYgKCFpc1BpbmNoKSB7XG4gICAgICBzbmFwRGlzdCA9IGNoZWNrU25hcFNjYWxlKG1vdmVhYmxlLCBkaXN0LCBkaXJlY3Rpb24sIGlzUmVxdWVzdCwgZGF0YXMpO1xuICAgIH1cblxuICAgIGlmIChrZWVwUmF0aW8pIHtcbiAgICAgIGlmIChzaXplRGlyZWN0aW9uWzBdICYmIHNpemVEaXJlY3Rpb25bMV0gJiYgc25hcERpc3RbMF0gJiYgc25hcERpc3RbMV0pIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHNuYXBEaXN0WzBdICogd2lkdGgpID4gTWF0aC5hYnMoc25hcERpc3RbMV0gKiBoZWlnaHQpKSB7XG4gICAgICAgICAgc25hcERpc3RbMV0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNuYXBEaXN0WzBdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNOb1NuYXAgPSAhc25hcERpc3RbMF0gJiYgIXNuYXBEaXN0WzFdO1xuXG4gICAgICBpZiAoaXNOb1NuYXApIHtcbiAgICAgICAgaWYgKGlzV2lkdGgpIHtcbiAgICAgICAgICBkaXN0WzBdID0gdGhyb3R0bGUoZGlzdFswXSAqIHN0YXJ0VmFsdWVbMF0sIHRocm90dGxlU2NhbGUpIC8gc3RhcnRWYWx1ZVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXN0WzFdID0gdGhyb3R0bGUoZGlzdFsxXSAqIHN0YXJ0VmFsdWVbMV0sIHRocm90dGxlU2NhbGUpIC8gc3RhcnRWYWx1ZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZURpcmVjdGlvblswXSAmJiAhc2l6ZURpcmVjdGlvblsxXSB8fCBzbmFwRGlzdFswXSAmJiAhc25hcERpc3RbMV0gfHwgaXNOb1NuYXAgJiYgaXNXaWR0aCkge1xuICAgICAgICBkaXN0WzBdICs9IHNuYXBEaXN0WzBdO1xuICAgICAgICB2YXIgc25hcEhlaWdodCA9IHdpZHRoICogZGlzdFswXSAqIHN0YXJ0VmFsdWVbMF0gLyByYXRpbztcbiAgICAgICAgZGlzdFsxXSA9IHNuYXBIZWlnaHQgLyBoZWlnaHQgLyBzdGFydFZhbHVlWzFdO1xuICAgICAgfSBlbHNlIGlmICghc2l6ZURpcmVjdGlvblswXSAmJiBzaXplRGlyZWN0aW9uWzFdIHx8ICFzbmFwRGlzdFswXSAmJiBzbmFwRGlzdFsxXSB8fCBpc05vU25hcCAmJiAhaXNXaWR0aCkge1xuICAgICAgICBkaXN0WzFdICs9IHNuYXBEaXN0WzFdO1xuICAgICAgICB2YXIgc25hcFdpZHRoID0gaGVpZ2h0ICogZGlzdFsxXSAqIHN0YXJ0VmFsdWVbMV0gKiByYXRpbztcbiAgICAgICAgZGlzdFswXSA9IHNuYXBXaWR0aCAvIHdpZHRoIC8gc3RhcnRWYWx1ZVswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGlzdFswXSArPSBzbmFwRGlzdFswXTtcbiAgICAgIGRpc3RbMV0gKz0gc25hcERpc3RbMV07XG5cbiAgICAgIGlmICghc25hcERpc3RbMF0pIHtcbiAgICAgICAgZGlzdFswXSA9IHRocm90dGxlKGRpc3RbMF0gKiBzdGFydFZhbHVlWzBdLCB0aHJvdHRsZVNjYWxlKSAvIHN0YXJ0VmFsdWVbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghc25hcERpc3RbMV0pIHtcbiAgICAgICAgZGlzdFsxXSA9IHRocm90dGxlKGRpc3RbMV0gKiBzdGFydFZhbHVlWzFdLCB0aHJvdHRsZVNjYWxlKSAvIHN0YXJ0VmFsdWVbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpc3RbMF0gPT09IDApIHtcbiAgICAgIGRpc3RbMF0gPSAocHJldkRpc3RbMF0gPiAwID8gMSA6IC0xKSAqIE1JTl9TQ0FMRTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdFsxXSA9PT0gMCkge1xuICAgICAgZGlzdFsxXSA9IChwcmV2RGlzdFsxXSA+IDAgPyAxIDogLTEpICogTUlOX1NDQUxFO1xuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IFtkaXN0WzBdIC8gcHJldkRpc3RbMF0sIGRpc3RbMV0gLyBwcmV2RGlzdFsxXV07XG4gICAgc2NhbGUgPSBtdWx0aXBseTIoZGlzdCwgc3RhcnRWYWx1ZSk7XG4gICAgdmFyIGludmVyc2VEaXN0ID0gZ2V0U2NhbGVEaXN0KG1vdmVhYmxlLCBkaXN0LCBmaXhlZERpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgZGF0YXMpO1xuICAgIHZhciBpbnZlcnNlRGVsdGEgPSBtaW51cyhpbnZlcnNlRGlzdCwgZGF0YXMucHJldkludmVyc2VEaXN0IHx8IFswLCAwXSk7XG4gICAgZGF0YXMucHJldkRpc3QgPSBkaXN0O1xuICAgIGRhdGFzLnByZXZJbnZlcnNlRGlzdCA9IGludmVyc2VEaXN0O1xuXG4gICAgaWYgKHNjYWxlWCA9PT0gcHJldkRpc3RbMF0gJiYgc2NhbGVZID09PSBwcmV2RGlzdFsxXSAmJiBpbnZlcnNlRGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkge1xuICAgICAgcmV0dXJuICFudW07XG4gICAgfSkgJiYgIXBhcmVudE1vdmVhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5leHRUcmFuc2Zvcm0gPSBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCBcInNjYWxlKFwiICsgc2NhbGUuam9pbihcIiwgXCIpICsgXCIpXCIsIFwic2NhbGUoXCIgKyBkaXN0LmpvaW4oXCIsIFwiKSArIFwiKVwiKTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oe1xuICAgICAgb2Zmc2V0V2lkdGg6IHdpZHRoLFxuICAgICAgb2Zmc2V0SGVpZ2h0OiBoZWlnaHQsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIC8vIGJlZm9yZVNjYWxlLFxuICAgICAgLy8gYmVmb3JlRGlzdCxcbiAgICAgIC8vIGJlZm9yZURlbHRhLFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgZGlzdDogZGlzdCxcbiAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIGlzUGluY2g6ICEhaXNQaW5jaFxuICAgIH0sIGZpbGxUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgbmV4dFRyYW5zZm9ybSwgaW52ZXJzZURlbHRhLCBpc1BpbmNoLCBlKSkpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzRHJhZyA9IGUuaXNEcmFnO1xuXG4gICAgaWYgKCFkYXRhcy5pc1NjYWxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0YXMuaXNTY2FsZSA9IGZhbHNlO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KSk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZGlyZWN0aW9uQ29uZGl0aW9uLFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbEV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJyZXNpemFibGVcIiwgZSk7XG5cbiAgICBmdW5jdGlvbiBzZXREaXN0KGNoaWxkLCBldikge1xuICAgICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb247XG4gICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb247XG4gICAgICB2YXIgcG9zID0gZ2V0QWJzb2x1dGVQb3NpdGlvbihjaGlsZCwgZml4ZWREaXJlY3Rpb24pO1xuXG4gICAgICB2YXIgX2EgPSBjYWxjdWxhdGUoY3JlYXRlUm90YXRlTWF0cml4KC1tb3ZlYWJsZS5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLCBbcG9zWzBdIC0gZml4ZWRQb3NpdGlvblswXSwgcG9zWzFdIC0gZml4ZWRQb3NpdGlvblsxXSwgMV0sIDMpLFxuICAgICAgICAgIG9yaWdpbmFsWCA9IF9hWzBdLFxuICAgICAgICAgIG9yaWdpbmFsWSA9IF9hWzFdO1xuXG4gICAgICBldi5kYXRhcy5vcmlnaW5hbFggPSBvcmlnaW5hbFg7XG4gICAgICBldi5kYXRhcy5vcmlnaW5hbFkgPSBvcmlnaW5hbFk7XG4gICAgICByZXR1cm4gZXY7XG4gICAgfVxuXG4gICAgZGF0YXMubW92ZWFibGVTY2FsZSA9IG1vdmVhYmxlLnNjYWxlO1xuICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFN0YXJ0XCIsIGUsIGZ1bmN0aW9uIChjaGlsZCwgZXYpIHtcbiAgICAgIHJldHVybiBzZXREaXN0KGNoaWxkLCBldik7XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICBzZXRGaXhlZERpcmVjdGlvbjogZnVuY3Rpb24gKGZpeGVkRGlyZWN0aW9uKSB7XG4gICAgICAgIHBhcmFtcy5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldiwgaSkge1xuICAgICAgICAgIGV2LnNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKTtcbiAgICAgICAgICBzZXREaXN0KG1vdmVhYmxlLm1vdmVhYmxlc1tpXSwgb3JpZ2luYWxFdmVudHNbaV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZUdyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XG4gICAgZGF0YXMuaXNTY2FsZSA9IHJlc3VsdCAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIGRhdGFzLmlzU2NhbGUgPyBuZXh0UGFyYW1zIDogZmFsc2U7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzU2NhbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XG5cbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtb3ZlYWJsZVNjYWxlID0gZGF0YXMubW92ZWFibGVTY2FsZTtcbiAgICBtb3ZlYWJsZS5zY2FsZSA9IFtwYXJhbXMuc2NhbGVbMF0gKiBtb3ZlYWJsZVNjYWxlWzBdLCBwYXJhbXMuc2NhbGVbMV0gKiBtb3ZlYWJsZVNjYWxlWzFdXTtcbiAgICB2YXIga2VlcFJhdGlvID0gbW92ZWFibGUucHJvcHMua2VlcFJhdGlvO1xuICAgIHZhciBkaXN0ID0gcGFyYW1zLmRpc3QsXG4gICAgICAgIHNjYWxlID0gcGFyYW1zLnNjYWxlO1xuICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcbiAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xcIiwgZSwgZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICB2YXIgX2EgPSBjYWxjdWxhdGUoY3JlYXRlUm90YXRlTWF0cml4KG1vdmVhYmxlLnJvdGF0aW9uIC8gMTgwICogTWF0aC5QSSwgMyksIFtldi5kYXRhcy5vcmlnaW5hbFggKiBkaXN0WzBdLCBldi5kYXRhcy5vcmlnaW5hbFkgKiBkaXN0WzFdLCAxXSwgMyksXG4gICAgICAgICAgY2xpZW50WCA9IF9hWzBdLFxuICAgICAgICAgIGNsaWVudFkgPSBfYVsxXTtcblxuICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHtcbiAgICAgICAgcGFyZW50RGlzdDogbnVsbCxcbiAgICAgICAgcGFyZW50U2NhbGU6IHNjYWxlLFxuICAgICAgICBwYXJlbnRLZWVwUmF0aW86IGtlZXBSYXRpbyxcbiAgICAgICAgZHJhZ0NsaWVudDogcGx1cyhmaXhlZFBvc2l0aW9uLCBbY2xpZW50WCwgY2xpZW50WV0pXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oe1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSwgcGFyYW1zKTtcblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlR3JvdXBcIiwgbmV4dFBhcmFtcyk7XG4gICAgcmV0dXJuIG5leHRQYXJhbXM7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBpc0RyYWcgPSBlLmlzRHJhZyxcbiAgICAgICAgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFkYXRhcy5pc1NjYWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnQ29udHJvbEVuZChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sRW5kXCIsIGUpO1xuICAgIHZhciBuZXh0UGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcbiAgICAgIGV2ZW50czogZXZlbnRzXG4gICAgfSk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU2NhbGVHcm91cEVuZFwiLCBuZXh0UGFyYW1zKTtcbiAgICByZXR1cm4gaXNEcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlLlNjYWxhYmxlI3JlcXVlc3RcbiAgICogQHBhcmFtIHtvYmplY3R9IFtlXSAtIHRoZSBSZXNpemFibGUncyByZXF1ZXN0IHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGlyZWN0aW9uPVsxLCAxXV0gLSBEaXJlY3Rpb24gdG8gc2NhbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhV2lkdGhdIC0gZGVsdGEgbnVtYmVyIG9mIHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YUhlaWdodF0gLSBkZWx0YSBudW1iZXIgb2YgaGVpZ2h0XG4gICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICAqIEBleGFtcGxlXG4gICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXG4gICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJzY2FsYWJsZVwiLCB7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RTdGFydFxuICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwic2NhbGFibGVcIik7XG4gICAqXG4gICAqIC8vIHJlcXVlc3RcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9KTtcbiAgICpcbiAgICogLy8gcmVxdWVzdEVuZFxuICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xuICAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhcyA9IHt9O1xuICAgIHZhciBkaXN0V2lkdGggPSAwO1xuICAgIHZhciBkaXN0SGVpZ2h0ID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiB0cnVlLFxuICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGFzOiBkYXRhcyxcbiAgICAgICAgICBwYXJlbnREaXJlY3Rpb246IGUuZGlyZWN0aW9uIHx8IFsxLCAxXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRpc3RXaWR0aCArPSBlLmRlbHRhV2lkdGg7XG4gICAgICAgIGRpc3RIZWlnaHQgKz0gZS5kZWx0YUhlaWdodDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgcGFyZW50RGlzdDogW2Rpc3RXaWR0aCwgZGlzdEhlaWdodF1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIGlzRHJhZzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gc2NhbGVkLiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY2FsYWJsZSNzY2FsYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS5zY2FsYWJsZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiB0aHJvdHRsZSBvZiBzY2FsZVgsIHNjYWxlWSB3aGVuIHNjYWxlLlxuICogQG5hbWUgTW92ZWFibGUuU2NhbGFibGUjdGhyb3R0bGVTY2FsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqXG4gKiBtb3ZlYWJsZS50aHJvdHRsZVNjYWxlID0gMC4xO1xuICovXG5cbi8qKlxuICogU2V0IGRpcmVjdGlvbnMgdG8gc2hvdyB0aGUgY29udHJvbCBib3guIChkZWZhdWx0OiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0pXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY2FsYWJsZSNyZW5kZXJEaXJlY3Rpb25zXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcbiAqICAgcmVuZGVyRGlyZWN0aW9uczogW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdLFxuICogfSk7XG4gKlxuICogbW92ZWFibGUucmVuZGVyRGlyZWN0aW9ucyA9IFtcIm53XCIsIFwibmVcIiwgXCJzd1wiLCBcInNlXCJdO1xuICovXG5cbi8qKlxuICogV2hlbiByZXNpemUgb3Igc2NhbGUsIGtlZXBzIGEgcmF0aW8gb2YgdGhlIHdpZHRoLCBoZWlnaHQuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLlNjYWxhYmxlI2tlZXBSYXRpb1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgc2NhbGFibGU6IHRydWUsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5rZWVwUmF0aW8gPSB0cnVlO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgc2NhbGUgc3RhcnRzLCB0aGUgc2NhbGVTdGFydCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcbiAqIEBldmVudCBzY2FsZVN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2NhbGVTdGFydCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHNjYWxhYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJzY2FsZVN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiBzY2FsaW5nLCB0aGUgc2NhbGUgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXG4gKiBAZXZlbnQgc2NhbGVcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZX0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2NhbGUgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBzY2FsYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVcIiwgKHsgdGFyZ2V0LCB0cmFuc2Zvcm0sIGRpc3QgfSkgPT4ge1xuICogICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gdGhlIHNjYWxlIGZpbmlzaGVzLCB0aGUgc2NhbGVFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXG4gKiBAZXZlbnQgc2NhbGVFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZUVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2NhbGVFbmQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBzY2FsYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuKiBXaGVuIHRoZSBncm91cCBzY2FsZSBzdGFydHMsIHRoZSBgc2NhbGVHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxuKiBAZXZlbnQgc2NhbGVHcm91cFN0YXJ0XG4qIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZUdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY2FsZUdyb3VwU3RhcnRgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiogICAgIHNjYWxhYmxlOiB0cnVlXG4qIH0pO1xuKiBtb3ZlYWJsZS5vbihcInNjYWxlR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcbiogICAgIGNvbnNvbGUubG9nKFwib25TY2FsZUdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XG4qIH0pO1xuKi9cblxuLyoqXG4qIFdoZW4gdGhlIGdyb3VwIHNjYWxlLCB0aGUgYHNjYWxlR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXG4qIEBldmVudCBzY2FsZUdyb3VwXG4qIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2NhbGVHcm91cGAgZXZlbnRcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuKiAgICAgc2NhbGFibGU6IHRydWVcbiogfSk7XG4qIG1vdmVhYmxlLm9uKFwic2NhbGVHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xuKiAgICAgY29uc29sZS5sb2coXCJvblNjYWxlR3JvdXBcIiwgdGFyZ2V0cyk7XG4qICAgICBldmVudHMuZm9yRWFjaChldiA9PiB7XG4qICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuKiAgICAgICAgIC8vIGV2LmRyYWcgaXMgYSBkcmFnIGV2ZW50IHRoYXQgb2NjdXJzIHdoZW4gdGhlIGdyb3VwIHNjYWxlLlxuKiAgICAgICAgIGNvbnN0IGxlZnQgPSBldi5kcmFnLmJlZm9yZURpc3RbMF07XG4qICAgICAgICAgY29uc3QgdG9wID0gZXYuZHJhZy5iZWZvcmVEaXN0WzFdO1xuKiAgICAgICAgIGNvbnN0IHNjYWxlWCA9IGV2LnNjYWxlWzBdO1xuKiAgICAgICAgIGNvbnN0IHNjYWxlWSA9IGV2LnNjYWxlWzFdO1xuKiAgICAgfSk7XG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIHRoZSBncm91cCBzY2FsZSBmaW5pc2hlcywgdGhlIGBzY2FsZUdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcbiAqIEBldmVudCBzY2FsZUdyb3VwRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjYWxlR3JvdXBFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogICAgIHNjYWxhYmxlOiB0cnVlXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVHcm91cEVuZFwiLCAoeyB0YXJnZXRzLCBpc0RyYWcgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25TY2FsZUdyb3VwRW5kXCIsIHRhcmdldHMsIGlzRHJhZyk7XG4gKiB9KTtcbiAqL1xuXG5mdW5jdGlvbiBnZXRNaWRkbGVMaW5lUG9zKHBvczEsIHBvczIpIHtcbiAgcmV0dXJuIHBvczEubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcbiAgICByZXR1cm4gZG90KHBvcywgcG9zMltpXSwgMSwgMik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUcmlhbmdsZVJhZChwb3MxLCBwb3MyLCBwb3MzKSB7XG4gIC8vIHBvczEgUmFkXG4gIHZhciByYWQxID0gZ2V0UmFkKHBvczEsIHBvczIpO1xuICB2YXIgcmFkMiA9IGdldFJhZChwb3MxLCBwb3MzKTtcbiAgdmFyIHJhZCA9IHJhZDIgLSByYWQxO1xuICByZXR1cm4gcmFkID49IDAgPyByYWQgOiByYWQgKyAyICogTWF0aC5QSTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvcyhwb3NlczEsIHBvc2VzMikge1xuICB2YXIgcmFkMSA9IGdldFRyaWFuZ2xlUmFkKHBvc2VzMVswXSwgcG9zZXMxWzFdLCBwb3NlczFbMl0pO1xuICB2YXIgcmFkMiA9IGdldFRyaWFuZ2xlUmFkKHBvc2VzMlswXSwgcG9zZXMyWzFdLCBwb3NlczJbMl0pO1xuICB2YXIgcGkgPSBNYXRoLlBJO1xuXG4gIGlmIChyYWQxID49IHBpICYmIHJhZDIgPD0gcGkgfHwgcmFkMSA8PSBwaSAmJiByYWQyID49IHBpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuV2FycGFibGVcbiAqIEBkZXNjcmlwdGlvbiBXYXJwYWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0IGNhbiBiZSB3YXJwZWQoZGlzdG9ydGVkLCBiZW50ZWQpLlxuICovXG5cblxudmFyIFdhcnBhYmxlID0ge1xuICBuYW1lOiBcIndhcnBhYmxlXCIsXG4gIGFibGVHcm91cDogXCJzaXplXCIsXG4gIHByb3BzOiB7XG4gICAgd2FycGFibGU6IEJvb2xlYW4sXG4gICAgcmVuZGVyRGlyZWN0aW9uczogQXJyYXlcbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25XYXJwU3RhcnQ6IFwid2FycFN0YXJ0XCIsXG4gICAgb25XYXJwOiBcIndhcnBcIixcbiAgICBvbldhcnBFbmQ6IFwid2FycEVuZFwiXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICByZXNpemFibGUgPSBfYS5yZXNpemFibGUsXG4gICAgICAgIHNjYWxhYmxlID0gX2Euc2NhbGFibGUsXG4gICAgICAgIHdhcnBhYmxlID0gX2Eud2FycGFibGUsXG4gICAgICAgIHpvb20gPSBfYS56b29tO1xuXG4gICAgaWYgKHJlc2l6YWJsZSB8fCBzY2FsYWJsZSB8fCAhd2FycGFibGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgICAgcG9zMSA9IF9iLnBvczEsXG4gICAgICAgIHBvczIgPSBfYi5wb3MyLFxuICAgICAgICBwb3MzID0gX2IucG9zMyxcbiAgICAgICAgcG9zNCA9IF9iLnBvczQ7XG4gICAgdmFyIGxpbmVQb3NGcm9tMSA9IGdldE1pZGRsZUxpbmVQb3MocG9zMSwgcG9zMik7XG4gICAgdmFyIGxpbmVQb3NGcm9tMiA9IGdldE1pZGRsZUxpbmVQb3MocG9zMiwgcG9zMSk7XG4gICAgdmFyIGxpbmVQb3NGcm9tMyA9IGdldE1pZGRsZUxpbmVQb3MocG9zMSwgcG9zMyk7XG4gICAgdmFyIGxpbmVQb3NGcm9tNCA9IGdldE1pZGRsZUxpbmVQb3MocG9zMywgcG9zMSk7XG4gICAgdmFyIGxpbmVQb3NUbzEgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczMsIHBvczQpO1xuICAgIHZhciBsaW5lUG9zVG8yID0gZ2V0TWlkZGxlTGluZVBvcyhwb3M0LCBwb3MzKTtcbiAgICB2YXIgbGluZVBvc1RvMyA9IGdldE1pZGRsZUxpbmVQb3MocG9zMiwgcG9zNCk7XG4gICAgdmFyIGxpbmVQb3NUbzQgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczQsIHBvczIpO1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiKSxcbiAgICAgIGtleTogXCJtaWRkZUxpbmUxXCIsXG4gICAgICBzdHlsZTogZ2V0TGluZVN0eWxlKGxpbmVQb3NGcm9tMSwgbGluZVBvc1RvMSwgem9vbSlcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiksXG4gICAgICBrZXk6IFwibWlkZGVMaW5lMlwiLFxuICAgICAgc3R5bGU6IGdldExpbmVTdHlsZShsaW5lUG9zRnJvbTIsIGxpbmVQb3NUbzIsIHpvb20pXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIpLFxuICAgICAga2V5OiBcIm1pZGRlTGluZTNcIixcbiAgICAgIHN0eWxlOiBnZXRMaW5lU3R5bGUobGluZVBvc0Zyb20zLCBsaW5lUG9zVG8zLCB6b29tKVxuICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiKSxcbiAgICAgIGtleTogXCJtaWRkZUxpbmU0XCIsXG4gICAgICBzdHlsZTogZ2V0TGluZVN0eWxlKGxpbmVQb3NGcm9tNCwgbGluZVBvc1RvNCwgem9vbSlcbiAgICB9KV0sIHJlbmRlckFsbERpcmVjdGlvbnMobW92ZWFibGUsIFJlYWN0KSk7XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBpZiAoZS5pc1JlcXVlc3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzQ2xhc3MoZS5pbnB1dEV2ZW50LnRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gbW92ZWFibGUucHJvcHMudGFyZ2V0O1xuICAgIHZhciBpbnB1dFRhcmdldCA9IGlucHV0RXZlbnQudGFyZ2V0O1xuICAgIHZhciBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXRUYXJnZXQpO1xuXG4gICAgaWYgKCFkaXJlY3Rpb24gfHwgIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgIGlzM2QgPSBzdGF0ZS5pczNkLFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0gPSBzdGF0ZS50YXJnZXRUcmFuc2Zvcm0sXG4gICAgICAgIHRhcmdldE1hdHJpeCA9IHN0YXRlLnRhcmdldE1hdHJpeCxcbiAgICAgICAgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0LFxuICAgICAgICBsZWZ0ID0gc3RhdGUubGVmdCxcbiAgICAgICAgdG9wID0gc3RhdGUudG9wO1xuICAgIGRhdGFzLmRhdGFzID0ge307XG4gICAgZGF0YXMudGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0VHJhbnNmb3JtO1xuICAgIGRhdGFzLndhcnBUYXJnZXRNYXRyaXggPSBpczNkID8gdGFyZ2V0TWF0cml4IDogY29udmVydERpbWVuc2lvbih0YXJnZXRNYXRyaXgsIDMsIDQpO1xuICAgIGRhdGFzLnRhcmdldEludmVyc2VNYXRyaXggPSBpZ25vcmVEaW1lbnNpb24oaW52ZXJ0KGRhdGFzLndhcnBUYXJnZXRNYXRyaXgsIDQpLCAzLCA0KTtcbiAgICBkYXRhcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgZGF0YXMubGVmdCA9IGxlZnQ7XG4gICAgZGF0YXMudG9wID0gdG9wO1xuICAgIGRhdGFzLnBvc2VzID0gW1swLCAwXSwgW3dpZHRoLCAwXSwgWzAsIGhlaWdodF0sIFt3aWR0aCwgaGVpZ2h0XV0ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gbWludXMocCwgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB9KTtcbiAgICBkYXRhcy5uZXh0UG9zZXMgPSBkYXRhcy5wb3Nlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgeCA9IF9hWzBdLFxuICAgICAgICAgIHkgPSBfYVsxXTtcbiAgICAgIHJldHVybiBjYWxjdWxhdGUoZGF0YXMud2FycFRhcmdldE1hdHJpeCwgW3gsIHksIDAsIDFdLCA0KTtcbiAgICB9KTtcbiAgICBkYXRhcy5zdGFydFZhbHVlID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgoNCk7XG4gICAgZGF0YXMucHJldk1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KDQpO1xuICAgIGRhdGFzLmFic29sdXRlUG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShzdGF0ZSk7XG4gICAgZGF0YXMucG9zSW5kZXhlcyA9IGdldFBvc0luZGV4ZXNCeURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KGUsIFwibWF0cml4M2RcIik7XG4gICAgc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XG4gICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfTtcbiAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oe1xuICAgICAgc2V0OiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSBtYXRyaXg7XG4gICAgICB9XG4gICAgfSwgZmlsbFRyYW5zZm9ybVN0YXJ0RXZlbnQoZSkpKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uV2FycFN0YXJ0XCIsIHBhcmFtcyk7XG5cbiAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNXYXJwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YXMuaXNXYXJwO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XG4gICAgdmFyIGRpc3RYID0gZS5kaXN0WCxcbiAgICAgICAgZGlzdFkgPSBlLmRpc3RZO1xuICAgIHZhciB0YXJnZXRJbnZlcnNlTWF0cml4ID0gZGF0YXMudGFyZ2V0SW52ZXJzZU1hdHJpeCxcbiAgICAgICAgcHJldk1hdHJpeCA9IGRhdGFzLnByZXZNYXRyaXgsXG4gICAgICAgIGlzV2FycCA9IGRhdGFzLmlzV2FycCxcbiAgICAgICAgc3RhcnRWYWx1ZSA9IGRhdGFzLnN0YXJ0VmFsdWUsXG4gICAgICAgIHBvc2VzID0gZGF0YXMucG9zZXMsXG4gICAgICAgIHBvc0luZGV4ZXMgPSBkYXRhcy5wb3NJbmRleGVzLFxuICAgICAgICBhYnNvbHV0ZVBvc2VzID0gZGF0YXMuYWJzb2x1dGVQb3NlcztcblxuICAgIGlmICghaXNXYXJwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KGUsIFwibWF0cml4M2RcIik7XG5cbiAgICBpZiAoaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJ3YXJwYWJsZVwiKSkge1xuICAgICAgdmFyIHNlbGVjdGVkUG9zZXMgPSBwb3NJbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlUG9zZXNbaW5kZXhdO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZFBvc2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2VsZWN0ZWRQb3Nlcy5wdXNoKFsoc2VsZWN0ZWRQb3Nlc1swXVswXSArIHNlbGVjdGVkUG9zZXNbMV1bMF0pIC8gMiwgKHNlbGVjdGVkUG9zZXNbMF1bMV0gKyBzZWxlY3RlZFBvc2VzWzFdWzFdKSAvIDJdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9hID0gY2hlY2tNb3ZlYWJsZVNuYXBCb3VuZHMobW92ZWFibGUsIGlzUmVxdWVzdCwge1xuICAgICAgICBob3Jpem9udGFsOiBzZWxlY3RlZFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc1sxXSArIGRpc3RZO1xuICAgICAgICB9KSxcbiAgICAgICAgdmVydGljYWw6IHNlbGVjdGVkUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICByZXR1cm4gcG9zWzBdICsgZGlzdFg7XG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgICAgICBob3Jpem9udGFsU25hcEluZm8gPSBfYS5ob3Jpem9udGFsLFxuICAgICAgICAgIHZlcnRpY2FsU25hcEluZm8gPSBfYS52ZXJ0aWNhbDtcblxuICAgICAgZGlzdFkgLT0gaG9yaXpvbnRhbFNuYXBJbmZvLm9mZnNldDtcbiAgICAgIGRpc3RYIC09IHZlcnRpY2FsU25hcEluZm8ub2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciBkaXN0ID0gZ2V0RHJhZ0Rpc3Qoe1xuICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgZGlzdFk6IGRpc3RZXG4gICAgfSwgdHJ1ZSk7XG4gICAgdmFyIG5leHRQb3NlcyA9IGRhdGFzLm5leHRQb3Nlcy5zbGljZSgpO1xuICAgIHBvc0luZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIG5leHRQb3Nlc1tpbmRleF0gPSBwbHVzKG5leHRQb3Nlc1tpbmRleF0sIGRpc3QpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFORUFSQllfUE9TLmV2ZXJ5KGZ1bmN0aW9uIChuZWFyQnlQb3Nlcykge1xuICAgICAgcmV0dXJuIGlzVmFsaWRQb3MobmVhckJ5UG9zZXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBwb3Nlc1tpXTtcbiAgICAgIH0pLCBuZWFyQnlQb3Nlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRQb3Nlc1tpXTtcbiAgICAgIH0pKTtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBoID0gY3JlYXRlV2FycE1hdHJpeChwb3Nlc1swXSwgcG9zZXNbMl0sIHBvc2VzWzFdLCBwb3Nlc1szXSwgbmV4dFBvc2VzWzBdLCBuZXh0UG9zZXNbMl0sIG5leHRQb3Nlc1sxXSwgbmV4dFBvc2VzWzNdKTtcblxuICAgIGlmICghaC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEIgKiBBICogTVxuXG5cbiAgICB2YXIgYWZ0ZXJNYXRyaXggPSBtdWx0aXBseSh0YXJnZXRJbnZlcnNlTWF0cml4LCBoLCA0KTsgLy8gQiAqIE0gKiBBXG5cbiAgICB2YXIgbWF0cml4ID0gZ2V0VHJhbnNmcm9tTWF0cml4KGRhdGFzLCBhZnRlck1hdHJpeCwgdHJ1ZSk7XG4gICAgdmFyIGRlbHRhID0gbXVsdGlwbHkoaW52ZXJ0KHByZXZNYXRyaXgsIDQpLCBtYXRyaXgsIDQpO1xuICAgIGRhdGFzLnByZXZNYXRyaXggPSBtYXRyaXg7XG4gICAgdmFyIHRvdGFsTWF0cml4ID0gbXVsdGlwbHkoc3RhcnRWYWx1ZSwgbWF0cml4LCA0KTtcbiAgICB2YXIgbmV4dFRyYW5zZm9ybSA9IGNvbnZlcnRUcmFuc2Zvcm1Gb3JtYXQoZGF0YXMsIFwibWF0cml4M2QoXCIgKyB0b3RhbE1hdHJpeC5qb2luKFwiLCBcIikgKyBcIilcIiwgXCJtYXRyaXgzZChcIiArIG1hdHJpeC5qb2luKFwiLCBcIikgKyBcIilcIik7XG4gICAgZmlsbE9yaWdpbmFsVHJhbnNmb3JtKGUsIG5leHRUcmFuc2Zvcm0pO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbldhcnBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgbWF0cml4OiB0b3RhbE1hdHJpeCxcbiAgICAgIGRpc3Q6IG1hdHJpeCxcbiAgICAgIG11bHRpcGx5OiBtdWx0aXBseSxcbiAgICAgIHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybVxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzRHJhZyA9IGUuaXNEcmFnO1xuXG4gICAgaWYgKCFkYXRhcy5pc1dhcnApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkYXRhcy5pc1dhcnAgPSBmYWxzZTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25XYXJwRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KSk7XG4gICAgcmV0dXJuIGlzRHJhZztcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSB3YXJwZWQuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLldhcnBhYmxlI3dhcnBhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICpcbiAqIG1vdmVhYmxlLndhcnBhYmxlID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiogU2V0IGRpcmVjdGlvbnMgdG8gc2hvdyB0aGUgY29udHJvbCBib3guIChkZWZhdWx0OiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0pXG4qIEBuYW1lIE1vdmVhYmxlLldhcnBhYmxlI3JlbmRlckRpcmVjdGlvbnNcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICB3YXJwYWJsZTogdHJ1ZSxcbiogICAgIHJlbmRlckRpcmVjdGlvbnM6IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXSxcbiogfSk7XG4qXG4qIG1vdmVhYmxlLnJlbmRlckRpcmVjdGlvbnMgPSBbXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXTtcbiovXG5cbi8qKlxuKiBXaGVuIHRoZSB3YXJwIHN0YXJ0cywgdGhlIHdhcnBTdGFydCBldmVudCBpcyBjYWxsZWQuXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5XYXJwYWJsZVxuKiBAZXZlbnQgd2FycFN0YXJ0XG4qIEBwYXJhbSB7TW92ZWFibGUuV2FycGFibGUuT25XYXJwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHdhcnBTdGFydCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgd2FycGFibGU6IHRydWUgfSk7XG4qIG1vdmVhYmxlLm9uKFwid2FycFN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuKiB9KTtcbiovXG5cbi8qKlxuICogV2hlbiB3YXJwaW5nLCB0aGUgd2FycCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuV2FycGFibGVcbiAqIEBldmVudCB3YXJwXG4gKiBAcGFyYW0ge01vdmVhYmxlLldhcnBhYmxlLk9uV2FycH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgd2FycCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqIGxldCBtYXRyaXggPSBbXG4gKiAgMSwgMCwgMCwgMCxcbiAqICAwLCAxLCAwLCAwLFxuICogIDAsIDAsIDEsIDAsXG4gKiAgMCwgMCwgMCwgMSxcbiAqIF07XG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHdhcnBhYmxlOiB0cnVlIH0pO1xuICogbW92ZWFibGUub24oXCJ3YXJwXCIsICh7IHRhcmdldCwgdHJhbnNmb3JtLCBkZWx0YSwgbXVsdGlwbHkgfSkgPT4ge1xuICogICAgLy8gdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAqICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgZGVsdGEpO1xuICogICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IGBtYXRyaXgzZCgke21hdHJpeC5qb2luKFwiLFwiKX0pYDtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgd2FycCBmaW5pc2hlcywgdGhlIHdhcnBFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLldhcnBhYmxlXG4gKiBAZXZlbnQgd2FycEVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5XYXJwYWJsZS5PbldhcnBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHdhcnBFbmQgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyB3YXJwYWJsZTogdHJ1ZSB9KTtcbiAqIG1vdmVhYmxlLm9uKFwid2FycEVuZFwiLCAoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xuICogfSk7XG4gKi9cblxudmFyIEFSRUFfUElFQ0VTID0gLyojX19QVVJFX18qL3ByZWZpeChcImFyZWEtcGllY2VzXCIpO1xudmFyIEFSRUFfUElFQ0UgPSAvKiNfX1BVUkVfXyovcHJlZml4KFwiYXJlYS1waWVjZVwiKTtcbnZhciBBVk9JRCA9IC8qI19fUFVSRV9fKi9wcmVmaXgoXCJhdm9pZFwiKTtcblxuZnVuY3Rpb24gcmVzdG9yZVN0eWxlKG1vdmVhYmxlKSB7XG4gIHZhciBlbCA9IG1vdmVhYmxlLmFyZWFFbGVtZW50O1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gIHJlbW92ZUNsYXNzKGVsLCBBVk9JRCk7XG4gIGVsLnN0eWxlLmNzc1RleHQgKz0gXCJsZWZ0OiAwcHg7IHRvcDogMHB4OyB3aWR0aDogXCIgKyB3aWR0aCArIFwicHg7IGhlaWdodDogXCIgKyBoZWlnaHQgKyBcInB4XCI7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBpZWNlcyhSZWFjdCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBcImFyZWFfcGllY2VzXCIsXG4gICAgY2xhc3NOYW1lOiBBUkVBX1BJRUNFU1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IEFSRUFfUElFQ0VcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogQVJFQV9QSUVDRVxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBBUkVBX1BJRUNFXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IEFSRUFfUElFQ0VcbiAgfSkpO1xufVxuXG52YXIgRHJhZ0FyZWEgPSB7XG4gIG5hbWU6IFwiZHJhZ0FyZWFcIixcbiAgcHJvcHM6IHtcbiAgICBkcmFnQXJlYTogQm9vbGVhbixcbiAgICBwYXNzRHJhZ0FyZWE6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25DbGljazogXCJjbGlja1wiLFxuICAgIG9uQ2xpY2tHcm91cDogXCJjbGlja0dyb3VwXCJcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgZHJhZ0FyZWEgPSBfYS5kcmFnQXJlYSxcbiAgICAgICAgZ3JvdXBhYmxlID0gX2EuZ3JvdXBhYmxlLFxuICAgICAgICBwYXNzRHJhZ0FyZWEgPSBfYS5wYXNzRHJhZ0FyZWE7XG4gICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHdpZHRoID0gX2Iud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9iLmhlaWdodCxcbiAgICAgICAgcmVuZGVyUG9zZXMgPSBfYi5yZW5kZXJQb3NlcztcbiAgICB2YXIgY2xhc3NOYW1lID0gcGFzc0RyYWdBcmVhID8gcHJlZml4KFwiYXJlYVwiLCBcInBhc3NcIikgOiBwcmVmaXgoXCJhcmVhXCIpO1xuXG4gICAgaWYgKGdyb3VwYWJsZSkge1xuICAgICAgcmV0dXJuIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcImFyZWFcIixcbiAgICAgICAgcmVmOiByZWYobW92ZWFibGUsIFwiYXJlYUVsZW1lbnRcIiksXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICB9KSwgcmVuZGVyUGllY2VzKFJlYWN0KV07XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQgfHwgIWRyYWdBcmVhKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGggPSBjcmVhdGVXYXJwTWF0cml4KFswLCAwXSwgW3dpZHRoLCAwXSwgWzAsIGhlaWdodF0sIFt3aWR0aCwgaGVpZ2h0XSwgcmVuZGVyUG9zZXNbMF0sIHJlbmRlclBvc2VzWzFdLCByZW5kZXJQb3Nlc1syXSwgcmVuZGVyUG9zZXNbM10pO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBoLmxlbmd0aCA/IG1ha2VNYXRyaXhDU1MoaCwgdHJ1ZSkgOiBcIm5vbmVcIjtcbiAgICByZXR1cm4gW1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAga2V5OiBcImFyZWFcIixcbiAgICAgIHJlZjogcmVmKG1vdmVhYmxlLCBcImFyZWFFbGVtZW50XCIpLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICB0b3A6IFwiMHB4XCIsXG4gICAgICAgIGxlZnQ6IFwiMHB4XCIsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArIFwicHhcIixcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBcInB4XCIsXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCIwIDBcIixcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9KSwgcmVuZGVyUGllY2VzKFJlYWN0KV07XG4gIH0sXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBfYSkge1xuICAgIHZhciBkYXRhcyA9IF9hLmRhdGFzLFxuICAgICAgICBjbGllbnRYID0gX2EuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WSA9IF9hLmNsaWVudFksXG4gICAgICAgIGlucHV0RXZlbnQgPSBfYS5pbnB1dEV2ZW50O1xuXG4gICAgaWYgKCFpbnB1dEV2ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0YXMuaXNEcmFnQXJlYSA9IGZhbHNlO1xuICAgIHZhciBhcmVhRWxlbWVudCA9IG1vdmVhYmxlLmFyZWFFbGVtZW50O1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciBtb3ZlYWJsZUNsaWVudFJlY3QgPSBzdGF0ZS5tb3ZlYWJsZUNsaWVudFJlY3QsXG4gICAgICAgIHJlbmRlclBvc2VzID0gc3RhdGUucmVuZGVyUG9zZXMsXG4gICAgICAgIHJvb3RNYXRyaXggPSBzdGF0ZS5yb290TWF0cml4LFxuICAgICAgICBpczNkID0gc3RhdGUuaXMzZDtcbiAgICB2YXIgbGVmdCA9IG1vdmVhYmxlQ2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICB0b3AgPSBtb3ZlYWJsZUNsaWVudFJlY3QudG9wO1xuXG4gICAgdmFyIF9iID0gZ2V0UmVjdChyZW5kZXJQb3NlcyksXG4gICAgICAgIHJlbGF0aXZlTGVmdCA9IF9iLmxlZnQsXG4gICAgICAgIHJlbGF0aXZlVG9wID0gX2IudG9wLFxuICAgICAgICB3aWR0aCA9IF9iLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYi5oZWlnaHQ7XG5cbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcblxuICAgIHZhciBfYyA9IGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbY2xpZW50WCAtIGxlZnQsIGNsaWVudFkgLSB0b3BdLCBuKSxcbiAgICAgICAgcG9zWCA9IF9jWzBdLFxuICAgICAgICBwb3NZID0gX2NbMV07XG5cbiAgICBwb3NYIC09IHJlbGF0aXZlTGVmdDtcbiAgICBwb3NZIC09IHJlbGF0aXZlVG9wO1xuICAgIHZhciByZWN0cyA9IFt7XG4gICAgICBsZWZ0OiByZWxhdGl2ZUxlZnQsXG4gICAgICB0b3A6IHJlbGF0aXZlVG9wLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBwb3NZIC0gMTBcbiAgICB9LCB7XG4gICAgICBsZWZ0OiByZWxhdGl2ZUxlZnQsXG4gICAgICB0b3A6IHJlbGF0aXZlVG9wLFxuICAgICAgd2lkdGg6IHBvc1ggLSAxMCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSwge1xuICAgICAgbGVmdDogcmVsYXRpdmVMZWZ0LFxuICAgICAgdG9wOiByZWxhdGl2ZVRvcCArIHBvc1kgKyAxMCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0IC0gcG9zWSAtIDEwXG4gICAgfSwge1xuICAgICAgbGVmdDogcmVsYXRpdmVMZWZ0ICsgcG9zWCArIDEwLFxuICAgICAgdG9wOiByZWxhdGl2ZVRvcCxcbiAgICAgIHdpZHRoOiB3aWR0aCAtIHBvc1ggLSAxMCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfV07XG4gICAgdmFyIGNoaWxkcmVuID0gW10uc2xpY2UuY2FsbChhcmVhRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcuY2hpbGRyZW4pO1xuICAgIHJlY3RzLmZvckVhY2goZnVuY3Rpb24gKHJlY3QsIGkpIHtcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmNzc1RleHQgPSBcImxlZnQ6IFwiICsgcmVjdC5sZWZ0ICsgXCJweDt0b3A6IFwiICsgcmVjdC50b3AgKyBcInB4OyB3aWR0aDogXCIgKyByZWN0LndpZHRoICsgXCJweDsgaGVpZ2h0OiBcIiArIHJlY3QuaGVpZ2h0ICsgXCJweDtcIjtcbiAgICB9KTtcbiAgICBhZGRDbGFzcyhhcmVhRWxlbWVudCwgQVZPSUQpO1xuICAgIHN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9LFxuICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIF9hKSB7XG4gICAgdmFyIGRhdGFzID0gX2EuZGF0YXMsXG4gICAgICAgIGlucHV0RXZlbnQgPSBfYS5pbnB1dEV2ZW50O1xuICAgIHRoaXMuZW5hYmxlTmF0aXZlRXZlbnQobW92ZWFibGUpO1xuXG4gICAgaWYgKCFpbnB1dEV2ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhcy5pc0RyYWdBcmVhKSB7XG4gICAgICBkYXRhcy5pc0RyYWdBcmVhID0gdHJ1ZTtcbiAgICAgIHJlc3RvcmVTdHlsZShtb3ZlYWJsZSk7XG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmVuYWJsZU5hdGl2ZUV2ZW50KG1vdmVhYmxlKTtcbiAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCxcbiAgICAgICAgZGF0YXMgPSBlLmRhdGFzO1xuXG4gICAgaWYgKCFpbnB1dEV2ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhcy5pc0RyYWdBcmVhKSB7XG4gICAgICByZXN0b3JlU3R5bGUobW92ZWFibGUpO1xuICAgIH1cbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICByZXN0b3JlU3R5bGUobW92ZWFibGUpO1xuICAgIG1vdmVhYmxlLnN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCA9IGZhbHNlO1xuICB9LFxuICBlbmFibGVOYXRpdmVFdmVudDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG5cbiAgICBpZiAoc3RhdGUuZGlzYWJsZU5hdGl2ZUV2ZW50KSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQWRkIGFuIGV2ZW50IHRvIHRoZSBtb3ZlYWJsZSBhcmVhIGluc3RlYWQgb2YgdGhlIHRhcmdldCBmb3Igc3RvcFByb3BhZ2F0aW9uLiAoZGVmYXVsdDogZmFsc2UsIHRydWUgaW4gZ3JvdXApXG4gKiBAbmFtZSBNb3ZlYWJsZSNkcmFnQXJlYVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgZHJhZ0FyZWE6IGZhbHNlLFxuICogfSk7XG4gKi9cblxuLyoqXG4gKiBTZXQgYHBvaW50ZXJFdmVudHM6IG5vbmU7YCBjc3MgdG8gcGFzcyBldmVudHMgaW4gZHJhZ0FyZWEuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlI3Bhc3NEcmFnQXJlYVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgZHJhZ0FyZWE6IGZhbHNlLFxuICogfSk7XG4gKi9cblxudmFyIE9yaWdpbiA9IG1ha2VBYmxlKFwib3JpZ2luXCIsIHtcbiAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XG4gICAgdmFyIHpvb20gPSBtb3ZlYWJsZS5wcm9wcy56b29tO1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICBiZWZvcmVPcmlnaW4gPSBfYS5iZWZvcmVPcmlnaW4sXG4gICAgICAgIHJvdGF0aW9uID0gX2Eucm90YXRpb247XG4gICAgcmV0dXJuIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcIm9yaWdpblwiKSxcbiAgICAgIHN0eWxlOiBnZXRDb250cm9sVHJhbnNmb3JtKHJvdGF0aW9uLCB6b29tLCBiZWZvcmVPcmlnaW4pLFxuICAgICAga2V5OiBcImJlZm9yZU9yaWdpblwiXG4gICAgfSldO1xuICB9XG59KTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIG9yaWdpbiBjb250cm9sYm94IHdpbGwgYmUgdmlzaWJsZSBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiBAbmFtZSBNb3ZlYWJsZSNvcmlnaW5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKlxuICogbW92ZWFibGUub3JpZ2luID0gdHJ1ZTtcbiAqL1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0U2Nyb2xsUG9zaXRpb24oZSkge1xuICB2YXIgc2Nyb2xsQ29udGFpbmVyID0gZS5zY3JvbGxDb250YWluZXI7XG4gIHJldHVybiBbc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQsIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3BdO1xufVxuLyoqXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLlNjcm9sbGFibGVcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZSBzY3JvbGwgY29udGFpbmVyIChkZWZhdWx0OiBmYWxzZSlcbiAqL1xuXG5cbnZhciBTY3JvbGxhYmxlID0ge1xuICBuYW1lOiBcInNjcm9sbGFibGVcIixcbiAgY2FuUGluY2g6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgc2Nyb2xsYWJsZTogQm9vbGVhbixcbiAgICBzY3JvbGxDb250YWluZXI6IE9iamVjdCxcbiAgICBzY3JvbGxUaHJlc2hvbGQ6IE51bWJlcixcbiAgICBnZXRTY3JvbGxQb3NpdGlvbjogRnVuY3Rpb25cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25TY3JvbGw6IFwic2Nyb2xsXCIsXG4gICAgb25TY3JvbGxHcm91cDogXCJzY3JvbGxHcm91cFwiXG4gIH0sXG4gIGRyYWdSZWxhdGlvbjogXCJzdHJvbmdcIixcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcbiAgICB2YXIgX2EgPSBwcm9wcy5zY3JvbGxDb250YWluZXIsXG4gICAgICAgIHNjcm9sbENvbnRhaW5lciA9IF9hID09PSB2b2lkIDAgPyBtb3ZlYWJsZS5nZXRDb250YWluZXIoKSA6IF9hO1xuICAgIHZhciBkcmFnU2Nyb2xsID0gbmV3IERyYWdTY3JvbGwoKTtcbiAgICB2YXIgc2Nyb2xsQ29udGFpbmVyRWxlbWVudCA9IGdldFJlZlRhcmdldChzY3JvbGxDb250YWluZXIsIHRydWUpO1xuICAgIGUuZGF0YXMuZHJhZ1Njcm9sbCA9IGRyYWdTY3JvbGw7XG4gICAgdmFyIGdlc3RvTmFtZSA9IGUuaXNDb250cm9sID8gXCJjb250cm9sR2VzdG9cIiA6IFwidGFyZ2V0R2VzdG9cIjtcbiAgICB2YXIgdGFyZ2V0cyA9IGUudGFyZ2V0cztcbiAgICBkcmFnU2Nyb2xsLm9uKFwic2Nyb2xsXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcixcbiAgICAgICAgICBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb247XG4gICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgICBzY3JvbGxDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgdmFyIGV2ZW50TmFtZSA9IHRhcmdldHMgPyBcIm9uU2Nyb2xsR3JvdXBcIiA6IFwib25TY3JvbGxcIjtcblxuICAgICAgaWYgKHRhcmdldHMpIHtcbiAgICAgICAgcGFyYW1zLnRhcmdldHMgPSB0YXJnZXRzO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIGV2ZW50TmFtZSwgcGFyYW1zKTtcbiAgICB9KS5vbihcIm1vdmVcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgb2Zmc2V0WCA9IF9hLm9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WSA9IF9hLm9mZnNldFk7XG4gICAgICBtb3ZlYWJsZVtnZXN0b05hbWVdLnNjcm9sbEJ5KG9mZnNldFgsIG9mZnNldFksIGUuaW5wdXRFdmVudCwgZmFsc2UpO1xuICAgIH0pO1xuICAgIGRyYWdTY3JvbGwuZHJhZ1N0YXJ0KGUsIHtcbiAgICAgIGNvbnRhaW5lcjogc2Nyb2xsQ29udGFpbmVyRWxlbWVudFxuICAgIH0pO1xuICB9LFxuICBjaGVja1Njcm9sbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRyYWdTY3JvbGwgPSBlLmRhdGFzLmRyYWdTY3JvbGw7XG5cbiAgICBpZiAoIWRyYWdTY3JvbGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgX2IgPSBfYS5zY3JvbGxDb250YWluZXIsXG4gICAgICAgIHNjcm9sbENvbnRhaW5lciA9IF9iID09PSB2b2lkIDAgPyBtb3ZlYWJsZS5nZXRDb250YWluZXIoKSA6IF9iLFxuICAgICAgICBfYyA9IF9hLnNjcm9sbFRocmVzaG9sZCxcbiAgICAgICAgc2Nyb2xsVGhyZXNob2xkID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgICAgX2QgPSBfYS5nZXRTY3JvbGxQb3NpdGlvbixcbiAgICAgICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBfZCA9PT0gdm9pZCAwID8gZ2V0RGVmYXVsdFNjcm9sbFBvc2l0aW9uIDogX2Q7XG4gICAgZHJhZ1Njcm9sbC5kcmFnKGUsIHtcbiAgICAgIGNvbnRhaW5lcjogc2Nyb2xsQ29udGFpbmVyLFxuICAgICAgdGhyZXNob2xkOiBzY3JvbGxUaHJlc2hvbGQsXG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHJldHVybiBnZXRTY3JvbGxQb3NpdGlvbih7XG4gICAgICAgICAgc2Nyb2xsQ29udGFpbmVyOiBldi5jb250YWluZXIsXG4gICAgICAgICAgZGlyZWN0aW9uOiBldi5kaXJlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWc6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmNoZWNrU2Nyb2xsKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgZS5kYXRhcy5kcmFnU2Nyb2xsLmRyYWdFbmQoKTtcbiAgICBlLmRhdGFzLmRyYWdTY3JvbGwgPSBudWxsO1xuICB9LFxuICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgaXNDb250cm9sOiB0cnVlXG4gICAgfSkpO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBpc0NvbnRyb2w6IHRydWVcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRybzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7XG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9FbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0c1xuICAgIH0pKTtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBzY3JvbGxlZCB0byB0aGUgc2Nyb2xsIGNvbnRhaW5lciAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY3JvbGxhYmxlI3Njcm9sbGFibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICBzY3JvbGxhYmxlOiB0cnVlLFxuICogICBzY3JvbGxDb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gKiAgIHNjcm9sbFRocmVzaG9sZDogMCxcbiAqICAgZ2V0U2Nyb2xsUG9zaXRpb246ICh7IHNjcm9sbENvbnRhaW5lciB9KSA9PiAoW3Njcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0LCBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wXSksXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5zY3JvbGxhYmxlID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFRoZSBjb250YWluZXIgdG8gd2hpY2ggc2Nyb2xsIGlzIGFwcGxpZWQgKGRlZmF1bHQ6IGNvbnRhaW5lcilcbiAqIEBuYW1lIE1vdmVhYmxlLlNjcm9sbGFibGUjc2Nyb2xsQ29udGFpbmVyXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgc2Nyb2xsYWJsZTogdHJ1ZSxcbiAqICAgc2Nyb2xsQ29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICogICBzY3JvbGxUaHJlc2hvbGQ6IDAsXG4gKiAgIGdldFNjcm9sbFBvc2l0aW9uOiAoeyBzY3JvbGxDb250YWluZXIgfSkgPT4gKFtzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCwgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcF0pLFxuICogfSk7XG4gKi9cblxuLyoqXG4gKiBFeHBhbmQgdGhlIHJhbmdlIG9mIHRoZSBzY3JvbGwgY2hlY2sgYXJlYS4gKGRlZmF1bHQ6IDApXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY3JvbGxhYmxlI3Njcm9sbFRocmVzaG9sZFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIHNjcm9sbGFibGU6IHRydWUsXG4gKiAgIHNjcm9sbENvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAqICAgc2Nyb2xsVGhyZXNob2xkOiAwLFxuICogICBnZXRTY3JvbGxQb3NpdGlvbjogKHsgc2Nyb2xsQ29udGFpbmVyIH0pID0+IChbc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQsIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3BdKSxcbiAqIH0pO1xuICovXG5cbi8qKlxuICogU2V0cyBhIGZ1bmN0aW9uIHRvIGdldCB0aGUgc2Nyb2xsIHBvc2l0aW9uLiAoZGVmYXVsdDogRnVuY3Rpb24pXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY3JvbGxhYmxlI2dldFNjcm9sbFBvc2l0aW9uXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgc2Nyb2xsYWJsZTogdHJ1ZSxcbiAqICAgc2Nyb2xsQ29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICogICBzY3JvbGxUaHJlc2hvbGQ6IDAsXG4gKiAgIGdldFNjcm9sbFBvc2l0aW9uOiAoeyBzY3JvbGxDb250YWluZXIgfSkgPT4gKFtzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCwgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcF0pLFxuICogfSk7XG4gKlxuICovXG5cbi8qKlxuICogV2hlbiB0aGUgZHJhZyBjdXJzb3IgbGVhdmVzIHRoZSBzY3JvbGxDb250YWluZXIsIHRoZSBgc2Nyb2xsYCBldmVudCBvY2N1ciB0byBzY3JvbGwuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2Nyb2xsYWJsZVxuICogQGV2ZW50IHNjcm9sbFxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY3JvbGxhYmxlLk9uU2Nyb2xsfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2Nyb2xsYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJzY3JvbGxcIiwgKHsgc2Nyb2xsQ29udGFpbmVyLCBkaXJlY3Rpb24gfSkgPT4ge1xuICogICBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArPSBkaXJlY3Rpb25bMF0gKiAxMDtcbiAqICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArPSBkaXJlY3Rpb25bMV0gKiAxMDtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgZHJhZyBjdXJzb3IgbGVhdmVzIHRoZSBzY3JvbGxDb250YWluZXIsIHRoZSBgc2Nyb2xsR3JvdXBgIGV2ZW50IG9jY3VyIHRvIHNjcm9sbCBpbiBncm91cC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY3JvbGxhYmxlXG4gKiBAZXZlbnQgc2Nyb2xsR3JvdXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2Nyb2xsYWJsZS5PblNjcm9sbEdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2Nyb2xsR3JvdXBgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInNjcm9sbFwiLCAoeyBzY3JvbGxDb250YWluZXIsIGRpcmVjdGlvbiB9KSA9PiB7XG4gKiAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IGRpcmVjdGlvblswXSAqIDEwO1xuICogICBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wICs9IGRpcmVjdGlvblsxXSAqIDEwO1xuICogfSk7XG4gKi9cblxudmFyIERlZmF1bHQgPSB7XG4gIG5hbWU6IFwiXCIsXG4gIHByb3BzOiB7XG4gICAgdGFyZ2V0OiBPYmplY3QsXG4gICAgZHJhZ1RhcmdldDogT2JqZWN0LFxuICAgIGNvbnRhaW5lcjogT2JqZWN0LFxuICAgIHBvcnRhbENvbnRhaW5lcjogT2JqZWN0LFxuICAgIHJvb3RDb250YWluZXI6IE9iamVjdCxcbiAgICB1c2VSZXNpemVPYnNlcnZlcjogQm9vbGVhbixcbiAgICB6b29tOiBOdW1iZXIsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBBcnJheSxcbiAgICBlZGdlOiBCb29sZWFuLFxuICAgIGFibGVzOiBBcnJheSxcbiAgICBjbGFzc05hbWU6IFN0cmluZyxcbiAgICBwaW5jaFRocmVzaG9sZDogTnVtYmVyLFxuICAgIHBpbmNoT3V0c2lkZTogQm9vbGVhbixcbiAgICB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseTogQm9vbGVhbixcbiAgICBjaGVja0lucHV0OiBCb29sZWFuLFxuICAgIGNzcE5vbmNlOiBTdHJpbmcsXG4gICAgdHJhbnNsYXRlWjogTnVtYmVyLFxuICAgIGhpZGVEZWZhdWx0TGluZXM6IEJvb2xlYW4sXG4gICAgcHJvcHM6IE9iamVjdFxuICB9LFxuICBldmVudHM6IHt9XG59O1xuXG52YXIgUGFkZGluZyA9IG1ha2VBYmxlKFwicGFkZGluZ1wiLCB7XG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xuXG4gICAgaWYgKHByb3BzLmRyYWdBcmVhKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmcgPSBwcm9wcy5wYWRkaW5nIHx8IHt9O1xuICAgIHZhciBfYSA9IHBhZGRpbmcubGVmdCxcbiAgICAgICAgbGVmdCA9IF9hID09PSB2b2lkIDAgPyAwIDogX2EsXG4gICAgICAgIF9iID0gcGFkZGluZy50b3AsXG4gICAgICAgIHRvcCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICAgIF9jID0gcGFkZGluZy5yaWdodCxcbiAgICAgICAgcmlnaHQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLFxuICAgICAgICBfZCA9IHBhZGRpbmcuYm90dG9tLFxuICAgICAgICBib3R0b20gPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kO1xuICAgIHZhciBfZSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICByZW5kZXJQb3NlcyA9IF9lLnJlbmRlclBvc2VzLFxuICAgICAgICBwb3MxID0gX2UucG9zMSxcbiAgICAgICAgcG9zMiA9IF9lLnBvczIsXG4gICAgICAgIHBvczMgPSBfZS5wb3MzLFxuICAgICAgICBwb3M0ID0gX2UucG9zNDtcbiAgICB2YXIgcG9zZXMgPSBbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF07XG4gICAgdmFyIHBhZGRpbmdEaXJlY3Rpb25zID0gW107XG5cbiAgICBpZiAobGVmdCA+IDApIHtcbiAgICAgIHBhZGRpbmdEaXJlY3Rpb25zLnB1c2goWzAsIDJdKTtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gMCkge1xuICAgICAgcGFkZGluZ0RpcmVjdGlvbnMucHVzaChbMCwgMV0pO1xuICAgIH1cblxuICAgIGlmIChyaWdodCA+IDApIHtcbiAgICAgIHBhZGRpbmdEaXJlY3Rpb25zLnB1c2goWzEsIDNdKTtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tID4gMCkge1xuICAgICAgcGFkZGluZ0RpcmVjdGlvbnMucHVzaChbMiwgM10pO1xuICAgIH1cblxuICAgIHJldHVybiBwYWRkaW5nRGlyZWN0aW9ucy5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgICB2YXIgZGlyMSA9IF9hWzBdLFxuICAgICAgICAgIGRpcjIgPSBfYVsxXTtcbiAgICAgIHZhciBwYWRkaW5nUG9zMSA9IHBvc2VzW2RpcjFdO1xuICAgICAgdmFyIHBhZGRpbmdQb3MyID0gcG9zZXNbZGlyMl07XG4gICAgICB2YXIgcGFkZGluZ1BvczMgPSByZW5kZXJQb3Nlc1tkaXIxXTtcbiAgICAgIHZhciBwYWRkaW5nUG9zNCA9IHJlbmRlclBvc2VzW2RpcjJdO1xuICAgICAgdmFyIGggPSBjcmVhdGVXYXJwTWF0cml4KFswLCAwXSwgWzEwMCwgMF0sIFswLCAxMDBdLCBbMTAwLCAxMDBdLCBwYWRkaW5nUG9zMSwgcGFkZGluZ1BvczIsIHBhZGRpbmdQb3MzLCBwYWRkaW5nUG9zNCk7XG5cbiAgICAgIGlmICghaC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IFwicGFkZGluZ1wiICsgaSxcbiAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJwYWRkaW5nXCIpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHRyYW5zZm9ybTogbWFrZU1hdHJpeENTUyhoLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG4vKipcbiAqIEFkZCBwYWRkaW5nIGFyb3VuZCB0aGUgdGFyZ2V0IHRvIGluY3JlYXNlIHRoZSBkcmFnIGFyZWEuIChkZWZhdWx0OiBudWxsKVxuICogQG5hbWUgTW92ZWFibGUjcGFkZGluZ1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgdGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKSxcbiAqICBwYWRkaW5nOiB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9LFxuICogfSk7XG4gKiBtb3ZlYWJsZS5wYWRkaW5nID0geyBsZWZ0OiAxMCwgdG9wOiAxMCwgcmlnaHQ6IDEwLCBib3R0b206IDEwIH0sXG4gKiBtb3ZlYWJsZS51cGRhdGVSZWN0KCk7XG4gKi9cblxudmFyIFJBRElVU19ESVJFQ1RJT05TID0gW1wibndcIiwgXCJuZVwiLCBcInNlXCIsIFwic3dcIl07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJhdGlvKHZhbHVlcywgc2l6ZSkge1xuICB2YXIgc3VtU2l6ZSA9IHZhbHVlc1swXSArIHZhbHVlc1sxXTtcbiAgdmFyIHN1bVJhdGlvID0gc3VtU2l6ZSA+IHNpemUgPyBzaXplIC8gc3VtU2l6ZSA6IDE7XG4gIHZhbHVlc1swXSAqPSBzdW1SYXRpbztcbiAgdmFsdWVzWzFdID0gc2l6ZSAtIHZhbHVlc1sxXSAqIHN1bVJhdGlvO1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG52YXIgSE9SSVpPTlRBTF9SQURJVVNfT1JERVIgPSBbMSwgMiwgNSwgNl07XG52YXIgVkVSVElDQUxfUkFESVVTX09SREVSID0gWzAsIDMsIDQsIDddO1xudmFyIEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlMgPSBbMSwgLTEsIC0xLCAxXTtcbnZhciBWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OUyA9IFsxLCAxLCAtMSwgLTFdO1xuZnVuY3Rpb24gZ2V0UmFkaXVzU3R5bGVzKHBvc2VzLCBjb250cm9sUG9zZXMsIGlzUmVsYXRpdmUsIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7XG4gICAgbGVmdCA9IDA7XG4gIH1cblxuICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICB0b3AgPSAwO1xuICB9XG5cbiAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHtcbiAgICByaWdodCA9IHdpZHRoO1xuICB9XG5cbiAgaWYgKGJvdHRvbSA9PT0gdm9pZCAwKSB7XG4gICAgYm90dG9tID0gaGVpZ2h0O1xuICB9XG5cbiAgdmFyIGNsaXBTdHlsZXMgPSBbXTtcbiAgdmFyIGlzVmVydGljYWwgPSBmYWxzZTtcbiAgdmFyIHJhd3MgPSBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgIHZhciBfYSA9IGNvbnRyb2xQb3Nlc1tpXSxcbiAgICAgICAgaG9yaXpvbnRhbCA9IF9hLmhvcml6b250YWwsXG4gICAgICAgIHZlcnRpY2FsID0gX2EudmVydGljYWw7XG5cbiAgICBpZiAodmVydGljYWwgJiYgIWlzVmVydGljYWwpIHtcbiAgICAgIGlzVmVydGljYWwgPSB0cnVlO1xuICAgICAgY2xpcFN0eWxlcy5wdXNoKFwiL1wiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgdmFyIHJhd1BvcyA9IE1hdGgubWF4KDAsIHZlcnRpY2FsID09PSAxID8gcG9zWzFdIC0gdG9wIDogYm90dG9tIC0gcG9zWzFdKTtcbiAgICAgIGNsaXBTdHlsZXMucHVzaChjb252ZXJ0Q1NTU2l6ZShyYXdQb3MsIGhlaWdodCwgaXNSZWxhdGl2ZSkpO1xuICAgICAgcmV0dXJuIHJhd1BvcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJhd1BvcyA9IE1hdGgubWF4KDAsIGhvcml6b250YWwgPT09IDEgPyBwb3NbMF0gLSBsZWZ0IDogcmlnaHQgLSBwb3NbMF0pO1xuICAgICAgY2xpcFN0eWxlcy5wdXNoKGNvbnZlcnRDU1NTaXplKHJhd1Bvcywgd2lkdGgsIGlzUmVsYXRpdmUpKTtcbiAgICAgIHJldHVybiByYXdQb3M7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZXM6IGNsaXBTdHlsZXMsXG4gICAgcmF3czogcmF3c1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmFkaXVzUmFuZ2UoY29udHJvbFBvc2VzKSB7XG4gIC8vIFtzdGFydCwgbGVuZ3RoXVxuICB2YXIgaG9yaXpvbnRhbFJhbmdlID0gWzAsIDBdO1xuICB2YXIgdmVydGljYWxSYW5nZSA9IFswLCAwXTtcbiAgdmFyIGxlbmd0aCA9IGNvbnRyb2xQb3Nlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBjbGlwUG9zZSA9IGNvbnRyb2xQb3Nlc1tpXTtcblxuICAgIGlmICghY2xpcFBvc2Uuc3ViKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2xpcFBvc2UuaG9yaXpvbnRhbCkge1xuICAgICAgaWYgKGhvcml6b250YWxSYW5nZVsxXSA9PT0gMCkge1xuICAgICAgICBob3Jpem9udGFsUmFuZ2VbMF0gPSBpO1xuICAgICAgfVxuXG4gICAgICBob3Jpem9udGFsUmFuZ2VbMV0gPSBpIC0gaG9yaXpvbnRhbFJhbmdlWzBdICsgMTtcbiAgICAgIHZlcnRpY2FsUmFuZ2VbMF0gPSBpICsgMTtcbiAgICB9XG5cbiAgICBpZiAoY2xpcFBvc2UudmVydGljYWwpIHtcbiAgICAgIGlmICh2ZXJ0aWNhbFJhbmdlWzFdID09PSAwKSB7XG4gICAgICAgIHZlcnRpY2FsUmFuZ2VbMF0gPSBpO1xuICAgICAgfVxuXG4gICAgICB2ZXJ0aWNhbFJhbmdlWzFdID0gaSAtIHZlcnRpY2FsUmFuZ2VbMF0gKyAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbFJhbmdlOiBob3Jpem9udGFsUmFuZ2UsXG4gICAgdmVydGljYWxSYW5nZTogdmVydGljYWxSYW5nZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmFkaXVzVmFsdWVzKHZhbHVlcywgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCBtaW5Db3VudHMpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuXG4gIGlmIChtaW5Db3VudHMgPT09IHZvaWQgMCkge1xuICAgIG1pbkNvdW50cyA9IFswLCAwXTtcbiAgfVxuXG4gIHZhciBzcGxpdEluZGV4ID0gdmFsdWVzLmluZGV4T2YoXCIvXCIpO1xuICB2YXIgc3BsaXRMZW5ndGggPSAoc3BsaXRJbmRleCA+IC0xID8gdmFsdWVzLnNsaWNlKDAsIHNwbGl0SW5kZXgpIDogdmFsdWVzKS5sZW5ndGg7XG4gIHZhciBob3Jpem9udGFsVmFsdWVzID0gdmFsdWVzLnNsaWNlKDAsIHNwbGl0TGVuZ3RoKTtcbiAgdmFyIHZlcnRpY2FsVmFsdWVzID0gdmFsdWVzLnNsaWNlKHNwbGl0TGVuZ3RoICsgMSk7XG4gIHZhciBfZSA9IGhvcml6b250YWxWYWx1ZXNbMF0sXG4gICAgICBud1ZhbHVlID0gX2UgPT09IHZvaWQgMCA/IFwiMHB4XCIgOiBfZSxcbiAgICAgIF9mID0gaG9yaXpvbnRhbFZhbHVlc1sxXSxcbiAgICAgIG5lVmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gbndWYWx1ZSA6IF9mLFxuICAgICAgX2cgPSBob3Jpem9udGFsVmFsdWVzWzJdLFxuICAgICAgc2VWYWx1ZSA9IF9nID09PSB2b2lkIDAgPyBud1ZhbHVlIDogX2csXG4gICAgICBfaCA9IGhvcml6b250YWxWYWx1ZXNbM10sXG4gICAgICBzd1ZhbHVlID0gX2ggPT09IHZvaWQgMCA/IG5lVmFsdWUgOiBfaDtcbiAgdmFyIF9qID0gdmVydGljYWxWYWx1ZXNbMF0sXG4gICAgICB3blZhbHVlID0gX2ogPT09IHZvaWQgMCA/IG53VmFsdWUgOiBfaixcbiAgICAgIF9rID0gdmVydGljYWxWYWx1ZXNbMV0sXG4gICAgICBlblZhbHVlID0gX2sgPT09IHZvaWQgMCA/IHduVmFsdWUgOiBfayxcbiAgICAgIF9sID0gdmVydGljYWxWYWx1ZXNbMl0sXG4gICAgICBlc1ZhbHVlID0gX2wgPT09IHZvaWQgMCA/IHduVmFsdWUgOiBfbCxcbiAgICAgIF9tID0gdmVydGljYWxWYWx1ZXNbM10sXG4gICAgICB3c1ZhbHVlID0gX20gPT09IHZvaWQgMCA/IGVuVmFsdWUgOiBfbTtcbiAgdmFyIGhvcml6b250YWxSYXdQb3NlcyA9IFtud1ZhbHVlLCBuZVZhbHVlLCBzZVZhbHVlLCBzd1ZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBjb252ZXJ0VW5pdFNpemUocG9zLCB3aWR0aCk7XG4gIH0pO1xuICB2YXIgdmVydGljYWxSYXdQb3NlcyA9IFt3blZhbHVlLCBlblZhbHVlLCBlc1ZhbHVlLCB3c1ZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBjb252ZXJ0VW5pdFNpemUocG9zLCBoZWlnaHQpO1xuICB9KTtcbiAgdmFyIGhvcml6b250YWxQb3NlcyA9IGhvcml6b250YWxSYXdQb3Nlcy5zbGljZSgpO1xuICB2YXIgdmVydGljYWxQb3NlcyA9IHZlcnRpY2FsUmF3UG9zZXMuc2xpY2UoKTtcbiAgX2EgPSBjYWxjdWxhdGVSYXRpbyhbaG9yaXpvbnRhbFBvc2VzWzBdLCBob3Jpem9udGFsUG9zZXNbMV1dLCB3aWR0aCksIGhvcml6b250YWxQb3Nlc1swXSA9IF9hWzBdLCBob3Jpem9udGFsUG9zZXNbMV0gPSBfYVsxXTtcbiAgX2IgPSBjYWxjdWxhdGVSYXRpbyhbaG9yaXpvbnRhbFBvc2VzWzNdLCBob3Jpem9udGFsUG9zZXNbMl1dLCB3aWR0aCksIGhvcml6b250YWxQb3Nlc1szXSA9IF9iWzBdLCBob3Jpem9udGFsUG9zZXNbMl0gPSBfYlsxXTtcbiAgX2MgPSBjYWxjdWxhdGVSYXRpbyhbdmVydGljYWxQb3Nlc1swXSwgdmVydGljYWxQb3Nlc1szXV0sIGhlaWdodCksIHZlcnRpY2FsUG9zZXNbMF0gPSBfY1swXSwgdmVydGljYWxQb3Nlc1szXSA9IF9jWzFdO1xuICBfZCA9IGNhbGN1bGF0ZVJhdGlvKFt2ZXJ0aWNhbFBvc2VzWzFdLCB2ZXJ0aWNhbFBvc2VzWzJdXSwgaGVpZ2h0KSwgdmVydGljYWxQb3Nlc1sxXSA9IF9kWzBdLCB2ZXJ0aWNhbFBvc2VzWzJdID0gX2RbMV07XG4gIHZhciBuZXh0SG9yaXpvbnRhbFBvc2VzID0gaG9yaXpvbnRhbFBvc2VzLnNsaWNlKDAsIE1hdGgubWF4KG1pbkNvdW50c1swXSwgaG9yaXpvbnRhbFZhbHVlcy5sZW5ndGgpKTtcbiAgdmFyIG5leHRWZXJ0aWNhbFBvc2VzID0gdmVydGljYWxQb3Nlcy5zbGljZSgwLCBNYXRoLm1heChtaW5Db3VudHNbMV0sIHZlcnRpY2FsVmFsdWVzLmxlbmd0aCkpO1xuICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBuZXh0SG9yaXpvbnRhbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IFJBRElVU19ESVJFQ1RJT05TW2ldO1xuICAgIHJldHVybiB7XG4gICAgICBob3Jpem9udGFsOiBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TW2ldLFxuICAgICAgdmVydGljYWw6IDAsXG4gICAgICBwb3M6IFtsZWZ0ICsgcG9zLCB0b3AgKyAoVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xID8gaGVpZ2h0IDogMCldLFxuICAgICAgc3ViOiB0cnVlLFxuICAgICAgcmF3OiBob3Jpem9udGFsUmF3UG9zZXNbaV0sXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH07XG4gIH0pKSwgbmV4dFZlcnRpY2FsUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gUkFESVVTX0RJUkVDVElPTlNbaV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICB2ZXJ0aWNhbDogVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0sXG4gICAgICBwb3M6IFtsZWZ0ICsgKEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xID8gd2lkdGggOiAwKSwgdG9wICsgcG9zXSxcbiAgICAgIHN1YjogdHJ1ZSxcbiAgICAgIHJhdzogdmVydGljYWxSYXdQb3Nlc1tpXSxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmFkaXVzUG9zKGNvbnRyb2xQb3NlcywgcG9zZXMsIGluZGV4LCBzdGFydEluZGV4LCBsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgbGVuZ3RoID0gcG9zZXMubGVuZ3RoO1xuICB9XG5cbiAgdmFyIF9hID0gZ2V0UmFkaXVzUmFuZ2UoY29udHJvbFBvc2VzLnNsaWNlKHN0YXJ0SW5kZXgpKSxcbiAgICAgIGhvcml6b250YWxSYW5nZSA9IF9hLmhvcml6b250YWxSYW5nZSxcbiAgICAgIHZlcnRpY2FsUmFuZ2UgPSBfYS52ZXJ0aWNhbFJhbmdlO1xuXG4gIHZhciByYWRpdXNsSW5kZXggPSBpbmRleCAtIHN0YXJ0SW5kZXg7XG4gIHZhciBkZWxldGVDb3VudCA9IDA7XG5cbiAgaWYgKHJhZGl1c2xJbmRleCA9PT0gMCkge1xuICAgIGRlbGV0ZUNvdW50ID0gbGVuZ3RoO1xuICB9IGVsc2UgaWYgKHJhZGl1c2xJbmRleCA+IDAgJiYgcmFkaXVzbEluZGV4IDwgaG9yaXpvbnRhbFJhbmdlWzFdKSB7XG4gICAgZGVsZXRlQ291bnQgPSBob3Jpem9udGFsUmFuZ2VbMV0gLSByYWRpdXNsSW5kZXg7XG4gIH0gZWxzZSBpZiAocmFkaXVzbEluZGV4ID49IHZlcnRpY2FsUmFuZ2VbMF0pIHtcbiAgICBkZWxldGVDb3VudCA9IHZlcnRpY2FsUmFuZ2VbMF0gKyB2ZXJ0aWNhbFJhbmdlWzFdIC0gcmFkaXVzbEluZGV4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnRyb2xQb3Nlcy5zcGxpY2UoaW5kZXgsIGRlbGV0ZUNvdW50KTtcbiAgcG9zZXMuc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCk7XG59XG5mdW5jdGlvbiBhZGRSYWRpdXNQb3MoY29udHJvbFBvc2VzLCBwb3Nlcywgc3RhcnRJbmRleCwgaG9yaXpvbnRhbEluZGV4LCB2ZXJ0aWNhbEluZGV4LCBkaXN0WCwgZGlzdFksIHJpZ2h0LCBib3R0b20sIGxlZnQsIHRvcCkge1xuICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7XG4gICAgbGVmdCA9IDA7XG4gIH1cblxuICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICB0b3AgPSAwO1xuICB9XG5cbiAgdmFyIF9hID0gZ2V0UmFkaXVzUmFuZ2UoY29udHJvbFBvc2VzLnNsaWNlKHN0YXJ0SW5kZXgpKSxcbiAgICAgIGhvcml6b250YWxSYW5nZSA9IF9hLmhvcml6b250YWxSYW5nZSxcbiAgICAgIHZlcnRpY2FsUmFuZ2UgPSBfYS52ZXJ0aWNhbFJhbmdlO1xuXG4gIGlmIChob3Jpem9udGFsSW5kZXggPiAtMSkge1xuICAgIHZhciByYWRpdXNYID0gSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1tob3Jpem9udGFsSW5kZXhdID09PSAxID8gZGlzdFggLSBsZWZ0IDogcmlnaHQgLSBkaXN0WDtcblxuICAgIGZvciAodmFyIGkgPSBob3Jpem9udGFsUmFuZ2VbMV07IGkgPD0gaG9yaXpvbnRhbEluZGV4OyArK2kpIHtcbiAgICAgIHZhciB5ID0gVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IDEgPyB0b3AgOiBib3R0b207XG4gICAgICB2YXIgeCA9IDA7XG5cbiAgICAgIGlmIChob3Jpem9udGFsSW5kZXggPT09IGkpIHtcbiAgICAgICAgeCA9IGRpc3RYO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgIHggPSBsZWZ0ICsgcmFkaXVzWDtcbiAgICAgIH0gZWxzZSBpZiAoSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1tpXSA9PT0gLTEpIHtcbiAgICAgICAgeCA9IHJpZ2h0IC0gKHBvc2VzW3N0YXJ0SW5kZXhdWzBdIC0gbGVmdCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRyb2xQb3Nlcy5zcGxpY2Uoc3RhcnRJbmRleCArIGksIDAsIHtcbiAgICAgICAgaG9yaXpvbnRhbDogSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1tpXSxcbiAgICAgICAgdmVydGljYWw6IDAsXG4gICAgICAgIHBvczogW3gsIHldXG4gICAgICB9KTtcbiAgICAgIHBvc2VzLnNwbGljZShzdGFydEluZGV4ICsgaSwgMCwgW3gsIHldKTtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHZlcnRpY2FsSW5kZXggPiAtMSkge1xuICAgIHZhciByYWRpdXNZID0gVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbdmVydGljYWxJbmRleF0gPT09IDEgPyBkaXN0WSAtIHRvcCA6IGJvdHRvbSAtIGRpc3RZO1xuXG4gICAgaWYgKGhvcml6b250YWxSYW5nZVsxXSA9PT0gMCAmJiB2ZXJ0aWNhbFJhbmdlWzFdID09PSAwKSB7XG4gICAgICB2YXIgcG9zID0gW2xlZnQgKyByYWRpdXNZLCB0b3BdO1xuICAgICAgY29udHJvbFBvc2VzLnB1c2goe1xuICAgICAgICBob3Jpem9udGFsOiBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TWzBdLFxuICAgICAgICB2ZXJ0aWNhbDogMCxcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pO1xuICAgICAgcG9zZXMucHVzaChwb3MpO1xuICAgIH1cblxuICAgIHZhciBzdGFydFZlcnRpY2FsSW5kZXggPSB2ZXJ0aWNhbFJhbmdlWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IHZlcnRpY2FsUmFuZ2VbMV07IGkgPD0gdmVydGljYWxJbmRleDsgKytpKSB7XG4gICAgICB2YXIgeCA9IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IDEgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICB2YXIgeSA9IDA7XG5cbiAgICAgIGlmICh2ZXJ0aWNhbEluZGV4ID09PSBpKSB7XG4gICAgICAgIHkgPSBkaXN0WTtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICB5ID0gdG9wICsgcmFkaXVzWTtcbiAgICAgIH0gZWxzZSBpZiAoVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IDEpIHtcbiAgICAgICAgeSA9IHBvc2VzW3N0YXJ0SW5kZXggKyBzdGFydFZlcnRpY2FsSW5kZXhdWzFdO1xuICAgICAgfSBlbHNlIGlmIChWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1tpXSA9PT0gLTEpIHtcbiAgICAgICAgeSA9IGJvdHRvbSAtIChwb3Nlc1tzdGFydEluZGV4ICsgc3RhcnRWZXJ0aWNhbEluZGV4XVsxXSAtIHRvcCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRyb2xQb3Nlcy5wdXNoKHtcbiAgICAgICAgaG9yaXpvbnRhbDogMCxcbiAgICAgICAgdmVydGljYWw6IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldLFxuICAgICAgICBwb3M6IFt4LCB5XVxuICAgICAgfSk7XG4gICAgICBwb3Nlcy5wdXNoKFt4LCB5XSk7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3BsaXRSYWRpdXNQb3Nlcyhjb250cm9sUG9zZXMsIHJhd3MpIHtcbiAgaWYgKHJhd3MgPT09IHZvaWQgMCkge1xuICAgIHJhd3MgPSBjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3MucmF3O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhvcml6b250YWxzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgcmV0dXJuIHBvcy5ob3Jpem9udGFsID8gcmF3c1tpXSA6IG51bGw7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAhPSBudWxsO1xuICB9KTtcbiAgdmFyIHZlcnRpY2FscyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgIHJldHVybiBwb3MudmVydGljYWwgPyByYXdzW2ldIDogbnVsbDtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICE9IG51bGw7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWxzOiBob3Jpem9udGFscyxcbiAgICB2ZXJ0aWNhbHM6IHZlcnRpY2Fsc1xuICB9O1xufVxuXG52YXIgQ0xJUF9ESVJFQ1RJT05TID0gW1swLCAtMSwgXCJuXCJdLCBbMSwgMCwgXCJlXCJdXTtcbnZhciBDTElQX1JFQ1RfRElSRUNUSU9OUyA9IFtbLTEsIC0xLCBcIm53XCJdLCBbMCwgLTEsIFwiblwiXSwgWzEsIC0xLCBcIm5lXCJdLCBbMSwgMCwgXCJlXCJdLCBbMSwgMSwgXCJzZVwiXSwgWzAsIDEsIFwic1wiXSwgWy0xLCAxLCBcInN3XCJdLCBbLTEsIDAsIFwid1wiXV07IC8vIDEgMiA1IDYgMCAzIDQgN1xuLy8gMCAxIDIgMyA0IDUgNiA3XG5cbmZ1bmN0aW9uIGdldENsaXBTdHlsZXMobW92ZWFibGUsIGNsaXBQYXRoLCBwb3Nlcykge1xuICB2YXIgY2xpcFJlbGF0aXZlID0gbW92ZWFibGUucHJvcHMuY2xpcFJlbGF0aXZlO1xuICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSxcbiAgICAgIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gIHZhciBfYiA9IGNsaXBQYXRoLFxuICAgICAgY2xpcFR5cGUgPSBfYi50eXBlLFxuICAgICAgY2xpcFBvc2VzID0gX2IucG9zZXM7XG4gIHZhciBpc1JlY3QgPSBjbGlwVHlwZSA9PT0gXCJyZWN0XCI7XG4gIHZhciBpc0NpcmNsZSA9IGNsaXBUeXBlID09PSBcImNpcmNsZVwiO1xuXG4gIGlmIChjbGlwVHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICByZXR1cm4gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBjb252ZXJ0Q1NTU2l6ZShwb3NbMF0sIHdpZHRoLCBjbGlwUmVsYXRpdmUpICsgXCIgXCIgKyBjb252ZXJ0Q1NTU2l6ZShwb3NbMV0sIGhlaWdodCwgY2xpcFJlbGF0aXZlKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1JlY3QgfHwgY2xpcFR5cGUgPT09IFwiaW5zZXRcIikge1xuICAgIHZhciB0b3AgPSBwb3Nlc1sxXVsxXTtcbiAgICB2YXIgcmlnaHQgPSBwb3Nlc1szXVswXTtcbiAgICB2YXIgbGVmdCA9IHBvc2VzWzddWzBdO1xuICAgIHZhciBib3R0b20gPSBwb3Nlc1s1XVsxXTtcblxuICAgIGlmIChpc1JlY3QpIHtcbiAgICAgIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zICsgXCJweFwiO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNsaXBTdHlsZXMgPSBbdG9wLCB3aWR0aCAtIHJpZ2h0LCBoZWlnaHQgLSBib3R0b20sIGxlZnRdLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgICByZXR1cm4gY29udmVydENTU1NpemUocG9zLCBpICUgMiA/IHdpZHRoIDogaGVpZ2h0LCBjbGlwUmVsYXRpdmUpO1xuICAgIH0pO1xuXG4gICAgaWYgKHBvc2VzLmxlbmd0aCA+IDgpIHtcbiAgICAgIHZhciBfYyA9IG1pbnVzKHBvc2VzWzRdLCBwb3Nlc1swXSksXG4gICAgICAgICAgc3ViV2lkdGggPSBfY1swXSxcbiAgICAgICAgICBzdWJIZWlnaHQgPSBfY1sxXTtcblxuICAgICAgY2xpcFN0eWxlcy5wdXNoLmFwcGx5KGNsaXBTdHlsZXMsIF9fc3ByZWFkQXJyYXkoW1wicm91bmRcIl0sIGdldFJhZGl1c1N0eWxlcyhwb3Nlcy5zbGljZSg4KSwgY2xpcFBvc2VzLnNsaWNlKDgpLCBjbGlwUmVsYXRpdmUsIHN1YldpZHRoLCBzdWJIZWlnaHQsIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkuc3R5bGVzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBTdHlsZXM7XG4gIH0gZWxzZSBpZiAoaXNDaXJjbGUgfHwgY2xpcFR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgdmFyIGNlbnRlciA9IHBvc2VzWzBdO1xuICAgIHZhciByeSA9IGNvbnZlcnRDU1NTaXplKE1hdGguYWJzKHBvc2VzWzFdWzFdIC0gY2VudGVyWzFdKSwgaXNDaXJjbGUgPyBNYXRoLnNxcnQoKHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpIC8gMikgOiBoZWlnaHQsIGNsaXBSZWxhdGl2ZSk7XG4gICAgdmFyIGNsaXBTdHlsZXMgPSBpc0NpcmNsZSA/IFtyeV0gOiBbY29udmVydENTU1NpemUoTWF0aC5hYnMocG9zZXNbMl1bMF0gLSBjZW50ZXJbMF0pLCB3aWR0aCwgY2xpcFJlbGF0aXZlKSwgcnldO1xuICAgIGNsaXBTdHlsZXMucHVzaChcImF0XCIsIGNvbnZlcnRDU1NTaXplKGNlbnRlclswXSwgd2lkdGgsIGNsaXBSZWxhdGl2ZSksIGNvbnZlcnRDU1NTaXplKGNlbnRlclsxXSwgaGVpZ2h0LCBjbGlwUmVsYXRpdmUpKTtcbiAgICByZXR1cm4gY2xpcFN0eWxlcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWN0UG9zZXModG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KSB7XG4gIHZhciB4cyA9IFtsZWZ0LCAobGVmdCArIHJpZ2h0KSAvIDIsIHJpZ2h0XTtcbiAgdmFyIHlzID0gW3RvcCwgKHRvcCArIGJvdHRvbSkgLyAyLCBib3R0b21dO1xuICByZXR1cm4gQ0xJUF9SRUNUX0RJUkVDVElPTlMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBkaXJ4ID0gX2FbMF0sXG4gICAgICAgIGRpcnkgPSBfYVsxXSxcbiAgICAgICAgZGlyID0gX2FbMl07XG4gICAgdmFyIHggPSB4c1tkaXJ4ICsgMV07XG4gICAgdmFyIHkgPSB5c1tkaXJ5ICsgMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnRpY2FsOiBNYXRoLmFicyhkaXJ5KSxcbiAgICAgIGhvcml6b250YWw6IE1hdGguYWJzKGRpcngpLFxuICAgICAgZGlyZWN0aW9uOiBkaXIsXG4gICAgICBwb3M6IFt4LCB5XVxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRDbGlwUGF0aCh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIGRlZmF1bHRDbGlwLCBjdXN0b21DbGlwKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcblxuICB2YXIgY2xpcFRleHQgPSBjdXN0b21DbGlwO1xuXG4gIGlmICghY2xpcFRleHQpIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgdmFyIGNsaXBQYXRoID0gc3R5bGUuY2xpcFBhdGg7XG4gICAgY2xpcFRleHQgPSBjbGlwUGF0aCAhPT0gXCJub25lXCIgPyBjbGlwUGF0aCA6IHN0eWxlLmNsaXA7XG4gIH1cblxuICBpZiAoIWNsaXBUZXh0IHx8IGNsaXBUZXh0ID09PSBcIm5vbmVcIiB8fCBjbGlwVGV4dCA9PT0gXCJhdXRvXCIpIHtcbiAgICBjbGlwVGV4dCA9IGRlZmF1bHRDbGlwO1xuXG4gICAgaWYgKCFjbGlwVGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfaCA9IHNwbGl0QnJhY2tldChjbGlwVGV4dCksXG4gICAgICBfaiA9IF9oLnByZWZpeCxcbiAgICAgIGNsaXBQcmVmaXggPSBfaiA9PT0gdm9pZCAwID8gY2xpcFRleHQgOiBfaixcbiAgICAgIF9rID0gX2gudmFsdWUsXG4gICAgICB2YWx1ZSA9IF9rID09PSB2b2lkIDAgPyBcIlwiIDogX2s7XG5cbiAgdmFyIGlzQ2lyY2xlID0gY2xpcFByZWZpeCA9PT0gXCJjaXJjbGVcIjtcbiAgdmFyIHNwbGl0dGVyID0gXCIgXCI7XG5cbiAgaWYgKGNsaXBQcmVmaXggPT09IFwicG9seWdvblwiKSB7XG4gICAgdmFyIHZhbHVlcyA9IHNwbGl0Q29tbWEodmFsdWUgfHwgXCIwJSAwJSwgMTAwJSAwJSwgMTAwJSAxMDAlLCAwJSAxMDAlXCIpO1xuICAgIHNwbGl0dGVyID0gXCIsXCI7XG4gICAgdmFyIHBvc2VzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICB2YXIgX2EgPSBwb3Muc3BsaXQoXCIgXCIpLFxuICAgICAgICAgIHhQb3MgPSBfYVswXSxcbiAgICAgICAgICB5UG9zID0gX2FbMV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRpY2FsOiAxLFxuICAgICAgICBob3Jpem9udGFsOiAxLFxuICAgICAgICBwb3M6IFtjb252ZXJ0VW5pdFNpemUoeFBvcywgd2lkdGgpLCBjb252ZXJ0VW5pdFNpemUoeVBvcywgaGVpZ2h0KV1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGNsaXBQcmVmaXgsXG4gICAgICBjbGlwVGV4dDogY2xpcFRleHQsXG4gICAgICBwb3NlczogcG9zZXMsXG4gICAgICBzcGxpdHRlcjogc3BsaXR0ZXJcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzQ2lyY2xlIHx8IGNsaXBQcmVmaXggPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgdmFyIHhQb3MgPSBcIlwiO1xuICAgIHZhciB5UG9zID0gXCJcIjtcbiAgICB2YXIgcmFkaXVzWF8xID0gMDtcbiAgICB2YXIgcmFkaXVzWV8xID0gMDtcbiAgICB2YXIgdmFsdWVzID0gc3BsaXRTcGFjZSh2YWx1ZSk7XG5cbiAgICBpZiAoaXNDaXJjbGUpIHtcbiAgICAgIHZhciByYWRpdXMgPSBcIlwiO1xuICAgICAgX2EgPSB2YWx1ZXNbMF0sIHJhZGl1cyA9IF9hID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2EsIF9iID0gdmFsdWVzWzJdLCB4UG9zID0gX2IgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfYiwgX2MgPSB2YWx1ZXNbM10sIHlQb3MgPSBfYyA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9jO1xuICAgICAgcmFkaXVzWF8xID0gY29udmVydFVuaXRTaXplKHJhZGl1cywgTWF0aC5zcXJ0KCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDIpKTtcbiAgICAgIHJhZGl1c1lfMSA9IHJhZGl1c1hfMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhSYWRpdXMgPSBcIlwiO1xuICAgICAgdmFyIHlSYWRpdXMgPSBcIlwiO1xuICAgICAgX2QgPSB2YWx1ZXNbMF0sIHhSYWRpdXMgPSBfZCA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9kLCBfZSA9IHZhbHVlc1sxXSwgeVJhZGl1cyA9IF9lID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2UsIF9mID0gdmFsdWVzWzNdLCB4UG9zID0gX2YgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfZiwgX2cgPSB2YWx1ZXNbNF0sIHlQb3MgPSBfZyA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9nO1xuICAgICAgcmFkaXVzWF8xID0gY29udmVydFVuaXRTaXplKHhSYWRpdXMsIHdpZHRoKTtcbiAgICAgIHJhZGl1c1lfMSA9IGNvbnZlcnRVbml0U2l6ZSh5UmFkaXVzLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHZhciBjZW50ZXJQb3NfMSA9IFtjb252ZXJ0VW5pdFNpemUoeFBvcywgd2lkdGgpLCBjb252ZXJ0VW5pdFNpemUoeVBvcywgaGVpZ2h0KV07XG5cbiAgICB2YXIgcG9zZXMgPSBfX3NwcmVhZEFycmF5KFt7XG4gICAgICB2ZXJ0aWNhbDogMSxcbiAgICAgIGhvcml6b250YWw6IDEsXG4gICAgICBwb3M6IGNlbnRlclBvc18xLFxuICAgICAgZGlyZWN0aW9uOiBcIm5lc3dcIlxuICAgIH1dLCBDTElQX0RJUkVDVElPTlMuc2xpY2UoMCwgaXNDaXJjbGUgPyAxIDogMikubWFwKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRpY2FsOiBNYXRoLmFicyhkaXJbMV0pLFxuICAgICAgICBob3Jpem9udGFsOiBkaXJbMF0sXG4gICAgICAgIGRpcmVjdGlvbjogZGlyWzJdLFxuICAgICAgICBzdWI6IHRydWUsXG4gICAgICAgIHBvczogW2NlbnRlclBvc18xWzBdICsgZGlyWzBdICogcmFkaXVzWF8xLCBjZW50ZXJQb3NfMVsxXSArIGRpclsxXSAqIHJhZGl1c1lfMV1cbiAgICAgIH07XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGNsaXBQcmVmaXgsXG4gICAgICBjbGlwVGV4dDogY2xpcFRleHQsXG4gICAgICByYWRpdXNYOiByYWRpdXNYXzEsXG4gICAgICByYWRpdXNZOiByYWRpdXNZXzEsXG4gICAgICBsZWZ0OiBjZW50ZXJQb3NfMVswXSAtIHJhZGl1c1hfMSxcbiAgICAgIHRvcDogY2VudGVyUG9zXzFbMV0gLSByYWRpdXNZXzEsXG4gICAgICBwb3NlczogcG9zZXMsXG4gICAgICBzcGxpdHRlcjogc3BsaXR0ZXJcbiAgICB9O1xuICB9IGVsc2UgaWYgKGNsaXBQcmVmaXggPT09IFwiaW5zZXRcIikge1xuICAgIHZhciB2YWx1ZXMgPSBzcGxpdFNwYWNlKHZhbHVlIHx8IFwiMCAwIDAgMFwiKTtcbiAgICB2YXIgcm91bmRJbmRleCA9IHZhbHVlcy5pbmRleE9mKFwicm91bmRcIik7XG4gICAgdmFyIHJlY3RMZW5ndGggPSAocm91bmRJbmRleCA+IC0xID8gdmFsdWVzLnNsaWNlKDAsIHJvdW5kSW5kZXgpIDogdmFsdWVzKS5sZW5ndGg7XG4gICAgdmFyIHJhZGl1c1ZhbHVlcyA9IHZhbHVlcy5zbGljZShyZWN0TGVuZ3RoICsgMSk7XG5cbiAgICB2YXIgX2wgPSB2YWx1ZXMuc2xpY2UoMCwgcmVjdExlbmd0aCksXG4gICAgICAgIHRvcFZhbHVlID0gX2xbMF0sXG4gICAgICAgIF9tID0gX2xbMV0sXG4gICAgICAgIHJpZ2h0VmFsdWUgPSBfbSA9PT0gdm9pZCAwID8gdG9wVmFsdWUgOiBfbSxcbiAgICAgICAgX28gPSBfbFsyXSxcbiAgICAgICAgYm90dG9tVmFsdWUgPSBfbyA9PT0gdm9pZCAwID8gdG9wVmFsdWUgOiBfbyxcbiAgICAgICAgX3AgPSBfbFszXSxcbiAgICAgICAgbGVmdFZhbHVlID0gX3AgPT09IHZvaWQgMCA/IHJpZ2h0VmFsdWUgOiBfcDtcblxuICAgIHZhciBfcSA9IFt0b3BWYWx1ZSwgYm90dG9tVmFsdWVdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgaGVpZ2h0KTtcbiAgICB9KSxcbiAgICAgICAgdG9wID0gX3FbMF0sXG4gICAgICAgIGJvdHRvbSA9IF9xWzFdO1xuXG4gICAgdmFyIF9yID0gW2xlZnRWYWx1ZSwgcmlnaHRWYWx1ZV0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBjb252ZXJ0VW5pdFNpemUocG9zLCB3aWR0aCk7XG4gICAgfSksXG4gICAgICAgIGxlZnQgPSBfclswXSxcbiAgICAgICAgcmlnaHQgPSBfclsxXTtcblxuICAgIHZhciBuZXh0UmlnaHQgPSB3aWR0aCAtIHJpZ2h0O1xuICAgIHZhciBuZXh0Qm90dG9tID0gaGVpZ2h0IC0gYm90dG9tO1xuICAgIHZhciByYWRpdXNQb3NlcyA9IGdldFJhZGl1c1ZhbHVlcyhyYWRpdXNWYWx1ZXMsIG5leHRSaWdodCAtIGxlZnQsIG5leHRCb3R0b20gLSB0b3AsIGxlZnQsIHRvcCk7XG5cbiAgICB2YXIgcG9zZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGdldFJlY3RQb3Nlcyh0b3AsIG5leHRSaWdodCwgbmV4dEJvdHRvbSwgbGVmdCkpLCByYWRpdXNQb3Nlcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbnNldFwiLFxuICAgICAgY2xpcFRleHQ6IGNsaXBUZXh0LFxuICAgICAgcG9zZXM6IHBvc2VzLFxuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgcmlnaHQ6IG5leHRSaWdodCxcbiAgICAgIGJvdHRvbTogbmV4dEJvdHRvbSxcbiAgICAgIHJhZGl1czogcmFkaXVzVmFsdWVzLFxuICAgICAgc3BsaXR0ZXI6IHNwbGl0dGVyXG4gICAgfTtcbiAgfSBlbHNlIGlmIChjbGlwUHJlZml4ID09PSBcInJlY3RcIikge1xuICAgIC8vIHRvcCByaWdodCBib3R0b20gbGVmdFxuICAgIHZhciB2YWx1ZXMgPSBzcGxpdENvbW1hKHZhbHVlIHx8IFwiMHB4LCBcIiArIHdpZHRoICsgXCJweCwgXCIgKyBoZWlnaHQgKyBcInB4LCAwcHhcIik7XG4gICAgc3BsaXR0ZXIgPSBcIixcIjtcblxuICAgIHZhciBfcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgdmFyIHBvc1ZhbHVlID0gc3BsaXRVbml0KHBvcykudmFsdWU7XG4gICAgICByZXR1cm4gcG9zVmFsdWU7XG4gICAgfSksXG4gICAgICAgIHRvcCA9IF9zWzBdLFxuICAgICAgICByaWdodCA9IF9zWzFdLFxuICAgICAgICBib3R0b20gPSBfc1syXSxcbiAgICAgICAgbGVmdCA9IF9zWzNdO1xuXG4gICAgdmFyIHBvc2VzID0gZ2V0UmVjdFBvc2VzKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmVjdFwiLFxuICAgICAgY2xpcFRleHQ6IGNsaXBUZXh0LFxuICAgICAgcG9zZXM6IHBvc2VzLFxuICAgICAgdG9wOiB0b3AsXG4gICAgICByaWdodDogcmlnaHQsXG4gICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgIHNwbGl0dGVyOiBzcGxpdHRlclxuICAgIH07XG4gIH1cblxuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIGFkZENsaXBQYXRoKG1vdmVhYmxlLCBlKSB7XG4gIHZhciBfYSA9IGNhbGN1bGF0ZVBvaW50ZXJEaXN0KG1vdmVhYmxlLCBlKSxcbiAgICAgIGRpc3RYID0gX2FbMF0sXG4gICAgICBkaXN0WSA9IF9hWzFdO1xuXG4gIHZhciBfYiA9IGUuZGF0YXMsXG4gICAgICBjbGlwUGF0aCA9IF9iLmNsaXBQYXRoLFxuICAgICAgaW5kZXggPSBfYi5pbmRleDtcbiAgdmFyIF9jID0gY2xpcFBhdGgsXG4gICAgICBjbGlwVHlwZSA9IF9jLnR5cGUsXG4gICAgICBjbGlwUG9zZXMgPSBfYy5wb3NlcyxcbiAgICAgIHNwbGl0dGVyID0gX2Muc3BsaXR0ZXI7XG4gIHZhciBwb3NlcyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MucG9zO1xuICB9KTtcblxuICBpZiAoY2xpcFR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgcG9zZXMuc3BsaWNlKGluZGV4LCAwLCBbZGlzdFgsIGRpc3RZXSk7XG4gIH0gZWxzZSBpZiAoY2xpcFR5cGUgPT09IFwiaW5zZXRcIikge1xuICAgIHZhciBob3Jpem9udGFsSW5kZXggPSBIT1JJWk9OVEFMX1JBRElVU19PUkRFUi5pbmRleE9mKGluZGV4KTtcbiAgICB2YXIgdmVydGljYWxJbmRleCA9IFZFUlRJQ0FMX1JBRElVU19PUkRFUi5pbmRleE9mKGluZGV4KTtcbiAgICB2YXIgbGVuZ3RoID0gY2xpcFBvc2VzLmxlbmd0aDtcbiAgICBhZGRSYWRpdXNQb3MoY2xpcFBvc2VzLCBwb3NlcywgOCwgaG9yaXpvbnRhbEluZGV4LCB2ZXJ0aWNhbEluZGV4LCBkaXN0WCwgZGlzdFksIHBvc2VzWzRdWzBdLCBwb3Nlc1s0XVsxXSwgcG9zZXNbMF1bMF0sIHBvc2VzWzBdWzFdKTtcblxuICAgIGlmIChsZW5ndGggPT09IGNsaXBQb3Nlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNsaXBTdHlsZXMgPSBnZXRDbGlwU3R5bGVzKG1vdmVhYmxlLCBjbGlwUGF0aCwgcG9zZXMpO1xuICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICBjbGlwRXZlbnRUeXBlOiBcImFkZGVkXCIsXG4gICAgY2xpcFR5cGU6IGNsaXBUeXBlLFxuICAgIHBvc2VzOiBwb3NlcyxcbiAgICBjbGlwU3R5bGVzOiBjbGlwU3R5bGVzLFxuICAgIGNsaXBTdHlsZTogY2xpcFR5cGUgKyBcIihcIiArIGNsaXBTdHlsZXMuam9pbihzcGxpdHRlcikgKyBcIilcIixcbiAgICBkaXN0WDogMCxcbiAgICBkaXN0WTogMFxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsaXBQYXRoKG1vdmVhYmxlLCBlKSB7XG4gIHZhciBfYSA9IGUuZGF0YXMsXG4gICAgICBjbGlwUGF0aCA9IF9hLmNsaXBQYXRoLFxuICAgICAgaW5kZXggPSBfYS5pbmRleDtcbiAgdmFyIF9iID0gY2xpcFBhdGgsXG4gICAgICBjbGlwVHlwZSA9IF9iLnR5cGUsXG4gICAgICBjbGlwUG9zZXMgPSBfYi5wb3NlcyxcbiAgICAgIHNwbGl0dGVyID0gX2Iuc3BsaXR0ZXI7XG4gIHZhciBwb3NlcyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MucG9zO1xuICB9KTtcbiAgdmFyIGxlbmd0aCA9IHBvc2VzLmxlbmd0aDtcblxuICBpZiAoY2xpcFR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgY2xpcFBvc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcG9zZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfSBlbHNlIGlmIChjbGlwVHlwZSA9PT0gXCJpbnNldFwiKSB7XG4gICAgaWYgKGluZGV4IDwgOCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbW92ZVJhZGl1c1BvcyhjbGlwUG9zZXMsIHBvc2VzLCBpbmRleCwgOCwgbGVuZ3RoKTtcblxuICAgIGlmIChsZW5ndGggPT09IGNsaXBQb3Nlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNsaXBTdHlsZXMgPSBnZXRDbGlwU3R5bGVzKG1vdmVhYmxlLCBjbGlwUGF0aCwgcG9zZXMpO1xuICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICBjbGlwRXZlbnRUeXBlOiBcInJlbW92ZWRcIixcbiAgICBjbGlwVHlwZTogY2xpcFR5cGUsXG4gICAgcG9zZXM6IHBvc2VzLFxuICAgIGNsaXBTdHlsZXM6IGNsaXBTdHlsZXMsXG4gICAgY2xpcFN0eWxlOiBjbGlwVHlwZSArIFwiKFwiICsgY2xpcFN0eWxlcy5qb2luKHNwbGl0dGVyKSArIFwiKVwiLFxuICAgIGRpc3RYOiAwLFxuICAgIGRpc3RZOiAwXG4gIH0pKTtcbn1cbi8qKlxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5DbGlwcGFibGVcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIHRvIGNsaXAgdGhlIHRhcmdldC5cbiAqL1xuXG5cbnZhciBDbGlwcGFibGUgPSB7XG4gIG5hbWU6IFwiY2xpcHBhYmxlXCIsXG4gIHByb3BzOiB7XG4gICAgY2xpcHBhYmxlOiBCb29sZWFuLFxuICAgIGRlZmF1bHRDbGlwUGF0aDogU3RyaW5nLFxuICAgIGN1c3RvbUNsaXBQYXRoOiBTdHJpbmcsXG4gICAgY2xpcFJlbGF0aXZlOiBCb29sZWFuLFxuICAgIGNsaXBBcmVhOiBCb29sZWFuLFxuICAgIGRyYWdXaXRoQ2xpcDogQm9vbGVhbixcbiAgICBjbGlwVGFyZ2V0Qm91bmRzOiBCb29sZWFuLFxuICAgIGNsaXBWZXJ0aWNhbEd1aWRlbGluZXM6IEFycmF5LFxuICAgIGNsaXBIb3Jpem9udGFsR3VpZGVsaW5lczogQXJyYXksXG4gICAgY2xpcFNuYXBUaHJlc2hvbGQ6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25DbGlwU3RhcnQ6IFwiY2xpcFN0YXJ0XCIsXG4gICAgb25DbGlwOiBcImNsaXBcIixcbiAgICBvbkNsaXBFbmQ6IFwiY2xpcEVuZFwiXG4gIH0sXG4gIGNzczogW1wiLmNvbnRyb2wuY2xpcC1jb250cm9sIHtcXG4gICAgYmFja2dyb3VuZDogIzZkNjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uY29udHJvbC5jbGlwLWNvbnRyb2wuY2xpcC1yYWRpdXMge1xcbiAgICBiYWNrZ3JvdW5kOiAjZDY2O1xcbn1cXG4ubGluZS5jbGlwLWxpbmUge1xcbiAgICBiYWNrZ3JvdW5kOiAjNmU2O1xcbiAgICBjdXJzb3I6IG1vdmU7XFxuICAgIHotaW5kZXg6IDE7XFxufVxcbi5jbGlwLWFyZWEge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG59XFxuLmNsaXAtZWxsaXBzZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgY3Vyc29yOiBtb3ZlO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjNmQ2O1xcbiAgICBib3JkZXI6IHZhcigtLXpvb21weCkgc29saWQgIzZkNjtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiAwcHggMHB4O1xcbn1cIiwgXCI6aG9zdCB7XFxuICAgIC0tYm91bmRzLWNvbG9yOiAjZDY2O1xcbn1cIiwgXCIuZ3VpZGVsaW5lIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgIHotaW5kZXg6IDI7XFxufVwiLCBcIi5saW5lLmd1aWRlbGluZS5ib3VuZHMge1xcbiAgICBiYWNrZ3JvdW5kOiAjZDY2O1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1ib3VuZHMtY29sb3IpO1xcbn1cIl0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICBjdXN0b21DbGlwUGF0aCA9IF9hLmN1c3RvbUNsaXBQYXRoLFxuICAgICAgICBkZWZhdWx0Q2xpcFBhdGggPSBfYS5kZWZhdWx0Q2xpcFBhdGgsXG4gICAgICAgIGNsaXBBcmVhID0gX2EuY2xpcEFyZWEsXG4gICAgICAgIHpvb20gPSBfYS56b29tO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB0YXJnZXQgPSBfYi50YXJnZXQsXG4gICAgICAgIHdpZHRoID0gX2Iud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9iLmhlaWdodCxcbiAgICAgICAgYWxsTWF0cml4ID0gX2IuYWxsTWF0cml4LFxuICAgICAgICBpczNkID0gX2IuaXMzZCxcbiAgICAgICAgbGVmdCA9IF9iLmxlZnQsXG4gICAgICAgIHRvcCA9IF9iLnRvcCxcbiAgICAgICAgcG9zMSA9IF9iLnBvczEsXG4gICAgICAgIHBvczIgPSBfYi5wb3MyLFxuICAgICAgICBwb3MzID0gX2IucG9zMyxcbiAgICAgICAgcG9zNCA9IF9iLnBvczQsXG4gICAgICAgIGNsaXBQYXRoU3RhdGUgPSBfYi5jbGlwUGF0aFN0YXRlLFxuICAgICAgICBzbmFwQm91bmRJbmZvcyA9IF9iLnNuYXBCb3VuZEluZm9zLFxuICAgICAgICByb3RhdGlvblJhZCA9IF9iLnJvdGF0aW9uO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgY2xpcFBhdGggPSBnZXRDbGlwUGF0aCh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIGRlZmF1bHRDbGlwUGF0aCB8fCBcImluc2V0XCIsIGNsaXBQYXRoU3RhdGUgfHwgY3VzdG9tQ2xpcFBhdGgpO1xuXG4gICAgaWYgKCFjbGlwUGF0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICAgIHZhciB0eXBlID0gY2xpcFBhdGgudHlwZTtcbiAgICB2YXIgY2xpcFBvc2VzID0gY2xpcFBhdGgucG9zZXM7XG4gICAgdmFyIHBvc2VzID0gY2xpcFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAvLyByZXR1cm4gW3gsIHldO1xuICAgICAgdmFyIGNhbGN1bGF0ZWRQb3MgPSBjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIHBvcy5wb3MsIG4pO1xuICAgICAgcmV0dXJuIFtjYWxjdWxhdGVkUG9zWzBdIC0gbGVmdCwgY2FsY3VsYXRlZFBvc1sxXSAtIHRvcF07XG4gICAgfSk7XG4gICAgdmFyIGNvbnRyb2xzID0gW107XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgdmFyIGlzUmVjdCA9IHR5cGUgPT09IFwicmVjdFwiO1xuICAgIHZhciBpc0luc2V0ID0gdHlwZSA9PT0gXCJpbnNldFwiO1xuICAgIHZhciBpc1BvbHlnb24gPSB0eXBlID09PSBcInBvbHlnb25cIjtcblxuICAgIGlmIChpc1JlY3QgfHwgaXNJbnNldCB8fCBpc1BvbHlnb24pIHtcbiAgICAgIHZhciBsaW5lUG9zZXNfMSA9IGlzSW5zZXQgPyBwb3Nlcy5zbGljZSgwLCA4KSA6IHBvc2VzO1xuICAgICAgbGluZXMgPSBsaW5lUG9zZXNfMS5tYXAoZnVuY3Rpb24gKHRvLCBpKSB7XG4gICAgICAgIHZhciBmcm9tID0gaSA9PT0gMCA/IGxpbmVQb3Nlc18xW2xpbmVQb3Nlc18xLmxlbmd0aCAtIDFdIDogbGluZVBvc2VzXzFbaSAtIDFdO1xuICAgICAgICB2YXIgcmFkID0gZ2V0UmFkKGZyb20sIHRvKTtcbiAgICAgICAgdmFyIGRpc3QgPSBnZXREaWFnb25hbFNpemUoZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAga2V5OiBcImNsaXBMaW5lXCIgKyBpLFxuICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiLCBcImNsaXAtbGluZVwiLCBcInNuYXAtY29udHJvbFwiKSxcbiAgICAgICAgICBcImRhdGEtY2xpcC1pbmRleFwiOiBpLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogZGlzdCArIFwicHhcIixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBmcm9tWzBdICsgXCJweCwgXCIgKyBmcm9tWzFdICsgXCJweCkgcm90YXRlKFwiICsgcmFkICsgXCJyYWQpIHNjYWxlWShcIiArIHpvb20gKyBcIilcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb250cm9scyA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGtleTogXCJjbGlwQ29udHJvbFwiICsgaSxcbiAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJjb250cm9sXCIsIFwiY2xpcC1jb250cm9sXCIsIFwic25hcC1jb250cm9sXCIpLFxuICAgICAgICBcImRhdGEtY2xpcC1pbmRleFwiOiBpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBwb3NbMF0gKyBcInB4LCBcIiArIHBvc1sxXSArIFwicHgpIHJvdGF0ZShcIiArIHJvdGF0aW9uUmFkICsgXCJyYWQpIHNjYWxlKFwiICsgem9vbSArIFwiKVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzSW5zZXQpIHtcbiAgICAgIGNvbnRyb2xzLnB1c2guYXBwbHkoY29udHJvbHMsIHBvc2VzLnNsaWNlKDgpLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBrZXk6IFwiY2xpcFJhZGl1c0NvbnRyb2xcIiArIGksXG4gICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJjb250cm9sXCIsIFwiY2xpcC1jb250cm9sXCIsIFwiY2xpcC1yYWRpdXNcIiwgXCJzbmFwLWNvbnRyb2xcIiksXG4gICAgICAgICAgXCJkYXRhLWNsaXAtaW5kZXhcIjogOCArIGksXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBwb3NbMF0gKyBcInB4LCBcIiArIHBvc1sxXSArIFwicHgpIHJvdGF0ZShcIiArIHJvdGF0aW9uUmFkICsgXCJyYWQpIHNjYWxlKFwiICsgem9vbSArIFwiKVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gXCJjaXJjbGVcIiB8fCB0eXBlID09PSBcImVsbGlwc2VcIikge1xuICAgICAgdmFyIGNsaXBMZWZ0ID0gY2xpcFBhdGgubGVmdCxcbiAgICAgICAgICBjbGlwVG9wID0gY2xpcFBhdGgudG9wLFxuICAgICAgICAgIHJhZGl1c1ggPSBjbGlwUGF0aC5yYWRpdXNYLFxuICAgICAgICAgIHJhZGl1c1kgPSBjbGlwUGF0aC5yYWRpdXNZO1xuXG4gICAgICB2YXIgX2MgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIFtjbGlwTGVmdCwgY2xpcFRvcF0sIG4pLCBjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIFswLCAwXSwgbikpLFxuICAgICAgICAgIGRpc3RMZWZ0ID0gX2NbMF0sXG4gICAgICAgICAgZGlzdFRvcCA9IF9jWzFdO1xuXG4gICAgICB2YXIgZWxsaXBzZUNsaXBQYXRoID0gXCJub25lXCI7XG5cbiAgICAgIGlmICghY2xpcEFyZWEpIHtcbiAgICAgICAgdmFyIHBpZWNlID0gTWF0aC5tYXgoMTAsIHJhZGl1c1ggLyA1LCByYWRpdXNZIC8gNSk7XG4gICAgICAgIHZhciBhcmVhUG9zZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwaWVjZTsgKytpKSB7XG4gICAgICAgICAgdmFyIHJhZCA9IE1hdGguUEkgKiAyIC8gcGllY2UgKiBpO1xuICAgICAgICAgIGFyZWFQb3Nlcy5wdXNoKFtyYWRpdXNYICsgKHJhZGl1c1ggLSB6b29tKSAqIE1hdGguY29zKHJhZCksIHJhZGl1c1kgKyAocmFkaXVzWSAtIHpvb20pICogTWF0aC5zaW4ocmFkKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJlYVBvc2VzLnB1c2goW3JhZGl1c1gsIC0yXSk7XG4gICAgICAgIGFyZWFQb3Nlcy5wdXNoKFstMiwgLTJdKTtcbiAgICAgICAgYXJlYVBvc2VzLnB1c2goWy0yLCByYWRpdXNZICogMiArIDJdKTtcbiAgICAgICAgYXJlYVBvc2VzLnB1c2goW3JhZGl1c1ggKiAyICsgMiwgcmFkaXVzWSAqIDIgKyAyXSk7XG4gICAgICAgIGFyZWFQb3Nlcy5wdXNoKFtyYWRpdXNYICogMiArIDIsIC0yXSk7XG4gICAgICAgIGFyZWFQb3Nlcy5wdXNoKFtyYWRpdXNYLCAtMl0pO1xuICAgICAgICBlbGxpcHNlQ2xpcFBhdGggPSBcInBvbHlnb24oXCIgKyBhcmVhUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICByZXR1cm4gcG9zWzBdICsgXCJweCBcIiArIHBvc1sxXSArIFwicHhcIjtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICB9XG5cbiAgICAgIGNvbnRyb2xzLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGtleTogXCJjbGlwRWxsaXBzZVwiLFxuICAgICAgICBjbGFzc05hbWU6IHByZWZpeChcImNsaXAtZWxsaXBzZVwiLCBcInNuYXAtY29udHJvbFwiKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB3aWR0aDogcmFkaXVzWCAqIDIgKyBcInB4XCIsXG4gICAgICAgICAgaGVpZ2h0OiByYWRpdXNZICogMiArIFwicHhcIixcbiAgICAgICAgICBjbGlwUGF0aDogZWxsaXBzZUNsaXBQYXRoLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyAoLWxlZnQgKyBkaXN0TGVmdCkgKyBcInB4LCBcIiArICgtdG9wICsgZGlzdFRvcCkgKyBcInB4KSBcIiArIG1ha2VNYXRyaXhDU1MoYWxsTWF0cml4KVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKGNsaXBBcmVhKSB7XG4gICAgICB2YXIgX2QgPSBnZXRSZWN0KF9fc3ByZWFkQXJyYXkoW3BvczEsIHBvczIsIHBvczMsIHBvczRdLCBwb3NlcykpLFxuICAgICAgICAgIGFsbFdpZHRoID0gX2Qud2lkdGgsXG4gICAgICAgICAgYWxsSGVpZ2h0ID0gX2QuaGVpZ2h0LFxuICAgICAgICAgIGFsbExlZnRfMSA9IF9kLmxlZnQsXG4gICAgICAgICAgYWxsVG9wXzEgPSBfZC50b3A7XG5cbiAgICAgIGlmIChpc1BvbHlnb24gfHwgaXNSZWN0IHx8IGlzSW5zZXQpIHtcbiAgICAgICAgdmFyIGFyZWFQb3NlcyA9IGlzSW5zZXQgPyBwb3Nlcy5zbGljZSgwLCA4KSA6IHBvc2VzO1xuICAgICAgICBjb250cm9scy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgIGtleTogXCJjbGlwQXJlYVwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY2xpcC1hcmVhXCIsIFwic25hcC1jb250cm9sXCIpLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogYWxsV2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgICBoZWlnaHQ6IGFsbEhlaWdodCArIFwicHhcIixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBhbGxMZWZ0XzEgKyBcInB4LCBcIiArIGFsbFRvcF8xICsgXCJweClcIixcbiAgICAgICAgICAgIGNsaXBQYXRoOiBcInBvbHlnb24oXCIgKyBhcmVhUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBvc1swXSAtIGFsbExlZnRfMSArIFwicHggXCIgKyAocG9zWzFdIC0gYWxsVG9wXzEpICsgXCJweFwiO1xuICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpICsgXCIpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc25hcEJvdW5kSW5mb3MpIHtcbiAgICAgIFtcInZlcnRpY2FsXCIsIFwiaG9yaXpvbnRhbFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb25UeXBlKSB7XG4gICAgICAgIHZhciBpbmZvID0gc25hcEJvdW5kSW5mb3NbZGlyZWN0aW9uVHlwZV07XG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSBkaXJlY3Rpb25UeXBlID09PSBcImhvcml6b250YWxcIjtcblxuICAgICAgICBpZiAoaW5mby5pc1NuYXApIHtcbiAgICAgICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCBpbmZvLnNuYXAucG9zSW5mb3MubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICAgICAgICAgIHZhciBzbmFwUG9zMSA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgaXNIb3Jpem9udGFsID8gWzAsIHBvc10gOiBbcG9zLCAwXSwgbiksIFtsZWZ0LCB0b3BdKTtcbiAgICAgICAgICAgIHZhciBzbmFwUG9zMiA9IG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgaXNIb3Jpem9udGFsID8gW3dpZHRoLCBwb3NdIDogW3BvcywgaGVpZ2h0XSwgbiksIFtsZWZ0LCB0b3BdKTtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJMaW5lKFJlYWN0LCBcIlwiLCBzbmFwUG9zMSwgc25hcFBvczIsIHpvb20sIFwiY2xpcFwiICsgZGlyZWN0aW9uVHlwZSArIFwic25hcFwiICsgaSwgXCJndWlkZWxpbmVcIik7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uaXNCb3VuZCkge1xuICAgICAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIGluZm8uYm91bmRzLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBfYS5wb3M7XG4gICAgICAgICAgICB2YXIgc25hcFBvczEgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIGlzSG9yaXpvbnRhbCA/IFswLCBwb3NdIDogW3BvcywgMF0sIG4pLCBbbGVmdCwgdG9wXSk7XG4gICAgICAgICAgICB2YXIgc25hcFBvczIgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIGlzSG9yaXpvbnRhbCA/IFt3aWR0aCwgcG9zXSA6IFtwb3MsIGhlaWdodF0sIG4pLCBbbGVmdCwgdG9wXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyTGluZShSZWFjdCwgXCJcIiwgc25hcFBvczEsIHNuYXBQb3MyLCB6b29tLCBcImNsaXBcIiArIGRpcmVjdGlvblR5cGUgKyBcImJvdW5kc1wiICsgaSwgXCJndWlkZWxpbmVcIiwgXCJib3VuZHNcIiwgXCJib2xkXCIpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgY29udHJvbHMpLCBsaW5lcyk7XG4gIH0sXG4gIGRyYWdDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gZS5pbnB1dEV2ZW50ICYmIChlLmlucHV0RXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpLmluZGV4T2YoXCJjbGlwXCIpID4gLTE7XG4gIH0sXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XG4gICAgdmFyIF9hID0gcHJvcHMuZHJhZ1dpdGhDbGlwLFxuICAgICAgICBkcmFnV2l0aENsaXAgPSBfYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9hO1xuXG4gICAgaWYgKGRyYWdXaXRoQ2xpcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdDb250cm9sRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICAgIGRlZmF1bHRDbGlwUGF0aCA9IF9hLmRlZmF1bHRDbGlwUGF0aCxcbiAgICAgICAgY3VzdG9tQ2xpcFBhdGggPSBfYS5jdXN0b21DbGlwUGF0aDtcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICB3aWR0aCA9IHN0YXRlLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgdmFyIGlucHV0VGFyZ2V0ID0gZS5pbnB1dEV2ZW50ID8gZS5pbnB1dEV2ZW50LnRhcmdldCA6IG51bGw7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGlucHV0VGFyZ2V0ICYmIGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCI7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgICB2YXIgY2xpcFBhdGggPSBnZXRDbGlwUGF0aCh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIGRlZmF1bHRDbGlwUGF0aCB8fCBcImluc2V0XCIsIGN1c3RvbUNsaXBQYXRoKTtcblxuICAgIGlmICghY2xpcFBhdGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2xpcFRleHQgPSBjbGlwUGF0aC5jbGlwVGV4dCxcbiAgICAgICAgdHlwZSA9IGNsaXBQYXRoLnR5cGUsXG4gICAgICAgIHBvc2VzID0gY2xpcFBhdGgucG9zZXM7XG4gICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaXBTdGFydFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBjbGlwVHlwZTogdHlwZSxcbiAgICAgIGNsaXBTdHlsZTogY2xpcFRleHQsXG4gICAgICBwb3NlczogcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcy5wb3M7XG4gICAgICB9KVxuICAgIH0pKTtcblxuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICBkYXRhcy5pc0NsaXBTdGFydCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRhdGFzLmlzQ29udHJvbCA9IGNsYXNzTmFtZSAmJiBjbGFzc05hbWUuaW5kZXhPZihcImNsaXAtY29udHJvbFwiKSA+IC0xO1xuICAgIGRhdGFzLmlzTGluZSA9IGNsYXNzTmFtZS5pbmRleE9mKFwiY2xpcC1saW5lXCIpID4gLTE7XG4gICAgZGF0YXMuaXNBcmVhID0gY2xhc3NOYW1lLmluZGV4T2YoXCJjbGlwLWFyZWFcIikgPiAtMSB8fCBjbGFzc05hbWUuaW5kZXhPZihcImNsaXAtZWxsaXBzZVwiKSA+IC0xO1xuICAgIGRhdGFzLmluZGV4ID0gaW5wdXRUYXJnZXQgPyBwYXJzZUludChpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNsaXAtaW5kZXhcIiksIDEwKSA6IC0xO1xuICAgIGRhdGFzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgZGF0YXMuaXNDbGlwU3RhcnQgPSB0cnVlO1xuICAgIHN0YXRlLmNsaXBQYXRoU3RhdGUgPSBjbGlwVGV4dDtcbiAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcztcblxuICAgIGlmICghZGF0YXMuaXNDbGlwU3RhcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2IgPSBkYXRhcyxcbiAgICAgICAgaXNDb250cm9sID0gX2IuaXNDb250cm9sLFxuICAgICAgICBpc0xpbmUgPSBfYi5pc0xpbmUsXG4gICAgICAgIGlzQXJlYSA9IF9iLmlzQXJlYSxcbiAgICAgICAgaW5kZXggPSBfYi5pbmRleCxcbiAgICAgICAgY2xpcFBhdGggPSBfYi5jbGlwUGF0aDtcblxuICAgIGlmICghY2xpcFBhdGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2MgPSBnZXREcmFnRGlzdChlKSxcbiAgICAgICAgZGlzdFggPSBfY1swXSxcbiAgICAgICAgZGlzdFkgPSBfY1sxXTtcblxuICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciB3aWR0aCA9IHN0YXRlLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgdmFyIGlzRHJhZ1dpdGhUYXJnZXQgPSAhaXNBcmVhICYmICFpc0NvbnRyb2wgJiYgIWlzTGluZTtcbiAgICB2YXIgY2xpcFR5cGUgPSBjbGlwUGF0aC50eXBlLFxuICAgICAgICBjbGlwUG9zZXMgPSBjbGlwUGF0aC5wb3NlcyxcbiAgICAgICAgc3BsaXR0ZXIgPSBjbGlwUGF0aC5zcGxpdHRlcjtcbiAgICB2YXIgcG9zZXMgPSBjbGlwUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3MucG9zO1xuICAgIH0pO1xuXG4gICAgaWYgKGlzRHJhZ1dpdGhUYXJnZXQpIHtcbiAgICAgIGRpc3RYID0gLWRpc3RYO1xuICAgICAgZGlzdFkgPSAtZGlzdFk7XG4gICAgfVxuXG4gICAgdmFyIGlzQWxsID0gIWlzQ29udHJvbCB8fCBjbGlwUG9zZXNbaW5kZXhdLmRpcmVjdGlvbiA9PT0gXCJuZXN3XCI7XG4gICAgdmFyIGlzUmVjdCA9IGNsaXBUeXBlID09PSBcImluc2V0XCIgfHwgY2xpcFR5cGUgPT09IFwicmVjdFwiO1xuICAgIHZhciBkaXN0cyA9IGNsaXBQb3Nlcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9KTtcblxuICAgIGlmIChpc0NvbnRyb2wgJiYgIWlzQWxsKSB7XG4gICAgICB2YXIgX2QgPSBjbGlwUG9zZXNbaW5kZXhdLFxuICAgICAgICAgIGhvcml6b250YWwgPSBfZC5ob3Jpem9udGFsLFxuICAgICAgICAgIHZlcnRpY2FsID0gX2QudmVydGljYWw7XG4gICAgICB2YXIgZGlzdCA9IFtkaXN0WCAqIE1hdGguYWJzKGhvcml6b250YWwpLCBkaXN0WSAqIE1hdGguYWJzKHZlcnRpY2FsKV07XG4gICAgICBkaXN0cyA9IG1vdmVDb250cm9sUG9zKGNsaXBQb3NlcywgaW5kZXgsIGRpc3QsIGlzUmVjdCk7XG4gICAgfSBlbHNlIGlmIChpc0FsbCkge1xuICAgICAgZGlzdHMgPSBwb3Nlcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW2Rpc3RYLCBkaXN0WV07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFBvc2VzID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcbiAgICAgIHJldHVybiBwbHVzKHBvcywgZGlzdHNbaV0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGd1aWRlUG9zZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBuZXh0UG9zZXMpO1xuXG4gICAgc3RhdGUuc25hcEJvdW5kSW5mb3MgPSBudWxsO1xuICAgIHZhciBpc0NpcmNsZSA9IGNsaXBQYXRoLnR5cGUgPT09IFwiY2lyY2xlXCI7XG4gICAgdmFyIGlzRWxsaXBzZSA9IGNsaXBQYXRoLnR5cGUgPT09IFwiZWxsaXBzZVwiO1xuXG4gICAgaWYgKGlzQ2lyY2xlIHx8IGlzRWxsaXBzZSkge1xuICAgICAgdmFyIGd1aWRlUmVjdCA9IGdldFJlY3QobmV4dFBvc2VzKTtcbiAgICAgIHZhciByeSA9IE1hdGguYWJzKGd1aWRlUmVjdC5ib3R0b20gLSBndWlkZVJlY3QudG9wKTtcbiAgICAgIHZhciByeCA9IE1hdGguYWJzKGlzRWxsaXBzZSA/IGd1aWRlUmVjdC5yaWdodCAtIGd1aWRlUmVjdC5sZWZ0IDogcnkpO1xuICAgICAgdmFyIGJvdHRvbSA9IG5leHRQb3Nlc1swXVsxXSArIHJ5O1xuICAgICAgdmFyIGxlZnQgPSBuZXh0UG9zZXNbMF1bMF0gLSByeDtcbiAgICAgIHZhciByaWdodCA9IG5leHRQb3Nlc1swXVswXSArIHJ4OyAvLyByaWdodFxuXG4gICAgICBpZiAoaXNDaXJjbGUpIHtcbiAgICAgICAgZ3VpZGVQb3Nlcy5wdXNoKFtyaWdodCwgZ3VpZGVSZWN0LmJvdHRvbV0pO1xuICAgICAgICBkaXN0cy5wdXNoKFsxLCAwXSk7XG4gICAgICB9IC8vIGJvdHRvbVxuXG5cbiAgICAgIGd1aWRlUG9zZXMucHVzaChbZ3VpZGVSZWN0LmxlZnQsIGJvdHRvbV0pO1xuICAgICAgZGlzdHMucHVzaChbMCwgMV0pOyAvLyBsZWZ0XG5cbiAgICAgIGd1aWRlUG9zZXMucHVzaChbbGVmdCwgZ3VpZGVSZWN0LmJvdHRvbV0pO1xuICAgICAgZGlzdHMucHVzaChbMSwgMF0pO1xuICAgIH1cblxuICAgIHZhciBndWlkZWxpbmVzID0gZ2V0RGVmYXVsdEd1aWRlbGluZXMoKHByb3BzLmNsaXBIb3Jpem9udGFsR3VpZGVsaW5lcyB8fCBbXSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gY29udmVydFVuaXRTaXplKFwiXCIgKyB2LCBoZWlnaHQpO1xuICAgIH0pLCAocHJvcHMuY2xpcFZlcnRpY2FsR3VpZGVsaW5lcyB8fCBbXSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gY29udmVydFVuaXRTaXplKFwiXCIgKyB2LCB3aWR0aCk7XG4gICAgfSksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBndWlkZVhQb3NlcyA9IFtdO1xuICAgIHZhciBndWlkZVlQb3NlcyA9IFtdO1xuXG4gICAgaWYgKGlzQ2lyY2xlIHx8IGlzRWxsaXBzZSkge1xuICAgICAgZ3VpZGVYUG9zZXMgPSBbZ3VpZGVQb3Nlc1s0XVswXSwgZ3VpZGVQb3Nlc1syXVswXV07XG4gICAgICBndWlkZVlQb3NlcyA9IFtndWlkZVBvc2VzWzFdWzFdLCBndWlkZVBvc2VzWzNdWzFdXTtcbiAgICB9IGVsc2UgaWYgKGlzUmVjdCkge1xuICAgICAgdmFyIHJlY3RQb3NlcyA9IFtndWlkZVBvc2VzWzBdLCBndWlkZVBvc2VzWzJdLCBndWlkZVBvc2VzWzRdLCBndWlkZVBvc2VzWzZdXTtcbiAgICAgIHZhciByZWN0RGlzdHNfMSA9IFtkaXN0c1swXSwgZGlzdHNbMl0sIGRpc3RzWzRdLCBkaXN0c1s2XV07XG4gICAgICBndWlkZVhQb3NlcyA9IHJlY3RQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgcmV0dXJuIHJlY3REaXN0c18xW2ldWzBdO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvc1swXTtcbiAgICAgIH0pO1xuICAgICAgZ3VpZGVZUG9zZXMgPSByZWN0UG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIHJldHVybiByZWN0RGlzdHNfMVtpXVsxXTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3NbMV07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3VpZGVYUG9zZXMgPSBndWlkZVBvc2VzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICByZXR1cm4gZGlzdHNbaV1bMF07XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzBdO1xuICAgICAgfSk7XG4gICAgICBndWlkZVlQb3NlcyA9IGd1aWRlUG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIHJldHVybiBkaXN0c1tpXVsxXTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3NbMV07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYm91bmREZWx0YSA9IFswLCAwXTtcblxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhciBfZSA9IGNoZWNrU25hcEJvdW5kcyhndWlkZWxpbmVzLCBwcm9wcy5jbGlwVGFyZ2V0Qm91bmRzICYmIHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogd2lkdGgsXG4gICAgICAgIGJvdHRvbTogaGVpZ2h0XG4gICAgICB9LCBndWlkZVhQb3NlcywgZ3VpZGVZUG9zZXMsIDUpLFxuICAgICAgICAgIGhvcml6b250YWxTbmFwSW5mbyA9IF9lLmhvcml6b250YWwsXG4gICAgICAgICAgdmVydGljYWxTbmFwSW5mbyA9IF9lLnZlcnRpY2FsO1xuXG4gICAgICB2YXIgc25hcE9mZnNldFkgPSBob3Jpem9udGFsU25hcEluZm8ub2Zmc2V0O1xuICAgICAgdmFyIHNuYXBPZmZzZXRYID0gdmVydGljYWxTbmFwSW5mby5vZmZzZXQ7XG5cbiAgICAgIGlmIChob3Jpem9udGFsU25hcEluZm8uaXNCb3VuZCkge1xuICAgICAgICBib3VuZERlbHRhWzFdICs9IHNuYXBPZmZzZXRZO1xuICAgICAgfVxuXG4gICAgICBpZiAodmVydGljYWxTbmFwSW5mby5pc0JvdW5kKSB7XG4gICAgICAgIGJvdW5kRGVsdGFbMF0gKz0gc25hcE9mZnNldFg7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaXNFbGxpcHNlIHx8IGlzQ2lyY2xlKSAmJiBkaXN0c1swXVswXSA9PT0gMCAmJiBkaXN0c1swXVsxXSA9PT0gMCkge1xuICAgICAgICB2YXIgZ3VpZGVSZWN0ID0gZ2V0UmVjdChuZXh0UG9zZXMpO1xuICAgICAgICB2YXIgY3kgPSBndWlkZVJlY3QuYm90dG9tIC0gZ3VpZGVSZWN0LnRvcDtcbiAgICAgICAgdmFyIGN4ID0gaXNFbGxpcHNlID8gZ3VpZGVSZWN0LnJpZ2h0IC0gZ3VpZGVSZWN0LmxlZnQgOiBjeTtcbiAgICAgICAgdmFyIGRpc3RTbmFwWCA9IHZlcnRpY2FsU25hcEluZm8uaXNCb3VuZCA/IE1hdGguYWJzKHNuYXBPZmZzZXRYKSA6IHZlcnRpY2FsU25hcEluZm8uc25hcEluZGV4ID09PSAwID8gLXNuYXBPZmZzZXRYIDogc25hcE9mZnNldFg7XG4gICAgICAgIHZhciBkaXN0U25hcFkgPSBob3Jpem9udGFsU25hcEluZm8uaXNCb3VuZCA/IE1hdGguYWJzKHNuYXBPZmZzZXRZKSA6IGhvcml6b250YWxTbmFwSW5mby5zbmFwSW5kZXggPT09IDAgPyAtc25hcE9mZnNldFkgOiBzbmFwT2Zmc2V0WTtcbiAgICAgICAgY3ggLT0gZGlzdFNuYXBYO1xuICAgICAgICBjeSAtPSBkaXN0U25hcFk7XG5cbiAgICAgICAgaWYgKGlzQ2lyY2xlKSB7XG4gICAgICAgICAgY3kgPSBjaGVja1NuYXBCb3VuZFByaW9yaXR5KHZlcnRpY2FsU25hcEluZm8sIGhvcml6b250YWxTbmFwSW5mbykgPiAwID8gY3kgOiBjeDtcbiAgICAgICAgICBjeCA9IGN5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IGd1aWRlUG9zZXNbMF07XG4gICAgICAgIGd1aWRlUG9zZXNbMV1bMV0gPSBjZW50ZXJbMV0gLSBjeTtcbiAgICAgICAgZ3VpZGVQb3Nlc1syXVswXSA9IGNlbnRlclswXSArIGN4O1xuICAgICAgICBndWlkZVBvc2VzWzNdWzFdID0gY2VudGVyWzFdICsgY3k7XG4gICAgICAgIGd1aWRlUG9zZXNbNF1bMF0gPSBjZW50ZXJbMF0gLSBjeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGd1aWRlUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zLCBqKSB7XG4gICAgICAgICAgdmFyIGRpc3QgPSBkaXN0c1tqXTtcblxuICAgICAgICAgIGlmIChkaXN0WzBdKSB7XG4gICAgICAgICAgICBwb3NbMF0gLT0gc25hcE9mZnNldFg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpc3RbMV0pIHtcbiAgICAgICAgICAgIHBvc1sxXSAtPSBzbmFwT2Zmc2V0WTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKCk7XG5cbiAgICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2xpcFN0eWxlcyA9IGdldENsaXBTdHlsZXMobW92ZWFibGUsIGNsaXBQYXRoLCBuZXh0UG9zZXMpO1xuICAgIHZhciBjbGlwU3R5bGUgPSBjbGlwVHlwZSArIFwiKFwiICsgbmV4dENsaXBTdHlsZXMuam9pbihzcGxpdHRlcikgKyBcIilcIjtcbiAgICBzdGF0ZS5jbGlwUGF0aFN0YXRlID0gY2xpcFN0eWxlO1xuXG4gICAgaWYgKGlzQ2lyY2xlIHx8IGlzRWxsaXBzZSkge1xuICAgICAgZ3VpZGVYUG9zZXMgPSBbZ3VpZGVQb3Nlc1s0XVswXSwgZ3VpZGVQb3Nlc1syXVswXV07XG4gICAgICBndWlkZVlQb3NlcyA9IFtndWlkZVBvc2VzWzFdWzFdLCBndWlkZVBvc2VzWzNdWzFdXTtcbiAgICB9IGVsc2UgaWYgKGlzUmVjdCkge1xuICAgICAgdmFyIHJlY3RQb3NlcyA9IFtndWlkZVBvc2VzWzBdLCBndWlkZVBvc2VzWzJdLCBndWlkZVBvc2VzWzRdLCBndWlkZVBvc2VzWzZdXTtcbiAgICAgIGd1aWRlWFBvc2VzID0gcmVjdFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3NbMF07XG4gICAgICB9KTtcbiAgICAgIGd1aWRlWVBvc2VzID0gcmVjdFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3NbMV07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3VpZGVYUG9zZXMgPSBndWlkZVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3NbMF07XG4gICAgICB9KTtcbiAgICAgIGd1aWRlWVBvc2VzID0gZ3VpZGVQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zWzFdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGUuc25hcEJvdW5kSW5mb3MgPSBjaGVja1NuYXBCb3VuZHMoZ3VpZGVsaW5lcywgcHJvcHMuY2xpcFRhcmdldEJvdW5kcyAmJiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IHdpZHRoLFxuICAgICAgYm90dG9tOiBoZWlnaHRcbiAgICB9LCBndWlkZVhQb3NlcywgZ3VpZGVZUG9zZXMsIDEpO1xuXG4gICAgaWYgKG9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlKSB7XG4gICAgICB2YXIgaXMzZCA9IHN0YXRlLmlzM2QsXG4gICAgICAgICAgYWxsTWF0cml4ID0gc3RhdGUuYWxsTWF0cml4O1xuICAgICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gICAgICBfYSA9IG11bHRpcGx5KGFsbE1hdHJpeCwgW2JvdW5kRGVsdGFbMF0sIGJvdW5kRGVsdGFbMV0sIDAsIDBdLCBuKSwgYm91bmREZWx0YVswXSA9IF9hWzBdLCBib3VuZERlbHRhWzFdID0gX2FbMV07XG4gICAgICBvcmlnaW5hbERhdGFzLmRyYWdnYWJsZS5kZWx0YU9mZnNldCA9IGJvdW5kRGVsdGE7XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBjbGlwRXZlbnRUeXBlOiBcImNoYW5nZWRcIixcbiAgICAgIGNsaXBUeXBlOiBjbGlwVHlwZSxcbiAgICAgIHBvc2VzOiBuZXh0UG9zZXMsXG4gICAgICBjbGlwU3R5bGU6IGNsaXBTdHlsZSxcbiAgICAgIGNsaXBTdHlsZXM6IG5leHRDbGlwU3R5bGVzLFxuICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgZGlzdFk6IGRpc3RZXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLFxuICAgICAgICBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzRG91YmxlID0gZS5pc0RvdWJsZTtcbiAgICB2YXIgaXNMaW5lID0gZGF0YXMuaXNMaW5lLFxuICAgICAgICBpc0NsaXBTdGFydCA9IGRhdGFzLmlzQ2xpcFN0YXJ0LFxuICAgICAgICBpc0NvbnRyb2wgPSBkYXRhcy5pc0NvbnRyb2w7XG5cbiAgICBpZiAoIWlzQ2xpcFN0YXJ0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcEVuZFwiLCBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xuXG4gICAgaWYgKGlzRG91YmxlKSB7XG4gICAgICBpZiAoaXNDb250cm9sKSB7XG4gICAgICAgIHJlbW92ZUNsaXBQYXRoKG1vdmVhYmxlLCBlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMaW5lKSB7XG4gICAgICAgIC8vIGFkZFxuICAgICAgICBhZGRDbGlwUGF0aChtb3ZlYWJsZSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRG91YmxlIHx8IGlzRHJhZztcbiAgfSxcbiAgdW5zZXQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgIG1vdmVhYmxlLnN0YXRlLmNsaXBQYXRoU3RhdGUgPSBcIlwiO1xuICAgIG1vdmVhYmxlLnN0YXRlLnNuYXBCb3VuZEluZm9zID0gbnVsbDtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciB0byBjbGlwIHRoZSB0YXJnZXQuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwcGFibGVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9XG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqICBJZiBjbGlwcGF0aCBpcyBub3Qgc2V0LCB0aGUgZGVmYXVsdCB2YWx1ZSBjYW4gYmUgc2V0LiAoZGVmYXVsdENsaXBQYXRoIDwgc3R5bGUgPCBjdXN0b21DbGlwUGF0aCA8IGRyYWdnaW5nIGNsaXBQYXRoKVxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2RlZmF1bHRDbGlwUGF0aFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogJSBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhYnNvbHV0ZSBweCAoYHJlY3RgIG5vdCBwb3NzaWJsZSkgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBSZWxhdGl2ZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogWW91IGNhbiBmb3JjZSB0aGUgY3VzdG9tIGNsaXBQYXRoLiAoZGVmYXVsdENsaXBQYXRoIDwgc3R5bGUgPCBjdXN0b21DbGlwUGF0aCA8IGRyYWdnaW5nIGNsaXBQYXRoKVxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2N1c3RvbUNsaXBQYXRoXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfVxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWdnaW5nIHRoZSB0YXJnZXQsIHRoZSBjbGlwIGFsc28gbW92ZXMuIChkZWZhdWx0OiB0cnVlKVxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2RyYWdXaXRoQ2xpcFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogWW91IGNhbiBkcmFnIHRoZSBjbGlwIGJ5IHNldHRpbmcgY2xpcEFyZWEuIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwQXJlYVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuKiBXaGV0aGVyIHRoZSBjbGlwIGlzIGJvdW5kIHRvIHRoZSB0YXJnZXQuIChkZWZhdWx0OiBmYWxzZSlcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBUYXJnZXRCb3VuZHNcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICBjbGlwcGFibGU6IHRydWUsXG4qICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiogICAgIGNsaXBUYXJnZXRCb3VuZHM6IHRydWUsXG4qIH0pO1xuKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiogICAgIGNvbnNvbGUubG9nKGUpO1xuKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4qICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XG4qICAgICB9IGVsc2Uge1xuKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4qICAgICB9XG4qIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiogICAgIGNvbnNvbGUubG9nKGUpO1xuKiB9KTtcbiovXG5cbi8qKlxuKiBBZGQgY2xpcCBndWlkZWxpbmVzIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uIChkZWZhdWx0OiBbXSlcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBWZXJ0aWNhbEd1aWRlbGluZXNcbiogQGV4YW1wbGVcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuKlxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4qICAgICBjbGlwcGFibGU6IHRydWUsXG4qICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcbiogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiogICAgIGNsaXBBcmVhOiBmYWxzZSxcbiogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiogICAgIGNsaXBWZXJ0aWNhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXG4qICAgICBjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXG4qICAgICBjbGlwU25hcFRocmVzaG9sZDogNSxcbiogfSk7XG4qL1xuXG4vKipcbiogQWRkIGNsaXAgZ3VpZGVsaW5lcyBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24uIChkZWZhdWx0OiBbXSlcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBIb3Jpem9udGFsR3VpZGVsaW5lc1xuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIGNsaXBwYWJsZTogdHJ1ZSxcbiogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4qICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxuKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuKiAgICAgY2xpcFZlcnRpY2FsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcbiogICAgIGNsaXBIb3Jpem9udGFsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcbiogICAgIGNsaXBTbmFwVGhyZXNob2xkOiA1LFxuKiB9KTtcbiovXG5cbi8qKlxuKiBpc3RhbmNlIHZhbHVlIHRoYXQgY2FuIHNuYXAgdG8gY2xpcCBndWlkZWxpbmVzLiAoZGVmYXVsdDogNSlcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBTbmFwVGhyZXNob2xkXG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4qICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcbiogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4qICAgICBjbGlwQXJlYTogZmFsc2UsXG4qICAgICBkcmFnV2l0aENsaXA6IHRydWUsXG4qICAgICBjbGlwVmVydGljYWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxuKiAgICAgY2xpcEhvcml6b250YWxHdWlkZWxpbmVzOiBbMCwgMTAwLCAyMDBdLFxuKiAgICAgY2xpcFNuYXBUaHJlc2hvbGQ6IDUsXG4qIH0pO1xuKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgc3RhcnQgdGhlIGNsaXAgYXJlYSBvciBjb250cm9scywgdGhlIGBjbGlwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5DbGlwcGFibGVcbiAqIEBldmVudCBjbGlwU3RhcnRcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgY2xpcFN0YXJ0YCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH1cbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogV2hlbiBkcmFnIHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgY2xpcGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkNsaXBwYWJsZVxuICogQGV2ZW50IGNsaXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaXBgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfVxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgZW5kIHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgY2xpcEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkNsaXBwYWJsZVxuICogQGV2ZW50IGNsaXBFbmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaXBFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XG4gKiAgICAgfVxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIE9yaWdpbkRyYWdnYWJsZVxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciB0byBkcmFnIG9yaWdpbiAoZGVmYXVsdDogZmFsc2UpXG4gKi9cblxudmFyIE9yaWdpbkRyYWdnYWJsZSA9IHtcbiAgbmFtZTogXCJvcmlnaW5EcmFnZ2FibGVcIixcbiAgcHJvcHM6IHtcbiAgICBvcmlnaW5EcmFnZ2FibGU6IEJvb2xlYW4sXG4gICAgb3JpZ2luUmVsYXRpdmU6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgb25EcmFnT3JpZ2luU3RhcnQ6IFwiZHJhZ09yaWdpblN0YXJ0XCIsXG4gICAgb25EcmFnT3JpZ2luOiBcImRyYWdPcmlnaW5cIixcbiAgICBvbkRyYWdPcmlnaW5FbmQ6IFwiZHJhZ09yaWdpbkVuZFwiXG4gIH0sXG4gIGNzczogW1wiOmhvc3RbZGF0YS1hYmxlLW9yaWdpbmRyYWdnYWJsZV0gLmNvbnRyb2wub3JpZ2luIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XFxufVwiXSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChfLCBlKSB7XG4gICAgaWYgKGUuaXNSZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gZS5yZXF1ZXN0QWJsZSA9PT0gXCJvcmlnaW5EcmFnZ2FibGVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzQ2xhc3MoZS5pbnB1dEV2ZW50LnRhcmdldCwgcHJlZml4KFwib3JpZ2luXCIpKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcbiAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xuICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBkcmFnU3RhcnQ6IERyYWdnYWJsZS5kcmFnU3RhcnQobW92ZWFibGUsIG5ldyBDdXN0b21HZXN0bygpLmRyYWdTdGFydChbMCwgMF0sIGUpKVxuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnT3JpZ2luU3RhcnRcIiwgcGFyYW1zKTtcbiAgICBkYXRhcy5zdGFydE9yaWdpbiA9IG1vdmVhYmxlLnN0YXRlLnRyYW5zZm9ybU9yaWdpbjtcbiAgICBkYXRhcy5zdGFydFRhcmdldE9yaWdpbiA9IG1vdmVhYmxlLnN0YXRlLnRhcmdldE9yaWdpbjtcbiAgICBkYXRhcy5wcmV2T3JpZ2luID0gWzAsIDBdO1xuICAgIGRhdGFzLmlzRHJhZ09yaWdpbiA9IHRydWU7XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgZGF0YXMuaXNEcmFnT3JpZ2luID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgIGlzUGluY2ggPSBlLmlzUGluY2gsXG4gICAgICAgIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xuXG4gICAgaWYgKCFkYXRhcy5pc0RyYWdPcmlnaW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBnZXREcmFnRGlzdChlKSxcbiAgICAgICAgZGlzdFggPSBfYVswXSxcbiAgICAgICAgZGlzdFkgPSBfYVsxXTtcblxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICAgIHZhciB3aWR0aCA9IHN0YXRlLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQsXG4gICAgICAgIG9mZnNldE1hdHJpeCA9IHN0YXRlLm9mZnNldE1hdHJpeCxcbiAgICAgICAgdGFyZ2V0TWF0cml4ID0gc3RhdGUudGFyZ2V0TWF0cml4LFxuICAgICAgICBpczNkID0gc3RhdGUuaXMzZDtcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcy5vcmlnaW5SZWxhdGl2ZSxcbiAgICAgICAgb3JpZ2luUmVsYXRpdmUgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICAgIHZhciBkaXN0ID0gW2Rpc3RYLCBkaXN0WV07XG5cbiAgICBpZiAoaXNSZXF1ZXN0KSB7XG4gICAgICB2YXIgZGlzdE9yaWdpbiA9IGUuZGlzdE9yaWdpbjtcblxuICAgICAgaWYgKGRpc3RPcmlnaW5bMF0gfHwgZGlzdE9yaWdpblsxXSkge1xuICAgICAgICBkaXN0ID0gZGlzdE9yaWdpbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luID0gcGx1cyhkYXRhcy5zdGFydE9yaWdpbiwgZGlzdCk7XG4gICAgdmFyIHRhcmdldE9yaWdpbiA9IHBsdXMoZGF0YXMuc3RhcnRUYXJnZXRPcmlnaW4sIGRpc3QpO1xuICAgIHZhciBkZWx0YSA9IG1pbnVzKGRpc3QsIGRhdGFzLnByZXZPcmlnaW4pO1xuICAgIHZhciBuZXh0TWF0cml4ID0gZ2V0TmV4dE1hdHJpeChvZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCwgb3JpZ2luLCBuKTtcbiAgICB2YXIgcmVjdCA9IG1vdmVhYmxlLmdldFJlY3QoKTtcbiAgICB2YXIgbmV4dFJlY3QgPSBnZXRSZWN0KGNhbGN1bGF0ZVBvc2VzKG5leHRNYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pKTtcbiAgICB2YXIgZHJhZ0RlbHRhID0gW3JlY3QubGVmdCAtIG5leHRSZWN0LmxlZnQsIHJlY3QudG9wIC0gbmV4dFJlY3QudG9wXTtcbiAgICBkYXRhcy5wcmV2T3JpZ2luID0gZGlzdDtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gW2NvbnZlcnRDU1NTaXplKHRhcmdldE9yaWdpblswXSwgd2lkdGgsIG9yaWdpblJlbGF0aXZlKSwgY29udmVydENTU1NpemUodGFyZ2V0T3JpZ2luWzFdLCBoZWlnaHQsIG9yaWdpblJlbGF0aXZlKV0uam9pbihcIiBcIik7XG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICBkaXN0OiBkaXN0LFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXG4gICAgICBkcmFnOiBEcmFnZ2FibGUuZHJhZyhtb3ZlYWJsZSwgc2V0Q3VzdG9tRHJhZyhlLCBtb3ZlYWJsZS5zdGF0ZSwgZHJhZ0RlbHRhLCAhIWlzUGluY2gsIGZhbHNlKSlcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnT3JpZ2luXCIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzRHJhZ09yaWdpbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdPcmlnaW5FbmRcIiwgZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2xDb25kaXRpb24obW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xuXG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBtb3ZlYWJsZS50cmFuc2Zvcm1PcmlnaW4gPSBwYXJhbXMudHJhbnNmb3JtT3JpZ2luO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAqIEBtZXRob2QgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlI3JlcXVlc3RcbiAgKiBAcGFyYW0ge29iamVjdH0gZSAtIHRoZSBPcmlnaW5EcmFnZ2FibGUncyByZXF1ZXN0IHBhcmFtZXRlclxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZS54XSAtIHggcG9zaXRpb25cbiAgKiBAcGFyYW0ge251bWJlcn0gW2UueV0gLSB5IHBvc2l0aW9uXG4gICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWF0gLSB4IG51bWJlciB0byBtb3ZlXG4gICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWV0gLSB5IG51bWJlciB0byBtb3ZlXG4gICogQHBhcmFtIHthcnJheX0gW2UuZGVsdGFPcmlnaW5dIC0gbGVmdCwgdG9wIG51bWJlciB0byBtb3ZlIHRyYW5zZm9ybS1vcmlnaW5cbiAgKiBAcGFyYW0ge2FycmF5fSBbZS5vcmlnaW5dIC0gdHJhbnNmb3JtLW9yaWdpbiBwb3NpdGlvblxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5pc0luc3RhbnRdIC0gV2hldGhlciB0byBleGVjdXRlIHRoZSByZXF1ZXN0IGluc3RhbnRseVxuICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXG4gICogQGV4YW1wbGVcbiAgICogLy8gSW5zdGFudGx5IFJlcXVlc3QgKHJlcXVlc3RTdGFydCAtIHJlcXVlc3QgLSByZXF1ZXN0RW5kKVxuICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0sIHRydWUpO1xuICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMDAsIHk6IDEwMCB9LCB0cnVlKTtcbiAgKiAvLyBVc2UgVHJhbnNmb3JtIFZhbHVlXG4gICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IGRlbHRhT3JpZ2luOiBbMTAsIDBdIH0sIHRydWUpO1xuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBvcmlnaW46IFsxMDAsIDBdIH0sIHRydWUpO1xuICAqIC8vIHJlcXVlc3RTdGFydFxuICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIik7XG4gICpcbiAgKiAvLyByZXF1ZXN0XG4gICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXG4gICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICogLy8gVXNlIEFic29sdXRlIFZhbHVlXG4gICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IHg6IDIwMCwgeTogMTAwIH0pO1xuICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyMjAsIHk6IDEwMCB9KTtcbiAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgeDogMjQwLCB5OiAxMDAgfSk7XG4gICpcbiAgKiAvLyByZXF1ZXN0RW5kXG4gICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgKi9cbiAgcmVxdWVzdDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdmFyIGRhdGFzID0ge307XG4gICAgdmFyIHJlY3QgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XG4gICAgdmFyIGRpc3RYID0gMDtcbiAgICB2YXIgZGlzdFkgPSAwO1xuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSByZWN0LnRyYW5zZm9ybU9yaWdpbjtcbiAgICB2YXIgZGlzdE9yaWdpbiA9IFswLCAwXTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb250cm9sOiB0cnVlLFxuICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKFwiZGVsdGFPcmlnaW5cIiBpbiBlKSB7XG4gICAgICAgICAgZGlzdE9yaWdpblswXSArPSBlLmRlbHRhT3JpZ2luWzBdO1xuICAgICAgICAgIGRpc3RPcmlnaW5bMV0gKz0gZS5kZWx0YU9yaWdpblsxXTtcbiAgICAgICAgfSBlbHNlIGlmIChcIm9yaWdpblwiIGluIGUpIHtcbiAgICAgICAgICBkaXN0T3JpZ2luWzBdID0gZS5vcmlnaW5bMF0gLSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgICAgICAgZGlzdE9yaWdpblsxXSA9IGUub3JpZ2luWzFdIC0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChcInhcIiBpbiBlKSB7XG4gICAgICAgICAgICBkaXN0WCA9IGUueCAtIHJlY3QubGVmdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiZGVsdGFYXCIgaW4gZSkge1xuICAgICAgICAgICAgZGlzdFggKz0gZS5kZWx0YVg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwieVwiIGluIGUpIHtcbiAgICAgICAgICAgIGRpc3RZID0gZS55IC0gcmVjdC50b3A7XG4gICAgICAgICAgfSBlbHNlIGlmIChcImRlbHRhWVwiIGluIGUpIHtcbiAgICAgICAgICAgIGRpc3RZICs9IGUuZGVsdGFZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YXM6IGRhdGFzLFxuICAgICAgICAgIGRpc3RYOiBkaXN0WCxcbiAgICAgICAgICBkaXN0WTogZGlzdFksXG4gICAgICAgICAgZGlzdE9yaWdpbjogZGlzdE9yaWdpblxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhczogZGF0YXMsXG4gICAgICAgICAgaXNEcmFnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogV2hldGhlciB0byBkcmFnIG9yaWdpbiAoZGVmYXVsdDogZmFsc2UpXG4gKiBAbmFtZSBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUjb3JpZ2luRHJhZ2dhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICBvcmlnaW5EcmFnZ2FibGU6IHRydWUsXG4gKiB9KTtcbiAqIGxldCB0cmFuc2xhdGUgPSBbMCwgMF07XG4gKiBtb3ZlYWJsZS5vbihcImRyYWdPcmlnaW5TdGFydFwiLCBlID0+IHtcbiAqICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcbiAqIH0pLm9uKFwiZHJhZ09yaWdpblwiLCBlID0+IHtcbiAqICAgICB0cmFuc2xhdGUgPSBlLmRyYWcuYmVmb3JlVHJhbnNsYXRlO1xuICogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcbiAqICAgICAgICAgPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtlLnRyYW5zZm9ybU9yaWdpbn07YFxuICogICAgICAgICArIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVswXX1weCwgJHt0cmFuc2xhdGVbMV19cHgpYDtcbiAqIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogJSBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhYnNvbHV0ZSBweCAoZGVmYXVsdDogdHJ1ZSlcbiAqIEBuYW1lIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZSNvcmlnaW5SZWxhdGl2ZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxuICogICAgIG9yaWdpblJlbGF0aXZlOiBmYWxzZSxcbiAqIH0pO1xuICogbW92ZWFibGUub3JpZ2luUmVsYXRpdmUgPSB0cnVlO1xuICovXG5cbi8qKlxuKiBXaGVuIGRyYWcgc3RhcnQgdGhlIG9yaWdpbiwgdGhlIGBkcmFnT3JpZ2luU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cbiogQG1lbWJlcm9mIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZVxuKiBAZXZlbnQgZHJhZ09yaWdpblN0YXJ0XG4qIEBwYXJhbSB7TW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLk9uRHJhZ09yaWdpblN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgZHJhZ09yaWdpblN0YXJ0YCBldmVudFxuKiBAZXhhbXBsZVxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4qXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiogICAgIG9yaWdpbkRyYWdnYWJsZTogdHJ1ZSxcbiogfSk7XG4qIGxldCB0cmFuc2xhdGUgPSBbMCwgMF07XG4qIG1vdmVhYmxlLm9uKFwiZHJhZ09yaWdpblN0YXJ0XCIsIGUgPT4ge1xuKiAgICAgZS5kcmFnU3RhcnQgJiYgZS5kcmFnU3RhcnQuc2V0KHRyYW5zbGF0ZSk7XG4qIH0pLm9uKFwiZHJhZ09yaWdpblwiLCBlID0+IHtcbiogICAgIHRyYW5zbGF0ZSA9IGUuZHJhZy5iZWZvcmVUcmFuc2xhdGU7XG4qICAgICBlLnRhcmdldC5zdHlsZS5jc3NUZXh0XG4qICAgICAgICAgPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtlLnRyYW5zZm9ybU9yaWdpbn07YFxuKiAgICAgICAgICsgYHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dHJhbnNsYXRlWzBdfXB4LCAke3RyYW5zbGF0ZVsxXX1weClgO1xuKiB9KS5vbihcImRyYWdPcmlnaW5FbmRcIiwgZSA9PiB7XG4qICAgICBjb25zb2xlLmxvZyhlKTtcbiogfSk7XG4qL1xuXG4vKipcbiogV2hlbiBkcmFnIHRoZSBvcmlnaW4sIHRoZSBgZHJhZ09yaWdpbmAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlXG4qIEBldmVudCBkcmFnT3JpZ2luXG4qIEBwYXJhbSB7TW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLk9uRHJhZ09yaWdpbn0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdPcmlnaW5gIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxuKiB9KTtcbiogbGV0IHRyYW5zbGF0ZSA9IFswLCAwXTtcbiogbW92ZWFibGUub24oXCJkcmFnT3JpZ2luU3RhcnRcIiwgZSA9PiB7XG4qICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcbiogfSkub24oXCJkcmFnT3JpZ2luXCIsIGUgPT4ge1xuKiAgICAgdHJhbnNsYXRlID0gZS5kcmFnLmJlZm9yZVRyYW5zbGF0ZTtcbiogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcbiogICAgICAgICA9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke2UudHJhbnNmb3JtT3JpZ2lufTtgXG4qICAgICAgICAgKyBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt0cmFuc2xhdGVbMF19cHgsICR7dHJhbnNsYXRlWzFdfXB4KWA7XG4qIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcbiogICAgIGNvbnNvbGUubG9nKGUpO1xuKiB9KTtcbiovXG5cbi8qKlxuKiBXaGVuIGRyYWcgZW5kIHRoZSBvcmlnaW4sIHRoZSBgZHJhZ09yaWdpbkVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuKiBAbWVtYmVyb2YgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlXG4qIEBldmVudCBkcmFnT3JpZ2luRW5kXG4qIEBwYXJhbSB7TW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLk9uRHJhZ09yaWdpbkVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdPcmlnaW5FbmRgIGV2ZW50XG4qIEBleGFtcGxlXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbipcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuKiAgICAgb3JpZ2luRHJhZ2dhYmxlOiB0cnVlLFxuKiB9KTtcbiogbGV0IHRyYW5zbGF0ZSA9IFswLCAwXTtcbiogbW92ZWFibGUub24oXCJkcmFnT3JpZ2luU3RhcnRcIiwgZSA9PiB7XG4qICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcbiogfSkub24oXCJkcmFnT3JpZ2luXCIsIGUgPT4ge1xuKiAgICAgdHJhbnNsYXRlID0gZS5kcmFnLmJlZm9yZVRyYW5zbGF0ZTtcbiogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcbiogICAgICAgICA9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke2UudHJhbnNmb3JtT3JpZ2lufTtgXG4qICAgICAgICAgKyBgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHt0cmFuc2xhdGVbMF19cHgsICR7dHJhbnNsYXRlWzFdfXB4KWA7XG4qIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcbiogICAgIGNvbnNvbGUubG9nKGUpO1xuKiB9KTtcbiovXG5cbmZ1bmN0aW9uIGFkZEJvcmRlclJhZGl1cyhjb250cm9sUG9zZXMsIHBvc2VzLCBsaW5lSW5kZXgsIGRpc3RYLCBkaXN0WSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgX2EgPSBzcGxpdFJhZGl1c1Bvc2VzKGNvbnRyb2xQb3NlcyksXG4gICAgICBob3Jpem9udGFscyA9IF9hLmhvcml6b250YWxzLFxuICAgICAgdmVydGljYWxzID0gX2EudmVydGljYWxzO1xuXG4gIHZhciBob3Jpem9udGFsc0xlbmd0aCA9IGhvcml6b250YWxzLmxlbmd0aDtcbiAgdmFyIHZlcnRpY2Fsc0xlbmd0aCA9IHZlcnRpY2Fscy5sZW5ndGg7IC8vIGxpbmVJbmRleFxuICAvLyAwIHRvcFxuICAvLyAxIHJpZ2h0XG4gIC8vIDIgbGVmdFxuICAvLyAzIGJvdHRvbVxuICAvLyAwIHRvcCAtIGxlZnRcbiAgLy8gMSB0b3AgLSByaWdodFxuICAvLyAyIGJvdHRvbSAtIHJpZ2h0XG4gIC8vIDMgYm90dG9tIC0gbGVmdFxuICAvLyAwIGxlZnQgLSB0b3BcbiAgLy8gMSByaWdodCAtIHRvcFxuICAvLyAyIHJpZ2h0IC0gYm90dG9tXG4gIC8vIDMgbGVmdCAtIGJvdHRvbVxuXG4gIHZhciBob3Jpem9udGFsSW5kZXggPSAtMTtcbiAgdmFyIHZlcnRpY2FsSW5kZXggPSAtMTtcblxuICBpZiAobGluZUluZGV4ID09PSAwKSB7XG4gICAgaWYgKGhvcml6b250YWxzTGVuZ3RoID09PSAwKSB7XG4gICAgICBob3Jpem9udGFsSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGhvcml6b250YWxJbmRleCA9IDE7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxpbmVJbmRleCA9PT0gMykge1xuICAgIGlmIChob3Jpem9udGFsc0xlbmd0aCA8PSAyKSB7XG4gICAgICBob3Jpem9udGFsSW5kZXggPSAyO1xuICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPD0gMykge1xuICAgICAgaG9yaXpvbnRhbEluZGV4ID0gMztcbiAgICB9XG4gIH1cblxuICBpZiAobGluZUluZGV4ID09PSAyKSB7XG4gICAgaWYgKHZlcnRpY2Fsc0xlbmd0aCA9PT0gMCkge1xuICAgICAgdmVydGljYWxJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmICh2ZXJ0aWNhbHNMZW5ndGggPCA0KSB7XG4gICAgICB2ZXJ0aWNhbEluZGV4ID0gMztcbiAgICB9XG4gIH0gZWxzZSBpZiAobGluZUluZGV4ID09PSAxKSB7XG4gICAgaWYgKHZlcnRpY2Fsc0xlbmd0aCA8PSAxKSB7XG4gICAgICB2ZXJ0aWNhbEluZGV4ID0gMTtcbiAgICB9IGVsc2UgaWYgKHZlcnRpY2Fsc0xlbmd0aCA8PSAyKSB7XG4gICAgICB2ZXJ0aWNhbEluZGV4ID0gMjtcbiAgICB9XG4gIH1cblxuICBhZGRSYWRpdXNQb3MoY29udHJvbFBvc2VzLCBwb3NlcywgMCwgaG9yaXpvbnRhbEluZGV4LCB2ZXJ0aWNhbEluZGV4LCBkaXN0WCwgZGlzdFksIHdpZHRoLCBoZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBnZXRCb3JkZXJSYWRpdXModGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBtaW5Db3VudHMsIHN0YXRlKSB7XG4gIGlmIChtaW5Db3VudHMgPT09IHZvaWQgMCkge1xuICAgIG1pbkNvdW50cyA9IFswLCAwXTtcbiAgfVxuXG4gIHZhciBib3JkZXJSYWRpdXM7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAoIXN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIGJvcmRlclJhZGl1cyA9IHN0eWxlICYmIHN0eWxlLmJvcmRlclJhZGl1cyB8fCBcIlwiO1xuICB9IGVsc2Uge1xuICAgIGJvcmRlclJhZGl1cyA9IHN0YXRlO1xuICB9XG5cbiAgaWYgKCFib3JkZXJSYWRpdXMgfHwgIXN0YXRlICYmIGJvcmRlclJhZGl1cyA9PT0gXCIwcHhcIikge1xuICAgIHZhbHVlcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlcyA9IHNwbGl0U3BhY2UoYm9yZGVyUmFkaXVzKTtcbiAgfVxuXG4gIHJldHVybiBnZXRSYWRpdXNWYWx1ZXModmFsdWVzLCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCBtaW5Db3VudHMpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyUm91bmRFdmVudChtb3ZlYWJsZSwgZSwgZGlzdCwgZGVsdGEsIGNvbnRyb2xQb3NlcywgbmV4dFBvc2VzKSB7XG4gIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xuICB2YXIgd2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcblxuICB2YXIgX2EgPSBnZXRSYWRpdXNTdHlsZXMobmV4dFBvc2VzLCBjb250cm9sUG9zZXMsIG1vdmVhYmxlLnByb3BzLnJvdW5kUmVsYXRpdmUsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgcmF3cyA9IF9hLnJhd3MsXG4gICAgICBzdHlsZXMgPSBfYS5zdHlsZXM7XG5cbiAgdmFyIF9iID0gc3BsaXRSYWRpdXNQb3Nlcyhjb250cm9sUG9zZXMsIHJhd3MpLFxuICAgICAgaG9yaXpvbnRhbHMgPSBfYi5ob3Jpem9udGFscyxcbiAgICAgIHZlcnRpY2FscyA9IF9iLnZlcnRpY2FscztcblxuICB2YXIgYm9yZGVyUmFkaXVzID0gc3R5bGVzLmpvaW4oXCIgXCIpO1xuICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IGJvcmRlclJhZGl1cztcbiAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgIGhvcml6b250YWxzOiBob3Jpem9udGFscyxcbiAgICB2ZXJ0aWNhbHM6IHZlcnRpY2FscyxcbiAgICBib3JkZXJSYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgZGVsdGE6IGRlbHRhLFxuICAgIGRpc3Q6IGRpc3RcbiAgfSkpO1xufVxuLyoqXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLlJvdW5kYWJsZVxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgdG8gc2hvdyBhbmQgZHJhZyBvciBkb3VibGUgY2xpY2sgYm9yZGVyLXJhZGl1c1xuICovXG5cblxudmFyIFJvdW5kYWJsZSA9IHtcbiAgbmFtZTogXCJyb3VuZGFibGVcIixcbiAgcHJvcHM6IHtcbiAgICByb3VuZGFibGU6IEJvb2xlYW4sXG4gICAgcm91bmRSZWxhdGl2ZTogQm9vbGVhbixcbiAgICBtaW5Sb3VuZENvbnRyb2xzOiBBcnJheSxcbiAgICBtYXhSb3VuZENvbnRyb2xzOiBBcnJheSxcbiAgICByb3VuZENsaWNrYWJsZTogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvblJvdW5kU3RhcnQ6IFwicm91bmRTdGFydFwiLFxuICAgIG9uUm91bmQ6IFwicm91bmRcIixcbiAgICBvblJvdW5kRW5kOiBcInJvdW5kRW5kXCJcbiAgfSxcbiAgY3NzOiBbXCIuY29udHJvbC5ib3JkZXItcmFkaXVzIHtcXG4gICAgYmFja2dyb3VuZDogI2Q2NjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cIiwgXCI6aG9zdFtkYXRhLWFibGUtcm91bmRhYmxlXSAubGluZS5kaXJlY3Rpb24ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVwiXSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0LFxuICAgICAgICBhbGxNYXRyaXggPSBfYS5hbGxNYXRyaXgsXG4gICAgICAgIGlzM2QgPSBfYS5pczNkLFxuICAgICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgICBib3JkZXJSYWRpdXNTdGF0ZSA9IF9hLmJvcmRlclJhZGl1c1N0YXRlO1xuICAgIHZhciBfYiA9IG1vdmVhYmxlLnByb3BzLFxuICAgICAgICBfYyA9IF9iLm1pblJvdW5kQ29udHJvbHMsXG4gICAgICAgIG1pblJvdW5kQ29udHJvbHMgPSBfYyA9PT0gdm9pZCAwID8gWzAsIDBdIDogX2MsXG4gICAgICAgIF9kID0gX2IubWF4Um91bmRDb250cm9scyxcbiAgICAgICAgbWF4Um91bmRDb250cm9scyA9IF9kID09PSB2b2lkIDAgPyBbNCwgNF0gOiBfZCxcbiAgICAgICAgem9vbSA9IF9iLnpvb207XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XG4gICAgdmFyIHJhZGl1c1ZhbHVlcyA9IGdldEJvcmRlclJhZGl1cyh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG1pblJvdW5kQ29udHJvbHMsIGJvcmRlclJhZGl1c1N0YXRlKTtcblxuICAgIGlmICghcmFkaXVzVmFsdWVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdmVydGljYWxDb3VudCA9IDA7XG4gICAgdmFyIGhvcml6b250YWxDb3VudCA9IDA7XG4gICAgcmV0dXJuIHJhZGl1c1ZhbHVlcy5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIGhvcml6b250YWxDb3VudCArPSBNYXRoLmFicyh2Lmhvcml6b250YWwpO1xuICAgICAgdmVydGljYWxDb3VudCArPSBNYXRoLmFicyh2LnZlcnRpY2FsKTtcbiAgICAgIHZhciBwb3MgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIHYucG9zLCBuKSwgW2xlZnQsIHRvcF0pO1xuICAgICAgdmFyIGlzRGlzcGxheSA9IHYudmVydGljYWwgPyB2ZXJ0aWNhbENvdW50IDw9IG1heFJvdW5kQ29udHJvbHNbMV0gOiBob3Jpem9udGFsQ291bnQgPD0gbWF4Um91bmRDb250cm9sc1swXTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBcImJvcmRlclJhZGl1c0NvbnRyb2xcIiArIGksXG4gICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcImJvcmRlci1yYWRpdXNcIiksXG4gICAgICAgIFwiZGF0YS1yYWRpdXMtaW5kZXhcIjogaSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiBpc0Rpc3BsYXkgPyBcImJsb2NrXCIgOiBcIm5vbmVcIixcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgcG9zWzBdICsgXCJweCwgXCIgKyBwb3NbMV0gKyBcInB4KSBzY2FsZShcIiArIHpvb20gKyBcIilcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIGlmICghZS5pbnB1dEV2ZW50IHx8IGUuaXNSZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZSA9IGUuaW5wdXRFdmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoXCJib3JkZXItcmFkaXVzXCIpID4gLTEgfHwgY2xhc3NOYW1lLmluZGV4T2YoXCJtb3ZlYWJsZS1saW5lXCIpID4gLTEgJiYgY2xhc3NOYW1lLmluZGV4T2YoXCJtb3ZlYWJsZS1kaXJlY3Rpb25cIikgPiAtMTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsXG4gICAgICAgIGRhdGFzID0gZS5kYXRhcztcbiAgICB2YXIgaW5wdXRUYXJnZXQgPSBpbnB1dEV2ZW50LnRhcmdldDtcbiAgICB2YXIgY2xhc3NOYW1lID0gaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICB2YXIgaXNDb250cm9sID0gY2xhc3NOYW1lLmluZGV4T2YoXCJib3JkZXItcmFkaXVzXCIpID4gLTE7XG4gICAgdmFyIGlzTGluZSA9IGNsYXNzTmFtZS5pbmRleE9mKFwibW92ZWFibGUtbGluZVwiKSA+IC0xICYmIGNsYXNzTmFtZS5pbmRleE9mKFwibW92ZWFibGUtZGlyZWN0aW9uXCIpID4gLTE7XG4gICAgdmFyIGNvbnRyb2xJbmRleCA9IGlzQ29udHJvbCA/IHBhcnNlSW50KGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmFkaXVzLWluZGV4XCIpLCAxMCkgOiAtMTtcbiAgICB2YXIgbGluZUluZGV4ID0gaXNMaW5lID8gcGFyc2VJbnQoaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1saW5lLWluZGV4XCIpLCAxMCkgOiAtMTtcblxuICAgIGlmICghaXNDb250cm9sICYmICFpc0xpbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRTdGFydFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSkpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkYXRhcy5saW5lSW5kZXggPSBsaW5lSW5kZXg7XG4gICAgZGF0YXMuY29udHJvbEluZGV4ID0gY29udHJvbEluZGV4O1xuICAgIGRhdGFzLmlzQ29udHJvbCA9IGlzQ29udHJvbDtcbiAgICBkYXRhcy5pc0xpbmUgPSBpc0xpbmU7XG4gICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcyxcbiAgICAgICAgcm91bmRSZWxhdGl2ZSA9IF9hLnJvdW5kUmVsYXRpdmUsXG4gICAgICAgIF9iID0gX2EubWluUm91bmRDb250cm9scyxcbiAgICAgICAgbWluUm91bmRDb250cm9scyA9IF9iID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfYjtcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICB3aWR0aCA9IHN0YXRlLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgZGF0YXMuaXNSb3VuZCA9IHRydWU7XG4gICAgZGF0YXMucHJldkRpc3QgPSBbMCwgMF07XG4gICAgdmFyIGNvbnRyb2xQb3NlcyA9IGdldEJvcmRlclJhZGl1cyh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIG1pblJvdW5kQ29udHJvbHMpIHx8IFtdO1xuICAgIGRhdGFzLmNvbnRyb2xQb3NlcyA9IGNvbnRyb2xQb3NlcztcbiAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IGdldFJhZGl1c1N0eWxlcyhjb250cm9sUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBwb3MucG9zO1xuICAgIH0pLCBjb250cm9sUG9zZXMsIHJvdW5kUmVsYXRpdmUsIHdpZHRoLCBoZWlnaHQpLnN0eWxlcy5qb2luKFwiIFwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgICBpZiAoIWRhdGFzLmlzUm91bmQgfHwgIWRhdGFzLmlzQ29udHJvbCB8fCAhZGF0YXMuY29udHJvbFBvc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGRhdGFzLmNvbnRyb2xJbmRleDtcbiAgICB2YXIgY29udHJvbFBvc2VzID0gZGF0YXMuY29udHJvbFBvc2VzO1xuXG4gICAgdmFyIF9hID0gZ2V0RHJhZ0Rpc3QoZSksXG4gICAgICAgIGRpc3RYID0gX2FbMF0sXG4gICAgICAgIGRpc3RZID0gX2FbMV07XG5cbiAgICB2YXIgZGlzdCA9IFtkaXN0WCwgZGlzdFldO1xuICAgIHZhciBkZWx0YSA9IG1pbnVzKGRpc3QsIGRhdGFzLnByZXZEaXN0KTtcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcy5tYXhSb3VuZENvbnRyb2xzLFxuICAgICAgICBtYXhSb3VuZENvbnRyb2xzID0gX2IgPT09IHZvaWQgMCA/IFs0LCA0XSA6IF9iO1xuICAgIHZhciBfYyA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICB3aWR0aCA9IF9jLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYy5oZWlnaHQ7XG4gICAgdmFyIHNlbGVjdGVkQ29udHJvbFBvc2UgPSBjb250cm9sUG9zZXNbaW5kZXhdO1xuICAgIHZhciBzZWxlY3RlZFZlcnRpY2FsID0gc2VsZWN0ZWRDb250cm9sUG9zZS52ZXJ0aWNhbDtcbiAgICB2YXIgc2VsZWN0ZWRIb3Jpem9udGFsID0gc2VsZWN0ZWRDb250cm9sUG9zZS5ob3Jpem9udGFsOyAvLyAwOiBbMCwgMSwgMiwgM10gbWF4Q291bnQgPT09IDFcbiAgICAvLyAwOiBbMCwgMl0gbWF4Q291bnQgPT09IDJcbiAgICAvLyAxOiBbMSwgM10gbWF4Q291bnQgPT09IDJcbiAgICAvLyAwOiBbMF0gbWF4Q291bnQgPT09IDNcbiAgICAvLyAxOiBbMSwgM10gbWF4Q291bnQgPT09IDNcblxuICAgIHZhciBkaXN0cyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvc2UpIHtcbiAgICAgIHZhciBob3Jpem9udGFsID0gcG9zZS5ob3Jpem9udGFsLFxuICAgICAgICAgIHZlcnRpY2FsID0gcG9zZS52ZXJ0aWNhbDtcbiAgICAgIHZhciBwb3NlRGlzdCA9IFtob3Jpem9udGFsICogc2VsZWN0ZWRIb3Jpem9udGFsICogZGlzdFswXSwgdmVydGljYWwgKiBzZWxlY3RlZFZlcnRpY2FsICogZGlzdFsxXV07XG5cbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChtYXhSb3VuZENvbnRyb2xzWzBdID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc2VEaXN0O1xuICAgICAgICB9IGVsc2UgaWYgKG1heFJvdW5kQ29udHJvbHNbMF0gPCA0ICYmIGhvcml6b250YWwgIT09IHNlbGVjdGVkSG9yaXpvbnRhbCkge1xuICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtYXhSb3VuZENvbnRyb2xzWzFdID09PSAwKSB7XG4gICAgICAgIHBvc2VEaXN0WzFdID0gdmVydGljYWwgKiBzZWxlY3RlZEhvcml6b250YWwgKiBkaXN0WzBdIC8gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRWZXJ0aWNhbCkge1xuICAgICAgICBpZiAobWF4Um91bmRDb250cm9sc1sxXSA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXhSb3VuZENvbnRyb2xzWzFdIDwgNCAmJiB2ZXJ0aWNhbCAhPT0gc2VsZWN0ZWRWZXJ0aWNhbCkge1xuICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH0pO1xuICAgIGRpc3RzW2luZGV4XSA9IGRpc3Q7XG4gICAgdmFyIG5leHRQb3NlcyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xuICAgICAgcmV0dXJuIHBsdXMocG9zLnBvcywgZGlzdHNbaV0pO1xuICAgIH0pO1xuICAgIGRhdGFzLnByZXZEaXN0ID0gW2Rpc3RYLCBkaXN0WV07XG4gICAgdHJpZ2dlclJvdW5kRXZlbnQobW92ZWFibGUsIGUsIGRpc3QsIGRlbHRhLCBjb250cm9sUG9zZXMsIG5leHRQb3Nlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcbiAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgaXNEb3VibGUgPSBlLmlzRG91YmxlO1xuXG4gICAgaWYgKCFkYXRhcy5pc1JvdW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gc3RhdGUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICB2YXIgaXNDb250cm9sID0gZGF0YXMuaXNDb250cm9sLFxuICAgICAgICBjb250cm9sSW5kZXggPSBkYXRhcy5jb250cm9sSW5kZXgsXG4gICAgICAgIGlzTGluZSA9IGRhdGFzLmlzTGluZSxcbiAgICAgICAgbGluZUluZGV4ID0gZGF0YXMubGluZUluZGV4O1xuICAgIHZhciBjb250cm9sUG9zZXMgPSBkYXRhcy5jb250cm9sUG9zZXM7XG4gICAgdmFyIHBvc2VzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zLnBvcztcbiAgICB9KTtcbiAgICB2YXIgbGVuZ3RoID0gcG9zZXMubGVuZ3RoO1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLnJvdW5kQ2xpY2thYmxlLFxuICAgICAgICByb3VuZENsaWNrYWJsZSA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2E7XG5cbiAgICBpZiAoaXNEb3VibGUgJiYgcm91bmRDbGlja2FibGUpIHtcbiAgICAgIGlmIChpc0NvbnRyb2wpIHtcbiAgICAgICAgcmVtb3ZlUmFkaXVzUG9zKGNvbnRyb2xQb3NlcywgcG9zZXMsIGNvbnRyb2xJbmRleCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGlzTGluZSkge1xuICAgICAgICB2YXIgX2IgPSBjYWxjdWxhdGVQb2ludGVyRGlzdChtb3ZlYWJsZSwgZSksXG4gICAgICAgICAgICBkaXN0WCA9IF9iWzBdLFxuICAgICAgICAgICAgZGlzdFkgPSBfYlsxXTtcblxuICAgICAgICBhZGRCb3JkZXJSYWRpdXMoY29udHJvbFBvc2VzLCBwb3NlcywgbGluZUluZGV4LCBkaXN0WCwgZGlzdFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoICE9PSBjb250cm9sUG9zZXMubGVuZ3RoKSB7XG4gICAgICAgIHRyaWdnZXJSb3VuZEV2ZW50KG1vdmVhYmxlLCBlLCBbMCwgMF0sIFswLCAwXSwgY29udHJvbFBvc2VzLCBwb3Nlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRFbmRcIiwgZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pKTtcbiAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XG4gIH1cbn07XG4vKipcbiAqIFdoZXRoZXIgdG8gc2hvdyBhbmQgZHJhZyBvciBkb3VibGUgY2xpY2sgYm9yZGVyLXJhZGl1cywgKGRlZmF1bHQ6IGZhbHNlKVxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI3JvdW5kYWJsZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xuICogfSkub24oXCJyb3VuZEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogJSBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhYnNvbHV0ZSBweFxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI3JvdW5kUmVsYXRpdmVcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3VuZFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcbiAqICAgICBlLnRhcmdldC5zdHlsZS5ib3JkZXJSYWRpdXMgPSBlLmJvcmRlclJhZGl1cztcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIE1pbmltdW0gbnVtYmVyIG9mIHJvdW5kIGNvbnRyb2xzLiBJdCBtb3ZlcyBpbiBwcm9wb3J0aW9uIGJ5IGNvbnRyb2wuIFtob3Jpem9udGFsLCB2ZXJ0aWNhbF0gKGRlZmF1bHQ6IFswLCAwXSlcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNtaW5Sb3VuZENvbnRyb2xzXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgbWluUm91bmRDb250cm9sczogWzAsIDBdLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5tYXhSb3VuZENvbnRyb2xzID0gWzEsIDBdO1xuICovXG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2Ygcm91bmQgY29udHJvbHMuIEl0IG1vdmVzIGluIHByb3BvcnRpb24gYnkgY29udHJvbC4gW2hvcml6b250YWwsIHZlcnRpY2FsXSAoZGVmYXVsdDogWzQsIDRdKVxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI21heFJvdW5kQ29udHJvbHNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcbiAqICAgICBtYXhSb3VuZENvbnRyb2xzOiBbNCwgNF0sXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm1heFJvdW5kQ29udHJvbHMgPSBbMSwgMF07XG4gKi9cblxuLyoqXG4gKiBAcHJvcGVydHkgLSBXaGV0aGVyIHlvdSBjYW4gYWRkL2RlbGV0ZSByb3VuZCBjb250cm9scyBieSBkb3VibGUtY2xpY2tpbmcgYSBsaW5lIG9yIGNvbnRyb2wuIChkZWZhdWx0OiB0cnVlKVxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI3JvdW5kQ2xpY2thYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiAgICAgcm91bmRDbGlja2FibGU6IHRydWUsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLnJvdW5kQ2xpY2thYmxlID0gZmFsc2U7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgc3RhcnQgdGhlIGNsaXAgYXJlYSBvciBjb250cm9scywgdGhlIGByb3VuZFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm91bmRhYmxlXG4gKiBAZXZlbnQgcm91bmRTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3VuZGFibGUuT25Sb3VuZFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm91bmRTdGFydGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyb3VuZFN0YXJ0XCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSkub24oXCJyb3VuZFwiLCBlID0+IHtcbiAqICAgICBlLnRhcmdldC5zdHlsZS5ib3JkZXJSYWRpdXMgPSBlLmJvcmRlclJhZGl1cztcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIFdoZW4gZHJhZyBvciBkb3VibGUgY2xpY2sgdGhlIGJvcmRlciBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYHJvdW5kYCBldmVudCBpcyBjYWxsZWQuXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm91bmRhYmxlXG4gKiBAZXZlbnQgcm91bmRcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm91bmRhYmxlLk9uUm91bmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3VuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICByb3VuZGFibGU6IHRydWUsXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pLm9uKFwicm91bmRcIiwgZSA9PiB7XG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XG4gKiB9KS5vbihcInJvdW5kRW5kXCIsIGUgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGUpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIGRyYWcgZW5kIHRoZSBib3JkZXIgYXJlYSBvciBjb250cm9scywgdGhlIGByb3VuZEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdW5kYWJsZVxuICogQGV2ZW50IHJvdW5kRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdW5kYWJsZS5vblJvdW5kRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm91bmRFbmRgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kU3RhcnRcIiwgZSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZSk7XG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xuICogICAgIGUudGFyZ2V0LnN0eWxlLmJvcmRlclJhZGl1cyA9IGUuYm9yZGVyUmFkaXVzO1xuICogfSkub24oXCJyb3VuZEVuZFwiLCBlID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcbiAqIH0pO1xuICovXG5cbmZ1bmN0aW9uIGlzSWRlbnRpdHlNYXRyaXgobWF0cml4LCBpczNkKSB7XG4gIHZhciB2YWx1ZSA9IGlzM2QgPyBcIm1hdHJpeDNkKFwiICsgY3JlYXRlSWRlbnRpdHlNYXRyaXgoNCkgOiBcIm1hdHJpeChcIiArIGNyZWF0ZUlkZW50aXR5TWF0cml4KDMpICsgXCIpXCI7XG4gIHJldHVybiBtYXRyaXggPT09IHZhbHVlIHx8IG1hdHJpeCA9PT0gXCJtYXRyaXgoMSwwLDAsMSwwLDApXCI7XG59XG5cbnZhciBCZWZvcmVSZW5kZXJhYmxlID0ge1xuICBpc1BpbmNoOiB0cnVlLFxuICBuYW1lOiBcImJlZm9yZVJlbmRlcmFibGVcIixcbiAgcHJvcHM6IHt9LFxuICBldmVudHM6IHtcbiAgICBvbkJlZm9yZVJlbmRlclN0YXJ0OiBcImJlZm9yZVJlbmRlclN0YXJ0XCIsXG4gICAgb25CZWZvcmVSZW5kZXI6IFwiYmVmb3JlUmVuZGVyXCIsXG4gICAgb25CZWZvcmVSZW5kZXJFbmQ6IFwiYmVmb3JlUmVuZGVyRW5kXCIsXG4gICAgb25CZWZvcmVSZW5kZXJHcm91cFN0YXJ0OiBcImJlZm9yZVJlbmRlckdyb3VwU3RhcnRcIixcbiAgICBvbkJlZm9yZVJlbmRlckdyb3VwOiBcImJlZm9yZVJlbmRlckdyb3VwXCIsXG4gICAgb25CZWZvcmVSZW5kZXJHcm91cEVuZDogXCJiZWZvcmVSZW5kZXJHcm91cEVuZFwiXG4gIH0sXG4gIGRyYWdSZWxhdGlvbjogXCJ3ZWFrXCIsXG4gIHNldFRyYW5zZm9ybTogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsXG4gICAgICAgIGlzM2QgPSBfYS5pczNkLFxuICAgICAgICB0YXJnZXQgPSBfYS50YXJnZXQsXG4gICAgICAgIHRhcmdldE1hdHJpeCA9IF9hLnRhcmdldE1hdHJpeDtcbiAgICB2YXIgdHJhbnNmb3JtID0gdGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybTtcbiAgICB2YXIgY3NzTWF0cml4ID0gaXMzZCA/IFwibWF0cml4M2QoXCIgKyB0YXJnZXRNYXRyaXguam9pbihcIixcIikgKyBcIilcIiA6IFwibWF0cml4KFwiICsgY29udmVydE1hdHJpeHRvQ1NTKHRhcmdldE1hdHJpeCwgdHJ1ZSkgKyBcIilcIjtcbiAgICB2YXIgc3RhcnRUcmFuc2Zvcm0gPSAhdHJhbnNmb3JtIHx8IHRyYW5zZm9ybSA9PT0gXCJub25lXCIgPyBjc3NNYXRyaXggOiB0cmFuc2Zvcm07XG4gICAgZS5kYXRhcy5zdGFydFRyYW5zZm9ybXMgPSBpc0lkZW50aXR5TWF0cml4KHN0YXJ0VHJhbnNmb3JtLCBpczNkKSA/IFtdIDogc3BsaXRTcGFjZShzdGFydFRyYW5zZm9ybSk7XG4gIH0sXG4gIHJlc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSkge1xuICAgIGUuZGF0YXMubmV4dFRyYW5zZm9ybXMgPSBlLmRhdGFzLnN0YXJ0VHJhbnNmb3JtcztcbiAgICBlLmRhdGFzLm5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMgPSBbXTtcbiAgfSxcbiAgZmlsbERyYWdTdGFydFBhcmFtczogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgICBlLmRhdGFzLnN0YXJ0VHJhbnNmb3JtcyA9IGlzQXJyYXkodHJhbnNmb3JtKSA/IHRyYW5zZm9ybSA6IHNwbGl0U3BhY2UodHJhbnNmb3JtKTtcbiAgICAgIH0sXG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaFxuICAgIH0pO1xuICB9LFxuICBmaWxsRHJhZ1BhcmFtczogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoXG4gICAgfSk7XG4gIH0sXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0obW92ZWFibGUsIGUpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlclN0YXJ0XCIsIHRoaXMuZmlsbERyYWdTdGFydFBhcmFtcyhtb3ZlYWJsZSwgZSkpO1xuICB9LFxuICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLnJlc2V0VHJhbnNmb3JtKGUpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlclwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaFxuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVuZGVyRW5kXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgaXNEcmFnOiBlLmlzRHJhZ1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gICAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJiZWZvcmVSZW5kZXJhYmxlXCIsIGUpO1xuICAgIHZhciBtb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXM7XG4gICAgdmFyIHBhcmFtcyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGNoaWxkRXZlbnQsIGkpIHtcbiAgICAgIHZhciBjaGlsZE1vdmVhYmxlID0gbW92ZWFibGVzW2ldO1xuXG4gICAgICBfdGhpcy5zZXRUcmFuc2Zvcm0oY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XG5cbiAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ1N0YXJ0UGFyYW1zKGNoaWxkTW92ZWFibGUsIGNoaWxkRXZlbnQpO1xuICAgIH0pO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlckdyb3VwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIGV2ZW50czogcGFyYW1zXG4gICAgfSkpO1xuICB9LFxuICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xuICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcbiAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xuICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XG4gICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcblxuICAgICAgX3RoaXMucmVzZXRUcmFuc2Zvcm0oY2hpbGRFdmVudCk7XG5cbiAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ1BhcmFtcyhjaGlsZE1vdmVhYmxlLCBjaGlsZEV2ZW50KTtcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJHcm91cFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICBldmVudHM6IHBhcmFtc1xuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlckdyb3VwRW5kXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcbiAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxuICAgICAgaXNEcmFnOiBlLmlzRHJhZyxcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cFN0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwRW5kKG1vdmVhYmxlLCBlKTtcbiAgfVxufTtcblxudmFyIFJlbmRlcmFibGUgPSB7XG4gIG5hbWU6IFwicmVuZGVyYWJsZVwiLFxuICBwcm9wczoge30sXG4gIGV2ZW50czoge1xuICAgIG9uUmVuZGVyU3RhcnQ6IFwicmVuZGVyU3RhcnRcIixcbiAgICBvblJlbmRlcjogXCJyZW5kZXJcIixcbiAgICBvblJlbmRlckVuZDogXCJyZW5kZXJFbmRcIixcbiAgICBvblJlbmRlckdyb3VwU3RhcnQ6IFwicmVuZGVyR3JvdXBTdGFydFwiLFxuICAgIG9uUmVuZGVyR3JvdXA6IFwicmVuZGVyR3JvdXBcIixcbiAgICBvblJlbmRlckdyb3VwRW5kOiBcInJlbmRlckdyb3VwRW5kXCJcbiAgfSxcbiAgZHJhZ1JlbGF0aW9uOiBcIndlYWtcIixcbiAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZW5kZXJTdGFydFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaFxuICAgIH0pKTtcbiAgfSxcbiAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyXCIsIHRoaXMuZmlsbERyYWdQYXJhbXMobW92ZWFibGUsIGUpKTtcbiAgfSxcbiAgZHJhZ0FmdGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBpZiAoZS5yZXN1bHRDb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZW5kZXJFbmRcIiwgdGhpcy5maWxsRHJhZ0VuZFBhcmFtcyhtb3ZlYWJsZSwgZSkpO1xuICB9LFxuICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyR3JvdXBTdGFydFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcbiAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xuICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XG4gICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcbiAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ1BhcmFtcyhjaGlsZE1vdmVhYmxlLCBjaGlsZEV2ZW50KTtcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZW5kZXJHcm91cFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXG4gICAgICB0cmFuc2Zvcm06IGdldE5leHRUcmFuc2Zvcm1UZXh0KGUpLFxuICAgICAgZXZlbnRzOiBwYXJhbXNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcbiAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xuICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XG4gICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcbiAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ0VuZFBhcmFtcyhjaGlsZE1vdmVhYmxlLCBjaGlsZEV2ZW50KTtcbiAgICB9KTtcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZW5kZXJHcm91cEVuZFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIGlzRHJhZzogZS5pc0RyYWcsXG4gICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxuICAgICAgZXZlbnRzOiBwYXJhbXNcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0FmdGVyKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiB0aGlzLmRyYWdHcm91cFN0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwRW5kKG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZmlsbERyYWdQYXJhbXM6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIHRyYW5zZm9ybTogZ2V0TmV4dFRyYW5zZm9ybVRleHQoZSlcbiAgICB9KTtcbiAgfSxcbiAgZmlsbERyYWdFbmRQYXJhbXM6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcbiAgICAgIGlzRHJhZzogZS5pc0RyYWdcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJpZ2dlckFibGUobW92ZWFibGUsIGFibGVUeXBlLCBldmVudE9wZXJhdGlvbiwgZXZlbnRBZmZpeCwgZXZlbnRUeXBlLCBlLCByZXF1ZXN0SW5zdGFudCkge1xuICB2YXIgaXNTdGFydCA9IGV2ZW50VHlwZSA9PT0gXCJTdGFydFwiO1xuICB2YXIgdGFyZ2V0ID0gbW92ZWFibGUuc3RhdGUudGFyZ2V0O1xuICB2YXIgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XG5cbiAgaWYgKCF0YXJnZXQgfHwgaXNTdGFydCAmJiBldmVudEFmZml4LmluZGV4T2YoXCJDb250cm9sXCIpID4gLTEgJiYgIWlzUmVxdWVzdCAmJiBtb3ZlYWJsZS5hcmVhRWxlbWVudCA9PT0gZS5pbnB1dEV2ZW50LnRhcmdldCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBcImRyYWdcIiBcIkNvbnRyb2xcIiBcIkFmdGVyXCJcblxuXG4gIHZhciBldmVudE5hbWUgPSBcIlwiICsgZXZlbnRPcGVyYXRpb24gKyBldmVudEFmZml4ICsgZXZlbnRUeXBlO1xuICB2YXIgY29uZGl0aW9uTmFtZSA9IFwiXCIgKyBldmVudE9wZXJhdGlvbiArIGV2ZW50QWZmaXggKyBcIkNvbmRpdGlvblwiO1xuICB2YXIgaXNFbmQgPSBldmVudFR5cGUgPT09IFwiRW5kXCI7XG4gIHZhciBpc0FmdGVyID0gZXZlbnRUeXBlID09PSBcIkFmdGVyXCI7XG4gIHZhciBpc0ZpcnN0U3RhcnQgPSBpc1N0YXJ0ICYmICghbW92ZWFibGUudGFyZ2V0R2VzdG8gfHwgIW1vdmVhYmxlLmNvbnRyb2xHZXN0byB8fCAhbW92ZWFibGUudGFyZ2V0R2VzdG8uaXNGbGFnKCkgfHwgIW1vdmVhYmxlLmNvbnRyb2xHZXN0by5pc0ZsYWcoKSk7XG5cbiAgaWYgKGlzRmlyc3RTdGFydCkge1xuICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QoZXZlbnRUeXBlLCB0cnVlLCBmYWxzZSk7XG4gIH1cblxuICBpZiAoZXZlbnRUeXBlID09PSBcIlwiICYmICFpc1JlcXVlc3QpIHtcbiAgICBjb252ZXJ0RHJhZ0Rpc3QobW92ZWFibGUuc3RhdGUsIGUpO1xuICB9IC8vIGNvbnN0IGlzR3JvdXAgPSBldmVudEFmZml4LmluZGV4T2YoXCJHcm91cFwiKSA+IC0xO1xuXG5cbiAgdmFyIGFibGVzID0gX19zcHJlYWRBcnJheShbXSwgbW92ZWFibGVbYWJsZVR5cGVdKTtcblxuICBpZiAoaXNSZXF1ZXN0KSB7XG4gICAgdmFyIHJlcXVlc3RBYmxlXzEgPSBlLnJlcXVlc3RBYmxlO1xuXG4gICAgaWYgKCFhYmxlcy5zb21lKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICByZXR1cm4gYWJsZS5uYW1lID09PSByZXF1ZXN0QWJsZV8xO1xuICAgIH0pKSB7XG4gICAgICBhYmxlcy5wdXNoLmFwcGx5KGFibGVzLCBtb3ZlYWJsZS5wcm9wcy5hYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGFibGUubmFtZSA9PT0gcmVxdWVzdEFibGVfMTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWFibGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudEFibGVzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtCZWZvcmVSZW5kZXJhYmxlXSwgYWJsZXMpLCBbUmVuZGVyYWJsZV0pLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgIHJldHVybiBhYmxlW2V2ZW50TmFtZV07XG4gIH0pO1xuXG4gIHZhciBkYXRhcyA9IGUuZGF0YXM7XG5cbiAgaWYgKGlzRmlyc3RTdGFydCkge1xuICAgIGV2ZW50QWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgYWJsZS51bnNldCAmJiBhYmxlLnVuc2V0KG1vdmVhYmxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50O1xuICB2YXIgaW5wdXRUYXJnZXQ7XG5cbiAgaWYgKGlzRW5kICYmIGlucHV0RXZlbnQpIHtcbiAgICBpbnB1dFRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpIHx8IGlucHV0RXZlbnQudGFyZ2V0O1xuICB9XG5cbiAgdmFyIHJlc3VsdENvdW50ID0gMDtcbiAgdmFyIHJlc3VsdHMgPSBldmVudEFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgIHZhciBhYmxlTmFtZSA9IGFibGUubmFtZTtcbiAgICB2YXIgbmV4dERhdGFzID0gZGF0YXNbYWJsZU5hbWVdIHx8IChkYXRhc1thYmxlTmFtZV0gPSB7fSk7XG5cbiAgICBpZiAoaXNTdGFydCkge1xuICAgICAgbmV4dERhdGFzLmlzRXZlbnRTdGFydCA9ICFhYmxlW2NvbmRpdGlvbk5hbWVdIHx8IGFibGVbY29uZGl0aW9uTmFtZV0obW92ZWFibGUsIGUpO1xuICAgIH1cblxuICAgIGlmIChuZXh0RGF0YXMuaXNFdmVudFN0YXJ0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYWJsZVtldmVudE5hbWVdKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgICAgcmVzdWx0Q291bnQ6IHJlc3VsdENvdW50LFxuICAgICAgICBkYXRhczogbmV4dERhdGFzLFxuICAgICAgICBvcmlnaW5hbERhdGFzOiBkYXRhcyxcbiAgICAgICAgaW5wdXRUYXJnZXQ6IGlucHV0VGFyZ2V0XG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChpc1N0YXJ0ICYmIHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgbmV4dERhdGFzLmlzRXZlbnRTdGFydCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRDb3VudCArPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgdmFyIGlzVXBkYXRlID0gcmVzdWx0cy5sZW5ndGg7XG4gIHZhciBpc0ZvcmNlRW5kID0gZmFsc2U7IC8vIGVuZCBhYmxlc1xuXG4gIGlmIChpc1N0YXJ0ICYmIGV2ZW50QWJsZXMubGVuZ3RoICYmICFpc1VwZGF0ZSkge1xuICAgIGlzRm9yY2VFbmQgPSBldmVudEFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgdmFyIGFibGVOYW1lID0gYWJsZS5uYW1lO1xuICAgICAgdmFyIG5leHREYXRhcyA9IGRhdGFzW2FibGVOYW1lXTtcblxuICAgICAgaWYgKG5leHREYXRhcy5pc0V2ZW50U3RhcnQpIHtcbiAgICAgICAgaWYgKGFibGUuZHJhZ1JlbGF0aW9uID09PSBcInN0cm9uZ1wiKSB7XG4gICAgICAgICAgLy8gY2FuY2VsIGRyYWdcbiAgICAgICAgICBuZXh0RGF0YXMuaXNFdmVudFN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIHN0YXJ0IGRyYWdcblxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBjYW5jZWwgZXZlbnRcblxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgaWYgKGlzRW5kIHx8IGlzRm9yY2VFbmQpIHtcbiAgICBtb3ZlYWJsZS5zdGF0ZS5nZXN0byA9IG51bGw7XG5cbiAgICBpZiAobW92ZWFibGUubW92ZWFibGVzKSB7XG4gICAgICBtb3ZlYWJsZS5tb3ZlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRNb3ZlYWJsZSkge1xuICAgICAgICBjaGlsZE1vdmVhYmxlLnN0YXRlLmdlc3RvID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0ZpcnN0U3RhcnQgJiYgaXNGb3JjZUVuZCkge1xuICAgIGV2ZW50QWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgYWJsZS51bnNldCAmJiBhYmxlLnVuc2V0KG1vdmVhYmxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc1N0YXJ0ICYmICFpc1JlcXVlc3QgJiYgaXNVcGRhdGUpIHtcbiAgICBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGlmIChtb3ZlYWJsZS5pc1VubW91bnRlZCB8fCBpc0ZvcmNlRW5kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFpc1N0YXJ0ICYmIGlzVXBkYXRlICYmICFyZXF1ZXN0SW5zdGFudCB8fCBpc0VuZCkge1xuICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QoaXNFbmQgPyBldmVudFR5cGUgOiBcIlwiLCB0cnVlLCBmYWxzZSk7XG4gICAgbW92ZWFibGUuZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmICghaXNTdGFydCAmJiAhaXNFbmQgJiYgIWlzQWZ0ZXIgJiYgaXNVcGRhdGUgJiYgIXJlcXVlc3RJbnN0YW50KSB7XG4gICAgdHJpZ2dlckFibGUobW92ZWFibGUsIGFibGVUeXBlLCBldmVudE9wZXJhdGlvbiwgZXZlbnRBZmZpeCwgZXZlbnRUeXBlICsgXCJBZnRlclwiLCBlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0QWJsZUdlc3RvKG1vdmVhYmxlLCBtb3ZlYWJsZVRhcmdldCwgZXZlbnRBZmZpeCkge1xuICB2YXIgY29udHJvbEJveCA9IG1vdmVhYmxlLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpO1xuICB2YXIgdGFyZ2V0cyA9IFtdO1xuICB0YXJnZXRzLnB1c2goY29udHJvbEJveCk7XG5cbiAgaWYgKCFtb3ZlYWJsZS5wcm9wcy5kcmFnQXJlYSB8fCBtb3ZlYWJsZS5wcm9wcy5kcmFnVGFyZ2V0KSB7XG4gICAgdGFyZ2V0cy5wdXNoKG1vdmVhYmxlVGFyZ2V0KTtcbiAgfVxuXG4gIHZhciBzdGFydEZ1bmMgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBldmVudFRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XG4gICAgdmFyIGFyZWFFbGVtZW50ID0gbW92ZWFibGUuYXJlYUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50VGFyZ2V0ID09PSBhcmVhRWxlbWVudCB8fCAhbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoZXZlbnRUYXJnZXQpICYmICFtb3ZlYWJsZS5jb250cm9sQm94LmdldEVsZW1lbnQoKS5jb250YWlucyhldmVudFRhcmdldCkgfHwgaGFzQ2xhc3MoZXZlbnRUYXJnZXQsIFwibW92ZWFibGUtYXJlYVwiKSB8fCBoYXNDbGFzcyhldmVudFRhcmdldCwgXCJtb3ZlYWJsZS1wYWRkaW5nXCIpO1xuICB9O1xuXG4gIHJldHVybiBnZXRBYmxlR2VzdG8obW92ZWFibGUsIHRhcmdldHMsIFwidGFyZ2V0QWJsZXNcIiwgZXZlbnRBZmZpeCwge1xuICAgIGRyYWdTdGFydDogc3RhcnRGdW5jLFxuICAgIHBpbmNoU3RhcnQ6IHN0YXJ0RnVuY1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFibGVHZXN0byhtb3ZlYWJsZSwgdGFyZ2V0LCBhYmxlVHlwZSwgZXZlbnRBZmZpeCwgY29uZGl0aW9uRnVuY3Rpb25zKSB7XG4gIGlmIChjb25kaXRpb25GdW5jdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGNvbmRpdGlvbkZ1bmN0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsXG4gICAgICBwaW5jaE91dHNpZGUgPSBfYS5waW5jaE91dHNpZGUsXG4gICAgICBwaW5jaFRocmVzaG9sZCA9IF9hLnBpbmNoVGhyZXNob2xkO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgY29udGFpbmVyOiB3aW5kb3csXG4gICAgcGluY2hUaHJlc2hvbGQ6IHBpbmNoVGhyZXNob2xkLFxuICAgIHBpbmNoT3V0c2lkZTogcGluY2hPdXRzaWRlXG4gIH07XG4gIHZhciBnZXN0byA9IG5ldyBHZXN0byh0YXJnZXQsIG9wdGlvbnMpO1xuICBbXCJkcmFnXCIsIFwicGluY2hcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRPcGVyYXRpb24pIHtcbiAgICBbXCJTdGFydFwiLCBcIlwiLCBcIkVuZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgIGdlc3RvLm9uKFwiXCIgKyBldmVudE9wZXJhdGlvbiArIGV2ZW50VHlwZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGUuZXZlbnRUeXBlO1xuXG4gICAgICAgIGlmIChjb25kaXRpb25GdW5jdGlvbnNbZXZlbnROYW1lXSAmJiAhY29uZGl0aW9uRnVuY3Rpb25zW2V2ZW50TmFtZV0oZSkpIHtcbiAgICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckFibGUobW92ZWFibGUsIGFibGVUeXBlLCBldmVudE9wZXJhdGlvbiwgZXZlbnRBZmZpeCwgZXZlbnRUeXBlLCBlKTtcblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBnZXN0bztcbn1cblxudmFyIEV2ZW50TWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50TWFuYWdlcih0YXJnZXQsIG1vdmVhYmxlLCBldmVudE5hbWUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5tb3ZlYWJsZSA9IG1vdmVhYmxlO1xuICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgIHRoaXMuYWJsZXMgPSBbXTtcblxuICAgIHRoaXMub25FdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZXZlbnROYW1lID0gX3RoaXMuZXZlbnROYW1lO1xuICAgICAgdmFyIG1vdmVhYmxlID0gX3RoaXMubW92ZWFibGU7XG5cbiAgICAgIGlmIChtb3ZlYWJsZS5zdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5hYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICAgIGFibGVbZXZlbnROYW1lXShtb3ZlYWJsZSwge1xuICAgICAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpLCB0aGlzLm9uRXZlbnQpO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBFdmVudE1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2V0QWJsZXMgPSBmdW5jdGlvbiAoYWJsZXMpIHtcbiAgICB0aGlzLmFibGVzID0gYWJsZXM7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5ldmVudE5hbWUudG9Mb3dlckNhc2UoKSwgdGhpcy5vbkV2ZW50KTtcbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5tb3ZlYWJsZSA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEV2ZW50TWFuYWdlcjtcbn0oKTtcblxudmFyIE1vdmVhYmxlTWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNb3ZlYWJsZU1hbmFnZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTW92ZWFibGVNYW5hZ2VyKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuc3RhdGUgPSBfX2Fzc2lnbih7XG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBnZXN0bzogbnVsbCxcbiAgICAgIHJlbmRlclBvc2VzOiBbWzAsIDBdLCBbMCwgMF0sIFswLCAwXSwgWzAsIDBdXSxcbiAgICAgIGRpc2FibGVOYXRpdmVFdmVudDogZmFsc2VcbiAgICB9LCBnZXRUYXJnZXRJbmZvKG51bGwpKTtcbiAgICBfdGhpcy5lbmFibGVkQWJsZXMgPSBbXTtcbiAgICBfdGhpcy50YXJnZXRBYmxlcyA9IFtdO1xuICAgIF90aGlzLmNvbnRyb2xBYmxlcyA9IFtdO1xuICAgIF90aGlzLnJvdGF0aW9uID0gMDtcbiAgICBfdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgICBfdGhpcy5pc1VubW91bnRlZCA9IGZhbHNlO1xuICAgIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgIFwibW91c2VFbnRlclwiOiBudWxsLFxuICAgICAgXCJtb3VzZUxlYXZlXCI6IG51bGxcbiAgICB9O1xuICAgIF90aGlzLl9wcmV2VGFyZ2V0ID0gbnVsbDtcbiAgICBfdGhpcy5fcHJldkRyYWdBcmVhID0gZmFsc2U7XG4gICAgX3RoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICBfdGhpcy5fb2JzZXJ2ZXJJZCA9IDA7XG5cbiAgICBfdGhpcy5vblByZXZlbnRDbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmVtb3ZlRXZlbnQod2luZG93LCBcImNsaWNrXCIsIF90aGlzLm9uUHJldmVudENsaWNrLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY2hlY2tVcGRhdGVSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IF90aGlzLnByb3BzLnBhcmVudE1vdmVhYmxlO1xuXG4gICAgICBpZiAocGFyZW50TW92ZWFibGUpIHtcbiAgICAgICAgcGFyZW50TW92ZWFibGUuY2hlY2tVcGRhdGVSZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMuX29ic2VydmVySWQpO1xuICAgICAgX3RoaXMuX29ic2VydmVySWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMudXBkYXRlUmVjdCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHBhcmVudFBvc2l0aW9uID0gcHJvcHMucGFyZW50UG9zaXRpb24sXG4gICAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgcHJvcHNUYXJnZXQgPSBwcm9wcy50YXJnZXQsXG4gICAgICAgIHpvb20gPSBwcm9wcy56b29tLFxuICAgICAgICBjc3BOb25jZSA9IHByb3BzLmNzcE5vbmNlLFxuICAgICAgICB0cmFuc2xhdGVaID0gcHJvcHMudHJhbnNsYXRlWixcbiAgICAgICAgQ29udHJvbEJveEVsZW1lbnQgPSBwcm9wcy5jc3NTdHlsZWQsXG4gICAgICAgIHBvcnRhbENvbnRhaW5lciA9IHByb3BzLnBvcnRhbENvbnRhaW5lcjtcbiAgICB0aGlzLmNoZWNrVXBkYXRlKCk7XG4gICAgdGhpcy51cGRhdGVSZW5kZXJQb3NlcygpO1xuXG4gICAgdmFyIF9hID0gcGFyZW50UG9zaXRpb24gfHwge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH0sXG4gICAgICAgIHBhcmVudExlZnQgPSBfYS5sZWZ0LFxuICAgICAgICBwYXJlbnRUb3AgPSBfYS50b3A7XG5cbiAgICB2YXIgbGVmdCA9IHN0YXRlLmxlZnQsXG4gICAgICAgIHRvcCA9IHN0YXRlLnRvcCxcbiAgICAgICAgc3RhdGVUYXJnZXQgPSBzdGF0ZS50YXJnZXQsXG4gICAgICAgIGRpcmVjdGlvbiA9IHN0YXRlLmRpcmVjdGlvbjtcbiAgICB2YXIgZ3JvdXBUYXJnZXRzID0gcHJvcHMudGFyZ2V0cztcbiAgICB2YXIgaXNEaXNwbGF5ID0gKGdyb3VwVGFyZ2V0cyAmJiBncm91cFRhcmdldHMubGVuZ3RoIHx8IHByb3BzVGFyZ2V0KSAmJiBzdGF0ZVRhcmdldDtcbiAgICB2YXIgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZygpO1xuICAgIHZhciBhYmxlQXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuZ2V0RW5hYmxlZEFibGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgYWJsZUF0dHJpYnV0ZXNbXCJkYXRhLWFibGUtXCIgKyBhYmxlLm5hbWUudG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KENvbnRyb2xCb3hFbGVtZW50LCBfX2Fzc2lnbih7XG4gICAgICBjc3BOb25jZTogY3NwTm9uY2UsXG4gICAgICByZWY6IHJlZih0aGlzLCBcImNvbnRyb2xCb3hcIiksXG4gICAgICBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2wtYm94XCIsIGRpcmVjdGlvbiA9PT0gLTEgPyBcInJldmVyc2VcIiA6IFwiXCIsIGlzRHJhZ2dpbmcgPyBcImRyYWdnaW5nXCIgOiBcIlwiKSArIFwiIFwiICsgY2xhc3NOYW1lXG4gICAgfSwgYWJsZUF0dHJpYnV0ZXMsIHtcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25QcmV2ZW50Q2xpY2ssXG4gICAgICBwb3J0YWxDb250YWluZXI6IHBvcnRhbENvbnRhaW5lcixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBcImRpc3BsYXlcIjogaXNEaXNwbGF5ID8gXCJibG9ja1wiIDogXCJub25lXCIsXG4gICAgICAgIFwidHJhbnNmb3JtXCI6IFwidHJhbnNsYXRlM2QoXCIgKyAobGVmdCAtIHBhcmVudExlZnQpICsgXCJweCwgXCIgKyAodG9wIC0gcGFyZW50VG9wKSArIFwicHgsIFwiICsgdHJhbnNsYXRlWiArIFwiKVwiLFxuICAgICAgICBcIi0tem9vbVwiOiB6b29tLFxuICAgICAgICBcIi0tem9vbXB4XCI6IHpvb20gKyBcInB4XCJcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5yZW5kZXJBYmxlcygpLCB0aGlzLl9yZW5kZXJMaW5lcygpKTtcbiAgfTtcblxuICBfX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udHJvbEJveC5nZXRFbGVtZW50KCk7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyZW50TW92ZWFibGUgPSBwcm9wcy5wYXJlbnRNb3ZlYWJsZSxcbiAgICAgICAgY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyLFxuICAgICAgICB3cmFwcGVyTW92ZWFibGUgPSBwcm9wcy53cmFwcGVyTW92ZWFibGU7XG5cbiAgICB0aGlzLl91cGRhdGVUYXJnZXRzKCk7XG5cbiAgICB0aGlzLl91cGRhdGVOYXRpdmVFdmVudHMoKTtcblxuICAgIHRoaXMuX3VwZGF0ZUV2ZW50cygpO1xuXG4gICAgaWYgKCFjb250YWluZXIgJiYgIXBhcmVudE1vdmVhYmxlICYmICF3cmFwcGVyTW92ZWFibGUpIHtcbiAgICAgIHRoaXMudXBkYXRlUmVjdChcIlwiLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVDaGVja0lucHV0KCk7XG5cbiAgICB0aGlzLl91cGRhdGVPYnNlcnZlcih0aGlzLnByb3BzKTtcbiAgfTtcblxuICBfX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICB0aGlzLl91cGRhdGVOYXRpdmVFdmVudHMoKTtcblxuICAgIHRoaXMuX3VwZGF0ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5fdXBkYXRlVGFyZ2V0cygpO1xuXG4gICAgdGhpcy51cGRhdGVDaGVja0lucHV0KCk7XG5cbiAgICB0aGlzLl91cGRhdGVPYnNlcnZlcihwcmV2UHJvcHMpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgdW5zZXQodGhpcywgXCJ0YXJnZXRHZXN0b1wiKTtcbiAgICB1bnNldCh0aGlzLCBcImNvbnRyb2xHZXN0b1wiKTtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgICAgdmFyIG1hbmFnZXIgPSBldmVudHNbbmFtZV07XG4gICAgICBtYW5hZ2VyICYmIG1hbmFnZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgICBwYXJlbnRNb3ZlYWJsZSA9IF9hLnBhcmVudE1vdmVhYmxlLFxuICAgICAgICB3cmFwcGVyTW92ZWFibGUgPSBfYS53cmFwcGVyTW92ZWFibGUsXG4gICAgICAgIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcjtcbiAgICByZXR1cm4gY29udGFpbmVyIHx8IHdyYXBwZXJNb3ZlYWJsZSAmJiB3cmFwcGVyTW92ZWFibGUuZ2V0Q29udGFpbmVyKCkgfHwgcGFyZW50TW92ZWFibGUgJiYgcGFyZW50TW92ZWFibGUuZ2V0Q29udGFpbmVyKCkgfHwgdGhpcy5jb250cm9sQm94LmdldEVsZW1lbnQoKS5wYXJlbnRFbGVtZW50O1xuICB9O1xuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBhbiBlbGVtZW50IGluY2x1ZGVkIGluIHRoZSBtb3ZlYWJsZS5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNpc01vdmVhYmxlRWxlbWVudFxuICAgKiBAcGFyYW0gLSB0aGUgdGFyZ2V0XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAqICAgICBpZiAoIW1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGUudGFyZ2V0KSkge1xuICAgKiAgICAgICAgIG1vdmVhYmxlLnRhcmdldCA9IGUudGFyZ2V0O1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmlzTW92ZWFibGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgJiYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKS5pbmRleE9mKFBSRUZJWCkgPiAtMTtcbiAgfTtcbiAgLyoqXG4gICAqIFlvdSBjYW4gZHJhZyBzdGFydCB0aGUgTW92ZWFibGUgdGhyb3VnaCB0aGUgZXh0ZXJuYWwgYE1vdXNlRXZlbnRgb3IgYFRvdWNoRXZlbnRgLiAoQW5ndWxhcjogbmdEcmFnU3RhcnQpXG4gICAqIEBtZXRob2QgTW92ZWFibGUjZHJhZ1N0YXJ0XG4gICAqIEBwYXJhbSAtIGV4dGVybmFsIGBNb3VzZUV2ZW50YG9yIGBUb3VjaEV2ZW50YFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB7XG4gICAqICAgICBpZiAoIW1vdmVhYmxlLmlzTW92ZWFibGVFbGVtZW50KGUudGFyZ2V0KSkge1xuICAgKiAgICAgICAgICBtb3ZlYWJsZS5kcmFnU3RhcnQoZSk7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy50YXJnZXRHZXN0bykge1xuICAgICAgdGhpcy50YXJnZXRHZXN0by50cmlnZ2VyRHJhZ1N0YXJ0KGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogSGl0IHRlc3QgYW4gZWxlbWVudCBvciByZWN0IG9uIGEgbW92ZWFibGUgdGFyZ2V0LlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2hpdFRlc3RcbiAgICogQHBhcmFtIC0gZWxlbWVudCBvciByZWN0IHRvIHRlc3RcbiAgICogQHJldHVybiAtIEdldCBoaXQgdGVzdCByYXRlIChyYXRlID4gMCBpcyBoaXR0ZWQpXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICogICAgIGlmIChtb3ZlYWJsZS5oaXRUZXN0KGUudGFyZ2V0KSA+IDApIHtcbiAgICogICAgICAgICAgY29uc29sZS5sb2coXCJoaWl0ZWRcIik7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uaGl0VGVzdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgcG9zMSA9IF9hLnBvczEsXG4gICAgICAgIHBvczIgPSBfYS5wb3MyLFxuICAgICAgICBwb3MzID0gX2EucG9zMyxcbiAgICAgICAgcG9zNCA9IF9hLnBvczQsXG4gICAgICAgIHRhcmdldENsaWVudFJlY3QgPSBfYS50YXJnZXRDbGllbnRSZWN0O1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciByZWN0O1xuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgdmFyIGNsaWVudFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJlY3QgPSB7XG4gICAgICAgIGxlZnQ6IGNsaWVudFJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCxcbiAgICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBfX2Fzc2lnbih7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIGVsKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdExlZnQgPSByZWN0LmxlZnQsXG4gICAgICAgIHJlY3RUb3AgPSByZWN0LnRvcCxcbiAgICAgICAgcmVjdFdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgICAgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIHZhciBwb2ludHMgPSBmaXRQb2ludHMoW3BvczEsIHBvczIsIHBvczQsIHBvczNdLCB0YXJnZXRDbGllbnRSZWN0KTtcbiAgICB2YXIgc2l6ZSA9IGdldE92ZXJsYXBTaXplKHBvaW50cywgW1tyZWN0TGVmdCwgcmVjdFRvcF0sIFtyZWN0TGVmdCArIHJlY3RXaWR0aCwgcmVjdFRvcF0sIFtyZWN0TGVmdCArIHJlY3RXaWR0aCwgcmVjdFRvcCArIHJlY3RIZWlnaHRdLCBbcmVjdExlZnQsIHJlY3RUb3AgKyByZWN0SGVpZ2h0XV0pO1xuICAgIHZhciB0b3RhbFNpemUgPSBnZXRBcmVhU2l6ZShwb2ludHMpO1xuXG4gICAgaWYgKCFzaXplIHx8ICF0b3RhbFNpemUpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1pbigxMDAsIHNpemUgLyB0b3RhbFNpemUgKiAxMDApO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSBNb3ZlYWJsZVxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2lzSW5zaWRlXG4gICAqIEBwYXJhbSAtIHggY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0gLSB5IGNvb3JkaW5hdGVcbiAgICogQHJldHVybiAtIFRydWUgaWYgdGhlIGNvb3JkaW5hdGUgaXMgaW4gbW92ZWFibGUgb3IgZmFsc2VcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgKiAgICAgaWYgKG1vdmVhYmxlLmlzSW5zaWRlKGUuY2xpZW50WCwgZS5jbGllbnRZKSkge1xuICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhcImluc2lkZVwiKTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5pc0luc2lkZSA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIF9hID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgdGFyZ2V0ID0gX2EudGFyZ2V0LFxuICAgICAgICBwb3MxID0gX2EucG9zMSxcbiAgICAgICAgcG9zMiA9IF9hLnBvczIsXG4gICAgICAgIHBvczMgPSBfYS5wb3MzLFxuICAgICAgICBwb3M0ID0gX2EucG9zNCxcbiAgICAgICAgdGFyZ2V0Q2xpZW50UmVjdCA9IF9hLnRhcmdldENsaWVudFJlY3Q7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBpc0luc2lkZShbY2xpZW50WCwgY2xpZW50WV0sIGZpdFBvaW50cyhbcG9zMSwgcG9zMiwgcG9zNCwgcG9zM10sIHRhcmdldENsaWVudFJlY3QpKTtcbiAgfTtcbiAgLyoqXG4gICAqIElmIHRoZSB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCBhbmQgdG9wIG9mIGFsbCBlbGVtZW50cyBjaGFuZ2UsIHVwZGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG1vdmVhYmxlLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI3VwZGF0ZVJlY3RcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZSA9PiB7XG4gICAqICAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KCk7XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8udXBkYXRlUmVjdCA9IGZ1bmN0aW9uICh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSkge1xuICAgIGlmIChpc1NldFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIGlzU2V0U3RhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcmVudE1vdmVhYmxlID0gcHJvcHMucGFyZW50TW92ZWFibGU7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0IHx8IHRoaXMucHJvcHMudGFyZ2V0O1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuICAgIHZhciByb290Q29udGFpbmVyID0gcGFyZW50TW92ZWFibGUgPyBwYXJlbnRNb3ZlYWJsZS5wcm9wcy5yb290Q29udGFpbmVyIDogcHJvcHMucm9vdENvbnRhaW5lcjtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKGdldFRhcmdldEluZm8odGhpcy5jb250cm9sQm94ICYmIHRoaXMuY29udHJvbEJveC5nZXRFbGVtZW50KCksIHRhcmdldCwgY29udGFpbmVyLCBjb250YWluZXIsIHJvb3RDb250YWluZXIgfHwgY29udGFpbmVyKSwgcGFyZW50TW92ZWFibGUgPyBmYWxzZSA6IGlzU2V0U3RhdGUpO1xuICB9O1xuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIG1vdmVhYmxlIHN0YXRlIGlzIGJlaW5nIGRyYWdnZWQuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjaXNEcmFnZ2luZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiAvLyBmYWxzZVxuICAgKiBjb25zb2xlLmxvZyhtb3ZlYWJsZS5pc0RyYWdnaW5nKCkpO1xuICAgKlxuICAgKiBtb3ZlYWJsZS5vbihcImRyYWdcIiwgKCkgPT4ge1xuICAgKiAgIC8vIHRydWVcbiAgICogICBjb25zb2xlLmxvZyhtb3ZlYWJsZS5pc0RyYWdnaW5nKCkpO1xuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnRhcmdldEdlc3RvID8gdGhpcy50YXJnZXRHZXN0by5pc0ZsYWcoKSA6IGZhbHNlKSB8fCAodGhpcy5jb250cm9sR2VzdG8gPyB0aGlzLmNvbnRyb2xHZXN0by5pc0ZsYWcoKSA6IGZhbHNlKTtcbiAgfTtcbiAgLyoqXG4gICAqIElmIHRoZSB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCBhbmQgdG9wIG9mIHRoZSBvbmx5IHRhcmdldCBjaGFuZ2UsIHVwZGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG1vdmVhYmxlLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI3VwZGF0ZVRhcmdldFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBtb3ZlYWJsZS51cGRhdGVUYXJnZXQoKTtcbiAgICovXG5cblxuICBfX3Byb3RvLnVwZGF0ZVRhcmdldCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGhpcy51cGRhdGVSZWN0KHR5cGUsIHRydWUpO1xuICB9O1xuICAvKipcbiAgICogWW91IGNhbiBnZXQgdGhlIHZlcnRleCBpbmZvcm1hdGlvbiwgcG9zaXRpb24gYW5kIG9mZnNldCBzaXplIGluZm9ybWF0aW9uIG9mIHRoZSB0YXJnZXQgYmFzZWQgb24gdGhlIGNvbnRhaW5lci5cbiAgICogQG1ldGhvZCBNb3ZlYWJsZSNnZXRSZWN0XG4gICAqIEByZXR1cm4gLSBUaGUgUmVjdCBJbmZvXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIGNvbnN0IHJlY3RJbmZvID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKHRoaXMuc3RhdGUpO1xuICAgIHZhciBwb3MxID0gcG9zZXNbMF0sXG4gICAgICAgIHBvczIgPSBwb3Nlc1sxXSxcbiAgICAgICAgcG9zMyA9IHBvc2VzWzJdLFxuICAgICAgICBwb3M0ID0gcG9zZXNbM107XG4gICAgdmFyIHJlY3QgPSBnZXRSZWN0KHBvc2VzKTtcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSBzdGF0ZS53aWR0aCxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3AgPSByZWN0LnRvcDtcbiAgICB2YXIgc3RhdGVQb3MgPSBbc3RhdGUubGVmdCwgc3RhdGUudG9wXTtcbiAgICB2YXIgb3JpZ2luID0gcGx1cyhzdGF0ZVBvcywgc3RhdGUub3JpZ2luKTtcbiAgICB2YXIgYmVmb3JlT3JpZ2luID0gcGx1cyhzdGF0ZVBvcywgc3RhdGUuYmVmb3JlT3JpZ2luKTtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHBvczE6IHBvczEsXG4gICAgICBwb3MyOiBwb3MyLFxuICAgICAgcG9zMzogcG9zMyxcbiAgICAgIHBvczQ6IHBvczQsXG4gICAgICBvZmZzZXRXaWR0aDogb2Zmc2V0V2lkdGgsXG4gICAgICBvZmZzZXRIZWlnaHQ6IG9mZnNldEhlaWdodCxcbiAgICAgIGJlZm9yZU9yaWdpbjogYmVmb3JlT3JpZ2luLFxuICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKClcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogR2V0IGEgbWFuYWdlciB0aGF0IG1hbmFnZXMgdGhlIG1vdmVhYmxlJ3Mgc3RhdGUgYW5kIHByb3BzLlxuICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldE1hbmFnZXJcbiAgICogQHJldHVybiAtIFRoZSBSZWN0IEluZm9cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICAgKlxuICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAgICpcbiAgICogY29uc3QgbWFuYWdlciA9IG1vdmVhYmxlLmdldE1hbmFnZXIoKTsgLy8gcmVhbCBtb3ZlYWJsZSBjbGFzcyBpbnN0YW5jZVxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHBvczEgPSBfYS5wb3MxLFxuICAgICAgICBwb3MyID0gX2EucG9zMixcbiAgICAgICAgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuICAgIHJldHVybiBnZXRBYnNvbHV0ZVJvdGF0aW9uKHBvczEsIHBvczIsIGRpcmVjdGlvbik7XG4gIH07XG4gIC8qKlxuICAgKiBSZXF1ZXN0IGFibGUgdGhyb3VnaCBhIG1ldGhvZCByYXRoZXIgdGhhbiBhbiBldmVudC5cbiAgICogQXQgdGhlIG1vbWVudCBvZiBleGVjdXRpb24sIHJlcXVlc3RTdGFydCBpcyBleGVjdXRlZCxcbiAgICogYW5kIHRoZW4gcmVxdWVzdCBhbmQgcmVxdWVzdEVuZCBjYW4gYmUgZXhlY3V0ZWQgdGhyb3VnaCBSZXF1ZXN0ZXIuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjcmVxdWVzdFxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuRHJhZ2dhYmxlLmh0bWwjcmVxdWVzdHxEcmFnZ2FibGUgUmVxdWVzdGVyfVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuUmVzaXphYmxlLmh0bWwjcmVxdWVzdHxSZXNpemFibGUgUmVxdWVzdGVyfVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU2NhbGFibGUuaHRtbCNyZXF1ZXN0fFNjYWxhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlJvdGF0YWJsZS5odG1sI3JlcXVlc3R8Um90YXRhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5odG1sI3JlcXVlc3R8T3JpZ2luRHJhZ2dhYmxlIFJlcXVlc3Rlcn1cbiAgICogQHBhcmFtIC0gYWJsZU5hbWVcbiAgICogQHBhcmFtIC0gcmVxdWVzdCB0byBiZSBhYmxlIHBhcmFtcy5cbiAgICogQHBhcmFtIC0gSWYgaXNJbnN0YW50IGlzIHRydWUsIHJlcXVlc3QgYW5kIHJlcXVlc3RFbmQgYXJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgKiBAcmV0dXJuIC0gQWJsZSBSZXF1ZXN0ZXIuIElmIHRoZXJlIGlzIG5vIHJlcXVlc3QgaW4gYWJsZSwgbm90aGluZyB3aWxsIHdvcmsuXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAgICpcbiAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gICAqXG4gICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcbiAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSwgdHJ1ZSk7XG4gICAqXG4gICAqIC8vIFN0YXJ0IG1vdmVcbiAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiKTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xuICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XG4gICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcbiAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcbiAgICovXG5cblxuICBfX3Byb3RvLnJlcXVlc3QgPSBmdW5jdGlvbiAoYWJsZU5hbWUsIHBhcmFtLCBpc0luc3RhbnQpIHtcbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgICBhYmxlcyA9IF9hLmFibGVzLFxuICAgICAgICBncm91cGFibGUgPSBfYS5ncm91cGFibGU7XG4gICAgdmFyIHJlcXVzZXRBYmxlID0gYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICByZXR1cm4gYWJsZS5uYW1lID09PSBhYmxlTmFtZTtcbiAgICB9KVswXTtcblxuICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhcmVxdXNldEFibGUgfHwgIXJlcXVzZXRBYmxlLnJlcXVlc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWJsZVJlcXVlc3RlciA9IHJlcXVzZXRBYmxlLnJlcXVlc3QodGhpcyk7XG4gICAgdmFyIHJlcXVlc3RJbnN0YW50ID0gaXNJbnN0YW50IHx8IHBhcmFtLmlzSW5zdGFudDtcbiAgICB2YXIgYWJsZVR5cGUgPSBhYmxlUmVxdWVzdGVyLmlzQ29udHJvbCA/IFwiY29udHJvbEFibGVzXCIgOiBcInRhcmdldEFibGVzXCI7XG4gICAgdmFyIGV2ZW50QWZmaXggPSBcIlwiICsgKGdyb3VwYWJsZSA/IFwiR3JvdXBcIiA6IFwiXCIpICsgKGFibGVSZXF1ZXN0ZXIuaXNDb250cm9sID8gXCJDb250cm9sXCIgOiBcIlwiKTtcbiAgICB2YXIgcmVxdWVzdGVyID0ge1xuICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGFibGVQYXJhbSkge1xuICAgICAgICB0cmlnZ2VyQWJsZShzZWxmLCBhYmxlVHlwZSwgXCJkcmFnXCIsIGV2ZW50QWZmaXgsIFwiXCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhYmxlUmVxdWVzdGVyLnJlcXVlc3QoYWJsZVBhcmFtKSksIHtcbiAgICAgICAgICByZXF1ZXN0QWJsZTogYWJsZU5hbWUsXG4gICAgICAgICAgaXNSZXF1ZXN0OiB0cnVlXG4gICAgICAgIH0pLCByZXF1ZXN0SW5zdGFudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJpZ2dlckFibGUoc2VsZiwgYWJsZVR5cGUsIFwiZHJhZ1wiLCBldmVudEFmZml4LCBcIkVuZFwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYWJsZVJlcXVlc3Rlci5yZXF1ZXN0RW5kKCkpLCB7XG4gICAgICAgICAgcmVxdWVzdEFibGU6IGFibGVOYW1lLFxuICAgICAgICAgIGlzUmVxdWVzdDogdHJ1ZVxuICAgICAgICB9KSwgcmVxdWVzdEluc3RhbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyaWdnZXJBYmxlKHNlbGYsIGFibGVUeXBlLCBcImRyYWdcIiwgZXZlbnRBZmZpeCwgXCJTdGFydFwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYWJsZVJlcXVlc3Rlci5yZXF1ZXN0U3RhcnQocGFyYW0pKSwge1xuICAgICAgcmVxdWVzdEFibGU6IGFibGVOYW1lLFxuICAgICAgaXNSZXF1ZXN0OiB0cnVlXG4gICAgfSksIHJlcXVlc3RJbnN0YW50KTtcbiAgICByZXR1cm4gcmVxdWVzdEluc3RhbnQgPyByZXF1ZXN0ZXIucmVxdWVzdChwYXJhbSkucmVxdWVzdEVuZCgpIDogcmVxdWVzdGVyO1xuICB9O1xuICAvKipcbiAgICogUmVtb3ZlIHRoZSBNb3ZlYWJsZSBvYmplY3QgYW5kIHRoZSBldmVudHMuXG4gICAqIEBtZXRob2QgTW92ZWFibGUjZGVzdHJveVxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gICAqXG4gICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICAgKlxuICAgKiBtb3ZlYWJsZS5kZXN0cm95KCk7XG4gICAqL1xuXG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZVJlbmRlclBvc2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgb3JpZ2luYWxCZWZvcmVPcmlnaW4gPSBzdGF0ZS5vcmlnaW5hbEJlZm9yZU9yaWdpbixcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luLFxuICAgICAgICBhbGxNYXRyaXggPSBzdGF0ZS5hbGxNYXRyaXgsXG4gICAgICAgIGlzM2QgPSBzdGF0ZS5pczNkLFxuICAgICAgICBwb3MxID0gc3RhdGUucG9zMSxcbiAgICAgICAgcG9zMiA9IHN0YXRlLnBvczIsXG4gICAgICAgIHBvczMgPSBzdGF0ZS5wb3MzLFxuICAgICAgICBwb3M0ID0gc3RhdGUucG9zNCxcbiAgICAgICAgc3RhdGVMZWZ0ID0gc3RhdGUubGVmdCxcbiAgICAgICAgc3RhdGVUb3AgPSBzdGF0ZS50b3A7XG5cbiAgICB2YXIgX2EgPSBwcm9wcy5wYWRkaW5nIHx8IHt9LFxuICAgICAgICBfYiA9IF9hLmxlZnQsXG4gICAgICAgIGxlZnQgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgICBfYyA9IF9hLnRvcCxcbiAgICAgICAgdG9wID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgICAgX2QgPSBfYS5ib3R0b20sXG4gICAgICAgIGJvdHRvbSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsXG4gICAgICAgIF9lID0gX2EucmlnaHQsXG4gICAgICAgIHJpZ2h0ID0gX2UgPT09IHZvaWQgMCA/IDAgOiBfZTtcblxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xuICAgIHZhciBhYnNvbHV0ZU9yaWdpbiA9IHByb3BzLmdyb3VwYWJsZSA/IG9yaWdpbmFsQmVmb3JlT3JpZ2luIDogcGx1cyhvcmlnaW5hbEJlZm9yZU9yaWdpbiwgW3N0YXRlTGVmdCwgc3RhdGVUb3BdKTtcbiAgICBzdGF0ZS5yZW5kZXJQb3NlcyA9IFtwbHVzKHBvczEsIGNhbGN1bGF0ZVBhZGRpbmcoYWxsTWF0cml4LCBbLWxlZnQsIC10b3BdLCB0cmFuc2Zvcm1PcmlnaW4sIGFic29sdXRlT3JpZ2luLCBuKSksIHBsdXMocG9zMiwgY2FsY3VsYXRlUGFkZGluZyhhbGxNYXRyaXgsIFtyaWdodCwgLXRvcF0sIHRyYW5zZm9ybU9yaWdpbiwgYWJzb2x1dGVPcmlnaW4sIG4pKSwgcGx1cyhwb3MzLCBjYWxjdWxhdGVQYWRkaW5nKGFsbE1hdHJpeCwgWy1sZWZ0LCBib3R0b21dLCB0cmFuc2Zvcm1PcmlnaW4sIGFic29sdXRlT3JpZ2luLCBuKSksIHBsdXMocG9zNCwgY2FsY3VsYXRlUGFkZGluZyhhbGxNYXRyaXgsIFtyaWdodCwgYm90dG9tXSwgdHJhbnNmb3JtT3JpZ2luLCBhYnNvbHV0ZU9yaWdpbiwgbikpXTtcbiAgfTtcblxuICBfX3Byb3RvLmNoZWNrVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIHRhcmdldCA9IF9hLnRhcmdldCxcbiAgICAgICAgY29udGFpbmVyID0gX2EuY29udGFpbmVyLFxuICAgICAgICBwYXJlbnRNb3ZlYWJsZSA9IF9hLnBhcmVudE1vdmVhYmxlO1xuICAgIHZhciBfYiA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXRlVGFyZ2V0ID0gX2IudGFyZ2V0LFxuICAgICAgICBzdGF0ZUNvbnRhaW5lciA9IF9iLmNvbnRhaW5lcjtcblxuICAgIGlmICghc3RhdGVUYXJnZXQgJiYgIXRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQWJsZXMoKTtcbiAgICB2YXIgaXNDaGFuZ2VkID0gIWVxdWFscyhzdGF0ZVRhcmdldCwgdGFyZ2V0KSB8fCAhZXF1YWxzKHN0YXRlQ29udGFpbmVyLCBjb250YWluZXIpO1xuXG4gICAgaWYgKCFpc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbW92ZWFibGVDb250YWluZXIgPSBjb250YWluZXIgfHwgdGhpcy5jb250cm9sQm94O1xuXG4gICAgaWYgKG1vdmVhYmxlQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnVuc2V0QWJsZXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgICB9KTtcblxuICAgIGlmICghcGFyZW50TW92ZWFibGUgJiYgbW92ZWFibGVDb250YWluZXIpIHtcbiAgICAgIHRoaXMudXBkYXRlUmVjdChcIkVuZFwiLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBlKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5wcm9wc1tuYW1lXTtcbiAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soZSk7XG4gIH07XG5cbiAgX19wcm90by51c2VDU1MgPSBmdW5jdGlvbiAodGFnLCBjc3MpIHtcbiAgICB2YXIgY3VzdG9tU3R5bGVNYXAgPSB0aGlzLnByb3BzLmN1c3RvbVN0eWxlZE1hcDtcbiAgICB2YXIga2V5ID0gdGFnICsgY3NzO1xuXG4gICAgaWYgKCFjdXN0b21TdHlsZU1hcFtrZXldKSB7XG4gICAgICBjdXN0b21TdHlsZU1hcFtrZXldID0gc3R5bGVkKHRhZywgY3NzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VzdG9tU3R5bGVNYXBba2V5XTtcbiAgfTtcblxuICBfX3Byb3RvLnVuc2V0QWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMudGFyZ2V0QWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYWJsZSkge1xuICAgICAgaWYgKGFibGUudW5zZXQpIHtcbiAgICAgICAgYWJsZS51bnNldChfdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by51cGRhdGVBYmxlcyA9IGZ1bmN0aW9uIChhYmxlcywgZXZlbnRBZmZpeCkge1xuICAgIGlmIChhYmxlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBhYmxlcyA9IHRoaXMucHJvcHMuYWJsZXM7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50QWZmaXggPT09IHZvaWQgMCkge1xuICAgICAgZXZlbnRBZmZpeCA9IFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHkgPSBwcm9wcy50cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseTtcbiAgICB2YXIgZW5hYmxlZEFibGVzID0gYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICByZXR1cm4gYWJsZSAmJiAoYWJsZS5hbHdheXMgJiYgcHJvcHNbYWJsZS5uYW1lXSAhPT0gZmFsc2UgfHwgcHJvcHNbYWJsZS5uYW1lXSk7XG4gICAgfSk7XG4gICAgdmFyIGRyYWdTdGFydCA9IFwiZHJhZ1wiICsgZXZlbnRBZmZpeCArIFwiU3RhcnRcIjtcbiAgICB2YXIgcGluY2hTdGFydCA9IFwicGluY2hcIiArIGV2ZW50QWZmaXggKyBcIlN0YXJ0XCI7XG4gICAgdmFyIGRyYWdDb250cm9sU3RhcnQgPSBcImRyYWdcIiArIGV2ZW50QWZmaXggKyBcIkNvbnRyb2xTdGFydFwiO1xuICAgIHZhciB0YXJnZXRBYmxlcyA9IGZpbHRlckFibGVzKGVuYWJsZWRBYmxlcywgW2RyYWdTdGFydCwgcGluY2hTdGFydF0sIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5KTtcbiAgICB2YXIgY29udHJvbEFibGVzID0gZmlsdGVyQWJsZXMoZW5hYmxlZEFibGVzLCBbZHJhZ0NvbnRyb2xTdGFydF0sIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5KTtcbiAgICB0aGlzLmVuYWJsZWRBYmxlcyA9IGVuYWJsZWRBYmxlcztcbiAgICB0aGlzLnRhcmdldEFibGVzID0gdGFyZ2V0QWJsZXM7XG4gICAgdGhpcy5jb250cm9sQWJsZXMgPSBjb250cm9sQWJsZXM7XG4gIH07XG5cbiAgX19wcm90by51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uIChuZXh0U3RhdGUsIGlzU2V0U3RhdGUpIHtcbiAgICBpZiAoaXNTZXRTdGF0ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIG5leHRTdGF0ZSkge1xuICAgICAgICBzdGF0ZVtuYW1lXSA9IG5leHRTdGF0ZVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5nZXRFbmFibGVkQWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgYWJsZXMgPSBwcm9wcy5hYmxlcztcbiAgICByZXR1cm4gYWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7XG4gICAgICByZXR1cm4gYWJsZSAmJiBwcm9wc1thYmxlLm5hbWVdO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVuZGVyQWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5ID0gcHJvcHMudHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHk7XG4gICAgdmFyIFJlbmRlcmVyID0ge1xuICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFxuICAgIH07XG4gICAgcmV0dXJuIGdyb3VwQnlNYXAoZmxhdChmaWx0ZXJBYmxlcyh0aGlzLmdldEVuYWJsZWRBYmxlcygpLCBbXCJyZW5kZXJcIl0sIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5KS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgcmVuZGVyID0gX2EucmVuZGVyO1xuICAgICAgcmV0dXJuIHJlbmRlcihfdGhpcywgUmVuZGVyZXIpIHx8IFtdO1xuICAgIH0pKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSksIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGtleSA9IF9hLmtleTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgcmV0dXJuIGdyb3VwWzBdO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlQ2hlY2tJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRhcmdldEdlc3RvICYmICh0aGlzLnRhcmdldEdlc3RvLm9wdGlvbnMuY2hlY2tJbnB1dCA9IHRoaXMucHJvcHMuY2hlY2tJbnB1dCk7XG4gIH07XG5cbiAgX19wcm90by5fdXBkYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuXG4gICAgaWYgKCF3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgfHwgIXRhcmdldCB8fCAhcHJvcHMudXNlUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIChfYSA9IHRoaXMuX29ic2VydmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcmV2UHJvcHMudGFyZ2V0ID09PSB0YXJnZXQgJiYgdGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5jaGVja1VwZGF0ZVJlY3QpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCB7XG4gICAgICBib3g6IFwiYm9yZGVyLWJveFwiXG4gICAgfSk7XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX19wcm90by5fdXBkYXRlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250cm9sQm94RWxlbWVudCA9IHRoaXMuY29udHJvbEJveC5nZXRFbGVtZW50KCk7XG4gICAgdmFyIGhhc1RhcmdldEFibGUgPSB0aGlzLnRhcmdldEFibGVzLmxlbmd0aDtcbiAgICB2YXIgaGFzQ29udHJvbEFibGUgPSB0aGlzLmNvbnRyb2xBYmxlcy5sZW5ndGg7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMuZHJhZ1RhcmdldCB8fCBwcm9wcy50YXJnZXQ7XG5cbiAgICB2YXIgaXNVbnNldCA9ICFoYXNUYXJnZXRBYmxlICYmIHRoaXMudGFyZ2V0R2VzdG8gfHwgdGhpcy5faXNUYXJnZXRDaGFuZ2VkKHRydWUpO1xuXG4gICAgaWYgKGlzVW5zZXQpIHtcbiAgICAgIHVuc2V0KHRoaXMsIFwidGFyZ2V0R2VzdG9cIik7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZ2VzdG86IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaGFzQ29udHJvbEFibGUpIHtcbiAgICAgIHVuc2V0KHRoaXMsIFwiY29udHJvbEdlc3RvXCIpO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQgJiYgaGFzVGFyZ2V0QWJsZSAmJiAhdGhpcy50YXJnZXRHZXN0bykge1xuICAgICAgdGhpcy50YXJnZXRHZXN0byA9IGdldFRhcmdldEFibGVHZXN0byh0aGlzLCB0YXJnZXQsIFwiXCIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sR2VzdG8gJiYgaGFzQ29udHJvbEFibGUpIHtcbiAgICAgIHRoaXMuY29udHJvbEdlc3RvID0gZ2V0QWJsZUdlc3RvKHRoaXMsIGNvbnRyb2xCb3hFbGVtZW50LCBcImNvbnRyb2xBYmxlc1wiLCBcIkNvbnRyb2xcIik7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZVRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLl9wcmV2VGFyZ2V0ID0gcHJvcHMuZHJhZ1RhcmdldCB8fCBwcm9wcy50YXJnZXQ7XG4gICAgdGhpcy5fcHJldkRyYWdBcmVhID0gcHJvcHMuZHJhZ0FyZWE7XG4gIH07XG5cbiAgX19wcm90by5fcmVuZGVyTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgZWRnZSA9IHByb3BzLmVkZ2UsXG4gICAgICAgIHpvb20gPSBwcm9wcy56b29tLFxuICAgICAgICBoaWRlRGVmYXVsdExpbmVzID0gcHJvcHMuaGlkZURlZmF1bHRMaW5lcztcblxuICAgIGlmIChoaWRlRGVmYXVsdExpbmVzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlclBvc2VzID0gdGhpcy5zdGF0ZS5yZW5kZXJQb3NlcztcbiAgICB2YXIgUmVuZGVyZXIgPSB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50XG4gICAgfTtcbiAgICByZXR1cm4gW3JlbmRlckxpbmUoUmVuZGVyZXIsIGVkZ2UgPyBcIm5cIiA6IFwiXCIsIHJlbmRlclBvc2VzWzBdLCByZW5kZXJQb3Nlc1sxXSwgem9vbSwgMCksIHJlbmRlckxpbmUoUmVuZGVyZXIsIGVkZ2UgPyBcImVcIiA6IFwiXCIsIHJlbmRlclBvc2VzWzFdLCByZW5kZXJQb3Nlc1szXSwgem9vbSwgMSksIHJlbmRlckxpbmUoUmVuZGVyZXIsIGVkZ2UgPyBcIndcIiA6IFwiXCIsIHJlbmRlclBvc2VzWzBdLCByZW5kZXJQb3Nlc1syXSwgem9vbSwgMiksIHJlbmRlckxpbmUoUmVuZGVyZXIsIGVkZ2UgPyBcInNcIiA6IFwiXCIsIHJlbmRlclBvc2VzWzJdLCByZW5kZXJQb3Nlc1szXSwgem9vbSwgMyldO1xuICB9O1xuXG4gIF9fcHJvdG8uX2lzVGFyZ2V0Q2hhbmdlZCA9IGZ1bmN0aW9uICh1c2VEcmFnQXJlYSkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQgfHwgcHJvcHMudGFyZ2V0O1xuICAgIHZhciBwcmV2VGFyZ2V0ID0gdGhpcy5fcHJldlRhcmdldDtcbiAgICB2YXIgcHJldkRyYWdBcmVhID0gdGhpcy5fcHJldkRyYWdBcmVhO1xuICAgIHZhciBkcmFnQXJlYSA9IHByb3BzLmRyYWdBcmVhOyAvLyBjaGVjayB0YXJnZXQgd2l0aG91dCBkcmFnQXJlYVxuXG4gICAgdmFyIGlzVGFyZ2V0Q2hhbmdlZCA9ICFkcmFnQXJlYSAmJiBwcmV2VGFyZ2V0ICE9PSB0YXJnZXQ7XG4gICAgdmFyIGlzRHJhZ0FyZWFDaGFuZ2VkID0gKHVzZURyYWdBcmVhIHx8IGRyYWdBcmVhKSAmJiBwcmV2RHJhZ0FyZWEgIT09IGRyYWdBcmVhO1xuICAgIHJldHVybiBpc1RhcmdldENoYW5nZWQgfHwgaXNEcmFnQXJlYUNoYW5nZWQ7XG4gIH07XG5cbiAgX19wcm90by5fdXBkYXRlTmF0aXZlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0YXJnZXQgPSBwcm9wcy5kcmFnQXJlYSA/IHRoaXMuYXJlYUVsZW1lbnQgOiB0aGlzLnN0YXRlLnRhcmdldDtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgdmFyIGV2ZW50S2V5cyA9IGdldEtleXMoZXZlbnRzKTtcblxuICAgIGlmICh0aGlzLl9pc1RhcmdldENoYW5nZWQoKSkge1xuICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cykge1xuICAgICAgICB2YXIgbWFuYWdlciA9IGV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgICBtYW5hZ2VyICYmIG1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW5hYmxlZEFibGVzID0gdGhpcy5lbmFibGVkQWJsZXM7XG4gICAgZXZlbnRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGFibGVzID0gZmlsdGVyQWJsZXMoZW5hYmxlZEFibGVzLCBbZXZlbnROYW1lXSk7XG4gICAgICB2YXIgaGFzQWJsZXMgPSBhYmxlcy5sZW5ndGggPiAwO1xuICAgICAgdmFyIG1hbmFnZXIgPSBldmVudHNbZXZlbnROYW1lXTtcblxuICAgICAgaWYgKCFoYXNBYmxlcykge1xuICAgICAgICBpZiAobWFuYWdlcikge1xuICAgICAgICAgIG1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtYW5hZ2VyKSB7XG4gICAgICAgIG1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKHRhcmdldCwgX3RoaXMsIGV2ZW50TmFtZSk7XG4gICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0gbWFuYWdlcjtcbiAgICAgIH1cblxuICAgICAgbWFuYWdlci5zZXRBYmxlcyhhYmxlcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgTW92ZWFibGVNYW5hZ2VyLmRlZmF1bHRQcm9wcyA9IHtcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgZHJhZ1RhcmdldDogbnVsbCxcbiAgICBjb250YWluZXI6IG51bGwsXG4gICAgcm9vdENvbnRhaW5lcjogbnVsbCxcbiAgICBvcmlnaW46IHRydWUsXG4gICAgZWRnZTogZmFsc2UsXG4gICAgcGFyZW50TW92ZWFibGU6IG51bGwsXG4gICAgd3JhcHBlck1vdmVhYmxlOiBudWxsLFxuICAgIHBhcmVudFBvc2l0aW9uOiBudWxsLFxuICAgIHBvcnRhbENvbnRhaW5lcjogbnVsbCxcbiAgICB1c2VSZXNpemVPYnNlcnZlcjogZmFsc2UsXG4gICAgYWJsZXM6IFtdLFxuICAgIHBpbmNoVGhyZXNob2xkOiAyMCxcbiAgICBkcmFnQXJlYTogZmFsc2UsXG4gICAgcGFzc0RyYWdBcmVhOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IFwiXCIsXG4gICAgY2xhc3NOYW1lOiBcIlwiLFxuICAgIHpvb206IDEsXG4gICAgdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHk6IGZhbHNlLFxuICAgIHBhZGRpbmc6IHt9LFxuICAgIHBpbmNoT3V0c2lkZTogdHJ1ZSxcbiAgICBjaGVja0lucHV0OiBmYWxzZSxcbiAgICBncm91cGFibGU6IGZhbHNlLFxuICAgIGhpZGVEZWZhdWx0TGluZXM6IGZhbHNlLFxuICAgIGNzcE5vbmNlOiBcIlwiLFxuICAgIHRyYW5zbGF0ZVo6IDAsXG4gICAgY3NzU3R5bGVkOiBudWxsLFxuICAgIGN1c3RvbVN0eWxlZE1hcDoge30sXG4gICAgcHJvcHM6IHt9XG4gIH07XG4gIHJldHVybiBNb3ZlYWJsZU1hbmFnZXI7XG59KFB1cmVDb21wb25lbnQpO1xuLyoqXG4gKiBUaGUgdGFyZ2V0IHRvIGluZGljYXRlIE1vdmVhYmxlIENvbnRyb2wgQm94LlxuICogQG5hbWUgTW92ZWFibGUjdGFyZ2V0XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICogbW92ZWFibGUudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIik7XG4gKi9cblxuLyoqXG4gKiBab29tcyBpbiB0aGUgZWxlbWVudHMgb2YgYSBtb3ZlYWJsZS5cbiAqIEBuYW1lIE1vdmVhYmxlI3pvb21cbiAqIEBkZWZhdWx0IDFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKiBtb3ZlYWJsZS56b29tID0gMjtcbiAqL1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIHRhcmdldCBzaXplIGlzIGRldGVjdGVkIGFuZCB1cGRhdGVkIHdoZW5ldmVyIGl0IGNoYW5nZXMuXG4gKiBAbmFtZSBNb3ZlYWJsZSN6b29tXG4gKiBAZGVmYXVsdCBmYWxzZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcbiAqIG1vdmVhYmxlLnVzZVJlc2l6ZU9ic2VydmVyID0gdHJ1ZTtcbiAqL1xuXG4vKipcbiAqIFJlc2l6ZSwgU2NhbGUgRXZlbnRzIGF0IGVkZ2VzXG4gKiBAbmFtZSBNb3ZlYWJsZSNlZGdlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xuICogbW92ZWFibGUuZWRnZSA9IHRydWU7XG4gKi9cblxuLyoqXG4gKiBZb3UgY2FuIHNwZWNpZnkgdGhlIGNsYXNzTmFtZSBvZiB0aGUgbW92ZWFibGUgY29udHJvbGJveC5cbiAqIEBuYW1lIE1vdmVhYmxlI2NsYXNzTmFtZVxuICogQGRlZmF1bHQgXCJcIlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgIGNsYXNzTmFtZTogXCJcIixcbiAqIH0pO1xuICpcbiAqIG1vdmVhYmxlLmNsYXNzTmFtZSA9IFwibW92ZWFibGUxXCI7XG4gKi9cblxuLyoqXG4gKiBUaGUgdGFyZ2V0KHMpIHRvIGRyYWcgTW92ZWFibGUgdGFyZ2V0KHMpXG4gKiBAbmFtZSBNb3ZlYWJsZSNkcmFnVGFyZ2V0XG4gKiBAZGVmYXVsdCB0YXJnZXRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XG4gKiBtb3ZlYWJsZS50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKTtcbiAqIG1vdmVhYmxlLmRyYWdUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmRyYWdUYXJnZXRcIik7XG4gKi9cblxuLyoqXG4gKiBgcmVuZGVyU3RhcnRgIGV2ZW50IG9jY3VycyBhdCB0aGUgZmlyc3Qgc3RhcnQgb2YgYWxsIGV2ZW50cy5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IHJlbmRlclN0YXJ0XG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJTdGFydGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyU3RhcnRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVuZGVyU3RhcnRcIiwgdGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogYHJlbmRlcmAgZXZlbnQgb2NjdXJzIGJlZm9yZSB0aGUgdGFyZ2V0IGlzIGRyYXduIG9uIHRoZSBzY3JlZW4uXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcbiAqIEBldmVudCByZW5kZXJcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25SZW5kZXJ9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJgIGV2ZW50XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxuICogfSk7XG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlclwiLCAoeyB0YXJnZXQgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJcIiwgdGFyZ2V0KTtcbiAqIH0pO1xuICovXG5cbi8qKlxuICogYHJlbmRlckVuZGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBlbmQgb2YgYWxsIGV2ZW50cy5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IHJlbmRlckVuZFxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlckVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlbmRlckVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyRW5kXCIsICh7IHRhcmdldCB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlckVuZFwiLCB0YXJnZXQpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBgcmVuZGVyR3JvdXBTdGFydGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBmaXJzdCBzdGFydCBvZiBhbGwgZXZlbnRzIGluIGdyb3VwLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZXZlbnQgcmVuZGVyR3JvdXBTdGFydFxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlckdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJHcm91cFN0YXJ0YCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyZW5kZXJHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBgcmVuZGVyR3JvdXBgIGV2ZW50IG9jY3VycyBiZWZvcmUgdGhlIHRhcmdldCBpcyBkcmF3biBvbiB0aGUgc2NyZWVuIGluIGdyb3VwLlxuICogQG1lbWJlcm9mIE1vdmVhYmxlXG4gKiBAZXZlbnQgcmVuZGVyR3JvdXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25SZW5kZXJHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlbmRlckdyb3VwYCBldmVudFxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcbiAqXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcbiAqIH0pO1xuICogbW92ZWFibGUub24oXCJyZW5kZXJHcm91cFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVuZGVyR3JvdXBcIiwgdGFyZ2V0cyk7XG4gKiB9KTtcbiAqL1xuXG4vKipcbiAqIGByZW5kZXJHcm91cEVuZGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBlbmQgb2YgYWxsIGV2ZW50cyBpbiBncm91cC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IHJlbmRlckdyb3VwRW5kXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJHcm91cEVuZGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwicmVuZGVyR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlckdyb3VwRW5kXCIsIHRhcmdldHMpO1xuICogfSk7XG4gKi9cblxudmFyIEdyb3VwYWJsZSA9IHtcbiAgbmFtZTogXCJncm91cGFibGVcIixcbiAgcHJvcHM6IHtcbiAgICBkZWZhdWx0R3JvdXBSb3RhdGU6IE51bWJlcixcbiAgICBkZWZhdWx0R3JvdXBPcmlnaW46IFN0cmluZyxcbiAgICBncm91cGFibGU6IEJvb2xlYW5cbiAgfSxcbiAgZXZlbnRzOiB7fSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XG4gICAgdmFyIHRhcmdldHMgPSBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIHx8IFtdO1xuICAgIG1vdmVhYmxlLm1vdmVhYmxlcyA9IFtdO1xuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLFxuICAgICAgICBsZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgdG9wID0gX2EudG9wO1xuICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcFxuICAgIH07XG4gICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XG4gICAgcmV0dXJuIHRhcmdldHMubWFwKGZ1bmN0aW9uICh0YXJnZXQsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1vdmVhYmxlTWFuYWdlciwge1xuICAgICAgICBrZXk6IFwibW92ZWFibGVcIiArIGksXG4gICAgICAgIHJlZjogcmVmcyhtb3ZlYWJsZSwgXCJtb3ZlYWJsZXNcIiwgaSksXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBvcmlnaW46IGZhbHNlLFxuICAgICAgICBjc3NTdHlsZWQ6IHByb3BzLmNzc1N0eWxlZCxcbiAgICAgICAgY3VzdG9tU3R5bGVkTWFwOiBwcm9wcy5jdXN0b21TdHlsZWRNYXAsXG4gICAgICAgIHVzZVJlc2l6ZU9ic2VydmVyOiBwcm9wcy51c2VSZXNpemVPYnNlcnZlcixcbiAgICAgICAgcGFyZW50TW92ZWFibGU6IG1vdmVhYmxlLFxuICAgICAgICBwYXJlbnRQb3NpdGlvbjogcG9zaXRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQ2xpY2thYmxlID0gbWFrZUFibGUoXCJjbGlja2FibGVcIiwge1xuICBwcm9wczoge1xuICAgIGNsaWNrYWJsZTogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHtcbiAgICBvbkNsaWNrOiBcImNsaWNrXCIsXG4gICAgb25DbGlja0dyb3VwOiBcImNsaWNrR3JvdXBcIlxuICB9LFxuICBhbHdheXM6IHRydWUsXG4gIGRyYWdSZWxhdGlvbjogXCJ3ZWFrXCIsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKCFlLmlzUmVxdWVzdCkge1xuICAgICAgYWRkRXZlbnQod2luZG93LCBcImNsaWNrXCIsIG1vdmVhYmxlLm9uUHJldmVudENsaWNrLCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgfSxcbiAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcbiAgICBlLmRhdGFzLmlucHV0VGFyZ2V0ID0gZS5pbnB1dEV2ZW50ICYmIGUuaW5wdXRFdmVudC50YXJnZXQ7XG4gIH0sXG4gIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHRoaXMuZW5kRXZlbnQobW92ZWFibGUpO1xuICAgIHZhciB0YXJnZXQgPSBtb3ZlYWJsZS5zdGF0ZS50YXJnZXQ7XG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgdmFyIGlucHV0VGFyZ2V0ID0gZS5pbnB1dFRhcmdldDtcbiAgICB2YXIgaXNNb3ZlYWJsZUVsZW1lbnQgPSBtb3ZlYWJsZS5pc01vdmVhYmxlRWxlbWVudChpbnB1dFRhcmdldCk7XG4gICAgdmFyIGNvbnRhaW5zRWxlbWVudCA9ICFpc01vdmVhYmxlRWxlbWVudCAmJiBtb3ZlYWJsZS5jb250cm9sQm94LmdldEVsZW1lbnQoKS5jb250YWlucyhpbnB1dFRhcmdldCk7XG5cbiAgICBpZiAoIWUuaXNEcmFnIHx8IGNvbnRhaW5zRWxlbWVudCkge1xuICAgICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnB1dEV2ZW50IHx8ICFpbnB1dFRhcmdldCB8fCBlLmlzRHJhZyB8fCBtb3ZlYWJsZS5pc01vdmVhYmxlRWxlbWVudChpbnB1dFRhcmdldCkgfHwgY29udGFpbnNFbGVtZW50IC8vIEV4dGVybmFsIGV2ZW50IGR1cGxpY2F0ZSB0YXJnZXQgb3IgZHJhZ0FyZWFFbGVtZW50XG4gICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIHZhciBjb250YWluc1RhcmdldCA9IHRhcmdldC5jb250YWlucyhpbnB1dFRhcmdldCk7XG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpY2tcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xuICAgICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXG4gICAgICBpbnB1dFRhcmdldDogaW5wdXRUYXJnZXQsXG4gICAgICBpc1RhcmdldDogdGFyZ2V0ID09PSBpbnB1dFRhcmdldCxcbiAgICAgIGNvbnRhaW5zVGFyZ2V0OiBjb250YWluc1RhcmdldFxuICAgIH0pKTtcbiAgfSxcbiAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmVuZEV2ZW50KG1vdmVhYmxlKTtcbiAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgICB2YXIgaW5wdXRUYXJnZXQgPSBlLmlucHV0VGFyZ2V0O1xuXG4gICAgaWYgKCFpbnB1dEV2ZW50IHx8ICFpbnB1dFRhcmdldCB8fCBlLmlzRHJhZyB8fCBtb3ZlYWJsZS5pc01vdmVhYmxlRWxlbWVudChpbnB1dFRhcmdldCkgLy8gRXh0ZXJuYWwgZXZlbnQgZHVwbGljYXRlIHRhcmdldCBvciBkcmFnQXJlYUVsZW1lbnRcbiAgICB8fCBlLmRhdGFzLmlucHV0VGFyZ2V0ID09PSBpbnB1dFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRzID0gbW92ZWFibGUucHJvcHMudGFyZ2V0cztcbiAgICB2YXIgdGFyZ2V0SW5kZXggPSB0YXJnZXRzLmluZGV4T2YoaW5wdXRUYXJnZXQpO1xuICAgIHZhciBpc1RhcmdldCA9IHRhcmdldEluZGV4ID4gLTE7XG4gICAgdmFyIGNvbnRhaW5zVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICBpZiAodGFyZ2V0SW5kZXggPT09IC0xKSB7XG4gICAgICB0YXJnZXRJbmRleCA9IGZpbmRJbmRleCh0YXJnZXRzLCBmdW5jdGlvbiAocGFyZW50VGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRUYXJnZXQuY29udGFpbnMoaW5wdXRUYXJnZXQpO1xuICAgICAgfSk7XG4gICAgICBjb250YWluc1RhcmdldCA9IHRhcmdldEluZGV4ID4gLTE7XG4gICAgfVxuXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpY2tHcm91cFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XG4gICAgICBpc0RvdWJsZTogZS5pc0RvdWJsZSxcbiAgICAgIHRhcmdldHM6IHRhcmdldHMsXG4gICAgICBpbnB1dFRhcmdldDogaW5wdXRUYXJnZXQsXG4gICAgICB0YXJnZXRJbmRleDogdGFyZ2V0SW5kZXgsXG4gICAgICBpc1RhcmdldDogaXNUYXJnZXQsXG4gICAgICBjb250YWluc1RhcmdldDogY29udGFpbnNUYXJnZXRcbiAgICB9KSk7XG4gIH0sXG4gIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xuICB9LFxuICBlbmRFdmVudDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy51bnNldChtb3ZlYWJsZSk7XG4gICAgfSk7XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICByZW1vdmVFdmVudCh3aW5kb3csIFwiY2xpY2tcIiwgbW92ZWFibGUub25QcmV2ZW50Q2xpY2ssIHRydWUpO1xuICB9XG59KTtcbi8qKlxuICogV2hlbiB5b3UgY2xpY2sgb24gdGhlIGVsZW1lbnQsIHRoZSBgY2xpY2tgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IGNsaWNrXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uQ2xpY2t9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBjbGlja2AgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpY2tcIiwgKHsgaGFzVGFyZ2V0LCBjb250YWluc1RhcmdldCwgdGFyZ2V0SW5kZXggfSkgPT4ge1xuICogICAgIC8vIElmIHlvdSBjbGljayBvbiBhbiBlbGVtZW50IG90aGVyIHRoYW4gdGhlIHRhcmdldCBhbmQgbm90IGluY2x1ZGVkIGluIHRoZSB0YXJnZXQsIGluZGV4IGlzIC0xLlxuICogICAgIGNvbnNvbGUubG9nKFwib25DbGlja0dyb3VwXCIsIHRhcmdldCwgaGFzVGFyZ2V0LCBjb250YWluc1RhcmdldCwgdGFyZ2V0SW5kZXgpO1xuICogfSk7XG4gKi9cblxuLyoqXG4gKiBXaGVuIHlvdSBjbGljayBvbiB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGdyb3VwLCB0aGUgYGNsaWNrR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxuICogQGV2ZW50IGNsaWNrR3JvdXBcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25DbGlja0dyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgY2xpY2tHcm91cGAgZXZlbnRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XG4gKlxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXG4gKiB9KTtcbiAqIG1vdmVhYmxlLm9uKFwiY2xpY2tHcm91cFwiLCAoeyBpbnB1dFRhcmdldCwgaXNUYXJnZXQsIGNvbnRhaW5zVGFyZ2V0LCB0YXJnZXRJbmRleCB9KSA9PiB7XG4gKiAgICAgLy8gSWYgeW91IGNsaWNrIG9uIGFuIGVsZW1lbnQgb3RoZXIgdGhhbiB0aGUgdGFyZ2V0IGFuZCBub3QgaW5jbHVkZWQgaW4gdGhlIHRhcmdldCwgaW5kZXggaXMgLTEuXG4gKiAgICAgY29uc29sZS5sb2coXCJvbkNsaWNrR3JvdXBcIiwgaW5wdXRUYXJnZXQsIGlzVGFyZ2V0LCBjb250YWluc1RhcmdldCwgdGFyZ2V0SW5kZXgpO1xuICogfSk7XG4gKi9cblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlRXZlbnQoZSkge1xuICB2YXIgZGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlO1xuXG4gIGlmICghZGF0YXMpIHtcbiAgICBlLm9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlID0ge307XG4gICAgZGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlO1xuICB9XG5cbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwge1xuICAgIGRhdGFzOiBkYXRhc1xuICB9KTtcbn1cblxudmFyIGVkZ2VEcmFnZ2FibGUgPSBtYWtlQWJsZShcImVkZ2VEcmFnZ2FibGVcIiwge1xuICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XG4gICAgaWYgKCFtb3ZlYWJsZS5wcm9wcy5lZGdlRHJhZ2dhYmxlIHx8ICFlLmlucHV0RXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZS5pbnB1dEV2ZW50LnRhcmdldDtcbiAgICByZXR1cm4gaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJkaXJlY3Rpb25cIikpICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwibGluZVwiKSk7XG4gIH0sXG4gIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XG4gIH0sXG4gIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWcobW92ZWFibGUsIGdldERyYWdnYWJsZUV2ZW50KGUpKTtcbiAgfSxcbiAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiBEcmFnZ2FibGUuZHJhZ0VuZChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xuICB9LFxuICBkcmFnR3JvdXBDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICBpZiAoIW1vdmVhYmxlLnByb3BzLmVkZ2VEcmFnZ2FibGUgfHwgIWUuaW5wdXRFdmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBlLmlucHV0RXZlbnQudGFyZ2V0O1xuICAgIHJldHVybiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImRpcmVjdGlvblwiKSkgJiYgaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJsaW5lXCIpKTtcbiAgfSxcbiAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdHcm91cFN0YXJ0KG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiBEcmFnZ2FibGUuZHJhZ0dyb3VwKG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XG4gIH0sXG4gIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xuICAgIHJldHVybiBEcmFnZ2FibGUuZHJhZ0dyb3VwRW5kKG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XG4gIH0sXG4gIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLnVuc2V0KG1vdmVhYmxlKTtcbiAgfVxufSk7XG4vKipcbiAqIFdoZXRoZXIgdG8gbW92ZSBieSBkcmFnZ2luZyB0aGUgZWRnZSBsaW5lIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBuYW1lIE1vdmVhYmxlLkRyYWdnYWJsZSNlZGdlRHJhZ2dhYmxlXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xuICpcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcbiAqICBkcmFnZ2FibGU6IHRydWUsXG4gKiAgZWRnZURyYWdnYWJsZTogZmFsc2UsXG4gKiB9KTtcbiAqXG4gKiBtb3ZlYWJsZS5lZGdlRHJhZ2dhYmxlID0gdHJ1ZTtcbiAqL1xuXG52YXIgSW5kaXZpZHVhbEdyb3VwYWJsZSA9IHtcbiAgbmFtZTogXCJpbmRpdmlkdWFsR3JvdXBhYmxlXCIsXG4gIHByb3BzOiB7XG4gICAgaW5kaXZpZHVhbEdyb3VwYWJsZTogQm9vbGVhblxuICB9LFxuICBldmVudHM6IHt9XG59O1xuXG52YXIgTU9WRUFCTEVfQUJMRVMgPSAvKiNfX1BVUkVfXyovW0JlZm9yZVJlbmRlcmFibGUsIERlZmF1bHQsIFNuYXBwYWJsZSwgUGluY2hhYmxlLCBEcmFnZ2FibGUsIGVkZ2VEcmFnZ2FibGUsIFJvdGF0YWJsZSwgUmVzaXphYmxlLCBTY2FsYWJsZSwgV2FycGFibGUsIFNjcm9sbGFibGUsIFBhZGRpbmcsIE9yaWdpbiwgT3JpZ2luRHJhZ2dhYmxlLCBDbGlwcGFibGUsIFJvdW5kYWJsZSwgR3JvdXBhYmxlLCBJbmRpdmlkdWFsR3JvdXBhYmxlLCBDbGlja2FibGUsIERyYWdBcmVhLCBSZW5kZXJhYmxlXTtcbnZhciBNT1ZFQUJMRV9FVkVOVFNfUFJPUFNfTUFQID0gLyojX19QVVJFX18qL01PVkVBQkxFX0FCTEVTLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudCwgYWJsZSkge1xuICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGN1cnJlbnQpLCBcImV2ZW50c1wiIGluIGFibGUgPyBhYmxlLmV2ZW50cyA6IHt9KTtcbn0sIHt9KTtcbnZhciBNT1ZFQUJMRV9QUk9QU19NQVAgPSAvKiNfX1BVUkVfXyovTU9WRUFCTEVfQUJMRVMucmVkdWNlKGZ1bmN0aW9uIChjdXJyZW50LCBhYmxlKSB7XG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY3VycmVudCksIGFibGUucHJvcHMpO1xufSwge30pO1xudmFyIE1PVkVBQkxFX0VWRU5UU19NQVAgPSAvKiNfX1BVUkVfXyovaW52ZXJ0T2JqZWN0KE1PVkVBQkxFX0VWRU5UU19QUk9QU19NQVApO1xudmFyIE1PVkVBQkxFX0VWRU5UUyA9IE9iamVjdC5rZXlzKE1PVkVBQkxFX0VWRU5UU19NQVApO1xudmFyIE1PVkVBQkxFX1BST1BTID0gT2JqZWN0LmtleXMoTU9WRUFCTEVfUFJPUFNfTUFQKTtcblxuZnVuY3Rpb24gZ2V0TWF4UG9zKHBvc2VzLCBpbmRleCkge1xuICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgcG9zZXMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwb3MxID0gX2FbMF0sXG4gICAgICAgIHBvczIgPSBfYVsxXSxcbiAgICAgICAgcG9zMyA9IF9hWzJdLFxuICAgICAgICBwb3M0ID0gX2FbM107XG4gICAgcmV0dXJuIE1hdGgubWF4KHBvczFbaW5kZXhdLCBwb3MyW2luZGV4XSwgcG9zM1tpbmRleF0sIHBvczRbaW5kZXhdKTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRNaW5Qb3MocG9zZXMsIGluZGV4KSB7XG4gIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBwb3Nlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBvczEgPSBfYVswXSxcbiAgICAgICAgcG9zMiA9IF9hWzFdLFxuICAgICAgICBwb3MzID0gX2FbMl0sXG4gICAgICAgIHBvczQgPSBfYVszXTtcbiAgICByZXR1cm4gTWF0aC5taW4ocG9zMVtpbmRleF0sIHBvczJbaW5kZXhdLCBwb3MzW2luZGV4XSwgcG9zNFtpbmRleF0pO1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwUmVjdChtb3ZlYWJsZXMsIHJvdGF0aW9uKSB7XG4gIGlmICghbW92ZWFibGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gIH1cblxuICB2YXIgbW92ZWFibGVQb3NlcyA9IG1vdmVhYmxlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgcmV0dXJuIGdldEFic29sdXRlUG9zZXNCeVN0YXRlKHN0YXRlKTtcbiAgfSk7XG4gIHZhciBtaW5YID0gTUFYX05VTTtcbiAgdmFyIG1pblkgPSBNQVhfTlVNO1xuICB2YXIgZ3JvdXBXaWR0aCA9IDA7XG4gIHZhciBncm91cEhlaWdodCA9IDA7XG4gIHZhciBmaXhlZFJvdGF0aW9uID0gdGhyb3R0bGUocm90YXRpb24sIFRJTllfTlVNKTtcblxuICBpZiAoZml4ZWRSb3RhdGlvbiAlIDkwKSB7XG4gICAgdmFyIHJhZF8xID0gZml4ZWRSb3RhdGlvbiAvIDE4MCAqIE1hdGguUEk7XG4gICAgdmFyIGExXzEgPSBNYXRoLnRhbihyYWRfMSk7XG4gICAgdmFyIGEyXzEgPSAtMSAvIGExXzE7XG4gICAgdmFyIGIxTWluTWF4XzEgPSBbTUlOX05VTSwgTUFYX05VTV07XG4gICAgdmFyIGIyTWluTWF4XzEgPSBbTUlOX05VTSwgTUFYX05VTV07XG4gICAgbW92ZWFibGVQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChwb3Nlcykge1xuICAgICAgcG9zZXMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIC8vIGF4ICsgYiA9IHlcbiAgICAgICAgLy8gYiA9IHkgLSBheFxuICAgICAgICB2YXIgYjEgPSBwb3NbMV0gLSBhMV8xICogcG9zWzBdO1xuICAgICAgICB2YXIgYjIgPSBwb3NbMV0gLSBhMl8xICogcG9zWzBdO1xuICAgICAgICBiMU1pbk1heF8xWzBdID0gTWF0aC5tYXgoYjFNaW5NYXhfMVswXSwgYjEpO1xuICAgICAgICBiMU1pbk1heF8xWzFdID0gTWF0aC5taW4oYjFNaW5NYXhfMVsxXSwgYjEpO1xuICAgICAgICBiMk1pbk1heF8xWzBdID0gTWF0aC5tYXgoYjJNaW5NYXhfMVswXSwgYjIpO1xuICAgICAgICBiMk1pbk1heF8xWzFdID0gTWF0aC5taW4oYjJNaW5NYXhfMVsxXSwgYjIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYjFNaW5NYXhfMS5mb3JFYWNoKGZ1bmN0aW9uIChiMSkge1xuICAgICAgLy8gYTF4ICsgYjEgPSBhMnggKyBiMlxuICAgICAgYjJNaW5NYXhfMS5mb3JFYWNoKGZ1bmN0aW9uIChiMikge1xuICAgICAgICAvLyAoYTEgLSBhMil4ID0gYjIgLSBiMVxuICAgICAgICB2YXIgeCA9IChiMiAtIGIxKSAvIChhMV8xIC0gYTJfMSk7XG4gICAgICAgIHZhciB5ID0gYTFfMSAqIHggKyBiMTtcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgcm90YXRlUG9zZXMgPSBtb3ZlYWJsZVBvc2VzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBwb3MxID0gX2FbMF0sXG4gICAgICAgICAgcG9zMiA9IF9hWzFdLFxuICAgICAgICAgIHBvczMgPSBfYVsyXSxcbiAgICAgICAgICBwb3M0ID0gX2FbM107XG4gICAgICByZXR1cm4gW3JvdGF0ZShwb3MxLCAtcmFkXzEpLCByb3RhdGUocG9zMiwgLXJhZF8xKSwgcm90YXRlKHBvczMsIC1yYWRfMSksIHJvdGF0ZShwb3M0LCAtcmFkXzEpXTtcbiAgICB9KTtcbiAgICBncm91cFdpZHRoID0gZ2V0TWF4UG9zKHJvdGF0ZVBvc2VzLCAwKSAtIGdldE1pblBvcyhyb3RhdGVQb3NlcywgMCk7XG4gICAgZ3JvdXBIZWlnaHQgPSBnZXRNYXhQb3Mocm90YXRlUG9zZXMsIDEpIC0gZ2V0TWluUG9zKHJvdGF0ZVBvc2VzLCAxKTtcbiAgfSBlbHNlIHtcbiAgICBtaW5YID0gZ2V0TWluUG9zKG1vdmVhYmxlUG9zZXMsIDApO1xuICAgIG1pblkgPSBnZXRNaW5Qb3MobW92ZWFibGVQb3NlcywgMSk7XG4gICAgZ3JvdXBXaWR0aCA9IGdldE1heFBvcyhtb3ZlYWJsZVBvc2VzLCAwKSAtIG1pblg7XG4gICAgZ3JvdXBIZWlnaHQgPSBnZXRNYXhQb3MobW92ZWFibGVQb3NlcywgMSkgLSBtaW5ZO1xuXG4gICAgaWYgKGZpeGVkUm90YXRpb24gJSAxODApIHtcbiAgICAgIHZhciBjaGFuZ2VkV2lkdGggPSBncm91cFdpZHRoO1xuICAgICAgZ3JvdXBXaWR0aCA9IGdyb3VwSGVpZ2h0O1xuICAgICAgZ3JvdXBIZWlnaHQgPSBjaGFuZ2VkV2lkdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW5YLCBtaW5ZLCBncm91cFdpZHRoLCBncm91cEhlaWdodF07XG59XG4vKipcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuR3JvdXBcbiAqIEBkZXNjcmlwdGlvbiBZb3UgY2FuIG1ha2UgdGFyZ2V0cyBtb3ZlYWJsZS5cbiAqL1xuXG5cbnZhciBNb3ZlYWJsZUdyb3VwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1vdmVhYmxlR3JvdXAsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTW92ZWFibGVHcm91cCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgIF90aGlzLmRpZmZlciA9IG5ldyBDaGlsZHJlbkRpZmZlcigpO1xuICAgIF90aGlzLm1vdmVhYmxlcyA9IFtdO1xuICAgIF90aGlzLnRyYW5zZm9ybU9yaWdpbiA9IFwiNTAlIDUwJVwiO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gTW92ZWFibGVHcm91cC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5jaGVja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVwZGF0ZUFibGVzKCk7XG4gIH07XG5cbiAgX19wcm90by51cGRhdGVSZWN0ID0gZnVuY3Rpb24gKHR5cGUsIGlzVGFyZ2V0LCBpc1NldFN0YXRlKSB7XG4gICAgaWYgKGlzU2V0U3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgaXNTZXRTdGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvbnRyb2xCb3gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1vdmVhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xuICAgICAgbW92ZWFibGUudXBkYXRlUmVjdCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgIH0pO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0IHx8IHByb3BzLnRhcmdldDtcblxuICAgIGlmICghaXNUYXJnZXQgfHwgdHlwZSAhPT0gXCJcIiAmJiBwcm9wcy51cGRhdGVHcm91cCkge1xuICAgICAgLy8gcmVzZXQgcm90YXRhaW9uXG4gICAgICB0aGlzLnJvdGF0aW9uID0gcHJvcHMuZGVmYXVsdEdyb3VwUm90YXRlO1xuICAgICAgdGhpcy50cmFuc2Zvcm1PcmlnaW4gPSBwcm9wcy5kZWZhdWx0R3JvdXBPcmlnaW4gfHwgXCI1MCUgNTAlXCI7XG4gICAgICB0aGlzLnNjYWxlID0gWzEsIDFdO1xuICAgIH1cblxuICAgIHZhciByb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAgIHZhciBfYSA9IGdldEdyb3VwUmVjdCh0aGlzLm1vdmVhYmxlcywgcm90YXRpb24pLFxuICAgICAgICBsZWZ0ID0gX2FbMF0sXG4gICAgICAgIHRvcCA9IF9hWzFdLFxuICAgICAgICB3aWR0aCA9IF9hWzJdLFxuICAgICAgICBoZWlnaHQgPSBfYVszXTsgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcblxuXG4gICAgdmFyIHRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgcm90YXRpb24gKyBcImRlZykgc2NhbGUoXCIgKyAoc2NhbGVbMF0gPj0gMCA/IDEgOiAtMSkgKyBcIiwgXCIgKyAoc2NhbGVbMV0gPj0gMCA/IDEgOiAtMSkgKyBcIilcIjtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcImxlZnQ6MHB4O3RvcDowcHg7IHRyYW5zZm9ybS1vcmlnaW46IFwiICsgdGhpcy50cmFuc2Zvcm1PcmlnaW4gKyBcIjsgd2lkdGg6XCIgKyB3aWR0aCArIFwicHg7IGhlaWdodDpcIiArIGhlaWdodCArIFwicHg7XCIgKyAoXCJ0cmFuc2Zvcm06XCIgKyB0cmFuc2Zvcm0pO1xuICAgIHN0YXRlLndpZHRoID0gd2lkdGg7XG4gICAgc3RhdGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuICAgIHZhciBpbmZvID0gZ2V0VGFyZ2V0SW5mbyh0aGlzLmNvbnRyb2xCb3guZ2V0RWxlbWVudCgpLCB0YXJnZXQsIHRoaXMuY29udHJvbEJveC5nZXRFbGVtZW50KCksIHRoaXMuZ2V0Q29udGFpbmVyKCksIHRoaXMucHJvcHMucm9vdENvbnRhaW5lciB8fCBjb250YWluZXIpO1xuICAgIHZhciBwb3MgPSBbaW5mby5sZWZ0LCBpbmZvLnRvcF07XG5cbiAgICB2YXIgX2IgPSBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShpbmZvKSxcbiAgICAgICAgcG9zMSA9IF9iWzBdLFxuICAgICAgICBwb3MyID0gX2JbMV0sXG4gICAgICAgIHBvczMgPSBfYlsyXSxcbiAgICAgICAgcG9zNCA9IF9iWzNdOyAvLyBpbmZvLmxlZnQgKyBpbmZvLnBvcygxIH4gNClcblxuXG4gICAgdmFyIG1pblBvcyA9IGdldE1pbk1heHMoW3BvczEsIHBvczIsIHBvczMsIHBvczRdKTtcbiAgICB2YXIgZGVsdGEgPSBbbWluUG9zLm1pblgsIG1pblBvcy5taW5ZXTtcbiAgICBpbmZvLnBvczEgPSBtaW51cyhwb3MxLCBkZWx0YSk7XG4gICAgaW5mby5wb3MyID0gbWludXMocG9zMiwgZGVsdGEpO1xuICAgIGluZm8ucG9zMyA9IG1pbnVzKHBvczMsIGRlbHRhKTtcbiAgICBpbmZvLnBvczQgPSBtaW51cyhwb3M0LCBkZWx0YSk7XG4gICAgaW5mby5sZWZ0ID0gbGVmdCAtIGluZm8ubGVmdCArIGRlbHRhWzBdO1xuICAgIGluZm8udG9wID0gdG9wIC0gaW5mby50b3AgKyBkZWx0YVsxXTtcbiAgICBpbmZvLm9yaWdpbiA9IG1pbnVzKHBsdXMocG9zLCBpbmZvLm9yaWdpbiksIGRlbHRhKTtcbiAgICBpbmZvLmJlZm9yZU9yaWdpbiA9IG1pbnVzKHBsdXMocG9zLCBpbmZvLmJlZm9yZU9yaWdpbiksIGRlbHRhKTtcbiAgICBpbmZvLm9yaWdpbmFsQmVmb3JlT3JpZ2luID0gcGx1cyhwb3MsIGluZm8ub3JpZ2luYWxCZWZvcmVPcmlnaW4pOyAvLyBpbmZvLnRyYW5zZm9ybU9yaWdpbiA9IG1pbnVzKHBsdXMocG9zLCBpbmZvLnRyYW5zZm9ybU9yaWdpbiEpLCBkZWx0YSk7XG5cbiAgICB2YXIgY2xpZW50UmVjdCA9IGluZm8udGFyZ2V0Q2xpZW50UmVjdDtcbiAgICB2YXIgZGlyZWN0aW9uID0gc2NhbGVbMF0gKiBzY2FsZVsxXSA+IDAgPyAxIDogLTE7XG4gICAgY2xpZW50UmVjdC50b3AgKz0gaW5mby50b3AgLSBzdGF0ZS50b3A7XG4gICAgY2xpZW50UmVjdC5sZWZ0ICs9IGluZm8ubGVmdCAtIHN0YXRlLmxlZnQ7XG4gICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgLWRlbHRhWzBdICsgXCJweCwgXCIgKyAtZGVsdGFbMV0gKyBcInB4KSBcIiArIHRyYW5zZm9ybTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbmZvKSwge1xuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBiZWZvcmVEaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH0pLCBpc1NldFN0YXRlKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBfc3VwZXIucHJvdG90eXBlLmdldFJlY3QuY2FsbCh0aGlzKSksIHtcbiAgICAgIGNoaWxkcmVuOiB0aGlzLm1vdmVhYmxlcy5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5nZXRSZWN0KCk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8udHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGUsIGlzTWFuYWdlcikge1xuICAgIGlmIChpc01hbmFnZXIgfHwgbmFtZS5pbmRleE9mKFwiR3JvdXBcIikgPiAtMSkge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudHJpZ2dlckV2ZW50LmNhbGwodGhpcywgbmFtZSwgZSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8udXBkYXRlQWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVBYmxlcy5jYWxsKHRoaXMsIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgdGhpcy5wcm9wcy5hYmxlcyksIFtHcm91cGFibGVdKSwgXCJHcm91cFwiKTtcbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGVUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUuX3VwZGF0ZVRhcmdldHMuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX3ByZXZUYXJnZXQgPSB0aGlzLnByb3BzLmRyYWdUYXJnZXQgfHwgdGhpcy5hcmVhRWxlbWVudDtcbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmV2VGFyZ2V0ID0gdGhpcy5fcHJldlRhcmdldDtcbiAgICB2YXIgbmV4dFRhcmdldCA9IHByb3BzLmRyYWdUYXJnZXQgfHwgdGhpcy5hcmVhRWxlbWVudDtcblxuICAgIGlmIChwcmV2VGFyZ2V0ICE9PSBuZXh0VGFyZ2V0KSB7XG4gICAgICB1bnNldCh0aGlzLCBcInRhcmdldEdlc3RvXCIpO1xuICAgICAgdW5zZXQodGhpcywgXCJjb250cm9sR2VzdG9cIik7XG4gICAgICBzdGF0ZS50YXJnZXQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghc3RhdGUudGFyZ2V0KSB7XG4gICAgICBzdGF0ZS50YXJnZXQgPSB0aGlzLmFyZWFFbGVtZW50O1xuICAgICAgdGhpcy5jb250cm9sQm94LmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGhpcy50YXJnZXRHZXN0byA9IGdldFRhcmdldEFibGVHZXN0byh0aGlzLCBuZXh0VGFyZ2V0LCBcIkdyb3VwXCIpO1xuICAgICAgdGhpcy5jb250cm9sR2VzdG8gPSBnZXRBYmxlR2VzdG8odGhpcywgdGhpcy5jb250cm9sQm94LmdldEVsZW1lbnQoKSwgXCJjb250cm9sQWJsZXNcIiwgXCJHcm91cENvbnRyb2xcIik7XG4gICAgfVxuXG4gICAgdmFyIGlzQ29udGFpbmVyQ2hhbmdlZCA9ICFlcXVhbHMoc3RhdGUuY29udGFpbmVyLCBwcm9wcy5jb250YWluZXIpO1xuXG4gICAgaWYgKGlzQ29udGFpbmVyQ2hhbmdlZCkge1xuICAgICAgc3RhdGUuY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIHZhciBfYSA9IHRoaXMuZGlmZmVyLnVwZGF0ZShwcm9wcy50YXJnZXRzKSxcbiAgICAgICAgYWRkZWQgPSBfYS5hZGRlZCxcbiAgICAgICAgY2hhbmdlZCA9IF9hLmNoYW5nZWQsXG4gICAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkO1xuXG4gICAgaWYgKGlzQ29udGFpbmVyQ2hhbmdlZCB8fCBhZGRlZC5sZW5ndGggfHwgY2hhbmdlZC5sZW5ndGggfHwgcmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMudXBkYXRlUmVjdCgpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGVPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIE1vdmVhYmxlR3JvdXAuZGVmYXVsdFByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIE1vdmVhYmxlTWFuYWdlci5kZWZhdWx0UHJvcHMpLCB7XG4gICAgdHJhbnNmb3JtT3JpZ2luOiBbXCI1MCVcIiwgXCI1MCVcIl0sXG4gICAgZ3JvdXBhYmxlOiB0cnVlLFxuICAgIGRyYWdBcmVhOiB0cnVlLFxuICAgIGtlZXBSYXRpbzogdHJ1ZSxcbiAgICB0YXJnZXRzOiBbXSxcbiAgICBkZWZhdWx0R3JvdXBSb3RhdGU6IDAsXG4gICAgZGVmYXVsdEdyb3VwT3JpZ2luOiBcIjUwJSA1MCVcIlxuICB9KTtcbiAgcmV0dXJuIE1vdmVhYmxlR3JvdXA7XG59KE1vdmVhYmxlTWFuYWdlcik7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5JbmRpdmlkdWFsR3JvdXBcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgdGFyZ2V0cyBpbmRpdmlkdWFsbHksIG5vdCBhcyBhIGdyb3VwLkNyZWF0ZSB0YXJnZXRzIGluZGl2aWR1YWxseSwgbm90IGFzIGEgZ3JvdXAuXG4gKi9cblxudmFyIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMubW92ZWFibGVzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNzcE5vbmNlID0gX2EuY3NwTm9uY2UsXG4gICAgICAgIENvbnRyb2xCb3hFbGVtZW50ID0gX2EuY3NzU3R5bGVkLFxuICAgICAgICB0YXJnZXRzID0gX2EudGFyZ2V0cztcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb250cm9sQm94RWxlbWVudCwge1xuICAgICAgY3NwTm9uY2U6IGNzcE5vbmNlLFxuICAgICAgcmVmOiByZWYodGhpcywgXCJjb250cm9sQm94XCIpLFxuICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJjb250cm9sLWJveFwiKVxuICAgIH0sIHRhcmdldHMubWFwKGZ1bmN0aW9uICh0YXJnZXQsIGkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KE1vdmVhYmxlTWFuYWdlciwgX19hc3NpZ24oe1xuICAgICAgICBrZXk6IFwibW92ZWFibGVcIiArIGksXG4gICAgICAgIHJlZjogcmVmcyhfdGhpcywgXCJtb3ZlYWJsZXNcIiwgaSlcbiAgICAgIH0sIF90aGlzLnByb3BzLCB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICB3cmFwcGVyTW92ZWFibGU6IF90aGlzXG4gICAgICB9KSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgX19wcm90by51cGRhdGVSZWN0ID0gZnVuY3Rpb24gKHR5cGUsIGlzVGFyZ2V0LCBpc1NldFN0YXRlKSB7XG4gICAgaWYgKGlzU2V0U3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgaXNTZXRTdGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5tb3ZlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAobW92ZWFibGUpIHtcbiAgICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QodHlwZSwgaXNUYXJnZXQsIGlzU2V0U3RhdGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIF9zdXBlci5wcm90b3R5cGUuZ2V0UmVjdC5jYWxsKHRoaXMpKSwge1xuICAgICAgY2hpbGRyZW46IHRoaXMubW92ZWFibGVzLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmdldFJlY3QoKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBfX3Byb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLmhpdFRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgX19wcm90by5pc0luc2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX19wcm90by5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfX3Byb3RvLnVwZGF0ZVJlbmRlclBvc2VzID0gZnVuY3Rpb24gKCkge307XG5cbiAgX19wcm90by5jaGVja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8udHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKCkge307XG5cbiAgX19wcm90by51cGRhdGVBYmxlcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkge307XG5cbiAgcmV0dXJuIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwO1xufShNb3ZlYWJsZU1hbmFnZXIpO1xuXG52YXIgSW5pdGlhbE1vdmVhYmxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEluaXRpYWxNb3ZlYWJsZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBJbml0aWFsTW92ZWFibGUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5yZWZUYXJnZXRzID0gW107XG4gICAgX3RoaXMuc2VsZWN0b3JNYXAgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGU7XG5cbiAgSW5pdGlhbE1vdmVhYmxlLm1ha2VTdHlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNzc01hcCA9IHt9O1xuICAgIHZhciBhYmxlcyA9IHRoaXMuZ2V0VG90YWxBYmxlcygpO1xuICAgIGFibGVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgY3NzID0gX2EuY3NzO1xuXG4gICAgICBpZiAoIWNzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNzcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIGNzc01hcFt0ZXh0XSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgc3R5bGUgPSBnZXRLZXlzKGNzc01hcCkuam9pbihcIlxcblwiKTtcbiAgICB0aGlzLmRlZmF1bHRTdHlsZWQgPSBzdHlsZWQoXCJkaXZcIiwgcHJlZml4Q1NTKFBSRUZJWCwgTU9WRUFCTEVfQ1NTICsgc3R5bGUpKTtcbiAgfTtcblxuICBJbml0aWFsTW92ZWFibGUuZ2V0VG90YWxBYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheShbRGVmYXVsdCwgR3JvdXBhYmxlLCBJbmRpdmlkdWFsR3JvdXBhYmxlLCBEcmFnQXJlYV0sIHRoaXMuZGVmYXVsdEFibGVzKTtcbiAgfTtcblxuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW92ZWFibGVDb250cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgIGlmICghbW92ZWFibGVDb250cnVjdG9yLmRlZmF1bHRTdHlsZWQpIHtcbiAgICAgIG1vdmVhYmxlQ29udHJ1Y3Rvci5tYWtlU3R5bGVkKCk7XG4gICAgfVxuXG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdXNlckFibGVzID0gX2EuYWJsZXMsXG4gICAgICAgIHVzZXJQcm9wcyA9IF9hLnByb3BzLFxuICAgICAgICBwcm9wcyA9IF9fcmVzdChfYSwgW1wiYWJsZXNcIiwgXCJwcm9wc1wiXSk7XG5cbiAgICB2YXIgcmVmVGFyZ2V0cyA9IHRoaXMuX3VwZGF0ZVJlZnModHJ1ZSk7XG5cbiAgICB2YXIgZWxlbWVudFRhcmdldHMgPSBnZXRFbGVtZW50VGFyZ2V0cyhyZWZUYXJnZXRzLCB0aGlzLnNlbGVjdG9yTWFwKTtcbiAgICB2YXIgaXNHcm91cCA9IGVsZW1lbnRUYXJnZXRzLmxlbmd0aCA+IDE7XG4gICAgdmFyIHRvdGFsQWJsZXMgPSBtb3ZlYWJsZUNvbnRydWN0b3IuZ2V0VG90YWxBYmxlcygpO1xuXG4gICAgdmFyIGFibGVzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCB0b3RhbEFibGVzKSwgdXNlckFibGVzIHx8IFtdKTtcblxuICAgIHZhciBuZXh0UHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMpLCB1c2VyUHJvcHMgfHwge30pLCB7XG4gICAgICBhYmxlczogYWJsZXMsXG4gICAgICBjc3NTdHlsZWQ6IG1vdmVhYmxlQ29udHJ1Y3Rvci5kZWZhdWx0U3R5bGVkLFxuICAgICAgY3VzdG9tU3R5bGVkTWFwOiBtb3ZlYWJsZUNvbnRydWN0b3IuY3VzdG9tU3R5bGVkTWFwXG4gICAgfSk7XG5cbiAgICBpZiAoaXNHcm91cCkge1xuICAgICAgaWYgKHByb3BzLmluZGl2aWR1YWxHcm91cGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAsIF9fYXNzaWduKHtcbiAgICAgICAgICBrZXk6IFwiaW5kaXZpZHVhbC1ncm91cFwiLFxuICAgICAgICAgIHJlZjogcmVmKHRoaXMsIFwibW92ZWFibGVcIilcbiAgICAgICAgfSwgbmV4dFByb3BzLCB7XG4gICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgIHRhcmdldHM6IGVsZW1lbnRUYXJnZXRzXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoTW92ZWFibGVHcm91cCwgX19hc3NpZ24oe1xuICAgICAgICBrZXk6IFwiZ3JvdXBcIixcbiAgICAgICAgcmVmOiByZWYodGhpcywgXCJtb3ZlYWJsZVwiKVxuICAgICAgfSwgbmV4dFByb3BzLCB7XG4gICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgdGFyZ2V0czogZWxlbWVudFRhcmdldHNcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoTW92ZWFibGVNYW5hZ2VyLCBfX2Fzc2lnbih7XG4gICAgICAgIGtleTogXCJzaW5nbGVcIixcbiAgICAgICAgcmVmOiByZWYodGhpcywgXCJtb3ZlYWJsZVwiKVxuICAgICAgfSwgbmV4dFByb3BzLCB7XG4gICAgICAgIHRhcmdldDogZWxlbWVudFRhcmdldHNbMF1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVSZWZzKCk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdXBkYXRlUmVmcygpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlYWJsZTtcbiAgfTtcblxuICBfX3Byb3RvLl91cGRhdGVSZWZzID0gZnVuY3Rpb24gKGlzUmVuZGVyKSB7XG4gICAgdmFyIHByZXZSZWZUYXJnZXRzID0gdGhpcy5yZWZUYXJnZXRzO1xuICAgIHZhciBuZXh0UmVmVGFyZ2V0cyA9IGdldFJlZlRhcmdldHModGhpcy5wcm9wcy50YXJnZXQgfHwgdGhpcy5wcm9wcy50YXJnZXRzKTtcbiAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc1VwZGF0ZSA9IHByZXZSZWZUYXJnZXRzLmxlbmd0aCAhPT0gbmV4dFJlZlRhcmdldHMubGVuZ3RoIHx8IHByZXZSZWZUYXJnZXRzLnNvbWUoZnVuY3Rpb24gKHRhcmdldCwgaSkge1xuICAgICAgdmFyIG5leHRUYXJnZXQgPSBuZXh0UmVmVGFyZ2V0c1tpXTtcblxuICAgICAgaWYgKCF0YXJnZXQgJiYgIW5leHRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IG5leHRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICB2YXIgc2VsZWN0b3JNYXAgPSB0aGlzLnNlbGVjdG9yTWFwO1xuICAgIHZhciBuZXh0U2VsZWN0b3JNYXAgPSB7fTtcbiAgICB0aGlzLnJlZlRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICBpZiAoIXNlbGVjdG9yTWFwW3RhcmdldF0gJiYgaXNCcm93c2VyKSB7XG4gICAgICAgICAgaXNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIG5leHRTZWxlY3Rvck1hcFt0YXJnZXRdID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRTZWxlY3Rvck1hcFt0YXJnZXRdID0gc2VsZWN0b3JNYXBbdGFyZ2V0XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVmVGFyZ2V0cyA9IG5leHRSZWZUYXJnZXRzO1xuICAgIHRoaXMuc2VsZWN0b3JNYXAgPSBuZXh0U2VsZWN0b3JNYXA7XG5cbiAgICBpZiAoIWlzUmVuZGVyICYmIGlzVXBkYXRlKSB7XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRSZWZUYXJnZXRzO1xuICB9O1xuXG4gIEluaXRpYWxNb3ZlYWJsZS5kZWZhdWx0QWJsZXMgPSBbXTtcbiAgSW5pdGlhbE1vdmVhYmxlLmN1c3RvbVN0eWxlZE1hcCA9IHt9O1xuICBJbml0aWFsTW92ZWFibGUuZGVmYXVsdFN0eWxlZCA9IG51bGw7XG5cbiAgX19kZWNvcmF0ZShbd2l0aE1ldGhvZHMoTU9WRUFCTEVfTUVUSE9EUyldLCBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLCBcIm1vdmVhYmxlXCIsIHZvaWQgMCk7XG5cbiAgcmV0dXJuIEluaXRpYWxNb3ZlYWJsZTtcbn0oUHVyZUNvbXBvbmVudCk7XG5cbnZhciBNb3ZlYWJsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNb3ZlYWJsZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBNb3ZlYWJsZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICBNb3ZlYWJsZS5kZWZhdWx0QWJsZXMgPSBNT1ZFQUJMRV9BQkxFUztcbiAgcmV0dXJuIE1vdmVhYmxlO1xufShJbml0aWFsTW92ZWFibGUpO1xuXG5mdW5jdGlvbiBtYWtlTW92ZWFibGUoYWJsZXMpIHtcbiAgdmFyIF9hO1xuXG4gIHJldHVybiBfYSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb3ZlYWJsZSwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIE1vdmVhYmxlKCkge1xuICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBNb3ZlYWJsZTtcbiAgfShJbml0aWFsTW92ZWFibGUpLCBfYS5kZWZhdWx0QWJsZXMgPSBhYmxlcywgX2E7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vdmVhYmxlO1xuZXhwb3J0IHsgQ2xpcHBhYmxlLCBEcmFnZ2FibGUsIGVkZ2VEcmFnZ2FibGUgYXMgRWRnZURyYWdnYWJsZSwgSW5pdGlhbE1vdmVhYmxlLCBNT1ZFQUJMRV9BQkxFUywgTU9WRUFCTEVfRVZFTlRTLCBNT1ZFQUJMRV9FVkVOVFNfTUFQLCBNT1ZFQUJMRV9FVkVOVFNfUFJPUFNfTUFQLCBNT1ZFQUJMRV9NRVRIT0RTLCBNT1ZFQUJMRV9QUk9QUywgTU9WRUFCTEVfUFJPUFNfTUFQLCBQaW5jaGFibGUsIFJlc2l6YWJsZSwgUm90YXRhYmxlLCBSb3VuZGFibGUsIFNjYWxhYmxlLCBTbmFwcGFibGUsIFdhcnBhYmxlLCBnZXRFbGVtZW50SW5mbywgbWFrZUFibGUsIG1ha2VNb3ZlYWJsZSB9O1xuIiwiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBmcm9tICcuL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QnO1xuZnVuY3Rpb24gdXNlT2JzZXJ2YWJsZShvYnNlcnZhYmxlJCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIF9hID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKSwgdmFsdWUgPSBfYVswXSwgdXBkYXRlID0gX2FbMV07XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzID0gb2JzZXJ2YWJsZSQuc3Vic2NyaWJlKHVwZGF0ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgfSwgW29ic2VydmFibGUkXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGRlZmF1bHQgdXNlT2JzZXJ2YWJsZTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTggRGF5YnJ1c2hcbkBuYW1lOiBAZGF5YnJ1c2gvdXRpbHNcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL3V0aWxzXG5AdmVyc2lvbiAxLjYuMFxuKi9cbi8qKlxuKiBAbmFtZXNwYWNlXG4qIEBuYW1lIENvbnN0c1xuKi9cblxuLyoqXG4qIGdldCBzdHJpbmcgXCJyZ2JcIlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7UkdCfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFJHQik7IC8vIFwicmdiXCJcbiovXG52YXIgUkdCID0gXCJyZ2JcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwicmdiYVwiXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtSR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFJHQkEpOyAvLyBcInJnYmFcIlxuKi9cblxudmFyIFJHQkEgPSBcInJnYmFcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwiaHNsXCJcbiogQG1lbWJlcm9mIENvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge0hTTH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhIU0wpOyAvLyBcImhzbFwiXG4qL1xuXG52YXIgSFNMID0gXCJoc2xcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwiaHNsYVwiXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtIU0xBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEhTTEEpOyAvLyBcImhzbGFcIlxuKi9cblxudmFyIEhTTEEgPSBcImhzbGFcIjtcbi8qKlxuKiBnZXRzIGFuIGFycmF5IG9mIGNvbG9yIG1vZGVscy5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge0NPTE9SX01PREVMU30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhDT0xPUl9NT0RFTFMpOyAvLyBbXCJyZ2JcIiwgXCJyZ2JhXCIsIFwiaHNsXCIsIFwiaHNsYVwiXTtcbiovXG5cbnZhciBDT0xPUl9NT0RFTFMgPSBbUkdCLCBSR0JBLCBIU0wsIEhTTEFdO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJmdW5jdGlvblwiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7RlVOQ1RJT059IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coRlVOQ1RJT04pOyAvLyBcImZ1bmN0aW9uXCJcbiovXG5cbnZhciBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwicHJvcGVydHlcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge1BST1BFUlRZfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFBST1BFUlRZKTsgLy8gXCJwcm9wZXJ0eVwiXG4qL1xuXG52YXIgUFJPUEVSVFkgPSBcInByb3BlcnR5XCI7XG4vKipcbiogZ2V0IHN0cmluZyBcImFycmF5XCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtBUlJBWX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhBUlJBWSk7IC8vIFwiYXJyYXlcIlxuKi9cblxudmFyIEFSUkFZID0gXCJhcnJheVwiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJvYmplY3RcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge09CSkVDVH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhPQkpFQ1QpOyAvLyBcIm9iamVjdFwiXG4qL1xuXG52YXIgT0JKRUNUID0gXCJvYmplY3RcIjtcbi8qKlxuKiBnZXQgc3RyaW5nIFwic3RyaW5nXCJcbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtTVFJJTkd9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coU1RSSU5HKTsgLy8gXCJzdHJpbmdcIlxuKi9cblxudmFyIFNUUklORyA9IFwic3RyaW5nXCI7XG4vKipcbiogZ2V0IHN0cmluZyBcIm51bWJlclwiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7TlVNQkVSfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKE5VTUJFUik7IC8vIFwibnVtYmVyXCJcbiovXG5cbnZhciBOVU1CRVIgPSBcIm51bWJlclwiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJ1bmRlZmluZWRcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhVTkRFRklORUQpOyAvLyBcInVuZGVmaW5lZFwiXG4qL1xuXG52YXIgVU5ERUZJTkVEID0gXCJ1bmRlZmluZWRcIjtcbi8qKlxuKiBDaGVjayB3aGV0aGVyIHRoZSBlbnZpcm9ubWVudCBpcyB3aW5kb3cgb3Igbm9kZS5qcy5cbiogQG1lbWJlcm9mIENvbnN0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtJU19XSU5ET1d9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coSVNfV0lORE9XKTsgLy8gZmFsc2UgaW4gbm9kZS5qc1xuY29uc29sZS5sb2coSVNfV0lORE9XKTsgLy8gdHJ1ZSBpbiBicm93c2VyXG4qL1xuXG52YXIgSVNfV0lORE9XID0gdHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZJTkVEO1xuLyoqXG4qIENoZWNrIHdoZXRoZXIgdGhlIGVudmlyb25tZW50IGlzIHdpbmRvdyBvciBub2RlLmpzLlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBuYW1lIGRvY3VtZW50XG4qIEBleGFtcGxlXG5pbXBvcnQge0lTX1dJTkRPV30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhJU19XSU5ET1cpOyAvLyBmYWxzZSBpbiBub2RlLmpzXG5jb25zb2xlLmxvZyhJU19XSU5ET1cpOyAvLyB0cnVlIGluIGJyb3dzZXJcbiovXG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFVOREVGSU5FRCAmJiBkb2N1bWVudDsgLy8gRklYTUU6IHRoaXMgdHlwZSBtYXliZSBmYWxzZVxudmFyIHByZWZpeGVzID0gW1wid2Via2l0XCIsIFwibXNcIiwgXCJtb3pcIiwgXCJvXCJdO1xuLyoqXG4gKiBAbmFtZXNwYWNlIENyb3NzQnJvd3NlclxuICovXG5cbi8qKlxuKiBHZXQgYSBDU1MgcHJvcGVydHkgd2l0aCBhIHZlbmRvciBwcmVmaXggdGhhdCBzdXBwb3J0cyBjcm9zcyBicm93c2VyLlxuKiBAZnVuY3Rpb25cbiogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gQSBDU1MgcHJvcGVydHlcbiogQHJldHVybiB7c3RyaW5nfSBDU1MgcHJvcGVydHkgd2l0aCBjcm9zcy1icm93c2VyIHZlbmRvciBwcmVmaXhcbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtnZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhnZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShcInRyYW5zZm9ybVwiKSk7IC8vIFwidHJhbnNmb3JtXCIsIFwiLW1zLXRyYW5zZm9ybVwiLCBcIi13ZWJraXQtdHJhbnNmb3JtXCJcbmNvbnNvbGUubG9nKGdldENyb3NzQnJvd3NlclByb3BlcnR5KFwiZmlsdGVyXCIpKTsgLy8gXCJmaWx0ZXJcIiwgXCItd2Via2l0LWZpbHRlclwiXG4qL1xuXG52YXIgZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gKGRvYy5ib2R5IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQpLnN0eWxlO1xuICB2YXIgbGVuZ3RoID0gcHJlZml4ZXMubGVuZ3RoO1xuXG4gIGlmICh0eXBlb2Ygc3R5bGVzW3Byb3BlcnR5XSAhPT0gVU5ERUZJTkVEKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBuYW1lID0gXCItXCIgKyBwcmVmaXhlc1tpXSArIFwiLVwiICsgcHJvcGVydHk7XG5cbiAgICBpZiAodHlwZW9mIHN0eWxlc1tuYW1lXSAhPT0gVU5ERUZJTkVEKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn07XG4vKipcbiogZ2V0IHN0cmluZyBcInRyYW5zZnJvbVwiIHdpdGggdGhlIHZlbmRvciBwcmVmaXguXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7VFJBTlNGT1JNfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKFRSQU5TRk9STSk7IC8vIFwidHJhbnNmb3JtXCIsIFwiLW1zLXRyYW5zZm9ybVwiLCBcIi13ZWJraXQtdHJhbnNmb3JtXCJcbiovXG5cbnZhciBUUkFOU0ZPUk0gPSAvKiNfX1BVUkVfXyovZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoXCJ0cmFuc2Zvcm1cIik7XG4vKipcbiogZ2V0IHN0cmluZyBcImZpbHRlclwiIHdpdGggdGhlIHZlbmRvciBwcmVmaXguXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7RklMVEVSfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEZJTFRFUik7IC8vIFwiZmlsdGVyXCIsIFwiLW1zLWZpbHRlclwiLCBcIi13ZWJraXQtZmlsdGVyXCJcbiovXG5cbnZhciBGSUxURVIgPSAvKiNfX1BVUkVfXyovZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoXCJmaWx0ZXJcIik7XG4vKipcbiogZ2V0IHN0cmluZyBcImFuaW1hdGlvblwiIHdpdGggdGhlIHZlbmRvciBwcmVmaXguXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7QU5JTUFUSU9OfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEFOSU1BVElPTik7IC8vIFwiYW5pbWF0aW9uXCIsIFwiLW1zLWFuaW1hdGlvblwiLCBcIi13ZWJraXQtYW5pbWF0aW9uXCJcbiovXG5cbnZhciBBTklNQVRJT04gPSAvKiNfX1BVUkVfXyovZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoXCJhbmltYXRpb25cIik7XG4vKipcbiogZ2V0IHN0cmluZyBcImtleWZyYW1lc1wiIHdpdGggdGhlIHZlbmRvciBwcmVmaXguXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQGV4YW1wbGVcbmltcG9ydCB7S0VZRlJBTUVTfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKEtFWUZSQU1FUyk7IC8vIFwia2V5ZnJhbWVzXCIsIFwiLW1zLWtleWZyYW1lc1wiLCBcIi13ZWJraXQta2V5ZnJhbWVzXCJcbiovXG5cbnZhciBLRVlGUkFNRVMgPSAvKiNfX1BVUkVfXyovQU5JTUFUSU9OLnJlcGxhY2UoXCJhbmltYXRpb25cIiwgXCJrZXlmcmFtZXNcIik7XG52YXIgT1BFTl9DTE9TRURfQ0hBUkFDVEVSUyA9IFt7XG4gIG9wZW46IFwiKFwiLFxuICBjbG9zZTogXCIpXCJcbn0sIHtcbiAgb3BlbjogXCJcXFwiXCIsXG4gIGNsb3NlOiBcIlxcXCJcIlxufSwge1xuICBvcGVuOiBcIidcIixcbiAgY2xvc2U6IFwiJ1wiXG59LCB7XG4gIG9wZW46IFwiXFxcXFxcXCJcIixcbiAgY2xvc2U6IFwiXFxcXFxcXCJcIlxufSwge1xuICBvcGVuOiBcIlxcXFwnXCIsXG4gIGNsb3NlOiBcIlxcXFwnXCJcbn1dO1xudmFyIFRJTllfTlVNID0gMC4wMDAwMDAxO1xudmFyIERFRkFVTFRfVU5JVF9QUkVTRVRTID0ge1xuICBcImNtXCI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICogOTYgLyAyLjU0O1xuICB9LFxuICBcIm1tXCI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zICogOTYgLyAyNTQ7XG4gIH0sXG4gIFwiaW5cIjogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MgKiA5NjtcbiAgfSxcbiAgXCJwdFwiOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvcyAqIDk2IC8gNzI7XG4gIH0sXG4gIFwicGNcIjogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiBwb3MgKiA5NiAvIDY7XG4gIH0sXG4gIFwiJVwiOiBmdW5jdGlvbiAocG9zLCBzaXplKSB7XG4gICAgcmV0dXJuIHBvcyAqIHNpemUgLyAxMDA7XG4gIH0sXG4gIFwidndcIjogZnVuY3Rpb24gKHBvcywgc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICAgIHNpemUgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zIC8gMTAwICogc2l6ZTtcbiAgfSxcbiAgXCJ2aFwiOiBmdW5jdGlvbiAocG9zLCBzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkge1xuICAgICAgc2l6ZSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zIC8gMTAwICogc2l6ZTtcbiAgfSxcbiAgXCJ2bWF4XCI6IGZ1bmN0aW9uIChwb3MsIHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcyAvIDEwMCAqIHNpemU7XG4gIH0sXG4gIFwidm1pblwiOiBmdW5jdGlvbiAocG9zLCBzaXplKSB7XG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkge1xuICAgICAgc2l6ZSA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3MgLyAxMDAgKiBzaXplO1xuICB9XG59O1xuXG4vKipcbiogQG5hbWVzcGFjZVxuKiBAbmFtZSBVdGlsc1xuKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbm5lciBwcm9kdWN0IG9mIHR3byBudW1iZXJzKGBhMWAsIGBhMmApIGJ5IHR3byBjcml0ZXJpYShgYjFgLCBgYjJgKS5cbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIC0gVGhlIGZpcnN0IG51bWJlclxuICogQHBhcmFtIC0gVGhlIHNlY29uZCBudW1iZXJcbiAqIEBwYXJhbSAtIFRoZSBmaXJzdCBudW1iZXIgdG8gYmFzZSBvbiB0aGUgaW5uZXIgcHJvZHVjdFxuICogQHBhcmFtIC0gVGhlIHNlY29uZCBudW1iZXIgdG8gYmFzZSBvbiB0aGUgaW5uZXIgcHJvZHVjdFxuICogQHJldHVybiAtIFJldHVybnMgdGhlIGlubmVyIHByb2R1Y3RcbmltcG9ydCB7IGRvdCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZG90KDAsIDE1LCAyLCAzKSk7IC8vIDZcbmNvbnNvbGUubG9nKGRvdCg1LCAxNSwgMiwgMykpOyAvLyA5XG5jb25zb2xlLmxvZyhkb3QoNSwgMTUsIDEsIDEpKTsgLy8gMTBcbiAqL1xuXG5mdW5jdGlvbiBkb3QoYTEsIGEyLCBiMSwgYjIpIHtcbiAgcmV0dXJuIChhMSAqIGIyICsgYTIgKiBiMSkgLyAoYjEgKyBiMik7XG59XG4vKipcbiogQ2hlY2sgdGhlIHR5cGUgdGhhdCB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCBmYWxzZSBvdGhlcndpc2VcbiogQGV4YW1wbGVcbmltcG9ydCB7aXNVbmRlZmluZWR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coaXNVbmRlZmluZWQodW5kZWZpbmVkKSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzVW5kZWZpbmVkKFwiXCIpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzVW5kZWZpbmVkKDEpKTsgLy8gZmFsc2VcbmNvbnNvbGUubG9nKGlzVW5kZWZpbmVkKG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFVOREVGSU5FRDtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBvYmplY3QuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzT2JqZWN0fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzT2JqZWN0KHt9KSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzT2JqZWN0KHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNPYmplY3QoXCJcIikpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNPYmplY3QobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gT0JKRUNUO1xufVxuLyoqXG4qIENoZWNrIHRoZSB0eXBlIHRoYXQgdGhlIHZhbHVlIGlzIGlzQXJyYXkuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzQXJyYXl9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coaXNBcnJheShbXSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc0FycmF5KHt9KSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc0FycmF5KHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNBcnJheShudWxsKSk7IC8vIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBzdHJpbmcuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzU3RyaW5nfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzU3RyaW5nKFwiMTIzNFwiKSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzU3RyaW5nKHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNTdHJpbmcoMSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNTdHJpbmcobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gU1RSSU5HO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gTlVNQkVSO1xufVxuLyoqXG4qIENoZWNrIHRoZSB0eXBlIHRoYXQgdGhlIHZhbHVlIGlzIGZ1bmN0aW9uLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gY2hlY2sgdGhlIHR5cGVcbiogQHJldHVybiB7fSB0cnVlIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuKiBAZXhhbXBsZVxuaW1wb3J0IHtpc0Z1bmN0aW9ufSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzRnVuY3Rpb24oZnVuY3Rpb24gYSgpIHt9KSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzRnVuY3Rpb24oKCkgPT4ge30pKTsgLy8gdHJ1ZVxuY29uc29sZS5sb2coaXNGdW5jdGlvbihcIjEyMzRcIikpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNGdW5jdGlvbigxKSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc0Z1bmN0aW9uKG51bGwpKTsgLy8gZmFsc2VcbiovXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gRlVOQ1RJT047XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxTZXBhcmF0b3IoY2hhcmFjdGVyLCBzZXBhcmF0b3IpIHtcbiAgdmFyIGlzQ2hhcmFjdGVyU3BhY2UgPSBjaGFyYWN0ZXIgPT09IFwiXCIgfHwgY2hhcmFjdGVyID09IFwiIFwiO1xuICB2YXIgaXNTZXBhcmF0b3JTcGFjZSA9IHNlcGFyYXRvciA9PT0gXCJcIiB8fCBzZXBhcmF0b3IgPT0gXCIgXCI7XG4gIHJldHVybiBpc1NlcGFyYXRvclNwYWNlICYmIGlzQ2hhcmFjdGVyU3BhY2UgfHwgY2hhcmFjdGVyID09PSBzZXBhcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGZpbmRPcGVuKG9wZW5DaGFyYWN0ZXIsIHRleHRzLCBpbmRleCwgbGVuZ3RoLCBvcGVuQ2xvc2VDaGFyYWN0ZXJzKSB7XG4gIHZhciBpc0lnbm9yZSA9IGZpbmRJZ25vcmUob3BlbkNoYXJhY3RlciwgdGV4dHMsIGluZGV4KTtcblxuICBpZiAoIWlzSWdub3JlKSB7XG4gICAgcmV0dXJuIGZpbmRDbG9zZShvcGVuQ2hhcmFjdGVyLCB0ZXh0cywgaW5kZXggKyAxLCBsZW5ndGgsIG9wZW5DbG9zZUNoYXJhY3RlcnMpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBmaW5kSWdub3JlKGNoYXJhY3RlciwgdGV4dHMsIGluZGV4KSB7XG4gIGlmICghY2hhcmFjdGVyLmlnbm9yZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG90aGVyVGV4dCA9IHRleHRzLnNsaWNlKE1hdGgubWF4KGluZGV4IC0gMywgMCksIGluZGV4ICsgMykuam9pbihcIlwiKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoY2hhcmFjdGVyLmlnbm9yZSkuZXhlYyhvdGhlclRleHQpO1xufVxuXG5mdW5jdGlvbiBmaW5kQ2xvc2UoY2xvc2VDaGFyYWN0ZXIsIHRleHRzLCBpbmRleCwgbGVuZ3RoLCBvcGVuQ2xvc2VDaGFyYWN0ZXJzKSB7XG4gIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgY2hhcmFjdGVyID0gdGV4dHNbaV0udHJpbSgpO1xuXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gY2xvc2VDaGFyYWN0ZXIuY2xvc2UgJiYgIWZpbmRJZ25vcmUoY2xvc2VDaGFyYWN0ZXIsIHRleHRzLCBpKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG5leHRJbmRleCA9IGk7IC8vIHJlIG9wZW5cblxuICAgIHZhciBvcGVuQ2hhcmFjdGVyID0gZmluZChvcGVuQ2xvc2VDaGFyYWN0ZXJzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBvcGVuID0gX2Eub3BlbjtcbiAgICAgIHJldHVybiBvcGVuID09PSBjaGFyYWN0ZXI7XG4gICAgfSk7XG5cbiAgICBpZiAob3BlbkNoYXJhY3Rlcikge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE9wZW4ob3BlbkNoYXJhY3RlciwgdGV4dHMsIGksIGxlbmd0aCwgb3BlbkNsb3NlQ2hhcmFjdGVycyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBvdXRfaV8xID0gaSwgXCJicmVha1wiO1xuICAgIH1cblxuICAgIGkgPSBuZXh0SW5kZXg7XG4gICAgb3V0X2lfMSA9IGk7XG4gIH07XG5cbiAgdmFyIG91dF9pXzE7XG5cbiAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoaSk7XG5cbiAgICBpID0gb3V0X2lfMTtcbiAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpIHJldHVybiBzdGF0ZV8xLnZhbHVlO1xuICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzcGxpdFRleHQodGV4dCwgc3BsaXRPcHRpb25zKSB7XG4gIHZhciBfYSA9IGlzU3RyaW5nKHNwbGl0T3B0aW9ucykgPyB7XG4gICAgc2VwYXJhdG9yOiBzcGxpdE9wdGlvbnNcbiAgfSA6IHNwbGl0T3B0aW9ucyxcbiAgICAgIF9iID0gX2Euc2VwYXJhdG9yLFxuICAgICAgc2VwYXJhdG9yID0gX2IgPT09IHZvaWQgMCA/IFwiLFwiIDogX2IsXG4gICAgICBpc1NlcGFyYXRlRmlyc3QgPSBfYS5pc1NlcGFyYXRlRmlyc3QsXG4gICAgICBpc1NlcGFyYXRlT25seU9wZW5DbG9zZSA9IF9hLmlzU2VwYXJhdGVPbmx5T3BlbkNsb3NlLFxuICAgICAgX2MgPSBfYS5pc1NlcGFyYXRlT3BlbkNsb3NlLFxuICAgICAgaXNTZXBhcmF0ZU9wZW5DbG9zZSA9IF9jID09PSB2b2lkIDAgPyBpc1NlcGFyYXRlT25seU9wZW5DbG9zZSA6IF9jLFxuICAgICAgX2QgPSBfYS5vcGVuQ2xvc2VDaGFyYWN0ZXJzLFxuICAgICAgb3BlbkNsb3NlQ2hhcmFjdGVycyA9IF9kID09PSB2b2lkIDAgPyBPUEVOX0NMT1NFRF9DSEFSQUNURVJTIDogX2Q7XG5cbiAgdmFyIG9wZW5DbG9zZWRUZXh0ID0gb3BlbkNsb3NlQ2hhcmFjdGVycy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG9wZW4gPSBfYS5vcGVuLFxuICAgICAgICBjbG9zZSA9IF9hLmNsb3NlO1xuXG4gICAgaWYgKG9wZW4gPT09IGNsb3NlKSB7XG4gICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BlbiArIFwifFwiICsgY2xvc2U7XG4gIH0pLmpvaW4oXCJ8XCIpO1xuICB2YXIgcmVnZXhUZXh0ID0gXCIoXFxcXHMqXCIgKyBzZXBhcmF0b3IgKyBcIlxcXFxzKnxcIiArIG9wZW5DbG9zZWRUZXh0ICsgXCJ8XFxcXHMrKVwiO1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4VGV4dCwgXCJnXCIpO1xuICB2YXIgdGV4dHMgPSB0ZXh0LnNwbGl0KHJlZ2V4KS5maWx0ZXIoQm9vbGVhbik7XG4gIHZhciBsZW5ndGggPSB0ZXh0cy5sZW5ndGg7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIHRlbXBWYWx1ZXMgPSBbXTtcblxuICBmdW5jdGlvbiByZXNldFRlbXAoKSB7XG4gICAgaWYgKHRlbXBWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZXMucHVzaCh0ZW1wVmFsdWVzLmpvaW4oXCJcIikpO1xuICAgICAgdGVtcFZhbHVlcyA9IFtdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBjaGFyYWN0ZXIgPSB0ZXh0c1tpXS50cmltKCk7XG4gICAgdmFyIG5leHRJbmRleCA9IGk7XG4gICAgdmFyIG9wZW5DaGFyYWN0ZXIgPSBmaW5kKG9wZW5DbG9zZUNoYXJhY3RlcnMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIG9wZW4gPSBfYS5vcGVuO1xuICAgICAgcmV0dXJuIG9wZW4gPT09IGNoYXJhY3RlcjtcbiAgICB9KTtcbiAgICB2YXIgY2xvc2VDaGFyYWN0ZXIgPSBmaW5kKG9wZW5DbG9zZUNoYXJhY3RlcnMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGNsb3NlID0gX2EuY2xvc2U7XG4gICAgICByZXR1cm4gY2xvc2UgPT09IGNoYXJhY3RlcjtcbiAgICB9KTtcblxuICAgIGlmIChvcGVuQ2hhcmFjdGVyKSB7XG4gICAgICBuZXh0SW5kZXggPSBmaW5kT3BlbihvcGVuQ2hhcmFjdGVyLCB0ZXh0cywgaSwgbGVuZ3RoLCBvcGVuQ2xvc2VDaGFyYWN0ZXJzKTtcblxuICAgICAgaWYgKG5leHRJbmRleCAhPT0gLTEgJiYgaXNTZXBhcmF0ZU9wZW5DbG9zZSkge1xuICAgICAgICBpZiAocmVzZXRUZW1wKCkgJiYgaXNTZXBhcmF0ZUZpcnN0KSB7XG4gICAgICAgICAgcmV0dXJuIG91dF9pXzIgPSBpLCBcImJyZWFrXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMucHVzaCh0ZXh0cy5zbGljZShpLCBuZXh0SW5kZXggKyAxKS5qb2luKFwiXCIpKTtcbiAgICAgICAgaSA9IG5leHRJbmRleDtcblxuICAgICAgICBpZiAoaXNTZXBhcmF0ZUZpcnN0KSB7XG4gICAgICAgICAgcmV0dXJuIG91dF9pXzIgPSBpLCBcImJyZWFrXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0X2lfMiA9IGksIFwiY29udGludWVcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNsb3NlQ2hhcmFjdGVyICYmICFmaW5kSWdub3JlKGNsb3NlQ2hhcmFjdGVyLCB0ZXh0cywgaSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIGNsb3NlQ2hhcmFjdGVyLmNsb3NlKTtcbiAgICB9IGVsc2UgaWYgKGlzRXF1YWxTZXBhcmF0b3IoY2hhcmFjdGVyLCBzZXBhcmF0b3IpICYmICFpc1NlcGFyYXRlT25seU9wZW5DbG9zZSkge1xuICAgICAgcmVzZXRUZW1wKCk7XG5cbiAgICAgIGlmIChpc1NlcGFyYXRlRmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIG91dF9pXzIgPSBpLCBcImJyZWFrXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRfaV8yID0gaSwgXCJjb250aW51ZVwiO1xuICAgIH1cblxuICAgIGlmIChuZXh0SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgIH1cblxuICAgIHRlbXBWYWx1ZXMucHVzaCh0ZXh0cy5zbGljZShpLCBuZXh0SW5kZXggKyAxKS5qb2luKFwiXCIpKTtcbiAgICBpID0gbmV4dEluZGV4O1xuICAgIG91dF9pXzIgPSBpO1xuICB9O1xuXG4gIHZhciBvdXRfaV8yO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgc3RhdGVfMiA9IF9sb29wXzIoaSk7XG5cbiAgICBpID0gb3V0X2lfMjtcbiAgICBpZiAoc3RhdGVfMiA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgfVxuXG4gIGlmICh0ZW1wVmFsdWVzLmxlbmd0aCkge1xuICAgIHZhbHVlcy5wdXNoKHRlbXBWYWx1ZXMuam9pbihcIlwiKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufVxuLyoqXG4qIGRpdmlkZSB0ZXh0IGJ5IHNwYWNlLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIGRpdmlkZVxuKiBAcmV0dXJuIHtBcnJheX0gZGl2aWRlZCB0ZXh0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtzcGxpY2VTcGFjZX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhzcGxpdFNwYWNlKFwiYSBiIGMgZCBlIGYgZ1wiKSk7XG4vLyBbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCJdXG5jb25zb2xlLmxvZyhzcGxpdFNwYWNlKFwiJ2EsYicgYyAnZCxlJyBmIGdcIikpO1xuLy8gW1wiJ2EsYidcIiwgXCJjXCIsIFwiJ2QsZSdcIiwgXCJmXCIsIFwiZ1wiXVxuKi9cblxuZnVuY3Rpb24gc3BsaXRTcGFjZSh0ZXh0KSB7XG4gIC8vIGRpdmlkZSBjb21tYShzcGFjZSlcbiAgcmV0dXJuIHNwbGl0VGV4dCh0ZXh0LCBcIlwiKTtcbn1cbi8qKlxuKiBkaXZpZGUgdGV4dCBieSBjb21tYS5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBkaXZpZGVcbiogQHJldHVybiB7QXJyYXl9IGRpdmlkZWQgdGV4dHNcbiogQGV4YW1wbGVcbmltcG9ydCB7c3BsaXRDb21tYX0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhzcGxpdENvbW1hKFwiYSxiLGMsZCxlLGYsZ1wiKSk7XG4vLyBbXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCJdXG5jb25zb2xlLmxvZyhzcGxpdENvbW1hKFwiJ2EsYicsYywnZCxlJyxmLGdcIikpO1xuLy8gW1wiJ2EsYidcIiwgXCJjXCIsIFwiJ2QsZSdcIiwgXCJmXCIsIFwiZ1wiXVxuKi9cblxuZnVuY3Rpb24gc3BsaXRDb21tYSh0ZXh0KSB7XG4gIC8vIGRpdmlkZSBjb21tYSgsKVxuICAvLyBcIlteXCJdKlwifCdbXiddKidcbiAgcmV0dXJuIHNwbGl0VGV4dCh0ZXh0LCBcIixcIik7XG59XG4vKipcbiogZGl2aWRlIHRleHQgYnkgYnJhY2tldCBcIihcIiwgXCIpXCIuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gZGl2aWRlXG4qIEByZXR1cm4ge29iamVjdH0gZGl2aWRlZCB0ZXh0c1xuKiBAZXhhbXBsZVxuaW1wb3J0IHtzcGxpdEJyYWNrZXR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3BsaXRCcmFja2V0KFwiYSgxLCAyKVwiKSk7XG4vLyB7cHJlZml4OiBcImFcIiwgdmFsdWU6IFwiMSwgMlwiLCBzdWZmaXg6IFwiXCJ9XG5jb25zb2xlLmxvZyhzcGxpdEJyYWNrZXQoXCJhKDEsIDIpYlwiKSk7XG4vLyB7cHJlZml4OiBcImFcIiwgdmFsdWU6IFwiMSwgMlwiLCBzdWZmaXg6IFwiYlwifVxuKi9cblxuZnVuY3Rpb24gc3BsaXRCcmFja2V0KHRleHQpIHtcbiAgdmFyIG1hdGNoZXMgPSAvKFteKF0qKVxcKChbXFxzXFxTXSopXFwpKFtcXHNcXFNdKikvZy5leGVjKHRleHQpO1xuXG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDQpIHtcbiAgICByZXR1cm4ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeDogbWF0Y2hlc1sxXSxcbiAgICAgIHZhbHVlOiBtYXRjaGVzWzJdLFxuICAgICAgc3VmZml4OiBtYXRjaGVzWzNdXG4gICAgfTtcbiAgfVxufVxuLyoqXG4qIGRpdmlkZSB0ZXh0IGJ5IG51bWJlciBhbmQgdW5pdC5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBkaXZpZGVcbiogQHJldHVybiB7fSBkaXZpZGVkIHRleHRzXG4qIEBleGFtcGxlXG5pbXBvcnQge3NwbGl0VW5pdH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhzcGxpdFVuaXQoXCIxMHB4XCIpKTtcbi8vIHtwcmVmaXg6IFwiXCIsIHZhbHVlOiAxMCwgdW5pdDogXCJweFwifVxuY29uc29sZS5sb2coc3BsaXRVbml0KFwiLTEwcHhcIikpO1xuLy8ge3ByZWZpeDogXCJcIiwgdmFsdWU6IC0xMCwgdW5pdDogXCJweFwifVxuY29uc29sZS5sb2coc3BsaXRVbml0KFwiYTEwJVwiKSk7XG4vLyB7cHJlZml4OiBcImFcIiwgdmFsdWU6IDEwLCB1bml0OiBcIiVcIn1cbiovXG5cbmZ1bmN0aW9uIHNwbGl0VW5pdCh0ZXh0KSB7XG4gIHZhciBtYXRjaGVzID0gL14oW15cXGR8ZXxcXC18XFwrXSopKCg/OlxcZHxcXC58LXxlLXxlXFwrKSspKFxcUyopJC9nLmV4ZWModGV4dCk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeDogXCJcIixcbiAgICAgIHVuaXQ6IFwiXCIsXG4gICAgICB2YWx1ZTogTmFOXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwcmVmaXggPSBtYXRjaGVzWzFdO1xuICB2YXIgdmFsdWUgPSBtYXRjaGVzWzJdO1xuICB2YXIgdW5pdCA9IG1hdGNoZXNbM107XG4gIHJldHVybiB7XG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgdW5pdDogdW5pdCxcbiAgICB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSlcbiAgfTtcbn1cbi8qKlxuKiB0cmFuc2Zvcm0gc3RyaW5ncyB0byBjYW1lbC1jYXNlXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIHN0cmluZ1xuKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsLWNhc2Ugc3RyaW5nXG4qIEBleGFtcGxlXG5pbXBvcnQge2NhbWVsaXplfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGNhbWVsaXplKFwidHJhbnNmb3JtLW9yaWdpblwiKSk7IC8vIHRyYW5zZm9ybU9yaWdpblxuY29uc29sZS5sb2coY2FtZWxpemUoXCJhYmNkX2VmZ1wiKSk7IC8vIGFiY2RFZmdcbmNvbnNvbGUubG9nKGNhbWVsaXplKFwiYWJjZCBlZmdcIikpOyAvLyBhYmNkRWZnXG4qL1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxzLV9dKFthLXpdKS9nLCBmdW5jdGlvbiAoYWxsLCBsZXR0ZXIpIHtcbiAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuLyoqXG4qIHRyYW5zZm9ybSBhIGNhbWVsaXplZCBzdHJpbmcgaW50byBhIGxvd2VyY2FzZWQgc3RyaW5nLlxuKiBAbWVtYmVyb2YgVXRpbHNcbiogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBhIGNhbWVsLWNhc2VkIHN0cmluZ1xuKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj1cIi1cIl0gLSBhIHNlcGFyYXRvclxuKiBAcmV0dXJuIHtzdHJpbmd9ICBhIGxvd2VyY2FzZWQgc3RyaW5nXG4qIEBleGFtcGxlXG5pbXBvcnQge2RlY2FtZWxpemV9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coZGVjYW1lbGl6ZShcInRyYW5zZm9ybU9yaWdpblwiKSk7IC8vIHRyYW5zZm9ybS1vcmlnaW5cbmNvbnNvbGUubG9nKGRlY2FtZWxpemUoXCJhYmNkRWZnXCIsIFwiX1wiKSk7IC8vIGFiY2RfZWZnXG4qL1xuXG5mdW5jdGlvbiBkZWNhbWVsaXplKHN0ciwgc2VwYXJhdG9yKSB7XG4gIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCkge1xuICAgIHNlcGFyYXRvciA9IFwiLVwiO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBmdW5jdGlvbiAoYWxsLCBsZXR0ZXIsIGxldHRlcjIpIHtcbiAgICByZXR1cm4gXCJcIiArIGxldHRlciArIHNlcGFyYXRvciArIGxldHRlcjIudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG4vKipcbiogdHJhbnNmb3JtcyBzb21ldGhpbmcgaW4gYW4gYXJyYXkgaW50byBhbiBhcnJheS5cbiogQG1lbWJlcm9mIFV0aWxzXG4qIEBwYXJhbSAtIEFycmF5IGZvcm1cbiogQHJldHVybiBhbiBhcnJheVxuKiBAZXhhbXBsZVxuaW1wb3J0IHt0b0FycmF5fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnN0IGFycjEgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYVwiKSk7IC8vIEVsZW1lbnRbXVxuY29uc3QgYXJyMiA9IHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MRWxlbWVudD4oXCIuYVwiKSk7IC8vIEhUTUxFbGVtZW50W11cbiovXG5cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodmFsdWUpO1xufVxuLyoqXG4qIERhdGUubm93KCkgbWV0aG9kXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHJldHVybiB7bnVtYmVyfSBtaWxsaXNlY29uZHNcbiogQGV4YW1wbGVcbmltcG9ydCB7bm93fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKG5vdygpKTsgLy8gMTIxMjEzMjQyNDEobWlsbGlzZWNvbmRzKVxuKi9cblxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG4vKipcbiogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAcGFyYW0gLSBUaGUgYXJyYXkgYGZpbmRJbmRleGAgd2FzIGNhbGxlZCB1cG9uLlxuKiBAcGFyYW0gLSBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuKiBAcGFyYW0gLSBSZXR1cm5zIGRlZmF1bHRJbmRleCBpZiBub3QgZm91bmQgYnkgdGhlIGZ1bmN0aW9uLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgZmluZEluZGV4IH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5maW5kSW5kZXgoW3thOiAxfSwge2E6IDJ9LCB7YTogM30sIHthOiA0fV0sICh7IGEgfSkgPT4gYSA9PT0gMik7IC8vIDFcbiovXG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIGNhbGxiYWNrLCBkZWZhdWx0SW5kZXgpIHtcbiAgaWYgKGRlZmF1bHRJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdEluZGV4ID0gLTE7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRJbmRleDtcbn1cbi8qKlxuKiBSZXR1cm5zIHRoZSByZXZlcnNlIGRpcmVjdGlvbiBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSAtIFRoZSBhcnJheSBgZmluZExhc3RJbmRleGAgd2FzIGNhbGxlZCB1cG9uLlxuKiBAcGFyYW0gLSBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkgdW50aWwgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgaW5kaWNhdGluZyB0aGF0IHRoZSBzYXRpc2Z5aW5nIGVsZW1lbnQgd2FzIGZvdW5kLlxuKiBAcGFyYW0gLSBSZXR1cm5zIGRlZmF1bHRJbmRleCBpZiBub3QgZm91bmQgYnkgdGhlIGZ1bmN0aW9uLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgZmluZExhc3RJbmRleCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZExhc3RJbmRleChbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XSwgKHsgYSB9KSA9PiBhID09PSAyKTsgLy8gMVxuKi9cblxuZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnIsIGNhbGxiYWNrLCBkZWZhdWx0SW5kZXgpIHtcbiAgaWYgKGRlZmF1bHRJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdEluZGV4ID0gLTE7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdEluZGV4O1xufVxuLyoqXG4qIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSByZXZlcnNlIGRpcmVjdGlvbiBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIC0gVGhlIGFycmF5IGBmaW5kTGFzdGAgd2FzIGNhbGxlZCB1cG9uLlxuKiBAcGFyYW0gLSBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXksXG4qIEBwYXJhbSAtIFJldHVybnMgZGVmYWx1dFZhbHVlIGlmIG5vdCBmb3VuZCBieSB0aGUgZnVuY3Rpb24uXG4qIEBleGFtcGxlXG5pbXBvcnQgeyBmaW5kIH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5maW5kKFt7YTogMX0sIHthOiAyfSwge2E6IDN9LCB7YTogNH1dLCAoeyBhIH0pID0+IGEgPT09IDIpOyAvLyB7YTogMn1cbiovXG5cbmZ1bmN0aW9uIGZpbmRMYXN0KGFyciwgY2FsbGJhY2ssIGRlZmFsdXRWYWx1ZSkge1xuICB2YXIgaW5kZXggPSBmaW5kTGFzdEluZGV4KGFyciwgY2FsbGJhY2spO1xuICByZXR1cm4gaW5kZXggPiAtMSA/IGFycltpbmRleF0gOiBkZWZhbHV0VmFsdWU7XG59XG4vKipcbiogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIENyb3NzQnJvd3NlclxuKiBAcGFyYW0gLSBUaGUgYXJyYXkgYGZpbmRgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LFxuKiBAcGFyYW0gLSBSZXR1cm5zIGRlZmFsdXRWYWx1ZSBpZiBub3QgZm91bmQgYnkgdGhlIGZ1bmN0aW9uLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHsgZmluZCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZChbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XSwgKHsgYSB9KSA9PiBhID09PSAyKTsgLy8ge2E6IDJ9XG4qL1xuXG5mdW5jdGlvbiBmaW5kKGFyciwgY2FsbGJhY2ssIGRlZmFsdXRWYWx1ZSkge1xuICB2YXIgaW5kZXggPSBmaW5kSW5kZXgoYXJyLCBjYWxsYmFjayk7XG4gIHJldHVybiBpbmRleCA+IC0xID8gYXJyW2luZGV4XSA6IGRlZmFsdXRWYWx1ZTtcbn1cbi8qKlxuKiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgbWV0aG9kIHdpdGggY3Jvc3MgYnJvd3Nlci5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIHtGcmFtZVJlcXVlc3RDYWxsYmFja30gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGl0J3MgdGltZSB0byB1cGRhdGUgeW91ciBhbmltYXRpb24gZm9yIHRoZSBuZXh0IHJlcGFpbnQuXG4qIEByZXR1cm4ge251bWJlcn0gaWRcbiogQGV4YW1wbGVcbmltcG9ydCB7cmVxdWVzdEFuaW1hdGlvbkZyYW1lfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gIGNvbnNvbGUubG9nKHRpbWVzdGFtcCk7XG59KTtcbiovXG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgZmlyc3RUaW1lID0gbm93KCk7XG4gIHZhciByYWYgPSBJU19XSU5ET1cgJiYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSk7XG4gIHJldHVybiByYWYgPyByYWYuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGN1cnJUaW1lID0gbm93KCk7XG4gICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soY3VyclRpbWUgLSBmaXJzdFRpbWUpO1xuICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xufSgpO1xuLyoqXG4qIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSgpIG1ldGhvZCB3aXRoIGNyb3NzIGJyb3dzZXIuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgQ3Jvc3NCcm93c2VyXG4qIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgLSB0aGUgaWQgb2J0YWluZWQgdGhyb3VnaCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbWV0aG9kXG4qIEByZXR1cm4ge3ZvaWR9XG4qIEBleGFtcGxlXG5pbXBvcnQgeyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lIH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zdCBpZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB7XG4gIGNvbnNvbGUubG9nKHRpbWVzdGFtcCk7XG59KTtcblxuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuKi9cblxudmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIGNhZiA9IElTX1dJTkRPVyAmJiAod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUpO1xuICByZXR1cm4gY2FmID8gY2FmLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgfTtcbn0oKTtcbi8qKlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBnZXRLZXlzKG9iaikge1xuICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBrZXlzKSB7XG4gICAga2V5cy5wdXNoKG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG4vKipcbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gc29ydE9yZGVycyhrZXlzLCBvcmRlcnMpIHtcbiAgaWYgKG9yZGVycyA9PT0gdm9pZCAwKSB7XG4gICAgb3JkZXJzID0gW107XG4gIH1cblxuICBrZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgaW5kZXgxID0gb3JkZXJzLmluZGV4T2YoYSk7XG4gICAgdmFyIGluZGV4MiA9IG9yZGVycy5pbmRleE9mKGIpO1xuXG4gICAgaWYgKGluZGV4MiA9PT0gLTEgJiYgaW5kZXgxID09PSAtMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4MSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmIChpbmRleDIgPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4MSAtIGluZGV4MjtcbiAgfSk7XG59XG4vKipcbiogY29udmVydCB1bml0IHNpemUgdG8gcHggc2l6ZVxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBjb252ZXJ0VW5pdFNpemUocG9zLCBzaXplKSB7XG4gIHZhciBfYSA9IHNwbGl0VW5pdChwb3MpLFxuICAgICAgdmFsdWUgPSBfYS52YWx1ZSxcbiAgICAgIHVuaXQgPSBfYS51bml0O1xuXG4gIGlmIChpc09iamVjdChzaXplKSkge1xuICAgIHZhciBzaXplRnVuY3Rpb24gPSBzaXplW3VuaXRdO1xuXG4gICAgaWYgKHNpemVGdW5jdGlvbikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oc2l6ZUZ1bmN0aW9uKSkge1xuICAgICAgICByZXR1cm4gc2l6ZUZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoREVGQVVMVF9VTklUX1BSRVNFVFNbdW5pdF0pIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfVU5JVF9QUkVTRVRTW3VuaXRdKHZhbHVlLCBzaXplRnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh1bml0ID09PSBcIiVcIikge1xuICAgIHJldHVybiB2YWx1ZSAqIHNpemUgLyAxMDA7XG4gIH1cblxuICBpZiAoREVGQVVMVF9VTklUX1BSRVNFVFNbdW5pdF0pIHtcbiAgICByZXR1cm4gREVGQVVMVF9VTklUX1BSRVNFVFNbdW5pdF0odmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4qIGNhbGN1bGF0ZSBiZXR3ZWVuIG1pbiwgbWF4XG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGJldHdlZW4odmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQm91bmRTaXplKHRhcmdldFNpemUsIGNvbXBhcmVTaXplLCBpc01heCkge1xuICByZXR1cm4gW1t0aHJvdHRsZShjb21wYXJlU2l6ZVswXSwgVElOWV9OVU0pLCB0aHJvdHRsZShjb21wYXJlU2l6ZVswXSAqIHRhcmdldFNpemVbMV0gLyB0YXJnZXRTaXplWzBdLCBUSU5ZX05VTSldLCBbdGhyb3R0bGUoY29tcGFyZVNpemVbMV0gKiB0YXJnZXRTaXplWzBdIC8gdGFyZ2V0U2l6ZVsxXSwgVElOWV9OVU0pLCB0aHJvdHRsZShjb21wYXJlU2l6ZVsxXSwgVElOWV9OVU0pXV0uZmlsdGVyKGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIHNpemUuZXZlcnkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICByZXR1cm4gaXNNYXggPyB2YWx1ZSA8PSBjb21wYXJlU2l6ZVtpXSA6IHZhbHVlID49IGNvbXBhcmVTaXplW2ldO1xuICAgIH0pO1xuICB9KVswXSB8fCB0YXJnZXRTaXplO1xufVxuLyoqXG4qIGNhbGN1bGF0ZSBib3VuZCBzaXplXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJvdW5kU2l6ZShzaXplLCBtaW5TaXplLCBtYXhTaXplLCBrZWVwUmF0aW8pIHtcbiAgaWYgKCFrZWVwUmF0aW8pIHtcbiAgICByZXR1cm4gc2l6ZS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICByZXR1cm4gYmV0d2Vlbih2YWx1ZSwgbWluU2l6ZVtpXSwgbWF4U2l6ZVtpXSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2lkdGggPSBzaXplWzBdLFxuICAgICAgaGVpZ2h0ID0gc2l6ZVsxXTsgLy8gd2lkdGggOiBoZWlnaHQgPSBtaW5XaWR0aCA6IG1pbkhlaWdodDtcblxuICB2YXIgX2EgPSBjaGVja0JvdW5kU2l6ZShzaXplLCBtaW5TaXplLCBmYWxzZSksXG4gICAgICBtaW5XaWR0aCA9IF9hWzBdLFxuICAgICAgbWluSGVpZ2h0ID0gX2FbMV07XG5cbiAgdmFyIF9iID0gY2hlY2tCb3VuZFNpemUoc2l6ZSwgbWF4U2l6ZSwgdHJ1ZSksXG4gICAgICBtYXhXaWR0aCA9IF9iWzBdLFxuICAgICAgbWF4SGVpZ2h0ID0gX2JbMV07XG5cbiAgaWYgKHdpZHRoIDwgbWluV2lkdGggfHwgaGVpZ2h0IDwgbWluSGVpZ2h0KSB7XG4gICAgd2lkdGggPSBtaW5XaWR0aDtcbiAgICBoZWlnaHQgPSBtaW5IZWlnaHQ7XG4gIH0gZWxzZSBpZiAod2lkdGggPiBtYXhXaWR0aCB8fCBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICB3aWR0aCA9IG1heFdpZHRoO1xuICAgIGhlaWdodCA9IG1heEhlaWdodDtcbiAgfVxuXG4gIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG59XG4vKipcbiogQWRkIGFsbCB0aGUgbnVtYmVycy5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gc3VtKG51bXMpIHtcbiAgdmFyIGxlbmd0aCA9IG51bXMubGVuZ3RoO1xuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHRvdGFsICs9IG51bXNbaV07XG4gIH1cblxuICByZXR1cm4gdG90YWw7XG59XG4vKipcbiogQXZlcmFnZSBhbGwgbnVtYmVycy5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gYXZlcmFnZShudW1zKSB7XG4gIHZhciBsZW5ndGggPSBudW1zLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB0b3RhbCArPSBudW1zW2ldO1xuICB9XG5cbiAgcmV0dXJuIGxlbmd0aCA/IHRvdGFsIC8gbGVuZ3RoIDogMDtcbn1cbi8qKlxuKiBHZXQgdGhlIGFuZ2xlIG9mIHR3byBwb2ludHMuICgwIDw9IHJhZCA8IDM1OSlcbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gZ2V0UmFkKHBvczEsIHBvczIpIHtcbiAgdmFyIGRpc3RYID0gcG9zMlswXSAtIHBvczFbMF07XG4gIHZhciBkaXN0WSA9IHBvczJbMV0gLSBwb3MxWzFdO1xuICB2YXIgcmFkID0gTWF0aC5hdGFuMihkaXN0WSwgZGlzdFgpO1xuICByZXR1cm4gcmFkID49IDAgPyByYWQgOiByYWQgKyBNYXRoLlBJICogMjtcbn1cbi8qKlxuKiBHZXQgdGhlIGF2ZXJhZ2UgcG9pbnQgb2YgYWxsIHBvaW50cy5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gZ2V0Q2VudGVyUG9pbnQocG9pbnRzKSB7XG4gIHJldHVybiBbMCwgMV0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF2ZXJhZ2UocG9pbnRzLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICByZXR1cm4gcG9zW2ldO1xuICAgIH0pKTtcbiAgfSk7XG59XG4vKipcbiogR2V0cyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzaGFwZS5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gZ2V0U2hhcGVEaXJlY3Rpb24ocG9pbnRzKSB7XG4gIHZhciBjZW50ZXIgPSBnZXRDZW50ZXJQb2ludChwb2ludHMpO1xuICB2YXIgcG9zMVJhZCA9IGdldFJhZChjZW50ZXIsIHBvaW50c1swXSk7XG4gIHZhciBwb3MyUmFkID0gZ2V0UmFkKGNlbnRlciwgcG9pbnRzWzFdKTtcbiAgcmV0dXJuIHBvczFSYWQgPCBwb3MyUmFkICYmIHBvczJSYWQgLSBwb3MxUmFkIDwgTWF0aC5QSSB8fCBwb3MxUmFkID4gcG9zMlJhZCAmJiBwb3MyUmFkIC0gcG9zMVJhZCA8IC1NYXRoLlBJID8gMSA6IC0xO1xufVxuLyoqXG4qIEdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuKiBAZnVuY3Rpb25cbiogQG1lbWJlcm9mIFV0aWxzXG4qL1xuXG5mdW5jdGlvbiBnZXREaXN0KGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdygoYiA/IGJbMF0gOiAwKSAtIGFbMF0sIDIpICsgTWF0aC5wb3coKGIgPyBiWzFdIDogMCkgLSBhWzFdLCAyKSk7XG59XG4vKipcbiogdGhyb3R0bGUgbnVtYmVyIGRlcGVuZGluZyBvbiB0aGUgdW5pdC5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gdGhyb3R0bGUobnVtLCB1bml0KSB7XG4gIGlmICghdW5pdCkge1xuICAgIHJldHVybiBudW07XG4gIH1cblxuICByZXR1cm4gTWF0aC5yb3VuZChudW0gLyB1bml0KSAqIHVuaXQ7XG59XG4vKipcbiogdGhyb3R0bGUgbnVtYmVyIGFycmF5IGRlcGVuZGluZyBvbiB0aGUgdW5pdC5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBVdGlsc1xuKi9cblxuZnVuY3Rpb24gdGhyb3R0bGVBcnJheShudW1zLCB1bml0KSB7XG4gIG51bXMuZm9yRWFjaChmdW5jdGlvbiAoXywgaSkge1xuICAgIG51bXNbaV0gPSB0aHJvdHRsZShudW1zW2ldLCB1bml0KTtcbiAgfSk7XG4gIHJldHVybiBudW1zO1xufVxuLyoqXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIGNvdW50ZXIobnVtKSB7XG4gIHZhciBudW1zID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07ICsraSkge1xuICAgIG51bXMucHVzaChpKTtcbiAgfVxuXG4gIHJldHVybiBudW1zO1xufVxuLyoqXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgVXRpbHNcbiovXG5cbmZ1bmN0aW9uIHJlcGxhY2VPbmNlKHRleHQsIGZyb21UZXh0LCB0b1RleHQpIHtcbiAgdmFyIGlzT25jZSA9IGZhbHNlO1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKGZyb21UZXh0LCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuXG4gICAgaWYgKGlzT25jZSkge1xuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfVxuXG4gICAgaXNPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gaXNTdHJpbmcodG9UZXh0KSA/IHRvVGV4dCA6IHRvVGV4dC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICB9KTtcbn1cblxuLyoqXG4qIEBuYW1lc3BhY2VcbiogQG5hbWUgQ29sb3JcbiovXG5cbi8qKlxuKiBSZW1vdmUgdGhlICMgZnJvbSB0aGUgaGV4IGNvbG9yLlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQHBhcmFtIHt9IGhleCAtIGhleCBjb2xvclxuKiBAcmV0dXJuIHt9IGhleCBjb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtjdXRIZXh9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coY3V0SGV4KFwiIzAwMDAwMFwiKSkgLy8gXCIwMDAwMDBcIlxuKi9cblxuZnVuY3Rpb24gY3V0SGV4KGhleCkge1xuICByZXR1cm4gaGV4LnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xufVxuLyoqXG4qIGNvbnZlcnQgaGV4IGNvbG9yIHRvIHJnYiBjb2xvci5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBwYXJhbSB7fSBoZXggLSBoZXggY29sb3JcbiogQHJldHVybiB7fSByZ2IgY29sb3JcbiogQGV4YW1wbGVcbmltcG9ydCB7aGV4VG9SR0JBfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGhleFRvUkdCQShcIiMwMDAwMDAwNVwiKSk7XG4vLyBbMCwgMCwgMCwgMV1cbmNvbnNvbGUubG9nKGhleFRvUkdCQShcIiMyMDEwNDVcIikpO1xuLy8gWzMyLCAxNiwgNjksIDFdXG4qL1xuXG5mdW5jdGlvbiBoZXhUb1JHQkEoaGV4KSB7XG4gIHZhciBoID0gY3V0SGV4KGhleCk7XG4gIHZhciByID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoMCwgMiksIDE2KTtcbiAgdmFyIGcgPSBwYXJzZUludChoLnN1YnN0cmluZygyLCA0KSwgMTYpO1xuICB2YXIgYiA9IHBhcnNlSW50KGguc3Vic3RyaW5nKDQsIDYpLCAxNik7XG4gIHZhciBhID0gcGFyc2VJbnQoaC5zdWJzdHJpbmcoNiwgOCksIDE2KSAvIDI1NTtcblxuICBpZiAoaXNOYU4oYSkpIHtcbiAgICBhID0gMTtcbiAgfVxuXG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG4vKipcbiogY29udmVydCAzKG9yIDQpLWRpZ2l0IGhleCBjb2xvciB0byA2KG9yIDgpLWRpZ2l0IGhleCBjb2xvci5cbiogQG1lbWJlcm9mIENvbG9yXG4qIEBwYXJhbSB7fSBoZXggLSAzKG9yIDQpLWRpZ2l0IGhleCBjb2xvclxuKiBAcmV0dXJuIHt9IDYob3IgOCktZGlnaXQgaGV4IGNvbG9yXG4qIEBleGFtcGxlXG5pbXBvcnQge3RvRnVsbEhleH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyh0b0Z1bGxIZXgoXCIjMTIzXCIpKTsgLy8gXCIjMTEyMjMzXCJcbmNvbnNvbGUubG9nKHRvRnVsbEhleChcIiMxMjNhXCIpKTsgLy8gXCIjMTEyMjMzYWFcIlxuKi9cblxuZnVuY3Rpb24gdG9GdWxsSGV4KGgpIHtcbiAgdmFyIHIgPSBoLmNoYXJBdCgxKTtcbiAgdmFyIGcgPSBoLmNoYXJBdCgyKTtcbiAgdmFyIGIgPSBoLmNoYXJBdCgzKTtcbiAgdmFyIGEgPSBoLmNoYXJBdCg0KTtcbiAgdmFyIGFyciA9IFtcIiNcIiwgciwgciwgZywgZywgYiwgYiwgYSwgYV07XG4gIHJldHVybiBhcnIuam9pbihcIlwiKTtcbn1cbi8qKlxuKiBjb252ZXJ0IGhzbCBjb2xvciB0byByZ2JhIGNvbG9yLlxuKiBAbWVtYmVyb2YgQ29sb3JcbiogQHBhcmFtIHt9IGhzbCAtIGhzbCBjb2xvcihodWU6IDAgfiAzNjAsIHNhdHVyYXRpb246IDAgfiAxLCBsaWdodG5lc3M6IDAgfiAxLCBhbHBoYTogMCB+IDEpXG4qIEByZXR1cm4ge30gcmdiYSBjb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtoc2xUb1JHQkF9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coaHNsVG9SR0JBKFsxNTAsIDAuNSwgMC40XSkpO1xuLy8gWzUxLCAxNTMsIDEwMiwgMV1cbiovXG5cbmZ1bmN0aW9uIGhzbFRvUkdCQShoc2wpIHtcbiAgdmFyIF9hO1xuXG4gIHZhciBoID0gaHNsWzBdO1xuICB2YXIgcyA9IGhzbFsxXTtcbiAgdmFyIGwgPSBoc2xbMl07XG5cbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSBNYXRoLmZsb29yKChNYXRoLmFicyhoKSArIDM2MCkgLyAzNjApICogMzYwO1xuICB9XG5cbiAgaCAlPSAzNjA7XG4gIHZhciBjID0gKDEgLSBNYXRoLmFicygyICogbCAtIDEpKSAqIHM7XG4gIHZhciB4ID0gYyAqICgxIC0gTWF0aC5hYnMoaCAvIDYwICUgMiAtIDEpKTtcbiAgdmFyIG0gPSBsIC0gYyAvIDI7XG4gIHZhciByZ2I7XG5cbiAgaWYgKGggPCA2MCkge1xuICAgIHJnYiA9IFtjLCB4LCAwXTtcbiAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XG4gICAgcmdiID0gW3gsIGMsIDBdO1xuICB9IGVsc2UgaWYgKGggPCAxODApIHtcbiAgICByZ2IgPSBbMCwgYywgeF07XG4gIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xuICAgIHJnYiA9IFswLCB4LCBjXTtcbiAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XG4gICAgcmdiID0gW3gsIDAsIGNdO1xuICB9IGVsc2UgaWYgKGggPCAzNjApIHtcbiAgICByZ2IgPSBbYywgMCwgeF07XG4gIH0gZWxzZSB7XG4gICAgcmdiID0gWzAsIDAsIDBdO1xuICB9XG5cbiAgcmV0dXJuIFtNYXRoLnJvdW5kKChyZ2JbMF0gKyBtKSAqIDI1NSksIE1hdGgucm91bmQoKHJnYlsxXSArIG0pICogMjU1KSwgTWF0aC5yb3VuZCgocmdiWzJdICsgbSkgKiAyNTUpLCAoX2EgPSBoc2xbM10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDFdO1xufVxuLyoqXG4qIGNvbnZlcnQgc3RyaW5nIHRvIHJnYmEgY29sb3IuXG4qIEBtZW1iZXJvZiBDb2xvclxuKiBAcGFyYW0ge30gLSAzLWhleCgjMDAwKSwgNC1oZXgoIzAwMDApIDYtaGV4KCMwMDAwMDApLCA4LWhleCgjMDAwMDAwMDApIG9yIFJHQihBKSwgb3IgSFNMKEEpXG4qIEByZXR1cm4ge30gcmdiYSBjb2xvclxuKiBAZXhhbXBsZVxuaW1wb3J0IHtzdHJpbmdUb1JHQkF9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coc3RyaW5nVG9SR0JBKFwiIzAwMDAwMFwiKSk7IC8vIFswLCAwLCAwLCAxXVxuY29uc29sZS5sb2coc3RyaW5nVG9SR0JBKFwicmdiKDEwMCwgMTAwLCAxMDApXCIpKTsgLy8gWzEwMCwgMTAwLCAxMDAsIDFdXG5jb25zb2xlLmxvZyhzdHJpbmdUb1JHQkEoXCJoc2woMTUwLCAwLjUsIDAuNClcIikpOyAvLyBbNTEsIDE1MywgMTAyLCAxXVxuKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9SR0JBKGNvbG9yKSB7XG4gIGlmIChjb2xvci5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCB8fCBjb2xvci5sZW5ndGggPT09IDUpIHtcbiAgICAgIHJldHVybiBoZXhUb1JHQkEodG9GdWxsSGV4KGNvbG9yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoZXhUb1JHQkEoY29sb3IpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb2xvci5pbmRleE9mKFwiKFwiKSAhPT0gLTEpIHtcbiAgICAvLyBpbiBicmFja2V0LlxuICAgIHZhciBfYSA9IHNwbGl0QnJhY2tldChjb2xvciksXG4gICAgICAgIHByZWZpeCA9IF9hLnByZWZpeCxcbiAgICAgICAgdmFsdWUgPSBfYS52YWx1ZTtcblxuICAgIGlmICghcHJlZml4IHx8ICF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgYXJyID0gc3BsaXRDb21tYSh2YWx1ZSk7XG4gICAgdmFyIGNvbG9yQXJyID0gWzAsIDAsIDAsIDFdO1xuICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICAgIGNhc2UgUkdCOlxuICAgICAgY2FzZSBSR0JBOlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29sb3JBcnJbaV0gPSBwYXJzZUZsb2F0KGFycltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sb3JBcnI7XG5cbiAgICAgIGNhc2UgSFNMOlxuICAgICAgY2FzZSBIU0xBOlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKGFycltpXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gcGFyc2VGbG9hdChhcnJbaV0pIC8gMTAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xvckFycltpXSA9IHBhcnNlRmxvYXQoYXJyW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaHNsLCBoc2xhIHRvIHJnYmFcblxuXG4gICAgICAgIHJldHVybiBoc2xUb1JHQkEoY29sb3JBcnIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZWxlbWVudCBkZXNjZW5kYW50cyBvZiBub2RlIHRoYXRcbiAqIG1hdGNoIHNlbGVjdG9ycy5cbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGNsYXNzIHZhbHVlIGV4aXN0cyBpbiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cbiAqIEBtZW1iZXJvZiBET01cbiAqIEBwYXJhbSAtIEEgRE9NU3RyaW5nIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc2VsZWN0b3JzIHRvIG1hdGNoXG4gKiBAcGFyYW0gLSBJZiBtdWx0aSBpcyB0cnVlLCBhIERPTVN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHNlbGVjdG9ycyB0byBtYXRjaCBhZ2FpbnN0LlxuICogQGV4YW1wbGVcbmltcG9ydCB7JH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZygkKFwiZGl2XCIpKTsgLy8gZGl2IGVsZW1lbnRcbmNvbnNvbGUubG9nKCQoXCJkaXZcIiwgdHJ1ZSkpOyAvLyBbZGl2LCBkaXZdIGVsZW1lbnRzXG4qL1xuXG5mdW5jdGlvbiAkKHNlbGVjdG9ycywgbXVsdGkpIHtcbiAgcmV0dXJuIG11bHRpID8gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzKSA6IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9ycyk7XG59XG4vKipcbiogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgY2xhc3MgdmFsdWUgZXhpc3RzIGluIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSBlbGVtZW50IC0gdGFyZ2V0XG4qIEBwYXJhbSBjbGFzc05hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byBzZWFyY2hcbiogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJuIGZhbHNlIGlmIHRoZSBjbGFzcyBpcyBub3QgZm91bmQuXG4qIEBleGFtcGxlXG5pbXBvcnQge2hhc0NsYXNzfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGhhc0NsYXNzKGVsZW1lbnQsIFwic3RhcnRcIikpOyAvLyB0cnVlIG9yIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gIH1cblxuICByZXR1cm4gISFlbGVtZW50LmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKFwiKFxcXFxzfF4pXCIgKyBjbGFzc05hbWUgKyBcIihcXFxcc3wkKVwiKSk7XG59XG4vKipcbiogQWRkIHRoZSBzcGVjaWZpZWQgY2xhc3MgdmFsdWUuIElmIHRoZXNlIGNsYXNzZSBhbHJlYWR5IGV4aXN0IGluIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIHRoZXkgYXJlIGlnbm9yZWQuXG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIGVsZW1lbnQgLSB0YXJnZXRcbiogQHBhcmFtIGNsYXNzTmFtZSAtIHRoZSBjbGFzcyBuYW1lIHRvIGFkZFxuKiBAZXhhbXBsZVxuaW1wb3J0IHthZGRDbGFzc30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5hZGRDbGFzcyhlbGVtZW50LCBcInN0YXJ0XCIpO1xuKi9cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICB9XG59XG4vKipcbiogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGNsYXNzIHZhbHVlLlxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSBlbGVtZW50IC0gdGFyZ2V0XG4qIEBwYXJhbSBjbGFzc05hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byByZW1vdmVcbiogQGV4YW1wbGVcbmltcG9ydCB7cmVtb3ZlQ2xhc3N9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxucmVtb3ZlQ2xhc3MoZWxlbWVudCwgXCJzdGFydFwiKTtcbiovXG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIihcXFxcc3xeKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHN8JClcIik7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgXCIgXCIpO1xuICB9XG59XG4vKipcbiogR2V0cyB0aGUgQ1NTIHByb3BlcnRpZXMgZnJvbSB0aGUgZWxlbWVudC5cbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gZWxlbWVudHMgLSBlbGVtZW50c1xuKiBAcGFyYW0gcHJvcGVyaXRlcyAtIHRoZSBDU1MgcHJvcGVydGllc1xuKiBAcmV0dXJuIHJldHVybnMgQ1NTIHByb3BlcnRpZXMgYW5kIHZhbHVlcy5cbiogQGV4YW1wbGVcbmltcG9ydCB7ZnJvbUNTU30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhmcm9tQ1NTKGVsZW1lbnQsIFtcImxlZnRcIiwgXCJvcGFjaXR5XCIsIFwidG9wXCJdKSk7IC8vIHtcImxlZnRcIjogXCIxMHB4XCIsIFwib3BhY2l0eVwiOiAxLCBcInRvcFwiOiBcIjEwcHhcIn1cbiovXG5cbmZ1bmN0aW9uIGZyb21DU1MoZWxlbWVudHMsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFlbGVtZW50cyB8fCAhcHJvcGVydGllcyB8fCAhcHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgZWxlbWVudDtcblxuICBpZiAoZWxlbWVudHMgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnRzO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgY3NzT2JqZWN0ID0ge307XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjc3NPYmplY3RbcHJvcGVydGllc1tpXV0gPSBzdHlsZXNbcHJvcGVydGllc1tpXV07XG4gIH1cblxuICByZXR1cm4gY3NzT2JqZWN0O1xufVxuLyoqXG4qIFNldHMgdXAgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgZXZlbnQgaXMgZGVsaXZlcmVkIHRvIHRoZSB0YXJnZXRcbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gLSBldmVudCB0YXJnZXRcbiogQHBhcmFtIC0gQSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IuXG4qIEBwYXJhbSAtIFRoZSBvYmplY3Qgd2hpY2ggcmVjZWl2ZXMgYSBub3RpZmljYXRpb24gKGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMgdGhlIEV2ZW50IGludGVyZmFjZSkgd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4qIEBwYXJhbSAtIEFuIG9wdGlvbnMgb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGNoYXJhY3RlcmlzdGljcyBhYm91dCB0aGUgZXZlbnQgbGlzdGVuZXIuXG4qIEBleGFtcGxlXG5pbXBvcnQge2FkZEV2ZW50fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmFkZEV2ZW50KGVsLCBcImNsaWNrXCIsIGUgPT4ge1xuICBjb25zb2xlLmxvZyhlKTtcbn0pO1xuKi9cblxuZnVuY3Rpb24gYWRkRXZlbnQoZWwsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xufVxuLyoqXG4qIHJlbW92ZXMgZnJvbSB0aGUgRXZlbnRUYXJnZXQgYW4gZXZlbnQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigpXG4qIEBtZW1iZXJvZiBET01cbiogQHBhcmFtIC0gZXZlbnQgdGFyZ2V0XG4qIEBwYXJhbSAtIEEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLlxuKiBAcGFyYW0gLSBUaGUgRXZlbnRMaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgaGFuZGxlciB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuKiBAcGFyYW0gLSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXQgdGhlIGV2ZW50IGxpc3RlbmVyLlxuKiBAZXhhbXBsZVxuaW1wb3J0IHthZGRFdmVudCwgcmVtb3ZlRXZlbnR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcbmNvbnN0IGxpc3RlbmVyID0gZSA9PiB7XG4gIGNvbnNvbGUubG9nKGUpO1xufTtcbmFkZEV2ZW50KGVsLCBcImNsaWNrXCIsIGxpc3RlbmVyKTtcbnJlbW92ZUV2ZW50KGVsLCBcImNsaWNrXCIsIGxpc3RlbmVyKTtcbiovXG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsLCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IHsgUkdCLCBSR0JBLCBIU0wsIEhTTEEsIENPTE9SX01PREVMUywgRlVOQ1RJT04sIFBST1BFUlRZLCBBUlJBWSwgT0JKRUNULCBTVFJJTkcsIE5VTUJFUiwgVU5ERUZJTkVELCBJU19XSU5ET1csIGRvYyBhcyBkb2N1bWVudCwgZ2V0Q3Jvc3NCcm93c2VyUHJvcGVydHksIFRSQU5TRk9STSwgRklMVEVSLCBBTklNQVRJT04sIEtFWUZSQU1FUywgT1BFTl9DTE9TRURfQ0hBUkFDVEVSUywgVElOWV9OVU0sIERFRkFVTFRfVU5JVF9QUkVTRVRTLCBjdXRIZXgsIGhleFRvUkdCQSwgdG9GdWxsSGV4LCBoc2xUb1JHQkEsIHN0cmluZ1RvUkdCQSwgZG90LCBpc1VuZGVmaW5lZCwgaXNPYmplY3QsIGlzQXJyYXksIGlzU3RyaW5nLCBpc051bWJlciwgaXNGdW5jdGlvbiwgc3BsaXRUZXh0LCBzcGxpdFNwYWNlLCBzcGxpdENvbW1hLCBzcGxpdEJyYWNrZXQsIHNwbGl0VW5pdCwgY2FtZWxpemUsIGRlY2FtZWxpemUsIHRvQXJyYXksIG5vdywgZmluZEluZGV4LCBmaW5kTGFzdEluZGV4LCBmaW5kTGFzdCwgZmluZCwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSwgZ2V0S2V5cywgc29ydE9yZGVycywgY29udmVydFVuaXRTaXplLCBiZXR3ZWVuLCBjaGVja0JvdW5kU2l6ZSwgY2FsY3VsYXRlQm91bmRTaXplLCBzdW0sIGF2ZXJhZ2UsIGdldFJhZCwgZ2V0Q2VudGVyUG9pbnQsIGdldFNoYXBlRGlyZWN0aW9uLCBnZXREaXN0LCB0aHJvdHRsZSwgdGhyb3R0bGVBcnJheSwgY291bnRlciwgcmVwbGFjZU9uY2UsICQsIGhhc0NsYXNzLCBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MsIGZyb21DU1MsIGFkZEV2ZW50LCByZW1vdmVFdmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvYWdlbnRcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9hZ2VudC5naXRcbnZlcnNpb246IDIuMy4wXG4qL1xuZnVuY3Rpb24gc29tZShhcnIsIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZChhcnIsIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpKSkge1xuICAgICAgcmV0dXJuIGFycltpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudChhZ2VudCkge1xuICB2YXIgdXNlckFnZW50ID0gYWdlbnQ7XG5cbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhbmF2aWdhdG9yKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG4gIH1cblxuICByZXR1cm4gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBleGVjUmVnRXhwKHBhdHRlcm4sIHRleHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBcImdcIikuZXhlYyh0ZXh0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBoYXNVc2VyQWdlbnREYXRhKCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhbmF2aWdhdG9yIHx8ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB1c2VyQWdlbnREYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHZhciBicmFuZHMgPSB1c2VyQWdlbnREYXRhLmJyYW5kcyB8fCB1c2VyQWdlbnREYXRhLnVhTGlzdDtcbiAgcmV0dXJuICEhKGJyYW5kcyAmJiBicmFuZHMubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZpbmRWZXJzaW9uKHZlcnNpb25UZXN0LCB1c2VyQWdlbnQpIHtcbiAgdmFyIHJlc3VsdCA9IGV4ZWNSZWdFeHAoXCIoXCIgKyB2ZXJzaW9uVGVzdCArIFwiKSgoPzpcXFxcL3xcXFxcc3w6KShbMC05fFxcXFwufF9dKykpXCIsIHVzZXJBZ2VudCk7XG4gIHJldHVybiByZXN1bHQgPyByZXN1bHRbM10gOiBcIlwiO1xufVxuZnVuY3Rpb24gY29udmVydFZlcnNpb24odGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9fL2csIFwiLlwiKTtcbn1cbmZ1bmN0aW9uIGZpbmRQcmVzZXQocHJlc2V0cywgdXNlckFnZW50KSB7XG4gIHZhciB1c2VyUHJlc2V0ID0gbnVsbDtcbiAgdmFyIHZlcnNpb24gPSBcIi0xXCI7XG4gIHNvbWUocHJlc2V0cywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHZhciByZXN1bHQgPSBleGVjUmVnRXhwKFwiKFwiICsgcHJlc2V0LnRlc3QgKyBcIikoKD86XFxcXC98XFxcXHN8OikoWzAtOXxcXFxcLnxfXSspKT9cIiwgdXNlckFnZW50KTtcblxuICAgIGlmICghcmVzdWx0IHx8IHByZXNldC5icmFuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHVzZXJQcmVzZXQgPSBwcmVzZXQ7XG4gICAgdmVyc2lvbiA9IHJlc3VsdFszXSB8fCBcIi0xXCI7XG5cbiAgICBpZiAocHJlc2V0LnZlcnNpb25BbGlhcykge1xuICAgICAgdmVyc2lvbiA9IHByZXNldC52ZXJzaW9uQWxpYXM7XG4gICAgfSBlbHNlIGlmIChwcmVzZXQudmVyc2lvblRlc3QpIHtcbiAgICAgIHZlcnNpb24gPSBmaW5kVmVyc2lvbihwcmVzZXQudmVyc2lvblRlc3QudG9Mb3dlckNhc2UoKSwgdXNlckFnZW50KSB8fCB2ZXJzaW9uO1xuICAgIH1cblxuICAgIHZlcnNpb24gPSBjb252ZXJ0VmVyc2lvbih2ZXJzaW9uKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJlc2V0OiB1c2VyUHJlc2V0LFxuICAgIHZlcnNpb246IHZlcnNpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQcmVzZXRCcmFuZChwcmVzZXRzLCBicmFuZHMpIHtcbiAgdmFyIGJyYW5kSW5mbyA9IHtcbiAgICBicmFuZDogXCJcIixcbiAgICB2ZXJzaW9uOiBcIi0xXCJcbiAgfTtcbiAgc29tZShwcmVzZXRzLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgdmFyIHJlc3VsdCA9IGZpbmRCcmFuZChicmFuZHMsIHByZXNldCk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGJyYW5kSW5mby5icmFuZCA9IHByZXNldC5pZDtcbiAgICBicmFuZEluZm8udmVyc2lvbiA9IHByZXNldC52ZXJzaW9uQWxpYXMgfHwgcmVzdWx0LnZlcnNpb247XG4gICAgcmV0dXJuIGJyYW5kSW5mby52ZXJzaW9uICE9PSBcIi0xXCI7XG4gIH0pO1xuICByZXR1cm4gYnJhbmRJbmZvO1xufVxuZnVuY3Rpb24gZmluZEJyYW5kKGJyYW5kcywgcHJlc2V0KSB7XG4gIHJldHVybiBmaW5kKGJyYW5kcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGJyYW5kID0gX2EuYnJhbmQ7XG4gICAgcmV0dXJuIGV4ZWNSZWdFeHAoXCJcIiArIHByZXNldC50ZXN0LCBicmFuZC50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG59XG5cbnZhciBCUk9XU0VSX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcInBoYW50b21qc1wiLFxuICBpZDogXCJwaGFudG9tanNcIlxufSwge1xuICB0ZXN0OiBcIndoYWxlXCIsXG4gIGlkOiBcIndoYWxlXCJcbn0sIHtcbiAgdGVzdDogXCJlZGdpb3N8ZWRnZXxlZGdcIixcbiAgaWQ6IFwiZWRnZVwiXG59LCB7XG4gIHRlc3Q6IFwibXNpZXx0cmlkZW50fHdpbmRvd3MgcGhvbmVcIixcbiAgaWQ6IFwiaWVcIixcbiAgdmVyc2lvblRlc3Q6IFwiaWVtb2JpbGV8bXNpZXxydlwiXG59LCB7XG4gIHRlc3Q6IFwibWl1aWJyb3dzZXJcIixcbiAgaWQ6IFwibWl1aSBicm93c2VyXCJcbn0sIHtcbiAgdGVzdDogXCJzYW1zdW5nYnJvd3NlclwiLFxuICBpZDogXCJzYW1zdW5nIGludGVybmV0XCJcbn0sIHtcbiAgdGVzdDogXCJzYW1zdW5nXCIsXG4gIGlkOiBcInNhbXN1bmcgaW50ZXJuZXRcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59LCB7XG4gIHRlc3Q6IFwiY2hyb21lfGNyaW9zXCIsXG4gIGlkOiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwiZmlyZWZveHxmeGlvc1wiLFxuICBpZDogXCJmaXJlZm94XCJcbn0sIHtcbiAgdGVzdDogXCJhbmRyb2lkXCIsXG4gIGlkOiBcImFuZHJvaWQgYnJvd3NlclwiLFxuICB2ZXJzaW9uVGVzdDogXCJ2ZXJzaW9uXCJcbn0sIHtcbiAgdGVzdDogXCJzYWZhcml8aXBob25lfGlwYWR8aXBvZFwiLFxuICBpZDogXCJzYWZhcmlcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59XTsgLy8gY2hyb21pdW0ncyBlbmdpbmUoYmxpbmspIGlzIGJhc2VkIG9uIGFwcGxld2Via2l0IDUzNy4zNi5cblxudmFyIENIUk9NSVVNX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcIig/PS4qYXBwbGV3ZWJraXQvKDUzWzAtN118NVswLTJdfFswLTRdKSkoPz0uKlxcXFxzY2hyb21lKVwiLFxuICBpZDogXCJjaHJvbWVcIixcbiAgdmVyc2lvblRlc3Q6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJjaHJvbWl1bVwiLFxuICBpZDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcIndoYWxlXCIsXG4gIGlkOiBcImNocm9tZVwiLFxuICB2ZXJzaW9uQWxpYXM6IFwiLTFcIixcbiAgYnJhbmQ6IHRydWVcbn1dO1xudmFyIFdFQktJVF9QUkVTRVRTID0gW3tcbiAgdGVzdDogXCJhcHBsZXdlYmtpdFwiLFxuICBpZDogXCJ3ZWJraXRcIixcbiAgdmVyc2lvblRlc3Q6IFwiYXBwbGV3ZWJraXR8c2FmYXJpXCJcbn1dO1xudmFyIFdFQlZJRVdfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwiKD89KGlwaG9uZXxpcGFkKSkoPyEoLip2ZXJzaW9uKSlcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59LCB7XG4gIHRlc3Q6IFwiKD89KGFuZHJvaWR8aXBob25lfGlwYWQpKSg/PS4qKG5hdmVyfGRhdW18OyB3dikpXCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufSwge1xuICAvLyB0ZXN0IHdlYnZpZXdcbiAgdGVzdDogXCJ3ZWJ2aWV3XCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufV07XG52YXIgT1NfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwid2luZG93cyBwaG9uZVwiLFxuICBpZDogXCJ3aW5kb3dzIHBob25lXCJcbn0sIHtcbiAgdGVzdDogXCJ3aW5kb3dzIDIwMDBcIixcbiAgaWQ6IFwid2luZG93XCIsXG4gIHZlcnNpb25BbGlhczogXCI1LjBcIlxufSwge1xuICB0ZXN0OiBcIndpbmRvd3MgbnRcIixcbiAgaWQ6IFwid2luZG93XCJcbn0sIHtcbiAgdGVzdDogXCJpcGhvbmV8aXBhZHxpcG9kXCIsXG4gIGlkOiBcImlvc1wiLFxuICB2ZXJzaW9uVGVzdDogXCJpcGhvbmUgb3N8Y3B1IG9zXCJcbn0sIHtcbiAgdGVzdDogXCJtYWMgb3MgeFwiLFxuICBpZDogXCJtYWNcIlxufSwge1xuICB0ZXN0OiBcImFuZHJvaWRcIixcbiAgaWQ6IFwiYW5kcm9pZFwiXG59LCB7XG4gIHRlc3Q6IFwidGl6ZW5cIixcbiAgaWQ6IFwidGl6ZW5cIlxufSwge1xuICB0ZXN0OiBcIndlYm9zfHdlYjBzXCIsXG4gIGlkOiBcIndlYm9zXCJcbn1dO1xuXG5mdW5jdGlvbiBwYXJzZVVzZXJBZ2VudERhdGEob3NEYXRhKSB7XG4gIHZhciB1c2VyQWdlbnREYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHZhciBicmFuZHMgPSAodXNlckFnZW50RGF0YS51YUxpc3QgfHwgdXNlckFnZW50RGF0YS5icmFuZHMpLnNsaWNlKCk7XG4gIHZhciBpc01vYmlsZSA9IHVzZXJBZ2VudERhdGEubW9iaWxlIHx8IGZhbHNlO1xuICB2YXIgZmlyc3RCcmFuZCA9IGJyYW5kc1swXTtcbiAgdmFyIGJyb3dzZXIgPSB7XG4gICAgbmFtZTogZmlyc3RCcmFuZC5icmFuZCxcbiAgICB2ZXJzaW9uOiBmaXJzdEJyYW5kLnZlcnNpb24sXG4gICAgbWFqb3JWZXJzaW9uOiAtMSxcbiAgICB3ZWJraXQ6IGZhbHNlLFxuICAgIHdlYmtpdFZlcnNpb246IFwiLTFcIixcbiAgICBjaHJvbWl1bTogZmFsc2UsXG4gICAgY2hyb21pdW1WZXJzaW9uOiBcIi0xXCIsXG4gICAgd2VidmlldzogISFmaW5kUHJlc2V0QnJhbmQoV0VCVklFV19QUkVTRVRTLCBicmFuZHMpLmJyYW5kXG4gIH07XG4gIHZhciBvcyA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMVxuICB9O1xuICBicm93c2VyLndlYmtpdCA9ICFicm93c2VyLmNocm9taXVtICYmIHNvbWUoV0VCS0lUX1BSRVNFVFMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICByZXR1cm4gZmluZEJyYW5kKGJyYW5kcywgcHJlc2V0KTtcbiAgfSk7XG4gIHZhciBjaHJvbWl1bUJyYW5kID0gZmluZFByZXNldEJyYW5kKENIUk9NSVVNX1BSRVNFVFMsIGJyYW5kcyk7XG4gIGJyb3dzZXIuY2hyb21pdW0gPSAhIWNocm9taXVtQnJhbmQuYnJhbmQ7XG4gIGJyb3dzZXIuY2hyb21pdW1WZXJzaW9uID0gY2hyb21pdW1CcmFuZC52ZXJzaW9uO1xuXG4gIGlmICghYnJvd3Nlci5jaHJvbWl1bSkge1xuICAgIHZhciB3ZWJraXRCcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChXRUJLSVRfUFJFU0VUUywgYnJhbmRzKTtcbiAgICBicm93c2VyLndlYmtpdCA9ICEhd2Via2l0QnJhbmQuYnJhbmQ7XG4gICAgYnJvd3Nlci53ZWJraXRWZXJzaW9uID0gd2Via2l0QnJhbmQudmVyc2lvbjtcbiAgfVxuXG4gIGlmIChvc0RhdGEpIHtcbiAgICB2YXIgcGxhdGZvcm1fMSA9IG9zRGF0YS5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciByZXN1bHQgPSBmaW5kKE9TX1BSRVNFVFMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXCIgKyBwcmVzZXQudGVzdCwgXCJnXCIpLmV4ZWMocGxhdGZvcm1fMSk7XG4gICAgfSk7XG4gICAgb3MubmFtZSA9IHJlc3VsdCA/IHJlc3VsdC5pZCA6IHBsYXRmb3JtXzE7XG4gICAgb3MudmVyc2lvbiA9IG9zRGF0YS5wbGF0Zm9ybVZlcnNpb247XG4gIH1cblxuICB2YXIgYnJvd3NlckJyYW5kID0gZmluZFByZXNldEJyYW5kKEJST1dTRVJfUFJFU0VUUywgYnJhbmRzKTtcblxuICBpZiAoYnJvd3NlckJyYW5kLmJyYW5kKSB7XG4gICAgYnJvd3Nlci5uYW1lID0gYnJvd3NlckJyYW5kLmJyYW5kO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IG9zRGF0YSA/IG9zRGF0YS51YUZ1bGxWZXJzaW9uIDogYnJvd3NlckJyYW5kLnZlcnNpb247XG4gIH1cblxuICBpZiAobmF2aWdhdG9yLnBsYXRmb3JtID09PSBcIkxpbnV4IGFybXY4bFwiKSB7XG4gICAgb3MubmFtZSA9IFwiYW5kcm9pZFwiO1xuICB9IGVsc2UgaWYgKGJyb3dzZXIud2Via2l0KSB7XG4gICAgb3MubmFtZSA9IGlzTW9iaWxlID8gXCJpb3NcIiA6IFwibWFjXCI7XG4gIH1cblxuICBpZiAob3MubmFtZSA9PT0gXCJpb3NcIiAmJiBicm93c2VyLndlYnZpZXcpIHtcbiAgICBicm93c2VyLnZlcnNpb24gPSBcIi0xXCI7XG4gIH1cblxuICBvcy52ZXJzaW9uID0gY29udmVydFZlcnNpb24ob3MudmVyc2lvbik7XG4gIGJyb3dzZXIudmVyc2lvbiA9IGNvbnZlcnRWZXJzaW9uKGJyb3dzZXIudmVyc2lvbik7XG4gIG9zLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KG9zLnZlcnNpb24sIDEwKTtcbiAgYnJvd3Nlci5tYWpvclZlcnNpb24gPSBwYXJzZUludChicm93c2VyLnZlcnNpb24sIDEwKTtcbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBpc01vYmlsZTogaXNNb2JpbGUsXG4gICAgaXNIaW50czogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVVzZXJBZ2VudCh1c2VyQWdlbnQpIHtcbiAgdmFyIG5leHRBZ2VudCA9IGdldFVzZXJBZ2VudCh1c2VyQWdlbnQpO1xuICB2YXIgaXNNb2JpbGUgPSAhIS9tb2JpL2cuZXhlYyhuZXh0QWdlbnQpO1xuICB2YXIgYnJvd3NlciA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMSxcbiAgICB3ZWJ2aWV3OiAhIWZpbmRQcmVzZXQoV0VCVklFV19QUkVTRVRTLCBuZXh0QWdlbnQpLnByZXNldCxcbiAgICBjaHJvbWl1bTogZmFsc2UsXG4gICAgY2hyb21pdW1WZXJzaW9uOiBcIi0xXCIsXG4gICAgd2Via2l0OiBmYWxzZSxcbiAgICB3ZWJraXRWZXJzaW9uOiBcIi0xXCJcbiAgfTtcbiAgdmFyIG9zID0ge1xuICAgIG5hbWU6IFwidW5rbm93blwiLFxuICAgIHZlcnNpb246IFwiLTFcIixcbiAgICBtYWpvclZlcnNpb246IC0xXG4gIH07XG5cbiAgdmFyIF9hID0gZmluZFByZXNldChCUk9XU0VSX1BSRVNFVFMsIG5leHRBZ2VudCksXG4gICAgICBicm93c2VyUHJlc2V0ID0gX2EucHJlc2V0LFxuICAgICAgYnJvd3NlclZlcnNpb24gPSBfYS52ZXJzaW9uO1xuXG4gIHZhciBfYiA9IGZpbmRQcmVzZXQoT1NfUFJFU0VUUywgbmV4dEFnZW50KSxcbiAgICAgIG9zUHJlc2V0ID0gX2IucHJlc2V0LFxuICAgICAgb3NWZXJzaW9uID0gX2IudmVyc2lvbjtcblxuICB2YXIgY2hyb21pdW1QcmVzZXQgPSBmaW5kUHJlc2V0KENIUk9NSVVNX1BSRVNFVFMsIG5leHRBZ2VudCk7XG4gIGJyb3dzZXIuY2hyb21pdW0gPSAhIWNocm9taXVtUHJlc2V0LnByZXNldDtcbiAgYnJvd3Nlci5jaHJvbWl1bVZlcnNpb24gPSBjaHJvbWl1bVByZXNldC52ZXJzaW9uO1xuXG4gIGlmICghYnJvd3Nlci5jaHJvbWl1bSkge1xuICAgIHZhciB3ZWJraXRQcmVzZXQgPSBmaW5kUHJlc2V0KFdFQktJVF9QUkVTRVRTLCBuZXh0QWdlbnQpO1xuICAgIGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXRQcmVzZXQucHJlc2V0O1xuICAgIGJyb3dzZXIud2Via2l0VmVyc2lvbiA9IHdlYmtpdFByZXNldC52ZXJzaW9uO1xuICB9XG5cbiAgaWYgKG9zUHJlc2V0KSB7XG4gICAgb3MubmFtZSA9IG9zUHJlc2V0LmlkO1xuICAgIG9zLnZlcnNpb24gPSBvc1ZlcnNpb247XG4gICAgb3MubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQob3NWZXJzaW9uLCAxMCk7XG4gIH1cblxuICBpZiAoYnJvd3NlclByZXNldCkge1xuICAgIGJyb3dzZXIubmFtZSA9IGJyb3dzZXJQcmVzZXQuaWQ7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gYnJvd3NlclZlcnNpb247XG5cbiAgICBpZiAoYnJvd3Nlci53ZWJ2aWV3ICYmIG9zLm5hbWUgPT09IFwiaW9zXCIgJiYgYnJvd3Nlci5uYW1lICE9PSBcInNhZmFyaVwiKSB7XG4gICAgICBicm93c2VyLndlYnZpZXcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBicm93c2VyLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KGJyb3dzZXIudmVyc2lvbiwgMTApO1xuICByZXR1cm4ge1xuICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgb3M6IG9zLFxuICAgIGlzTW9iaWxlOiBpc01vYmlsZSxcbiAgICBpc0hpbnRzOiBmYWxzZVxuICB9O1xufVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZWcuYWdlbnRcbiAqL1xuXG4vKipcbiogRXh0cmFjdHMgYWNjdWF0ZSBicm93c2VyIGFuZCBvcGVyYXRpbmcgc3lzdGVtIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIgYWdlbnQgc3RyaW5nIG9yIGNsaWVudCBoaW50cy5cbiogQGtvIOycoOyggCDsl5DsnbTsoITtirgg66y47J6Q7Je0IOuYkOuKlCBjbGllbnQgaGludHPsl5DshJwg7KCV7ZmV7ZWcIOu4jOudvOyasOyggOyZgCDsmrTsmIHssrTsoJwg7KCV67O066W8IOy2lOy2nO2VnOuLpC5cbiogQGZ1bmN0aW9uIGVnLmFnZW50I2dldEFjY3VyYXRlQWdlbnRcbiogQHBhcmFtIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZ2V0IHRoZSBhY2N1YXRlIGFnZW50IDxrbz7soJXtmZXtlZwg7JeQ7J207KCE7Yq466W8IOqwgOyguOyYpOq4sCDsnITtlZwgY2FsbGJhY2sg7ZWo7IiYPC9rbz5cbiogQHJldHVybiAtIGdldCB0aGUgYWNjdWF0ZSBhZ2VudCBwcm9taXNlLiBJZiBQcm9taXNlIGFyZSBub3Qgc3VwcG9ydGVkLCBudWxsIGlzIHJldHVybmVkLiA8a28+IOygle2Zle2VnCDsl5DsnbTsoITtirggcHJvbWlzZeulvCDqsIDsoLjsmKjri6QuIFByb21pc2Xrpbwg7KeA7JuQIO2VmOyngCDslYrripQg6rK97JqwLCBudWxs7J2EIOuwmO2ZmO2VnOuLpC4gPC9rbz5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGdldEFjY3VyYXRlQWdlbnQgfSBmcm9tIFwiQGVnanMvYWdlbnRcIjtcbi8vIGVnLmFnZW50LmdldEFjY3VyYXRlQWdlbnQoKVxuZ2V0QWNjdXJhdGVBZ2VudCgpLnRoZW4oYWdlbnQgPT4ge1xuICAgY29uc3QgeyBvcywgYnJvd3NlciwgaXNNb2JpbGUgfSA9IGFnZW50O1xufSk7XG5nZXRBY2N1cmF0ZUFnZW50KGFnZW50ID0+IHtcbiAgICBjb25zdCB7IG9zLCBicm93c2VyLCBpc01vYmlsZSB9ID0gYWdlbnQ7XG59KTtcbiovXG5cbmZ1bmN0aW9uIGdldEFjY3VyYXRlQWdlbnQoY2FsbGJhY2spIHtcbiAgaWYgKGhhc1VzZXJBZ2VudERhdGEoKSkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5nZXRIaWdoRW50cm9weVZhbHVlcyhbXCJhcmNoaXRlY3R1cmVcIiwgXCJtb2RlbFwiLCBcInBsYXRmb3JtXCIsIFwicGxhdGZvcm1WZXJzaW9uXCIsIFwidWFGdWxsVmVyc2lvblwiXSkudGhlbihmdW5jdGlvbiAoaW5mbykge1xuICAgICAgdmFyIGFnZW50SW5mbyA9IHBhcnNlVXNlckFnZW50RGF0YShpbmZvKTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGFnZW50SW5mbyk7XG4gICAgICByZXR1cm4gYWdlbnRJbmZvO1xuICAgIH0pO1xuICB9XG5cbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soYWdlbnQoKSk7XG5cbiAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcInVuZGVmaW5lZFwiIHx8ICFQcm9taXNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFnZW50KCkpO1xufVxuLyoqXG4gKiBFeHRyYWN0cyBicm93c2VyIGFuZCBvcGVyYXRpbmcgc3lzdGVtIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICogQGtvIOycoOyggCDsl5DsnbTsoITtirgg66y47J6Q7Je07JeQ7IScIOu4jOudvOyasOyggOyZgCDsmrTsmIHssrTsoJwg7KCV67O066W8IOy2lOy2nO2VnOuLpC5cbiAqIEBmdW5jdGlvbiBlZy5hZ2VudCNhZ2VudFxuICogQHBhcmFtIC0gdXNlciBhZ2VudCBzdHJpbmcgdG8gcGFyc2UgPGtvPu2MjOyLse2VoCDsnKDsoIDsl5DsnbTsoITtirgg66y47J6Q7Je0PC9rbz5cbiAqIEByZXR1cm4gLSBhZ2VudCBJbmZvIDxrbz4g7JeQ7J207KCE7Yq4IOygleuztCA8L2tvPlxuICogQGV4YW1wbGVcbmltcG9ydCBhZ2VudCBmcm9tIFwiQGVnanMvYWdlbnRcIjtcbi8vIGVnLmFnZW50KCk7XG5jb25zdCB7IG9zLCBicm93c2VyLCBpc01vYmlsZSB9ID0gYWdlbnQoKTtcbiAqL1xuXG5mdW5jdGlvbiBhZ2VudCh1c2VyQWdlbnQpIHtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09IFwidW5kZWZpbmVkXCIgJiYgaGFzVXNlckFnZW50RGF0YSgpKSB7XG4gICAgcmV0dXJuIHBhcnNlVXNlckFnZW50RGF0YSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZVVzZXJBZ2VudCh1c2VyQWdlbnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFnZW50O1xuZXhwb3J0IHsgZ2V0QWNjdXJhdGVBZ2VudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWdlbnQuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9jaGlsZHJlbi1kaWZmZXJcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY2hpbGRyZW4tZGlmZmVyXG52ZXJzaW9uOiAxLjAuMVxuKi9cbmltcG9ydCBMaXN0RGlmZmVyLCB7IGRpZmYgYXMgZGlmZiQxIH0gZnJvbSAnQGVnanMvbGlzdC1kaWZmZXInO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuLypcbmVnanMtY2hpbGRyZW4tZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgZmluZEtleUNhbGxiYWNrID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGRyZW5Db3VudCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuX19ESUZGX0tFWV9fIHx8IChlbC5fX0RJRkZfS0VZX18gPSArK2NoaWxkcmVuQ291bnQpO1xuICB9O1xufSgpO1xuXG4vKipcbiAqIEEgbW9kdWxlIHRoYXQgY2hlY2tzIGRpZmYgd2hlbiBjaGlsZCBhcmUgYWRkZWQsIHJlbW92ZWQsIG9yIGNoYW5nZWQgLlxuICogQGtvIOyekOyLnSDrhbjrk5zrk6Tsl5DshJwg7J6Q7IudIOuFuOuTnOqwgCDstpTqsIDrkJjqsbDrgpgg7IKt7KCc65CY6rGw64KYIOyInOyEnOqwgCDrs4Dqsr3rkJwg7IKs7ZWt7J2EIOyytO2BrO2VmOuKlCDrqqjrk4jsnoXri4jri6QuXG4gKiBAbWVtYmVyb2YgZWdcbiAqIEBleHRlbmRzIGVnLkxpc3REaWZmZXJcbiAqL1xuXG52YXIgQ2hpbGRyZW5EaWZmZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2hpbGRyZW5EaWZmZXIsIF9zdXBlcik7XG4gIC8qKlxuICAgKiBAcGFyYW0gLSBJbml0aWFsaXppbmcgQ2hpbGRyZW4gPGtvPiDstIjquLAg7ISk7KCV7ZWgIOyekOyLnSDrhbjrk5zrk6Q8L2tvPlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIENoaWxkcmVuRGlmZmVyKGxpc3QpIHtcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGxpc3QsIGZpbmRLZXlDYWxsYmFjaykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBDaGlsZHJlbkRpZmZlcjtcbn0oTGlzdERpZmZlcik7XG5cbi8qXG5lZ2pzLWNoaWxkcmVuLWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xuLyoqXG4gKlxuICogQG1lbWJlcm9mIGVnLkNoaWxkcmVuRGlmZmVyXG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSAtIFByZXZpb3VzIExpc3QgPGtvPiDsnbTsoIQg66qp66GdIDwva28+XG4gKiBAcGFyYW0gLSBMaXN0IHRvIFVwZGF0ZSA8a28+IOyXheuNsOydtO2KuCDtlaAg66qp66GdIDwva28+XG4gKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZGlmZiBiZXR3ZWVuIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCA8a28+IGBwcmV2TGlzdGDsmYAgYGxpc3Rg7J2YIOuLpOuluCDsoJDsnYQg67CY7ZmY7ZWc64ukLjwva28+XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZGlmZiB9IGZyb20gXCJAZWdqcy9jaGlsZHJlbi1kaWZmZXJcIjtcbiAqIC8vIHNjcmlwdCA9PiBlZy5DaGlsZHJlbkRpZmZlci5kaWZmXG4gKiBjb25zdCByZXN1bHQgPSBkaWZmKFswLCAxLCAyLCAzLCA0LCA1XSwgWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdKTtcbiAqIC8vIExpc3QgYmVmb3JlIHVwZGF0ZVxuICogLy8gWzEsIDIsIDMsIDQsIDVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucHJldkxpc3QpO1xuICogLy8gVXBkYXRlZCBsaXN0XG4gKiAvLyBbNCwgMywgNiwgMiwgMV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5saXN0KTtcbiAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyBhZGRlZCB0byBgbGlzdGBcbiAqIC8vIFswLCAxLCA1XVxuICogY29uc29sZS5sb2cocmVzdWx0LmFkZGVkKTtcbiAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyByZW1vdmVkIGluIGBwcmV2TGlzdGBcbiAqIC8vIFs1XVxuICogY29uc29sZS5sb2cocmVzdWx0LnJlbW92ZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHdpdGggZGlmZmVyZW50IGluZGV4ZXMgZnJvbSBgcHJldkxpc3RgIGFuZCBgbGlzdGBcbiAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5jaGFuZ2VkKTtcbiAqIC8vIFRoZSBzdWJzZXQgb2YgYGNoYW5nZWRgIGFuZCBhbiBhcnJheSBvZiBpbmRleCBwYWlycyB0aGF0IG1vdmVkIGRhdGEgZGlyZWN0bHkuIEluZGljYXRlIGFuIGFycmF5IG9mIGFic29sdXRlIGluZGV4IHBhaXJzIG9mIGBvcmRlcmVkYC4oRm9ybWF0dGVkIGJ5OiBBcnJheTxbaW5kZXggb2YgcHJldkxpc3QsIGluZGV4IG9mIGxpc3RdPilcbiAqIC8vIFtbNCwgM10sIFszLCA0XSwgWzIsIDZdXVxuICogY29uc29sZS5sb2cocmVzdWx0LnB1cmVDaGFuZ2VkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRvIGJlIGBvcmRlcmVkYCB0aGF0IGNhbiBzeW5jaHJvbml6ZSBgbGlzdGAgYmVmb3JlIGFkZGluZyBkYXRhLiAoRm9ybWF0dGVkIGJ5OiBBcnJheTxbcHJldkluZGV4LCBuZXh0SW5kZXhdPilcbiAqIC8vIFtbNCwgMV0sIFs0LCAyXSwgWzQsIDNdXVxuICogY29uc29sZS5sb2cocmVzdWx0Lm9yZGVyZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHRoYXQgaGF2ZSBub3QgYmVlbiBhZGRlZC9yZW1vdmVkIHNvIGRhdGEgaXMgcHJlc2VydmVkXG4gKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQubWFpbnRhaW5lZCk7XG4gKi9cblxuZnVuY3Rpb24gZGlmZihwcmV2TGlzdCwgbGlzdCkge1xuICByZXR1cm4gZGlmZiQxKHByZXZMaXN0LCBsaXN0LCBmaW5kS2V5Q2FsbGJhY2spO1xufVxuXG4vKlxuZWdqcy1jaGlsZHJlbi1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cblxuZXhwb3J0IGRlZmF1bHQgQ2hpbGRyZW5EaWZmZXI7XG5leHBvcnQgeyBkaWZmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZHJlbi1kaWZmZXIuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9saXN0LWRpZmZlclxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1saXN0LWRpZmZlclxudmVyc2lvbjogMS4wLjBcbiovXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFBvbHlNYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQb2x5TWFwKCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMudmFsdWVzID0gW107XG4gIH1cblxuICB2YXIgX19wcm90byA9IFBvbHlNYXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmtleXMuaW5kZXhPZihrZXkpXTtcbiAgfTtcblxuICBfX3Byb3RvLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBwcmV2SW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KTtcbiAgICB2YXIgaW5kZXggPSBwcmV2SW5kZXggPT09IC0xID8ga2V5cy5sZW5ndGggOiBwcmV2SW5kZXg7XG4gICAga2V5c1tpbmRleF0gPSBrZXk7XG4gICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBQb2x5TWFwO1xufSgpO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIEhhc2hNYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIYXNoTWFwKCkge1xuICAgIHRoaXMub2JqZWN0ID0ge307XG4gIH1cblxuICB2YXIgX19wcm90byA9IEhhc2hNYXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFtrZXldO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm9iamVjdFtrZXldID0gdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hNYXA7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgU1VQUE9SVF9NQVAgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCI7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgTGluayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmsoKSB7fVxuXG4gIHZhciBfX3Byb3RvID0gTGluay5wcm90b3R5cGU7XG5cbiAgX19wcm90by5jb25uZWN0ID0gZnVuY3Rpb24gKHByZXZMaW5rLCBuZXh0TGluaykge1xuICAgIHRoaXMucHJldiA9IHByZXZMaW5rO1xuICAgIHRoaXMubmV4dCA9IG5leHRMaW5rO1xuICAgIHByZXZMaW5rICYmIChwcmV2TGluay5uZXh0ID0gdGhpcyk7XG4gICAgbmV4dExpbmsgJiYgKG5leHRMaW5rLnByZXYgPSB0aGlzKTtcbiAgfTtcblxuICBfX3Byb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSW4gZG91YmxlIGxpbmtlZCBsaXN0LCBkaWNvbm5lY3QgdGhlIGludGVyY29ubmVjdGVkIHJlbGF0aW9uc2hpcC5cbiAgICB2YXIgcHJldkxpbmsgPSB0aGlzLnByZXY7XG4gICAgdmFyIG5leHRMaW5rID0gdGhpcy5uZXh0O1xuICAgIHByZXZMaW5rICYmIChwcmV2TGluay5uZXh0ID0gbmV4dExpbmspO1xuICAgIG5leHRMaW5rICYmIChuZXh0TGluay5wcmV2ID0gcHJldkxpbmspO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzO1xuICAgIHZhciBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKGxpbmspIHtcbiAgICAgIGxpbmsgPSBsaW5rLnByZXY7XG4gICAgICArK2luZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICByZXR1cm4gTGluaztcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cblxuZnVuY3Rpb24gb3JkZXJDaGFuZ2VkKGNoYW5nZWQsIGZpeGVkKSB7XG4gIC8vIEl0IGlzIHJvdWdobHkgaW4gdGhlIG9yZGVyIG9mIHRoZXNlIGV4YW1wbGVzLlxuICAvLyA0LCA2LCAwLCAyLCAxLCAzLCA1LCA3XG4gIHZhciBmcm9tTGlua3MgPSBbXTsgLy8gMCwgMSwgMiwgMywgNCwgNSwgNiwgN1xuXG4gIHZhciB0b0xpbmtzID0gW107XG4gIGNoYW5nZWQuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZnJvbSA9IF9hWzBdLFxuICAgICAgICB0byA9IF9hWzFdO1xuICAgIHZhciBsaW5rID0gbmV3IExpbmsoKTtcbiAgICBmcm9tTGlua3NbZnJvbV0gPSBsaW5rO1xuICAgIHRvTGlua3NbdG9dID0gbGluaztcbiAgfSk7IC8vIGBmcm9tTGlua3NgIGFyZSBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlciBieSBkb3VibGUgbGlua2VkIGxpc3QuXG5cbiAgZnJvbUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmssIGkpIHtcbiAgICBsaW5rLmNvbm5lY3QoZnJvbUxpbmtzW2kgLSAxXSk7XG4gIH0pO1xuICByZXR1cm4gY2hhbmdlZC5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICByZXR1cm4gIWZpeGVkW2ldO1xuICB9KS5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbUxpbmsgPSBmcm9tTGlua3NbZnJvbV07XG4gICAgdmFyIHRvTGluayA9IHRvTGlua3NbdG8gLSAxXTtcbiAgICB2YXIgZnJvbUluZGV4ID0gZnJvbUxpbmsuZ2V0SW5kZXgoKTsgLy8gRGlzY29ubmVjdCB0aGUgbGluayBjb25uZWN0ZWQgdG8gYGZyb21MaW5rYC5cblxuICAgIGZyb21MaW5rLmRpc2Nvbm5lY3QoKTsgLy8gQ29ubmVjdCBgZnJvbUxpbmtgIHRvIHRoZSByaWdodCBvZiBgdG9MaW5rYC5cblxuICAgIGlmICghdG9MaW5rKSB7XG4gICAgICBmcm9tTGluay5jb25uZWN0KHVuZGVmaW5lZCwgZnJvbUxpbmtzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbUxpbmsuY29ubmVjdCh0b0xpbmssIHRvTGluay5uZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgdG9JbmRleCA9IGZyb21MaW5rLmdldEluZGV4KCk7XG4gICAgcmV0dXJuIFtmcm9tSW5kZXgsIHRvSW5kZXhdO1xuICB9KTtcbn1cblxudmFyIFJlc3VsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3VsdChwcmV2TGlzdCwgbGlzdCwgYWRkZWQsIHJlbW92ZWQsIGNoYW5nZWQsIG1haW50YWluZWQsIGNoYW5nZWRCZWZvcmVBZGRlZCwgZml4ZWQpIHtcbiAgICB0aGlzLnByZXZMaXN0ID0gcHJldkxpc3Q7XG4gICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB0aGlzLmFkZGVkID0gYWRkZWQ7XG4gICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB0aGlzLmNoYW5nZWQgPSBjaGFuZ2VkO1xuICAgIHRoaXMubWFpbnRhaW5lZCA9IG1haW50YWluZWQ7XG4gICAgdGhpcy5jaGFuZ2VkQmVmb3JlQWRkZWQgPSBjaGFuZ2VkQmVmb3JlQWRkZWQ7XG4gICAgdGhpcy5maXhlZCA9IGZpeGVkO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBSZXN1bHQucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJvcmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5jYWNoZU9yZGVyZWQpIHtcbiAgICAgICAgdGhpcy5jYWN1bGF0ZU9yZGVyZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVPcmRlcmVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInB1cmVDaGFuZ2VkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5jYWNoZVB1cmVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuY2FjdWxhdGVPcmRlcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUHVyZUNoYW5nZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBfX3Byb3RvLmNhY3VsYXRlT3JkZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JkZXJlZCA9IG9yZGVyQ2hhbmdlZCh0aGlzLmNoYW5nZWRCZWZvcmVBZGRlZCwgdGhpcy5maXhlZCk7XG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgdmFyIHB1cmVDaGFuZ2VkID0gW107XG4gICAgdGhpcy5jYWNoZU9yZGVyZWQgPSBvcmRlcmVkLmZpbHRlcihmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgICAgdG8gPSBfYVsxXTtcbiAgICAgIHZhciBfYiA9IGNoYW5nZWRbaV0sXG4gICAgICAgICAgZnJvbUJlZm9yZSA9IF9iWzBdLFxuICAgICAgICAgIHRvQmVmb3JlID0gX2JbMV07XG5cbiAgICAgIGlmIChmcm9tICE9PSB0bykge1xuICAgICAgICBwdXJlQ2hhbmdlZC5wdXNoKFtmcm9tQmVmb3JlLCB0b0JlZm9yZV0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlUHVyZUNoYW5nZWQgPSBwdXJlQ2hhbmdlZDtcbiAgfTtcblxuICByZXR1cm4gUmVzdWx0O1xufSgpO1xuXG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgZWcuTGlzdERpZmZlclxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0gLSBQcmV2aW91cyBMaXN0IDxrbz4g7J207KCEIOuqqeuhnSA8L2tvPlxuICogQHBhcmFtIC0gTGlzdCB0byBVcGRhdGUgPGtvPiDsl4XrjbDsnbTtirgg7ZWgIOuqqeuhnSA8L2tvPlxuICogQHBhcmFtIC0gVGhpcyBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0uIDxrbz4g7JWE7J207YWc7J2YIO2CpOulvCDrsJjtmZjtlZjripQg7L2c67CxIO2VqOyImOyeheuLiOuLpC48L2tvPlxuICogQHJldHVybiAtIFJldHVybnMgdGhlIGRpZmYgYmV0d2VlbiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgPGtvPiBgcHJldkxpc3Rg7JmAIGBsaXN0YOydmCDri6Trpbgg7KCQ7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGRpZmYgfSBmcm9tIFwiQGVnanMvbGlzdC1kaWZmZXJcIjtcbiAqIC8vIHNjcmlwdCA9PiBlZy5MaXN0RGlmZmVyLmRpZmZcbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmYoWzAsIDEsIDIsIDMsIDQsIDVdLCBbNywgOCwgMCwgNCwgMywgNiwgMiwgMV0sIGUgPT4gZSk7XG4gKiAvLyBMaXN0IGJlZm9yZSB1cGRhdGVcbiAqIC8vIFsxLCAyLCAzLCA0LCA1XVxuICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAqIC8vIFVwZGF0ZWQgbGlzdFxuICogLy8gWzQsIDMsIDYsIDIsIDFdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgYWRkZWQgdG8gYGxpc3RgXG4gKiAvLyBbMCwgMSwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5hZGRlZCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgXG4gKiAvLyBbNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5yZW1vdmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB3aXRoIGRpZmZlcmVudCBpbmRleGVzIGZyb20gYHByZXZMaXN0YCBhbmQgYGxpc3RgXG4gKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gKiAvLyBUaGUgc3Vic2V0IG9mIGBjaGFuZ2VkYCBhbmQgYW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdGhhdCBtb3ZlZCBkYXRhIGRpcmVjdGx5LiBJbmRpY2F0ZSBhbiBhcnJheSBvZiBhYnNvbHV0ZSBpbmRleCBwYWlycyBvZiBgb3JkZXJlZGAuKEZvcm1hdHRlZCBieTogQXJyYXk8W2luZGV4IG9mIHByZXZMaXN0LCBpbmRleCBvZiBsaXN0XT4pXG4gKiAvLyBbWzQsIDNdLCBbMywgNF0sIFsyLCA2XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyB0byBiZSBgb3JkZXJlZGAgdGhhdCBjYW4gc3luY2hyb25pemUgYGxpc3RgIGJlZm9yZSBhZGRpbmcgZGF0YS4gKEZvcm1hdHRlZCBieTogQXJyYXk8W3ByZXZJbmRleCwgbmV4dEluZGV4XT4pXG4gKiAvLyBbWzQsIDFdLCBbNCwgMl0sIFs0LCAzXV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB0aGF0IGhhdmUgbm90IGJlZW4gYWRkZWQvcmVtb3ZlZCBzbyBkYXRhIGlzIHByZXNlcnZlZFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0Lm1haW50YWluZWQpO1xuICovXG5cbmZ1bmN0aW9uIGRpZmYocHJldkxpc3QsIGxpc3QsIGZpbmRLZXlDYWxsYmFjaykge1xuICB2YXIgbWFwQ2xhc3MgPSBTVVBQT1JUX01BUCA/IE1hcCA6IGZpbmRLZXlDYWxsYmFjayA/IEhhc2hNYXAgOiBQb2x5TWFwO1xuXG4gIHZhciBjYWxsYmFjayA9IGZpbmRLZXlDYWxsYmFjayB8fCBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlO1xuICB9O1xuXG4gIHZhciBhZGRlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZCA9IFtdO1xuICB2YXIgbWFpbnRhaW5lZCA9IFtdO1xuICB2YXIgcHJldktleXMgPSBwcmV2TGlzdC5tYXAoY2FsbGJhY2spO1xuICB2YXIga2V5cyA9IGxpc3QubWFwKGNhbGxiYWNrKTtcbiAgdmFyIHByZXZLZXlNYXAgPSBuZXcgbWFwQ2xhc3MoKTtcbiAgdmFyIGtleU1hcCA9IG5ldyBtYXBDbGFzcygpO1xuICB2YXIgY2hhbmdlZEJlZm9yZUFkZGVkID0gW107XG4gIHZhciBmaXhlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZE1hcCA9IHt9O1xuICB2YXIgY2hhbmdlZCA9IFtdO1xuICB2YXIgYWRkZWRDb3VudCA9IDA7XG4gIHZhciByZW1vdmVkQ291bnQgPSAwOyAvLyBBZGQgcHJldktleXMgYW5kIGtleXMgdG8gdGhlIGhhc2htYXAuXG5cbiAgcHJldktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBwcmV2TGlzdEluZGV4KSB7XG4gICAgcHJldktleU1hcC5zZXQoa2V5LCBwcmV2TGlzdEluZGV4KTtcbiAgfSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBsaXN0SW5kZXgpIHtcbiAgICBrZXlNYXAuc2V0KGtleSwgbGlzdEluZGV4KTtcbiAgfSk7IC8vIENvbXBhcmUgYHByZXZLZXlzYCBhbmQgYGtleXNgIGFuZCBhZGQgdGhlbSB0byBgcmVtb3ZlZGAgaWYgdGhleSBhcmUgbm90IGluIGBrZXlzYC5cblxuICBwcmV2S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIHByZXZMaXN0SW5kZXgpIHtcbiAgICB2YXIgbGlzdEluZGV4ID0ga2V5TWFwLmdldChrZXkpOyAvLyBJbiBwcmV2TGlzdCwgYnV0IG5vdCBpbiBsaXN0LCBpdCBpcyByZW1vdmVkLlxuXG4gICAgaWYgKHR5cGVvZiBsaXN0SW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICsrcmVtb3ZlZENvdW50O1xuICAgICAgcmVtb3ZlZC5wdXNoKHByZXZMaXN0SW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVkTWFwW2xpc3RJbmRleF0gPSByZW1vdmVkQ291bnQ7XG4gICAgfVxuICB9KTsgLy8gQ29tcGFyZSBgcHJldktleXNgIGFuZCBga2V5c2AgYW5kIGFkZCB0aGVtIHRvIGBhZGRlZGAgaWYgdGhleSBhcmUgbm90IGluIGBwcmV2S2V5c2AuXG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGxpc3RJbmRleCkge1xuICAgIHZhciBwcmV2TGlzdEluZGV4ID0gcHJldktleU1hcC5nZXQoa2V5KTsgLy8gSW4gbGlzdCwgYnV0IG5vdCBpbiBwcmV2TGlzdCwgaXQgaXMgYWRkZWQuXG5cbiAgICBpZiAodHlwZW9mIHByZXZMaXN0SW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGFkZGVkLnB1c2gobGlzdEluZGV4KTtcbiAgICAgICsrYWRkZWRDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFpbnRhaW5lZC5wdXNoKFtwcmV2TGlzdEluZGV4LCBsaXN0SW5kZXhdKTtcbiAgICAgIHJlbW92ZWRDb3VudCA9IHJlbW92ZWRNYXBbbGlzdEluZGV4XSB8fCAwO1xuICAgICAgY2hhbmdlZEJlZm9yZUFkZGVkLnB1c2goW3ByZXZMaXN0SW5kZXggLSByZW1vdmVkQ291bnQsIGxpc3RJbmRleCAtIGFkZGVkQ291bnRdKTtcbiAgICAgIGZpeGVkLnB1c2gobGlzdEluZGV4ID09PSBwcmV2TGlzdEluZGV4KTtcblxuICAgICAgaWYgKHByZXZMaXN0SW5kZXggIT09IGxpc3RJbmRleCkge1xuICAgICAgICBjaGFuZ2VkLnB1c2goW3ByZXZMaXN0SW5kZXgsIGxpc3RJbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIFNvcnQgYnkgYXNjZW5kaW5nIG9yZGVyIG9mICd0byhsaXN0J3MgaW5kZXgpLlxuXG4gIHJlbW92ZWQucmV2ZXJzZSgpO1xuICByZXR1cm4gbmV3IFJlc3VsdChwcmV2TGlzdCwgbGlzdCwgYWRkZWQsIHJlbW92ZWQsIGNoYW5nZWQsIG1haW50YWluZWQsIGNoYW5nZWRCZWZvcmVBZGRlZCwgZml4ZWQpO1xufVxuXG4vKipcbiAqIEEgbW9kdWxlIHRoYXQgY2hlY2tzIGRpZmYgd2hlbiB2YWx1ZXMgYXJlIGFkZGVkLCByZW1vdmVkLCBvciBjaGFuZ2VkIGluIGFuIGFycmF5LlxuICogQGtvIOuwsOyXtCDrmJDripQg7Jik67iM7KCd7Yq47JeQ7IScIOqwkuydtCDstpTqsIDrkJjqsbDrgpgg7IKt7KCc65CY6rGw64KYIOyInOyEnOqwgCDrs4Dqsr3sgqztla3snYQg7LK07YGs7ZWY64qUIOuqqOuTiOyeheuLiOuLpC5cbiAqIEBtZW1iZXJvZiBlZ1xuICovXG5cbnZhciBMaXN0RGlmZmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSAtIEluaXRpYWxpemluZyBEYXRhIEFycmF5LiA8a28+IOy0iOq4sCDshKTsoJXtlaAg642w7J207YSwIOuwsOyXtC48L2tvPlxuICAgKiBAcGFyYW0gLSBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbS4gPGtvPiDslYTsnbTthZzsnZgg7YKk66W8IOuwmO2ZmO2VmOuKlCDsvZzrsLEg7ZWo7IiY7J6F64uI64ukLjwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBMaXN0RGlmZmVyIGZyb20gXCJAZWdqcy9saXN0LWRpZmZlclwiO1xuICAgKiAvLyBzY3JpcHQgPT4gZWcuTGlzdERpZmZlclxuICAgKiBjb25zdCBkaWZmZXIgPSBuZXcgTGlzdERpZmZlcihbMCwgMSwgMiwgMywgNCwgNV0sIGUgPT4gZSk7XG4gICAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlci51cGRhdGUoWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdKTtcbiAgICogLy8gTGlzdCBiZWZvcmUgdXBkYXRlXG4gICAqIC8vIFsxLCAyLCAzLCA0LCA1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQucHJldkxpc3QpO1xuICAgKiAvLyBVcGRhdGVkIGxpc3RcbiAgICogLy8gWzQsIDMsIDYsIDIsIDFdXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5saXN0KTtcbiAgICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIGFkZGVkIHRvIGBsaXN0YC5cbiAgICogLy8gWzAsIDEsIDVdXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5hZGRlZCk7XG4gICAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyByZW1vdmVkIGluIGBwcmV2TGlzdGAuXG4gICAqIC8vIFs1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQucmVtb3ZlZCk7XG4gICAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB3aXRoIGRpZmZlcmVudCBpbmRleGVzIGZyb20gYHByZXZMaXN0YCBhbmQgYGxpc3RgLlxuICAgKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5jaGFuZ2VkKTtcbiAgICogLy8gVGhlIHN1YnNldCBvZiBgY2hhbmdlZGAgYW5kIGFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRoYXQgbW92ZWQgZGF0YSBkaXJlY3RseS4gSW5kaWNhdGUgYW4gYXJyYXkgb2YgYWJzb2x1dGUgaW5kZXggcGFpcnMgb2YgYG9yZGVyZWRgLihGb3JtYXR0ZWQgYnk6IEFycmF5PFtpbmRleCBvZiBwcmV2TGlzdCwgaW5kZXggb2YgbGlzdF0+KVxuICAgKiAvLyBbWzQsIDNdLCBbMywgNF0sIFsyLCA2XV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnB1cmVDaGFuZ2VkKTtcbiAgICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdG8gYmUgYG9yZGVyZWRgIHRoYXQgY2FuIHN5bmNocm9uaXplIGBsaXN0YCBiZWZvcmUgYWRkaW5nIGRhdGEuIChGb3JtYXR0ZWQgYnk6IEFycmF5PFtwcmV2SW5kZXgsIG5leHRJbmRleF0+KVxuICAgKiAvLyBbWzQsIDFdLCBbNCwgMl0sIFs0LCAzXV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0Lm9yZGVyZWQpO1xuICAgKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgdGhhdCBoYXZlIG5vdCBiZWVuIGFkZGVkL3JlbW92ZWQgc28gZGF0YSBpcyBwcmVzZXJ2ZWQuXG4gICAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0Lm1haW50YWluZWQpO1xuICAgKi9cbiAgZnVuY3Rpb24gTGlzdERpZmZlcihsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHtcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5maW5kS2V5Q2FsbGJhY2sgPSBmaW5kS2V5Q2FsbGJhY2s7XG4gICAgdGhpcy5saXN0ID0gW10uc2xpY2UuY2FsbChsaXN0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGxpc3QuXG4gICAqIEBrbyDrpqzsiqTtirjrpbwg7JeF642w7J207Yq466W8IO2VqeuLiOuLpC5cbiAgICogQHBhcmFtIC0gTGlzdCB0byB1cGRhdGUgPGtvPiDsl4XrjbDsnbTtirjtlaAg66as7Iqk7Yq4IDwva28+XG4gICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFuIHVwZGF0ZSBmcm9tIGBwcmV2TGlzdGAgdG8gYGxpc3RgLjxrbz4gYHByZXZMaXN0YOyXkOyEnCBgbGlzdGDroZwg7JeF642w7J207Yq47ZWcIOqysOqzvOulvCDrsJjtmZjtlZzri6QuIDwva28+XG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBMaXN0RGlmZmVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgdmFyIG5ld0RhdGEgPSBbXS5zbGljZS5jYWxsKGxpc3QpO1xuICAgIHZhciByZXN1bHQgPSBkaWZmKHRoaXMubGlzdCwgbmV3RGF0YSwgdGhpcy5maW5kS2V5Q2FsbGJhY2spO1xuICAgIHRoaXMubGlzdCA9IG5ld0RhdGE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gTGlzdERpZmZlcjtcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cblxuZXhwb3J0IGRlZmF1bHQgTGlzdERpZmZlcjtcbmV4cG9ydCB7IGRpZmYgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QtZGlmZmVyLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IEBzY2VuYS9kcmFnc2Nyb2xsXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvZHJhZ3Njcm9sbC5naXRcbnZlcnNpb246IDEuMS4xXG4qL1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdAc2NlbmEvZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgeyBub3cgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0U2Nyb2xsUG9zaXRpb24oZSkge1xuICB2YXIgY29udGFpbmVyID0gZS5jb250YWluZXI7XG5cbiAgaWYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBbY29udGFpbmVyLnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsIGNvbnRhaW5lci5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcF07XG4gIH1cblxuICByZXR1cm4gW2NvbnRhaW5lci5zY3JvbGxMZWZ0LCBjb250YWluZXIuc2Nyb2xsVG9wXTtcbn1cblxudmFyIERyYWdTY3JvbGwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRHJhZ1Njcm9sbCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBEcmFnU2Nyb2xsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuX3N0YXJ0UmVjdCA9IG51bGw7XG4gICAgX3RoaXMuX3N0YXJ0UG9zID0gW107XG4gICAgX3RoaXMuX3ByZXZUaW1lID0gMDtcbiAgICBfdGhpcy5fdGltZXIgPSAwO1xuICAgIF90aGlzLl9wcmV2U2Nyb2xsUG9zID0gWzAsIDBdO1xuICAgIF90aGlzLl9pc1dhaXQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IERyYWdTY3JvbGwucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgdmFyIHRvcCA9IDA7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGhlaWdodCA9IDA7XG5cbiAgICBpZiAoY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRvcCA9IHJlY3QudG9wO1xuICAgICAgbGVmdCA9IHJlY3QubGVmdDtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0UG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICB0aGlzLl9zdGFydFJlY3QgPSB7XG4gICAgICB0b3A6IHRvcCxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gICAgdGhpcy5fcHJldlNjcm9sbFBvcyA9IHRoaXMuX2dldFNjcm9sbFBvc2l0aW9uKFswLCAwXSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgX19wcm90by5kcmFnID0gZnVuY3Rpb24gKGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2xpZW50WCA9IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WSA9IGUuY2xpZW50WTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnRocmVzaG9sZCxcbiAgICAgICAgdGhyZXNob2xkID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYTtcblxuICAgIHZhciBfYiA9IHRoaXMsXG4gICAgICAgIF9zdGFydFJlY3QgPSBfYi5fc3RhcnRSZWN0LFxuICAgICAgICBfc3RhcnRQb3MgPSBfYi5fc3RhcnRQb3M7XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gWzAsIDBdO1xuXG4gICAgaWYgKF9zdGFydFJlY3QudG9wID4gY2xpZW50WSAtIHRocmVzaG9sZCkge1xuICAgICAgaWYgKF9zdGFydFBvc1sxXSA+IF9zdGFydFJlY3QudG9wIHx8IGNsaWVudFkgPCBfc3RhcnRQb3NbMV0pIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gLTE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfc3RhcnRSZWN0LnRvcCArIF9zdGFydFJlY3QuaGVpZ2h0IDwgY2xpZW50WSArIHRocmVzaG9sZCkge1xuICAgICAgaWYgKF9zdGFydFBvc1sxXSA8IF9zdGFydFJlY3QudG9wICsgX3N0YXJ0UmVjdC5oZWlnaHQgfHwgY2xpZW50WSA+IF9zdGFydFBvc1sxXSkge1xuICAgICAgICBkaXJlY3Rpb25bMV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfc3RhcnRSZWN0LmxlZnQgPiBjbGllbnRYIC0gdGhyZXNob2xkKSB7XG4gICAgICBpZiAoX3N0YXJ0UG9zWzBdID4gX3N0YXJ0UmVjdC5sZWZ0IHx8IGNsaWVudFggPCBfc3RhcnRQb3NbMF0pIHtcbiAgICAgICAgZGlyZWN0aW9uWzBdID0gLTE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfc3RhcnRSZWN0LmxlZnQgKyBfc3RhcnRSZWN0LndpZHRoIDwgY2xpZW50WCArIHRocmVzaG9sZCkge1xuICAgICAgaWYgKF9zdGFydFBvc1swXSA8IF9zdGFydFJlY3QubGVmdCArIF9zdGFydFJlY3Qud2lkdGggfHwgY2xpZW50WCA+IF9zdGFydFBvc1swXSkge1xuICAgICAgICBkaXJlY3Rpb25bMF0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cbiAgICBpZiAoIWRpcmVjdGlvblswXSAmJiAhZGlyZWN0aW9uWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVlRHJhZyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgaW5wdXRFdmVudDogZSxcbiAgICAgIGlzRHJhZzogdHJ1ZVxuICAgIH0pKTtcbiAgfTtcblxuICBfX3Byb3RvLmNoZWNrU2Nyb2xsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2lzV2FpdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBfYSA9IG9wdGlvbnMucHJldlNjcm9sbFBvcyxcbiAgICAgICAgcHJldlNjcm9sbFBvcyA9IF9hID09PSB2b2lkIDAgPyB0aGlzLl9wcmV2U2Nyb2xsUG9zIDogX2EsXG4gICAgICAgIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uLFxuICAgICAgICBfYiA9IG9wdGlvbnMudGhyb3R0bGVUaW1lLFxuICAgICAgICB0aHJvdHRsZVRpbWUgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgICBpbnB1dEV2ZW50ID0gb3B0aW9ucy5pbnB1dEV2ZW50LFxuICAgICAgICBpc0RyYWcgPSBvcHRpb25zLmlzRHJhZztcblxuICAgIHZhciBuZXh0U2Nyb2xsUG9zID0gdGhpcy5fZ2V0U2Nyb2xsUG9zaXRpb24oZGlyZWN0aW9uIHx8IFswLCAwXSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgb2Zmc2V0WCA9IG5leHRTY3JvbGxQb3NbMF0gLSBwcmV2U2Nyb2xsUG9zWzBdO1xuICAgIHZhciBvZmZzZXRZID0gbmV4dFNjcm9sbFBvc1sxXSAtIHByZXZTY3JvbGxQb3NbMV07XG4gICAgdmFyIG5leHREaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgW29mZnNldFggPyBNYXRoLmFicyhvZmZzZXRYKSAvIG9mZnNldFggOiAwLCBvZmZzZXRZID8gTWF0aC5hYnMob2Zmc2V0WSkgLyBvZmZzZXRZIDogMF07XG4gICAgdGhpcy5fcHJldlNjcm9sbFBvcyA9IG5leHRTY3JvbGxQb3M7XG5cbiAgICBpZiAoIW9mZnNldFggJiYgIW9mZnNldFkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJtb3ZlXCIsIHtcbiAgICAgIG9mZnNldFg6IG5leHREaXJlY3Rpb25bMF0gPyBvZmZzZXRYIDogMCxcbiAgICAgIG9mZnNldFk6IG5leHREaXJlY3Rpb25bMV0gPyBvZmZzZXRZIDogMCxcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnRcbiAgICB9KTtcblxuICAgIGlmICh0aHJvdHRsZVRpbWUgJiYgaXNEcmFnKSB7XG4gICAgICB0aGlzLl90aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2NvbnRpbnVlRHJhZyhvcHRpb25zKTtcbiAgICAgIH0sIHRocm90dGxlVGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5kcmFnRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH07XG5cbiAgX19wcm90by5fZ2V0U2Nyb2xsUG9zaXRpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyLFxuICAgICAgICBfYSA9IG9wdGlvbnMuZ2V0U2Nyb2xsUG9zaXRpb24sXG4gICAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gX2EgPT09IHZvaWQgMCA/IGdldERlZmF1bHRTY3JvbGxQb3NpdGlvbiA6IF9hO1xuICAgIHJldHVybiBnZXRTY3JvbGxQb3NpdGlvbih7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5fY29udGludWVEcmFnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyLFxuICAgICAgICBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgdGhyb3R0bGVUaW1lID0gb3B0aW9ucy50aHJvdHRsZVRpbWUsXG4gICAgICAgIHVzZVNjcm9sbCA9IG9wdGlvbnMudXNlU2Nyb2xsLFxuICAgICAgICBpc0RyYWcgPSBvcHRpb25zLmlzRHJhZyxcbiAgICAgICAgaW5wdXRFdmVudCA9IG9wdGlvbnMuaW5wdXRFdmVudDtcblxuICAgIGlmIChpc0RyYWcgJiYgdGhpcy5faXNXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vd1RpbWUgPSBub3coKTtcbiAgICB2YXIgZGlzdFRpbWUgPSBNYXRoLm1heCh0aHJvdHRsZVRpbWUgKyB0aGlzLl9wcmV2VGltZSAtIG5vd1RpbWUsIDApO1xuXG4gICAgaWYgKGRpc3RUaW1lID4gMCkge1xuICAgICAgdGhpcy5fdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9jb250aW51ZURyYWcob3B0aW9ucyk7XG4gICAgICB9LCBkaXN0VGltZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldlRpbWUgPSBub3dUaW1lO1xuXG4gICAgdmFyIHByZXZTY3JvbGxQb3MgPSB0aGlzLl9nZXRTY3JvbGxQb3NpdGlvbihkaXJlY3Rpb24sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fcHJldlNjcm9sbFBvcyA9IHByZXZTY3JvbGxQb3M7XG5cbiAgICBpZiAoaXNEcmFnKSB7XG4gICAgICB0aGlzLl9pc1dhaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcihcInNjcm9sbFwiLCB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgIH0pO1xuICAgIHRoaXMuX2lzV2FpdCA9IGZhbHNlO1xuICAgIHJldHVybiB1c2VTY3JvbGwgfHwgdGhpcy5jaGVja1Njcm9sbChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgIHByZXZTY3JvbGxQb3M6IHByZXZTY3JvbGxQb3MsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnRcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIERyYWdTY3JvbGw7XG59KEV2ZW50RW1pdHRlcik7XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdTY3JvbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmFnc2Nyb2xsLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IEBzY2VuYS9ldmVudC1lbWl0dGVyXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvZ2VzdHVyZS5naXRcbnZlcnNpb246IDEuMC41XG4qL1xuaW1wb3J0IHsgaXNPYmplY3QsIGZpbmRJbmRleCB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblxuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKSByW2tdID0gYVtqXTtcblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnQgRXZlbnRFbWl0dGVyIG9uIG9iamVjdCBvciBjb21wb25lbnQuXG4gKi9cblxudmFyIEV2ZW50RW1pdHRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHJlZ2lzdGVyZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBwYXJhbSAtIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhZGRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBBZGQgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnRcbiAgICogZW1pdHRlci5vbihcImFcIiwgKCkgPT4ge1xuICAgKiB9KTtcbiAgICogLy8gQWRkIGxpc3RlbmVyc1xuICAgKiBlbWl0dGVyLm9uKHtcbiAgICogIGE6ICgpID0+IHt9LFxuICAgKiAgYjogKCkgPT4ge30sXG4gICAqIH0pO1xuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoaXNPYmplY3QoZXZlbnROYW1lKSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vbihuYW1lLCBldmVudE5hbWVbbmFtZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRFdmVudChldmVudE5hbWUsIGxpc3RlbmVyLCB7fSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgaW4gdGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gLSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZFxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKiBjb3NudCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycy5cbiAgICogZW1pdHRlci5vZmYoKTtcbiAgICpcbiAgICogLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaW4gXCJBXCIgZXZlbnQuXG4gICAqIGVtaXR0ZXIub2ZmKFwiYVwiKTtcbiAgICpcbiAgICpcbiAgICogLy8gUmVtb3ZlIFwibGlzdGVuZXJcIiBsaXN0ZW5lciBpbiBcImFcIiBldmVudC5cbiAgICogZW1pdHRlci5vZmYoXCJhXCIsIGxpc3RlbmVyKTtcbiAgICovXG5cblxuICBfX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCFldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZXZlbnROYW1lKSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vZmYobmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcblxuICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgoZXZlbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmxpc3RlbmVyID09PSBsaXN0ZW5lcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQWRkIGEgZGlzcG9zYWJsZSBsaXN0ZW5lciBhbmQgVXNlIHByb21pc2UgdG8gdGhlIHJlZ2lzdGVyZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAtIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBwYXJhbSAtIGRpc3Bvc2FibGUgbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIEFkZCBhIGRpc3Bvc2FibGUgbGlzdGVuZXIgaW4gXCJhXCIgZXZlbnRcbiAgICogZW1pdHRlci5vbmNlKFwiYVwiLCAoKSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBVc2UgUHJvbWlzZVxuICAgKiBlbWl0dGVyLm9uY2UoXCJhXCIpLnRoZW4oZSA9PiB7XG4gICAqIH0pO1xuICAgKi9cblxuXG4gIF9fcHJvdG8ub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fYWRkRXZlbnQoZXZlbnROYW1lLCBsaXN0ZW5lciwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF90aGlzLl9hZGRFdmVudChldmVudE5hbWUsIHJlc29sdmUsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gLSBFdmVudCBwYXJhbWV0ZXJcbiAgICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqXG4gICAqXG4gICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIGVtaXR0ZXIub24oXCJhXCIsIGUgPT4ge1xuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogZW1pdHRlci5lbWl0KFwiYVwiLCB7XG4gICAqICAgYTogMSxcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGFyYW0pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHBhcmFtID09PSB2b2lkIDApIHtcbiAgICAgIHBhcmFtID0ge307XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgaWYgKCFldmVudE5hbWUgfHwgIWV2ZW50cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzU3RvcCA9IGZhbHNlO1xuICAgIHBhcmFtLmV2ZW50VHlwZSA9IGV2ZW50TmFtZTtcblxuICAgIHBhcmFtLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpc1N0b3AgPSB0cnVlO1xuICAgIH07XG5cbiAgICBwYXJhbS5jdXJyZW50VGFyZ2V0ID0gdGhpcztcblxuICAgIF9fc3ByZWFkQXJyYXlzKGV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgaW5mby5saXN0ZW5lcihwYXJhbSk7XG5cbiAgICAgIGlmIChpbmZvLm9uY2UpIHtcbiAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgaW5mby5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gIWlzU3RvcDtcbiAgfTtcbiAgLyoqXG4gICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICpcbiAgICpcbiAgICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBlbWl0dGVyLmVtaXQoXCJhXCIsIHtcbiAgICogICBhOiAxLFxuICAgKiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICogQHBhcmFtIC0gRXZlbnQgbmFtZVxuICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAqIEBleGFtcGxlXG4gICpcbiAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAqXG4gICpcbiAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAqXG4gICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICogfSk7XG4gICpcbiAgKiAvLyBlbWl0XG4gICogZW1pdHRlci50cmlnZ2VyKFwiYVwiLCB7XG4gICogICBhOiAxLFxuICAqIH0pO1xuICAqL1xuXG5cbiAgX19wcm90by50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGFyYW0pIHtcbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50TmFtZSwgcGFyYW0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2FkZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGV2ZW50c1tldmVudE5hbWVdID0gZXZlbnRzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1tldmVudE5hbWVdO1xuICAgIGxpc3RlbmVycy5wdXNoKF9fYXNzaWduKHtcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudC1lbWl0dGVyLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMjAgRGF5YnJ1c2hcbm5hbWU6IEBzY2VuYS9tYXRyaXhcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9tYXRyaXhcbnZlcnNpb246IDEuMS4xXG4qL1xuaW1wb3J0IHsgdGhyb3R0bGUsIFRJTllfTlVNLCBhdmVyYWdlIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuZnVuY3Rpb24gYWRkKG1hdHJpeCwgaW52ZXJzZU1hdHJpeCwgc3RhcnRJbmRleCwgZnJvbUluZGV4LCBuLCBrKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgdmFyIHggPSBzdGFydEluZGV4ICsgaSAqIG47XG4gICAgdmFyIGZyb21YID0gZnJvbUluZGV4ICsgaSAqIG47XG4gICAgbWF0cml4W3hdICs9IG1hdHJpeFtmcm9tWF0gKiBrO1xuICAgIGludmVyc2VNYXRyaXhbeF0gKz0gaW52ZXJzZU1hdHJpeFtmcm9tWF0gKiBrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAobWF0cml4LCBpbnZlcnNlTWF0cml4LCBzdGFydEluZGV4LCBmcm9tSW5kZXgsIG4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB2YXIgeCA9IHN0YXJ0SW5kZXggKyBpICogbjtcbiAgICB2YXIgZnJvbVggPSBmcm9tSW5kZXggKyBpICogbjtcbiAgICB2YXIgdiA9IG1hdHJpeFt4XTtcbiAgICB2YXIgaXYgPSBpbnZlcnNlTWF0cml4W3hdO1xuICAgIG1hdHJpeFt4XSA9IG1hdHJpeFtmcm9tWF07XG4gICAgbWF0cml4W2Zyb21YXSA9IHY7XG4gICAgaW52ZXJzZU1hdHJpeFt4XSA9IGludmVyc2VNYXRyaXhbZnJvbVhdO1xuICAgIGludmVyc2VNYXRyaXhbZnJvbVhdID0gaXY7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGl2aWRlKG1hdHJpeCwgaW52ZXJzZU1hdHJpeCwgc3RhcnRJbmRleCwgbiwgaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHZhciB4ID0gc3RhcnRJbmRleCArIGkgKiBuO1xuICAgIG1hdHJpeFt4XSAvPSBrO1xuICAgIGludmVyc2VNYXRyaXhbeF0gLz0gaztcbiAgfVxufVxuLyoqXG4gKlxuICogQG5hbWVzcGFjZSBNYXRyaXhcbiAqL1xuXG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGlnbm9yZURpbWVuc2lvbihtYXRyaXgsIG0sIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH1cblxuICB2YXIgbmV3TWF0cml4ID0gbWF0cml4LnNsaWNlKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBuZXdNYXRyaXhbaSAqIG4gKyBtIC0gMV0gPSAwO1xuICAgIG5ld01hdHJpeFsobSAtIDEpICogbiArIGldID0gMDtcbiAgfVxuXG4gIG5ld01hdHJpeFsobSAtIDEpICogKG4gKyAxKV0gPSAxO1xuICByZXR1cm4gbmV3TWF0cml4O1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gaW52ZXJ0KG1hdHJpeCwgbikge1xuICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgbiA9IE1hdGguc3FydChtYXRyaXgubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBuZXdNYXRyaXggPSBtYXRyaXguc2xpY2UoKTtcbiAgdmFyIGludmVyc2VNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIC8vIGRpYWdvbmFsXG4gICAgdmFyIGlkZW50aXR5SW5kZXggPSBuICogaSArIGk7XG5cbiAgICBpZiAoIXRocm90dGxlKG5ld01hdHJpeFtpZGVudGl0eUluZGV4XSwgVElOWV9OVU0pKSB7XG4gICAgICAvLyBuZXdNYXRyaXhbaWRlbnRpdHlJbmRleF0gPSAwO1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICAgIGlmIChuZXdNYXRyaXhbbiAqIGkgKyBqXSkge1xuICAgICAgICAgIHN3YXAobmV3TWF0cml4LCBpbnZlcnNlTWF0cml4LCBpLCBqLCBuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhyb3R0bGUobmV3TWF0cml4W2lkZW50aXR5SW5kZXhdLCBUSU5ZX05VTSkpIHtcbiAgICAgIC8vIG5vIGludmVyc2UgbWF0cml4XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgZGl2aWRlKG5ld01hdHJpeCwgaW52ZXJzZU1hdHJpeCwgaSwgbiwgbmV3TWF0cml4W2lkZW50aXR5SW5kZXhdKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICB2YXIgdGFyZ2V0U3RhcnRJbmRleCA9IGo7XG4gICAgICB2YXIgdGFyZ2V0SW5kZXggPSBqICsgaSAqIG47XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3TWF0cml4W3RhcmdldEluZGV4XTtcblxuICAgICAgaWYgKCF0aHJvdHRsZSh0YXJnZXQsIFRJTllfTlVNKSB8fCBpID09PSBqKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhZGQobmV3TWF0cml4LCBpbnZlcnNlTWF0cml4LCB0YXJnZXRTdGFydEluZGV4LCBpLCBuLCAtdGFyZ2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW52ZXJzZU1hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIHRyYW5zcG9zZShtYXRyaXgsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH1cblxuICB2YXIgbmV3TWF0cml4ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgbmV3TWF0cml4W2ogKiBuICsgaV0gPSBtYXRyaXhbbiAqIGkgKyBqXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3TWF0cml4O1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gZ2V0T3JpZ2luKG1hdHJpeCwgbikge1xuICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgbiA9IE1hdGguc3FydChtYXRyaXgubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBvcmlnaW5NYXRyaXggPSBbXTtcbiAgdmFyIHcgPSBtYXRyaXhbbiAqIG4gLSAxXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4gLSAxOyArK2kpIHtcbiAgICBvcmlnaW5NYXRyaXhbaV0gPSBtYXRyaXhbbiAqIChuIC0gMSkgKyBpXSAvIHc7XG4gIH1cblxuICBvcmlnaW5NYXRyaXhbbiAtIDFdID0gMDtcbiAgcmV0dXJuIG9yaWdpbk1hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihwb3MsIG4pIHtcbiAgdmFyIG5ld01hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7ICsraSkge1xuICAgIG5ld01hdHJpeFtuICogKG4gLSAxKSArIGldID0gcG9zW2ldIHx8IDA7XG4gIH1cblxuICByZXR1cm4gbmV3TWF0cml4O1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gY29udmVydFBvc2l0aW9uTWF0cml4KG1hdHJpeCwgbikge1xuICB2YXIgbmV3TWF0cml4ID0gbWF0cml4LnNsaWNlKCk7XG5cbiAgZm9yICh2YXIgaSA9IG1hdHJpeC5sZW5ndGg7IGkgPCBuIC0gMTsgKytpKSB7XG4gICAgbmV3TWF0cml4W2ldID0gMDtcbiAgfVxuXG4gIG5ld01hdHJpeFtuIC0gMV0gPSAxO1xuICByZXR1cm4gbmV3TWF0cml4O1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gY29udmVydERpbWVuc2lvbihtYXRyaXgsIG4sIG0pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCk7XG4gIH0gLy8gbiA8IG1cblxuXG4gIGlmIChuID09PSBtKSB7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHZhciBuZXdNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChtKTtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKG4sIG0pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGggLSAxOyArK2opIHtcbiAgICAgIG5ld01hdHJpeFtpICogbSArIGpdID0gbWF0cml4W2kgKiBuICsgal07XG4gICAgfVxuXG4gICAgbmV3TWF0cml4WyhpICsgMSkgKiBtIC0gMV0gPSBtYXRyaXhbKGkgKyAxKSAqIG4gLSAxXTtcbiAgICBuZXdNYXRyaXhbKG0gLSAxKSAqIG0gKyBpXSA9IG1hdHJpeFsobiAtIDEpICogbiArIGldO1xuICB9XG5cbiAgbmV3TWF0cml4W20gKiBtIC0gMV0gPSBtYXRyaXhbbiAqIG4gLSAxXTtcbiAgcmV0dXJuIG5ld01hdHJpeDtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIG11bHRpcGxpZXMobikge1xuICB2YXIgbWF0cml4ZXMgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIG1hdHJpeGVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgdmFyIG0gPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcbiAgbWF0cml4ZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgbSA9IG11bHRpcGx5KG0sIG1hdHJpeCwgbik7XG4gIH0pO1xuICByZXR1cm4gbTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG1hdHJpeCwgbWF0cml4Miwgbikge1xuICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgbiA9IE1hdGguc3FydChtYXRyaXgubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBuZXdNYXRyaXggPSBbXTsgLy8gMSB5OiBuXG4gIC8vIDEgeDogbVxuICAvLyAyIHg6IG1cbiAgLy8gMiB5OiBrXG4gIC8vIG4gKiBtIFggbSAqIGtcblxuICB2YXIgbSA9IG1hdHJpeC5sZW5ndGggLyBuO1xuICB2YXIgayA9IG1hdHJpeDIubGVuZ3RoIC8gbTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbWF0cml4MjtcbiAgfSBlbHNlIGlmICghaykge1xuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICBuZXdNYXRyaXhbaiAqIG4gKyBpXSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbTsgKytsKSB7XG4gICAgICAgIC8vIG0xIHg6IG0obCksIHk6IG4oaSlcbiAgICAgICAgLy8gbTIgeDogayhqKTogIHk6IG0obClcbiAgICAgICAgLy8gbncgeDogbihpKSwgeTogayhqKVxuICAgICAgICBuZXdNYXRyaXhbaiAqIG4gKyBpXSArPSBtYXRyaXhbbCAqIG4gKyBpXSAqIG1hdHJpeDJbaiAqIG0gKyBsXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gbiAqIGtcblxuXG4gIHJldHVybiBuZXdNYXRyaXg7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBwbHVzKHBvczEsIHBvczIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHBvczEubGVuZ3RoLCBwb3MyLmxlbmd0aCk7XG4gIHZhciBuZXh0UG9zID0gcG9zMS5zbGljZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBuZXh0UG9zW2ldID0gbmV4dFBvc1tpXSArIHBvczJbaV07XG4gIH1cblxuICByZXR1cm4gbmV4dFBvcztcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIG1pbnVzKHBvczEsIHBvczIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHBvczEubGVuZ3RoLCBwb3MyLmxlbmd0aCk7XG4gIHZhciBuZXh0UG9zID0gcG9zMS5zbGljZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBuZXh0UG9zW2ldID0gbmV4dFBvc1tpXSAtIHBvczJbaV07XG4gIH1cblxuICByZXR1cm4gbmV4dFBvcztcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnRDU1N0b01hdHJpeChhLCBpczJkKSB7XG4gIGlmIChpczJkID09PSB2b2lkIDApIHtcbiAgICBpczJkID0gYS5sZW5ndGggPT09IDY7XG4gIH1cblxuICBpZiAoaXMyZCkge1xuICAgIHJldHVybiBbYVswXSwgYVsxXSwgMCwgYVsyXSwgYVszXSwgMCwgYVs0XSwgYVs1XSwgMV07XG4gIH1cblxuICByZXR1cm4gYTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXRyaXh0b0NTUyhhLCBpczJkKSB7XG4gIGlmIChpczJkID09PSB2b2lkIDApIHtcbiAgICBpczJkID0gYS5sZW5ndGggPT09IDk7XG4gIH1cblxuICBpZiAoaXMyZCkge1xuICAgIHJldHVybiBbYVswXSwgYVsxXSwgYVszXSwgYVs0XSwgYVs2XSwgYVs3XV07XG4gIH1cblxuICByZXR1cm4gYTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZShtYXRyaXgsIG1hdHJpeDIsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSBtYXRyaXgyLmxlbmd0aDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBtdWx0aXBseShtYXRyaXgsIG1hdHJpeDIsIG4pO1xuICB2YXIgayA9IHJlc3VsdFtuIC0gMV07XG4gIHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgLyBrO1xuICB9KTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIHJvdGF0ZVgzZChtYXRyaXgsIHJhZCkge1xuICByZXR1cm4gbXVsdGlwbHkobWF0cml4LCBbMSwgMCwgMCwgMCwgMCwgTWF0aC5jb3MocmFkKSwgTWF0aC5zaW4ocmFkKSwgMCwgMCwgLU1hdGguc2luKHJhZCksIE1hdGguY29zKHJhZCksIDAsIDAsIDAsIDAsIDFdLCA0KTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIHJvdGF0ZVkzZChtYXRyaXgsIHJhZCkge1xuICByZXR1cm4gbXVsdGlwbHkobWF0cml4LCBbTWF0aC5jb3MocmFkKSwgMCwgLU1hdGguc2luKHJhZCksIDAsIDAsIDEsIDAsIDAsIE1hdGguc2luKHJhZCksIDAsIE1hdGguY29zKHJhZCksIDAsIDAsIDAsIDAsIDFdLCA0KTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIHJvdGF0ZVozZChtYXRyaXgsIHJhZCkge1xuICByZXR1cm4gbXVsdGlwbHkobWF0cml4LCBjcmVhdGVSb3RhdGVNYXRyaXgocmFkLCA0KSk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBzY2FsZTNkKG1hdHJpeCwgX2EpIHtcbiAgdmFyIF9iID0gX2FbMF0sXG4gICAgICBzeCA9IF9iID09PSB2b2lkIDAgPyAxIDogX2IsXG4gICAgICBfYyA9IF9hWzFdLFxuICAgICAgc3kgPSBfYyA9PT0gdm9pZCAwID8gMSA6IF9jLFxuICAgICAgX2QgPSBfYVsyXSxcbiAgICAgIHN6ID0gX2QgPT09IHZvaWQgMCA/IDEgOiBfZDtcbiAgcmV0dXJuIG11bHRpcGx5KG1hdHJpeCwgW3N4LCAwLCAwLCAwLCAwLCBzeSwgMCwgMCwgMCwgMCwgc3osIDAsIDAsIDAsIDAsIDFdLCA0KTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIHJvdGF0ZShwb3MsIHJhZCkge1xuICByZXR1cm4gY2FsY3VsYXRlKGNyZWF0ZVJvdGF0ZU1hdHJpeChyYWQsIDMpLCBjb252ZXJ0UG9zaXRpb25NYXRyaXgocG9zLCAzKSk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2xhdGUzZChtYXRyaXgsIF9hKSB7XG4gIHZhciBfYiA9IF9hWzBdLFxuICAgICAgdHggPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgX2MgPSBfYVsxXSxcbiAgICAgIHR5ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgIF9kID0gX2FbMl0sXG4gICAgICB0eiA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gIHJldHVybiBtdWx0aXBseShtYXRyaXgsIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCB0eCwgdHksIHR6LCAxXSwgNCk7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBtYXRyaXgzZChtYXRyaXgxLCBtYXRyaXgyKSB7XG4gIHJldHVybiBtdWx0aXBseShtYXRyaXgxLCBtYXRyaXgyLCA0KTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdGF0ZU1hdHJpeChyYWQsIG4pIHtcbiAgdmFyIGNvcyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgbSA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pOyAvLyBjb3MgLXNpblxuICAvLyBzaW4gY29zXG5cbiAgbVswXSA9IGNvcztcbiAgbVsxXSA9IHNpbjtcbiAgbVtuXSA9IC1zaW47XG4gIG1bbiArIDFdID0gY29zO1xuICByZXR1cm4gbTtcbn1cbi8qKlxuICogQG1lbWJlcm9mIE1hdHJpeFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pIHtcbiAgdmFyIGxlbmd0aCA9IG4gKiBuO1xuICB2YXIgbWF0cml4ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIG1hdHJpeFtpXSA9IGkgJSAobiArIDEpID8gMCA6IDE7XG4gIH1cblxuICByZXR1cm4gbWF0cml4O1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlU2NhbGVNYXRyaXgoc2NhbGUsIG4pIHtcbiAgdmFyIG0gPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHNjYWxlLmxlbmd0aCwgbiAtIDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBtWyhuICsgMSkgKiBpXSA9IHNjYWxlW2ldO1xuICB9XG5cbiAgcmV0dXJuIG07XG59XG4vKipcbiAqIEBtZW1iZXJvZiBNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVPcmlnaW5NYXRyaXgob3JpZ2luLCBuKSB7XG4gIHZhciBtID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihvcmlnaW4ubGVuZ3RoLCBuIC0gMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIG1bbiAqIChuIC0gMSkgKyBpXSA9IG9yaWdpbltpXTtcbiAgfVxuXG4gIHJldHVybiBtO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlV2FycE1hdHJpeChwb3MwLCBwb3MxLCBwb3MyLCBwb3MzLCBuZXh0UG9zMCwgbmV4dFBvczEsIG5leHRQb3MyLCBuZXh0UG9zMykge1xuICB2YXIgeDAgPSBwb3MwWzBdLFxuICAgICAgeTAgPSBwb3MwWzFdO1xuICB2YXIgeDEgPSBwb3MxWzBdLFxuICAgICAgeTEgPSBwb3MxWzFdO1xuICB2YXIgeDIgPSBwb3MyWzBdLFxuICAgICAgeTIgPSBwb3MyWzFdO1xuICB2YXIgeDMgPSBwb3MzWzBdLFxuICAgICAgeTMgPSBwb3MzWzFdO1xuICB2YXIgdTAgPSBuZXh0UG9zMFswXSxcbiAgICAgIHYwID0gbmV4dFBvczBbMV07XG4gIHZhciB1MSA9IG5leHRQb3MxWzBdLFxuICAgICAgdjEgPSBuZXh0UG9zMVsxXTtcbiAgdmFyIHUyID0gbmV4dFBvczJbMF0sXG4gICAgICB2MiA9IG5leHRQb3MyWzFdO1xuICB2YXIgdTMgPSBuZXh0UG9zM1swXSxcbiAgICAgIHYzID0gbmV4dFBvczNbMV07XG4gIHZhciBtYXRyaXggPSBbeDAsIDAsIHgxLCAwLCB4MiwgMCwgeDMsIDAsIHkwLCAwLCB5MSwgMCwgeTIsIDAsIHkzLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAxLCAwLCAwLCB4MCwgMCwgeDEsIDAsIHgyLCAwLCB4MywgMCwgeTAsIDAsIHkxLCAwLCB5MiwgMCwgeTMsIDAsIDEsIDAsIDEsIDAsIDEsIDAsIDEsIC11MCAqIHgwLCAtdjAgKiB4MCwgLXUxICogeDEsIC12MSAqIHgxLCAtdTIgKiB4MiwgLXYyICogeDIsIC11MyAqIHgzLCAtdjMgKiB4MywgLXUwICogeTAsIC12MCAqIHkwLCAtdTEgKiB5MSwgLXYxICogeTEsIC11MiAqIHkyLCAtdjIgKiB5MiwgLXUzICogeTMsIC12MyAqIHkzXTtcbiAgdmFyIGludmVyc2VNYXRyaXggPSBpbnZlcnQobWF0cml4LCA4KTtcblxuICBpZiAoIWludmVyc2VNYXRyaXgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGggPSBtdWx0aXBseShpbnZlcnNlTWF0cml4LCBbdTAsIHYwLCB1MSwgdjEsIHUyLCB2MiwgdTMsIHYzXSwgOCk7XG4gIGhbOF0gPSAxO1xuICByZXR1cm4gY29udmVydERpbWVuc2lvbih0cmFuc3Bvc2UoaCksIDMsIDQpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgTWF0cml4XG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50cykge1xuICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdmVyYWdlKHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIHBvc1tpXTtcbiAgICB9KSk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBjYWxjdWxhdGUsIGNvbnZlcnRDU1N0b01hdHJpeCwgY29udmVydERpbWVuc2lvbiwgY29udmVydE1hdHJpeHRvQ1NTLCBjb252ZXJ0UG9zaXRpb25NYXRyaXgsIGNyZWF0ZUlkZW50aXR5TWF0cml4LCBjcmVhdGVPcmlnaW5NYXRyaXgsIGNyZWF0ZVJvdGF0ZU1hdHJpeCwgY3JlYXRlU2NhbGVNYXRyaXgsIGNyZWF0ZVdhcnBNYXRyaXgsIGZyb21UcmFuc2xhdGlvbiwgZ2V0Q2VudGVyLCBnZXRPcmlnaW4sIGlnbm9yZURpbWVuc2lvbiwgaW52ZXJ0LCBtYXRyaXgzZCwgbWludXMsIG11bHRpcGxpZXMsIG11bHRpcGx5LCBwbHVzLCByb3RhdGUsIHJvdGF0ZVgzZCwgcm90YXRlWTNkLCByb3RhdGVaM2QsIHNjYWxlM2QsIHRyYW5zbGF0ZTNkLCB0cmFuc3Bvc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdHJpeC5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBjc3MtdG8tbWF0XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvY3NzLXRvLW1hdC5naXRcbnZlcnNpb246IDEuMC4zXG4qL1xuaW1wb3J0IHsgc3BsaXRCcmFja2V0LCBzcGxpdENvbW1hLCBzcGxpdFVuaXQsIGlzQXJyYXksIHNwbGl0U3BhY2UgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlLCBtYXRyaXgzZCwgaW52ZXJ0LCB0cmFuc2xhdGUzZCwgc2NhbGUzZCwgcm90YXRlWjNkLCByb3RhdGVYM2QsIHJvdGF0ZVkzZCB9IGZyb20gJ0BzY2VuYS9tYXRyaXgnO1xuXG5mdW5jdGlvbiBjcmVhdGVNYXRyaXgoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG5mdW5jdGlvbiBwYXJzZU1hdCh0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIHRvTWF0KHBhcnNlKHRyYW5zZm9ybSkpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudE1hdHJpeChlbCkge1xuICByZXR1cm4gcGFyc2VNYXQoZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNmb3JtKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1hdHJpeERpc3QobWF0cml4LCBwb3MpIHtcbiAgdmFyIHJlcyA9IGNhbGN1bGF0ZShtYXRyaXgsIFtwb3NbMF0sIHBvc1sxXSB8fCAwLCBwb3NbMl0gfHwgMCwgMV0sIDQpO1xuICB2YXIgdyA9IHJlc1szXSB8fCAxO1xuICByZXR1cm4gW3Jlc1swXSAvIHcsIHJlc1sxXSAvIHcsIHJlc1syXSAvIHddO1xufVxuZnVuY3Rpb24gZ2V0RGlzdEVsZW1lbnRNYXRyaXgoZWwsIGNvbnRhaW5lcikge1xuICBpZiAoY29udGFpbmVyID09PSB2b2lkIDApIHtcbiAgICBjb250YWluZXIgPSBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IGVsO1xuICB2YXIgbWF0cml4ID0gY3JlYXRlTWF0cml4KCk7XG5cbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkudHJhbnNmb3JtO1xuICAgIG1hdHJpeCA9IG1hdHJpeDNkKHBhcnNlTWF0KHRyYW5zZm9ybSksIG1hdHJpeCk7XG5cbiAgICBpZiAodGFyZ2V0ID09PSBjb250YWluZXIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICB9XG5cbiAgbWF0cml4ID0gaW52ZXJ0KG1hdHJpeCwgNCk7XG4gIG1hdHJpeFsxMl0gPSAwO1xuICBtYXRyaXhbMTNdID0gMDtcbiAgbWF0cml4WzE0XSA9IDA7XG4gIHJldHVybiBtYXRyaXg7XG59XG5mdW5jdGlvbiB0b01hdChtYXRyaXhJbmZvcykge1xuICB2YXIgdGFyZ2V0ID0gY3JlYXRlTWF0cml4KCk7XG4gIG1hdHJpeEluZm9zLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICB2YXIgbWF0cml4RnVuY3Rpb24gPSBpbmZvLm1hdHJpeEZ1bmN0aW9uLFxuICAgICAgICBmdW5jdGlvblZhbHVlID0gaW5mby5mdW5jdGlvblZhbHVlO1xuXG4gICAgaWYgKCFtYXRyaXhGdW5jdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRhcmdldCA9IG1hdHJpeEZ1bmN0aW9uKHRhcmdldCwgZnVuY3Rpb25WYWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gcGFyc2UodHJhbnNmb3JtKSB7XG4gIHZhciB0cmFuc2Zvcm1zID0gaXNBcnJheSh0cmFuc2Zvcm0pID8gdHJhbnNmb3JtIDogc3BsaXRTcGFjZSh0cmFuc2Zvcm0pO1xuICByZXR1cm4gdHJhbnNmb3Jtcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgX2EgPSBzcGxpdEJyYWNrZXQodCksXG4gICAgICAgIG5hbWUgPSBfYS5wcmVmaXgsXG4gICAgICAgIHZhbHVlID0gX2EudmFsdWU7XG5cbiAgICB2YXIgbWF0cml4RnVuY3Rpb24gPSBudWxsO1xuICAgIHZhciBmdW5jdGlvbk5hbWUgPSBuYW1lO1xuICAgIHZhciBmdW5jdGlvblZhbHVlID0gXCJcIjtcblxuICAgIGlmIChuYW1lID09PSBcInRyYW5zbGF0ZVwiIHx8IG5hbWUgPT09IFwidHJhbnNsYXRlWFwiIHx8IG5hbWUgPT09IFwidHJhbnNsYXRlM2RcIikge1xuICAgICAgdmFyIF9iID0gc3BsaXRDb21tYSh2YWx1ZSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHYpO1xuICAgICAgfSksXG4gICAgICAgICAgcG9zWCA9IF9iWzBdLFxuICAgICAgICAgIF9jID0gX2JbMV0sXG4gICAgICAgICAgcG9zWSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICAgICAgX2QgPSBfYlsyXSxcbiAgICAgICAgICBwb3NaID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZDtcblxuICAgICAgbWF0cml4RnVuY3Rpb24gPSB0cmFuc2xhdGUzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBbcG9zWCwgcG9zWSwgcG9zWl07XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInRyYW5zbGF0ZVlcIikge1xuICAgICAgdmFyIHBvc1kgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIG1hdHJpeEZ1bmN0aW9uID0gdHJhbnNsYXRlM2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gWzAsIHBvc1ksIDBdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ0cmFuc2xhdGVaXCIpIHtcbiAgICAgIHZhciBwb3NaID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IHRyYW5zbGF0ZTNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IFswLCAwLCBwb3NaXTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic2NhbGVcIiB8fCBuYW1lID09PSBcInNjYWxlM2RcIikge1xuICAgICAgdmFyIF9lID0gc3BsaXRDb21tYSh2YWx1ZSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHYpO1xuICAgICAgfSksXG4gICAgICAgICAgc3ggPSBfZVswXSxcbiAgICAgICAgICBfZiA9IF9lWzFdLFxuICAgICAgICAgIHN5ID0gX2YgPT09IHZvaWQgMCA/IHN4IDogX2YsXG4gICAgICAgICAgX2cgPSBfZVsyXSxcbiAgICAgICAgICBzeiA9IF9nID09PSB2b2lkIDAgPyAxIDogX2c7XG5cbiAgICAgIG1hdHJpeEZ1bmN0aW9uID0gc2NhbGUzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBbc3gsIHN5LCBzel07XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNjYWxlWFwiKSB7XG4gICAgICB2YXIgc3ggPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIG1hdHJpeEZ1bmN0aW9uID0gc2NhbGUzZDtcbiAgICAgIGZ1bmN0aW9uVmFsdWUgPSBbc3gsIDEsIDFdO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzY2FsZVlcIikge1xuICAgICAgdmFyIHN5ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IHNjYWxlM2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gWzEsIHN5LCAxXTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic2NhbGVaXCIpIHtcbiAgICAgIHZhciBzeiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgbWF0cml4RnVuY3Rpb24gPSBzY2FsZTNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IFsxLCAxLCBzel07XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInJvdGF0ZVwiIHx8IG5hbWUgPT09IFwicm90YXRlWlwiIHx8IG5hbWUgPT09IFwicm90YXRlWFwiIHx8IG5hbWUgPT09IFwicm90YXRlWVwiKSB7XG4gICAgICB2YXIgX2ggPSBzcGxpdFVuaXQodmFsdWUpLFxuICAgICAgICAgIHVuaXQgPSBfaC51bml0LFxuICAgICAgICAgIHVuaXRWYWx1ZSA9IF9oLnZhbHVlO1xuXG4gICAgICB2YXIgcmFkID0gdW5pdCA9PT0gXCJyYWRcIiA/IHVuaXRWYWx1ZSA6IHVuaXRWYWx1ZSAqIE1hdGguUEkgLyAxODA7XG5cbiAgICAgIGlmIChuYW1lID09PSBcInJvdGF0ZVwiIHx8IG5hbWUgPT09IFwicm90YXRlWlwiKSB7XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9IFwicm90YXRlWlwiO1xuICAgICAgICBtYXRyaXhGdW5jdGlvbiA9IHJvdGF0ZVozZDtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJyb3RhdGVYXCIpIHtcbiAgICAgICAgbWF0cml4RnVuY3Rpb24gPSByb3RhdGVYM2Q7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwicm90YXRlWVwiKSB7XG4gICAgICAgIG1hdHJpeEZ1bmN0aW9uID0gcm90YXRlWTNkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvblZhbHVlID0gcmFkO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJtYXRyaXgzZFwiKSB7XG4gICAgICBtYXRyaXhGdW5jdGlvbiA9IG1hdHJpeDNkO1xuICAgICAgZnVuY3Rpb25WYWx1ZSA9IHNwbGl0Q29tbWEodmFsdWUpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgdmFyIG0gPSBzcGxpdENvbW1hKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodik7XG4gICAgICB9KTtcbiAgICAgIG1hdHJpeEZ1bmN0aW9uID0gbWF0cml4M2Q7XG4gICAgICBmdW5jdGlvblZhbHVlID0gW21bMF0sIG1bMV0sIDAsIDAsIG1bMl0sIG1bM10sIDAsIDAsIDAsIDAsIDEsIDAsIG1bNF0sIG1bNV0sIDAsIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdW5jdGlvbk5hbWUgPSBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBtYXRyaXhGdW5jdGlvbjogbWF0cml4RnVuY3Rpb24sXG4gICAgICBmdW5jdGlvblZhbHVlOiBmdW5jdGlvblZhbHVlXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGNhbGN1bGF0ZU1hdHJpeERpc3QsIGNyZWF0ZU1hdHJpeCwgZ2V0RGlzdEVsZW1lbnRNYXRyaXgsIGdldEVsZW1lbnRNYXRyaXgsIHBhcnNlLCBwYXJzZU1hdCwgdG9NYXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy10by1tYXQuZXNtLmpzLm1hcFxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxOSBEYXlicnVzaFxubmFtZTogZnJhbWV3b3JrLXV0aWxzXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvZnJhbWV3b3JrLXV0aWxzLmdpdFxudmVyc2lvbjogMS4xLjBcbiovXG5mdW5jdGlvbiBwcmVmaXhOYW1lcyhwcmVmaXgpIHtcbiAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGNsYXNzTmFtZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICByZXR1cm4gY2xhc3NOYW1lcy5tYXAoZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBjbGFzc05hbWUuc3BsaXQoXCIgXCIpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUgPyBcIlwiICsgcHJlZml4ICsgbmFtZSA6IFwiXCI7XG4gICAgfSkuam9pbihcIiBcIik7XG4gIH0pLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gcHJlZml4Q1NTKHByZWZpeCwgY3NzKSB7XG4gIHJldHVybiBjc3MucmVwbGFjZSgvKFtefXtdKil7L2dtLCBmdW5jdGlvbiAoXywgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZSgvXFwuKFteeyxcXHNcXGQuXSspL2csIFwiLlwiICsgcHJlZml4ICsgXCIkMVwiKSArIFwie1wiO1xuICB9KTtcbn1cbi8qIHJlYWN0ICovXG5cbmZ1bmN0aW9uIHJlZih0YXJnZXQsIG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgZSAmJiAodGFyZ2V0W25hbWVdID0gZSk7XG4gIH07XG59XG5mdW5jdGlvbiByZWZzKHRhcmdldCwgbmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICBlICYmICh0YXJnZXRbbmFtZV1baV0gPSBlKTtcbiAgfTtcbn1cbi8qIENsYXNzIERlY29yYXRvciAqL1xuXG5mdW5jdGlvbiBQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGFjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHZhciBwcm90b3R5cGUgPSBjb21wb25lbnQucHJvdG90eXBlO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIGFjdGlvbihwcm90b3R5cGUsIHByb3BlcnR5KTtcbiAgICB9KTtcbiAgfTtcbn1cbi8qIFByb3BlcnR5IERlY29yYXRvciAqL1xuXG5mdW5jdGlvbiB3aXRoTWV0aG9kcyhtZXRob2RzLCBkdXBsaWNhdGUpIHtcbiAgaWYgKGR1cGxpY2F0ZSA9PT0gdm9pZCAwKSB7XG4gICAgZHVwbGljYXRlID0ge307XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgbWV0aG9kTmFtZSA9IGR1cGxpY2F0ZVtuYW1lXSB8fCBuYW1lO1xuXG4gICAgICBpZiAobWV0aG9kTmFtZSBpbiBwcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcblxuICAgICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IChfYSA9IHRoaXNbcHJvcGVydHlOYW1lXSlbbmFtZV0uYXBwbHkoX2EsIGFyZ3MpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHRoaXNbcHJvcGVydHlOYW1lXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IFByb3BlcnRpZXMsIHByZWZpeENTUywgcHJlZml4TmFtZXMsIHJlZiwgcmVmcywgd2l0aE1ldGhvZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IGdlc3RvXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvZ2VzdG8uZ2l0XG52ZXJzaW9uOiAxLjcuMFxuKi9cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnQHNjZW5hL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgcmVtb3ZlRXZlbnQsIG5vdywgYWRkRXZlbnQgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBnZXRSYWQocG9zMSwgcG9zMikge1xuICB2YXIgZGlzdFggPSBwb3MyWzBdIC0gcG9zMVswXTtcbiAgdmFyIGRpc3RZID0gcG9zMlsxXSAtIHBvczFbMV07XG4gIHZhciByYWQgPSBNYXRoLmF0YW4yKGRpc3RZLCBkaXN0WCk7XG4gIHJldHVybiByYWQgPj0gMCA/IHJhZCA6IHJhZCArIE1hdGguUEkgKiAyO1xufVxuZnVuY3Rpb24gZ2V0Um90YXRpaW9uKHRvdWNoZXMpIHtcbiAgcmV0dXJuIGdldFJhZChbdG91Y2hlc1swXS5jbGllbnRYLCB0b3VjaGVzWzBdLmNsaWVudFldLCBbdG91Y2hlc1sxXS5jbGllbnRYLCB0b3VjaGVzWzFdLmNsaWVudFldKSAvIE1hdGguUEkgKiAxODA7XG59XG5mdW5jdGlvbiBpc011bHRpVG91Y2goZSkge1xuICByZXR1cm4gZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPj0gMjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xpZW50cyhlKSB7XG4gIGlmIChlLnRvdWNoZXMpIHtcbiAgICByZXR1cm4gZ2V0Q2xpZW50cyhlLnRvdWNoZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbZ2V0Q2xpZW50KGUpXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UG9zaXRpb24oY2xpZW50cywgcHJldkNsaWVudHMsIHN0YXJ0Q2xpZW50cykge1xuICB2YXIgbGVuZ3RoID0gc3RhcnRDbGllbnRzLmxlbmd0aDtcblxuICB2YXIgX2EgPSBnZXRBdmVyYWdlQ2xpZW50KGNsaWVudHMsIGxlbmd0aCksXG4gICAgICBjbGllbnRYID0gX2EuY2xpZW50WCxcbiAgICAgIGNsaWVudFkgPSBfYS5jbGllbnRZLFxuICAgICAgb3JpZ2luYWxDbGllbnRYID0gX2Eub3JpZ2luYWxDbGllbnRYLFxuICAgICAgb3JpZ2luYWxDbGllbnRZID0gX2Eub3JpZ2luYWxDbGllbnRZO1xuXG4gIHZhciBfYiA9IGdldEF2ZXJhZ2VDbGllbnQocHJldkNsaWVudHMsIGxlbmd0aCksXG4gICAgICBwcmV2WCA9IF9iLmNsaWVudFgsXG4gICAgICBwcmV2WSA9IF9iLmNsaWVudFk7XG5cbiAgdmFyIF9jID0gZ2V0QXZlcmFnZUNsaWVudChzdGFydENsaWVudHMsIGxlbmd0aCksXG4gICAgICBzdGFydFggPSBfYy5jbGllbnRYLFxuICAgICAgc3RhcnRZID0gX2MuY2xpZW50WTtcblxuICB2YXIgZGVsdGFYID0gY2xpZW50WCAtIHByZXZYO1xuICB2YXIgZGVsdGFZID0gY2xpZW50WSAtIHByZXZZO1xuICB2YXIgZGlzdFggPSBjbGllbnRYIC0gc3RhcnRYO1xuICB2YXIgZGlzdFkgPSBjbGllbnRZIC0gc3RhcnRZO1xuICByZXR1cm4ge1xuICAgIGNsaWVudFg6IG9yaWdpbmFsQ2xpZW50WCxcbiAgICBjbGllbnRZOiBvcmlnaW5hbENsaWVudFksXG4gICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgZGVsdGFZOiBkZWx0YVksXG4gICAgZGlzdFg6IGRpc3RYLFxuICAgIGRpc3RZOiBkaXN0WVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGlzdChjbGllbnRzKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coY2xpZW50c1swXS5jbGllbnRYIC0gY2xpZW50c1sxXS5jbGllbnRYLCAyKSArIE1hdGgucG93KGNsaWVudHNbMF0uY2xpZW50WSAtIGNsaWVudHNbMV0uY2xpZW50WSwgMikpO1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50cyh0b3VjaGVzKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbih0b3VjaGVzLmxlbmd0aCwgMik7XG4gIHZhciBjbGllbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNsaWVudHMucHVzaChnZXRDbGllbnQodG91Y2hlc1tpXSkpO1xuICB9XG5cbiAgcmV0dXJuIGNsaWVudHM7XG59XG5mdW5jdGlvbiBnZXRDbGllbnQoZSkge1xuICByZXR1cm4ge1xuICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICBjbGllbnRZOiBlLmNsaWVudFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEF2ZXJhZ2VDbGllbnQoY2xpZW50cywgbGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPT09IHZvaWQgMCkge1xuICAgIGxlbmd0aCA9IGNsaWVudHMubGVuZ3RoO1xuICB9XG5cbiAgdmFyIHN1bUNsaWVudCA9IHtcbiAgICBjbGllbnRYOiAwLFxuICAgIGNsaWVudFk6IDAsXG4gICAgb3JpZ2luYWxDbGllbnRYOiAwLFxuICAgIG9yaWdpbmFsQ2xpZW50WTogMFxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2xpZW50ID0gY2xpZW50c1tpXTtcbiAgICBzdW1DbGllbnQub3JpZ2luYWxDbGllbnRYICs9IFwib3JpZ2luYWxDbGllbnRYXCIgaW4gY2xpZW50ID8gY2xpZW50Lm9yaWdpbmFsQ2xpZW50WCA6IGNsaWVudC5jbGllbnRYO1xuICAgIHN1bUNsaWVudC5vcmlnaW5hbENsaWVudFkgKz0gXCJvcmlnaW5hbENsaWVudFlcIiBpbiBjbGllbnQgPyBjbGllbnQub3JpZ2luYWxDbGllbnRZIDogY2xpZW50LmNsaWVudFk7XG4gICAgc3VtQ2xpZW50LmNsaWVudFggKz0gY2xpZW50LmNsaWVudFg7XG4gICAgc3VtQ2xpZW50LmNsaWVudFkgKz0gY2xpZW50LmNsaWVudFk7XG4gIH1cblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiBzdW1DbGllbnQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNsaWVudFg6IHN1bUNsaWVudC5jbGllbnRYIC8gbGVuZ3RoLFxuICAgIGNsaWVudFk6IHN1bUNsaWVudC5jbGllbnRZIC8gbGVuZ3RoLFxuICAgIG9yaWdpbmFsQ2xpZW50WDogc3VtQ2xpZW50Lm9yaWdpbmFsQ2xpZW50WCAvIGxlbmd0aCxcbiAgICBvcmlnaW5hbENsaWVudFk6IHN1bUNsaWVudC5vcmlnaW5hbENsaWVudFkgLyBsZW5ndGhcbiAgfTtcbn1cblxudmFyIENsaWVudFN0b3JlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2xpZW50U3RvcmUoY2xpZW50cykge1xuICAgIHRoaXMucHJldkNsaWVudHMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0Q2xpZW50cyA9IFtdO1xuICAgIHRoaXMubW92ZW1lbnQgPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnN0YXJ0Q2xpZW50cyA9IGNsaWVudHM7XG4gICAgdGhpcy5wcmV2Q2xpZW50cyA9IGNsaWVudHM7XG4gICAgdGhpcy5sZW5ndGggPSBjbGllbnRzLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gQ2xpZW50U3RvcmUucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZ2V0QW5nbGUgPSBmdW5jdGlvbiAoY2xpZW50cykge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRSb3RhdGlpb24oY2xpZW50cyk7XG4gIH07XG5cbiAgX19wcm90by5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIChjbGllbnRzKSB7XG4gICAgaWYgKGNsaWVudHMgPT09IHZvaWQgMCkge1xuICAgICAgY2xpZW50cyA9IHRoaXMucHJldkNsaWVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFJvdGF0aWlvbihjbGllbnRzKSAtIGdldFJvdGF0aWlvbih0aGlzLnN0YXJ0Q2xpZW50cyk7XG4gIH07XG5cbiAgX19wcm90by5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChjbGllbnRzLCBpc0FkZCkge1xuICAgIGlmIChjbGllbnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNsaWVudHMgPSB0aGlzLnByZXZDbGllbnRzO1xuICAgIH1cblxuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKGNsaWVudHMgfHwgdGhpcy5wcmV2Q2xpZW50cywgdGhpcy5wcmV2Q2xpZW50cywgdGhpcy5zdGFydENsaWVudHMpO1xuICAgIHZhciBkZWx0YVggPSBwb3NpdGlvbi5kZWx0YVgsXG4gICAgICAgIGRlbHRhWSA9IHBvc2l0aW9uLmRlbHRhWTtcbiAgICB0aGlzLm1vdmVtZW50ICs9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xuICAgIHRoaXMucHJldkNsaWVudHMgPSBjbGllbnRzO1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfTtcblxuICBfX3Byb3RvLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIChjbGllbnRzKSB7XG4gICAgaWYgKGNsaWVudHMgPT09IHZvaWQgMCkge1xuICAgICAgY2xpZW50cyA9IHRoaXMucHJldkNsaWVudHM7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDbGllbnRzID0gdGhpcy5wcmV2Q2xpZW50cztcbiAgICByZXR1cm4gdGhpcy5zdGFydENsaWVudHMubWFwKGZ1bmN0aW9uIChzdGFydENsaWVudCwgaSkge1xuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKFtjbGllbnRzW2ldXSwgW3ByZXZDbGllbnRzW2ldXSwgW3N0YXJ0Q2xpZW50XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uIChjbGllbnRzKSB7XG4gICAgdmFyIG1vdmVtZW50ID0gdGhpcy5tb3ZlbWVudDtcblxuICAgIGlmICghY2xpZW50cykge1xuICAgICAgcmV0dXJuIG1vdmVtZW50O1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50Q2xpZW50ID0gZ2V0QXZlcmFnZUNsaWVudChjbGllbnRzLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIHByZXZDbGllbnQgPSBnZXRBdmVyYWdlQ2xpZW50KHRoaXMucHJldkNsaWVudHMsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgZGVsdGFYID0gY3VycmVudENsaWVudC5jbGllbnRYIC0gcHJldkNsaWVudC5jbGllbnRYO1xuICAgIHZhciBkZWx0YVkgPSBjdXJyZW50Q2xpZW50LmNsaWVudFkgLSBwcmV2Q2xpZW50LmNsaWVudFk7XG4gICAgcmV0dXJuIE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpICsgbW92ZW1lbnQ7XG4gIH07XG5cbiAgX19wcm90by5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIChjbGllbnRzKSB7XG4gICAgaWYgKGNsaWVudHMgPT09IHZvaWQgMCkge1xuICAgICAgY2xpZW50cyA9IHRoaXMucHJldkNsaWVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldERpc3QoY2xpZW50cyk7XG4gIH07XG5cbiAgX19wcm90by5nZXRTY2FsZSA9IGZ1bmN0aW9uIChjbGllbnRzKSB7XG4gICAgaWYgKGNsaWVudHMgPT09IHZvaWQgMCkge1xuICAgICAgY2xpZW50cyA9IHRoaXMucHJldkNsaWVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldERpc3QoY2xpZW50cykgLyBnZXREaXN0KHRoaXMuc3RhcnRDbGllbnRzKTtcbiAgfTtcblxuICBfX3Byb3RvLm1vdmUgPSBmdW5jdGlvbiAoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB0aGlzLnN0YXJ0Q2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICAgIGNsaWVudC5jbGllbnRYIC09IGRlbHRhWDtcbiAgICAgIGNsaWVudC5jbGllbnRZIC09IGRlbHRhWTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ2xpZW50U3RvcmU7XG59KCk7XG5cbnZhciBJTlBVVF9UQUdOQU1FUyA9IFtcInRleHRhcmVhXCIsIFwiaW5wdXRcIl07XG4vKipcbiAqIFlvdSBjYW4gc2V0IHVwIGRyYWcsIHBpbmNoIGV2ZW50cyBpbiBhbnkgYnJvd3Nlci5cbiAqL1xuXG52YXIgR2VzdG8gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoR2VzdG8sIF9zdXBlcik7XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIEdlc3RvKHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICBfdGhpcy5mbGFnID0gZmFsc2U7XG4gICAgX3RoaXMucGluY2hGbGFnID0gZmFsc2U7XG4gICAgX3RoaXMuZGF0YXMgPSB7fTtcbiAgICBfdGhpcy5pc0RyYWcgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1BpbmNoID0gZmFsc2U7XG4gICAgX3RoaXMuaXNNb3VzZSA9IGZhbHNlO1xuICAgIF90aGlzLmlzVG91Y2ggPSBmYWxzZTtcbiAgICBfdGhpcy5jbGllbnRTdG9yZXMgPSBbXTtcbiAgICBfdGhpcy50YXJnZXRzID0gW107XG4gICAgX3RoaXMucHJldlRpbWUgPSAwO1xuICAgIF90aGlzLmRvdWJsZUZsYWcgPSBmYWxzZTtcbiAgICBfdGhpcy5fZHJhZ0ZsYWcgPSBmYWxzZTtcblxuICAgIF90aGlzLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUsIGlzVHJ1c3RlZCkge1xuICAgICAgaWYgKGlzVHJ1c3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzVHJ1c3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3RoaXMuZmxhZyAmJiBlLmNhbmNlbGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9hID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXIsXG4gICAgICAgICAgcGluY2hPdXRzaWRlID0gX2EucGluY2hPdXRzaWRlLFxuICAgICAgICAgIHByZXZlbnRSaWdodENsaWNrID0gX2EucHJldmVudFJpZ2h0Q2xpY2ssXG4gICAgICAgICAgcHJldmVudERlZmF1bHQgPSBfYS5wcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBjaGVja0lucHV0ID0gX2EuY2hlY2tJbnB1dDtcbiAgICAgIHZhciBpc1RvdWNoID0gX3RoaXMuaXNUb3VjaDtcbiAgICAgIHZhciBpc0RyYWdTdGFydCA9ICFfdGhpcy5mbGFnO1xuXG4gICAgICBpZiAoaXNEcmFnU3RhcnQpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGhhc0lucHV0ID0gSU5QVVRfVEFHTkFNRVMuaW5kZXhPZih0YWdOYW1lKSA+IC0xO1xuICAgICAgICB2YXIgaGFzQ29udGVudEVkaXRhYmxlID0gdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlO1xuXG4gICAgICAgIGlmIChoYXNJbnB1dCB8fCBoYXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgICBpZiAoY2hlY2tJbnB1dCB8fCBhY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vIGZvcmNlIGZhbHNlIG9yIGFscmVhZHkgZm9jdXNlZC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIG5vIGZvY3VzXG5cblxuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGhhc0NvbnRlbnRFZGl0YWJsZSAmJiBhY3RpdmVFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlICYmIGFjdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgocHJldmVudERlZmF1bHQgfHwgZS50eXBlID09PSBcInRvdWNoc3RhcnRcIikgJiYgYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgIHZhciBhY3RpdmVUYWdOYW1lID0gYWN0aXZlRWxlbWVudC50YWdOYW1lO1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQuaXNDb250ZW50RWRpdGFibGUgfHwgSU5QVVRfVEFHTkFNRVMuaW5kZXhPZihhY3RpdmVUYWdOYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5jbGllbnRTdG9yZXMgPSBbbmV3IENsaWVudFN0b3JlKGdldEV2ZW50Q2xpZW50cyhlKSldO1xuICAgICAgICBfdGhpcy5mbGFnID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuaXNEcmFnID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9kcmFnRmxhZyA9IHRydWU7XG4gICAgICAgIF90aGlzLmRhdGFzID0ge307XG5cbiAgICAgICAgaWYgKHByZXZlbnRSaWdodENsaWNrICYmIChlLndoaWNoID09PSAzIHx8IGUuYnV0dG9uID09PSAyKSkge1xuICAgICAgICAgIF90aGlzLmluaXREcmFnKCk7XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5kb3VibGVGbGFnID0gbm93KCkgLSBfdGhpcy5wcmV2VGltZSA8IDIwMDtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuZW1pdChcImRyYWdTdGFydFwiLCBfX2Fzc2lnbih7XG4gICAgICAgICAgZGF0YXM6IF90aGlzLmRhdGFzLFxuICAgICAgICAgIGlucHV0RXZlbnQ6IGUsXG4gICAgICAgICAgaXNUcnVzdGVkOiBpc1RydXN0ZWQsXG4gICAgICAgICAgaXNEb3VibGU6IF90aGlzLmRvdWJsZUZsYWdcbiAgICAgICAgfSwgX3RoaXMuZ2V0Q3VycmVudFN0b3JlKCkuZ2V0UG9zaXRpb24oKSwge1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcmV2ZW50RHJhZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2RyYWdGbGFnID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBfdGhpcy5pbml0RHJhZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZmxhZyAmJiBwcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3RoaXMuZmxhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1lciA9IDA7XG5cbiAgICAgIGlmIChpc0RyYWdTdGFydCAmJiBpc1RvdWNoICYmIHBpbmNoT3V0c2lkZSkge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLm9uRHJhZ1N0YXJ0LCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0RyYWdTdGFydCAmJiBpc1RvdWNoICYmIHBpbmNoT3V0c2lkZSkge1xuICAgICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5mbGFnICYmIGlzTXVsdGlUb3VjaChlKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIGlmIChpc0RyYWdTdGFydCAmJiBlLnRvdWNoZXMubGVuZ3RoICE9PSBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXMucGluY2hGbGFnKSB7XG4gICAgICAgICAgX3RoaXMub25QaW5jaFN0YXJ0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRHJhZyA9IGZ1bmN0aW9uIChlLCBpc1Njcm9sbCkge1xuICAgICAgaWYgKCFfdGhpcy5mbGFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsaWVudHMgPSBnZXRFdmVudENsaWVudHMoZSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5tb3ZlQ2xpZW50cyhjbGllbnRzLCBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChfdGhpcy5fZHJhZ0ZsYWcpIHtcbiAgICAgICAgaWYgKF90aGlzLnBpbmNoRmxhZyB8fCByZXN1bHQuZGVsdGFYIHx8IHJlc3VsdC5kZWx0YVkpIHtcbiAgICAgICAgICB2YXIgZHJhZ1Jlc3VsdCA9IF90aGlzLmVtaXQoXCJkcmFnXCIsIF9fYXNzaWduKHt9LCByZXN1bHQsIHtcbiAgICAgICAgICAgIGlzU2Nyb2xsOiAhIWlzU2Nyb2xsLFxuICAgICAgICAgICAgaW5wdXRFdmVudDogZVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGlmIChkcmFnUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RvcCgpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLnBpbmNoRmxhZykge1xuICAgICAgICAgIF90aGlzLm9uUGluY2goZSwgY2xpZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMuZ2V0Q3VycmVudFN0b3JlKCkuZ2V0UG9zaXRpb24oY2xpZW50cywgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLmZsYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2EgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHBpbmNoT3V0c2lkZSA9IF9hLnBpbmNoT3V0c2lkZSxcbiAgICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXI7XG5cbiAgICAgIGlmIChfdGhpcy5pc1RvdWNoICYmIHBpbmNoT3V0c2lkZSkge1xuICAgICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwidG91Y2hzdGFydFwiLCBfdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmZsYWcgPSBmYWxzZTtcblxuICAgICAgdmFyIHBvc2l0aW9uID0gX3RoaXMuX2dldFBvc2l0aW9uKCk7XG5cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgICAgdmFyIGlzRG91YmxlID0gIV90aGlzLmlzRHJhZyAmJiBfdGhpcy5kb3VibGVGbGFnO1xuICAgICAgX3RoaXMucHJldlRpbWUgPSBfdGhpcy5pc0RyYWcgfHwgaXNEb3VibGUgPyAwIDogY3VycmVudFRpbWU7XG5cbiAgICAgIF90aGlzLmVtaXQoXCJkcmFnRW5kXCIsIF9fYXNzaWduKHtcbiAgICAgICAgZGF0YXM6IF90aGlzLmRhdGFzLFxuICAgICAgICBpc0RvdWJsZTogaXNEb3VibGUsXG4gICAgICAgIGlzRHJhZzogX3RoaXMuaXNEcmFnLFxuICAgICAgICBpc0NsaWNrOiAhX3RoaXMuaXNEcmFnLFxuICAgICAgICBpbnB1dEV2ZW50OiBlXG4gICAgICB9LCBwb3NpdGlvbikpO1xuXG4gICAgICBpZiAoX3RoaXMucGluY2hGbGFnKSB7XG4gICAgICAgIF90aGlzLm9uUGluY2hFbmQoZSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmNsaWVudFN0b3JlcyA9IFtdO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vbkRyYWdFbmQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGVsZW1lbnRzID0gW10uY29uY2F0KHRhcmdldHMpO1xuICAgIF90aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBjaGVja0lucHV0OiBmYWxzZSxcbiAgICAgIGNvbnRhaW5lcjogZWxlbWVudHMubGVuZ3RoID4gMSA/IHdpbmRvdyA6IGVsZW1lbnRzWzBdLFxuICAgICAgcHJldmVudFJpZ2h0Q2xpY2s6IHRydWUsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgIGNoZWNrV2luZG93Qmx1cjogZmFsc2UsXG4gICAgICBwaW5jaFRocmVzaG9sZDogMCxcbiAgICAgIGV2ZW50czogW1widG91Y2hcIiwgXCJtb3VzZVwiXVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcixcbiAgICAgICAgZXZlbnRzID0gX2EuZXZlbnRzLFxuICAgICAgICBjaGVja1dpbmRvd0JsdXIgPSBfYS5jaGVja1dpbmRvd0JsdXI7XG4gICAgX3RoaXMuaXNUb3VjaCA9IGV2ZW50cy5pbmRleE9mKFwidG91Y2hcIikgPiAtMTtcbiAgICBfdGhpcy5pc01vdXNlID0gZXZlbnRzLmluZGV4T2YoXCJtb3VzZVwiKSA+IC0xO1xuICAgIF90aGlzLnRhcmdldHMgPSBlbGVtZW50cztcblxuICAgIGlmIChfdGhpcy5pc01vdXNlKSB7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBhZGRFdmVudChlbCwgXCJtb3VzZWRvd25cIiwgX3RoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfSk7XG4gICAgICBhZGRFdmVudChjb250YWluZXIsIFwibW91c2Vtb3ZlXCIsIF90aGlzLm9uRHJhZyk7XG4gICAgICBhZGRFdmVudChjb250YWluZXIsIFwibW91c2V1cFwiLCBfdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgYWRkRXZlbnQoY29udGFpbmVyLCBcImNvbnRleHRtZW51XCIsIF90aGlzLm9uRHJhZ0VuZCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrV2luZG93Qmx1cikge1xuICAgICAgYWRkRXZlbnQod2luZG93LCBcImJsdXJcIiwgX3RoaXMub25CbHVyKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuaXNUb3VjaCkge1xuICAgICAgdmFyIHBhc3NpdmVfMSA9IHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBhZGRFdmVudChlbCwgXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLm9uRHJhZ1N0YXJ0LCBwYXNzaXZlXzEpO1xuICAgICAgfSk7XG4gICAgICBhZGRFdmVudChjb250YWluZXIsIFwidG91Y2htb3ZlXCIsIF90aGlzLm9uRHJhZywgcGFzc2l2ZV8xKTtcbiAgICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJ0b3VjaGVuZFwiLCBfdGhpcy5vbkRyYWdFbmQsIHBhc3NpdmVfMSk7XG4gICAgICBhZGRFdmVudChjb250YWluZXIsIFwidG91Y2hjYW5jZWxcIiwgX3RoaXMub25EcmFnRW5kLCBwYXNzaXZlXzEpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcCBHZXN0bydzIGRyYWcgZXZlbnRzLlxuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gR2VzdG8ucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgIHRoaXMuZmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuY2xpZW50U3RvcmVzID0gW107XG4gICAgdGhpcy5kYXRhcyA9IHt9O1xuICB9O1xuICAvKipcbiAgICogVGhlIHRvdGFsIG1vdmVkIGRpc3RhbmNlXG4gICAqL1xuXG5cbiAgX19wcm90by5nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uIChjbGllbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFN0b3JlKCkuZ2V0TW92ZW1lbnQoY2xpZW50cykgKyB0aGlzLmNsaWVudFN0b3Jlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgcmV0dXJuIHByZXYgKyBjdXIubW92ZW1lbnQ7XG4gICAgfSwgMCk7XG4gIH07XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRyYWdcbiAgICovXG5cblxuICBfX3Byb3RvLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEcmFnO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0byBzdGFydCBkcmFnXG4gICAqL1xuXG5cbiAgX19wcm90by5pc0ZsYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZztcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3RhcnQgcGluY2hcbiAgICovXG5cblxuICBfX3Byb3RvLmlzUGluY2hGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBpbmNoRmxhZztcbiAgfTtcbiAgLyoqXG4gICogV2hldGhlciB0byBzdGFydCBkb3VibGUgY2xpY2tcbiAgKi9cblxuXG4gIF9fcHJvdG8uaXNEb3VibGVGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRvdWJsZUZsYWc7XG4gIH07XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHBpbmNoXG4gICAqL1xuXG5cbiAgX19wcm90by5pc1BpbmNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGluY2g7XG4gIH07XG4gIC8qKlxuICAgKiBJZiBhIHNjcm9sbCBldmVudCBvY2N1cnMsIGl0IGlzIGNvcnJlY3RlZCBieSB0aGUgc2Nyb2xsIGRpc3RhbmNlLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uc2Nyb2xsQnkgPSBmdW5jdGlvbiAoZGVsdGFYLCBkZWx0YVksIGUsIGlzQ2FsbERyYWcpIHtcbiAgICBpZiAoaXNDYWxsRHJhZyA9PT0gdm9pZCAwKSB7XG4gICAgICBpc0NhbGxEcmFnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZmxhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2xpZW50U3RvcmVzWzBdLm1vdmUoZGVsdGFYLCBkZWx0YVkpO1xuICAgIGlzQ2FsbERyYWcgJiYgdGhpcy5vbkRyYWcoZSwgdHJ1ZSk7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2aXJ0dWFsIGRyYWcgZXZlbnQuXG4gICAqL1xuXG5cbiAgX19wcm90by5tb3ZlID0gZnVuY3Rpb24gKF9hLCBpbnB1dEV2ZW50KSB7XG4gICAgdmFyIGRlbHRhWCA9IF9hWzBdLFxuICAgICAgICBkZWx0YVkgPSBfYVsxXTtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLmdldEN1cnJlbnRTdG9yZSgpO1xuICAgIHZhciBuZXh0Q2xpZW50cyA9IHN0b3JlLnByZXZDbGllbnRzO1xuICAgIHJldHVybiB0aGlzLm1vdmVDbGllbnRzKG5leHRDbGllbnRzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgIHZhciBjbGllbnRYID0gX2EuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX2EuY2xpZW50WTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFg6IGNsaWVudFggKyBkZWx0YVgsXG4gICAgICAgIGNsaWVudFk6IGNsaWVudFkgKyBkZWx0YVksXG4gICAgICAgIG9yaWdpbmFsQ2xpZW50WDogY2xpZW50WCxcbiAgICAgICAgb3JpZ2luYWxDbGllbnRZOiBjbGllbnRZXG4gICAgICB9O1xuICAgIH0pLCBpbnB1dEV2ZW50LCB0cnVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSBkcmFnU3RhcnQgZXZlbnQgaXMgdHJpZ2dlcmVkIGJ5IGFuIGV4dGVybmFsIGV2ZW50LlxuICAgKi9cblxuXG4gIF9fcHJvdG8udHJpZ2dlckRyYWdTdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdGhpcy5vbkRyYWdTdGFydChlLCBmYWxzZSk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdGhlIGV2ZW50IGRhdGEgd2hpbGUgZHJhZ2dpbmcuXG4gICAqL1xuXG5cbiAgX19wcm90by5zZXRFdmVudERhdGFzID0gZnVuY3Rpb24gKGRhdGFzKSB7XG4gICAgdmFyIGN1cnJlbnREYXRhcyA9IHRoaXMuZGF0YXM7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGRhdGFzKSB7XG4gICAgICBjdXJyZW50RGF0YXNbbmFtZV0gPSBkYXRhc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBldmVudCBzdGF0ZSB3aGlsZSBkcmFnZ2luZy5cbiAgICovXG5cblxuICBfX3Byb3RvLmdldEN1cnJlbnRFdmVudCA9IGZ1bmN0aW9uIChpbnB1dEV2ZW50KSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKHtcbiAgICAgIGRhdGFzOiB0aGlzLmRhdGFzXG4gICAgfSwgdGhpcy5fZ2V0UG9zaXRpb24oKSwge1xuICAgICAgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQoKSxcbiAgICAgIGlzRHJhZzogdGhpcy5pc0RyYWcsXG4gICAgICBpc1BpbmNoOiB0aGlzLmlzUGluY2gsXG4gICAgICBpc1Njcm9sbDogZmFsc2UsXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgJiBTZXQgdGhlIGV2ZW50IGRhdGEgd2hpbGUgZHJhZ2dpbmcuXG4gICAqL1xuXG5cbiAgX19wcm90by5nZXRFdmVudERhdGFzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFzO1xuICB9O1xuICAvKipcbiAgICogVW5zZXQgR2VzdG9cbiAgICovXG5cblxuICBfX3Byb3RvLnVuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLm9mZigpO1xuICAgIHJlbW92ZUV2ZW50KHdpbmRvdywgXCJibHVyXCIsIHRoaXMub25CbHVyKTtcblxuICAgIGlmICh0aGlzLmlzTW91c2UpIHtcbiAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHJlbW92ZUV2ZW50KHRhcmdldCwgXCJtb3VzZWRvd25cIiwgX3RoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfSk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwibW91c2Vtb3ZlXCIsIHRoaXMub25EcmFnKTtcbiAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJtb3VzZXVwXCIsIHRoaXMub25EcmFnRW5kKTtcbiAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJjb250ZXh0bWVudVwiLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNUb3VjaCkge1xuICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnQodGFyZ2V0LCBcInRvdWNoc3RhcnRcIiwgX3RoaXMub25EcmFnU3RhcnQpO1xuICAgICAgfSk7XG4gICAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwidG91Y2hzdGFydFwiLCB0aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJ0b3VjaG1vdmVcIiwgdGhpcy5vbkRyYWcpO1xuICAgICAgcmVtb3ZlRXZlbnQoY29udGFpbmVyLCBcInRvdWNoZW5kXCIsIHRoaXMub25EcmFnRW5kKTtcbiAgICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8ub25QaW5jaFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcGluY2hUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMucGluY2hUaHJlc2hvbGQ7XG5cbiAgICBpZiAodGhpcy5pc0RyYWcgJiYgdGhpcy5nZXRNb3ZlbWVudCgpID4gcGluY2hUaHJlc2hvbGQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RvcmUgPSBuZXcgQ2xpZW50U3RvcmUoZ2V0RXZlbnRDbGllbnRzKGUpKTtcbiAgICB0aGlzLnBpbmNoRmxhZyA9IHRydWU7XG4gICAgdGhpcy5jbGllbnRTdG9yZXMuc3BsaWNlKDAsIDAsIHN0b3JlKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5lbWl0KFwicGluY2hTdGFydFwiLCBfX2Fzc2lnbih7XG4gICAgICBkYXRhczogdGhpcy5kYXRhcyxcbiAgICAgIGFuZ2xlOiBzdG9yZS5nZXRBbmdsZSgpLFxuICAgICAgdG91Y2hlczogdGhpcy5nZXRDdXJyZW50U3RvcmUoKS5nZXRQb3NpdGlvbnMoKVxuICAgIH0sIHN0b3JlLmdldFBvc2l0aW9uKCksIHtcbiAgICAgIGlucHV0RXZlbnQ6IGVcbiAgICB9KSk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5waW5jaEZsYWcgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5vblBpbmNoID0gZnVuY3Rpb24gKGUsIGNsaWVudHMpIHtcbiAgICBpZiAoIXRoaXMuZmxhZyB8fCAhdGhpcy5waW5jaEZsYWcgfHwgY2xpZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0b3JlID0gdGhpcy5nZXRDdXJyZW50U3RvcmUoKTtcbiAgICB0aGlzLmlzUGluY2ggPSB0cnVlO1xuICAgIHRoaXMuZW1pdChcInBpbmNoXCIsIF9fYXNzaWduKHtcbiAgICAgIGRhdGFzOiB0aGlzLmRhdGFzLFxuICAgICAgbW92ZW1lbnQ6IHRoaXMuZ2V0TW92ZW1lbnQoY2xpZW50cyksXG4gICAgICBhbmdsZTogc3RvcmUuZ2V0QW5nbGUoY2xpZW50cyksXG4gICAgICByb3RhdGlvbjogc3RvcmUuZ2V0Um90YXRpb24oY2xpZW50cyksXG4gICAgICB0b3VjaGVzOiBzdG9yZS5nZXRQb3NpdGlvbnMoY2xpZW50cyksXG4gICAgICBzY2FsZTogc3RvcmUuZ2V0U2NhbGUoY2xpZW50cyksXG4gICAgICBkaXN0YW5jZTogc3RvcmUuZ2V0RGlzdGFuY2UoY2xpZW50cylcbiAgICB9LCBzdG9yZS5nZXRQb3NpdGlvbihjbGllbnRzKSwge1xuICAgICAgaW5wdXRFdmVudDogZVxuICAgIH0pKTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUGluY2hFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghdGhpcy5waW5jaEZsYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNQaW5jaCA9IHRoaXMuaXNQaW5jaDtcbiAgICB0aGlzLmlzUGluY2ggPSBmYWxzZTtcbiAgICB0aGlzLnBpbmNoRmxhZyA9IGZhbHNlO1xuICAgIHZhciBzdG9yZSA9IHRoaXMuZ2V0Q3VycmVudFN0b3JlKCk7XG4gICAgdGhpcy5lbWl0KFwicGluY2hFbmRcIiwgX19hc3NpZ24oe1xuICAgICAgZGF0YXM6IHRoaXMuZGF0YXMsXG4gICAgICBpc1BpbmNoOiBpc1BpbmNoLFxuICAgICAgdG91Y2hlczogc3RvcmUuZ2V0UG9zaXRpb25zKClcbiAgICB9LCBzdG9yZS5nZXRQb3NpdGlvbigpLCB7XG4gICAgICBpbnB1dEV2ZW50OiBlXG4gICAgfSkpO1xuICAgIHRoaXMuaXNQaW5jaCA9IGZhbHNlO1xuICAgIHRoaXMucGluY2hGbGFnID0gZmFsc2U7XG4gIH07XG5cbiAgX19wcm90by5pbml0RHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsaWVudFN0b3JlcyA9IFtdO1xuICAgIHRoaXMucGluY2hGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5kb3VibGVGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2VGltZSA9IDA7XG4gICAgdGhpcy5mbGFnID0gZmFsc2U7XG4gIH07XG5cbiAgX19wcm90by5nZXRDdXJyZW50U3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50U3RvcmVzWzBdO1xuICB9O1xuXG4gIF9fcHJvdG8ubW92ZUNsaWVudHMgPSBmdW5jdGlvbiAoY2xpZW50cywgaW5wdXRFdmVudCwgaXNBZGQpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihjbGllbnRzLCBpc0FkZCk7XG5cbiAgICBpZiAocG9zaXRpb24uZGVsdGFYIHx8IHBvc2l0aW9uLmRlbHRhWSkge1xuICAgICAgdGhpcy5pc0RyYWcgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfX2Fzc2lnbih7XG4gICAgICBkYXRhczogdGhpcy5kYXRhc1xuICAgIH0sIHBvc2l0aW9uLCB7XG4gICAgICBtb3ZlbWVudDogdGhpcy5nZXRNb3ZlbWVudChjbGllbnRzKSxcbiAgICAgIGlzRHJhZzogdGhpcy5pc0RyYWcsXG4gICAgICBpc1BpbmNoOiB0aGlzLmlzUGluY2gsXG4gICAgICBpc1Njcm9sbDogZmFsc2UsXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5fZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoY2xpZW50cywgaXNBZGQpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLmdldEN1cnJlbnRTdG9yZSgpO1xuICAgIHZhciBwb3NpdGlvbiA9IHN0b3JlLmdldFBvc2l0aW9uKGNsaWVudHMsIGlzQWRkKTtcblxuICAgIHZhciBfYSA9IHRoaXMuY2xpZW50U3RvcmVzLnNsaWNlKDEpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICB2YXIgc3RvcmVQb3NpdGlvbiA9IGN1ci5nZXRQb3NpdGlvbigpO1xuICAgICAgcHJldi5kaXN0WCArPSBzdG9yZVBvc2l0aW9uLmRpc3RYO1xuICAgICAgcHJldi5kaXN0WSArPSBzdG9yZVBvc2l0aW9uLmRpc3RZO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwgcG9zaXRpb24pLFxuICAgICAgICBkaXN0WCA9IF9hLmRpc3RYLFxuICAgICAgICBkaXN0WSA9IF9hLmRpc3RZO1xuXG4gICAgcmV0dXJuIF9fYXNzaWduKHt9LCBwb3NpdGlvbiwge1xuICAgICAgZGlzdFg6IGRpc3RYLFxuICAgICAgZGlzdFk6IGRpc3RZXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEdlc3RvO1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBHZXN0bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlc3RvLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIERheWJydXNoXG5uYW1lOiBrZXljb25cbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9rZXljb24uZ2l0XG52ZXJzaW9uOiAxLjEuMlxuKi9cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE4IERheWJydXNoXG5AbmFtZTogQGRheWJydXNoL3V0aWxzXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC91dGlsc1xuQHZlcnNpb24gMS4wLjBcbiovXG4vKipcbiogZ2V0IHN0cmluZyBcIm9iamVjdFwiXG4qIEBtZW1iZXJvZiBDb25zdHNcbiogQGV4YW1wbGVcbmltcG9ydCB7T0JKRUNUfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKE9CSkVDVCk7IC8vIFwib2JqZWN0XCJcbiovXG5cbnZhciBPQkpFQ1QgPSBcIm9iamVjdFwiO1xuLyoqXG4qIGdldCBzdHJpbmcgXCJzdHJpbmdcIlxuKiBAbWVtYmVyb2YgQ29uc3RzXG4qIEBleGFtcGxlXG5pbXBvcnQge1NUUklOR30gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuXG5jb25zb2xlLmxvZyhTVFJJTkcpOyAvLyBcInN0cmluZ1wiXG4qL1xuXG52YXIgU1RSSU5HID0gXCJzdHJpbmdcIjtcbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBvYmplY3QuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzT2JqZWN0fSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzT2JqZWN0KHt9KSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzT2JqZWN0KHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNPYmplY3QoXCJcIikpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNPYmplY3QobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gT0JKRUNUO1xufVxuLyoqXG4qIENoZWNrIHRoZSB0eXBlIHRoYXQgdGhlIHZhbHVlIGlzIGlzQXJyYXkuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzQXJyYXl9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuY29uc29sZS5sb2coaXNBcnJheShbXSkpOyAvLyB0cnVlXG5jb25zb2xlLmxvZyhpc0FycmF5KHt9KSk7IC8vIGZhbHNlXG5jb25zb2xlLmxvZyhpc0FycmF5KHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNBcnJheShudWxsKSk7IC8vIGZhbHNlXG4qL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8qKlxuKiBDaGVjayB0aGUgdHlwZSB0aGF0IHRoZSB2YWx1ZSBpcyBzdHJpbmcuXG4qIEBtZW1iZXJvZiBVdGlsc1xuKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBWYWx1ZSB0byBjaGVjayB0aGUgdHlwZVxuKiBAcmV0dXJuIHt9IHRydWUgaWYgdGhlIHR5cGUgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4qIEBleGFtcGxlXG5pbXBvcnQge2lzU3RyaW5nfSBmcm9tIFwiQGRheWJydXNoL3V0aWxzXCI7XG5cbmNvbnNvbGUubG9nKGlzU3RyaW5nKFwiMTIzNFwiKSk7IC8vIHRydWVcbmNvbnNvbGUubG9nKGlzU3RyaW5nKHVuZGVmaW5lZCkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNTdHJpbmcoMSkpOyAvLyBmYWxzZVxuY29uc29sZS5sb2coaXNTdHJpbmcobnVsbCkpOyAvLyBmYWxzZVxuKi9cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gU1RSSU5HO1xufVxuLyoqXG4qIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBDcm9zc0Jyb3dzZXJcbiogQHBhcmFtIC0gVGhlIGFycmF5IGBmaW5kSW5kZXhgIHdhcyBjYWxsZWQgdXBvbi5cbiogQHBhcmFtIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5IHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGluZGljYXRpbmcgdGhhdCB0aGUgc2F0aXNmeWluZyBlbGVtZW50IHdhcyBmb3VuZC5cbiogQHBhcmFtIC0gUmV0dXJucyBkZWZhdWx0SW5kZXggaWYgbm90IGZvdW5kIGJ5IHRoZSBmdW5jdGlvbi5cbiogQGV4YW1wbGVcbmltcG9ydCB7IGZpbmRJbmRleCB9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuZmluZEluZGV4KFt7YTogMX0sIHthOiAyfSwge2E6IDN9LCB7YTogNH1dLCAoeyBhIH0pID0+IGEgPT09IDIpOyAvLyAxXG4qL1xuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBjYWxsYmFjaywgZGVmYXVsdEluZGV4KSB7XG4gIGlmIChkZWZhdWx0SW5kZXggPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRJbmRleCA9IC0xO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGksIGFycikpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0SW5kZXg7XG59XG4vKipcbiogU2V0cyB1cCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHNwZWNpZmllZCBldmVudCBpcyBkZWxpdmVyZWQgdG8gdGhlIHRhcmdldFxuKiBAbWVtYmVyb2YgRE9NXG4qIEBwYXJhbSAtIGV2ZW50IHRhcmdldFxuKiBAcGFyYW0gLSBBIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvci5cbiogQHBhcmFtIC0gVGhlIG9iamVjdCB3aGljaCByZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgRXZlbnQgaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnNcbiogQHBhcmFtIC0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0IHRoZSBldmVudCBsaXN0ZW5lci4gVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiogQGV4YW1wbGVcbmltcG9ydCB7YWRkRXZlbnR9IGZyb20gXCJAZGF5YnJ1c2gvdXRpbHNcIjtcblxuYWRkRXZlbnQoZWwsIFwiY2xpY2tcIiwgZSA9PiB7XG4gIGNvbnNvbGUubG9nKGUpO1xufSk7XG4qL1xuXG5mdW5jdGlvbiBhZGRFdmVudChlbCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG59XG4vKipcbiogcmVtb3ZlcyBmcm9tIHRoZSBFdmVudFRhcmdldCBhbiBldmVudCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKClcbiogQG1lbWJlcm9mIERPTVxuKiBAcGFyYW0gLSBldmVudCB0YXJnZXRcbiogQHBhcmFtIC0gQSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IuXG4qIEBwYXJhbSAtIFRoZSBFdmVudExpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCBoYW5kbGVyIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG4qIEBleGFtcGxlXG5pbXBvcnQge2FkZEV2ZW50LCByZW1vdmVFdmVudH0gZnJvbSBcIkBkYXlicnVzaC91dGlsc1wiO1xuY29uc3QgbGlzdGVuZXIgPSBlID0+IHtcbiAgY29uc29sZS5sb2coZSk7XG59O1xuYWRkRXZlbnQoZWwsIFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xucmVtb3ZlRXZlbnQoZWwsIFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xuKi9cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWwsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xufVxuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBAc2NlbmEvZXZlbnQtZW1pdHRlclxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3R1cmUuZ2l0XG52ZXJzaW9uOiAxLjAuMlxuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEltcGxlbWVudCBFdmVudEVtaXR0ZXIgb24gb2JqZWN0IG9yIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgcmVnaXN0ZXJlZCBldmVudC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIC0gbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIEFkZCBsaXN0ZW5lciBpbiBcImFcIiBldmVudFxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCAoKSA9PiB7XG4gICAqIH0pO1xuICAgKiAvLyBBZGQgbGlzdGVuZXJzXG4gICAqIGVtaXR0ZXIub24oe1xuICAgKiAgYTogKCkgPT4ge30sXG4gICAqICBiOiAoKSA9PiB7fSxcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChpc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9uKG5hbWUsIGV2ZW50TmFtZVtuYW1lXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgbGlzdGVuZXIsIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBpbiB0aGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAqIEBwYXJhbSAtIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzLlxuICAgKiBlbWl0dGVyLm9mZigpO1xuICAgKlxuICAgKiAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBcIkFcIiBldmVudC5cbiAgICogZW1pdHRlci5vZmYoXCJhXCIpO1xuICAgKlxuICAgKlxuICAgKiAvLyBSZW1vdmUgXCJsaXN0ZW5lclwiIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50LlxuICAgKiBlbWl0dGVyLm9mZihcImFcIiwgbGlzdGVuZXIpO1xuICAgKi9cblxuXG4gIF9fcHJvdG8ub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9mZihuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleChldmVudHMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUubGlzdGVuZXIgPT09IGxpc3RlbmVyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBBZGQgYSBkaXNwb3NhYmxlIGxpc3RlbmVyIGFuZCBVc2UgcHJvbWlzZSB0byB0aGUgcmVnaXN0ZXJlZCBldmVudC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIC0gZGlzcG9zYWJsZSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gQWRkIGEgZGlzcG9zYWJsZSBsaXN0ZW5lciBpbiBcImFcIiBldmVudFxuICAgKiBlbWl0dGVyLm9uY2UoXCJhXCIsICgpID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIFVzZSBQcm9taXNlXG4gICAqIGVtaXR0ZXIub25jZShcImFcIikudGhlbihlID0+IHtcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudChldmVudE5hbWUsIGxpc3RlbmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3RoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgcmVzb2x2ZSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICpcbiAgICpcbiAgICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBlbWl0dGVyLmVtaXQoXCJhXCIsIHtcbiAgICogICBhOiAxLFxuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICBpZiAoIWV2ZW50TmFtZSB8fCAhZXZlbnRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdG9wID0gZmFsc2U7XG4gICAgcGFyYW0uZXZlbnRUeXBlID0gZXZlbnROYW1lO1xuXG4gICAgcGFyYW0uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzU3RvcCA9IHRydWU7XG4gICAgfTtcblxuICAgIHBhcmFtLmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXG4gICAgX19zcHJlYWRBcnJheXMoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBpbmZvLmxpc3RlbmVyKHBhcmFtKTtcblxuICAgICAgaWYgKGluZm8ub25jZSkge1xuICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBpbmZvLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAhaXNTdG9wO1xuICB9O1xuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKlxuICAgKlxuICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIGVtaXR0ZXIuZW1pdChcImFcIiwge1xuICAgKiAgIGE6IDEsXG4gICAqIH0pO1xuICAgKi9cblxuICAvKipcbiAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICpcbiAgKlxuICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICpcbiAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgKiB9KTtcbiAgKlxuICAqIC8vIGVtaXRcbiAgKiBlbWl0dGVyLnRyaWdnZXIoXCJhXCIsIHtcbiAgKiAgIGE6IDEsXG4gICogfSk7XG4gICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgIGlmIChwYXJhbSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnROYW1lLCBwYXJhbSk7XG4gIH07XG5cbiAgX19wcm90by5fYWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgZXZlbnRzW2V2ZW50TmFtZV0gPSBldmVudHNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgbGlzdGVuZXJzLnB1c2goX19hc3NpZ24oe1xuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgcmV0dXJuIG1vZHVsZSA9IHtcbiAgICBleHBvcnRzOiB7fVxuICB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbnZhciBrZXljb2RlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLy8gU291cmNlOiBodHRwOi8vanNmaWRkbGUubmV0L3ZXeDhWL1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjAzMTk1L2Z1bGwtbGlzdC1vZi1qYXZhc2NyaXB0LWtleWNvZGVzXG5cbi8qKlxuICogQ29uZW5pZW5jZSBtZXRob2QgcmV0dXJucyBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciBnaXZlbiBrZXlOYW1lIG9yIGtleUNvZGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0ga2V5Q29kZSB7TnVtYmVyfSBvciBrZXlOYW1lIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24ga2V5Q29kZShzZWFyY2hJbnB1dCkge1xuICAvLyBLZXlib2FyZCBFdmVudHNcbiAgaWYgKHNlYXJjaElucHV0ICYmICdvYmplY3QnID09PSB0eXBlb2Ygc2VhcmNoSW5wdXQpIHtcbiAgICB2YXIgaGFzS2V5Q29kZSA9IHNlYXJjaElucHV0LndoaWNoIHx8IHNlYXJjaElucHV0LmtleUNvZGUgfHwgc2VhcmNoSW5wdXQuY2hhckNvZGU7XG4gICAgaWYgKGhhc0tleUNvZGUpIHNlYXJjaElucHV0ID0gaGFzS2V5Q29kZTtcbiAgfVxuXG4gIC8vIE51bWJlcnNcbiAgaWYgKCdudW1iZXInID09PSB0eXBlb2Ygc2VhcmNoSW5wdXQpIHJldHVybiBuYW1lc1tzZWFyY2hJbnB1dF1cblxuICAvLyBFdmVyeXRoaW5nIGVsc2UgKGNhc3QgdG8gc3RyaW5nKVxuICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaElucHV0KTtcblxuICAvLyBjaGVjayBjb2Rlc1xuICB2YXIgZm91bmROYW1lZEtleSA9IGNvZGVzW3NlYXJjaC50b0xvd2VyQ2FzZSgpXTtcbiAgaWYgKGZvdW5kTmFtZWRLZXkpIHJldHVybiBmb3VuZE5hbWVkS2V5XG5cbiAgLy8gY2hlY2sgYWxpYXNlc1xuICB2YXIgZm91bmROYW1lZEtleSA9IGFsaWFzZXNbc2VhcmNoLnRvTG93ZXJDYXNlKCldO1xuICBpZiAoZm91bmROYW1lZEtleSkgcmV0dXJuIGZvdW5kTmFtZWRLZXlcblxuICAvLyB3ZWlyZCBjaGFyYWN0ZXI/XG4gIGlmIChzZWFyY2gubGVuZ3RoID09PSAxKSByZXR1cm4gc2VhcmNoLmNoYXJDb2RlQXQoMClcblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQ29tcGFyZXMgYSBrZXlib2FyZCBldmVudCB3aXRoIGEgZ2l2ZW4ga2V5Q29kZSBvciBrZXlOYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEtleWJvYXJkIGV2ZW50IHRoYXQgc2hvdWxkIGJlIHRlc3RlZFxuICogQHBhcmFtIHtNaXhlZH0ga2V5Q29kZSB7TnVtYmVyfSBvciBrZXlOYW1lIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xua2V5Q29kZS5pc0V2ZW50S2V5ID0gZnVuY3Rpb24gaXNFdmVudEtleShldmVudCwgbmFtZU9yQ29kZSkge1xuICBpZiAoZXZlbnQgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBldmVudCkge1xuICAgIHZhciBrZXlDb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSB8fCBldmVudC5jaGFyQ29kZTtcbiAgICBpZiAoa2V5Q29kZSA9PT0gbnVsbCB8fCBrZXlDb2RlID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKHR5cGVvZiBuYW1lT3JDb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gY2hlY2sgY29kZXNcbiAgICAgIHZhciBmb3VuZE5hbWVkS2V5ID0gY29kZXNbbmFtZU9yQ29kZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmIChmb3VuZE5hbWVkS2V5KSB7IHJldHVybiBmb3VuZE5hbWVkS2V5ID09PSBrZXlDb2RlOyB9XG4gICAgXG4gICAgICAvLyBjaGVjayBhbGlhc2VzXG4gICAgICB2YXIgZm91bmROYW1lZEtleSA9IGFsaWFzZXNbbmFtZU9yQ29kZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmIChmb3VuZE5hbWVkS2V5KSB7IHJldHVybiBmb3VuZE5hbWVkS2V5ID09PSBrZXlDb2RlOyB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZU9yQ29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBuYW1lT3JDb2RlID09PSBrZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGtleUNvZGU7XG5cbi8qKlxuICogR2V0IGJ5IG5hbWVcbiAqXG4gKiAgIGV4cG9ydHMuY29kZVsnZW50ZXInXSAvLyA9PiAxM1xuICovXG5cbnZhciBjb2RlcyA9IGV4cG9ydHMuY29kZSA9IGV4cG9ydHMuY29kZXMgPSB7XG4gICdiYWNrc3BhY2UnOiA4LFxuICAndGFiJzogOSxcbiAgJ2VudGVyJzogMTMsXG4gICdzaGlmdCc6IDE2LFxuICAnY3RybCc6IDE3LFxuICAnYWx0JzogMTgsXG4gICdwYXVzZS9icmVhayc6IDE5LFxuICAnY2FwcyBsb2NrJzogMjAsXG4gICdlc2MnOiAyNyxcbiAgJ3NwYWNlJzogMzIsXG4gICdwYWdlIHVwJzogMzMsXG4gICdwYWdlIGRvd24nOiAzNCxcbiAgJ2VuZCc6IDM1LFxuICAnaG9tZSc6IDM2LFxuICAnbGVmdCc6IDM3LFxuICAndXAnOiAzOCxcbiAgJ3JpZ2h0JzogMzksXG4gICdkb3duJzogNDAsXG4gICdpbnNlcnQnOiA0NSxcbiAgJ2RlbGV0ZSc6IDQ2LFxuICAnY29tbWFuZCc6IDkxLFxuICAnbGVmdCBjb21tYW5kJzogOTEsXG4gICdyaWdodCBjb21tYW5kJzogOTMsXG4gICdudW1wYWQgKic6IDEwNixcbiAgJ251bXBhZCArJzogMTA3LFxuICAnbnVtcGFkIC0nOiAxMDksXG4gICdudW1wYWQgLic6IDExMCxcbiAgJ251bXBhZCAvJzogMTExLFxuICAnbnVtIGxvY2snOiAxNDQsXG4gICdzY3JvbGwgbG9jayc6IDE0NSxcbiAgJ215IGNvbXB1dGVyJzogMTgyLFxuICAnbXkgY2FsY3VsYXRvcic6IDE4MyxcbiAgJzsnOiAxODYsXG4gICc9JzogMTg3LFxuICAnLCc6IDE4OCxcbiAgJy0nOiAxODksXG4gICcuJzogMTkwLFxuICAnLyc6IDE5MSxcbiAgJ2AnOiAxOTIsXG4gICdbJzogMjE5LFxuICAnXFxcXCc6IDIyMCxcbiAgJ10nOiAyMjEsXG4gIFwiJ1wiOiAyMjJcbn07XG5cbi8vIEhlbHBlciBhbGlhc2VzXG5cbnZhciBhbGlhc2VzID0gZXhwb3J0cy5hbGlhc2VzID0ge1xuICAnd2luZG93cyc6IDkxLFxuICAn4oenJzogMTYsXG4gICfijKUnOiAxOCxcbiAgJ+KMgyc6IDE3LFxuICAn4oyYJzogOTEsXG4gICdjdGwnOiAxNyxcbiAgJ2NvbnRyb2wnOiAxNyxcbiAgJ29wdGlvbic6IDE4LFxuICAncGF1c2UnOiAxOSxcbiAgJ2JyZWFrJzogMTksXG4gICdjYXBzJzogMjAsXG4gICdyZXR1cm4nOiAxMyxcbiAgJ2VzY2FwZSc6IDI3LFxuICAnc3BjJzogMzIsXG4gICdzcGFjZWJhcic6IDMyLFxuICAncGd1cCc6IDMzLFxuICAncGdkbic6IDM0LFxuICAnaW5zJzogNDUsXG4gICdkZWwnOiA0NixcbiAgJ2NtZCc6IDkxXG59O1xuXG4vKiFcbiAqIFByb2dyYW1hdGljYWxseSBhZGQgdGhlIGZvbGxvd2luZ1xuICovXG5cbi8vIGxvd2VyIGNhc2UgY2hhcnNcbmZvciAoaSA9IDk3OyBpIDwgMTIzOyBpKyspIGNvZGVzW1N0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaSAtIDMyO1xuXG4vLyBudW1iZXJzXG5mb3IgKHZhciBpID0gNDg7IGkgPCA1ODsgaSsrKSBjb2Rlc1tpIC0gNDhdID0gaTtcblxuLy8gZnVuY3Rpb24ga2V5c1xuZm9yIChpID0gMTsgaSA8IDEzOyBpKyspIGNvZGVzWydmJytpXSA9IGkgKyAxMTE7XG5cbi8vIG51bXBhZCBrZXlzXG5mb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgY29kZXNbJ251bXBhZCAnK2ldID0gaSArIDk2O1xuXG4vKipcbiAqIEdldCBieSBjb2RlXG4gKlxuICogICBleHBvcnRzLm5hbWVbMTNdIC8vID0+ICdFbnRlcidcbiAqL1xuXG52YXIgbmFtZXMgPSBleHBvcnRzLm5hbWVzID0gZXhwb3J0cy50aXRsZSA9IHt9OyAvLyB0aXRsZSBmb3IgYmFja3dhcmQgY29tcGF0XG5cbi8vIENyZWF0ZSByZXZlcnNlIG1hcHBpbmdcbmZvciAoaSBpbiBjb2RlcykgbmFtZXNbY29kZXNbaV1dID0gaTtcblxuLy8gQWRkIGFsaWFzZXNcbmZvciAodmFyIGFsaWFzIGluIGFsaWFzZXMpIHtcbiAgY29kZXNbYWxpYXNdID0gYWxpYXNlc1thbGlhc107XG59XG59KTtcbnZhciBrZXljb2RlXzEgPSBrZXljb2RlLmNvZGU7XG52YXIga2V5Y29kZV8yID0ga2V5Y29kZS5jb2RlcztcbnZhciBrZXljb2RlXzMgPSBrZXljb2RlLmFsaWFzZXM7XG52YXIga2V5Y29kZV80ID0ga2V5Y29kZS5uYW1lcztcbnZhciBrZXljb2RlXzUgPSBrZXljb2RlLnRpdGxlO1xuXG52YXIgY29kZURhdGEgPSB7XG4gIFwiK1wiOiBcInBsdXNcIixcbiAgXCJsZWZ0IGNvbW1hbmRcIjogXCJtZXRhXCIsXG4gIFwicmlnaHQgY29tbWFuZFwiOiBcIm1ldGFcIlxufTtcbnZhciBrZXlzU29ydCA9IHtcbiAgc2hpZnQ6IDEsXG4gIGN0cmw6IDIsXG4gIGFsdDogMyxcbiAgbWV0YTogNFxufTtcbi8qKlxuICogQG1lbWJlcm9mIEtleUNvbnRyb2xsZXJcbiAqL1xuXG5mdW5jdGlvbiBnZXRLZXkoa2V5Q29kZSkge1xuICB2YXIga2V5ID0ga2V5Y29kZV80W2tleUNvZGVdIHx8IFwiXCI7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBjb2RlRGF0YSkge1xuICAgIGtleSA9IGtleS5yZXBsYWNlKG5hbWUsIGNvZGVEYXRhW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBrZXkucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xufVxuLyoqXG4gKiBAbWVtYmVyb2YgS2V5Q29udHJvbGxlclxuICovXG5cbmZ1bmN0aW9uIGdldENvbWJpKGUsIGtleSkge1xuICBpZiAoa2V5ID09PSB2b2lkIDApIHtcbiAgICBrZXkgPSBnZXRLZXkoZS5rZXlDb2RlKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gZ2V0TW9kaWZpZXJDb21iaShlKTtcbiAga2V5cy5pbmRleE9mKGtleSkgPT09IC0xICYmIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cy5maWx0ZXIoQm9vbGVhbik7XG59XG4vKipcbiAqIEBtZW1iZXJvZiBLZXlDb250cm9sbGVyXG4gKi9cblxuZnVuY3Rpb24gZ2V0TW9kaWZpZXJDb21iaShlKSB7XG4gIHZhciBrZXlzID0gW2Uuc2hpZnRLZXkgJiYgXCJzaGlmdFwiLCBlLmN0cmxLZXkgJiYgXCJjdHJsXCIsIGUuYWx0S2V5ICYmIFwiYWx0XCIsIGUubWV0YUtleSAmJiBcIm1ldGFcIl07XG4gIHJldHVybiBrZXlzLmZpbHRlcihCb29sZWFuKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYW5nZUNvbWJpKGtleXMpIHtcbiAgdmFyIGFycmFuZ2VLZXlzID0ga2V5cy5zbGljZSgpO1xuICBhcnJhbmdlS2V5cy5zb3J0KGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgdmFyIHByZXZTY29yZSA9IGtleXNTb3J0W3ByZXZdIHx8IDU7XG4gICAgdmFyIG5leHRTY29yZSA9IGtleXNTb3J0W25leHRdIHx8IDU7XG4gICAgcmV0dXJuIHByZXZTY29yZSAtIG5leHRTY29yZTtcbiAgfSk7XG4gIHJldHVybiBhcnJhbmdlS2V5cztcbn1cblxudmFyIGdsb2JhbEtleUNvbnRyb2xsZXI7XG4vKipcbiAqL1xuXG52YXIgS2V5Q29udHJvbGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhLZXlDb250cm9sbGVyLCBfc3VwZXIpO1xuICAvKipcbiAgICpcbiAgICovXG5cblxuICBmdW5jdGlvbiBLZXlDb250cm9sbGVyKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgICAgY29udGFpbmVyID0gd2luZG93O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgLyoqXG4gICAgICovXG5cbiAgICBfdGhpcy5jdHJsS2V5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICovXG5cbiAgICBfdGhpcy5hbHRLZXkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuXG4gICAgX3RoaXMuc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuXG4gICAgX3RoaXMubWV0YUtleSA9IGZhbHNlO1xuXG4gICAgX3RoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jdHJsS2V5ID0gZmFsc2U7XG4gICAgICBfdGhpcy5hbHRLZXkgPSBmYWxzZTtcbiAgICAgIF90aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgICBfdGhpcy5tZXRhS2V5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIF90aGlzLmtleWRvd25FdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy50cmlnZ2VyRXZlbnQoXCJrZXlkb3duXCIsIGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5rZXl1cEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLnRyaWdnZXJFdmVudChcImtleXVwXCIsIGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcblxuICAgICAgX3RoaXMudHJpZ2dlcihcImJsdXJcIik7XG4gICAgfTtcblxuICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJibHVyXCIsIF90aGlzLmJsdXIpO1xuICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJrZXlkb3duXCIsIF90aGlzLmtleWRvd25FdmVudCk7XG4gICAgYWRkRXZlbnQoY29udGFpbmVyLCBcImtleXVwXCIsIF90aGlzLmtleXVwRXZlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gS2V5Q29udHJvbGxlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLZXlDb250cm9sbGVyLCBcImdsb2JhbFwiLCB7XG4gICAgLyoqXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsS2V5Q29udHJvbGxlciB8fCAoZ2xvYmFsS2V5Q29udHJvbGxlciA9IG5ldyBLZXlDb250cm9sbGVyKCkpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIEtleUNvbnRyb2xsZXIuc2V0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbDtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5vZmYoKTtcbiAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwiYmx1clwiLCB0aGlzLmJsdXIpO1xuICAgIHJlbW92ZUV2ZW50KGNvbnRhaW5lciwgXCJrZXlkb3duXCIsIHRoaXMua2V5ZG93bkV2ZW50KTtcbiAgICByZW1vdmVFdmVudChjb250YWluZXIsIFwia2V5dXBcIiwgdGhpcy5rZXl1cEV2ZW50KTtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5rZXlkb3duID0gZnVuY3Rpb24gKGNvbWIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkRXZlbnQoXCJrZXlkb3duXCIsIGNvbWIsIGNhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5vZmZLZXlkb3duID0gZnVuY3Rpb24gKGNvbWIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlRXZlbnQoXCJrZXlkb3duXCIsIGNvbWIsIGNhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX19wcm90by5vZmZLZXl1cCA9IGZ1bmN0aW9uIChjb21iLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUV2ZW50KFwia2V5dXBcIiwgY29tYiwgY2FsbGJhY2spO1xuICB9O1xuICAvKipcbiAgICpcbiAgICovXG5cblxuICBfX3Byb3RvLmtleXVwID0gZnVuY3Rpb24gKGNvbWIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkRXZlbnQoXCJrZXl1cFwiLCBjb21iLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX19wcm90by5hZGRFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb21iLCBjYWxsYmFjaykge1xuICAgIGlmIChpc0FycmF5KGNvbWIpKSB7XG4gICAgICB0aGlzLm9uKHR5cGUgKyBcIi5cIiArIGdldEFycmFuZ2VDb21iaShjb21iKS5qb2luKFwiLlwiKSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29tYikpIHtcbiAgICAgIHRoaXMub24odHlwZSArIFwiLlwiICsgY29tYiwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKHR5cGUsIGNvbWIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwgY29tYiwgY2FsbGJhY2spIHtcbiAgICBpZiAoaXNBcnJheShjb21iKSkge1xuICAgICAgdGhpcy5vZmYodHlwZSArIFwiLlwiICsgZ2V0QXJyYW5nZUNvbWJpKGNvbWIpLmpvaW4oXCIuXCIpLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhjb21iKSkge1xuICAgICAgdGhpcy5vZmYodHlwZSArIFwiLlwiICsgY29tYiwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9mZih0eXBlLCBjb21iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgdGhpcy5jdHJsS2V5ID0gZS5jdHJsS2V5O1xuICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgIHRoaXMuYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgdGhpcy5tZXRhS2V5ID0gZS5tZXRhS2V5O1xuICAgIHZhciBrZXkgPSBnZXRLZXkoZS5rZXlDb2RlKTtcbiAgICB2YXIgaXNUb2dnbGUgPSBrZXkgPT09IFwiY3RybFwiIHx8IGtleSA9PT0gXCJzaGlmdFwiIHx8IGtleSA9PT0gXCJtZXRhXCIgfHwga2V5ID09PSBcImFsdFwiO1xuICAgIHZhciBwYXJhbSA9IHtcbiAgICAgIGtleToga2V5LFxuICAgICAgaXNUb2dnbGU6IGlzVG9nZ2xlLFxuICAgICAgaW5wdXRFdmVudDogZSxcbiAgICAgIGtleUNvZGU6IGUua2V5Q29kZSxcbiAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgIGFsdEtleTogZS5hbHRLZXksXG4gICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgIG1ldGFLZXk6IGUubWV0YUtleVxuICAgIH07XG4gICAgdGhpcy50cmlnZ2VyKHR5cGUsIHBhcmFtKTtcbiAgICB0aGlzLnRyaWdnZXIodHlwZSArIFwiLlwiICsga2V5LCBwYXJhbSk7XG4gICAgdmFyIGNvbWJpID0gZ2V0Q29tYmkoZSwga2V5KTtcbiAgICBjb21iaS5sZW5ndGggPiAxICYmIHRoaXMudHJpZ2dlcih0eXBlICsgXCIuXCIgKyBjb21iaS5qb2luKFwiLlwiKSwgcGFyYW0pO1xuICB9O1xuXG4gIHJldHVybiBLZXlDb250cm9sbGVyO1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBLZXlDb250cm9sbGVyO1xuZXhwb3J0IHsgZ2V0Q29tYmksIGdldEtleSwgZ2V0TW9kaWZpZXJDb21iaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5Y29uLmVzbS5qcy5tYXBcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IG1vdmVhYmxlXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvbW92ZWFibGUuZ2l0XG52ZXJzaW9uOiAwLjI4LjBcbiovXG5pbXBvcnQgeyByZWYsIFByb3BlcnRpZXMgfSBmcm9tICdmcmFtZXdvcmstdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCBjcmVhdGVFbGVtZW50LCBDb21wb25lbnQsIHJlbmRlciB9IGZyb20gJ3JlYWN0LXNpbXBsZS1jb21wYXQnO1xuaW1wb3J0IE1vdmVhYmxlJDEsIHsgTU9WRUFCTEVfUFJPUFMsIE1PVkVBQkxFX01FVEhPRFMsIE1PVkVBQkxFX0VWRU5UUywgTU9WRUFCTEVfUFJPUFNfTUFQLCBnZXRFbGVtZW50SW5mbyBhcyBnZXRFbGVtZW50SW5mbyQxLCBtYWtlQWJsZSBhcyBtYWtlQWJsZSQxIH0gZnJvbSAncmVhY3QtY29tcGF0LW1vdmVhYmxlJztcbmltcG9ydCB7IGlzT2JqZWN0LCBmaW5kSW5kZXgsIGNhbWVsaXplLCBpc0FycmF5IH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cblxudmFyIElubmVyTW92ZWFibGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoSW5uZXJNb3ZlYWJsZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBJbm5lck1vdmVhYmxlKHByb3BzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgIF90aGlzLnN0YXRlID0gX3RoaXMucHJvcHM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBJbm5lck1vdmVhYmxlLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNyZWF0ZUVsZW1lbnQoTW92ZWFibGUkMSwgX19hc3NpZ24oe1xuICAgICAgcmVmOiByZWYodGhpcywgXCJtb3ZlYWJsZVwiKVxuICAgIH0sIHRoaXMuc3RhdGUpKSwgdGhpcy5zdGF0ZS5wYXJlbnRFbGVtZW50KTtcbiAgfTtcblxuICByZXR1cm4gSW5uZXJNb3ZlYWJsZTtcbn0oQ29tcG9uZW50KTtcblxudmFyIFBST1BFUlRJRVMgPSBNT1ZFQUJMRV9QUk9QUztcbnZhciBNRVRIT0RTID0gTU9WRUFCTEVfTUVUSE9EUztcbnZhciBFVkVOVFMgPSBNT1ZFQUJMRV9FVkVOVFM7XG52YXIgUFJPUFNfTUFQID0gTU9WRUFCTEVfUFJPUFNfTUFQO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiBAc2NlbmEvZXZlbnQtZW1pdHRlclxubGljZW5zZTogTUlUXG5hdXRob3I6IERheWJydXNoXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL2RheWJydXNoL2dlc3R1cmUuZ2l0XG52ZXJzaW9uOiAxLjAuM1xuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbnZhciBfX2Fzc2lnbiQxID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiQxID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbiQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEltcGxlbWVudCBFdmVudEVtaXR0ZXIgb24gb2JqZWN0IG9yIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgcmVnaXN0ZXJlZCBldmVudC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIC0gbGlzdGVuZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGFkZGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIEFkZCBsaXN0ZW5lciBpbiBcImFcIiBldmVudFxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCAoKSA9PiB7XG4gICAqIH0pO1xuICAgKiAvLyBBZGQgbGlzdGVuZXJzXG4gICAqIGVtaXR0ZXIub24oe1xuICAgKiAgYTogKCkgPT4ge30sXG4gICAqICBiOiAoKSA9PiB7fSxcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8ub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChpc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9uKG5hbWUsIGV2ZW50TmFtZVtuYW1lXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgbGlzdGVuZXIsIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBpbiB0aGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gLSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAqIEBwYXJhbSAtIGxpc3RlbmVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICAqIGNvc250IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAqXG4gICAqIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzLlxuICAgKiBlbWl0dGVyLm9mZigpO1xuICAgKlxuICAgKiAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBcIkFcIiBldmVudC5cbiAgICogZW1pdHRlci5vZmYoXCJhXCIpO1xuICAgKlxuICAgKlxuICAgKiAvLyBSZW1vdmUgXCJsaXN0ZW5lclwiIGxpc3RlbmVyIGluIFwiYVwiIGV2ZW50LlxuICAgKiBlbWl0dGVyLm9mZihcImFcIiwgbGlzdGVuZXIpO1xuICAgKi9cblxuXG4gIF9fcHJvdG8ub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChldmVudE5hbWUpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9mZihuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleChldmVudHMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUubGlzdGVuZXIgPT09IGxpc3RlbmVyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBBZGQgYSBkaXNwb3NhYmxlIGxpc3RlbmVyIGFuZCBVc2UgcHJvbWlzZSB0byB0aGUgcmVnaXN0ZXJlZCBldmVudC5cbiAgICogQHBhcmFtIC0gTmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQHBhcmFtIC0gZGlzcG9zYWJsZSBsaXN0ZW5lciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYWRkZWRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICogY29zbnQgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogLy8gQWRkIGEgZGlzcG9zYWJsZSBsaXN0ZW5lciBpbiBcImFcIiBldmVudFxuICAgKiBlbWl0dGVyLm9uY2UoXCJhXCIsICgpID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIFVzZSBQcm9taXNlXG4gICAqIGVtaXR0ZXIub25jZShcImFcIikudGhlbihlID0+IHtcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudChldmVudE5hbWUsIGxpc3RlbmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3RoaXMuX2FkZEV2ZW50KGV2ZW50TmFtZSwgcmVzb2x2ZSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEZpcmVzIGFuIGV2ZW50IHRvIGNhbGwgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSAtIEV2ZW50IHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIElmIGZhbHNlLCBzdG9wIHRoZSBldmVudC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiQHNjZW5hL2V2ZW50LWVtaXR0ZXJcIjtcbiAgICpcbiAgICpcbiAgICogY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICpcbiAgICogZW1pdHRlci5vbihcImFcIiwgZSA9PiB7XG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBlbWl0dGVyLmVtaXQoXCJhXCIsIHtcbiAgICogICBhOiAxLFxuICAgKiB9KTtcbiAgICovXG5cblxuICBfX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG5cbiAgICBpZiAoIWV2ZW50TmFtZSB8fCAhZXZlbnRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdG9wID0gZmFsc2U7XG4gICAgcGFyYW0uZXZlbnRUeXBlID0gZXZlbnROYW1lO1xuXG4gICAgcGFyYW0uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzU3RvcCA9IHRydWU7XG4gICAgfTtcblxuICAgIHBhcmFtLmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXG4gICAgX19zcHJlYWRBcnJheXMoZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBpbmZvLmxpc3RlbmVyKHBhcmFtKTtcblxuICAgICAgaWYgKGluZm8ub25jZSkge1xuICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBpbmZvLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAhaXNTdG9wO1xuICB9O1xuICAvKipcbiAgICogRmlyZXMgYW4gZXZlbnQgdG8gY2FsbCBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSAtIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4gSWYgZmFsc2UsIHN0b3AgdGhlIGV2ZW50LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJAc2NlbmEvZXZlbnQtZW1pdHRlclwiO1xuICAgKlxuICAgKlxuICAgKiBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgKlxuICAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIGVtaXR0ZXIuZW1pdChcImFcIiwge1xuICAgKiAgIGE6IDEsXG4gICAqIH0pO1xuICAgKi9cblxuICAvKipcbiAgKiBGaXJlcyBhbiBldmVudCB0byBjYWxsIGxpc3RlbmVycy5cbiAgKiBAcGFyYW0gLSBFdmVudCBuYW1lXG4gICogQHBhcmFtIC0gRXZlbnQgcGFyYW1ldGVyXG4gICogQHJldHVybiBJZiBmYWxzZSwgc3RvcCB0aGUgZXZlbnQuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIGltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIkBzY2VuYS9ldmVudC1lbWl0dGVyXCI7XG4gICpcbiAgKlxuICAqIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICpcbiAgKiBlbWl0dGVyLm9uKFwiYVwiLCBlID0+IHtcbiAgKiB9KTtcbiAgKlxuICAqIC8vIGVtaXRcbiAgKiBlbWl0dGVyLnRyaWdnZXIoXCJhXCIsIHtcbiAgKiAgIGE6IDEsXG4gICogfSk7XG4gICovXG5cblxuICBfX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgIGlmIChwYXJhbSA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJhbSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnROYW1lLCBwYXJhbSk7XG4gIH07XG5cbiAgX19wcm90by5fYWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgZXZlbnRzW2V2ZW50TmFtZV0gPSBldmVudHNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgbGlzdGVuZXJzLnB1c2goX19hc3NpZ24kMSh7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICB9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKTtcblxuLyoqXG4gKiBNb3ZlYWJsZSBpcyBEcmFnZ2FibGUhIFJlc2l6YWJsZSEgU2NhbGFibGUhIFJvdGF0YWJsZSFcbiAqIEBzb3J0IDFcbiAqIEBhbGlhcyBNb3ZlYWJsZVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cblxudmFyIE1vdmVhYmxlTWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNb3ZlYWJsZU1hbmFnZXIsIF9zdXBlcik7XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlTWFuYWdlcihwYXJlbnRFbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy50ZW1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICB2YXIgbmV4dE9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgZXZlbnRzID0ge307XG4gICAgRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGV2ZW50c1tjYW1lbGl6ZShcIm9uIFwiICsgbmFtZSldID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnRyaWdnZXIobmFtZSwgZSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJlbmRlcihjcmVhdGVFbGVtZW50KElubmVyTW92ZWFibGUsIF9fYXNzaWduKHtcbiAgICAgIHJlZjogcmVmKF90aGlzLCBcImlubmVyTW92ZWFibGVcIiksXG4gICAgICBwYXJlbnRFbGVtZW50OiBwYXJlbnRFbGVtZW50XG4gICAgfSwgbmV4dE9wdGlvbnMsIGV2ZW50cykpLCBfdGhpcy50ZW1wRWxlbWVudCk7XG4gICAgdmFyIHRhcmdldCA9IG5leHRPcHRpb25zLnRhcmdldDtcblxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgdGFyZ2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIF90aGlzLnVwZGF0ZVJlY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmlubmVyTW92ZWFibGUuc2V0U3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVuZGVyKG51bGwsIHRoaXMudGVtcEVsZW1lbnQpO1xuICAgIHRoaXMub2ZmKCk7XG4gICAgdGhpcy50ZW1wRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5pbm5lck1vdmVhYmxlID0gbnVsbDtcbiAgfTtcblxuICBfX3Byb3RvLmdldE1vdmVhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlubmVyTW92ZWFibGUubW92ZWFibGU7XG4gIH07XG5cbiAgTW92ZWFibGVNYW5hZ2VyID0gX19kZWNvcmF0ZShbUHJvcGVydGllcyhNRVRIT0RTLCBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0eSkge1xuICAgIGlmIChwcm90b3R5cGVbcHJvcGVydHldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJvdG90eXBlW3Byb3BlcnR5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSB0aGlzLmdldE1vdmVhYmxlKCk7XG5cbiAgICAgIGlmICghc2VsZiB8fCAhc2VsZltwcm9wZXJ0eV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZltwcm9wZXJ0eV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfTtcbiAgfSksIFByb3BlcnRpZXMoUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwcm9wZXJ0eSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vdmVhYmxlKCkucHJvcHNbcHJvcGVydHldO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKChfYSA9IHt9LCBfYVtwcm9wZXJ0eV0gPSB2YWx1ZSwgX2EpKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pXSwgTW92ZWFibGVNYW5hZ2VyKTtcbiAgcmV0dXJuIE1vdmVhYmxlTWFuYWdlcjtcbn0oRXZlbnRFbWl0dGVyKTtcblxudmFyIE1vdmVhYmxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1vdmVhYmxlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE1vdmVhYmxlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBNb3ZlYWJsZTtcbn0oTW92ZWFibGVNYW5hZ2VyKTtcblxuZnVuY3Rpb24gZ2V0RWxlbWVudEluZm8odGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIpIHtcbiAgcmV0dXJuIGdldEVsZW1lbnRJbmZvJDEodGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIpO1xufVxuZnVuY3Rpb24gbWFrZUFibGUobmFtZSwgYWJsZSkge1xuICByZXR1cm4gbWFrZUFibGUkMShuYW1lLCBhYmxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTW92ZWFibGU7XG5leHBvcnQgeyBFVkVOVFMsIE1FVEhPRFMsIFBST1BFUlRJRVMsIFBST1BTX01BUCwgZ2V0RWxlbWVudEluZm8sIG1ha2VBYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3ZlYWJsZS5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDIwIERheWJydXNoXG5uYW1lOiBvdmVybGFwLWFyZWFcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9vdmVybGFwLWFyZWEuZ2l0XG52ZXJzaW9uOiAxLjAuMFxuKi9cbmltcG9ydCB7IHN1bSwgZmluZEluZGV4LCBnZXRTaGFwZURpcmVjdGlvbiwgZ2V0RGlzdCB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykgcltrXSA9IGFbal07XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogQG5hbWVzcGFjZSBPdmVybGFwQXJlYVxuICovXG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIHNoYXBlIChwb2x5Z29uKSBtYWRlIG9mIHBvaW50cy5cbiAqIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuICovXG5cbmZ1bmN0aW9uIGdldEFyZWFTaXplKHBvaW50cykge1xuICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBNYXRoLmFicyhzdW0ocG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQsIGkpIHtcbiAgICB2YXIgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXSB8fCBwb2ludHNbMF07XG4gICAgcmV0dXJuIHBvaW50WzBdICogbmV4dFBvaW50WzFdIC0gbmV4dFBvaW50WzBdICogcG9pbnRbMV07XG4gIH0pKSkgLyAyO1xufVxuLyoqXG4gKiBHZXQgcG9pbnRzIHRoYXQgZml0IHRoZSByZWN0LFxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZml0UG9pbnRzKHBvaW50cywgcmVjdCkge1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQsXG4gICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgdG9wID0gcmVjdC50b3A7XG5cbiAgdmFyIF9hID0gZ2V0TWluTWF4cyhwb2ludHMpLFxuICAgICAgbWluWCA9IF9hLm1pblgsXG4gICAgICBtaW5ZID0gX2EubWluWSxcbiAgICAgIG1heFggPSBfYS5tYXhYLFxuICAgICAgbWF4WSA9IF9hLm1heFk7XG5cbiAgdmFyIHJhdGlvWCA9IHdpZHRoIC8gKG1heFggLSBtaW5YKTtcbiAgdmFyIHJhdGlvWSA9IGhlaWdodCAvIChtYXhZIC0gbWluWSk7XG4gIHJldHVybiBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBbbGVmdCArIChwb2ludFswXSAtIG1pblgpICogcmF0aW9YLCB0b3AgKyAocG9pbnRbMV0gLSBtaW5ZKSAqIHJhdGlvWV07XG4gIH0pO1xufVxuLyoqXG4gKiBHZXQgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gcG9pbnRzIG9mIHRoZSBwb2ludHMuXG4gKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiAqL1xuXG5mdW5jdGlvbiBnZXRNaW5NYXhzKHBvaW50cykge1xuICB2YXIgeHMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBwb2ludFswXTtcbiAgfSk7XG4gIHZhciB5cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcmV0dXJuIHBvaW50WzFdO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBtaW5YOiBNYXRoLm1pbi5hcHBseShNYXRoLCB4cyksXG4gICAgbWluWTogTWF0aC5taW4uYXBwbHkoTWF0aCwgeXMpLFxuICAgIG1heFg6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHhzKSxcbiAgICBtYXhZOiBNYXRoLm1heC5hcHBseShNYXRoLCB5cylcbiAgfTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgcG9pbnQgaXMgaW4gc2hhcGVcbiAqIEBwYXJhbSAtIHBvaW50IHBvc1xuICogQHBhcmFtIC0gc2hhcGUgcG9pbnRzXG4gKiBAcGFyYW0gLSB3aGV0aGVyIHRvIGNoZWNrIGV4Y2VwdCBsaW5lXG4gKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiAqL1xuXG5mdW5jdGlvbiBpc0luc2lkZShwb3MsIHBvaW50cywgZXhjbHVkZUxpbmUpIHtcbiAgdmFyIHggPSBwb3NbMF0sXG4gICAgICB5ID0gcG9zWzFdO1xuXG4gIHZhciBfYSA9IGdldE1pbk1heHMocG9pbnRzKSxcbiAgICAgIG1pblggPSBfYS5taW5YLFxuICAgICAgbWluWSA9IF9hLm1pblksXG4gICAgICBtYXhYID0gX2EubWF4WCxcbiAgICAgIG1heFkgPSBfYS5tYXhZO1xuXG4gIHZhciB4TGluZSA9IFtbbWluWCwgeV0sIFttYXhYLCB5XV07XG4gIHZhciB5TGluZSA9IFtbeCwgbWluWV0sIFt4LCBtYXhZXV07XG4gIHZhciB4TGluZWFyQ29uc3RhbnRzID0gZ2V0TGluZWFyQ29uc3RhbnRzKHhMaW5lWzBdLCB4TGluZVsxXSk7XG4gIHZhciB5TGluZWFyQ29uc3RhbnRzID0gZ2V0TGluZWFyQ29uc3RhbnRzKHlMaW5lWzBdLCB5TGluZVsxXSk7XG4gIHZhciBsaW5lcyA9IGNvbnZlcnRMaW5lcyhwb2ludHMpO1xuICB2YXIgaW50ZXJzZWN0aW9uWFBvaW50cyA9IFtdO1xuICB2YXIgaW50ZXJzZWN0aW9uWVBvaW50cyA9IFtdO1xuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgdmFyIGxpbmVhckNvbnN0YW50cyA9IGdldExpbmVhckNvbnN0YW50cyhsaW5lWzBdLCBsaW5lWzFdKTtcbiAgICB2YXIgeFBvaW50cyA9IGdldFBvaW50c09uTGluZXMoZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMoeExpbmVhckNvbnN0YW50cywgbGluZWFyQ29uc3RhbnRzKSwgW3hMaW5lLCBsaW5lXSk7XG4gICAgdmFyIHlQb2ludHMgPSBnZXRQb2ludHNPbkxpbmVzKGdldEludGVyc2VjdGlvblBvaW50c0J5Q29uc3RhbnRzKHlMaW5lYXJDb25zdGFudHMsIGxpbmVhckNvbnN0YW50cyksIFt5TGluZSwgbGluZV0pO1xuXG4gICAgaWYgKHhQb2ludHMubGVuZ3RoID09PSAxID8gbGluZVswXVsxXSAhPT0geSA6IHRydWUpIHtcbiAgICAgIGludGVyc2VjdGlvblhQb2ludHMucHVzaC5hcHBseShpbnRlcnNlY3Rpb25YUG9pbnRzLCB4UG9pbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoeVBvaW50cy5sZW5ndGggPT09IDEgPyBsaW5lWzBdWzBdICE9PSB4IDogdHJ1ZSkge1xuICAgICAgaW50ZXJzZWN0aW9uWVBvaW50cy5wdXNoLmFwcGx5KGludGVyc2VjdGlvbllQb2ludHMsIHlQb2ludHMpO1xuICAgIH1cblxuICAgIGlmICghbGluZWFyQ29uc3RhbnRzWzBdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25YUG9pbnRzLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9uWFBvaW50cywgeFBvaW50cyk7XG4gICAgfVxuXG4gICAgaWYgKCFsaW5lYXJDb25zdGFudHNbMV0pIHtcbiAgICAgIGludGVyc2VjdGlvbllQb2ludHMucHVzaC5hcHBseShpbnRlcnNlY3Rpb25ZUG9pbnRzLCB5UG9pbnRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghZXhjbHVkZUxpbmUpIHtcbiAgICBpZiAoZmluZEluZGV4KGludGVyc2VjdGlvblhQb2ludHMsIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcFswXSA9PT0geDtcbiAgICB9KSA+IC0xIHx8IGZpbmRJbmRleChpbnRlcnNlY3Rpb25ZUG9pbnRzLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHBbMV0gPT09IHk7XG4gICAgfSkgPiAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGludGVyc2VjdGlvblhQb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHBbMF0gPiB4O1xuICB9KS5sZW5ndGggJSAyICYmIGludGVyc2VjdGlvbllQb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHBbMV0gPiB5O1xuICB9KS5sZW5ndGggJSAyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEdldCB0aGUgY29lZmZpY2llbnQgb2YgdGhlIGxpbmVhciBmdW5jdGlvbi4gW2EsIGIsIGNdIChheCArIGJ5ICsgYyA9IDApXG4gKiBAcmV0dXJuIFthLCBiLCBjXVxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZ2V0TGluZWFyQ29uc3RhbnRzKHBvaW50MSwgcG9pbnQyKSB7XG4gIHZhciB4MSA9IHBvaW50MVswXSxcbiAgICAgIHkxID0gcG9pbnQxWzFdO1xuICB2YXIgeDIgPSBwb2ludDJbMF0sXG4gICAgICB5MiA9IHBvaW50MlsxXTsgLy8gYXggKyBieSArIGMgPSAwXG5cbiAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG5cbiAgaWYgKHgxID09PSB4Mikge1xuICAgIC8vIHggPSB4MVxuICAgIHJldHVybiBbMSwgMCwgLXgxXTtcbiAgfSBlbHNlIGlmICh5MSA9PT0geTIpIHtcbiAgICAvLyB5ID0geTFcbiAgICByZXR1cm4gWzAsIDEsIC15MV07XG4gIH0gZWxzZSB7XG4gICAgLy8geDEgKyBhICogeTEgKyBiID0gMFxuICAgIC8vIHgyICsgYSAqIHkyICsgYiA9IDBcbiAgICAvLyAoeDEgLXgyKSArICh5MSAtIHkyKSAqIGEgPSAwXG4gICAgLy8gYSA9ICh4MiAtIHgxKSAvICh5MSAtIHkyKVxuICAgIC8vIHgxICsgKHgyIC0geDEpIC8gKHkxIC0geTIpXG4gICAgdmFyIGFfMSA9ICh4MiAtIHgxKSAvICh5MSAtIHkyKTtcbiAgICB2YXIgYl8xID0gLXgxIC0gYV8xICogeTE7XG4gICAgcmV0dXJuIFsxLCBhXzEsIGJfMV07XG4gIH1cbn1cbi8qKlxuICogR2V0IGludGVyc2VjdGlvbiBwb2ludHMgd2l0aCBsaW5lYXIgZnVuY3Rpb25zLlxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMobGluZWFyQ29uc3RhbnRzMSwgbGluZWFyQ29uc3RhbnRzMikge1xuICB2YXIgYTEgPSBsaW5lYXJDb25zdGFudHMxWzBdLFxuICAgICAgYjEgPSBsaW5lYXJDb25zdGFudHMxWzFdLFxuICAgICAgYzEgPSBsaW5lYXJDb25zdGFudHMxWzJdO1xuICB2YXIgYTIgPSBsaW5lYXJDb25zdGFudHMyWzBdLFxuICAgICAgYjIgPSBsaW5lYXJDb25zdGFudHMyWzFdLFxuICAgICAgYzIgPSBsaW5lYXJDb25zdGFudHMyWzJdO1xuICB2YXIgaXNaZXJvQSA9IGExID09PSAwICYmIGEyID09PSAwO1xuICB2YXIgaXNaZXJvQiA9IGIxID09PSAwICYmIGIyID09PSAwO1xuXG4gIGlmIChpc1plcm9BICYmIGlzWmVyb0IpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSBpZiAoaXNaZXJvQSkge1xuICAgIC8vIGIxICogeSArIGMxID0gMFxuICAgIC8vIGIyICogeSArIGMyID0gMFxuICAgIHZhciB5MSA9IC1jMSAvIGIxO1xuICAgIHZhciB5MiA9IC1jMiAvIGIyO1xuXG4gICAgaWYgKHkxICE9PSB5Mikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1stSW5maW5pdHksIHkxXSwgW0luZmluaXR5LCB5MV1dO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1plcm9CKSB7XG4gICAgLy8gYTEgKiB4ICsgYzEgPSAwXG4gICAgLy8gYTIgKiB4ICsgYzIgPSAwXG4gICAgdmFyIHgxID0gLWMxIC8gYTE7XG4gICAgdmFyIHgyID0gLWMyIC8gYTI7XG5cbiAgICBpZiAoeDEgIT09IHgyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbW3gxLCAtSW5maW5pdHldLCBbeDEsIEluZmluaXR5XV07XG4gICAgfVxuICB9IGVsc2UgaWYgKGExID09PSAwKSB7XG4gICAgLy8gYjEgKiB5ICsgYzEgPSAwXG4gICAgLy8geSA9IC0gYzEgLyBiMTtcbiAgICAvLyBhMiAqIHggKyBiMiAqIHkgKyBjMiA9IDBcbiAgICB2YXIgeSA9IC1jMSAvIGIxO1xuICAgIHZhciB4ID0gLShiMiAqIHkgKyBjMikgLyBhMjtcbiAgICByZXR1cm4gW1t4LCB5XV07XG4gIH0gZWxzZSBpZiAoYTIgPT09IDApIHtcbiAgICAvLyBiMiAqIHkgKyBjMiA9IDBcbiAgICAvLyB5ID0gLSBjMiAvIGIyO1xuICAgIC8vIGExICogeCArIGIxICogeSArIGMxID0gMFxuICAgIHZhciB5ID0gLWMyIC8gYjI7XG4gICAgdmFyIHggPSAtKGIxICogeSArIGMxKSAvIGExO1xuICAgIHJldHVybiBbW3gsIHldXTtcbiAgfSBlbHNlIGlmIChiMSA9PT0gMCkge1xuICAgIC8vIGExICogeCArIGMxID0gMFxuICAgIC8vIHggPSAtIGMxIC8gYTE7XG4gICAgLy8gYTIgKiB4ICsgYjIgKiB5ICsgYzIgPSAwXG4gICAgdmFyIHggPSAtYzEgLyBhMTtcbiAgICB2YXIgeSA9IC0oYTIgKiB4ICsgYzIpIC8gYjI7XG4gICAgcmV0dXJuIFtbeCwgeV1dO1xuICB9IGVsc2UgaWYgKGIyID09PSAwKSB7XG4gICAgLy8gYTIgKiB4ICsgYzIgPSAwXG4gICAgLy8geCA9IC0gYzIgLyBhMjtcbiAgICAvLyBhMSAqIHggKyBiMSAqIHkgKyBjMSA9IDBcbiAgICB2YXIgeCA9IC1jMiAvIGEyO1xuICAgIHZhciB5ID0gLShhMSAqIHggKyBjMSkgLyBiMTtcbiAgICByZXR1cm4gW1t4LCB5XV07XG4gIH0gZWxzZSB7XG4gICAgLy8gYTEgKiB4ICsgYjEgKiB5ICsgYzEgPSAwXG4gICAgLy8gYTIgKiB4ICsgYjIgKiB5ICsgYzIgPSAwXG4gICAgLy8gYjIgKiBhMSAqIHggKyBiMiAqIGIxICogeSArIGIyICogYzEgPSAwXG4gICAgLy8gYjEgKiBhMiAqIHggKyBiMSAqIGIyICogeSArIGIxICogYzIgPSAwXG4gICAgLy8gKGIyICogYTEgLSBiMSAqIGEyKSAgKiB4ID0gKGIxICogYzIgLSBiMiAqIGMxKVxuICAgIHZhciB4ID0gKGIxICogYzIgLSBiMiAqIGMxKSAvIChiMiAqIGExIC0gYjEgKiBhMik7XG4gICAgdmFyIHkgPSAtKGExICogeCArIGMxKSAvIGIxO1xuICAgIHJldHVybiBbW3gsIHldXTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgaW50ZXJzZWN0aW9uIHBvaW50cyB0byB0aGUgdHdvIGxpbmVzLlxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnRzKGxpbmUxLCBsaW5lMiwgaXNMaW1pdCkge1xuICB2YXIgcG9pbnRzID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMoZ2V0TGluZWFyQ29uc3RhbnRzKGxpbmUxWzBdLCBsaW5lMVsxXSksIGdldExpbmVhckNvbnN0YW50cyhsaW5lMlswXSwgbGluZTJbMV0pKTtcblxuICBpZiAoaXNMaW1pdCkge1xuICAgIHJldHVybiBnZXRQb2ludHNPbkxpbmVzKHBvaW50cywgW2xpbmUxLCBsaW5lMl0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cbi8qKlxuICogR2V0IHRoZSBwb2ludHMgb24gdGhlIGxpbmVzIChiZXR3ZWVuIHR3byBwb2ludHMpLlxuICogQG1lbWJlcm9mIE92ZXJsYXBBcmVhXG4gKi9cblxuZnVuY3Rpb24gZ2V0UG9pbnRzT25MaW5lcyhwb2ludHMsIGxpbmVzKSB7XG4gIHZhciBtaW5NYXhzID0gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuIFswLCAxXS5tYXAoZnVuY3Rpb24gKG9yZGVyKSB7XG4gICAgICByZXR1cm4gW01hdGgubWluKGxpbmVbMF1bb3JkZXJdLCBsaW5lWzFdW29yZGVyXSksIE1hdGgubWF4KGxpbmVbMF1bb3JkZXJdLCBsaW5lWzFdW29yZGVyXSldO1xuICAgIH0pO1xuICB9KTtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBfYSA9IHBvaW50c1swXSxcbiAgICAgICAgeCA9IF9hWzBdLFxuICAgICAgICB5ID0gX2FbMV07XG5cbiAgICBpZiAoeCA9PT0gcG9pbnRzWzFdWzBdKSB7XG4gICAgICAvLy8gTWF0aC5tYXgobWluWTEsIG1pblkyKVxuICAgICAgdmFyIHRvcCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIG1pbk1heHMubWFwKGZ1bmN0aW9uIChtaW5NYXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbk1heFsxXVswXTtcbiAgICAgIH0pKTsgLy8vIE1hdGgubWluKG1heFkxLCBtaWF4MilcblxuICAgICAgdmFyIGJvdHRvbSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIG1pbk1heHMubWFwKGZ1bmN0aW9uIChtaW5NYXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbk1heFsxXVsxXTtcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKHRvcCA+IGJvdHRvbSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbW3gsIHRvcF0sIFt4LCBib3R0b21dXTtcbiAgICB9IGVsc2UgaWYgKHkgPT09IHBvaW50c1sxXVsxXSkge1xuICAgICAgLy8vIE1hdGgubWF4KG1pblkxLCBtaW5ZMilcbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgbWluTWF4cy5tYXAoZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgICByZXR1cm4gbWluTWF4WzBdWzBdO1xuICAgICAgfSkpOyAvLy8gTWF0aC5taW4obWF4WTEsIG1pYXgyKVxuXG4gICAgICB2YXIgcmlnaHQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBtaW5NYXhzLm1hcChmdW5jdGlvbiAobWluTWF4KSB7XG4gICAgICAgIHJldHVybiBtaW5NYXhbMF1bMV07XG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1tsZWZ0LCB5XSwgW3JpZ2h0LCB5XV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgcmV0dXJuIG1pbk1heHMuZXZlcnkoZnVuY3Rpb24gKG1pbk1heCkge1xuICAgICAgcmV0dXJuIG1pbk1heFswXVswXSA8PSBwb2ludFswXSAmJiBwb2ludFswXSA8PSBtaW5NYXhbMF1bMV0gJiYgbWluTWF4WzFdWzBdIDw9IHBvaW50WzFdICYmIHBvaW50WzFdIDw9IG1pbk1heFsxXVsxXTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiogQ29udmVydCB0d28gcG9pbnRzIGludG8gbGluZXMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiovXG5cbmZ1bmN0aW9uIGNvbnZlcnRMaW5lcyhwb2ludHMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKHBvaW50cy5zbGljZSgxKSwgW3BvaW50c1swXV0pLm1hcChmdW5jdGlvbiAocG9pbnQsIGkpIHtcbiAgICByZXR1cm4gW3BvaW50c1tpXSwgcG9pbnRdO1xuICB9KTtcbn1cbi8qKlxuKiBHZXQgdGhlIHBvaW50cyBvZiB0aGUgb3ZlcmxhcHBlZCBwYXJ0IG9mIHR3byBzaGFwZXMuXG4qIEBmdW5jdGlvblxuKiBAbWVtYmVyb2YgT3ZlcmxhcEFyZWFcbiovXG5cbmZ1bmN0aW9uIGdldE92ZXJsYXBQb2ludHMocG9pbnRzMSwgcG9pbnRzMikge1xuICB2YXIgdGFyZ2V0UG9pbnRzMSA9IHBvaW50czEuc2xpY2UoKTtcbiAgdmFyIHRhcmdldFBvaW50czIgPSBwb2ludHMyLnNsaWNlKCk7XG5cbiAgaWYgKGdldFNoYXBlRGlyZWN0aW9uKHRhcmdldFBvaW50czEpID09PSAtMSkge1xuICAgIHRhcmdldFBvaW50czEucmV2ZXJzZSgpO1xuICB9XG5cbiAgaWYgKGdldFNoYXBlRGlyZWN0aW9uKHRhcmdldFBvaW50czIpID09PSAtMSkge1xuICAgIHRhcmdldFBvaW50czIucmV2ZXJzZSgpO1xuICB9XG5cbiAgdmFyIGxpbmVzMSA9IGNvbnZlcnRMaW5lcyh0YXJnZXRQb2ludHMxKTtcbiAgdmFyIGxpbmVzMiA9IGNvbnZlcnRMaW5lcyh0YXJnZXRQb2ludHMyKTtcbiAgdmFyIGxpbmVhckNvbnN0YW50c3MxID0gbGluZXMxLm1hcChmdW5jdGlvbiAobGluZTEpIHtcbiAgICByZXR1cm4gZ2V0TGluZWFyQ29uc3RhbnRzKGxpbmUxWzBdLCBsaW5lMVsxXSk7XG4gIH0pO1xuICB2YXIgbGluZWFyQ29uc3RhbnRzczIgPSBsaW5lczIubWFwKGZ1bmN0aW9uIChsaW5lMikge1xuICAgIHJldHVybiBnZXRMaW5lYXJDb25zdGFudHMobGluZTJbMF0sIGxpbmUyWzFdKTtcbiAgfSk7XG4gIHZhciBvdmVybGFwSW5mb3MgPSBbXTtcbiAgbGluZWFyQ29uc3RhbnRzczEuZm9yRWFjaChmdW5jdGlvbiAobGluZWFyQ29uc3RhbnRzMSwgaSkge1xuICAgIHZhciBsaW5lMSA9IGxpbmVzMVtpXTtcbiAgICB2YXIgbGluZVBvaW50SW5mb3MgPSBbXTtcbiAgICBsaW5lYXJDb25zdGFudHNzMi5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lYXJDb25zdGFudHMyLCBqKSB7XG4gICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnRzID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMobGluZWFyQ29uc3RhbnRzMSwgbGluZWFyQ29uc3RhbnRzMik7XG4gICAgICB2YXIgcG9pbnRzID0gZ2V0UG9pbnRzT25MaW5lcyhpbnRlcnNlY3Rpb25Qb2ludHMsIFtsaW5lMSwgbGluZXMyW2pdXSk7XG4gICAgICBsaW5lUG9pbnRJbmZvcy5wdXNoLmFwcGx5KGxpbmVQb2ludEluZm9zLCBwb2ludHMubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRleDE6IGksXG4gICAgICAgICAgaW5kZXgyOiBqLFxuICAgICAgICAgIHBvczogcG9zXG4gICAgICAgIH07XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgbGluZVBvaW50SW5mb3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldERpc3QobGluZTFbMF0sIGEucG9zKSAtIGdldERpc3QobGluZTFbMF0sIGIucG9zKTtcbiAgICB9KTtcbiAgICBvdmVybGFwSW5mb3MucHVzaC5hcHBseShvdmVybGFwSW5mb3MsIGxpbmVQb2ludEluZm9zKTtcblxuICAgIGlmIChpc0luc2lkZShsaW5lMVsxXSwgdGFyZ2V0UG9pbnRzMikpIHtcbiAgICAgIG92ZXJsYXBJbmZvcy5wdXNoKHtcbiAgICAgICAgaW5kZXgxOiBpLFxuICAgICAgICBpbmRleDI6IC0xLFxuICAgICAgICBwb3M6IGxpbmUxWzFdXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBsaW5lczIuZm9yRWFjaChmdW5jdGlvbiAobGluZTIsIGkpIHtcbiAgICBpZiAoaXNJbnNpZGUobGluZTJbMV0sIHRhcmdldFBvaW50czEpKSB7XG4gICAgICB2YXIgaXNOZXh0XzEgPSBmYWxzZTtcbiAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleChvdmVybGFwSW5mb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaW5kZXgyID0gX2EuaW5kZXgyO1xuXG4gICAgICAgIGlmIChpbmRleDIgPT09IGkpIHtcbiAgICAgICAgICBpc05leHRfMSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmV4dF8xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpc05leHRfMSA9IGZhbHNlO1xuICAgICAgICBpbmRleCA9IGZpbmRJbmRleChvdmVybGFwSW5mb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHZhciBpbmRleDEgPSBfYS5pbmRleDEsXG4gICAgICAgICAgICAgIGluZGV4MiA9IF9hLmluZGV4MjtcblxuICAgICAgICAgIGlmIChpbmRleDEgPT09IC0xICYmIGluZGV4MiArIDEgPT09IGkpIHtcbiAgICAgICAgICAgIGlzTmV4dF8xID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNOZXh0XzEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgb3ZlcmxhcEluZm9zLnB1c2goe1xuICAgICAgICAgIGluZGV4MTogLTEsXG4gICAgICAgICAgaW5kZXgyOiBpLFxuICAgICAgICAgIHBvczogbGluZTJbMV1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdmVybGFwSW5mb3Muc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgICAgaW5kZXgxOiAtMSxcbiAgICAgICAgICBpbmRleDI6IGksXG4gICAgICAgICAgcG9zOiBsaW5lMlsxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBjb25zb2xlLmxvZyhvdmVybGFwSW5mb3MpO1xuXG4gIHZhciBvdmVybGFwUG9pbnRzID0gb3ZlcmxhcEluZm9zLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcG9zID0gX2EucG9zO1xuICAgIHJldHVybiBwb3M7XG4gIH0pO1xuICB2YXIgcG9pbnRNYXAgPSB7fTtcbiAgcmV0dXJuIG92ZXJsYXBQb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBrZXkgPSBwb2ludFswXSArIFwieFwiICsgcG9pbnRbMV07XG5cbiAgICBpZiAocG9pbnRNYXBba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHBvaW50TWFwW2tleV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbi8qKlxuKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBvdmVybGFwcGVkIHBhcnQgb2YgdHdvIHNoYXBlcy5cbiogQGZ1bmN0aW9uXG4qIEBtZW1iZXJvZiBPdmVybGFwQXJlYVxuKi9cblxuZnVuY3Rpb24gZ2V0T3ZlcmxhcFNpemUocG9pbnRzMSwgcG9pbnRzMikge1xuICB2YXIgcG9pbnRzID0gZ2V0T3ZlcmxhcFBvaW50cyhwb2ludHMxLCBwb2ludHMyKTtcbiAgcmV0dXJuIGdldEFyZWFTaXplKHBvaW50cyk7XG59XG5cbmV4cG9ydCB7IGNvbnZlcnRMaW5lcywgZml0UG9pbnRzLCBnZXRBcmVhU2l6ZSwgZ2V0SW50ZXJzZWN0aW9uUG9pbnRzLCBnZXRJbnRlcnNlY3Rpb25Qb2ludHNCeUNvbnN0YW50cywgZ2V0TGluZWFyQ29uc3RhbnRzLCBnZXRNaW5NYXhzLCBnZXRPdmVybGFwUG9pbnRzLCBnZXRPdmVybGFwU2l6ZSwgZ2V0UG9pbnRzT25MaW5lcywgaXNJbnNpZGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW92ZXJsYXAtYXJlYS5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSBEYXlicnVzaFxubmFtZTogcmVhY3QtY29tcGF0LWNzcy1zdHlsZWRcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBEYXlicnVzaFxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9jc3Mtc3R5bGVkLmdpdFxudmVyc2lvbjogMS4wLjhcbiovXG5pbXBvcnQgY3NzU3R5bGVkIGZyb20gJ2Nzcy1zdHlsZWQnO1xuaW1wb3J0IHsgdmVyc2lvbiwgY3JlYXRlRWxlbWVudCwgQ29tcG9uZW50IH0gZnJvbSAncmVhY3Qtc2ltcGxlLWNvbXBhdCc7XG5pbXBvcnQgeyByZWYgfSBmcm9tICdmcmFtZXdvcmstdXRpbHMnO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE5IERheWJydXNoXG5uYW1lOiByZWFjdC1jc3Mtc3R5bGVkXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9jc3Mtc3R5bGVkL3RyZWUvbWFzdGVyL3BhY2thZ2VzL3JlYWN0LWNzcy1zdHlsZWRcbnZlcnNpb246IDEuMC4zXG4qL1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcblxuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG5cbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxudmFyIFN0eWxlZEVsZW1lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU3R5bGVkRWxlbWVudCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTdHlsZWRFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuaW5qZWN0UmVzdWx0ID0gbnVsbDtcbiAgICBfdGhpcy50YWcgPSBcImRpdlwiO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gU3R5bGVkRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgX2IgPSBfYS5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzTmFtZSA9IF9iID09PSB2b2lkIDAgPyBcIlwiIDogX2IsXG4gICAgICAgIGNzcE5vbmNlID0gX2EuY3NwTm9uY2UsXG4gICAgICAgIHBvcnRhbENvbnRhaW5lciA9IF9hLnBvcnRhbENvbnRhaW5lcixcbiAgICAgICAgYXR0cmlidXRlcyA9IF9fcmVzdChfYSwgW1wiY2xhc3NOYW1lXCIsIFwiY3NwTm9uY2VcIiwgXCJwb3J0YWxDb250YWluZXJcIl0pO1xuXG4gICAgdmFyIGNzc0lkID0gdGhpcy5pbmplY3Rvci5jbGFzc05hbWU7XG4gICAgdmFyIFRhZyA9IHRoaXMudGFnO1xuICAgIHZhciBwb3J0YWxBdHRyaWJ1dGVzID0ge307XG5cbiAgICBpZiAoKHZlcnNpb24gfHwgXCJcIikuaW5kZXhPZihcInNpbXBsZVwiKSA+IC0xICYmIHBvcnRhbENvbnRhaW5lcikge1xuICAgICAgcG9ydGFsQXR0cmlidXRlcyA9IHtcbiAgICAgICAgcG9ydGFsQ29udGFpbmVyOiBwb3J0YWxDb250YWluZXJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVGFnLCBfX2Fzc2lnbih7XG4gICAgICBcInJlZlwiOiByZWYodGhpcywgXCJlbGVtZW50XCIpLFxuICAgICAgXCJkYXRhLXN0eWxlZC1pZFwiOiBjc3NJZCxcbiAgICAgIFwiY2xhc3NOYW1lXCI6IGNsYXNzTmFtZSArIFwiIFwiICsgY3NzSWRcbiAgICB9LCBwb3J0YWxBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKSk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmluamVjdFJlc3VsdCA9IHRoaXMuaW5qZWN0b3IuaW5qZWN0KHRoaXMuZWxlbWVudCwge1xuICAgICAgbm9uY2U6IHRoaXMucHJvcHMuY3NwTm9uY2VcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW5qZWN0UmVzdWx0LmRlc3Ryb3koKTtcbiAgICB0aGlzLmluamVjdFJlc3VsdCA9IG51bGw7XG4gIH07XG5cbiAgX19wcm90by5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlZEVsZW1lbnQ7XG59KENvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIHN0eWxlZCh0YWcsIGNzcykge1xuICB2YXIgaW5qZWN0b3IgPSBjc3NTdHlsZWQoY3NzKTtcbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzKFN0eWxlZCwgX3N1cGVyKTtcblxuICAgICAgZnVuY3Rpb24gU3R5bGVkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblxuICAgICAgICBfdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICBfdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFN0eWxlZDtcbiAgICB9KFN0eWxlZEVsZW1lbnQpXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlZDtcbmV4cG9ydCB7IFN0eWxlZEVsZW1lbnQgfTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIERheWJydXNoXG5uYW1lOiByZWFjdC1zaW1wbGUtY29tcGF0XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvcmVhY3Qtc2ltcGxlLWNvbXBhdC5naXRcbnZlcnNpb246IDEuMi4xXG4qL1xuaW1wb3J0IHsgZGlmZiB9IGZyb20gJ0BlZ2pzL2xpc3QtZGlmZmVyJztcbmltcG9ydCB7IGlzQXJyYXksIGlzU3RyaW5nLCBpc051bWJlciwgaXNVbmRlZmluZWQsIGRlY2FtZWxpemUgfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcblxuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG5cbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblxuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKSByW2tdID0gYVtqXTtcblxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gaXNEaWZmKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpIGluIGEpIHtcbiAgICBpZiAoIShpIGluIGIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkaWZmT2JqZWN0KGEsIGIpIHtcbiAgdmFyIGtleXMxID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKGIpO1xuICB2YXIgcmVzdWx0ID0gZGlmZihrZXlzMSwga2V5czIsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9KTtcbiAgdmFyIGFkZGVkID0ge307XG4gIHZhciByZW1vdmVkID0ge307XG4gIHZhciBjaGFuZ2VkID0ge307XG4gIHJlc3VsdC5hZGRlZC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBuYW1lID0ga2V5czJbaW5kZXhdO1xuICAgIGFkZGVkW25hbWVdID0gYltuYW1lXTtcbiAgfSk7XG4gIHJlc3VsdC5yZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIG5hbWUgPSBrZXlzMVtpbmRleF07XG4gICAgcmVtb3ZlZFtuYW1lXSA9IGFbbmFtZV07XG4gIH0pO1xuICByZXN1bHQubWFpbnRhaW5lZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBpbmRleCA9IF9hWzBdO1xuICAgIHZhciBuYW1lID0ga2V5czFbaW5kZXhdO1xuICAgIHZhciB2YWx1ZXMgPSBbYVtuYW1lXSwgYltuYW1lXV07XG5cbiAgICBpZiAoYVtuYW1lXSAhPT0gYltuYW1lXSkge1xuICAgICAgY2hhbmdlZFtuYW1lXSA9IHZhbHVlcztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGFkZGVkOiBhZGRlZCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIGNoYW5nZWQ6IGNoYW5nZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZUhvb2tzKGhvb2tzKSB7XG4gIGhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaWxsS2V5cyhrZXlzKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHJldHVybiBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleSA9PSBudWxsID8gXCIkY29tcGF0XCIgKyArK2luZGV4IDogXCJcIiArIGtleTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyKGVsLCBrZXksIGluZGV4LCBjb250YWluZXIpIHtcbiAgaWYgKGlzU3RyaW5nKGVsKSB8fCBpc051bWJlcihlbCkpIHtcbiAgICByZXR1cm4gbmV3IFRleHRQcm92aWRlcihcInRleHRfXCIgKyBlbCwga2V5LCBpbmRleCwgY29udGFpbmVyLCBudWxsLCB7fSk7XG4gIH1cblxuICB2YXIgcHJvdmlkZXJDbGFzcyA9IHR5cGVvZiBlbC50eXBlID09PSBcInN0cmluZ1wiID8gRWxlbWVudFByb3ZpZGVyIDogZWwudHlwZS5wcm90b3R5cGUucmVuZGVyID8gQ29tcG9uZW50UHJvdmlkZXIgOiBGdW5jdGlvblByb3ZpZGVyO1xuICByZXR1cm4gbmV3IHByb3ZpZGVyQ2xhc3MoZWwudHlwZSwga2V5LCBpbmRleCwgY29udGFpbmVyLCBlbC5yZWYsIGVsLnByb3BzKTtcbn1cblxuZnVuY3Rpb24gZmxhdChhcnIpIHtcbiAgdmFyIGFycjIgPSBbXTtcbiAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgYXJyMiA9IGFycjIuY29uY2F0KGlzQXJyYXkoZWwpID8gZmxhdChlbCkgOiBlbCk7XG4gIH0pO1xuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgb3RoZXJQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wiY2xhc3NOYW1lXCJdKTtcblxuICBpZiAoY2xhc3NOYW1lICE9IG51bGwpIHtcbiAgICBvdGhlclByb3BzLmNsYXNzID0gY2xhc3NOYW1lO1xuICB9XG5cbiAgZGVsZXRlIG90aGVyUHJvcHMuc3R5bGU7XG4gIGRlbGV0ZSBvdGhlclByb3BzLmNoaWxkcmVuO1xuICByZXR1cm4gb3RoZXJQcm9wcztcbn1cblxuZnVuY3Rpb24gZmlsbFByb3BzKHByb3BzLCBkZWZhdWx0UHJvcHMpIHtcbiAgaWYgKCFkZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmaW5lZChwcm9wc1tuYW1lXSkpIHtcbiAgICAgIHByb3BzW25hbWVdID0gZGVmYXVsdFByb3BzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGNoaWxkcmVuW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgdmFyIF9hID0gcHJvcHMgfHwge30sXG4gICAgICBrZXkgPSBfYS5rZXksXG4gICAgICByZWYgPSBfYS5yZWYsXG4gICAgICBvdGhlclByb3BzID0gX19yZXN0KF9hLCBbXCJrZXlcIiwgXCJyZWZcIl0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogX19hc3NpZ24oX19hc3NpZ24oe30sIG90aGVyUHJvcHMpLCB7XG4gICAgICBjaGlsZHJlbjogZmxhdChjaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQgIT0gbnVsbCAmJiBjaGlsZCAhPT0gZmFsc2U7XG4gICAgICB9KVxuICAgIH0pXG4gIH07XG59XG5cbnZhciBQcm92aWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3ZpZGVyKHR5cGUsIGtleSwgaW5kZXgsIGNvbnRhaW5lciwgcmVmLCBwcm9wcykge1xuICAgIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm9wcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMucmVmID0gcmVmO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLl9wcm92aWRlcnMgPSBbXTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gUHJvdmlkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uX3Nob3VsZCA9IGZ1bmN0aW9uIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZSA9IGZ1bmN0aW9uIChob29rcywgbmV4dEVsZW1lbnQsIG5leHRTdGF0ZSwgaXNGb3JjZVVwZGF0ZSkge1xuICAgIGlmICh0aGlzLmJhc2UgJiYgIWlzU3RyaW5nKG5leHRFbGVtZW50KSAmJiAhaXNGb3JjZVVwZGF0ZSAmJiAhdGhpcy5fc2hvdWxkKG5leHRFbGVtZW50LnByb3BzLCBuZXh0U3RhdGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcmlnaW5hbCA9IG5leHRFbGVtZW50O1xuXG4gICAgdGhpcy5fc2V0U3RhdGUobmV4dFN0YXRlKTsgLy8gcmVuZGVyXG5cblxuICAgIHZhciBwcmV2UHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFpc1N0cmluZyhuZXh0RWxlbWVudCkpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBuZXh0RWxlbWVudC5wcm9wcztcbiAgICAgIHRoaXMucmVmID0gbmV4dEVsZW1lbnQucmVmO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcihob29rcywgdGhpcy5iYXNlID8gcHJldlByb3BzIDoge30sIG5leHRTdGF0ZSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLl9tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnJlZjtcbiAgICByZWYgJiYgcmVmKHRoaXMuYmFzZSk7XG4gIH07XG5cbiAgX19wcm90by5fc2V0U3RhdGUgPSBmdW5jdGlvbiAobmV4dHN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9fcHJvdG8uX3VwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMucmVmO1xuICAgIHJlZiAmJiByZWYodGhpcy5iYXNlKTtcbiAgfTtcblxuICBfX3Byb3RvLl9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnJlZjtcbiAgICByZWYgJiYgcmVmKG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBQcm92aWRlcjtcbn0oKTtcblxuZnVuY3Rpb24gZGlmZkF0dHJpYnV0ZXMoYXR0cnMxLCBhdHRyczIsIGVsKSB7XG4gIHZhciBfYSA9IGRpZmZPYmplY3QoYXR0cnMxLCBhdHRyczIpLFxuICAgICAgYWRkZWQgPSBfYS5hZGRlZCxcbiAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgY2hhbmdlZCA9IF9hLmNoYW5nZWQ7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhZGRlZCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCBhZGRlZFtuYW1lXSk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGNoYW5nZWQpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgY2hhbmdlZFtuYW1lXVsxXSk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHJlbW92ZWQpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkV2ZW50cyhldmVudHMxLCBldmVudHMyLCBwcm92aWVyKSB7XG4gIHZhciBfYSA9IGRpZmZPYmplY3QoZXZlbnRzMSwgZXZlbnRzMiksXG4gICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsXG4gICAgICBjaGFuZ2VkID0gX2EuY2hhbmdlZDtcblxuICBmb3IgKHZhciBuYW1lIGluIHJlbW92ZWQpIHtcbiAgICBwcm92aWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIGFkZGVkKSB7XG4gICAgcHJvdmllci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGFkZGVkW25hbWVdKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gY2hhbmdlZCkge1xuICAgIHByb3ZpZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lKTtcbiAgICBwcm92aWVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2hhbmdlZFtuYW1lXVsxXSk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHJlbW92ZWQpIHtcbiAgICBwcm92aWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZlN0eWxlKHN0eWxlMSwgc3R5bGUyLCBlbCkge1xuICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcblxuICB2YXIgX2EgPSBkaWZmT2JqZWN0KHN0eWxlMSwgc3R5bGUyKSxcbiAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcbiAgICAgIGNoYW5nZWQgPSBfYS5jaGFuZ2VkO1xuXG4gIGZvciAodmFyIGJlZm9yZU5hbWUgaW4gYWRkZWQpIHtcbiAgICB2YXIgbmFtZSA9IGRlY2FtZWxpemUoYmVmb3JlTmFtZSwgXCItXCIpO1xuXG4gICAgaWYgKHN0eWxlLnNldFByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBhZGRlZFtiZWZvcmVOYW1lXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW25hbWVdID0gYWRkZWRbYmVmb3JlTmFtZV07XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgYmVmb3JlTmFtZSBpbiBjaGFuZ2VkKSB7XG4gICAgdmFyIG5hbWUgPSBkZWNhbWVsaXplKGJlZm9yZU5hbWUsIFwiLVwiKTtcblxuICAgIGlmIChzdHlsZS5zZXRQcm9wZXJ0eSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgY2hhbmdlZFtiZWZvcmVOYW1lXVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW25hbWVdID0gY2hhbmdlZFtiZWZvcmVOYW1lXVsxXTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBiZWZvcmVOYW1lIGluIHJlbW92ZWQpIHtcbiAgICB2YXIgbmFtZSA9IGRlY2FtZWxpemUoYmVmb3JlTmFtZSwgXCItXCIpO1xuXG4gICAgaWYgKHN0eWxlLnJlbW92ZVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVbbmFtZV0gPSBcIlwiO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdFByb3BzKHByb3BzKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0ge307XG4gIHZhciBldmVudHMgPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIHByb3BzKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZihcIm9uXCIpID09PSAwKSB7XG4gICAgICBldmVudHNbbmFtZS5yZXBsYWNlKFwib25cIiwgXCJcIikudG9Mb3dlckNhc2UoKV0gPSBwcm9wc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBldmVudHM6IGV2ZW50c1xuICB9O1xufVxuXG52YXIgVGV4dFByb3ZpZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRleHRQcm92aWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBUZXh0UHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBUZXh0UHJvdmlkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uIChob29rcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgaXNNb3VudCA9ICF0aGlzLmJhc2U7XG5cbiAgICBpZiAoaXNNb3VudCkge1xuICAgICAgdGhpcy5iYXNlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50eXBlLnJlcGxhY2UoXCJ0ZXh0X1wiLCBcIlwiKSk7XG4gICAgfVxuXG4gICAgaG9va3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNNb3VudCkge1xuICAgICAgICBfdGhpcy5fbW91bnRlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLl91bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYmFzZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFzZSk7XG4gIH07XG5cbiAgcmV0dXJuIFRleHRQcm92aWRlcjtcbn0oUHJvdmlkZXIpO1xuXG52YXIgRWxlbWVudFByb3ZpZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVsZW1lbnRQcm92aWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBFbGVtZW50UHJvdmlkZXIoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5ldmVudHMgPSB7fTtcbiAgICBfdGhpcy5faXNTVkcgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IEVsZW1lbnRQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuXG4gICAgZXZlbnRzW25hbWVdID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUubmF0aXZlRXZlbnQgPSBlO1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcblxuICAgIHRoaXMuYmFzZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50c1tuYW1lXSk7XG4gIH07XG5cbiAgX19wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgdGhpcy5iYXNlLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRzW25hbWVdKTtcbiAgICBkZWxldGUgZXZlbnRzW25hbWVdO1xuICB9O1xuXG4gIF9fcHJvdG8uX3Nob3VsZCA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gaXNEaWZmKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG4gIH07XG5cbiAgX19wcm90by5fcmVuZGVyID0gZnVuY3Rpb24gKGhvb2tzLCBwcmV2UHJvcHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGlzTW91bnQgPSAhdGhpcy5iYXNlO1xuXG4gICAgaWYgKGlzTW91bnQpIHtcbiAgICAgIHZhciBpc1NWRyA9IHRoaXMuX2hhc1NWRygpO1xuXG4gICAgICB0aGlzLl9pc1NWRyA9IGlzU1ZHO1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnByb3BzLnBvcnRhbENvbnRhaW5lcjtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICAgIGlmIChpc1NWRykge1xuICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB0eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmJhc2UgPSBlbGVtZW50O1xuICAgIH1cblxuICAgIHJlbmRlclByb3ZpZGVycyh0aGlzLCB0aGlzLl9wcm92aWRlcnMsIHRoaXMucHJvcHMuY2hpbGRyZW4sIGhvb2tzLCBudWxsKTtcbiAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcblxuICAgIHZhciBfYSA9IHNwbGl0UHJvcHMocHJldlByb3BzKSxcbiAgICAgICAgcHJldkF0dHJpYnV0ZXMgPSBfYS5hdHRyaWJ1dGVzLFxuICAgICAgICBwcmV2RXZlbnRzID0gX2EuZXZlbnRzO1xuXG4gICAgdmFyIF9iID0gc3BsaXRQcm9wcyh0aGlzLnByb3BzKSxcbiAgICAgICAgbmV4dEF0dHJpYnV0ZXMgPSBfYi5hdHRyaWJ1dGVzLFxuICAgICAgICBuZXh0RXZlbnRzID0gX2IuZXZlbnRzO1xuXG4gICAgZGlmZkF0dHJpYnV0ZXMoZ2V0QXR0cmlidXRlcyhwcmV2QXR0cmlidXRlcyksIGdldEF0dHJpYnV0ZXMobmV4dEF0dHJpYnV0ZXMpLCBiYXNlKTtcbiAgICBkaWZmRXZlbnRzKHByZXZFdmVudHMsIG5leHRFdmVudHMsIHRoaXMpO1xuICAgIGRpZmZTdHlsZShwcmV2UHJvcHMuc3R5bGUgfHwge30sIHRoaXMucHJvcHMuc3R5bGUgfHwge30sIGJhc2UpO1xuICAgIGhvb2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgX3RoaXMuX21vdW50ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl91cGRhdGVkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5fdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgICAgYmFzZS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50c1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICBwcm92aWRlci5fdW5tb3VudCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5ldmVudHMgPSB7fTtcblxuICAgIGlmICghdGhpcy5wcm9wcy5wb3J0YWxDb250YWluZXIpIHtcbiAgICAgIGJhc2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYXNlKTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5faGFzU1ZHID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc1NWRyB8fCB0aGlzLnR5cGUgPT09IFwic3ZnXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXJOb2RlID0gZmluZENvbnRhaW5lck5vZGUodGhpcy5jb250YWluZXIpO1xuICAgIHJldHVybiBjb250YWluZXJOb2RlICYmIFwib3duZXJTVkdFbGVtZW50XCIgaW4gY29udGFpbmVyTm9kZTtcbiAgfTtcblxuICByZXR1cm4gRWxlbWVudFByb3ZpZGVyO1xufShQcm92aWRlcik7XG5cbmZ1bmN0aW9uIGZpbmRDb250YWluZXJOb2RlKHByb3ZpZGVyKSB7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBiYXNlID0gcHJvdmlkZXIuYmFzZTtcblxuICBpZiAoYmFzZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHJldHVybiBmaW5kQ29udGFpbmVyTm9kZShwcm92aWRlci5jb250YWluZXIpO1xufVxuXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wKSB7XG4gIGlmICghY29tcCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbXAgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgcmV0dXJuIGNvbXA7XG4gIH1cblxuICB2YXIgcHJvdmlkZXJzID0gY29tcC4kX3Byb3ZpZGVyLl9wcm92aWRlcnM7XG5cbiAgaWYgKCFwcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZmluZERPTU5vZGUocHJvdmlkZXJzWzBdLmJhc2UpO1xufVxuXG52YXIgRnVuY3Rpb25Qcm92aWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhGdW5jdGlvblByb3ZpZGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBGdW5jdGlvblByb3ZpZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLl9yZW5kZXIgPSBmdW5jdGlvbiAoaG9va3MpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnR5cGUodGhpcy5wcm9wcyk7XG4gICAgcmVuZGVyUHJvdmlkZXJzKHRoaXMsIHRoaXMuX3Byb3ZpZGVycywgdGVtcGxhdGUgPyBbdGVtcGxhdGVdIDogW10sIGhvb2tzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLl91bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgcHJvdmlkZXIuX3VubW91bnQoKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRnVuY3Rpb25Qcm92aWRlcjtcbn0oUHJvdmlkZXIpO1xuXG52YXIgQ29udGFpbmVyUHJvdmlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ29udGFpbmVyUHJvdmlkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQ29udGFpbmVyUHJvdmlkZXIoYmFzZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiY29udGFpbmVyXCIsIFwiY29udGFpbmVyXCIsIDAsIG51bGwpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5iYXNlID0gYmFzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IENvbnRhaW5lclByb3ZpZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5fdW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgcmV0dXJuIENvbnRhaW5lclByb3ZpZGVyO1xufShQcm92aWRlcik7XG5cbnZhciBDb21wb25lbnRQcm92aWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDb21wb25lbnRQcm92aWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDb21wb25lbnRQcm92aWRlcih0eXBlLCBrZXksIGluZGV4LCBjb250YWluZXIsIHJlZiwgcHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwga2V5LCBpbmRleCwgY29udGFpbmVyLCByZWYsIGZpbGxQcm9wcyhwcm9wcywgdHlwZS5kZWZhdWx0UHJvcHMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBDb21wb25lbnRQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5fc2hvdWxkID0gZnVuY3Rpb24gKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZS5zaG91bGRDb21wb25lbnRVcGRhdGUoZmlsbFByb3BzKG5leHRQcm9wcywgdGhpcy50eXBlLmRlZmF1bHRQcm9wcyksIG5leHRTdGF0ZSB8fCB0aGlzLmJhc2Uuc3RhdGUpO1xuICB9O1xuXG4gIF9fcHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uIChob29rcywgcHJldlByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5wcm9wcyA9IGZpbGxQcm9wcyh0aGlzLnByb3BzLCB0aGlzLnR5cGUuZGVmYXVsdFByb3BzKTtcbiAgICB2YXIgaXNNb3VudCA9ICF0aGlzLmJhc2U7XG5cbiAgICBpZiAoaXNNb3VudCkge1xuICAgICAgdGhpcy5iYXNlID0gbmV3IHRoaXMudHlwZSh0aGlzLnByb3BzKTtcbiAgICAgIHRoaXMuYmFzZS4kX3Byb3ZpZGVyID0gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iYXNlLnByb3BzID0gdGhpcy5wcm9wcztcbiAgICB9XG5cbiAgICB2YXIgYmFzZSA9IHRoaXMuYmFzZTtcbiAgICB2YXIgcHJldlN0YXRlID0gYmFzZS5zdGF0ZTtcbiAgICB2YXIgdGVtcGxhdGUgPSBiYXNlLnJlbmRlcigpO1xuXG4gICAgaWYgKHRlbXBsYXRlICYmIHRlbXBsYXRlLnByb3BzICYmICF0ZW1wbGF0ZS5wcm9wcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRlbXBsYXRlLnByb3BzLmNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICByZW5kZXJQcm92aWRlcnModGhpcywgdGhpcy5fcHJvdmlkZXJzLCB0ZW1wbGF0ZSA/IFt0ZW1wbGF0ZV0gOiBbXSwgaG9va3MsIG5leHRTdGF0ZSwgbnVsbCk7XG4gICAgaG9va3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNNb3VudCkge1xuICAgICAgICBfdGhpcy5fbW91bnRlZCgpO1xuXG4gICAgICAgIGJhc2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl91cGRhdGVkKCk7XG5cbiAgICAgICAgYmFzZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX3NldFN0YXRlID0gZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgIGlmICghbmV4dFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgYmFzZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgfTtcblxuICBfX3Byb3RvLl91bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgcHJvdmlkZXIuX3VubW91bnQoKTtcbiAgICB9KTtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmJhc2UuJF90aW1lcik7XG4gICAgdGhpcy5iYXNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvbmVudFByb3ZpZGVyO1xufShQcm92aWRlcik7XG5cbnZhciBDb21wb25lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMuJF90aW1lciA9IDA7XG4gICAgdGhpcy4kX3N0YXRlID0ge307XG4gIH1cblxuICB2YXIgX19wcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAocHJvcHMsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX19wcm90by5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2ssIGlzRm9yY2VVcGRhdGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLiRfdGltZXIpIHtcbiAgICAgIHRoaXMuJF9zdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLiRfdGltZXIpO1xuICAgIHRoaXMuJF90aW1lciA9IDA7XG4gICAgdGhpcy4kX3N0YXRlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuJF9zdGF0ZSksIHN0YXRlKTtcblxuICAgIGlmICghaXNGb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy4kX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLiRfdGltZXIgPSAwO1xuXG4gICAgICAgIF90aGlzLiRfc2V0U3RhdGUoY2FsbGJhY2ssIGlzRm9yY2VVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJF9zZXRTdGF0ZShjYWxsYmFjaywgaXNGb3JjZVVwZGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9fcHJvdG8uZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnNldFN0YXRlKHt9LCBjYWxsYmFjaywgdHJ1ZSk7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlKSB7fTtcblxuICBfX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge307XG5cbiAgX19wcm90by4kX3NldFN0YXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpc0ZvcmNlVXBkYXRlKSB7XG4gICAgdmFyIGhvb2tzID0gW107XG4gICAgdmFyIHByb3ZpZGVyID0gdGhpcy4kX3Byb3ZpZGVyO1xuICAgIHZhciBpc1VwZGF0ZSA9IHJlbmRlclByb3ZpZGVycyhwcm92aWRlci5jb250YWluZXIsIFtwcm92aWRlcl0sIFtwcm92aWRlci5vcmlnaW5hbF0sIGhvb2tzLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5zdGF0ZSksIHRoaXMuJF9zdGF0ZSksIGlzRm9yY2VVcGRhdGUpO1xuXG4gICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va3MucHVzaChjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGV4ZWN1dGVIb29rcyhob29rcyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KCk7XG5cbnZhciBQdXJlQ29tcG9uZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFB1cmVDb21wb25lbnQsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUHVyZUNvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKHByb3BzLCBzdGF0ZSkge1xuICAgIHJldHVybiBpc0RpZmYodGhpcy5wcm9wcywgcHJvcHMpIHx8IGlzRGlmZih0aGlzLnN0YXRlLCBzdGF0ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFB1cmVDb21wb25lbnQ7XG59KENvbXBvbmVudCk7XG5cbnZhciBfUG9ydGFsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKF9Qb3J0YWwsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gX1BvcnRhbCgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IF9Qb3J0YWwucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZWxlbWVudCA9IF9hLmVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcjtcbiAgICB0aGlzLl9wb3J0YWxQcm92aWRlciA9IG5ldyBDb250YWluZXJQcm92aWRlcihjb250YWluZXIpO1xuICAgIHJlbmRlclByb3ZpZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgdGhpcy5fcG9ydGFsUHJvdmlkZXIpO1xuICB9O1xuXG4gIF9fcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsXG4gICAgICAgIGVsZW1lbnQgPSBfYS5lbGVtZW50LFxuICAgICAgICBjb250YWluZXIgPSBfYS5jb250YWluZXI7XG4gICAgcmVuZGVyUHJvdmlkZXIoZWxlbWVudCwgY29udGFpbmVyLCB0aGlzLl9wb3J0YWxQcm92aWRlcik7XG4gIH07XG5cbiAgX19wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5wcm9wcy5jb250YWluZXI7XG4gICAgcmVuZGVyUHJvdmlkZXIobnVsbCwgY29udGFpbmVyLCB0aGlzLl9wb3J0YWxQcm92aWRlcik7XG4gICAgdGhpcy5fcG9ydGFsUHJvdmlkZXIgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBfUG9ydGFsO1xufShQdXJlQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gdXBkYXRlUHJvdmlkZXIocHJvdmlkZXIsIGNoaWxkcmVuLCBuZXh0U3RhdGUpIHtcbiAgdmFyIGhvb2tzID0gW107XG4gIHJlbmRlclByb3ZpZGVycyhwcm92aWRlciwgcHJvdmlkZXIuX3Byb3ZpZGVycywgY2hpbGRyZW4sIGhvb2tzLCBuZXh0U3RhdGUpO1xuICBleGVjdXRlSG9va3MoaG9va3MpO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0U2liaWxpbmcocHJvdmlkZXIsIGNoaWxkUHJvdmlkZXIpIHtcbiAgdmFyIGNoaWxkUHJvdmlkZXJzID0gcHJvdmlkZXIuX3Byb3ZpZGVycztcbiAgdmFyIGxlbmd0aCA9IGNoaWxkUHJvdmlkZXJzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gY2hpbGRQcm92aWRlci5pbmRleCArIDE7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBlbCA9IGZpbmRET01Ob2RlKGNoaWxkUHJvdmlkZXJzW2ldLmJhc2UpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRpZmZQcm92aWRlcnMoY29udGFpbmVyUHJvdmlkZXIsIHByb3ZpZGVycywgY2hpbGRyZW4pIHtcbiAgdmFyIGNoaWxkcmVuS2V5cyA9IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBpc1N0cmluZyhwKSA/IG51bGwgOiBwLmtleTtcbiAgfSk7XG4gIHZhciBrZXlzMSA9IGZpbGxLZXlzKHByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5rZXk7XG4gIH0pKTtcbiAgdmFyIGtleXMyID0gZmlsbEtleXMoY2hpbGRyZW5LZXlzKTtcbiAgdmFyIHJlc3VsdCA9IGRpZmYoa2V5czEsIGtleXMyLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG4gIHJlc3VsdC5yZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcHJvdmlkZXJzLnNwbGljZShpbmRleCwgMSlbMF0uX3VubW91bnQoKTtcbiAgfSk7XG4gIHJlc3VsdC5vcmRlcmVkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcbiAgICB2YXIgY2hpbGRyZW5Qcm92aWRlciA9IHByb3ZpZGVycy5zcGxpY2UoZnJvbSwgMSlbMF07XG4gICAgcHJvdmlkZXJzLnNwbGljZSh0bywgMCwgY2hpbGRyZW5Qcm92aWRlcik7XG4gICAgdmFyIGVsID0gZmluZERPTU5vZGUoY2hpbGRyZW5Qcm92aWRlci5iYXNlKTtcbiAgICB2YXIgbmV4dCA9IGZpbmRET01Ob2RlKHByb3ZpZGVyc1t0byArIDFdICYmIHByb3ZpZGVyc1t0byArIDFdLmJhc2UpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbmV4dCk7XG4gICAgfVxuICB9KTtcbiAgcmVzdWx0LmFkZGVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcHJvdmlkZXJzLnNwbGljZShpbmRleCwgMCwgY3JlYXRlUHJvdmlkZXIoY2hpbGRyZW5baW5kZXhdLCBjaGlsZHJlbktleXNbaW5kZXhdLCBpbmRleCwgY29udGFpbmVyUHJvdmlkZXIpKTtcbiAgfSk7XG4gIHZhciBjaGFuZ2VkID0gcmVzdWx0Lm1haW50YWluZWQuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG4gICAgdmFyIGVsID0gY2hpbGRyZW5bdG9dO1xuICAgIHZhciBjaGlsZFByb3ZpZGVyID0gcHJvdmlkZXJzW3RvXTtcbiAgICB2YXIgdHlwZSA9IGlzU3RyaW5nKGVsKSA/IFwidGV4dF9cIiArIGVsIDogZWwudHlwZTtcblxuICAgIGlmICh0eXBlICE9PSBjaGlsZFByb3ZpZGVyLnR5cGUpIHtcbiAgICAgIGNoaWxkUHJvdmlkZXIuX3VubW91bnQoKTtcblxuICAgICAgcHJvdmlkZXJzLnNwbGljZSh0bywgMSwgY3JlYXRlUHJvdmlkZXIoZWwsIGNoaWxkcmVuS2V5c1t0b10sIHRvLCBjb250YWluZXJQcm92aWRlcikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY2hpbGRQcm92aWRlci5pbmRleCA9IHRvO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiBfX3NwcmVhZEFycmF5cyhyZXN1bHQuYWRkZWQsIGNoYW5nZWQubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG4gICAgcmV0dXJuIHRvO1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclByb3ZpZGVycyhjb250YWluZXJQcm92aWRlciwgcHJvdmlkZXJzLCBjaGlsZHJlbiwgdXBkYXRlZEhvb2tzLCBuZXh0U3RhdGUsIGlzRm9yY2VVcGRhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IGRpZmZQcm92aWRlcnMoY29udGFpbmVyUHJvdmlkZXIsIHByb3ZpZGVycywgY2hpbGRyZW4pO1xuICB2YXIgdXBkYXRlZCA9IHByb3ZpZGVycy5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkUHJvdmlkZXIsIGkpIHtcbiAgICByZXR1cm4gY2hpbGRQcm92aWRlci5fdXBkYXRlKHVwZGF0ZWRIb29rcywgY2hpbGRyZW5baV0sIG5leHRTdGF0ZSwgaXNGb3JjZVVwZGF0ZSk7XG4gIH0pO1xuICB2YXIgY29udGFpbmVyTm9kZSA9IGZpbmRDb250YWluZXJOb2RlKGNvbnRhaW5lclByb3ZpZGVyKTtcblxuICBpZiAoY29udGFpbmVyTm9kZSkge1xuICAgIHJlc3VsdC5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciBjaGlsZFByb3ZpZGVyID0gcHJvdmlkZXJzW2luZGV4XTtcbiAgICAgIHZhciBlbCA9IGZpbmRET01Ob2RlKGNoaWxkUHJvdmlkZXIuYmFzZSk7XG5cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGFpbmVyTm9kZSAhPT0gZWwgJiYgIWVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIG5leHRFbGVtZW50ID0gZ2V0TmV4dFNpYmlsaW5nKGNvbnRhaW5lclByb3ZpZGVyLCBjaGlsZFByb3ZpZGVyKTtcbiAgICAgICAgY29udGFpbmVyTm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5leHRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVkLmxlbmd0aCA+IDA7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclByb3ZpZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcHJvdmlkZXIpIHtcbiAgaWYgKHByb3ZpZGVyID09PSB2b2lkIDApIHtcbiAgICBwcm92aWRlciA9IGNvbnRhaW5lci5fX1JFQUNUX0NPTVBBVF9fO1xuICB9XG5cbiAgdmFyIGlzUHJvdmlkZXIgPSAhIXByb3ZpZGVyO1xuXG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICBwcm92aWRlciA9IG5ldyBDb250YWluZXJQcm92aWRlcihjb250YWluZXIpO1xuICB9XG5cbiAgdXBkYXRlUHJvdmlkZXIocHJvdmlkZXIsIGVsZW1lbnQgPyBbZWxlbWVudF0gOiBbXSk7XG5cbiAgaWYgKCFpc1Byb3ZpZGVyKSB7XG4gICAgY29udGFpbmVyLl9fUkVBQ1RfQ09NUEFUX18gPSBwcm92aWRlcjtcbiAgfVxuXG4gIHJldHVybiBwcm92aWRlcjtcbn1cblxuZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgdmFyIHByb3ZpZGVyID0gY29udGFpbmVyLl9fUkVBQ1RfQ09NUEFUX187XG5cbiAgaWYgKGVsZW1lbnQgJiYgIXByb3ZpZGVyKSB7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gIH1cblxuICByZW5kZXJQcm92aWRlcihlbGVtZW50LCBjb250YWluZXIsIHByb3ZpZGVyKTtcbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChlbCwgY29udGFpbmVyKSB7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KF9Qb3J0YWwsIHtcbiAgICBlbGVtZW50OiBlbCxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICB9KTtcbn1cbnZhciB2ZXJzaW9uID0gXCJzaW1wbGUtMS4xLjBcIjtcblxuZXhwb3J0IHsgQ29tcG9uZW50LCBQdXJlQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBjcmVhdGVQb3J0YWwsIGZpbmRET01Ob2RlLCByZW5kZXIsIHZlcnNpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhdC5lc20uanMubWFwXG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDIwIERheWJydXNoXG5uYW1lOiBzZWxlY3RvXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvc2VsZWN0by5naXRcbnZlcnNpb246IDEuMTUuMFxuKi9cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnQHNjZW5hL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IEdlc3RvIGZyb20gJ2dlc3RvJztcbmltcG9ydCB7IFByb3BlcnRpZXMgfSBmcm9tICdmcmFtZXdvcmstdXRpbHMnO1xuaW1wb3J0IHsgaGFzQ2xhc3MsIGFkZENsYXNzLCBjYWxjdWxhdGVCb3VuZFNpemUsIGlzT2JqZWN0LCBpc1N0cmluZywgcmVtb3ZlRXZlbnQsIGFkZEV2ZW50LCBzcGxpdFVuaXQsIGJldHdlZW4sIGlzQXJyYXksIGNhbWVsaXplIH0gZnJvbSAnQGRheWJydXNoL3V0aWxzJztcbmltcG9ydCB7IGRpZmYgfSBmcm9tICdAZWdqcy9jaGlsZHJlbi1kaWZmZXInO1xuaW1wb3J0IERyYWdTY3JvbGwgZnJvbSAnQHNjZW5hL2RyYWdzY3JvbGwnO1xuaW1wb3J0IEtleUNvbnRyb2xsZXIsIHsgZ2V0Q29tYmkgfSBmcm9tICdrZXljb24nO1xuaW1wb3J0IHsgZml0UG9pbnRzLCBpc0luc2lkZSwgZ2V0T3ZlcmxhcFBvaW50cywgZ2V0QXJlYVNpemUgfSBmcm9tICdvdmVybGFwLWFyZWEnO1xuaW1wb3J0IHsgY3JlYXRlTWF0cml4LCBnZXREaXN0RWxlbWVudE1hdHJpeCwgY2FsY3VsYXRlTWF0cml4RGlzdCB9IGZyb20gJ2Nzcy10by1tYXQnO1xuaW1wb3J0IHN0eWxlZCBmcm9tICdjc3Mtc3R5bGVkJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG5cbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuXG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLFxuICAgICAgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnQoZSkge1xuICBpZiAoXCJ0b3VjaGVzXCIgaW4gZSkge1xuICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGUuY2xpZW50WVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoanN4LCBwcmV2VGFyZ2V0LCBjb250YWluZXIpIHtcbiAgdmFyIHRhZyA9IGpzeC50YWcsXG4gICAgICBjaGlsZHJlbiA9IGpzeC5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBqc3guYXR0cmlidXRlcyxcbiAgICAgIGNsYXNzTmFtZSA9IGpzeC5jbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IGpzeC5zdHlsZTtcbiAgdmFyIGVsID0gcHJldlRhcmdldCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZXNbbmFtZV0pO1xuICB9XG5cbiAgdmFyIGVsQ2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICBjcmVhdGVFbGVtZW50KGNoaWxkLCBlbENoaWxkcmVuW2ldLCBlbCk7XG4gIH0pO1xuXG4gIGlmIChjbGFzc05hbWUpIHtcbiAgICBjbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XG4gICAgICAgIGFkZENsYXNzKGVsLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzdHlsZSkge1xuICAgIHZhciBlbFN0eWxlID0gZWwuc3R5bGU7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgICBlbFN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwcmV2VGFyZ2V0ICYmIGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBoKHRhZywgYXR0cnMpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjaGlsZHJlbltfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBfYSA9IGF0dHJzIHx8IHt9LFxuICAgICAgX2IgPSBfYS5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLFxuICAgICAgX2MgPSBfYS5zdHlsZSxcbiAgICAgIHN0eWxlID0gX2MgPT09IHZvaWQgMCA/IHt9IDogX2MsXG4gICAgICBhdHRyaWJ1dGVzID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiXSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZyxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZWYWx1ZShwcmV2LCBjdXIsIGZ1bmMpIHtcbiAgaWYgKHByZXYgIT09IGN1cikge1xuICAgIGZ1bmMocHJldiwgY3VyKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVjdChlLCByYXRpbywgYm91bmRBcmVhKSB7XG4gIHZhciBfYTtcblxuICBpZiAoYm91bmRBcmVhID09PSB2b2lkIDApIHtcbiAgICBib3VuZEFyZWEgPSBlLmRhdGFzLmJvdW5kQXJlYTtcbiAgfVxuXG4gIHZhciBfYiA9IGUuZGlzdFgsXG4gICAgICBkaXN0WCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICBfYyA9IGUuZGlzdFksXG4gICAgICBkaXN0WSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2M7XG4gIHZhciBfZCA9IGUuZGF0YXMsXG4gICAgICBzdGFydFggPSBfZC5zdGFydFgsXG4gICAgICBzdGFydFkgPSBfZC5zdGFydFk7XG5cbiAgaWYgKHJhdGlvID4gMCkge1xuICAgIHZhciBuZXh0SGVpZ2h0ID0gTWF0aC5zcXJ0KChkaXN0WCAqIGRpc3RYICsgZGlzdFkgKiBkaXN0WSkgLyAoMSArIHJhdGlvICogcmF0aW8pKTtcbiAgICB2YXIgbmV4dFdpZHRoID0gcmF0aW8gKiBuZXh0SGVpZ2h0O1xuICAgIGRpc3RYID0gKGRpc3RYID49IDAgPyAxIDogLTEpICogbmV4dFdpZHRoO1xuICAgIGRpc3RZID0gKGRpc3RZID49IDAgPyAxIDogLTEpICogbmV4dEhlaWdodDtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IE1hdGguYWJzKGRpc3RYKTtcbiAgdmFyIGhlaWdodCA9IE1hdGguYWJzKGRpc3RZKTtcbiAgdmFyIG1heFdpZHRoID0gZGlzdFggPCAwID8gc3RhcnRYIC0gYm91bmRBcmVhLmxlZnQgOiBib3VuZEFyZWEucmlnaHQgLSBzdGFydFg7XG4gIHZhciBtYXhIZWlnaHQgPSBkaXN0WSA8IDAgPyBzdGFydFkgLSBib3VuZEFyZWEudG9wIDogYm91bmRBcmVhLmJvdHRvbSAtIHN0YXJ0WTtcbiAgX2EgPSBjYWxjdWxhdGVCb3VuZFNpemUoW3dpZHRoLCBoZWlnaHRdLCBbMCwgMF0sIFttYXhXaWR0aCwgbWF4SGVpZ2h0XSwgISFyYXRpbyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICBkaXN0WCA9IChkaXN0WCA+PSAwID8gMSA6IC0xKSAqIHdpZHRoO1xuICBkaXN0WSA9IChkaXN0WSA+PSAwID8gMSA6IC0xKSAqIGhlaWdodDtcbiAgdmFyIHR4ID0gTWF0aC5taW4oMCwgZGlzdFgpO1xuICB2YXIgdHkgPSBNYXRoLm1pbigwLCBkaXN0WSk7XG4gIHZhciBsZWZ0ID0gc3RhcnRYICsgdHg7XG4gIHZhciB0b3AgPSBzdGFydFkgKyB0eTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHRvcDogdG9wLFxuICAgIHJpZ2h0OiBsZWZ0ICsgd2lkdGgsXG4gICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RWxlbWVudFJlY3QoZWwpIHtcbiAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICB0b3AgPSByZWN0LnRvcCxcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHBvczE6IFtsZWZ0LCB0b3BdLFxuICAgIHBvczI6IFtsZWZ0ICsgd2lkdGgsIHRvcF0sXG4gICAgcG9zMzogW2xlZnQsIHRvcCArIGhlaWdodF0sXG4gICAgcG9zNDogW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XVxuICB9O1xufVxuZnVuY3Rpb24gcGFzc1RhcmdldHMoYmVmb3JlVGFyZ2V0cywgYWZ0ZXJUYXJnZXRzKSB7XG4gIHZhciBfYSA9IGRpZmYoYmVmb3JlVGFyZ2V0cywgYWZ0ZXJUYXJnZXRzKSxcbiAgICAgIGxpc3QgPSBfYS5saXN0LFxuICAgICAgcHJldkxpc3QgPSBfYS5wcmV2TGlzdCxcbiAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICByZW1vdmVkID0gX2EucmVtb3ZlZDtcblxuICByZXR1cm4gYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgfSkuY29uY2F0KHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gIH0pKTtcbn1cblxudmFyIGluamVjdG9yID0gc3R5bGVkKFwiXFxuOmhvc3Qge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICM0YWY7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoNjgsIDE3MCwgMjU1LCAwLjUpO1xcbiAgICB6LWluZGV4OiAxMDA7XFxufVxcbjpob3N0IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cIik7XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIENMQVNTX05BTUUgPSBcInNlbGVjdG8tc2VsZWN0aW9uIFwiICsgaW5qZWN0b3IuY2xhc3NOYW1lO1xudmFyIFBST1BFUlRJRVMgPSBbXCJib3VuZENvbnRhaW5lclwiLCBcInNlbGVjdGFibGVUYXJnZXRzXCIsIFwic2VsZWN0QnlDbGlja1wiLCBcInNlbGVjdEZyb21JbnNpZGVcIiwgXCJjb250aW51ZVNlbGVjdFwiLCBcInRvZ2dsZUNvbnRpbnVlU2VsZWN0XCIsIFwia2V5Q29udGFpbmVyXCIsIFwiaGl0UmF0ZVwiLCBcInNjcm9sbE9wdGlvbnNcIiwgXCJjaGVja0lucHV0XCIsIFwicHJldmVudERlZmF1bHRcIiwgXCJyYXRpb1wiLCBcImdldEVsZW1lbnRSZWN0XCIsIFwicHJldmVudERyYWdGcm9tSW5zaWRlXCIsIFwicm9vdENvbnRhaW5lclwiLCBcImRyYWdDb25kaXRpb25cIiwgXCJjbGlja0J5U2VsZWN0RW5kXCJdO1xuLyoqXG4gKiBAbWVtYmVyb2YgU2VsZWN0b1xuICovXG5cbnZhciBPUFRJT05TID0gX19zcHJlYWRBcnJheXMoWy8vIGlnbm9yZSB0YXJnZXQsIGNvbnRhaW5lcixcblwiZHJhZ0NvbnRhaW5lclwiLCBcImNzcE5vbmNlXCJdLCBQUk9QRVJUSUVTKTtcbnZhciBPUFRJT05fVFlQRVMgPSB7XG4gIGJvdW5kQ29udGFpbmVyOiBudWxsLFxuICBwb3J0YWxDb250YWluZXI6IG51bGwsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgZHJhZ0NvbnRhaW5lcjogbnVsbCxcbiAgc2VsZWN0YWJsZVRhcmdldHM6IEFycmF5LFxuICBzZWxlY3RCeUNsaWNrOiBCb29sZWFuLFxuICBzZWxlY3RGcm9tSW5zaWRlOiBCb29sZWFuLFxuICBjb250aW51ZVNlbGVjdDogQm9vbGVhbixcbiAgdG9nZ2xlQ29udGludWVTZWxlY3Q6IEFycmF5LFxuICBrZXlDb250YWluZXI6IG51bGwsXG4gIGhpdFJhdGU6IE51bWJlcixcbiAgc2Nyb2xsT3B0aW9uczogT2JqZWN0LFxuICBjaGVja0lucHV0OiBCb29sZWFuLFxuICBwcmV2ZW50RGVmYXVsdDogQm9vbGVhbixcbiAgY3NwTm9uY2U6IFN0cmluZyxcbiAgcmF0aW86IE51bWJlcixcbiAgZ2V0RWxlbWVudFJlY3Q6IEZ1bmN0aW9uLFxuICBwcmV2ZW50RHJhZ0Zyb21JbnNpZGU6IEJvb2xlYW4sXG4gIHJvb3RDb250YWluZXI6IE9iamVjdCxcbiAgZHJhZ0NvbmRpdGlvbjogRnVuY3Rpb24sXG4gIGNsaWNrQnlTZWxlY3RFbmQ6IEJvb2xlYW5cbn07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIEVWRU5UUyA9IFtcImRyYWdTdGFydFwiLCBcImRyYWdcIiwgXCJkcmFnRW5kXCIsIFwic2VsZWN0U3RhcnRcIiwgXCJzZWxlY3RcIiwgXCJzZWxlY3RFbmRcIiwgXCJrZXlkb3duXCIsIFwia2V5dXBcIiwgXCJzY3JvbGxcIl07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIE1FVEhPRFMgPSBbXCJjbGlja1RhcmdldFwiLCBcImdldFNlbGVjdGFibGVFbGVtZW50c1wiLCBcInNldFNlbGVjdGVkVGFyZ2V0c1wiLCBcImdldEVsZW1lbnRQb2ludHNcIiwgXCJnZXRTZWxlY3RlZFRhcmdldHNcIiwgXCJmaW5kU2VsZWN0YWJsZVRhcmdldHNcIiwgXCJ0cmlnZ2VyRHJhZ1N0YXJ0XCIsIFwiY2hlY2tTY3JvbGxcIl07XG5cbi8qKlxuICogU2VsZWN0by5qcyBpcyBhIGNvbXBvbmVudCB0aGF0IGFsbG93cyB5b3UgdG8gc2VsZWN0IGVsZW1lbnRzIGluIHRoZSBkcmFnIGFyZWEgdXNpbmcgdGhlIG1vdXNlIG9yIHRvdWNoLlxuICogQHNvcnQgMVxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cblxudmFyIFNlbGVjdG8gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2VsZWN0bywgX3N1cGVyKTtcbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gU2VsZWN0byhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zZWxlY3RlZFRhcmdldHMgPSBbXTtcbiAgICBfdGhpcy5kcmFnU2Nyb2xsID0gbmV3IERyYWdTY3JvbGwoKTtcblxuICAgIF90aGlzLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChlLCBjbGlja2VkVGFyZ2V0KSB7XG4gICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLFxuICAgICAgICAgIGNsaWVudFggPSBlLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IGUuY2xpZW50WSxcbiAgICAgICAgICBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50O1xuICAgICAgdmFyIF9hID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250aW51ZVNlbGVjdCA9IF9hLmNvbnRpbnVlU2VsZWN0LFxuICAgICAgICAgIHNlbGVjdEZyb21JbnNpZGUgPSBfYS5zZWxlY3RGcm9tSW5zaWRlLFxuICAgICAgICAgIHNlbGVjdEJ5Q2xpY2sgPSBfYS5zZWxlY3RCeUNsaWNrLFxuICAgICAgICAgIHJvb3RDb250YWluZXIgPSBfYS5yb290Q29udGFpbmVyLFxuICAgICAgICAgIGJvdW5kQ29udGFpbmVyID0gX2EuYm91bmRDb250YWluZXIsXG4gICAgICAgICAgX2IgPSBfYS5wcmV2ZW50RHJhZ0Zyb21JbnNpZGUsXG4gICAgICAgICAgcHJldmVudERyYWdGcm9tSW5zaWRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYixcbiAgICAgICAgICBjbGlja0J5U2VsZWN0RW5kID0gX2EuY2xpY2tCeVNlbGVjdEVuZCxcbiAgICAgICAgICBkcmFnQ29uZGl0aW9uID0gX2EuZHJhZ0NvbmRpdGlvbjtcblxuICAgICAgaWYgKGRyYWdDb25kaXRpb24gJiYgIWRyYWdDb25kaXRpb24oZSkpIHtcbiAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuZmluZFNlbGVjdGFibGVUYXJnZXRzKGRhdGFzKTtcblxuICAgICAgZGF0YXMuc3RhcnRTZWxlY3RlZFRhcmdldHMgPSBfdGhpcy5zZWxlY3RlZFRhcmdldHM7XG4gICAgICBkYXRhcy5zY2FsZU1hdHJpeCA9IGNyZWF0ZU1hdHJpeCgpO1xuICAgICAgZGF0YXMuY29udGFpbmVyWCA9IDA7XG4gICAgICBkYXRhcy5jb250YWluZXJZID0gMDtcbiAgICAgIHZhciBib3VuZEFyZWEgPSB7XG4gICAgICAgIGxlZnQ6IC1JbmZpbml0eSxcbiAgICAgICAgdG9wOiAtSW5maW5pdHksXG4gICAgICAgIHJpZ2h0OiBJbmZpbml0eSxcbiAgICAgICAgYm90dG9tOiBJbmZpbml0eVxuICAgICAgfTtcblxuICAgICAgaWYgKHJvb3RDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBfdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgZGF0YXMuY29udGFpbmVyWCA9IGNvbnRhaW5lclJlY3QubGVmdDtcbiAgICAgICAgZGF0YXMuY29udGFpbmVyWSA9IGNvbnRhaW5lclJlY3QudG9wO1xuICAgICAgICBkYXRhcy5zY2FsZU1hdHJpeCA9IGdldERpc3RFbGVtZW50TWF0cml4KF90aGlzLmNvbnRhaW5lciwgcm9vdENvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZENvbnRhaW5lcikge1xuICAgICAgICB2YXIgYm91bmRJbmZvID0gaXNPYmplY3QoYm91bmRDb250YWluZXIpICYmIFwiZWxlbWVudFwiIGluIGJvdW5kQ29udGFpbmVyID8gX19hc3NpZ24oe1xuICAgICAgICAgIGxlZnQ6IHRydWUsXG4gICAgICAgICAgdG9wOiB0cnVlLFxuICAgICAgICAgIGJvdHRvbTogdHJ1ZSxcbiAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICB9LCBib3VuZENvbnRhaW5lcikgOiB7XG4gICAgICAgICAgZWxlbWVudDogYm91bmRDb250YWluZXIsXG4gICAgICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgICAgICB0b3A6IHRydWUsXG4gICAgICAgICAgYm90dG9tOiB0cnVlLFxuICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZEVsZW1lbnQgPSBib3VuZEluZm8uZWxlbWVudDtcbiAgICAgICAgdmFyIHJlY3RFbGVtZW50ID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChib3VuZEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoaXNTdHJpbmcoYm91bmRFbGVtZW50KSkge1xuICAgICAgICAgICAgcmVjdEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGJvdW5kRWxlbWVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChib3VuZEVsZW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlY3RFbGVtZW50ID0gX3RoaXMuY29udGFpbmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWN0RWxlbWVudCA9IGJvdW5kRWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjdCA9IHJlY3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgaWYgKGJvdW5kSW5mby5sZWZ0KSB7XG4gICAgICAgICAgICBib3VuZEFyZWEubGVmdCA9IHJlY3QubGVmdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYm91bmRJbmZvLnRvcCkge1xuICAgICAgICAgICAgYm91bmRBcmVhLnRvcCA9IHJlY3QudG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChib3VuZEluZm8ucmlnaHQpIHtcbiAgICAgICAgICAgIGJvdW5kQXJlYS5yaWdodCA9IHJlY3QucmlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJvdW5kSW5mby5ib3R0b20pIHtcbiAgICAgICAgICAgIGJvdW5kQXJlYS5ib3R0b20gPSByZWN0LmJvdHRvbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGF0YXMuYm91bmRBcmVhID0gYm91bmRBcmVhO1xuICAgICAgdmFyIGhpdFJlY3QgPSB7XG4gICAgICAgIGxlZnQ6IGNsaWVudFgsXG4gICAgICAgIHRvcDogY2xpZW50WSxcbiAgICAgICAgcmlnaHQ6IGNsaWVudFgsXG4gICAgICAgIGJvdHRvbTogY2xpZW50WSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIHZhciBmaXJzdFBhc3NlZFRhcmdldHMgPSBbXTtcblxuICAgICAgaWYgKHNlbGVjdEJ5Q2xpY2sgJiYgIWNsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgdmFyIHBvaW50VGFyZ2V0ID0gX3RoaXMuX2ZpbmRFbGVtZW50KGNsaWNrZWRUYXJnZXQgfHwgZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKSwgZGF0YXMuc2VsZWN0YWJsZVRhcmdldHMpO1xuXG4gICAgICAgIGZpcnN0UGFzc2VkVGFyZ2V0cyA9IHBvaW50VGFyZ2V0ID8gW3BvaW50VGFyZ2V0XSA6IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzSW5zaWRlVGFyZ2V0cyA9IGZpcnN0UGFzc2VkVGFyZ2V0cy5sZW5ndGggPiAwO1xuICAgICAgdmFyIGlzUHJldmVudFNlbGVjdCA9ICFzZWxlY3RGcm9tSW5zaWRlICYmIGhhc0luc2lkZVRhcmdldHM7IC8vIHByZXZlbnQgZHJhZyBmcm9tIGluc2lkZSB3aGVuIHNlbGVjdEJ5Q2xpY2sgaXMgZmFsc2VcblxuICAgICAgaWYgKGlzUHJldmVudFNlbGVjdCAmJiAhc2VsZWN0QnlDbGljaykge1xuICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZSA9IGlucHV0RXZlbnQudHlwZTtcbiAgICAgIHZhciBpc1RydXN0ZWQgPSB0eXBlID09PSBcIm1vdXNlZG93blwiIHx8IHR5cGUgPT09IFwidG91Y2hzdGFydFwiO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRoZSBkcmFnIHN0YXJ0cyAodHJpZ2dlcnMgb24gbW91c2Vkb3duIG9yIHRvdWNoc3RhcnQpLCB0aGUgZHJhZ1N0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAqIENhbGwgdGhlIHN0b3AgKCkgZnVuY3Rpb24gaWYgeW91IGhhdmUgYSBzcGVjaWZpYyBlbGVtZW50IG9yIGRvbid0IHdhbnQgdG8gcmFpc2UgYSBzZWxlY3RcbiAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgKiBAZXZlbnQgZHJhZ1N0YXJ0XG4gICAgICAgKiBAcGFyYW0ge09uRHJhZ1N0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkcmFnU3RhcnQgZXZlbnRcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICpcbiAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICAgKiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBzZWxlY3RvLm9uKFwiZHJhZ1N0YXJ0XCIsIGUgPT4ge1xuICAgICAgICogICBpZiAoZS5pbnB1dEV2ZW50LnRhcmdldC50YWdOYW1lID09PSBcIlNQQU5cIikge1xuICAgICAgICogICAgIGUuc3RvcCgpO1xuICAgICAgICogICB9XG4gICAgICAgKiB9KS5vbihcInNlbGVjdFwiLCBlID0+IHtcbiAgICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqIH0pO1xuICAgICAgICovXG5cbiAgICAgIHZhciByZXN1bHQgPSAhZS5pc0NsaWNrICYmIGlzVHJ1c3RlZCA/IF90aGlzLmVtaXQoXCJkcmFnU3RhcnRcIiwgX19hc3NpZ24oe30sIGUpKSA6IHRydWU7XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGUuc3RvcCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGludWVTZWxlY3QpIHtcbiAgICAgICAgZGF0YXMuc3RhcnRQYXNzZWRUYXJnZXRzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdFBhc3NlZFRhcmdldHMgPSBwYXNzVGFyZ2V0cyhfdGhpcy5zZWxlY3RlZFRhcmdldHMsIGZpcnN0UGFzc2VkVGFyZ2V0cyk7XG4gICAgICAgIGRhdGFzLnN0YXJ0UGFzc2VkVGFyZ2V0cyA9IF90aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2VsZWN0KF90aGlzLnNlbGVjdGVkVGFyZ2V0cywgZmlyc3RQYXNzZWRUYXJnZXRzLCBoaXRSZWN0LCBpbnB1dEV2ZW50LCB0cnVlKTtcblxuICAgICAgZGF0YXMuc3RhcnRYID0gY2xpZW50WDtcbiAgICAgIGRhdGFzLnN0YXJ0WSA9IGNsaWVudFk7XG4gICAgICBkYXRhcy5zZWxlY3RGbGFnID0gZmFsc2U7XG4gICAgICBkYXRhcy5wcmV2ZW50RHJhZ0Zyb21JbnNpZGUgPSBmYWxzZTtcbiAgICAgIHZhciBvZmZzZXRQb3MgPSBjYWxjdWxhdGVNYXRyaXhEaXN0KGRhdGFzLnNjYWxlTWF0cml4LCBbY2xpZW50WCAtIGRhdGFzLmNvbnRhaW5lclgsIGNsaWVudFkgLSBkYXRhcy5jb250YWluZXJZXSk7XG4gICAgICBkYXRhcy5ib3VuZHNBcmVhID0gX3RoaXMudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gXCJwb3NpdGlvbjogXCIgKyAocm9vdENvbnRhaW5lciA/IFwiYWJzb2x1dGVcIiA6IFwiZml4ZWRcIikgKyBcIjtcIiArIFwibGVmdDowcHg7dG9wOjBweDtcIiArIChcInRyYW5zZm9ybTogdHJhbnNsYXRlKFwiICsgb2Zmc2V0UG9zWzBdICsgXCJweCwgXCIgKyBvZmZzZXRQb3NbMV0gKyBcInB4KVwiKTtcblxuICAgICAgaWYgKGlzUHJldmVudFNlbGVjdCAmJiBzZWxlY3RCeUNsaWNrICYmICFjbGlja0J5U2VsZWN0RW5kKSB7XG4gICAgICAgIGlucHV0RXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBkcmFnIGZyb20gaW5zaWRlIHdoZW4gc2VsZWN0QnlDbGljayBpcyB0cnVlIGFuZCBmb3JjZSBjYWxsIGBzZWxlY3RFbmRgXG5cbiAgICAgICAgaWYgKHByZXZlbnREcmFnRnJvbUluc2lkZSkge1xuICAgICAgICAgIF90aGlzLnNlbGVjdEVuZChkYXRhcy5zdGFydFNlbGVjdGVkVGFyZ2V0cywgZGF0YXMuc3RhcnRQYXNzZWRUYXJnZXRzLCBoaXRSZWN0LCBlKTtcblxuICAgICAgICAgIGRhdGFzLnByZXZlbnREcmFnRnJvbUluc2lkZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFzLnNlbGVjdEZsYWcgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcInRvdWNoc3RhcnRcIikge1xuICAgICAgICAgIGlucHV0RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY3JvbGxPcHRpb25zID0gX3RoaXMub3B0aW9ucy5zY3JvbGxPcHRpb25zO1xuXG4gICAgICAgIGlmIChzY3JvbGxPcHRpb25zICYmIHNjcm9sbE9wdGlvbnMuY29udGFpbmVyKSB7XG4gICAgICAgICAgX3RoaXMuZHJhZ1Njcm9sbC5kcmFnU3RhcnQoZSwgc2Nyb2xsT3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xpY2tCeVNlbGVjdEVuZCkge1xuICAgICAgICAgIGRhdGFzLnNlbGVjdEZsYWcgPSBmYWxzZTtcbiAgICAgICAgICBlLnByZXZlbnREcmFnKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIF90aGlzLl9vbkRyYWcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIF9hO1xuXG4gICAgICBpZiAoZS5kYXRhcy5zZWxlY3RGbGFnKSB7XG4gICAgICAgIHZhciBzY3JvbGxPcHRpb25zID0gX3RoaXMuc2Nyb2xsT3B0aW9uczsgLy8gSWYgaXQgaXMgYSBzY3JvbGxpbmcgcG9zaXRpb24sIHBhc3MgZHJhZ1xuXG4gICAgICAgIGlmICgoKF9hID0gc2Nyb2xsT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5lcikgJiYgX3RoaXMuZHJhZ1Njcm9sbC5kcmFnKGUsIHNjcm9sbE9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9jaGVja1NlbGVjdGVkKGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsXG4gICAgICAgICAgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgICAgIHZhciByZWN0ID0gZ2V0UmVjdChlLCBfdGhpcy5vcHRpb25zLnJhdGlvKTtcbiAgICAgIHZhciBzZWxlY3RGbGFnID0gZGF0YXMuc2VsZWN0RmxhZztcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0aGUgZHJhZyBlbmRzICh0cmlnZ2VycyBvbiBtb3VzZXVwIG9yIHRvdWNoZW5kIGFmdGVyIGRyYWcpLCB0aGUgZHJhZ0VuZCBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICogQGV2ZW50IGRyYWdFbmRcbiAgICAgICAqIEBwYXJhbSB7X09uRHJhZ0VuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZ0VuZCBldmVudFxuICAgICAgICovXG5cbiAgICAgIGlmIChpbnB1dEV2ZW50ICYmICFlLmlzQ2xpY2spIHtcbiAgICAgICAgX3RoaXMuZW1pdChcImRyYWdFbmRcIiwgX19hc3NpZ24oX19hc3NpZ24oe1xuICAgICAgICAgIGlzRG91YmxlOiAhIWUuaXNEb3VibGUsXG4gICAgICAgICAgaXNEcmFnOiBmYWxzZSxcbiAgICAgICAgICBpc1NlbGVjdDogc2VsZWN0RmxhZ1xuICAgICAgICB9LCBlKSwge1xuICAgICAgICAgIGlzQ2xpY2s6ICEhZS5pc0NsaWNrLFxuICAgICAgICAgIHJlY3Q6IHJlY3RcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy50YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcImRpc3BsYXk6IG5vbmU7XCI7XG5cbiAgICAgIGlmIChzZWxlY3RGbGFnKSB7XG4gICAgICAgIGRhdGFzLnNlbGVjdEZsYWcgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5kcmFnU2Nyb2xsLmRyYWdFbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuc2VsZWN0QnlDbGljayAmJiBfdGhpcy5jbGlja0J5U2VsZWN0RW5kKSB7XG4gICAgICAgIC8vIG9ubHkgY2xpY2tCeVNlbGVjdEVuZFxuICAgICAgICB2YXIgcG9pbnRUYXJnZXQgPSBfdGhpcy5fZmluZEVsZW1lbnQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSksIGRhdGFzLnNlbGVjdGFibGVUYXJnZXRzKTtcblxuICAgICAgICBfdGhpcy5zZWxlY3QoX3RoaXMuc2VsZWN0ZWRUYXJnZXRzLCBwb2ludFRhcmdldCA/IFtwb2ludFRhcmdldF0gOiBbXSwgcmVjdCwgaW5wdXRFdmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YXMucHJldmVudERyYWdGcm9tSW5zaWRlKSB7XG4gICAgICAgIF90aGlzLnNlbGVjdEVuZChkYXRhcy5zdGFydFNlbGVjdGVkVGFyZ2V0cywgZGF0YXMuc3RhcnRQYXNzZWRUYXJnZXRzLCByZWN0LCBlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX29uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLl9zYW1lQ29tYmlLZXkoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jb250aW51ZVNlbGVjdCA9IHRydWU7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4geW91IGtleWRvd24gdGhlIGtleSB5b3Ugc3BlY2lmaWVkIGluIHRvZ2dsZUNvbnRpbnVlU2VsZWN0LCB0aGUga2V5ZG93biBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICogQGV2ZW50IGtleWRvd25cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICpcbiAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAqICAgdG9nZ2xlQ29udGludWVTZWxlY3Q6IFwic2hpZnRcIjtcbiAgICAgICAqICAga2V5Q29udGFpbmVyOiB3aW5kb3csXG4gICAgICAgKiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBzZWxlY3RvLm9uKFwia2V5ZG93blwiLCAoKSA9PiB7XG4gICAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uXCIpLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqIH0pLm9uKFwia2V5dXBcIiwgKCkgPT4ge1xuICAgICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmJ1dHRvblwiKS5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiB9KS5vbihcInNlbGVjdFwiLCBlID0+IHtcbiAgICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqIH0pO1xuICAgICAgICovXG5cbiAgICAgIF90aGlzLmVtaXQoXCJrZXlkb3duXCIsIHt9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX29uS2V5VXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFfdGhpcy5fc2FtZUNvbWJpS2V5KGUsIHRydWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY29udGludWVTZWxlY3QgPSBmYWxzZTtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB5b3Uga2V5dXAgdGhlIGtleSB5b3Ugc3BlY2lmaWVkIGluIHRvZ2dsZUNvbnRpbnVlU2VsZWN0LCB0aGUga2V5dXAgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBrZXl1cFxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgKlxuICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICogICB0b2dnbGVDb250aW51ZVNlbGVjdDogXCJzaGlmdFwiO1xuICAgICAgICogICBrZXlDb250YWluZXI6IHdpbmRvdyxcbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIHNlbGVjdG8ub24oXCJrZXlkb3duXCIsICgpID0+IHtcbiAgICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5idXR0b25cIikuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogfSkub24oXCJrZXl1cFwiLCAoKSA9PiB7XG4gICAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMuZW1pdChcImtleXVwXCIsIHt9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX29uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy50b2dnbGVDb250aW51ZVNlbGVjdCAmJiBfdGhpcy5jb250aW51ZVNlbGVjdCkge1xuICAgICAgICBfdGhpcy5jb250aW51ZVNlbGVjdCA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzLmVtaXQoXCJrZXl1cFwiLCB7fSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLl9vbkRvY3VtZW50U2VsZWN0U3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFfdGhpcy5nZXN0by5pc0ZsYWcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkcmFnQ29udGFpbmVyID0gX3RoaXMuZHJhZ0NvbnRhaW5lcjtcblxuICAgICAgaWYgKGRyYWdDb250YWluZXIgPT09IHdpbmRvdykge1xuICAgICAgICBkcmFnQ29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGFpbmVycyA9IGRyYWdDb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50ID8gW2RyYWdDb250YWluZXJdIDogW10uc2xpY2UuY2FsbChkcmFnQ29udGFpbmVyKTtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIGNvbnRhaW5lcnMuc29tZShmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChjb250YWluZXIgPT09IHRhcmdldCB8fCBjb250YWluZXIuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLnRhcmdldCA9IG9wdGlvbnMucG9ydGFsQ29udGFpbmVyO1xuICAgIF90aGlzLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgX3RoaXMub3B0aW9ucyA9IF9fYXNzaWduKHtcbiAgICAgIHBvcnRhbENvbnRhaW5lcjogbnVsbCxcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIGRyYWdDb250YWluZXI6IG51bGwsXG4gICAgICBzZWxlY3RhYmxlVGFyZ2V0czogW10sXG4gICAgICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAgc2VsZWN0RnJvbUluc2lkZTogdHJ1ZSxcbiAgICAgIGNsaWNrQnlTZWxlY3RFbmQ6IGZhbHNlLFxuICAgICAgaGl0UmF0ZTogMTAwLFxuICAgICAgY29udGludWVTZWxlY3Q6IGZhbHNlLFxuICAgICAgdG9nZ2xlQ29udGludWVTZWxlY3Q6IG51bGwsXG4gICAgICBrZXlDb250YWluZXI6IG51bGwsXG4gICAgICBzY3JvbGxPcHRpb25zOiB1bmRlZmluZWQsXG4gICAgICBjaGVja0lucHV0OiBmYWxzZSxcbiAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcbiAgICAgIGJvdW5kQ29udGFpbmVyOiBmYWxzZSxcbiAgICAgIHByZXZlbnREcmFnRnJvbUluc2lkZTogdHJ1ZSxcbiAgICAgIGRyYWdDb25kaXRpb246IG51bGwsXG4gICAgICByb290Q29udGFpbmVyOiBudWxsLFxuICAgICAgZ2V0RWxlbWVudFJlY3Q6IGdldERlZmF1bHRFbGVtZW50UmVjdCxcbiAgICAgIGNzcE5vbmNlOiBcIlwiLFxuICAgICAgcmF0aW86IDBcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIF90aGlzLmluaXRFbGVtZW50KCk7XG5cbiAgICBfdGhpcy5pbml0RHJhZ1Njcm9sbCgpO1xuXG4gICAgX3RoaXMuc2V0S2V5Q29udHJvbGxlcigpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBZb3UgY2FuIHNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhcmdldHMuXG4gICAqXG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBTZWxlY3RvLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnNldFNlbGVjdGVkVGFyZ2V0cyA9IGZ1bmN0aW9uIChzZWxlY3RlZFRhcmdldHMpIHtcbiAgICB0aGlzLnNlbGVjdGVkVGFyZ2V0cyA9IHNlbGVjdGVkVGFyZ2V0cztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFlvdSBjYW4gZ2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFyZ2V0cy5cbiAgICovXG5cblxuICBfX3Byb3RvLmdldFNlbGVjdGVkVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZFRhcmdldHM7XG4gIH07XG5cbiAgX19wcm90by5zZXRLZXlDb250YWluZXIgPSBmdW5jdGlvbiAoa2V5Q29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGRpZmZWYWx1ZShvcHRpb25zLmtleUNvbnRhaW5lciwga2V5Q29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvcHRpb25zLmtleUNvbnRhaW5lciA9IGtleUNvbnRhaW5lcjtcblxuICAgICAgX3RoaXMuc2V0S2V5Q29udHJvbGxlcigpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0VG9nZ2xlQ29udGludWVTZWxlY3QgPSBmdW5jdGlvbiAodG9nZ2xlQ29udGludWVTZWxlY3QpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgZGlmZlZhbHVlKG9wdGlvbnMudG9nZ2xlQ29udGludWVTZWxlY3QsIHRvZ2dsZUNvbnRpbnVlU2VsZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICBvcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0ID0gdG9nZ2xlQ29udGludWVTZWxlY3Q7XG5cbiAgICAgIF90aGlzLnNldEtleUV2ZW50KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5zZXRQcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuZ2VzdG8ub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9IHZhbHVlO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0Q2hlY2tJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuZ2VzdG8ub3B0aW9ucy5jaGVja0lucHV0ID0gdmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBgT25EcmFnU3RhcnRgIGlzIHRyaWdnZXJlZCBieSBhbiBleHRlcm5hbCBldmVudC5cbiAgICogQHBhcmFtIC0gZXh0ZXJuYWwgZXZlbnRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICpcbiAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKCk7XG4gICAqXG4gICAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgKiAgIHNlbGVjdG8udHJpZ2dlckRyYWdTdGFydChlKTtcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by50cmlnZ2VyRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB0aGlzLmdlc3RvLnRyaWdnZXJEcmFnU3RhcnQoZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95IGVsZW1lbnRzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9mZigpO1xuICAgIHRoaXMua2V5Y29uICYmIHRoaXMua2V5Y29uLmRlc3Ryb3koKTtcbiAgICB0aGlzLmdlc3RvLnVuc2V0KCk7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQuZGVzdHJveSgpO1xuICAgIHJlbW92ZUV2ZW50KGRvY3VtZW50LCBcInNlbGVjdHN0YXJ0XCIsIHRoaXMuX29uRG9jdW1lbnRTZWxlY3RTdGFydCk7XG4gICAgdGhpcy5rZXljb24gPSBudWxsO1xuICAgIHRoaXMuZ2VzdG8gPSBudWxsO1xuICAgIHRoaXMuaW5qZWN0UmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gIH07XG5cbiAgX19wcm90by5nZXRFbGVtZW50UG9pbnRzID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBnZXRFbGVtZW50UmVjdCA9IHRoaXMuZ2V0RWxlbWVudFJlY3QgfHwgZ2V0RGVmYXVsdEVsZW1lbnRSZWN0O1xuICAgIHZhciBpbmZvID0gZ2V0RWxlbWVudFJlY3QodGFyZ2V0KTtcbiAgICB2YXIgcG9pbnRzID0gW2luZm8ucG9zMSwgaW5mby5wb3MyLCBpbmZvLnBvczQsIGluZm8ucG9zM107XG5cbiAgICBpZiAoZ2V0RWxlbWVudFJlY3QgIT09IGdldERlZmF1bHRFbGVtZW50UmVjdCkge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gZml0UG9pbnRzKHBvaW50cywgcmVjdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBhbGwgZWxlbWVudHMgc2V0IGluIGBzZWxlY3RhYmxlVGFyZ2V0c2AuXG4gICAqL1xuXG5cbiAgX19wcm90by5nZXRTZWxlY3RhYmxlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGVjdGFibGVFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmIChpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHNlbGVjdGFibGVFbGVtZW50cy5wdXNoKHRhcmdldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KSk7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgc2VsZWN0YWJsZUVsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZWN0YWJsZUVsZW1lbnRzO1xuICB9O1xuICAvKipcbiAgICogSWYgc2Nyb2xsIG9jY3VycyBkdXJpbmcgZHJhZ2dpbmcsIHlvdSBjYW4gbWFudWFsbHkgY2FsbCB0aGlzIG1ldGhvZCB0byBjaGVjayB0aGUgcG9zaXRpb24gYWdhaW4uXG4gICAqL1xuXG5cbiAgX19wcm90by5jaGVja1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG5cbiAgICBpZiAoIXRoaXMuZ2VzdG8uaXNGbGFnKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IHRoaXMuc2Nyb2xsT3B0aW9uczsgLy8gSWYgaXQgaXMgYSBzY3JvbGxpbmcgcG9zaXRpb24sIHBhc3MgZHJhZ1xuXG4gICAgKChfYSA9IHNjcm9sbE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWluZXIpICYmIHRoaXMuZHJhZ1Njcm9sbC5jaGVja1Njcm9sbChfX2Fzc2lnbih7XG4gICAgICBpbnB1dEV2ZW50OiB0aGlzLmdlc3RvLmdldEN1cnJlbnRFdmVudCgpXG4gICAgfSwgc2Nyb2xsT3B0aW9ucykpO1xuICB9O1xuICAvKipcbiAgICogRmluZCBmb3Igc2VsZWN0YWJsZVRhcmdldHMgYWdhaW4gZHVyaW5nIGRyYWcgZXZlbnRcbiAgICovXG5cblxuICBfX3Byb3RvLmZpbmRTZWxlY3RhYmxlVGFyZ2V0cyA9IGZ1bmN0aW9uIChkYXRhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoZGF0YXMgPT09IHZvaWQgMCkge1xuICAgICAgZGF0YXMgPSB0aGlzLmdlc3RvLmdldEV2ZW50RGF0YXMoKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0YWJsZVRhcmdldHMgPSB0aGlzLmdldFNlbGVjdGFibGVFbGVtZW50cygpO1xuICAgIHZhciBzZWxlY3RhYmxlUG9pbnRzID0gc2VsZWN0YWJsZVRhcmdldHMubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5nZXRFbGVtZW50UG9pbnRzKHRhcmdldCk7XG4gICAgfSk7XG4gICAgZGF0YXMuc2VsZWN0YWJsZVRhcmdldHMgPSBzZWxlY3RhYmxlVGFyZ2V0cztcbiAgICBkYXRhcy5zZWxlY3RhYmxlUG9pbnRzID0gc2VsZWN0YWJsZVBvaW50cztcbiAgfTtcbiAgLyoqXG4gICAqIEV4dGVybmFsIGNsaWNrIG9yIG1vdXNlIGV2ZW50cyBjYW4gYmUgYXBwbGllZCB0byB0aGUgc2VsZWN0by5cbiAgICogQHBhcmFtcyAtIEV4dGVuYWwgY2xpY2sgb3IgbW91c2UgZXZlbnRcbiAgICogQHBhcmFtcyAtIFNwZWNpZnkgdGhlIGNsaWNrZWQgdGFyZ2V0IGRpcmVjdGx5LlxuICAgKi9cblxuXG4gIF9fcHJvdG8uY2xpY2tUYXJnZXQgPSBmdW5jdGlvbiAoZSwgY2xpY2tlZFRhcmdldCkge1xuICAgIHZhciBfYSA9IGdldENsaWVudChlKSxcbiAgICAgICAgY2xpZW50WCA9IF9hLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBfYS5jbGllbnRZO1xuXG4gICAgdmFyIGRyYWdFdmVudCA9IHtcbiAgICAgIGRhdGFzOiB7XG4gICAgICAgIHNlbGVjdEZsYWc6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGNsaWVudFksXG4gICAgICBpbnB1dEV2ZW50OiBlLFxuICAgICAgaXNDbGljazogdHJ1ZSxcbiAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fb25EcmFnU3RhcnQoZHJhZ0V2ZW50LCBjbGlja2VkVGFyZ2V0KSkge1xuICAgICAgdGhpcy5fb25EcmFnRW5kKGRyYWdFdmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19wcm90by5zZXRLZXlDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAga2V5Q29udGFpbmVyID0gX2Eua2V5Q29udGFpbmVyLFxuICAgICAgICB0b2dnbGVDb250aW51ZVNlbGVjdCA9IF9hLnRvZ2dsZUNvbnRpbnVlU2VsZWN0O1xuXG4gICAgaWYgKHRoaXMua2V5Y29uKSB7XG4gICAgICB0aGlzLmtleWNvbi5kZXN0cm95KCk7XG4gICAgICB0aGlzLmtleWNvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRvZ2dsZUNvbnRpbnVlU2VsZWN0KSB7XG4gICAgICB0aGlzLmtleWNvbiA9IG5ldyBLZXlDb250cm9sbGVyKGtleUNvbnRhaW5lciB8fCB3aW5kb3cpO1xuICAgICAgdGhpcy5rZXljb24ua2V5ZG93bih0aGlzLl9vbktleURvd24pLmtleXVwKHRoaXMuX29uS2V5VXApLm9uKFwiYmx1clwiLCB0aGlzLl9vbkJsdXIpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLnNldEtleUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b2dnbGVDb250aW51ZVNlbGVjdCA9IHRoaXMub3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdDtcblxuICAgIGlmICghdG9nZ2xlQ29udGludWVTZWxlY3QgfHwgdGhpcy5rZXljb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldEtleUNvbnRyb2xsZXIoKTtcbiAgfTtcblxuICBfX3Byb3RvLmluaXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFyZ2V0ID0gY3JlYXRlRWxlbWVudChoKFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogQ0xBU1NfTkFNRVxuICAgIH0pLCB0aGlzLnRhcmdldCwgdGhpcy5jb250YWluZXIpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGRyYWdDb250YWluZXIgPSBfYS5kcmFnQ29udGFpbmVyLFxuICAgICAgICBjaGVja0lucHV0ID0gX2EuY2hlY2tJbnB1dCxcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSBfYS5wcmV2ZW50RGVmYXVsdDtcbiAgICB0aGlzLmRyYWdDb250YWluZXIgPSB0eXBlb2YgZHJhZ0NvbnRhaW5lciA9PT0gXCJzdHJpbmdcIiA/IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkcmFnQ29udGFpbmVyKSkgOiBkcmFnQ29udGFpbmVyIHx8IHRoaXMudGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgdGhpcy5nZXN0byA9IG5ldyBHZXN0byh0aGlzLmRyYWdDb250YWluZXIsIHtcbiAgICAgIGNoZWNrV2luZG93Qmx1cjogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogd2luZG93LFxuICAgICAgY2hlY2tJbnB1dDogY2hlY2tJbnB1dCxcbiAgICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdFxuICAgIH0pLm9uKHtcbiAgICAgIGRyYWdTdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gICAgICBkcmFnOiB0aGlzLl9vbkRyYWcsXG4gICAgICBkcmFnRW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgICB9KTtcbiAgICBhZGRFdmVudChkb2N1bWVudCwgXCJzZWxlY3RzdGFydFwiLCB0aGlzLl9vbkRvY3VtZW50U2VsZWN0U3RhcnQpO1xuICAgIHRoaXMuaW5qZWN0UmVzdWx0ID0gaW5qZWN0b3IuaW5qZWN0KHRhcmdldCwge1xuICAgICAgbm9uY2U6IHRoaXMub3B0aW9ucy5jc3BOb25jZVxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uaGl0VGVzdCA9IGZ1bmN0aW9uIChzZWxlY3RSZWN0LCBjbGllbnRYLCBjbGllbnRZLCB0YXJnZXRzLCBzZWxlY3RhYmxlUG9pbnRzKSB7XG4gICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBoaXRSYXRlID0gX2EuaGl0UmF0ZSxcbiAgICAgICAgc2VsZWN0QnlDbGljayA9IF9hLnNlbGVjdEJ5Q2xpY2s7XG4gICAgdmFyIGxlZnQgPSBzZWxlY3RSZWN0LmxlZnQsXG4gICAgICAgIHRvcCA9IHNlbGVjdFJlY3QudG9wLFxuICAgICAgICByaWdodCA9IHNlbGVjdFJlY3QucmlnaHQsXG4gICAgICAgIGJvdHRvbSA9IHNlbGVjdFJlY3QuYm90dG9tO1xuICAgIHZhciByZWN0UG9pbnRzID0gW1tsZWZ0LCB0b3BdLCBbcmlnaHQsIHRvcF0sIFtyaWdodCwgYm90dG9tXSwgW2xlZnQsIGJvdHRvbV1dO1xuICAgIHJldHVybiB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkge1xuICAgICAgdmFyIHBvaW50cyA9IHNlbGVjdGFibGVQb2ludHNbaV07XG4gICAgICB2YXIgaW5BcmVhID0gaXNJbnNpZGUoW2NsaWVudFgsIGNsaWVudFldLCBwb2ludHMpO1xuXG4gICAgICBpZiAoc2VsZWN0QnlDbGljayAmJiBpbkFyZWEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdmVybGFwUG9pbnRzID0gZ2V0T3ZlcmxhcFBvaW50cyhyZWN0UG9pbnRzLCBwb2ludHMpO1xuXG4gICAgICBpZiAoIW92ZXJsYXBQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG92ZXJsYXBTaXplID0gZ2V0QXJlYVNpemUob3ZlcmxhcFBvaW50cyk7XG4gICAgICB2YXIgdGFyZ2V0U2l6ZSA9IGdldEFyZWFTaXplKHBvaW50cyk7XG4gICAgICB2YXIgaGl0UmF0ZVZhbHVlID0gc3BsaXRVbml0KFwiXCIgKyBoaXRSYXRlKTtcblxuICAgICAgaWYgKGhpdFJhdGVWYWx1ZS51bml0ID09PSBcInB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXBTaXplID49IGhpdFJhdGVWYWx1ZS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYXRlID0gYmV0d2VlbihNYXRoLnJvdW5kKG92ZXJsYXBTaXplIC8gdGFyZ2V0U2l6ZSAqIDEwMCksIDAsIDEwMCk7XG4gICAgICAgIHJldHVybiByYXRlID49IE1hdGgubWluKDEwMCwgaGl0UmF0ZVZhbHVlLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmluaXREcmFnU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRyYWdTY3JvbGwub24oXCJzY3JvbGxcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gX2EuY29udGFpbmVyLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcblxuICAgICAgX3RoaXMuZW1pdChcInNjcm9sbFwiLCB7XG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgfSk7XG4gICAgfSkub24oXCJtb3ZlXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIG9mZnNldFggPSBfYS5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfYS5vZmZzZXRZLFxuICAgICAgICAgIGlucHV0RXZlbnQgPSBfYS5pbnB1dEV2ZW50O1xuICAgICAgdmFyIGdlc3RvID0gX3RoaXMuZ2VzdG87XG5cbiAgICAgIGlmICghZ2VzdG8gfHwgIWdlc3RvLmlzRmxhZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGFzID0gX3RoaXMuZ2VzdG8uZ2V0RXZlbnREYXRhcygpO1xuXG4gICAgICB2YXIgYm91bmRBcmVhID0gZGF0YXMuYm91bmRBcmVhO1xuICAgICAgZGF0YXMuc3RhcnRYIC09IG9mZnNldFg7XG4gICAgICBkYXRhcy5zdGFydFkgLT0gb2Zmc2V0WTtcbiAgICAgIGRhdGFzLnNlbGVjdGFibGVQb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICBwb3NbMF0gLT0gb2Zmc2V0WDtcbiAgICAgICAgICBwb3NbMV0gLT0gb2Zmc2V0WTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJvdW5kQXJlYS5sZWZ0IC09IG9mZnNldFg7XG4gICAgICBib3VuZEFyZWEucmlnaHQgLT0gb2Zmc2V0WDtcbiAgICAgIGJvdW5kQXJlYS50b3AgLT0gb2Zmc2V0WTtcbiAgICAgIGJvdW5kQXJlYS5ib3R0b20gLT0gb2Zmc2V0WTtcblxuICAgICAgX3RoaXMuZ2VzdG8uc2Nyb2xsQnkob2Zmc2V0WCwgb2Zmc2V0WSwgaW5wdXRFdmVudC5pbnB1dEV2ZW50LCBmYWxzZSk7XG5cbiAgICAgIF90aGlzLl9jaGVja1NlbGVjdGVkKF90aGlzLmdlc3RvLmdldEN1cnJlbnRFdmVudCgpKTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnNlbGVjdCA9IGZ1bmN0aW9uIChwcmV2U2VsZWN0ZWRUYXJnZXRzLCBzZWxlY3RlZFRhcmdldHMsIHJlY3QsIGlucHV0RXZlbnQsIGlzU3RhcnQpIHtcbiAgICB2YXIgX2EgPSBkaWZmKHByZXZTZWxlY3RlZFRhcmdldHMsIHNlbGVjdGVkVGFyZ2V0cyksXG4gICAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgICBwcmV2TGlzdCA9IF9hLnByZXZMaXN0LFxuICAgICAgICBsaXN0ID0gX2EubGlzdDtcblxuICAgIHRoaXMuc2VsZWN0ZWRUYXJnZXRzID0gc2VsZWN0ZWRUYXJnZXRzO1xuXG4gICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0aGUgc2VsZWN0KGRyYWcpIHN0YXJ0cywgdGhlIHNlbGVjdFN0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgKiBAZXZlbnQgc2VsZWN0U3RhcnRcbiAgICAgICAqIEBwYXJhbSB7U2VsZWN0by5PblNlbGVjdH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2VsZWN0U3RhcnQgZXZlbnRcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICpcbiAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICAgKiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBzZWxlY3RvLm9uKFwic2VsZWN0U3RhcnRcIiwgZSA9PiB7XG4gICAgICAgKiAgIGUuYWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqICAgZS5yZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiB9KS5vbihcInNlbGVjdEVuZFwiLCBlID0+IHtcbiAgICAgICAqICAgZS5hZnRlckFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUuYWZ0ZXJSZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiB9KTtcbiAgICAgICAqL1xuICAgICAgdGhpcy5lbWl0KFwic2VsZWN0U3RhcnRcIiwge1xuICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRUYXJnZXRzLFxuICAgICAgICBhZGRlZDogYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgICAgICAgfSksXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gICAgICAgIH0pLFxuICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWRkZWQubGVuZ3RoIHx8IHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIHNlbGVjdCBpbiByZWFsIHRpbWUsIHRoZSBzZWxlY3QgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBzZWxlY3RcbiAgICAgICAqIEBwYXJhbSB7U2VsZWN0by5PblNlbGVjdH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2VsZWN0IGV2ZW50XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgICAqXG4gICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICAgKiAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogc2VsZWN0by5vbihcInNlbGVjdFwiLCBlID0+IHtcbiAgICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqIH0pO1xuICAgICAgICovXG4gICAgICB0aGlzLmVtaXQoXCJzZWxlY3RcIiwge1xuICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRUYXJnZXRzLFxuICAgICAgICBhZGRlZDogYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgICAgICAgfSksXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gICAgICAgIH0pLFxuICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5zZWxlY3RFbmQgPSBmdW5jdGlvbiAoc3RhcnRTZWxlY3RlZFRhcmdldHMsIHN0YXJ0UGFzc2VkVGFyZ2V0cywgcmVjdCwgZSkge1xuICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LFxuICAgICAgICBpc0RvdWJsZSA9IGUuaXNEb3VibGU7XG5cbiAgICB2YXIgX2EgPSBkaWZmKHN0YXJ0U2VsZWN0ZWRUYXJnZXRzLCB0aGlzLnNlbGVjdGVkVGFyZ2V0cyksXG4gICAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgICBwcmV2TGlzdCA9IF9hLnByZXZMaXN0LFxuICAgICAgICBsaXN0ID0gX2EubGlzdDtcblxuICAgIHZhciBfYiA9IGRpZmYoc3RhcnRQYXNzZWRUYXJnZXRzLCB0aGlzLnNlbGVjdGVkVGFyZ2V0cyksXG4gICAgICAgIGFmdGVyQWRkZWQgPSBfYi5hZGRlZCxcbiAgICAgICAgYWZ0ZXJSZW1vdmVkID0gX2IucmVtb3ZlZCxcbiAgICAgICAgYWZ0ZXJQcmV2TGlzdCA9IF9iLnByZXZMaXN0LFxuICAgICAgICBhZnRlckxpc3QgPSBfYi5saXN0O1xuXG4gICAgdmFyIHR5cGUgPSBpbnB1dEV2ZW50ICYmIGlucHV0RXZlbnQudHlwZTtcbiAgICB2YXIgaXNEcmFnU3RhcnQgPSB0eXBlID09PSBcIm1vdXNlZG93blwiIHx8IHR5cGUgPT09IFwidG91Y2hzdGFydFwiO1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHNlbGVjdChkcmFnRW5kIG9yIGNsaWNrKSBlbmRzLCB0aGUgc2VsZWN0RW5kIGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAqIEBldmVudCBzZWxlY3RFbmRcbiAgICAgKiBAcGFyYW0ge1NlbGVjdG8uT25TZWxlY3RFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNlbGVjdEVuZCBldmVudFxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzZWxlY3RvLm9uKFwic2VsZWN0U3RhcnRcIiwgZSA9PiB7XG4gICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICogICB9KTtcbiAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAqICAgfSk7XG4gICAgICogfSkub24oXCJzZWxlY3RFbmRcIiwgZSA9PiB7XG4gICAgICogICBlLmFmdGVyQWRkZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqICAgZS5hZnRlclJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgdGhpcy5lbWl0KFwic2VsZWN0RW5kXCIsIHtcbiAgICAgIHNlbGVjdGVkOiB0aGlzLnNlbGVjdGVkVGFyZ2V0cyxcbiAgICAgIGFkZGVkOiBhZGRlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgICAgIH0pLFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIGFmdGVyQWRkZWQ6IGFmdGVyQWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gYWZ0ZXJMaXN0W2luZGV4XTtcbiAgICAgIH0pLFxuICAgICAgYWZ0ZXJSZW1vdmVkOiBhZnRlclJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gYWZ0ZXJQcmV2TGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIGlzRHJhZ1N0YXJ0OiBpc0RyYWdTdGFydCxcbiAgICAgIGlzQ2xpY2s6ICEhZS5pc0NsaWNrLFxuICAgICAgaXNEb3VibGU6ICEhaXNEb3VibGUsXG4gICAgICByZWN0OiByZWN0LFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudFxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2NoZWNrU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZSwgcmVjdCkge1xuICAgIGlmIChyZWN0ID09PSB2b2lkIDApIHtcbiAgICAgIHJlY3QgPSBnZXRSZWN0KGUsIHRoaXMub3B0aW9ucy5yYXRpbyk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcyxcbiAgICAgICAgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcbiAgICB2YXIgdG9wID0gcmVjdC50b3AsXG4gICAgICAgIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICAgIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgdmFyIHNlbGVjdEZsYWcgPSBkYXRhcy5zZWxlY3RGbGFnO1xuICAgIHZhciBjb250YWluZXJYID0gZGF0YXMuY29udGFpbmVyWCxcbiAgICAgICAgY29udGFpbmVyWSA9IGRhdGFzLmNvbnRhaW5lclksXG4gICAgICAgIHNjYWxlTWF0cml4ID0gZGF0YXMuc2NhbGVNYXRyaXg7XG4gICAgdmFyIG9mZnNldFBvcyA9IGNhbGN1bGF0ZU1hdHJpeERpc3Qoc2NhbGVNYXRyaXgsIFtsZWZ0IC0gY29udGFpbmVyWCwgdG9wIC0gY29udGFpbmVyWV0pO1xuICAgIHZhciBvZmZzZXRTaXplID0gY2FsY3VsYXRlTWF0cml4RGlzdChzY2FsZU1hdHJpeCwgW3dpZHRoLCBoZWlnaHRdKTtcbiAgICB2YXIgcHJldlNlbGVjdGVkVGFyZ2V0cyA9IFtdO1xuICAgIHZhciBzZWxlY3RlZFRhcmdldHMgPSBbXTtcblxuICAgIGlmIChzZWxlY3RGbGFnKSB7XG4gICAgICB0aGlzLnRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IFwiZGlzcGxheTogYmxvY2s7XCIgKyBcImxlZnQ6MHB4O3RvcDowcHg7cG9pbnRlci1ldmVudHM6IG5vbmU7XCIgKyAoXCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZShcIiArIG9mZnNldFBvc1swXSArIFwicHgsIFwiICsgb2Zmc2V0UG9zWzFdICsgXCJweCk7XCIpICsgKFwid2lkdGg6XCIgKyBvZmZzZXRTaXplWzBdICsgXCJweDtoZWlnaHQ6XCIgKyBvZmZzZXRTaXplWzFdICsgXCJweDtcIik7XG4gICAgICB2YXIgcGFzc2VkVGFyZ2V0cyA9IHRoaXMuaGl0VGVzdChyZWN0LCBkYXRhcy5zdGFydFgsIGRhdGFzLnN0YXJ0WSwgZGF0YXMuc2VsZWN0YWJsZVRhcmdldHMsIGRhdGFzLnNlbGVjdGFibGVQb2ludHMpO1xuICAgICAgcHJldlNlbGVjdGVkVGFyZ2V0cyA9IHRoaXMuc2VsZWN0ZWRUYXJnZXRzO1xuICAgICAgc2VsZWN0ZWRUYXJnZXRzID0gcGFzc1RhcmdldHMoZGF0YXMuc3RhcnRQYXNzZWRUYXJnZXRzLCBwYXNzZWRUYXJnZXRzKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRUYXJnZXRzID0gc2VsZWN0ZWRUYXJnZXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBkcmFnLCB0aGUgZHJhZyBldmVudCBpcyBjYWxsZWQuXG4gICAgICogQ2FsbCB0aGUgc3RvcCAoKSBmdW5jdGlvbiBpZiB5b3UgaGF2ZSBhIHNwZWNpZmljIGVsZW1lbnQgb3IgZG9uJ3Qgd2FudCB0byByYWlzZSBhIHNlbGVjdFxuICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICogQGV2ZW50IGRyYWdcbiAgICAgKiBAcGFyYW0ge09uRHJhZ30gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZyBldmVudFxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzZWxlY3RvLm9uKFwiZHJhZ1wiLCBlID0+IHtcbiAgICAgKiAgIGUuc3RvcCgpO1xuICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAqICAgfSk7XG4gICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqL1xuXG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5lbWl0KFwiZHJhZ1wiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIGlzU2VsZWN0OiBzZWxlY3RGbGFnLFxuICAgICAgcmVjdDogcmVjdFxuICAgIH0pKTtcblxuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IFwiZGlzcGxheTogbm9uZTtcIjtcbiAgICAgIGUuc3RvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RGbGFnKSB7XG4gICAgICB0aGlzLnNlbGVjdChwcmV2U2VsZWN0ZWRUYXJnZXRzLCBzZWxlY3RlZFRhcmdldHMsIHJlY3QsIGlucHV0RXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLl9zYW1lQ29tYmlLZXkgPSBmdW5jdGlvbiAoZSwgaXNLZXl1cCkge1xuICAgIHZhciB0b2dnbGVDb250aW51ZVNlbGVjdCA9IFtdLmNvbmNhdCh0aGlzLm9wdGlvbnMudG9nZ2xlQ29udGludWVTZWxlY3QpO1xuICAgIHZhciBjb21iaSA9IGdldENvbWJpKGUuaW5wdXRFdmVudCwgZS5rZXkpO1xuICAgIHZhciB0b2dnbGVLZXlzID0gaXNBcnJheSh0b2dnbGVDb250aW51ZVNlbGVjdFswXSkgPyB0b2dnbGVDb250aW51ZVNlbGVjdCA6IFt0b2dnbGVDb250aW51ZVNlbGVjdF07XG5cbiAgICBpZiAoaXNLZXl1cCkge1xuICAgICAgdmFyIHNpbmdsZUtleV8xID0gZS5rZXk7XG4gICAgICByZXR1cm4gdG9nZ2xlS2V5cy5zb21lKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHJldHVybiBrZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkgPT09IHNpbmdsZUtleV8xO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0b2dnbGVLZXlzLnNvbWUoZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpLmluZGV4T2Yoa2V5KSA+IC0xO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5fZmluZEVsZW1lbnQgPSBmdW5jdGlvbiAoY2xpY2tlZFRhcmdldCwgc2VsZWN0YWJsZVRhcmdldHMpIHtcbiAgICB2YXIgcG9pbnRUYXJnZXQgPSBjbGlja2VkVGFyZ2V0O1xuXG4gICAgd2hpbGUgKHBvaW50VGFyZ2V0KSB7XG4gICAgICBpZiAoc2VsZWN0YWJsZVRhcmdldHMuaW5kZXhPZihwb2ludFRhcmdldCkgPiAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9pbnRUYXJnZXQgPSBwb2ludFRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludFRhcmdldDtcbiAgfTtcblxuICBTZWxlY3RvID0gX19kZWNvcmF0ZShbUHJvcGVydGllcyhQUk9QRVJUSUVTLCBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0eSkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBjYW1lbGl6ZShcInNldCBcIiArIHByb3BlcnR5KTtcblxuICAgIGlmIChwcm90b3R5cGVbc2V0dGVyXSkge1xuICAgICAgYXR0cmlidXRlcy5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpc1tzZXR0ZXJdKHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHJvcGVydHksIGF0dHJpYnV0ZXMpO1xuICB9KV0sIFNlbGVjdG8pO1xuICByZXR1cm4gU2VsZWN0bztcbn0oRXZlbnRFbWl0dGVyKTtcblxudmFyIFNlbGVjdG8kMSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTZWxlY3RvLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdG8oKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNlbGVjdG87XG59KFNlbGVjdG8pO1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RvJDE7XG5leHBvcnQgeyBDTEFTU19OQU1FLCBFVkVOVFMsIE1FVEhPRFMsIE9QVElPTlMsIE9QVElPTl9UWVBFUywgUFJPUEVSVElFUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0by5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJWYWx1ZVBpY2tlciIsIkFkZExheWVyQnV0dG9uIiwib25DaGFuZ2UiLCJvcHRpb25zIiwibGFiZWwiLCJEcmFnRHJvcENvbnRleHQiLCJEcmFnZ2FibGUiLCJEcm9wcGFibGUiLCJjc3MiLCJjeCIsIkljb24iLCJJY29uQnV0dG9uIiwic3R5bGVzRmFjdG9yeSIsImNvbmZpZyIsIkxheWVyTmFtZSIsIkxheWVyRHJhZ0Ryb3BMaXN0IiwibGF5ZXJzIiwiZ2V0TGF5ZXJJbmZvIiwib25EcmFnRW5kIiwib25TZWxlY3QiLCJvbkRlbGV0ZSIsIm9uRHVwbGljYXRlIiwiaXNHcm91cCIsInNlbGVjdGlvbiIsImV4Y2x1ZGVCYXNlTGF5ZXIiLCJvbk5hbWVDaGFuZ2UiLCJ2ZXJpZnlMYXllck5hbWVVbmlxdWVuZXNzIiwic3R5bGUiLCJzdHlsZXMiLCJ0aGVtZSIsImdldFJvd1N0eWxlIiwiaXNTZWxlY3RlZCIsInJvdyIsInNlbCIsInByb3ZpZGVkIiwic25hcHNob3QiLCJkcm9wcGFibGVQcm9wcyIsImlubmVyUmVmIiwicm93cyIsImxhc3RMYXllckluZGV4Iiwic2hvdWxkUmVuZGVyRHJhZ0ljb25MZW5ndGhUaHJlc2hvbGQiLCJpIiwibGVuZ3RoIiwiZWxlbWVudCIsInVpZCIsImdldE5hbWUiLCJCb29sZWFuIiwiaW5jbHVkZXMiLCJwdXNoIiwiZHJhZ2dhYmxlUHJvcHMiLCJkcmFnSGFuZGxlUHJvcHMiLCJ2IiwidW5kZWZpbmVkIiwidGV4dFdyYXBwZXIiLCJhY3Rpb25JY29uIiwiZHJhZ0ljb24iLCJwbGFjZWhvbGRlciIsImRlZmF1bHRQcm9wcyIsIndyYXBwZXIiLCJzcGFjaW5nIiwibWQiLCJ4cyIsInNtIiwiYm9yZGVyIiwicmFkaXVzIiwiY29sb3JzIiwiYmcyIiwiZm9ybUlucHV0SGVpZ2h0IiwiZm9ybUlucHV0Qm9yZGVyIiwiZm9ybUlucHV0Qm9yZGVySG92ZXIiLCJmb3JtSW5wdXRCb3JkZXJBY3RpdmUiLCJ0ZXh0V2VhayIsInRleHQiLCJ0eXBlV3JhcHBlciIsInRleHRCbHVlIiwidXNlU3RhdGUiLCJJbnB1dCIsIkZpZWxkVmFsaWRhdGlvbk1lc3NhZ2UiLCJ1c2VTdHlsZXMiLCJuYW1lIiwiZ2V0U3R5bGVzIiwiaXNFZGl0aW5nIiwic2V0SXNFZGl0aW5nIiwidmFsaWRhdGlvbkVycm9yIiwic2V0VmFsaWRhdGlvbkVycm9yIiwib25FZGl0TGF5ZXIiLCJldmVudCIsIm9uRW5kRWRpdE5hbWUiLCJuZXdOYW1lIiwib25JbnB1dENoYW5nZSIsImN1cnJlbnRUYXJnZXQiLCJ2YWx1ZSIsInRyaW0iLCJvbkVkaXRMYXllckJsdXIiLCJvbktleURvd24iLCJrZXkiLCJ0YXJnZXQiLCJvbkZvY3VzIiwic2VsZWN0IiwibGF5ZXJOYW1lV3JhcHBlciIsImxheWVyTmFtZSIsImxheWVyRWRpdEljb24iLCJsYXllck5hbWVJbnB1dCIsImJnMyIsImJvcmRlcjMiLCJ0eXBvZ3JhcGh5Iiwid2VpZ2h0Iiwic2VtaWJvbGQiLCJQdXJlQ29tcG9uZW50IiwiQnV0dG9uIiwiVGV4dERpbWVuc2lvbkVkaXRvciIsIkFQSUVkaXRvciIsImNhbGxBcGkiLCJCdXR0b25EaXNwbGF5IiwicmVuZGVyIiwiZGF0YSIsInByb3BzIiwib25DbGljayIsImFwaSIsImJ1dHRvbkl0ZW0iLCJpZCIsImRlc2NyaXB0aW9uIiwiZGlzcGxheSIsImRlZmF1bHRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJnZXROZXdPcHRpb25zIiwicHJlcGFyZURhdGEiLCJjdHgiLCJjZmciLCJnZXRUZXh0IiwicmVnaXN0ZXJPcHRpb25zVUkiLCJidWlsZGVyIiwiY2F0ZWdvcnkiLCJhZGRDdXN0b21FZGl0b3IiLCJwYXRoIiwiZWRpdG9yIiwidXNlU3R5bGVzMiIsIlNjYWxhckRpbWVuc2lvbkVkaXRvciIsIkRyb25lRnJvbnREaXNwbGF5IiwiZHJvbmVGcm9udFRyYW5zZm9ybVN0eWxlIiwicm9sbEFuZ2xlIiwiZHJvbmVGcm9udCIsInRyYW5zZm9ybSIsImRyb25lRnJvbnRJdGVtIiwiZ2V0U2NhbGFyIiwiRHJvbmVTaWRlRGlzcGxheSIsImRyb25lU2lkZVBpdGNoVHJhbnNmb3JtU3R5bGUiLCJwaXRjaEFuZ2xlIiwiZHJvbmVTaWRlIiwiZHJvbmVTaWRlSXRlbSIsIkRyb25lVG9wRGlzcGxheSIsImZSaWdodFJvdG9yQW5pbWF0aW9uIiwiZlJpZ2h0Um90b3JSUE0iLCJNYXRoIiwiYWJzIiwiZkxlZnRSb3RvckFuaW1hdGlvbiIsImZMZWZ0Um90b3JSUE0iLCJiUmlnaHRSb3RvckFuaW1hdGlvbiIsImJSaWdodFJvdG9yUlBNIiwiYkxlZnRSb3RvckFuaW1hdGlvbiIsImJMZWZ0Um90b3JSUE0iLCJkcm9uZVRvcFRyYW5zZm9ybVN0eWxlIiwieWF3QW5nbGUiLCJwcm9wZWxsZXIiLCJwcm9wZWxsZXJDVyIsImFuaW1hdGlvbiIsInByb3BlbGxlckNDVyIsImRyb25lVG9wSXRlbSIsIlJlc291cmNlRGltZW5zaW9uTW9kZSIsImdldFB1YmxpY09yQWJzb2x1dGVVcmwiLCJDb2xvckRpbWVuc2lvbkVkaXRvciIsIlJlc291cmNlRGltZW5zaW9uRWRpdG9yIiwiU1ZHIiwiaXNTdHJpbmciLCJzdmdTdHJva2VQYXRoQ2xhc3MiLCJJY29uRGlzcGxheSIsInN2Z1N0eWxlIiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiLCJpY29uSXRlbSIsInBsYWNlbWVudCIsIm1vZGUiLCJGaXhlZCIsImZpeGVkIiwiZ2V0UmVzb3VyY2UiLCJnZXRDb2xvciIsImNvbG9yIiwic2V0dGluZ3MiLCJyZXNvdXJjZVR5cGUiLCJkZWZhdWx0VmFsdWUiLCJhZGRTbGlkZXJJbnB1dCIsIm1pbiIsIm1heCIsInNob3dJZiIsIk5vdEZvdW5kRGlzcGxheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJub3RGb3VuZEl0ZW0iLCJBbGlnbiIsIlZBbGlnbiIsIlRleHRCb3hEaXNwbGF5IiwidGhlbWUyIiwiY29udGFpbmVyIiwic3BhbiIsInZhbGlnbiIsImFsaWduIiwic2l6ZSIsInRleHRCb3hJdGVtIiwiYmFja2dyb3VuZCIsIkxlZnQiLCJNaWRkbGUiLCJDZW50ZXIiLCJhZGRSYWRpbyIsIlJpZ2h0IiwiVG9wIiwiQm90dG9tIiwiYWRkTnVtYmVySW5wdXQiLCJXaW5kVHVyYmluZURpc3BsYXkiLCJ3aW5kVHVyYmluZUFuaW1hdGlvbiIsInJwbSIsImJsYWRlIiwid2luZFR1cmJpbmVJdGVtIiwiQ2FudmFzR3JvdXBPcHRpb25zIiwiUmVnaXN0cnkiLCJERUZBVUxUX0NBTlZBU19FTEVNRU5UX0NPTkZJRyIsInR5cGUiLCJjYW52YXNFbGVtZW50UmVnaXN0cnkiLCJCYWNrZ3JvdW5kSW1hZ2VTaXplIiwiY291bnRlciIsIkVsZW1lbnRTdGF0ZSIsImNvbnN0cnVjdG9yIiwiaXRlbSIsInBhcmVudCIsImRpdiIsImFuY2hvciIsImRlbHRhWCIsImRlbHRhIiwiZGVsdGFZIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiZGlyTFIiLCJkaXJlY3Rpb24iLCJkaXJUQiIsImZhbGxiYWNrTmFtZSIsIkRhdGUiLCJub3ciLCJzY2VuZSIsImdldFNjZW5lIiwiZ2V0TmV4dEVsZW1lbnROYW1lIiwiYnlOYW1lIiwic2V0IiwidHJhdiIsImlzUm9vdCIsInZhbGlkYXRlUGxhY2VtZW50IiwidyIsImgiLCJ1cGRhdGVTaXplIiwic2l6ZVN0eWxlIiwicG9zaXRpb24iLCJ1cGRhdGVEYXRhIiwicmV2SWQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJpbWFnZSIsImJhY2tncm91bmRJbWFnZSIsIkNvbnRhaW4iLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRSZXBlYXQiLCJDb3ZlciIsIk9yaWdpbmFsIiwiVGlsZSIsIkZpbGwiLCJib3JkZXJXaWR0aCIsImJvcmRlclN0eWxlIiwiYm9yZGVyQ29sb3IiLCJiYWNrZ3JvdW5kT3JpZ2luIiwiZGF0YVN0eWxlIiwidmlzaXQiLCJ2aXNpdG9yIiwiZ2V0SWZFeGlzdHMiLCJvbGROYW1lIiwic2F2ZSIsImRlbGV0ZSIsImdldFNhdmVNb2RlbCIsImluaXRFbGVtZW50IiwiVUlEIiwiTGF5ZXJBY3Rpb25JRCIsImNsb25lRGVlcCIsImdyb3VwSXRlbUR1bW15IiwiR3JvdXBTdGF0ZSIsImFjdGlvbiIsInVwZGF0ZU5hbWUiLCJEZWxldGUiLCJlbGVtZW50cyIsImZpbHRlciIsImUiLCJyZWluaXRpYWxpemVNb3ZlYWJsZSIsIkR1cGxpY2F0ZSIsImNvbnNvbGUiLCJsb2ciLCJvcHRzIiwiY29weSIsImNvbnRleHQiLCJjIiwiZWxlbSIsInJlb3JkZXIiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJyZXN1bHQiLCJBcnJheSIsImZyb20iLCJyZW1vdmVkIiwic3BsaWNlIiwiY2xlYXJDdXJyZW50U2VsZWN0aW9uIiwic2V0VGltZW91dCIsImluaXRNb3ZlYWJsZSIsIm1hcCIsIlJvb3RFbGVtZW50IiwiY2hhbmdlQ2FsbGJhY2siLCJyZXN0IiwiUmVwbGF5U3ViamVjdCIsIlN1YmplY3QiLCJmaXJzdCIsIk1vdmVhYmxlIiwiU2VsZWN0byIsImdldENvbG9yRGltZW5zaW9uRnJvbURhdGEiLCJnZXRTY2FsZURpbWVuc2lvbkZyb21EYXRhIiwiZ2V0UmVzb3VyY2VEaW1lbnNpb25Gcm9tRGF0YSIsImdldFRleHREaW1lbnNpb25Gcm9tRGF0YSIsImdldFNjYWxhckRpbWVuc2lvbkZyb21EYXRhIiwiU2NlbmUiLCJlbmFibGVFZGl0aW5nIiwib25TYXZlIiwiTWFwIiwiaWR4IiwiaGFzIiwiZ2V0U2NhbGUiLCJzY2FsZSIsInNjYWxhciIsInJlcyIsInJvb3QiLCJzdGFjayIsImN1cnJlbnRFbGVtZW50Iiwic2hpZnQiLCJuZXN0ZWRFbGVtZW50cyIsIm5lc3RlZEVsZW1lbnQiLCJ1bnNoaWZ0Iiwic2NlbmVDb250YWluZXIiLCJzZWxlY3RvIiwic2V0U2VsZWN0ZWRUYXJnZXRzIiwidGFyZ2V0cyIsInVwZGF0ZVNlbGVjdGlvbiIsIm1vdmVhYmxlIiwiZ3JvdXAiLCJuZXh0IiwicyIsInQiLCJmaW5kRWxlbWVudEJ5VGFyZ2V0Iiwicm9vdEVsZW1lbnRzIiwidGFyZ2V0RWxlbWVudHMiLCJkZXN0cm95U2VsZWN0byIsImFsbG93Q2hhbmdlcyIsImdlbmVyYXRlVGFyZ2V0RWxlbWVudHMiLCJkZXN0cm95Iiwic2VsZWN0YWJsZVRhcmdldHMiLCJzZWxlY3RCeUNsaWNrIiwiZHJhZ2dhYmxlIiwicmVzaXphYmxlIiwib3JpZ2luIiwib24iLCJjbGlja1RhcmdldCIsImlucHV0RXZlbnQiLCJpbnB1dFRhcmdldCIsInRhcmdldGVkRWxlbWVudCIsImFwcGx5RHJhZyIsIm1vdmVkIiwiZXZlbnRzIiwiZm9yRWFjaCIsImFwcGx5UmVzaXplIiwic2VsZWN0ZWRUYXJnZXQiLCJpc1RhcmdldE1vdmVhYmxlRWxlbWVudCIsImlzTW92ZWFibGVFbGVtZW50Iiwic29tZSIsImNvbnRhaW5zIiwic3RvcCIsInNlbGVjdGVkIiwiaXNEcmFnU3RhcnQiLCJwcmV2ZW50RGVmYXVsdCIsImRyYWdTdGFydCIsImxvYWQiLCJnZXRTZWxlY3RlZFRhcmdldHMiLCJncm91cFNlbGVjdGlvbiIsInBpcGUiLCJzdWJzY3JpYmUiLCJjdXJyZW50U2VsZWN0ZWRFbGVtZW50cyIsImN1cnJlbnRMYXllciIsIm5ld0xheWVyIiwiZG9BY3Rpb24iLCJNb3VzZUV2ZW50IiwidXBkYXRlQ3VycmVudExheWVyIiwidG9nZ2xlQW5jaG9yIiwiayIsImluZm8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3cmFwIiwic2V0UmVmIiwidG9vbGJhciIsIkNvbXBvbmVudCIsIlN1YnNjcmlwdGlvbiIsIlBhbmVsRWRpdEVudGVyZWRFdmVudCIsIlBhbmVsRWRpdEV4aXRlZEV2ZW50IiwiUGFuZWxDb250ZXh0Um9vdCIsIkNhbnZhc1BhbmVsIiwib25PcHRpb25zQ2hhbmdlIiwic2V0U3RhdGUiLCJyZWZyZXNoIiwic3RhdGUiLCJpbmxpbmVFZGl0aW5nIiwib25VcGRhdGVTY2VuZSIsInN1YnMiLCJhZGQiLCJldmVudEJ1cyIsImV2dCIsInBheWxvYWQiLCJuZWVkc1JlbG9hZCIsImNvbXBvbmVudERpZE1vdW50IiwicGFuZWxDb250ZXh0Iiwib25JbnN0YW5jZVN0YXRlQ2hhbmdlIiwibGF5ZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInVuc3Vic2NyaWJlIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwibmV4dFByb3BzIiwibmV4dFN0YXRlIiwiY2hhbmdlZCIsInNob3VsZFVwZGF0ZVNjZW5lQW5kUGFuZWwiLCJ1c2VDYWxsYmFjayIsIklubGluZUZpZWxkIiwiSW5saW5lRmllbGRSb3ciLCJKU09ORm9ybWF0dGVyIiwiU3RyaW5nVmFsdWVFZGl0b3IiLCJBcHBFdmVudHMiLCJnZXRCYWNrZW5kU3J2IiwiYXBwRXZlbnRzIiwiZHVtbXlTdHJpbmdTZXR0aW5ncyIsImlzVGVzdCIsImZldGNoIiwidXJsIiwiZW5kcG9pbnQiLCJtZXRob2QiLCJlcnJvciIsImVtaXQiLCJhbGVydEVycm9yIiwiY29tcGxldGUiLCJhbGVydFN1Y2Nlc3MiLCJsYWJlbFdpZHRoIiwib25FbmRwb2ludENoYW5nZSIsIm9uRGF0YUNoYW5nZSIsInJlbmRlckpTT04iLCJqc29uIiwicGFyc2UiLCJtZXNzYWdlIiwicmVuZGVyVGVzdEFQSUJ1dHRvbiIsImRpc2FibGVTYW5pdGl6ZUh0bWwiLCJIb3Jpem9udGFsR3JvdXAiLCJTaG93Q29uZmlybU1vZGFsRXZlbnQiLCJMYXllckVsZW1lbnRMaXN0RWRpdG9yIiwibmV3RWxlbWVudE9wdGlvbnMiLCJuZXdFbGVtZW50IiwidGFyZ2V0RWxlbWVudCIsImRlc3RpbmF0aW9uIiwiY291bnQiLCJzcmMiLCJzb3VyY2UiLCJpbmRleCIsImRzdCIsImRlbGV0ZUdyb3VwIiwicHVibGlzaCIsInRpdGxlIiwidGV4dDIiLCJjb25maXJtVGV4dCIsInllc1RleHQiLCJvbkNvbmZpcm0iLCJkZWNvdXBsZUdyb3VwIiwiZ29VcExheWVyIiwid2FybiIsImljb24iLCJuYW1lVG9WZXJpZnkiLCJjYW5SZW5hbWUiLCJvbkRlY291cGxlR3JvdXAiLCJvbkRlbGV0ZUdyb3VwIiwib25BZGRJdGVtIiwic2VsZWN0T3B0aW9ucyIsIm9uQ2xlYXJTZWxlY3Rpb24iLCJvbkdyb3VwU2VsZWN0aW9uIiwiRmllbGQiLCJ1c2VPYnNlcnZhYmxlIiwiTnVtYmVySW5wdXQiLCJhbmNob3JzIiwicGxhY2VzIiwiUGxhY2VtZW50RWRpdG9yIiwiYSIsInAiLCJnZXQiLCJsb2Rhc2hHZXQiLCJvcHRpb25CdWlsZGVyIiwic2V0T3B0aW9uSW1tdXRhYmx5IiwiZ2V0RWxlbWVudEVkaXRvciIsInZhbHVlcyIsImdldFZhbHVlIiwiYnVpbGQiLCJsYXllclR5cGVzIiwiYWRkU2VsZWN0IiwiY3VycmVudE9wdGlvbnMiLCJmbG9vciIsInJhbmRvbSIsImFkZEJhY2tncm91bmQiLCJhZGRCb3JkZXIiLCJnZXRMYXllckVkaXRvciIsIlBhbmVsUGx1Z2luIiwicGx1Z2luIiwic2V0Tm9QYWRkaW5nIiwidXNlRmllbGRDb25maWciLCJzZXRQYW5lbE9wdGlvbnMiLCJpbnN0YW5jZVN0YXRlIiwiYWRkQm9vbGVhblN3aXRjaCIsImFkZE5lc3RlZE9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9