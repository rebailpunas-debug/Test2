(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["lokiPlugin"],{

/***/ "./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAnnotationsQueryCtrl": () => (/* binding */ LokiAnnotationsQueryCtrl)
/* harmony export */ });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Just a simple wrapper for a react component that is actually implementing the query editor.
 */
class LokiAnnotationsQueryCtrl {
  /** @ngInject */
  constructor($scope) {
    this.annotation = $scope.ctrl.annotation;
    this.annotation.target = this.annotation.target || {};
    this.onQueryChange = this.onQueryChange.bind(this);
  }

  onQueryChange(query) {
    this.annotation.expr = query.expr;
    this.annotation.maxLines = query.maxLines;
    this.annotation.instant = query.instant;
  }

}
LokiAnnotationsQueryCtrl.$inject = ["$scope"];

_defineProperty(LokiAnnotationsQueryCtrl, "templateUrl", 'partials/annotations.editor.html');

/***/ }),

/***/ "./public/app/plugins/datasource/loki/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery),
/* harmony export */   "addLabelToSelector": () => (/* binding */ addLabelToSelector),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");



const builtInWords = [...app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_2__.PROM_KEYWORDS, ...app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_2__.OPERATORS, ...app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_2__.LOGICAL_OPERATORS, ..._syntax__WEBPACK_IMPORTED_MODULE_1__.LOKI_KEYWORDS]; // We want to extract all possible metrics and also keywords

const metricsAndKeywordsRegexp = /([A-Za-z:][\w:]*)\b(?![\]{=!",])/g;
function addLabelToQuery(query, key, value, operator, hasNoMetrics) {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  } // We need to make sure that we convert the value back to string because it may be a number


  const transformedValue = value === Infinity ? '+Inf' : value.toString(); // Add empty selectors to bare metric names

  let previousWord;
  query = query.replace(metricsAndKeywordsRegexp, (match, word, offset) => {
    const isMetric = isWordMetric(query, word, offset, previousWord, hasNoMetrics);
    previousWord = word;
    return isMetric ? `${word}{}` : word;
  }); //This is a RegExp for stream selector - e.g. {job="grafana"}

  const selectorRegexp = /(\$)?{([^{]*)}/g;
  const parts = [];
  let lastIndex = 0;
  let suffix = '';
  let match = selectorRegexp.exec(query);
  /* 
    There are 2 possible false positive scenarios: 
    
    1. We match Grafana's variables with ${ syntax - such as${__rate_s}. To filter these out we could use negative lookbehind,
    but Safari browser currently doesn't support it. Therefore we need to hack this by creating 2 matching groups. 
    (\$) is for the Grafana's variables and if we match it, we know this is not a stream selector and we don't want to add label.
     2. Log queries can include {{.label}} syntax when line_format is used. We need to filter these out by checking
    if match starts with "{."
  */

  while (match) {
    const prefix = query.slice(lastIndex, match.index);
    lastIndex = match.index + match[2].length + 2;
    suffix = query.slice(match.index + match[0].length); // Filtering our false positives

    if (match[0].startsWith('{.') || match[1]) {
      parts.push(prefix);
      parts.push(match[0]);
    } else {
      // If we didn't match first group, we are inside selector and we want to add labels
      const selector = match[2];
      const selectorWithLabel = addLabelToSelector(selector, key, transformedValue, operator);
      parts.push(prefix, selectorWithLabel);
    }

    match = selectorRegexp.exec(query);
  }

  parts.push(suffix);
  return parts.join('');
}
const labelRegexp = /(\w+)\s*(=|!=|=~|!~)\s*("[^"]*")/g;
function addLabelToSelector(selector, labelKey, labelValue, labelOperator) {
  const parsedLabels = []; // Split selector into labels

  if (selector) {
    let match = labelRegexp.exec(selector);

    while (match) {
      parsedLabels.push({
        key: match[1],
        operator: match[2],
        value: match[3]
      });
      match = labelRegexp.exec(selector);
    }
  } // Add new label


  const operatorForLabelKey = labelOperator || '=';
  parsedLabels.push({
    key: labelKey,
    operator: operatorForLabelKey,
    value: `"${labelValue}"`
  }); // Sort labels by key and put them together

  const formatted = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(parsedLabels).uniqWith(lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual).compact().sortBy('key').map(({
    key,
    operator,
    value
  }) => `${key}${operator}${value}`).value().join(',');
  return `{${formatted}}`;
}

function isPositionInsideChars(text, position, openChar, closeChar) {
  const nextSelectorStart = text.slice(position).indexOf(openChar);
  const nextSelectorEnd = text.slice(position).indexOf(closeChar);
  return nextSelectorEnd > -1 && (nextSelectorStart === -1 || nextSelectorStart > nextSelectorEnd);
}

function isWordMetric(query, word, offset, previousWord, hasNoMetrics) {
  const insideSelector = isPositionInsideChars(query, offset, '{', '}'); // Handle "sum by (key) (metric)"

  const previousWordIsKeyWord = previousWord && app_plugins_datasource_prometheus_promql__WEBPACK_IMPORTED_MODULE_2__.OPERATORS.indexOf(previousWord) > -1; // Check for colon as as "word boundary" symbol

  const isColonBounded = word.endsWith(':'); // Check for words that start with " which means that they are not metrics

  const startsWithQuote = query[offset - 1] === '"'; // Check for template variables

  const isTemplateVariable = query[offset - 1] === '$'; // Check for time units

  const isTimeUnit = ['s', 'm', 'h', 'd', 'w'].includes(word) && Boolean(Number(query[offset - 1]));

  if (!hasNoMetrics && !insideSelector && !isColonBounded && !previousWordIsKeyWord && !startsWithQuote && !isTemplateVariable && !isTimeUnit && builtInWords.indexOf(word) === -1) {
    return true;
  }

  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addLabelToQuery);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/backendResultTransformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transformBackendResult": () => (/* binding */ transformBackendResult)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var _makeTableFrames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/makeTableFrames.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _makeIdField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/makeIdField.ts");
const _excluded = ["meta"],
      _excluded2 = ["data"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function isMetricFrame(frame) {
  return frame.fields.every(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time || field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number);
} // returns a new frame, with meta merged with it's original meta


function setFrameMeta(frame, meta) {
  const {
    meta: oldMeta
  } = frame,
        rest = _objectWithoutPropertiesLoose(frame, _excluded); // meta maybe be undefined, we need to handle that


  const newMeta = Object.assign({}, oldMeta, meta);
  return Object.assign({}, rest, {
    meta: newMeta
  });
}

function processStreamFrame(frame, query) {
  const meta = {
    preferredVisualisationType: 'logs',
    searchWords: query !== undefined ? (0,_query_utils__WEBPACK_IMPORTED_MODULE_3__.getHighlighterExpressionsFromQuery)((0,_query_utils__WEBPACK_IMPORTED_MODULE_3__.formatQuery)(query.expr)) : undefined,
    custom: {
      // used by logs_model
      lokiQueryStatKey: 'Summary: total bytes processed'
    }
  };
  const newFrame = setFrameMeta(frame, meta);
  const newFields = frame.fields.map(field => {
    // the nanosecond-timestamp field must have a type-time
    if (field.name === 'tsNs') {
      return Object.assign({}, field, {
        type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time
      });
    } else {
      return field;
    }
  }); // we add a calculated id-field

  newFields.push((0,_makeIdField__WEBPACK_IMPORTED_MODULE_4__.makeIdField)(frame));
  return Object.assign({}, newFrame, {
    fields: newFields
  });
}

function processStreamsFrames(frames, queryMap) {
  return frames.map(frame => {
    const query = frame.refId !== undefined ? queryMap.get(frame.refId) : undefined;
    return processStreamFrame(frame, query);
  });
}

function processMetricInstantFrames(frames) {
  return frames.length > 0 ? (0,_makeTableFrames__WEBPACK_IMPORTED_MODULE_2__.makeTableFrames)(frames) : [];
}

function processMetricRangeFrames(frames) {
  const meta = {
    preferredVisualisationType: 'graph'
  };
  return frames.map(frame => setFrameMeta(frame, meta));
} // we split the frames into 3 groups, because we will handle
// each group slightly differently


function groupFrames(frames, queryMap) {
  const streamsFrames = [];
  const metricInstantFrames = [];
  const metricRangeFrames = [];
  frames.forEach(frame => {
    if (!isMetricFrame(frame)) {
      streamsFrames.push(frame);
    } else {
      var _queryMap$get;

      const isInstantFrame = frame.refId != null && ((_queryMap$get = queryMap.get(frame.refId)) === null || _queryMap$get === void 0 ? void 0 : _queryMap$get.queryType) === _types__WEBPACK_IMPORTED_MODULE_1__.LokiQueryType.Instant;

      if (isInstantFrame) {
        metricInstantFrames.push(frame);
      } else {
        metricRangeFrames.push(frame);
      }
    }
  });
  return {
    streamsFrames,
    metricInstantFrames,
    metricRangeFrames
  };
}

function transformBackendResult(response, request) {
  const {
    data
  } = response,
        rest = _objectWithoutPropertiesLoose(response, _excluded2); // in the typescript type, data is an array of basically anything.
  // we do know that they have to be dataframes, so we make a quick check,
  // this way we can be sure, and also typescript is happy.


  const dataFrames = data.map(d => {
    if (!(0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.isDataFrame)(d)) {
      throw new Error('transformation only supports dataframe responses');
    }

    return d;
  });
  const queryMap = new Map(request.targets.map(query => [query.refId, query]));
  const {
    streamsFrames,
    metricInstantFrames,
    metricRangeFrames
  } = groupFrames(dataFrames, queryMap);
  return Object.assign({}, rest, {
    data: [...processMetricRangeFrames(metricRangeFrames), ...processMetricInstantFrames(metricInstantFrames), ...processStreamsFrames(streamsFrames, queryMap)]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LokiCheatSheet)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h, _div, _div2, _div3, _div4, _div5, _div6, _div7, _div8;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const DEFAULT_EXAMPLES = ['{job="default/prometheus"}'];
const PREFERRED_LABELS = ['job', 'app', 'k8s_app'];
const EXAMPLES_LIMIT = 5;
const LOGQL_EXAMPLES = [{
  title: 'Log pipeline',
  expression: '{job="mysql"} |= "metrics" | logfmt | duration > 10s',
  label: 'This query targets the MySQL job, filters out logs that donâ€™t contain the word "metrics" and parses each log line to extract more labels and filters with them.'
}, {
  title: 'Count over time',
  expression: 'count_over_time({job="mysql"}[5m])',
  label: 'This query counts all the log lines within the last five minutes for the MySQL job.'
}, {
  title: 'Rate',
  expression: 'rate(({job="mysql"} |= "error" != "timeout")[10s])',
  label: 'This query gets the per-second rate of all non-timeout errors within the last ten seconds for the MySQL job.'
}, {
  title: 'Aggregate, count, and group',
  expression: 'sum(count_over_time({job="mysql"}[5m])) by (level)',
  label: 'Get the count of logs during the last five minutes, grouping by level.'
}];
class LokiCheatSheet extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      userExamples: []
    });

    _defineProperty(this, "checkUserLabels", async () => {
      var _this$props$datasourc;

      // Set example from user labels
      const provider = (_this$props$datasourc = this.props.datasource) === null || _this$props$datasourc === void 0 ? void 0 : _this$props$datasourc.languageProvider;

      if (provider.started) {
        const labels = provider.getLabelKeys() || [];
        const preferredLabel = PREFERRED_LABELS.find(l => labels.includes(l));

        if (preferredLabel) {
          const values = await provider.getLabelValues(preferredLabel);
          const userExamples = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.shuffle)(values).slice(0, EXAMPLES_LIMIT).map(value => `{${preferredLabel}="${value}"}`);
          this.setState({
            userExamples
          });
        }
      } else {
        this.scheduleUserLabelChecking();
      }
    });
  }

  componentDidMount() {
    this.scheduleUserLabelChecking();
  }

  componentWillUnmount() {
    clearTimeout(this.userLabelTimer);
  }

  scheduleUserLabelChecking() {
    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);
  }

  renderExpression(expr) {
    const {
      onClickExample
    } = this.props;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
      className: "cheat-sheet-item__example",
      onClick: e => onClickExample({
        refId: 'A',
        expr
      }),
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("code", {
        children: expr
      })
    }, expr);
  }

  render() {
    const {
      userExamples
    } = this.state;
    const hasUserExamples = userExamples.length > 0;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
      children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("h2", {
        children: "Loki Cheat Sheet"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "See your logs"
        })), _div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: "Start by selecting a log stream from the Log browser, or alternatively you can write a stream selector into the query field."
        })), hasUserExamples ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
          children: [_div3 || (_div3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
            className: "cheat-sheet-item__label",
            children: "Here are some example streams from your logs:"
          })), userExamples.map(example => this.renderExpression(example))]
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
          children: [_div4 || (_div4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
            className: "cheat-sheet-item__label",
            children: "Here is an example of a log stream:"
          })), this.renderExpression(DEFAULT_EXAMPLES[0])]
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div5 || (_div5 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "Combine stream selectors"
        })), this.renderExpression('{app="cassandra",namespace="prod"}'), _div6 || (_div6 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: "Returns all log lines from streams that have both labels."
        }))]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [_div7 || (_div7 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: "Filtering for search terms."
        })), this.renderExpression('{app="cassandra"} |~ "(duration|latency)s*(=|is|of)s*[d.]+"'), this.renderExpression('{app="cassandra"} |= "exact match"'), this.renderExpression('{app="cassandra"} != "do not match"'), _div8 || (_div8 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
          className: "cheat-sheet-item__label",
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("a", {
            href: "https://grafana.com/docs/loki/latest/logql/#log-pipeline",
            target: "logql",
            children: "LogQL"
          }), ' ', "supports exact and regular expression filters."]
        }))]
      }), LOGQL_EXAMPLES.map(item => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("div", {
        className: "cheat-sheet-item",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__title",
          children: item.title
        }), this.renderExpression(item.expression), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("div", {
          className: "cheat-sheet-item__label",
          children: item.label
        })]
      }, item.expression))]
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiExploreQueryEditor": () => (/* binding */ LokiExploreQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var _LokiOptionFields__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
// Libraries
 // Types




const LokiExploreQueryEditor = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(props => {
  var _query$maxLines;

  const {
    query,
    data,
    datasource,
    history,
    onChange,
    onRunQuery,
    range
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_1__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onBlur: () => {},
    onRunQuery: onRunQuery,
    history: history,
    data: data,
    range: range,
    "data-testid": testIds.editor,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_LokiOptionFields__WEBPACK_IMPORTED_MODULE_2__.LokiOptionFields, {
      lineLimitValue: (query === null || query === void 0 ? void 0 : (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) || '',
      resolution: query.resolution || 1,
      query: query,
      onRunQuery: onRunQuery,
      onChange: onChange
    })
  });
});
LokiExploreQueryEditor.displayName = 'LokiExploreQueryEditor';
const testIds = {
  editor: 'loki-editor-explore'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiLabelBrowser.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiLabelBrowser": () => (/* binding */ LokiLabelBrowser),
/* harmony export */   "UnthemedLokiLabelBrowser": () => (/* binding */ UnthemedLokiLabelBrowser),
/* harmony export */   "buildSelector": () => (/* binding */ buildSelector),
/* harmony export */   "facetLabels": () => (/* binding */ facetLabels)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react_window__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-window-virtual-0f9a8c6a67/0/cache/react-window-npm-1.8.6-4f5a230226-54ccf2b16c.zip/node_modules/react-window/dist/index.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _LoadingPlaceholder, _Label, _Label2, _Label3;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





 // Hard limit on labels to render



const MAX_LABEL_COUNT = 1000;
const MAX_VALUE_COUNT = 10000;
const MAX_AUTO_SELECT = 4;
const EMPTY_SELECTOR = '{}';
function buildSelector(labels) {
  const selectedLabels = [];

  for (const label of labels) {
    if (label.selected && label.values && label.values.length > 0) {
      const selectedValues = label.values.filter(value => value.selected).map(value => value.name);

      if (selectedValues.length > 1) {
        selectedLabels.push(`${label.name}=~"${selectedValues.join('|')}"`);
      } else if (selectedValues.length === 1) {
        selectedLabels.push(`${label.name}="${selectedValues[0]}"`);
      }
    }
  }

  return ['{', selectedLabels.join(','), '}'].join('');
}
function facetLabels(labels, possibleLabels, lastFacetted) {
  return labels.map(label => {
    const possibleValues = possibleLabels[label.name];

    if (possibleValues) {
      let existingValues;

      if (label.name === lastFacetted && label.values) {
        // Facetting this label, show all values
        existingValues = label.values;
      } else {
        var _label$values;

        // Keep selection in other facets
        const selectedValues = new Set(((_label$values = label.values) === null || _label$values === void 0 ? void 0 : _label$values.filter(value => value.selected).map(value => value.name)) || []); // Values for this label have not been requested yet, let's use the facetted ones as the initial values

        existingValues = possibleValues.map(value => ({
          name: value,
          selected: selectedValues.has(value)
        }));
      }

      return Object.assign({}, label, {
        loading: false,
        values: existingValues,
        facets: existingValues.length
      });
    } // Label is facetted out, hide all values


    return Object.assign({}, label, {
      loading: false,
      hidden: !possibleValues,
      values: undefined,
      facets: 0
    });
  });
}

const getStyles = theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    background-color: ${theme.colors.background.secondary};
    padding: ${theme.spacing(2)};
    width: 100%;
  `,
  list: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    margin-top: ${theme.spacing(1)};
    display: flex;
    flex-wrap: wrap;
    max-height: 200px;
    overflow: auto;
  `,
  section: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    & + & {
      margin: ${theme.spacing(2, 0)};
    }
    position: relative;
  `,
  selector: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    font-family: ${theme.typography.fontFamilyMonospace};
    margin-bottom: ${theme.spacing(1)};
  `,
  status: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    padding: ${theme.spacing(0.5)};
    color: ${theme.colors.text.secondary};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* using absolute positioning because flex interferes with ellipsis */
    position: absolute;
    width: 50%;
    right: 0;
    text-align: right;
    transition: opacity 100ms linear;
    opacity: 0;
  `,
  statusShowing: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    opacity: 1;
  `,
  error: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    color: ${theme.colors.error.main};
  `,
  valueList: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    margin-right: ${theme.spacing(1)};
  `,
  valueListWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    border-left: 1px solid ${theme.colors.border.medium};
    margin: ${theme.spacing(1, 0)};
    padding: ${theme.spacing(1, 0, 1, 1)};
  `,
  valueListArea: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    display: flex;
    flex-wrap: wrap;
    margin-top: ${theme.spacing(1)};
  `,
  valueTitle: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    margin-left: -${theme.spacing(0.5)};
    margin-bottom: ${theme.spacing(1)};
  `,
  validationStatus: _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
    padding: ${theme.spacing(0.5)};
    margin-bottom: ${theme.spacing(1)};
    color: ${theme.colors.text.maxContrast};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  `
});

class UnthemedLokiLabelBrowser extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      labels: [],
      searchTerm: '',
      status: 'Ready',
      error: '',
      validationStatus: ''
    });

    _defineProperty(this, "onChangeSearch", event => {
      this.setState({
        searchTerm: event.target.value
      });
    });

    _defineProperty(this, "onClickRunLogsQuery", () => {
      const selector = buildSelector(this.state.labels);
      this.props.onChange(selector);
    });

    _defineProperty(this, "onClickRunMetricsQuery", () => {
      const selector = buildSelector(this.state.labels);
      const query = `rate(${selector}[$__interval])`;
      this.props.onChange(query);
    });

    _defineProperty(this, "onClickClear", () => {
      this.setState(state => {
        const labels = state.labels.map(label => Object.assign({}, label, {
          values: undefined,
          selected: false,
          loading: false,
          hidden: false,
          facets: undefined
        }));
        return {
          labels,
          searchTerm: '',
          status: '',
          error: '',
          validationStatus: ''
        };
      });
      this.props.deleteLastUsedLabels();
    });

    _defineProperty(this, "onClickLabel", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label) {
        return;
      } // Toggle selected state


      const selected = !label.selected;
      let nextValue = {
        selected
      };

      if (label.values && !selected) {
        // Deselect all values if label was deselected
        const values = label.values.map(value => Object.assign({}, value, {
          selected: false
        }));
        nextValue = Object.assign({}, nextValue, {
          facets: 0,
          values
        });
      } // Resetting search to prevent empty results


      this.setState({
        searchTerm: ''
      });
      this.updateLabelState(name, nextValue, '', () => this.doFacettingForLabel(name));
    });

    _defineProperty(this, "onClickValue", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        searchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value ? !v.selected : v.selected
      }));
      this.updateLabelState(name, {
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickValidate", () => {
      const selector = buildSelector(this.state.labels);
      this.validateSelector(selector);
    });

    _defineProperty(this, "doFacetting", lastFacetted => {
      const selector = buildSelector(this.state.labels);

      if (selector === EMPTY_SELECTOR) {
        // Clear up facetting
        const labels = this.state.labels.map(label => {
          return Object.assign({}, label, {
            facets: 0,
            values: undefined,
            hidden: false
          });
        });
        this.setState({
          labels
        }, () => {
          // Get fresh set of values
          this.state.labels.forEach(label => label.selected && this.fetchValues(label.name, selector));
        });
      } else {
        // Do facetting
        this.fetchSeries(selector, lastFacetted);
      }
    });
  }

  updateLabelState(name, updatedFields, status = '', cb) {
    this.setState(state => {
      const labels = state.labels.map(label => {
        if (label.name === name) {
          return Object.assign({}, label, updatedFields);
        }

        return label;
      }); // New status overrides errors

      const error = status ? '' : state.error;
      return {
        labels,
        status,
        error,
        validationStatus: ''
      };
    }, cb);
  }

  componentDidMount() {
    const {
      languageProvider,
      autoSelect = MAX_AUTO_SELECT,
      lastUsedLabels
    } = this.props;

    if (languageProvider) {
      const selectedLabels = lastUsedLabels;
      languageProvider.start().then(() => {
        let rawLabels = languageProvider.getLabelKeys();

        if (rawLabels.length > MAX_LABEL_COUNT) {
          const error = `Too many labels found (showing only ${MAX_LABEL_COUNT} of ${rawLabels.length})`;
          rawLabels = rawLabels.slice(0, MAX_LABEL_COUNT);
          this.setState({
            error
          });
        } // Auto-select all labels if label list is small enough


        const labels = rawLabels.map((label, i, arr) => ({
          name: label,
          selected: arr.length <= autoSelect && selectedLabels.length === 0 || selectedLabels.includes(label),
          loading: false
        })); // Pre-fetch values for selected labels

        this.setState({
          labels
        }, () => {
          this.state.labels.forEach(label => {
            if (label.selected) {
              this.fetchValues(label.name, EMPTY_SELECTOR);
            }
          });
        });
      });
    }
  }

  doFacettingForLabel(name) {
    const label = this.state.labels.find(l => l.name === name);

    if (!label) {
      return;
    }

    const selectedLabels = this.state.labels.filter(label => label.selected).map(label => label.name);
    this.props.storeLastUsedLabels(selectedLabels);

    if (label.selected) {
      // Refetch values for newly selected label...
      if (!label.values) {
        this.fetchValues(name, buildSelector(this.state.labels));
      }
    } else {
      // Only need to facet when deselecting labels
      this.doFacetting();
    }
  }

  async fetchValues(name, selector) {
    const {
      languageProvider
    } = this.props;
    this.updateLabelState(name, {
      loading: true
    }, `Fetching values for ${name}`);

    try {
      let rawValues = await languageProvider.getLabelValues(name); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        this.updateLabelState(name, {
          loading: false
        }, '');
        return;
      }

      if (rawValues.length > MAX_VALUE_COUNT) {
        const error = `Too many values for ${name} (showing only ${MAX_VALUE_COUNT} of ${rawValues.length})`;
        rawValues = rawValues.slice(0, MAX_VALUE_COUNT);
        this.setState({
          error
        });
      }

      const values = rawValues.map(value => ({
        name: value
      }));
      this.updateLabelState(name, {
        values,
        loading: false
      });
    } catch (error) {
      console.error(error);
    }
  }

  async fetchSeries(selector, lastFacetted) {
    const {
      languageProvider
    } = this.props;

    if (lastFacetted) {
      this.updateLabelState(lastFacetted, {
        loading: true
      }, `Facetting labels for ${selector}`);
    }

    try {
      const possibleLabels = await languageProvider.fetchSeriesLabels(selector, true); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        if (lastFacetted) {
          this.updateLabelState(lastFacetted, {
            loading: false
          });
        }

        return;
      }

      if (Object.keys(possibleLabels).length === 0) {
        this.setState({
          error: `Empty results, no matching label for ${selector}`
        });
        return;
      }

      const labels = facetLabels(this.state.labels, possibleLabels, lastFacetted);
      this.setState({
        labels,
        error: ''
      });

      if (lastFacetted) {
        this.updateLabelState(lastFacetted, {
          loading: false
        });
      }
    } catch (error) {
      console.error(error);
    }
  }

  async validateSelector(selector) {
    const {
      languageProvider
    } = this.props;
    this.setState({
      validationStatus: `Validating selector ${selector}`,
      error: ''
    });
    const streams = await languageProvider.fetchSeries(selector);
    this.setState({
      validationStatus: `Selector is valid (${streams.length} streams found)`
    });
  }

  render() {
    const {
      theme
    } = this.props;
    const {
      labels,
      searchTerm,
      status,
      error,
      validationStatus
    } = this.state;

    if (labels.length === 0) {
      return _LoadingPlaceholder || (_LoadingPlaceholder = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.LoadingPlaceholder, {
        text: "Loading labels..."
      }));
    }

    const styles = getStyles(theme);
    const selector = buildSelector(this.state.labels);
    const empty = selector === EMPTY_SELECTOR;
    let selectedLabels = labels.filter(label => label.selected && label.values);

    if (searchTerm) {
      selectedLabels = selectedLabels.map(label => {
        const searchResults = label.values.filter(value => {
          // Always return selected values
          if (value.selected) {
            value.highlightParts = undefined;
            return true;
          }

          const fuzzyMatchResult = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.fuzzyMatch)(value.name.toLowerCase(), searchTerm.toLowerCase());

          if (fuzzyMatchResult.found) {
            value.highlightParts = fuzzyMatchResult.ranges;
            value.order = fuzzyMatchResult.distance;
            return true;
          } else {
            return false;
          }
        });
        return Object.assign({}, label, {
          values: (0,lodash__WEBPACK_IMPORTED_MODULE_3__.sortBy)(searchResults, value => value.selected ? -Infinity : value.order)
        });
      });
    } else {
      // Clear highlight parts when searchTerm is cleared
      selectedLabels = this.state.labels.filter(label => label.selected && label.values).map(label => Object.assign({}, label, {
        values: label !== null && label !== void 0 && label.values ? label.values.map(value => Object.assign({}, value, {
          highlightParts: undefined
        })) : []
      }));
    }

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.wrapper,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.section,
        children: [_Label || (_Label = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Label, {
          description: "Which labels would you like to consider for your search?",
          children: "1. Select labels to search in"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: styles.list,
          children: labels.map(label => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BrowserLabel, {
            name: label.name,
            loading: label.loading,
            active: label.selected,
            hidden: label.hidden,
            facets: label.facets,
            onClick: this.onClickLabel
          }, label.name))
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.section,
        children: [_Label2 || (_Label2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Label, {
          description: "Choose the label values that you would like to use for the query. Use the search field to find values across selected labels.",
          children: "2. Find values for the selected labels"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Input, {
            onChange: this.onChangeSearch,
            "aria-label": "Filter expression for values",
            value: searchTerm
          })
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: styles.valueListArea,
          children: selectedLabels.map(label => {
            var _label$values2, _label$values3;

            return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
              role: "list",
              className: styles.valueListWrapper,
              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                className: styles.valueTitle,
                "aria-label": `Values for ${label.name}`,
                children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BrowserLabel, {
                  name: label.name,
                  loading: label.loading,
                  active: label.selected,
                  hidden: label.hidden //If no facets, we want to show number of all label values
                  ,
                  facets: label.facets || ((_label$values2 = label.values) === null || _label$values2 === void 0 ? void 0 : _label$values2.length),
                  onClick: this.onClickLabel
                })
              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_5__.FixedSizeList, {
                height: 200,
                itemCount: ((_label$values3 = label.values) === null || _label$values3 === void 0 ? void 0 : _label$values3.length) || 0,
                itemSize: 28,
                itemKey: i => label.values[i].name,
                width: 200,
                className: styles.valueList,
                children: ({
                  index,
                  style
                }) => {
                  var _label$values4;

                  const value = (_label$values4 = label.values) === null || _label$values4 === void 0 ? void 0 : _label$values4[index];

                  if (!value) {
                    return null;
                  }

                  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                    style: style,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BrowserLabel, {
                      name: label.name,
                      value: value === null || value === void 0 ? void 0 : value.name,
                      active: value === null || value === void 0 ? void 0 : value.selected,
                      highlightParts: value === null || value === void 0 ? void 0 : value.highlightParts,
                      onClick: this.onClickValue,
                      searchTerm: searchTerm
                    })
                  });
                }
              })]
            }, label.name);
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.section,
        children: [_Label3 || (_Label3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Label, {
          children: "3. Resulting selector"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          "aria-label": "selector",
          className: styles.selector,
          children: selector
        }), validationStatus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: styles.validationStatus,
          children: validationStatus
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.HorizontalGroup, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
            "aria-label": "Use selector as logs button",
            disabled: empty,
            onClick: this.onClickRunLogsQuery,
            children: "Show logs"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
            "aria-label": "Use selector as metrics button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickRunMetricsQuery,
            children: "Show logs rate"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
            "aria-label": "Validate submit button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickValidate,
            children: "Validate selector"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
            "aria-label": "Selector clear button",
            variant: "secondary",
            onClick: this.onClickClear,
            children: "Clear"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
            className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.cx)(styles.status, (status || error) && styles.statusShowing),
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
              className: error ? styles.error : '',
              children: error || status
            })
          })]
        })]
      })]
    });
  }

}
const LokiLabelBrowser = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.withTheme2)(UnthemedLokiLabelBrowser);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_RESOLUTION": () => (/* binding */ DEFAULT_RESOLUTION),
/* harmony export */   "LokiOptionFields": () => (/* binding */ LokiOptionFields),
/* harmony export */   "RESOLUTION_OPTIONS": () => (/* binding */ RESOLUTION_OPTIONS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "preprocessMaxLines": () => (/* binding */ preprocessMaxLines),
/* harmony export */   "queryTypeOptions": () => (/* binding */ queryTypeOptions)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel;

const _excluded = ["instant", "range"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// Libraries


 // Types






const queryTypeOptions = [{
  value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Range,
  label: 'Range',
  description: 'Run query over a range of time.'
}, {
  value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Instant,
  label: 'Instant',
  description: 'Run query against a single point in time. For this query, the "To" time is used.'
}];

if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.config.featureToggles.lokiLive) {
  queryTypeOptions.push({
    value: _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Stream,
    label: 'Stream',
    description: 'Run a query and keep sending results on an interval'
  });
}

const DEFAULT_RESOLUTION = {
  value: 1,
  label: '1/1'
};
const RESOLUTION_OPTIONS = [DEFAULT_RESOLUTION].concat((0,lodash__WEBPACK_IMPORTED_MODULE_2__.map)([2, 3, 4, 5, 10], value => ({
  value,
  label: '1/' + value
})));
function LokiOptionFields(props) {
  var _props$query, _query$queryType;

  const {
    lineLimitValue,
    resolution,
    onRunQuery,
    runOnBlur,
    onChange
  } = props;
  const query = (_props$query = props.query) !== null && _props$query !== void 0 ? _props$query : {};
  let queryType = (_query$queryType = query.queryType) !== null && _query$queryType !== void 0 ? _query$queryType : query.instant ? _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_5__.LokiQueryType.Range;

  function onChangeQueryLimit(value) {
    const nextQuery = Object.assign({}, query, {
      maxLines: preprocessMaxLines(value)
    });
    onChange(nextQuery);
  }

  function onQueryTypeChange(queryType) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded);

    onChange(Object.assign({}, rest, {
      queryType
    }));
  }

  function onMaxLinesChange(e) {
    if (query.maxLines !== preprocessMaxLines(e.currentTarget.value)) {
      onChangeQueryLimit(e.currentTarget.value);
    }
  }

  function onReturnKeyDown(e) {
    if (e.key === 'Enter') {
      onRunQuery();
    }
  }

  function onResolutionChange(option) {
    const nextQuery = Object.assign({}, query, {
      resolution: option.value
    });
    onChange(nextQuery);
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
    "aria-label": "Loki extra field",
    className: "gf-form-inline",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      "data-testid": "queryTypeField",
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.cx)('gf-form explore-input-margin', _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
            flex-wrap: nowrap;
          `),
      "aria-label": "Query type field",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
        width: "auto",
        children: "Query type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.RadioButtonGroup, {
        options: queryTypeOptions,
        value: queryType,
        onChange: type => {
          onQueryTypeChange(type);

          if (runOnBlur) {
            onRunQuery();
          }
        }
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      "data-testid": "lineLimitField",
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.cx)('gf-form', _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
            flex-wrap: nowrap;
          `),
      "aria-label": "Line limit field",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
        label: "Line limit",
        tooltip: 'Upper limit for number of log lines returned by query.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Input, {
          className: "width-4",
          placeholder: "auto",
          type: "number",
          min: 0,
          onChange: onMaxLinesChange,
          onKeyDown: onReturnKeyDown,
          value: lineLimitValue,
          onBlur: () => {
            if (runOnBlur) {
              onRunQuery();
            }
          }
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
        label: "Resolution",
        tooltip: 'Resolution 1/1 sets step parameter of Loki metrics range queries such that each pixel corresponds to one data point. For better performance, lower resolutions can be picked. 1/2 only retrieves a data point for every other pixel, and 1/10 retrieves one data point per 10 pixels.',
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          isSearchable: false,
          onChange: onResolutionChange,
          options: RESOLUTION_OPTIONS,
          value: resolution,
          "aria-label": "Select resolution",
          menuShouldPortal: true
        })
      })]
    })]
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(LokiOptionFields));
function preprocessMaxLines(value) {
  if (value.length === 0) {
    // empty input - falls back to dataSource.maxLines limit
    return NaN;
  } else if (value.length > 0 && (isNaN(+value) || +value < 0)) {
    // input with at least 1 character and that is either incorrect (value in the input field is not a number) or negative
    // falls back to the limit of 0 lines
    return 0;
  } else {
    // default case - correct input
    return +value;
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditor": () => (/* binding */ LokiQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var _LokiOptionFields__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel;

// Libraries
 // Types







function LokiQueryEditor(props) {
  var _query$maxLines;

  const {
    query,
    data,
    datasource,
    onChange,
    onRunQuery,
    range
  } = props;

  const onLegendChange = e => {
    const nextQuery = Object.assign({}, query, {
      legendFormat: e.currentTarget.value
    });
    onChange(nextQuery);
  };

  const legendField = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: "gf-form-inline",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
        width: 6,
        tooltip: "Controls the name of the time series, using name or pattern. For example {{hostname}} will be replaced with label value for the label hostname. The legend only applies to metric queries.",
        children: "Legend"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("input", {
        type: "text",
        className: "gf-form-input",
        placeholder: "legend format",
        value: query.legendFormat || '',
        onChange: onLegendChange,
        onBlur: onRunQuery
      })]
    })
  });

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_2__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onRunQuery: onRunQuery,
    onBlur: onRunQuery,
    history: [],
    data: data,
    "data-testid": testIds.editor,
    range: range,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LokiOptionFields__WEBPACK_IMPORTED_MODULE_3__.LokiOptionFields, {
        lineLimitValue: (query === null || query === void 0 ? void 0 : (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) || '',
        resolution: (query === null || query === void 0 ? void 0 : query.resolution) || 1,
        query: query,
        onRunQuery: onRunQuery,
        onChange: onChange,
        runOnBlur: true
      }), legendField]
    })
  });
}
const testIds = {
  editor: 'loki-editor'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorByApp": () => (/* binding */ LokiQueryEditorByApp),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _LokiQueryEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx");
/* harmony import */ var _LokiQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx");
/* harmony import */ var _LokiExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx");
/* harmony import */ var _querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryEditorSelector.tsx");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function LokiQueryEditorByApp(props) {
  const {
    app
  } = props;

  switch (app) {
    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.CloudAlerting:
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_3__.LokiQueryEditorForAlerting, Object.assign({}, props));

    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_6__.config.featureToggles.lokiQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_5__.LokiQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiExploreQueryEditor__WEBPACK_IMPORTED_MODULE_4__.LokiExploreQueryEditor, Object.assign({}, props));

    default:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_6__.config.featureToggles.lokiQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_LokiQueryEditorSelector__WEBPACK_IMPORTED_MODULE_5__.LokiQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_2__.LokiQueryEditor, Object.assign({}, props));
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(LokiQueryEditorByApp));

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorForAlerting": () => (/* binding */ LokiQueryEditorForAlerting),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiQueryField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



function LokiQueryEditorForAlerting(props) {
  const {
    query,
    data,
    datasource,
    onChange,
    onRunQuery
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_LokiQueryField__WEBPACK_IMPORTED_MODULE_1__.LokiQueryField, {
    datasource: datasource,
    query: query,
    onChange: onChange,
    onRunQuery: onRunQuery,
    onBlur: onRunQuery,
    history: [],
    data: data,
    placeholder: "Enter a Loki query",
    "data-testid": testIds.editor
  });
}
const testIds = {
  editor: 'loki-editor-cloud-alerting'
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/components/LokiQueryField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryField": () => (/* binding */ LokiQueryField)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _LokiLabelBrowser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiLabelBrowser.tsx");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/language_utils.ts");
/* harmony import */ var app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/components/LocalStorageValueProvider/index.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










const LAST_USED_LABELS_KEY = 'grafana.datasources.loki.browser.labels';

function getChooserText(hasSyntax, hasLogLabels) {
  if (!hasSyntax) {
    return 'Loading labels...';
  }

  if (!hasLogLabels) {
    return '(No logs found)';
  }

  return 'Log browser';
}

function willApplySuggestion(suggestion, {
  typeaheadContext,
  typeaheadText
}) {
  // Modify suggestion based on context
  switch (typeaheadContext) {
    case 'context-labels':
      {
        const nextChar = _grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DOMUtil.getNextCharacter();

        if (!nextChar || nextChar === '}' || nextChar === ',') {
          suggestion += '=';
        }

        break;
      }

    case 'context-label-values':
      {
        // Always add quotes and remove existing ones instead
        if (!typeaheadText.match(/^(!?=~?"|")/)) {
          suggestion = `"${suggestion}`;
        }

        if (_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DOMUtil.getNextCharacter() !== '"') {
          suggestion = `${suggestion}"`;
        }

        break;
      }

    default:
  }

  return suggestion;
}

class LokiQueryField extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "plugins", void 0);

    _defineProperty(this, "_isMounted", false);

    _defineProperty(this, "onChangeLabelBrowser", selector => {
      this.onChangeQuery(selector, true);
      this.setState({
        labelBrowserVisible: false
      });
    });

    _defineProperty(this, "onChangeQuery", (value, override) => {
      // Send text change to parent
      const {
        query,
        onChange,
        onRunQuery
      } = this.props;

      if (onChange) {
        const nextQuery = Object.assign({}, query, {
          expr: value
        });
        onChange(nextQuery);

        if (override && onRunQuery) {
          onRunQuery();
        }
      }
    });

    _defineProperty(this, "onClickChooserButton", () => {
      this.setState(state => ({
        labelBrowserVisible: !state.labelBrowserVisible
      }));
    });

    _defineProperty(this, "onTypeahead", async typeahead => {
      const {
        datasource
      } = this.props;

      if (!datasource.languageProvider) {
        return {
          suggestions: []
        };
      }

      const lokiLanguageProvider = datasource.languageProvider;
      const {
        history
      } = this.props;
      const {
        prefix,
        text,
        value,
        wrapperClasses,
        labelKey
      } = typeahead;
      const result = await lokiLanguageProvider.provideCompletionItems({
        text,
        value,
        prefix,
        wrapperClasses,
        labelKey
      }, {
        history
      });
      return result;
    });

    this.state = {
      labelsLoaded: false,
      labelBrowserVisible: false
    };
    this.plugins = [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BracesPlugin)(), (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.SlatePrism)({
      onlyIn: node => node.object === 'block' && node.type === 'code_block',
      getSyntax: node => 'logql'
    }, Object.assign({}, prismjs__WEBPACK_IMPORTED_MODULE_3__.languages, {
      logql: this.props.datasource.languageProvider.getSyntax()
    }))];
  }

  async componentDidMount() {
    this._isMounted = true;
    await this.props.datasource.languageProvider.start();

    if (this._isMounted) {
      this.setState({
        labelsLoaded: true
      });
    }
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

  componentDidUpdate(prevProps) {
    const {
      range,
      datasource: {
        languageProvider
      }
    } = this.props;
    const refreshLabels = (0,_language_utils__WEBPACK_IMPORTED_MODULE_4__.shouldRefreshLabels)(range, prevProps.range); // We want to refresh labels when range changes (we round up intervals to a minute)

    if (refreshLabels) {
      languageProvider.fetchLabels();
    }
  }

  render() {
    const {
      ExtraFieldElement,
      query,
      datasource,
      placeholder = 'Enter a Loki query (run with Shift+Enter)'
    } = this.props;
    const {
      labelsLoaded,
      labelBrowserVisible
    } = this.state;
    const lokiLanguageProvider = datasource.languageProvider;
    const cleanText = datasource.languageProvider ? lokiLanguageProvider.cleanText : undefined;
    const hasLogLabels = lokiLanguageProvider.getLabelKeys().length > 0;
    const chooserText = getChooserText(labelsLoaded, hasLogLabels);
    const buttonDisabled = !(labelsLoaded && hasLogLabels);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_5__.LocalStorageValueProvider, {
      storageKey: LAST_USED_LABELS_KEY,
      defaultValue: [],
      children: (lastUsedLabels, onLastUsedLabelsSave, onLastUsedLabelsDelete) => {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
            className: "gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1",
            "data-testid": this.props['data-testid'],
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("button", {
              className: "gf-form-label query-keyword pointer",
              onClick: this.onClickChooserButton,
              disabled: buttonDisabled,
              children: [chooserText, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Icon, {
                name: labelBrowserVisible ? 'angle-down' : 'angle-right'
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
              className: "gf-form gf-form--grow flex-shrink-1 min-width-15",
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.QueryField, {
                additionalPlugins: this.plugins,
                cleanText: cleanText,
                query: query.expr,
                onTypeahead: this.onTypeahead,
                onWillApplySuggestion: willApplySuggestion,
                onChange: this.onChangeQuery,
                onBlur: this.props.onBlur,
                onRunQuery: this.props.onRunQuery,
                placeholder: placeholder,
                portalOrigin: "loki"
              })
            })]
          }), labelBrowserVisible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
            className: "gf-form",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_LokiLabelBrowser__WEBPACK_IMPORTED_MODULE_2__.LokiLabelBrowser, {
              languageProvider: lokiLanguageProvider,
              onChange: this.onChangeLabelBrowser,
              lastUsedLabels: lastUsedLabels || [],
              storeLastUsedLabels: onLastUsedLabelsSave,
              deleteLastUsedLabels: onLastUsedLabelsDelete
            })
          }), ExtraFieldElement]
        });
      }
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigEditor": () => (/* binding */ ConfigEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _MaxLinesField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx");
/* harmony import */ var _DerivedFields__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx");
/* harmony import */ var app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/alerting/unified/utils/alertmanager.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









const makeJsonUpdater = field => (options, value) => {
  return Object.assign({}, options, {
    jsonData: Object.assign({}, options.jsonData, {
      [field]: value
    })
  });
};

const setMaxLines = makeJsonUpdater('maxLines');
const setDerivedFields = makeJsonUpdater('derivedFields');
const ConfigEditor = props => {
  const {
    options,
    onOptionsChange
  } = props;
  const alertmanagers = (0,app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_4__.getAllAlertmanagerDataSources)();
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DataSourceHttpSettings, {
      defaultUrl: 'http://localhost:3100',
      dataSourceConfig: options,
      showAccessOptions: false,
      onChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.AlertingSettings, {
      alertmanagerDataSources: alertmanagers,
      options: options,
      onOptionsChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_MaxLinesField__WEBPACK_IMPORTED_MODULE_2__.MaxLinesField, {
            value: options.jsonData.maxLines || '',
            onChange: value => onOptionsChange(setMaxLines(options, value))
          })
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_DerivedFields__WEBPACK_IMPORTED_MODULE_3__.DerivedFields, {
      value: options.jsonData.derivedFields,
      onChange: value => onOptionsChange(setDerivedFields(options, value))
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DebugSection.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebugSection": () => (/* binding */ DebugSection)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/classnames-npm-2.3.1-f2ae0a8d3c-14db8889d5.zip/node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _features_explore_utils_links__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/features/explore/utils/links.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _thead;





const {
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_3__.LegacyForms;




const DebugSection = props => {
  const {
    derivedFields,
    className
  } = props;
  const [debugText, setDebugText] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');
  let debugFields = [];

  if (debugText && derivedFields) {
    debugFields = makeDebugFields(derivedFields, debugText);
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
    className: className,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(FormField, {
      labelWidth: 12,
      label: 'Debug log message',
      inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("textarea", {
        placeholder: 'Paste an example log line here to test the regular expressions of your derived fields',
        className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('gf-form-input gf-form-textarea', _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
                width: 100%;
              `),
        value: debugText,
        onChange: event => setDebugText(event.currentTarget.value)
      })
    }), !!debugFields.length && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(DebugFields, {
      fields: debugFields
    })]
  });
};

const DebugFields = ({
  fields
}) => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("table", {
    className: 'filter-table',
    children: [_thead || (_thead = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("thead", {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("tr", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Name"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Value"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("th", {
          children: "Url"
        })]
      })
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("tbody", {
      children: fields.map(field => {
        let value = field.value;

        if (field.error) {
          value = field.error.message;
        } else if (field.href) {
          value = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("a", {
            href: field.href,
            children: value
          });
        }

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("tr", {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: field.name
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: value
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("td", {
            children: field.href ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("a", {
              href: field.href,
              children: field.href
            }) : ''
          })]
        }, `${field.name}=${field.value}`);
      })
    })]
  });
};

function makeDebugFields(derivedFields, debugText) {
  return derivedFields.filter(field => field.name && field.matcherRegex).map(field => {
    try {
      const testMatch = debugText.match(field.matcherRegex);
      const value = testMatch && testMatch[1];
      let link = null;

      if (field.url && value) {
        link = (0,_features_explore_utils_links__WEBPACK_IMPORTED_MODULE_5__.getFieldLinksForExplore)({
          field: {
            name: '',
            type: _grafana_data__WEBPACK_IMPORTED_MODULE_4__.FieldType.string,
            values: new _grafana_data__WEBPACK_IMPORTED_MODULE_4__.ArrayVector([value]),
            config: {
              links: [{
                title: '',
                url: field.url
              }]
            }
          },
          rowIndex: 0,
          range: {}
        })[0];
      }

      return {
        name: field.name,
        value: value || '<no match>',
        href: link && link.href
      };
    } catch (error) {
      return {
        name: field.name,
        error
      };
    }
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DerivedField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DerivedField": () => (/* binding */ DerivedField)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







const {
  Switch,
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_2__.LegacyForms;
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.stylesFactory)(() => ({
  row: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    display: flex;
    align-items: baseline;
  `,
  nameField: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    flex: 2;
  `,
  regexField: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    flex: 3;
  `,
  urlField: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    flex: 1;
  `,
  urlDisplayLabelField: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    flex: 1;
  `
}));
const DerivedField = props => {
  const {
    value,
    onChange,
    onDelete,
    suggestions,
    className
  } = props;
  const styles = getStyles();
  const [showInternalLink, setShowInternalLink] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!!value.datasourceUid);
  const previousUid = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(value.datasourceUid); // Force internal link visibility change if uid changed outside of this component.

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!previousUid && value.datasourceUid && !showInternalLink) {
      setShowInternalLink(true);
    }

    if (previousUid && !value.datasourceUid && showInternalLink) {
      setShowInternalLink(false);
    }
  }, [previousUid, value.datasourceUid, showInternalLink]);

  const handleChange = field => event => {
    onChange(Object.assign({}, value, {
      [field]: event.currentTarget.value
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: className,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.nameField,
        labelWidth: 5 // A bit of a hack to prevent using default value for the width from FormField
        ,
        inputWidth: null,
        label: "Name",
        type: "text",
        value: value.name,
        onChange: handleChange('name')
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.regexField,
        inputWidth: null,
        label: "Regex",
        type: "text",
        value: value.matcherRegex,
        onChange: handleChange('matcherRegex'),
        tooltip: 'Use to parse and capture some part of the log message. You can use the captured groups in the template.'
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
        variant: "destructive",
        title: "Remove field",
        icon: "times",
        onClick: event => {
          event.preventDefault();
          onDelete();
        },
        className: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
            margin-left: 8px;
          `
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        label: showInternalLink ? 'Query' : 'URL',
        inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.DataLinkInput, {
          placeholder: showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}',
          value: value.url || '',
          onChange: newValue => onChange(Object.assign({}, value, {
            url: newValue
          })),
          suggestions: suggestions
        }),
        className: styles.urlField
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
        className: styles.urlDisplayLabelField,
        inputWidth: null,
        label: "URL Label",
        type: "text",
        value: value.urlDisplayLabel,
        onChange: handleChange('urlDisplayLabel'),
        tooltip: 'Use to override the button label when this derived field is found in a log.'
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.row,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Switch, {
        label: "Internal link",
        checked: showInternalLink,
        onChange: () => {
          if (showInternalLink) {
            onChange(Object.assign({}, value, {
              datasourceUid: undefined
            }));
          }

          setShowInternalLink(!showInternalLink);
        }
      }), showInternalLink && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.DataSourcePicker, {
        tracing: true,
        onChange: ds => onChange(Object.assign({}, value, {
          datasourceUid: ds.uid
        })),
        current: value.datasourceUid
      })]
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DerivedFields": () => (/* binding */ DerivedFields)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _DerivedField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DerivedField.tsx");
/* harmony import */ var _DebugSection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/DebugSection.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;











const getStyles = theme => ({
  infoText: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    padding-bottom: ${theme.spacing(2)};
    color: ${theme.colors.text.secondary};
  `,
  derivedField: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
    margin-bottom: ${theme.spacing(1)};
  `
});

const DerivedFields = props => {
  const {
    value,
    onChange
  } = props;
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme2)();
  const styles = getStyles(theme);
  const [showDebug, setShowDebug] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h3", {
      className: "page-heading",
      children: "Derived fields"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: styles.infoText,
      children: "Derived fields can be used to extract new fields from a log message and create a link from its value."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
      className: "gf-form-group",
      children: [value && value.map((field, index) => {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_DerivedField__WEBPACK_IMPORTED_MODULE_4__.DerivedField, {
          className: styles.derivedField,
          value: field,
          onChange: newField => {
            const newDerivedFields = [...value];
            newDerivedFields.splice(index, 1, newField);
            onChange(newDerivedFields);
          },
          onDelete: () => {
            const newDerivedFields = [...value];
            newDerivedFields.splice(index, 1);
            onChange(newDerivedFields);
          },
          suggestions: [{
            value: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.DataLinkBuiltInVars.valueRaw,
            label: 'Raw value',
            documentation: 'Exact string captured by the regular expression',
            origin: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.VariableOrigin.Value
          }]
        }, index);
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          variant: "secondary",
          className: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
              margin-right: 10px;
            `,
          icon: "plus",
          onClick: event => {
            event.preventDefault();
            const newDerivedFields = [...(value || []), {
              name: '',
              matcherRegex: ''
            }];
            onChange(newDerivedFields);
          },
          children: "Add"
        }), value && value.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          variant: "secondary",
          type: "button",
          onClick: () => setShowDebug(!showDebug),
          children: showDebug ? 'Hide example log message' : 'Show example log message'
        })]
      })]
    }), showDebug && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_DebugSection__WEBPACK_IMPORTED_MODULE_5__.DebugSection, {
        className: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
              margin-bottom: 10px;
            `,
        derivedFields: value
      })
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaxLinesField": () => (/* binding */ MaxLinesField)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




const {
  FormField
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_1__.LegacyForms;
const MaxLinesField = props => {
  const {
    value,
    onChange
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(FormField, {
    label: "Maximum lines",
    labelWidth: 11,
    inputWidth: 20,
    inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("input", {
      type: "number",
      className: "gf-form-input width-8 gf-form-input--has-help-icon",
      value: value,
      onChange: event => onChange(event.currentTarget.value),
      spellCheck: false,
      placeholder: "1000"
    }),
    tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
      children: "Loki queries must contain a limit of the maximum number of lines returned (default: 1000). Increase this limit to have a bigger result set for ad-hoc analysis. Decrease this limit if your browser becomes sluggish when displaying the log results."
    })
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/datasource.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_MAX_LINES": () => (/* binding */ DEFAULT_MAX_LINES),
/* harmony export */   "LOKI_ENDPOINT": () => (/* binding */ LOKI_ENDPOINT),
/* harmony export */   "LokiDatasource": () => (/* binding */ LokiDatasource),
/* harmony export */   "isMetricsQuery": () => (/* binding */ isMetricsQuery),
/* harmony export */   "lokiRegularEscape": () => (/* binding */ lokiRegularEscape),
/* harmony export */   "lokiSpecialRegexEscape": () => (/* binding */ lokiSpecialRegexEscape)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/catchError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/features/templating/template_srv.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/add_label_to_query.ts");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var app_core_utils_explore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/core/utils/explore.ts");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/loki/result_transformer.ts");
/* harmony import */ var _backendResultTransformer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/loki/backendResultTransformer.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var _live_streams__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/loki/live_streams.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/loki/language_provider.ts");
/* harmony import */ var _core_utils_fetch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/core/utils/fetch.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var app_core_logs_model__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/core/logs_model.ts");
/* harmony import */ var _streaming__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/plugins/datasource/loki/streaming.ts");
/* harmony import */ var _prometheus_legend__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
const _excluded = ["__interval", "__interval_ms"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Libraries



 // Types



















const DEFAULT_MAX_LINES = 1000;
const LOKI_ENDPOINT = '/loki/api/v1';
const NS_IN_MS = 1000000;
const RANGE_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query_range`;
const INSTANT_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query`;
const DEFAULT_QUERY_PARAMS = {
  direction: 'BACKWARD',
  limit: DEFAULT_MAX_LINES,
  query: ''
};
class LokiDatasource extends _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.DataSourceWithBackend {
  constructor(instanceSettings, templateSrv = (0,app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_4__.getTemplateSrv)(), timeSrv = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__.getTimeSrv)()) {
    var _settingsData$maxLine;

    super(instanceSettings);
    this.instanceSettings = instanceSettings;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;

    _defineProperty(this, "streams", new _live_streams__WEBPACK_IMPORTED_MODULE_12__.LiveStreams());

    _defineProperty(this, "languageProvider", void 0);

    _defineProperty(this, "maxLines", void 0);

    _defineProperty(this, "runInstantQuery", (target, options, responseListLength = 1) => {
      const timeNs = this.getTime(options.range.to, true);
      const queryLimit = isMetricsQuery(target.expr) ? options.maxDataPoints : target.maxLines;
      const query = {
        query: target.expr,
        time: `${timeNs + (1e9 - timeNs % 1e9)}`,
        limit: Math.min(queryLimit || Infinity, this.maxLines)
      };
      /** Used only for results of metrics instant queries */

      const meta = {
        preferredVisualisationType: 'table'
      };
      return this._request(INSTANT_QUERY_ENDPOINT, query).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.map)(response => {
        if (response.data.data.resultType === _types__WEBPACK_IMPORTED_MODULE_11__.LokiResultType.Stream) {
          return {
            data: response.data ? (0,_result_transformer__WEBPACK_IMPORTED_MODULE_8__.lokiStreamsToDataFrames)(response.data, target, query.limit, this.instanceSettings.jsonData) : [],
            key: `${target.refId}_instant`
          };
        }

        return {
          data: [(0,_result_transformer__WEBPACK_IMPORTED_MODULE_8__.lokiResultsToTableModel)(response.data.data.result, responseListLength, target.refId, meta, true)],
          key: `${target.refId}_instant`
        };
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.catchError)(err => (0,rxjs__WEBPACK_IMPORTED_MODULE_22__.throwError)(() => this.processError(err, target))));
    });

    _defineProperty(this, "runRangeQuery", (target, options, responseListLength = 1) => {
      // For metric query we use maxDataPoints from the request options which should be something like width of the
      // visualisation in pixels. In case of logs request we either use lines limit defined in the query target or
      // global limit defined for the data source which ever is lower.
      let maxDataPoints = isMetricsQuery(target.expr) ? // We fallback to maxLines here because maxDataPoints is defined as possibly undefined. Not sure that can
      // actually happen both Dashboards and Explore should send some value here. If not maxLines does not make that
      // much sense but nor any other arbitrary value.
      options.maxDataPoints || this.maxLines : // If user wants maxLines 0 we still fallback to data source limit. I think that makes sense as why would anyone
      // want to do a query and not see any results?
      target.maxLines || this.maxLines;

      if (options.liveStreaming) {
        return this.runLiveQuery(target, maxDataPoints);
      }

      const query = this.createRangeQuery(target, options, maxDataPoints);
      const headers = target.volumeQuery ? {
        'X-Query-Tags': 'Source=logvolhist'
      } : undefined;
      return this._request(RANGE_QUERY_ENDPOINT, query, {
        headers
      }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.catchError)(err => (0,rxjs__WEBPACK_IMPORTED_MODULE_22__.throwError)(() => this.processError(err, target))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.switchMap)(response => (0,_result_transformer__WEBPACK_IMPORTED_MODULE_8__.processRangeQueryResponse)(response.data, target, query, responseListLength, maxDataPoints, this.instanceSettings.jsonData, options.scopedVars, options.reverse)));
    });

    _defineProperty(this, "runLiveQuery", (target, maxDataPoints) => {
      const liveTarget = this.createLiveTarget(target, maxDataPoints);
      return this.streams.getStream(liveTarget).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.map)(data => ({
        data: data || [],
        key: `loki-${liveTarget.refId}`,
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LoadingState.Streaming
      })), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.catchError)(err => {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_22__.throwError)(() => `Live tailing was stopped due to following error: ${err.reason}`);
      }));
    });

    _defineProperty(this, "getLogRowContext", (row, options) => {
      const target = this.prepareLogRowContextQueryTarget(row, options && options.limit || 10, options && options.direction || 'BACKWARD');
      const reverse = options && options.direction === 'FORWARD';
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.lastValueFrom)(this._request(RANGE_QUERY_ENDPOINT, target).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.catchError)(err => {
        const error = {
          message: 'Error during context query. Please check JS console logs.',
          status: err.status,
          statusText: err.statusText
        };
        throw error;
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.switchMap)(res => (0,rxjs__WEBPACK_IMPORTED_MODULE_25__.of)({
        data: res.data ? res.data.data.result.map(stream => (0,_result_transformer__WEBPACK_IMPORTED_MODULE_8__.lokiStreamResultToDataFrame)(stream, reverse)) : []
      }))));
    });

    _defineProperty(this, "prepareLogRowContextQueryTarget", (row, limit, direction) => {
      const labels = this.languageProvider.getLabelKeys();
      const query = Object.keys(row.labels).map(label => {
        if (labels.includes(label)) {
          // escape backslashes in label as users can't escape them by themselves
          return `${label}="${row.labels[label].replace(/\\/g, '\\\\')}"`;
        }

        return '';
      }) // Filter empty strings
      .filter(label => !!label).join(',');
      const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer

      const commonTargetOptions = {
        limit,
        query: `{${query}}`,
        expr: `{${query}}`,
        direction
      };
      const fieldCache = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldCache(row.dataFrame);
      const nsField = fieldCache.getFieldByName('tsNs');
      const nsTimestamp = nsField.values.get(row.rowIndex);

      if (direction === 'BACKWARD') {
        return Object.assign({}, commonTargetOptions, {
          // convert to ns, we loose some precision here but it is not that important at the far points of the context
          start: row.timeEpochMs - contextTimeBuffer + '000000',
          end: nsTimestamp,
          direction
        });
      } else {
        return Object.assign({}, commonTargetOptions, {
          // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from
          // and any other that were logged in the same ns but before the row. Right now these rows will be lost
          // because the are before but came it he response that should return only rows after.
          start: nsTimestamp,
          // convert to ns, we loose some precision here but it is not that important at the far points of the context
          end: row.timeEpochMs + contextTimeBuffer + '000000'
        });
      }
    });

    this.instanceSettings = instanceSettings;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.languageProvider = new _language_provider__WEBPACK_IMPORTED_MODULE_13__["default"](this);
    const settingsData = instanceSettings.jsonData || {};
    this.maxLines = parseInt((_settingsData$maxLine = settingsData.maxLines) !== null && _settingsData$maxLine !== void 0 ? _settingsData$maxLine : '0', 10) || DEFAULT_MAX_LINES;
  }

  _request(apiUrl, data, options) {
    const baseUrl = this.instanceSettings.url;
    const params = data ? (0,_core_utils_fetch__WEBPACK_IMPORTED_MODULE_14__.serializeParams)(data) : '';
    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;

    if (this.instanceSettings.withCredentials || this.instanceSettings.basicAuth) {
      options = Object.assign({}, options, {
        withCredentials: true
      });

      if (this.instanceSettings.basicAuth) {
        options.headers = Object.assign({}, options.headers, {
          Authorization: this.instanceSettings.basicAuth
        });
      }
    }

    const req = Object.assign({}, options, {
      url
    });
    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.getBackendSrv)().fetch(req);
  }

  getLogsVolumeDataProvider(request) {
    const isLogsVolumeAvailable = request.targets.some(target => target.expr && !isMetricsQuery(target.expr));

    if (!isLogsVolumeAvailable) {
      return undefined;
    }

    const logsVolumeRequest = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(request);
    logsVolumeRequest.targets = logsVolumeRequest.targets.filter(target => target.expr && !isMetricsQuery(target.expr)).map(target => {
      return Object.assign({}, target, {
        instant: false,
        volumeQuery: true,
        expr: `sum by (level) (count_over_time(${target.expr}[$__interval]))`
      });
    });
    return (0,app_core_logs_model__WEBPACK_IMPORTED_MODULE_17__.queryLogsVolume)(this, logsVolumeRequest, {
      extractLevel,
      range: request.range,
      targets: request.targets
    });
  }

  query(request) {
    const subQueries = [];
    const scopedVars = Object.assign({}, request.scopedVars, this.getRangeScopedVars(request.range));
    const shouldRunBackendQuery = _grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.featureToggles.lokiBackendMode && request.app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore;

    if (shouldRunBackendQuery) {
      // we "fix" the loki queries to have `.queryType` and not have `.instant` and `.range`
      const fixedRequest = Object.assign({}, request, {
        targets: request.targets.map(_query_utils__WEBPACK_IMPORTED_MODULE_10__.getNormalizedLokiQuery)
      });
      return super.query(fixedRequest).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.map)(response => (0,_backendResultTransformer__WEBPACK_IMPORTED_MODULE_9__.transformBackendResult)(response, fixedRequest)));
    }

    const filteredTargets = request.targets.filter(target => target.expr && !target.hide).map(target => {
      const expr = this.addAdHocFilters(target.expr);
      return Object.assign({}, target, {
        expr: this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr)
      });
    });

    for (const target of filteredTargets) {
      var _request$rangeRaw;

      if (target.instant || target.queryType === _types__WEBPACK_IMPORTED_MODULE_11__.LokiQueryType.Instant) {
        subQueries.push(this.runInstantQuery(target, request, filteredTargets.length));
      } else if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_3__.config.featureToggles.lokiLive && target.queryType === _types__WEBPACK_IMPORTED_MODULE_11__.LokiQueryType.Stream && ((_request$rangeRaw = request.rangeRaw) === null || _request$rangeRaw === void 0 ? void 0 : _request$rangeRaw.to) === 'now') {
        subQueries.push((0,_streaming__WEBPACK_IMPORTED_MODULE_18__.doLokiChannelStream)(target, this, request));
      } else {
        subQueries.push(this.runRangeQuery(target, request, filteredTargets.length));
      }
    } // No valid targets, return the empty result to save a round trip.


    if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(subQueries)) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_25__.of)({
        data: [],
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LoadingState.Done
      });
    }

    return (0,rxjs__WEBPACK_IMPORTED_MODULE_26__.merge)(...subQueries);
  }

  createRangeQuery(target, options, limit) {
    const query = target.expr;
    let range = {};

    if (options.range) {
      const startNs = this.getTime(options.range.from, false);
      const endNs = this.getTime(options.range.to, true);
      const rangeMs = Math.ceil((endNs - startNs) / 1e6);
      const resolution = target.resolution || _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_16__.DEFAULT_RESOLUTION.value;
      const adjustedInterval = this.adjustInterval(options.intervalMs || 1000, resolution, rangeMs) / 1000; // We want to ceil to 3 decimal places

      const step = Math.ceil(adjustedInterval * 1000) / 1000;
      range = {
        start: startNs,
        end: endNs,
        step
      };
    }

    return Object.assign({}, DEFAULT_QUERY_PARAMS, range, {
      query,
      limit
    });
  }
  /**
   * Attempts to send a query to /loki/api/v1/query_range
   */


  createLiveTarget(target, maxDataPoints) {
    const query = target.expr;
    const baseUrl = this.instanceSettings.url;
    const params = (0,_core_utils_fetch__WEBPACK_IMPORTED_MODULE_14__.serializeParams)({
      query
    });
    return {
      query,
      url: (0,app_core_utils_explore__WEBPACK_IMPORTED_MODULE_7__.convertToWebSocketUrl)(`${baseUrl}/loki/api/v1/tail?${params}`),
      refId: target.refId,
      size: maxDataPoints
    };
  }
  /**
   * Runs live queries which in this case means creating a websocket and listening on it for new logs.
   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple
   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique
   * labels per row.
   */


  getRangeScopedVars(range = this.timeSrv.timeRange()) {
    const msRange = range.to.diff(range.from);
    const sRange = Math.round(msRange / 1000);
    return {
      __range_ms: {
        text: msRange,
        value: msRange
      },
      __range_s: {
        text: sRange,
        value: sRange
      },
      __range: {
        text: sRange + 's',
        value: sRange + 's'
      }
    };
  }

  interpolateVariablesInQueries(queries, scopedVars) {
    let expandedQueries = queries;

    if (queries && queries.length) {
      expandedQueries = queries.map(query => Object.assign({}, query, {
        datasource: this.getRef(),
        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr)
      }));
    }

    return expandedQueries;
  }

  getQueryDisplayText(query) {
    return query.expr;
  }

  getTimeRangeParams() {
    const timeRange = this.timeSrv.timeRange();
    return {
      start: timeRange.from.valueOf() * NS_IN_MS,
      end: timeRange.to.valueOf() * NS_IN_MS
    };
  }

  async importFromAbstractQueries(abstractQueries) {
    await this.languageProvider.start();
    const existingKeys = this.languageProvider.labelKeys;

    if (existingKeys && existingKeys.length) {
      abstractQueries = abstractQueries.map(abstractQuery => {
        abstractQuery.labelMatchers = abstractQuery.labelMatchers.filter(labelMatcher => {
          return existingKeys.includes(labelMatcher.name);
        });
        return abstractQuery;
      });
    }

    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));
  }

  async exportToAbstractQueries(queries) {
    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));
  }

  async metadataRequest(url, params) {
    const res = await (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.lastValueFrom)(this._request(url, params, {
      hideFromInspector: true
    }));
    return res.data.data || res.data.values || [];
  }

  async metricFindQuery(query) {
    if (!query) {
      return Promise.resolve([]);
    }

    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);
    return await this.processMetricFindQuery(interpolated);
  }

  async processMetricFindQuery(query) {
    const labelNamesRegex = /^label_names\(\)\s*$/;
    const labelValuesRegex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\)\s*$/;
    const labelNames = query.match(labelNamesRegex);

    if (labelNames) {
      return await this.labelNamesQuery();
    }

    const labelValues = query.match(labelValuesRegex);

    if (labelValues) {
      // If we have query expr, use /series endpoint
      if (labelValues[1]) {
        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);
      }

      return await this.labelValuesQuery(labelValues[2]);
    }

    return Promise.resolve([]);
  }

  async labelNamesQuery() {
    const url = `${LOKI_ENDPOINT}/label`;
    const params = this.getTimeRangeParams();
    const result = await this.metadataRequest(url, params);
    return result.map(value => ({
      text: value
    }));
  }

  async labelValuesQuery(label) {
    const params = this.getTimeRangeParams();
    const url = `${LOKI_ENDPOINT}/label/${label}/values`;
    const result = await this.metadataRequest(url, params);
    return result.map(value => ({
      text: value
    }));
  }

  async labelValuesSeriesQuery(expr, label) {
    const timeParams = this.getTimeRangeParams();
    const params = Object.assign({}, timeParams, {
      'match[]': expr
    });
    const url = `${LOKI_ENDPOINT}/series`;
    const streams = new Set();
    const result = await this.metadataRequest(url, params);
    result.forEach(stream => {
      if (stream[label]) {
        streams.add({
          text: stream[label]
        });
      }
    });
    return Array.from(streams);
  } // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality


  async getTagKeys() {
    return await this.labelNamesQuery();
  }

  async getTagValues(options = {}) {
    return await this.labelValuesQuery(options.key);
  }

  interpolateQueryExpr(value, variable) {
    // if no multi or include all do not regexEscape
    if (!variable.multi && !variable.includeAll) {
      return lokiRegularEscape(value);
    }

    if (typeof value === 'string') {
      return lokiSpecialRegexEscape(value);
    }

    const escapedValues = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(value, lokiSpecialRegexEscape);
    return escapedValues.join('|');
  }

  modifyQuery(query, action) {
    var _query$expr;

    let expression = (_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '';

    switch (action.type) {
      case 'ADD_FILTER':
        {
          expression = this.addLabelToQuery(expression, action.key, action.value, '=');
          break;
        }

      case 'ADD_FILTER_OUT':
        {
          expression = this.addLabelToQuery(expression, action.key, action.value, '!=');
          break;
        }

      default:
        break;
    }

    return Object.assign({}, query, {
      expr: expression
    });
  }

  getTime(date, roundUp) {
    if (typeof date === 'string') {
      date = _grafana_data__WEBPACK_IMPORTED_MODULE_2__.dateMath.parse(date, roundUp);
    }

    return Math.ceil(date.valueOf() * 1e6);
  }

  testDatasource() {
    // Consider only last 10 minutes otherwise request takes too long
    const startMs = Date.now() - 10 * 60 * 1000;
    const start = `${startMs}000000`; // API expects nanoseconds

    return (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.lastValueFrom)(this._request(`${LOKI_ENDPOINT}/label`, {
      start
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.map)(res => {
      var _res$data, _res$data2;

      const values = (res === null || res === void 0 ? void 0 : (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.data) || (res === null || res === void 0 ? void 0 : (_res$data2 = res.data) === null || _res$data2 === void 0 ? void 0 : _res$data2.values) || [];
      const testResult = values.length > 0 ? {
        status: 'success',
        message: 'Data source connected and labels found.'
      } : {
        status: 'error',
        message: 'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.'
      };
      return testResult;
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.catchError)(err => {
      let message = 'Loki: ';

      if (err.statusText) {
        message += err.statusText;
      } else {
        message += 'Cannot connect to Loki';
      }

      if (err.status) {
        message += `. ${err.status}`;
      }

      if (err.data && err.data.message) {
        message += `. ${err.data.message}`;
      } else if (err.data) {
        message += `. ${err.data}`;
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_25__.of)({
        status: 'error',
        message: message
      });
    })));
  }

  async annotationQuery(options) {
    const {
      expr,
      maxLines,
      instant,
      stepInterval,
      tagKeys = '',
      titleFormat = '',
      textFormat = ''
    } = options.annotation;

    if (!expr) {
      return [];
    }

    const interpolatedExpr = this.templateSrv.replace(expr, {}, this.interpolateQueryExpr);
    const query = {
      refId: `annotation-${options.annotation.name}`,
      expr: interpolatedExpr,
      maxLines,
      instant,
      stepInterval,
      queryType: instant ? _types__WEBPACK_IMPORTED_MODULE_11__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_11__.LokiQueryType.Range
    };
    const {
      data
    } = instant ? await (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.lastValueFrom)(this.runInstantQuery(query, options)) : await (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.lastValueFrom)(this.runRangeQuery(query, options));
    const annotations = [];
    const splitKeys = tagKeys.split(',').filter(v => v !== '');

    for (const frame of data) {
      const labels = {};

      for (const field of frame.fields) {
        if (field.labels) {
          for (const [key, value] of Object.entries(field.labels)) {
            labels[key] = String(value).trim();
          }
        }
      }

      const tags = [...new Set(Object.entries(labels).reduce((acc, [key, val]) => {
        if (val === '') {
          return acc;
        }

        if (splitKeys.length && !splitKeys.includes(key)) {
          return acc;
        }

        acc.push.apply(acc, [val]);
        return acc;
      }, []))];
      const view = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.DataFrameView(frame);
      view.forEach(row => {
        annotations.push({
          time: new Date(row.ts).valueOf(),
          title: (0,_prometheus_legend__WEBPACK_IMPORTED_MODULE_19__.renderLegendFormat)(titleFormat, labels),
          text: (0,_prometheus_legend__WEBPACK_IMPORTED_MODULE_19__.renderLegendFormat)(textFormat, labels) || row.line,
          tags
        });
      });
    }

    return annotations;
  }

  showContextToggle(row) {
    return (row && row.searchWords && row.searchWords.length > 0) === true;
  }

  processError(err, target) {
    let error = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(err);

    if (err.data.message.includes('escape') && target.expr.includes('\\')) {
      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;
    }

    return error;
  }

  adjustInterval(dynamicInterval, resolution, range) {
    // Loki will drop queries that might return more than 11000 data points.
    // Calibrate interval if it is too small.
    let safeInterval = range / 11000;

    if (safeInterval > 1) {
      safeInterval = Math.ceil(safeInterval);
    }

    let adjustedInterval = Math.max(resolution * dynamicInterval, safeInterval);
    return adjustedInterval;
  }

  addAdHocFilters(queryExpr) {
    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    let expr = queryExpr;
    expr = adhocFilters.reduce((acc, filter) => {
      const {
        key,
        operator
      } = filter;
      let {
        value
      } = filter;

      if (operator === '=~' || operator === '!~') {
        value = lokiRegularEscape(value);
      }

      return this.addLabelToQuery(acc, key, value, operator, true);
    }, expr);
    return expr;
  }

  addLabelToQuery(queryExpr, key, value, operator, // Override to make sure that we use label as actual label and not parsed label
  notParsedLabelOverride) {
    if ((0,_query_utils__WEBPACK_IMPORTED_MODULE_10__.queryHasPipeParser)(queryExpr) && !isMetricsQuery(queryExpr) && !notParsedLabelOverride) {
      // If query has parser, we treat all labels as parsed and use | key="value" syntax
      return (0,_query_utils__WEBPACK_IMPORTED_MODULE_10__.addParsedLabelToQuery)(queryExpr, key, value, operator);
    } else {
      return (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_5__.addLabelToQuery)(queryExpr, key, value, operator, true);
    }
  } // Used when running queries through backend


  filterQuery(query) {
    if (query.hide || query.expr === '') {
      return false;
    }

    return true;
  } // Used when running queries through backend


  applyTemplateVariables(target, scopedVars) {
    // We want to interpolate these variables on backend
    const rest = _objectWithoutPropertiesLoose(scopedVars, _excluded);

    return Object.assign({}, target, {
      legendFormat: this.templateSrv.replace(target.legendFormat, rest),
      expr: this.templateSrv.replace(target.expr, rest, this.interpolateQueryExpr)
    });
  }

  interpolateString(string) {
    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);
  }

  getVariables() {
    return this.templateSrv.getVariables().map(v => `$${v.name}`);
  }

}
function lokiRegularEscape(value) {
  if (typeof value === 'string') {
    return value.replace(/'/g, "\\\\'");
  }

  return value;
}
function lokiSpecialRegexEscape(value) {
  if (typeof value === 'string') {
    return lokiRegularEscape(value.replace(/\\/g, '\\\\\\\\').replace(/[$^*{}\[\]+?.()|]/g, '\\\\$&'));
  }

  return value;
}
/**
 * Checks if the query expression uses function and so should return a time series instead of logs.
 * Sometimes important to know that before we actually do the query.
 */

function isMetricsQuery(query) {
  if (!query) {
    return false;
  }

  const tokens = prismjs__WEBPACK_IMPORTED_MODULE_1___default().tokenize(query, _syntax__WEBPACK_IMPORTED_MODULE_15__["default"]);
  return tokens.some(t => {
    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function
    return typeof t !== 'string' && t.type === 'function';
  });
}

function extractLevel(dataFrame) {
  var _valueField;

  let valueField;

  try {
    valueField = new _grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldCache(dataFrame).getFirstFieldOfType(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.FieldType.number);
  } catch {}

  return (_valueField = valueField) !== null && _valueField !== void 0 && _valueField.labels ? getLogLevelFromLabels(valueField.labels) : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LogLevel.unknown;
}

function getLogLevelFromLabels(labels) {
  const labelNames = ['level', 'lvl', 'loglevel'];
  let levelLabel;

  for (let labelName of labelNames) {
    if (labelName in labels) {
      levelLabel = labelName;
      break;
    }
  }

  return levelLabel ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.getLogLevelFromKey)(labels[levelLabel]) : _grafana_data__WEBPACK_IMPORTED_MODULE_2__.LogLevel.unknown;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LABEL_REFRESH_INTERVAL": () => (/* binding */ LABEL_REFRESH_INTERVAL),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ LokiLanguageProvider)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.7.1-726274dc4d-f362c5a2cf.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_6__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Libraries

 // Services & Utils


 // Types




const DEFAULT_KEYS = ['job', 'namespace'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 10;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h

const NS_IN_MS = 1000000; // When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too
// @see public/app/plugins/datasource/prometheus/promql.ts

const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec

const wrapLabel = label => ({
  label,
  filterText: `\"${label}\"`
});

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query.expr === item.label);
  let hint = `Queried ${historyForItem.length} times in the last 24h.`;
  const recent = historyForItem[0];

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_5__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}
class LokiLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_5__.LanguageProvider {
  // Dynamically set to true for big/slow instances

  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "labelKeys", void 0);

    _defineProperty(this, "labelFetchTs", void 0);

    _defineProperty(this, "started", false);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "lookupsDisabled", false);

    _defineProperty(this, "seriesCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "cleanText", s => s.replace(/[{}[\]="(),!~+\-*/^%\|]/g, '').trim());

    _defineProperty(this, "request", async (url, params) => {
      try {
        return await this.datasource.metadataRequest(url, params);
      } catch (error) {
        console.error(error);
      }

      return undefined;
    });

    _defineProperty(this, "start", () => {
      if (!this.startTask) {
        this.startTask = this.fetchLabels().then(() => {
          this.started = true;
          return [];
        });
      }

      return this.startTask;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const suggestions = [];
      suggestions.push({
        prefixMatch: true,
        label: 'Functions',
        items: _syntax__WEBPACK_IMPORTED_MODULE_3__.FUNCTIONS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'function'
        }))
      });
      return {
        suggestions
      };
    });

    _defineProperty(this, "getPipeCompletionItem", () => {
      const suggestions = [];
      suggestions.push({
        label: 'Operators',
        items: _syntax__WEBPACK_IMPORTED_MODULE_3__.PIPE_OPERATORS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'operators'
        }))
      });
      suggestions.push({
        label: 'Parsers',
        items: _syntax__WEBPACK_IMPORTED_MODULE_3__.PIPE_PARSERS.map(suggestion => Object.assign({}, suggestion, {
          kind: 'parsers'
        }))
      });
      return {
        suggestions
      };
    });

    _defineProperty(this, "fetchSeriesLabels", async match => {
      const interpolatedMatch = this.datasource.interpolateString(match);
      const url = '/loki/api/v1/series';
      const {
        start,
        end
      } = this.datasource.getTimeRangeParams();
      const cacheKey = this.generateCacheKey(url, start, end, interpolatedMatch);
      let value = this.seriesCache.get(cacheKey);

      if (!value) {
        // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.
        this.seriesCache.set(cacheKey, {});
        const params = {
          'match[]': interpolatedMatch,
          start,
          end
        };
        const data = await this.request(url, params);
        const {
          values
        } = (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_2__.processLabels)(data);
        value = values;
        this.seriesCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = '/loki/api/v1/series';
      const {
        start,
        end
      } = this.datasource.getTimeRangeParams();
      const params = {
        'match[]': match,
        start,
        end
      };
      return await this.request(url, params);
    });

    this.datasource = datasource;
    this.labelKeys = [];
    this.labelFetchTs = 0;
    Object.assign(this, initialValues);
  } // Strip syntax chars


  getSyntax() {
    return _syntax__WEBPACK_IMPORTED_MODULE_3__["default"];
  }

  getLabelKeys() {
    return this.labelKeys;
  }
  /**
   * Return suggestions based on input that can be then plugged into a typeahead dropdown.
   * Keep this DOM-free for testing
   * @param input
   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems
   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems
   * @param context.history Optional used only in getEmptyCompletionItems
   */


  async provideCompletionItems(input, context) {
    const {
      wrapperClasses,
      value,
      prefix,
      text
    } = input;
    const emptyResult = {
      suggestions: []
    };

    if (!value) {
      return emptyResult;
    } // Local text properties


    const empty = (value === null || value === void 0 ? void 0 : value.document.text.length) === 0;
    const selectedLines = value.document.getTextsAtRange(value.selection);
    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

    const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

    const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

    const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

    const safePrefix = prefix && !text.match(/^['"~=\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

    const operatorsPattern = /[+\-*/^%]/;
    const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

    if (wrapperClasses.includes('context-range')) {
      // Suggestions for metric[|]
      return this.getRangeCompletionItems();
    } else if (wrapperClasses.includes('context-labels')) {
      // Suggestions for {|} and {foo=|}
      return await this.getLabelCompletionItems(input);
    } else if (wrapperClasses.includes('context-pipe')) {
      return this.getPipeCompletionItem();
    } else if (empty) {
      // Suggestions for empty query field
      return this.getEmptyCompletionItems(context);
    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
      // Show term suggestions in a couple of scenarios
      return this.getBeginningCompletionItems(context);
    } else if (prefixUnrecognized && safePrefix) {
      // Show term suggestions in a couple of scenarios
      return this.getTermCompletionItems();
    }

    return emptyResult;
  }

  getEmptyCompletionItems(context) {
    const history = context === null || context === void 0 ? void 0 : context.history;
    const suggestions = [];

    if (history !== null && history !== void 0 && history.length) {
      const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
      suggestions.push({
        prefixMatch: true,
        skipSort: true,
        label: 'History',
        items: historyItems
      });
    }

    return {
      suggestions
    };
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [...RATE_RANGES]
      }]
    };
  }

  async getLabelCompletionItems({
    text,
    wrapperClasses,
    labelKey,
    value
  }) {
    let context = 'context-labels';
    const suggestions = [];

    if (!value) {
      return {
        context,
        suggestions: []
      };
    }

    const line = value.anchorBlock.getText();
    const cursorOffset = value.selection.anchor.offset;
    const isValueStart = text.match(/^(=|=~|!=|!~)/); // Get normalized selector

    let selector;
    let parsedSelector;

    try {
      parsedSelector = (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_2__.parseSelector)(line, cursorOffset);
      selector = parsedSelector.selector;
    } catch {
      selector = EMPTY_SELECTOR;
    }

    if (!labelKey && selector === EMPTY_SELECTOR) {
      // start task gets all labels
      await this.start();
      const allLabels = this.getLabelKeys();
      return {
        context,
        suggestions: [{
          label: `Labels`,
          items: allLabels.map(wrapLabel)
        }]
      };
    }

    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
    let labelValues; // Query labels for selector

    if (selector) {
      if (selector === EMPTY_SELECTOR && labelKey) {
        const labelValuesForKey = await this.getLabelValues(labelKey);
        labelValues = {
          [labelKey]: labelValuesForKey
        };
      } else {
        labelValues = await this.getSeriesLabels(selector);
      }
    }

    if (!labelValues) {
      console.warn(`Server did not return any values for selector = ${selector}`);
      return {
        context,
        suggestions
      };
    }

    if (text && isValueStart || wrapperClasses.includes('attr-value')) {
      // Label values
      if (labelKey && labelValues[labelKey]) {
        context = 'context-label-values';
        suggestions.push({
          label: `Label values for "${labelKey}"`,
          // Filter to prevent previously selected values from being repeatedly suggested
          items: labelValues[labelKey].map(wrapLabel).filter(({
            filterText
          }) => filterText !== text)
        });
      }
    } else {
      // Label keys
      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;

      if (labelKeys) {
        const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

        if (possibleKeys.length) {
          const newItems = possibleKeys.map(key => ({
            label: key
          }));
          const newSuggestion = {
            label: `Labels`,
            items: newItems
          };
          suggestions.push(newSuggestion);
        }
      }
    }

    return {
      context,
      suggestions
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return {
      refId: labelBasedQuery.refId,
      expr: (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_2__.toPromLikeExpr)(labelBasedQuery),
      queryType: _types__WEBPACK_IMPORTED_MODULE_4__.LokiQueryType.Range
    };
  }

  exportToAbstractQuery(query) {
    const lokiQuery = query.expr;

    if (!lokiQuery || lokiQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_6___default().tokenize(lokiQuery, _syntax__WEBPACK_IMPORTED_MODULE_3__["default"]);
    return {
      refId: query.refId,
      labelMatchers: (0,app_plugins_datasource_prometheus_language_utils__WEBPACK_IMPORTED_MODULE_2__.extractLabelMatchers)(tokens)
    };
  }

  async getSeriesLabels(selector) {
    if (this.lookupsDisabled) {
      return undefined;
    }

    try {
      return await this.fetchSeriesLabels(selector);
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return undefined;
    }
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = '/loki/api/v1/label';
    const timeRange = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, timeRange);

    if (Array.isArray(res)) {
      const labels = res.slice().sort().filter(label => label !== '__name__');
      this.labelKeys = labels;
    }

    return [];
  }

  async refreshLogLabels(forceRefresh) {
    if (this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL || forceRefresh) {
      await this.fetchLabels();
    }
  }
  /**
   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   */


  // Cache key is a bit different here. We round up to a minute the intervals.
  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
  // millisecond while still actually getting all the keys for the correct interval. This still can create problems
  // when user does not the newest values for a minute if already cached.
  generateCacheKey(url, start, end, param) {
    return [url, this.roundTime(start), this.roundTime(end), param].join();
  } // Round nanos epoch to nearest 5 minute interval


  roundTime(nanos) {
    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }

  async fetchLabelValues(key) {
    var _labelValues;

    const interpolatedKey = this.datasource.interpolateString(key);
    const url = `/loki/api/v1/label/${interpolatedKey}/values`;
    const rangeParams = this.datasource.getTimeRangeParams();
    const {
      start,
      end
    } = rangeParams;
    const cacheKey = this.generateCacheKey(url, start, end, interpolatedKey);
    const params = {
      start,
      end
    };
    let labelValues = this.labelsCache.get(cacheKey);

    if (!labelValues) {
      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.
      this.labelsCache.set(cacheKey, []);
      const res = await this.request(url, params);

      if (Array.isArray(res)) {
        labelValues = res.slice().sort();
        this.labelsCache.set(cacheKey, labelValues);
      }
    }

    return (_labelValues = labelValues) !== null && _labelValues !== void 0 ? _labelValues : [];
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shouldRefreshLabels": () => (/* binding */ shouldRefreshLabels)
/* harmony export */ });
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}

function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}

function shouldRefreshLabels(range, prevRange) {
  if (range && prevRange) {
    const sameMinuteFrom = roundMsToMin(range.from.valueOf()) === roundMsToMin(prevRange.from.valueOf());
    const sameMinuteTo = roundMsToMin(range.to.valueOf()) === roundMsToMin(prevRange.to.valueOf()); // If both are same, don't need to refresh

    return !(sameMinuteFrom && sameMinuteTo);
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/live_streams.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LiveStreams": () => (/* binding */ LiveStreams)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/timer.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs_webSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/finalize.js");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/result_transformer.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






/**
 * Maps directly to a query in the UI (refId is key)
 */

/**
 * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular
 * target it is returned and on subscription returns the latest dataFrame.
 */
class LiveStreams {
  constructor() {
    _defineProperty(this, "streams", {});
  }

  getStream(target, retryInterval = 5000) {
    let stream = this.streams[target.url];

    if (stream) {
      return stream;
    }

    const data = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.CircularDataFrame({
      capacity: target.size
    });
    data.addField({
      name: 'ts',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time,
      config: {
        displayName: 'Time'
      }
    });
    data.addField({
      name: 'tsNs',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time,
      config: {
        displayName: 'Time ns'
      }
    });
    data.addField({
      name: 'line',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string
    }).labels = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.parseLabels)(target.query);
    data.addField({
      name: 'labels',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.other
    }); // The labels for each line

    data.addField({
      name: 'id',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string
    });
    data.meta = Object.assign({}, data.meta, {
      preferredVisualisationType: 'logs'
    });
    data.refId = target.refId;
    stream = (0,rxjs_webSocket__WEBPACK_IMPORTED_MODULE_2__.webSocket)(target.url).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(response => {
      (0,_result_transformer__WEBPACK_IMPORTED_MODULE_1__.appendResponseToBufferedData)(response, data);
      return [data];
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.retryWhen)(attempts => attempts.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.mergeMap)((error, i) => {
      const retryAttempt = i + 1; // Code 1006 is used to indicate that a connection was closed abnormally.
      // Added hard limit of 30 on number of retries.
      // If connection was closed abnormally, and we wish to retry, otherwise throw error.

      if (error.code === 1006 && retryAttempt < 30) {
        if (retryAttempt > 10) {
          // If more than 10 times retried, consol.warn, but keep reconnecting
          console.warn(`Websocket connection is being disrupted. We keep reconnecting but consider starting new live tailing again. Error: ${error.reason}`);
        } // Retry every 5s


        return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.timer)(retryInterval);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_7__.throwError)(error);
    }))), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.finalize)(() => {
      delete this.streams[target.url];
    }));
    this.streams[target.url] = stream;
    return stream;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/makeIdField.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeIdField": () => (/* binding */ makeIdField)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");


const UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';

function createUid(text, usedUids, refId) {
  var _usedUids$get;

  const id = (0,uuid__WEBPACK_IMPORTED_MODULE_1__["default"])(text, UUID_NAMESPACE); // check how many times have we seen this id before,
  // set the count to zero, if never.

  const count = (_usedUids$get = usedUids.get(id)) !== null && _usedUids$get !== void 0 ? _usedUids$get : 0; // if we have seen this id before, we need to make
  // it unique by appending the seen-count
  // (starts with 1, and goes up)

  const uniqueId = count > 0 ? `${id}_${count}` : id; // we increment the counter for this id, to be used when we are called the next time

  usedUids.set(id, count + 1); // we add refId to the end, if it is available

  return refId !== undefined ? `${uniqueId}_${refId}` : uniqueId;
}

function makeIdField(frame) {
  const allLabels = {}; // collect labels from every field

  frame.fields.forEach(field => {
    Object.assign(allLabels, field.labels);
  });
  const labelsString = Object.entries(allLabels).map(([key, val]) => `${key}="${val}"`).sort().join('');
  const usedUids = new Map();
  const {
    length
  } = frame;
  const uids = new Array(length); // we need to go through the dataframe "row by row"

  for (let i = 0; i < length; i++) {
    const row = frame.fields.map(f => String(f.values.get(i)));
    const text = `${labelsString}_${row.join('_')}`;
    const uid = createUid(text, usedUids, frame.refId);
    uids[i] = uid;
  }

  return {
    name: 'id',
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector(uids)
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/makeTableFrames.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeTableFrames": () => (/* binding */ makeTableFrames)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);


function makeTableFrames(instantMetricFrames) {
  // first we remove frames that have no refId
  // (we will group them by refId, so we need it to be set)
  const framesWithRefId = instantMetricFrames.filter(f => f.refId !== undefined);
  const framesByRefId = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.groupBy)(framesWithRefId, frame => frame.refId);
  return Object.entries(framesByRefId).map(([refId, frames]) => makeTableFrame(frames, refId));
}

function makeTableFrame(instantMetricFrames, refId) {
  const tableTimeField = {
    name: 'Time',
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time
  };
  const tableValueField = {
    name: `Value #${refId}`,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number
  }; // Sort metric labels, create columns for them and record their index

  const allLabelNames = new Set(instantMetricFrames.map(frame => frame.fields.map(field => {
    var _field$labels;

    return Object.keys((_field$labels = field.labels) !== null && _field$labels !== void 0 ? _field$labels : {});
  }).flat()).flat());
  const sortedLabelNames = Array.from(allLabelNames).sort();
  const labelFields = sortedLabelNames.map(labelName => ({
    name: labelName,
    config: {
      filterable: true
    },
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector(),
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string
  }));
  instantMetricFrames.forEach(frame => {
    var _valueField$labels;

    const timeField = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time);
    const valueField = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number);

    if (timeField == null || valueField == null) {
      return;
    }

    const timeArray = timeField.values.toArray();
    const valueArray = valueField.values.toArray();

    for (let x of timeArray) {
      tableTimeField.values.add(x);
    }

    for (let x of valueArray) {
      tableValueField.values.add(x);
    }

    const labels = (_valueField$labels = valueField.labels) !== null && _valueField$labels !== void 0 ? _valueField$labels : {};

    for (let f of labelFields) {
      var _labels$f$name;

      const text = (_labels$f$name = labels[f.name]) !== null && _labels$f$name !== void 0 ? _labels$f$name : ''; // we insert the labels as many times as we have values

      for (let i = 0; i < valueArray.length; i++) {
        f.values.add(text);
      }
    }
  });
  return {
    fields: [tableTimeField, ...labelFields, tableValueField],
    refId,
    meta: {
      preferredVisualisationType: 'table'
    },
    length: tableTimeField.values.length
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/module.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/datasource.ts");
/* harmony import */ var _components_LokiCheatSheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx");
/* harmony import */ var _components_LokiQueryEditorByApp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx");
/* harmony import */ var _LokiAnnotationsQueryCtrl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx");
/* harmony import */ var _configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx");






const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataSourcePlugin(_datasource__WEBPACK_IMPORTED_MODULE_1__.LokiDatasource).setQueryEditor(_components_LokiQueryEditorByApp__WEBPACK_IMPORTED_MODULE_3__["default"]).setConfigEditor(_configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_5__.ConfigEditor).setQueryEditorHelp(_components_LokiCheatSheet__WEBPACK_IMPORTED_MODULE_2__["default"]).setAnnotationQueryCtrl(_LokiAnnotationsQueryCtrl__WEBPACK_IMPORTED_MODULE_4__.LokiAnnotationsQueryCtrl);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/query_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addParsedLabelToQuery": () => (/* binding */ addParsedLabelToQuery),
/* harmony export */   "formatQuery": () => (/* binding */ formatQuery),
/* harmony export */   "getHighlighterExpressionsFromQuery": () => (/* binding */ getHighlighterExpressionsFromQuery),
/* harmony export */   "getNormalizedLokiQuery": () => (/* binding */ getNormalizedLokiQuery),
/* harmony export */   "queryHasPipeParser": () => (/* binding */ queryHasPipeParser)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
const _excluded = ["instant", "range"],
      _excluded2 = ["instant", "range"],
      _excluded3 = ["instant", "range"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




function formatQuery(selector) {
  return `${selector || ''}`.trim();
}
/**
 * Returns search terms from a LogQL query.
 * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.
 */

function getHighlighterExpressionsFromQuery(input) {
  let expression = input;
  const results = []; // Consume filter expression from left to right

  while (expression) {
    const filterStart = expression.search(/\|=|\|~|!=|!~/); // Nothing more to search

    if (filterStart === -1) {
      break;
    } // Drop terms for negative filters


    const filterOperator = expression.slice(filterStart, filterStart + 2);
    const skip = expression.slice(filterStart).search(/!=|!~/) === 0;
    expression = expression.slice(filterStart + 2);

    if (skip) {
      continue;
    } // Check if there is more chained


    const filterEnd = expression.search(/\|=|\|~|!=|!~/);
    let filterTerm;

    if (filterEnd === -1) {
      filterTerm = expression.trim();
    } else {
      filterTerm = expression.slice(0, filterEnd).trim();
      expression = expression.slice(filterEnd);
    }

    const quotedTerm = filterTerm.match(/"(.*?)"/);
    const backtickedTerm = filterTerm.match(/`(.*?)`/);
    const term = quotedTerm || backtickedTerm;

    if (term) {
      const unwrappedFilterTerm = term[1];
      const regexOperator = filterOperator === '|~'; // Only filter expressions with |~ operator are treated as regular expressions

      if (regexOperator) {
        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array
        // When using quotes, we have extra backslash escaping and we need to replace \\ with \
        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\/g, '\\'));
      } else {
        // We need to escape this string so it is not matched as regular expression
        results.push((0,lodash__WEBPACK_IMPORTED_MODULE_0__.escapeRegExp)(unwrappedFilterTerm));
      }
    } else {
      return results;
    }
  }

  return results;
}
function queryHasPipeParser(expr) {
  const parsers = _syntax__WEBPACK_IMPORTED_MODULE_1__.PIPE_PARSERS.map(parser => `${parser.label}`).join('|');
  const regexp = new RegExp(`\\\|\\\s?(${parsers})`);
  return regexp.test(expr);
}
function addParsedLabelToQuery(expr, key, value, operator) {
  return expr + ` | ${key}${operator}"${value.toString()}"`;
} // we are migrating from `.instant` and `.range` to `.queryType`
// this function returns a new query object that:
// - has `.queryType`
// - does not have `.instant`
// - does not have `.range`

function getNormalizedLokiQuery(query) {
  // if queryType exists, it is respected
  if (query.queryType !== undefined) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded);

    return rest;
  } // if no queryType, and instant===true, it's instant


  if (query.instant === true) {
    const rest = _objectWithoutPropertiesLoose(query, _excluded2);

    return Object.assign({}, rest, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_2__.LokiQueryType.Instant
    });
  } // otherwise it is range


  const rest = _objectWithoutPropertiesLoose(query, _excluded3);

  return Object.assign({}, rest, {
    queryType: _types__WEBPACK_IMPORTED_MODULE_2__.LokiQueryType.Range
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryModeller": () => (/* binding */ LokiQueryModeller),
/* harmony export */   "lokiQueryModeller": () => (/* binding */ lokiQueryModeller)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/operations.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");



class LokiQueryModeller extends _prometheus_querybuilder_shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_0__.LokiAndPromQueryModellerBase {
  constructor() {
    super(_operations__WEBPACK_IMPORTED_MODULE_1__.getOperationDefinitions);
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.Formats, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.LabelFilters, _types__WEBPACK_IMPORTED_MODULE_2__.LokiVisualQueryOperationCategory.LineFilters]);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '{}';
    }

    return super.renderLabels(labels);
  }

  getQueryPatterns() {
    return [{
      name: 'Log query and label filter',
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineMatchesRegex,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilter,
        params: ['', '=', '']
      }]
    }, {
      name: 'Time series query on value inside log line',
      operations: [{
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LineMatchesRegex,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Logfmt,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.LabelFilterNoErrors,
        params: []
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Unwrap,
        params: ['']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.SumOverTime,
        params: ['$__interval']
      }, {
        id: _types__WEBPACK_IMPORTED_MODULE_2__.LokiOperationId.Sum,
        params: []
      }]
    }];
  }

}
const lokiQueryModeller = new LokiQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_1__.LokiOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}]; // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.unshift({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.unshift(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_1__.LokiVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      param = model.params[1];
      bool = model.params[0] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilder": () => (/* binding */ LokiQueryBuilder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _QueryPreview__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/QueryPreview.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx");
/* harmony import */ var _NestedQueryList__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/NestedQueryList.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");











const LokiQueryBuilder = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  datasource,
  query,
  nested,
  onChange,
  onRunQuery
}) => {
  const onChangeLabels = labels => {
    onChange(Object.assign({}, query, {
      labels
    }));
  };

  const withTemplateVariableOptions = async optionsPromise => {
    const options = await optionsPromise;
    return [...datasource.getVariables(), ...options].map(value => ({
      label: value,
      value
    }));
  };

  const onGetLabelNames = async forLabel => {
    const labelsToConsider = query.labels.filter(x => x !== forLabel);

    if (labelsToConsider.length === 0) {
      await datasource.languageProvider.refreshLogLabels();
      return datasource.languageProvider.getLabelKeys();
    }

    const expr = _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_3__.lokiQueryModeller.renderLabels(labelsToConsider);
    const series = await datasource.languageProvider.fetchSeriesLabels(expr);
    return Object.keys(series).sort();
  };

  const onGetLabelValues = async forLabel => {
    var _result$forLabelInter;

    if (!forLabel.label) {
      return [];
    }

    const labelsToConsider = query.labels.filter(x => x !== forLabel);

    if (labelsToConsider.length === 0) {
      return await datasource.languageProvider.fetchLabelValues(forLabel.label);
    }

    const expr = _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_3__.lokiQueryModeller.renderLabels(labelsToConsider);
    const result = await datasource.languageProvider.fetchSeriesLabels(expr);
    const forLabelInterpolated = datasource.interpolateString(forLabel.label);
    return (_result$forLabelInter = result[forLabelInterpolated]) !== null && _result$forLabelInter !== void 0 ? _result$forLabelInter : [];
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_4__.EditorRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_1__.LabelFilters, {
        onGetLabelNames: forLabel => withTemplateVariableOptions(onGetLabelNames(forLabel)),
        onGetLabelValues: forLabel => withTemplateVariableOptions(onGetLabelValues(forLabel)),
        labelsFilters: query.labels,
        onChange: onChangeLabels
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_6__.OperationsEditorRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationList__WEBPACK_IMPORTED_MODULE_2__.OperationList, {
        queryModeller: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_3__.lokiQueryModeller,
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery,
        datasource: datasource
      })
    }), query.binaryQueries && query.binaryQueries.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_NestedQueryList__WEBPACK_IMPORTED_MODULE_7__.NestedQueryList, {
      query: query,
      datasource: datasource,
      onChange: onChange,
      onRunQuery: onRunQuery
    }), !nested && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_4__.EditorRow, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_QueryPreview__WEBPACK_IMPORTED_MODULE_5__.QueryPreview, {
        query: query
      })
    })]
  });
});
LokiQueryBuilder.displayName = 'LokiQueryBuilder';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderExplaind.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilderExplained": () => (/* binding */ LokiQueryBuilderExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







const LokiQueryBuilderExplained = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  nested
}) => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_4__.OperationExplainedBox, {
      stepNumber: 1,
      title: `${_LokiQueryModeller__WEBPACK_IMPORTED_MODULE_2__.lokiQueryModeller.renderLabels(query.labels)}`,
      children: "Fetch all log lines matching label filters."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_3__.OperationListExplained, {
      stepNumber: 2,
      queryModeller: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_2__.lokiQueryModeller,
      query: query
    })]
  });
});
LokiQueryBuilderExplained.displayName = 'LokiQueryBuilderExplained';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderOptions.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryBuilderOptions": () => (/* binding */ LokiQueryBuilderOptions)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx");
/* harmony import */ var _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiOptionFields.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/datasource.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










const LokiQueryBuilderOptions = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  onChange,
  onRunQuery
}) => {
  var _query$queryType, _query$maxLines$toStr, _query$maxLines;

  const onQueryTypeChange = value => {
    onChange(Object.assign({}, query, {
      queryType: value
    }));
    onRunQuery();
  };

  const onResolutionChange = option => {
    onChange(Object.assign({}, query, {
      resolution: option.value
    }));
    onRunQuery();
  };

  const onLegendFormatChanged = evt => {
    onChange(Object.assign({}, query, {
      legendFormat: evt.currentTarget.value
    }));
    onRunQuery();
  };

  function onMaxLinesChange(e) {
    const newMaxLines = (0,_components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.preprocessMaxLines)(e.currentTarget.value);

    if (query.maxLines !== newMaxLines) {
      onChange(Object.assign({}, query, {
        maxLines: newMaxLines
      }));
      onRunQuery();
    }
  }

  let queryType = (_query$queryType = query.queryType) !== null && _query$queryType !== void 0 ? _query$queryType : query.instant ? _types__WEBPACK_IMPORTED_MODULE_3__.LokiQueryType.Instant : _types__WEBPACK_IMPORTED_MODULE_3__.LokiQueryType.Range;
  let showMaxLines = !(0,_datasource__WEBPACK_IMPORTED_MODULE_7__.isMetricsQuery)(query.expr);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)(app_plugins_datasource_prometheus_querybuilder_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_4__.QueryOptionGroup, {
      title: "Options",
      collapsedInfo: getCollapsedInfo(query, queryType, showMaxLines),
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Legend",
        tooltip: "Series name override or template. Ex. {{hostname}} will be replaced with label value for hostname.",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_6__.AutoSizeInput, {
          placeholder: "{{label}}",
          id: "loki-query-editor-legend-format",
          type: "string",
          minWidth: 14,
          defaultValue: query.legendFormat,
          onCommitChange: onLegendFormatChanged
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Type",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.RadioButtonGroup, {
          options: _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.queryTypeOptions,
          value: queryType,
          onChange: onQueryTypeChange
        })
      }), showMaxLines && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Line limit",
        tooltip: "Upper limit for number of log lines returned by query.",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_6__.AutoSizeInput, {
          className: "width-4",
          placeholder: "auto",
          type: "number",
          min: 0,
          defaultValue: (_query$maxLines$toStr = (_query$maxLines = query.maxLines) === null || _query$maxLines === void 0 ? void 0 : _query$maxLines.toString()) !== null && _query$maxLines$toStr !== void 0 ? _query$maxLines$toStr : '',
          onCommitChange: onMaxLinesChange
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Resolution",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
          isSearchable: false,
          onChange: onResolutionChange,
          options: _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.RESOLUTION_OPTIONS,
          value: query.resolution || 1,
          "aria-label": "Select resolution",
          menuShouldPortal: true
        })
      })]
    })
  });
});

function getCollapsedInfo(query, queryType, showMaxLines) {
  const queryTypeLabel = _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.queryTypeOptions.find(x => x.value === queryType);
  const resolutionLabel = _components_LokiOptionFields__WEBPACK_IMPORTED_MODULE_5__.RESOLUTION_OPTIONS.find(x => {
    var _query$resolution;

    return x.value === ((_query$resolution = query.resolution) !== null && _query$resolution !== void 0 ? _query$resolution : 1);
  });
  const items = [];

  if (query.legendFormat) {
    items.push(`Legend: ${query.legendFormat}`);
  }

  if (query.resolution) {
    items.push(`Resolution: ${resolutionLabel === null || resolutionLabel === void 0 ? void 0 : resolutionLabel.label}`);
  }

  items.push(`Type: ${queryTypeLabel === null || queryTypeLabel === void 0 ? void 0 : queryTypeLabel.label}`);

  if (showMaxLines && query.maxLines) {
    items.push(`Line limit: ${query.maxLines}`);
  }

  return items;
}

LokiQueryBuilderOptions.displayName = 'LokiQueryBuilderOptions';

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryCodeEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryCodeEditor": () => (/* binding */ LokiQueryCodeEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _components_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _components_LokiQueryField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/components/LokiQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function LokiQueryCodeEditor({
  query,
  datasource,
  range,
  onRunQuery,
  onChange,
  data
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
    className: styles.wrapper,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_components_LokiQueryField__WEBPACK_IMPORTED_MODULE_4__.LokiQueryField, {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: onRunQuery,
      onChange: onChange,
      history: [],
      data: data,
      "data-testid": _components_LokiQueryEditor__WEBPACK_IMPORTED_MODULE_1__.testIds.editor
    })
  });
}

const getStyles = theme => {
  return {
    // This wrapper styling can be removed after the old PromQueryEditor is removed.
    // This is removing margin bottom on the old legacy inline form styles
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
      .gf-form {
        margin-bottom: 0;
      }
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryEditorSelector.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryEditorSelector": () => (/* binding */ LokiQueryEditorSelector)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/state.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");
/* harmony import */ var _LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx");
/* harmony import */ var _LokiQueryBuilderExplaind__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderExplaind.tsx");
/* harmony import */ var _LokiQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilderOptions.tsx");
/* harmony import */ var _LokiQueryCodeEditor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryCodeEditor.tsx");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/parsing.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem, _Space;



















const LokiQueryEditorSelector = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6__.memo(props => {
  var _query$visualQuery, _query$editorMode;

  const {
    onChange,
    onRunQuery,
    data
  } = props;
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const query = (0,_state__WEBPACK_IMPORTED_MODULE_8__.getQueryWithDefaults)(props.query);
  const [visualQuery, setVisualQuery] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)((_query$visualQuery = query.visualQuery) !== null && _query$visualQuery !== void 0 ? _query$visualQuery : (0,_types__WEBPACK_IMPORTED_MODULE_9__.getDefaultEmptyQuery)());
  const [parseModalOpen, setParseModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(false);
  const [pendingChange, setPendingChange] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(undefined);
  const onEditorModeChange = (0,react__WEBPACK_IMPORTED_MODULE_6__.useCallback)(newMetricEditorMode => {
    const change = Object.assign({}, query, {
      editorMode: newMetricEditorMode
    });

    if (newMetricEditorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__.QueryEditorMode.Builder) {
      const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_14__.buildVisualQueryFromString)(query.expr);
      change.visualQuery = result.query; // If there are errors, give user a chance to decide if they want to go to builder as that can loose some data.

      if (result.errors.length) {
        setParseModalOpen(true);
        setPendingChange(change);
        return;
      }

      setVisualQuery(change.visualQuery);
    }

    onChange(change);
  }, [onChange, query]);

  const onChangeViewModel = updatedQuery => {
    setVisualQuery(updatedQuery);
    onChange(Object.assign({}, query, {
      expr: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_7__.lokiQueryModeller.renderQuery(updatedQuery),
      visualQuery: updatedQuery,
      editorMode: app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__.QueryEditorMode.Builder
    }));
  }; // If no expr (ie new query) then default to builder


  const editorMode = (_query$editorMode = query.editorMode) !== null && _query$editorMode !== void 0 ? _query$editorMode : query.expr ? app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__.QueryEditorMode.Code : app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__.QueryEditorMode.Builder;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.ConfirmModal, {
      isOpen: parseModalOpen,
      title: "Query parsing",
      body: "There were errors while trying to parse the query. Continuing to visual builder may loose some parts of the query.",
      confirmText: "Continue",
      onConfirm: () => {
        setVisualQuery(pendingChange.visualQuery);
        onChange(pendingChange);
        setParseModalOpen(false);
      },
      onDismiss: () => setParseModalOpen(false)
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorHeader, {
      children: [_FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
        className: styles.runQuery,
        variant: "secondary",
        size: "sm",
        fill: "outline",
        onClick: onRunQuery,
        icon: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading ? 'fa fa-spinner' : undefined,
        disabled: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading,
        children: "Run query"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.InlineSelect, {
        value: null,
        placeholder: "Query patterns",
        allowCustomValue: true,
        onChange: ({
          value
        }) => {
          onChangeViewModel(Object.assign({}, visualQuery, {
            operations: value === null || value === void 0 ? void 0 : value.operations
          }));
        },
        options: _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_7__.lokiQueryModeller.getQueryPatterns().map(x => ({
          label: x.name,
          value: x
        }))
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_4__.QueryEditorModeToggle, {
        mode: editorMode,
        onChange: onEditorModeChange
      })]
    }), _Space || (_Space = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Space, {
      v: 0.5
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRows, {
      children: [editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__.QueryEditorMode.Code && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_LokiQueryCodeEditor__WEBPACK_IMPORTED_MODULE_13__.LokiQueryCodeEditor, Object.assign({}, props)), editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_10__.LokiQueryBuilder, {
        datasource: props.datasource,
        query: visualQuery,
        onChange: onChangeViewModel,
        onRunQuery: props.onRunQuery
      }), editorMode === app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_LokiQueryBuilderExplaind__WEBPACK_IMPORTED_MODULE_11__.LokiQueryBuilderExplained, {
        query: visualQuery
      }), editorMode !== app_plugins_datasource_prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_5__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_LokiQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_12__.LokiQueryBuilderOptions, {
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery
      })]
    })]
  });
});
LokiQueryEditorSelector.displayName = 'LokiQueryEditorSelector';

const getStyles = theme => {
  return {
    runQuery: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary
    }),
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/NestedQuery.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQuery": () => (/* binding */ NestedQuery)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/LokiQueryBuilder.tsx");
/* harmony import */ var app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;











const NestedQuery = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.memo(({
  nestedQuery,
  index,
  datasource,
  onChange,
  onRemove,
  onRunQuery
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
    className: styles.card,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
      className: styles.header,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: styles.name,
        children: "Operator"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        width: "auto",
        options: operators,
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(nestedQuery.operator),
        onChange: value => {
          onChange(index, Object.assign({}, nestedQuery, {
            operator: value.value
          }));
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: styles.name,
        children: "Vector matches"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
        className: styles.vectorMatchWrapper,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          width: "auto",
          value: nestedQuery.vectorMatchesType || 'on',
          allowCustomValue: true,
          options: [{
            value: 'on',
            label: 'on'
          }, {
            value: 'ignoring',
            label: 'ignoring'
          }],
          onChange: val => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatchesType: val.value
            }));
          }
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(app_plugins_datasource_prometheus_querybuilder_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_7__.AutoSizeInput, {
          className: styles.vectorMatchInput,
          minWidth: 20,
          defaultValue: nestedQuery.vectorMatches,
          onCommitChange: evt => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatches: evt.currentTarget.value,
              vectorMatchesType: nestedQuery.vectorMatchesType || 'on'
            }));
          }
        })]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.IconButton, {
        name: "times",
        size: "sm",
        onClick: () => onRemove(index)
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
      className: styles.body,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRows, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_LokiQueryBuilder__WEBPACK_IMPORTED_MODULE_6__.LokiQueryBuilder, {
          query: nestedQuery.query,
          datasource: datasource,
          nested: true,
          onRunQuery: onRunQuery,
          onChange: update => {
            onChange(index, Object.assign({}, nestedQuery, {
              query: update
            }));
          }
        })
      })
    })]
  });
});
const operators = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_5__.binaryScalarDefs.map(def => ({
  label: def.sign,
  value: def.sign
}));
NestedQuery.displayName = 'NestedQuery';

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'card',
      display: 'flex',
      flexDirection: 'column',
      gap: theme.spacing(0.5)
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'header',
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      gap: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    name: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'name',
      whiteSpace: 'nowrap'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'body',
      paddingLeft: theme.spacing(2)
    }),
    vectorMatchInput: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchInput',
      marginLeft: -1
    }),
    vectorMatchWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchWrapper',
      display: 'flex'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/NestedQueryList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQueryList": () => (/* binding */ NestedQueryList)
/* harmony export */ });
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _NestedQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/components/NestedQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function NestedQueryList({
  query,
  datasource,
  onChange,
  onRunQuery
}) {
  var _query$binaryQueries;

  const nestedQueries = (_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : [];

  const onNestedQueryUpdate = (index, update) => {
    const updatedList = [...nestedQueries];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...nestedQueries.slice(0, index), ...nestedQueries.slice(index + 1)];
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_0__.Stack, {
    direction: "column",
    gap: 1,
    children: nestedQueries.map((nestedQuery, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_NestedQuery__WEBPACK_IMPORTED_MODULE_2__.NestedQuery, {
      nestedQuery: nestedQuery,
      index: index,
      onChange: onNestedQueryUpdate,
      datasource: datasource,
      onRemove: onRemove,
      onRunQuery: onRunQuery
    }, index.toString()))
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/components/QueryPreview.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryPreview": () => (/* binding */ QueryPreview)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/LokiQueryModeller.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function QueryPreview({
  query
}) {
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.useTheme2)();
  const styles = getStyles(theme);
  const hightlighted = prismjs__WEBPACK_IMPORTED_MODULE_4___default().highlight(_LokiQueryModeller__WEBPACK_IMPORTED_MODULE_6__.lokiQueryModeller.renderQuery(query), _syntax__WEBPACK_IMPORTED_MODULE_5__.lokiGrammar, 'lokiql');
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorField, {
      label: "Query text",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.cx)(styles.editorField, 'prism-syntax-highlight'),
        "aria-label": "selector",
        dangerouslySetInnerHTML: {
          __html: hightlighted
        }
      })
    })
  });
}

const getStyles = theme => {
  return {
    editorField: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.css)({
      padding: theme.spacing(0.25, 1),
      fontFamily: theme.typography.fontFamilyMonospace,
      fontSize: theme.typography.bodySmall.fontSize
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLokiOperation": () => (/* binding */ addLokiOperation),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions)
/* harmony export */ });
/* harmony import */ var _prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/loki/syntax.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/types.ts");




function getOperationDefinitions() {
  const aggregations = [_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Sum, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Min, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Max, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Avg, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Stddev, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Stdvar, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Count].flatMap(opId => (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.createAggregationOperation)(opId, {
    addOperationHandler: addLokiOperation,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Last
  }));
  const aggregationsWithParam = [_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.TopK, _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BottomK].flatMap(opId => {
    return (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.createAggregationOperationWithParam)(opId, {
      params: [{
        name: 'K-value',
        type: 'number'
      }],
      defaultParams: [5]
    }, {
      addOperationHandler: addLokiOperation,
      orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Last
    });
  });
  const list = [createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Rate), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.CountOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.SumOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BytesRate), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.BytesOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.AbsentOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.AvgOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.MaxOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.MinOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.FirstOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LastOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.StdvarOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.StddevOverTime), createRangeOperation(_types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.QuantileOverTime), ...aggregations, ...aggregationsWithParam, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Json,
    name: 'Json',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Logfmt,
    name: 'Logfmt',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will extract all keys and values from a [logfmt](https://grafana.com/docs/loki/latest/logql/log_queries/#logfmt) formatted log line as labels. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Regexp,
    name: 'Regexp',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '<re>',
      description: 'The regexp expression that matches the structure of a log line.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | regexp \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `The [regexp parser](https://grafana.com/docs/loki/latest/logql/log_queries/#regular-expression) takes a single parameter | regexp "<re>" which is the regular expression using the Golang RE2 syntax. The regular expression must contain a least one named sub-match (e.g (?P<name>re)), each sub-match will extract a different label. The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Pattern,
    name: 'Pattern',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '<pattern-expression>',
      description: 'The expression that matches the structure of a log line.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | pattern \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `The [pattern parser](https://grafana.com/docs/loki/latest/logql/log_queries/#pattern) allows the explicit extraction of fields from log lines by defining a pattern expression (| pattern \`<pattern-expression>\`). The expression matches the structure of a log line. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Unpack,
    name: 'Unpack',
    params: [],
    defaultParams: [],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: pipelineRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will extract all keys and values from a JSON log line, [unpacking](https://grafana.com/docs/loki/latest/logql/log_queries/#unpack) all embedded labels in the pack stage. The extracted labels can be used in label filter expressions and used as values for a range aggregation via the unwrap operation.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineFormat,
    name: 'Line format',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: '{{.status_code}}',
      description: 'A line template that can refer to stream labels and extracted labels.',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | line_format \`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will replace log line using a specified template. The template can refer to stream labels and extracted labels.

        Example: \`{{.status_code}} - {{.message}}\`

        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#line-format-expression) for more.
        `
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFormat,
    name: 'Label format',
    params: [{
      name: 'Label',
      type: 'string'
    }, {
      name: 'Rename',
      type: 'string'
    }],
    defaultParams: ['', ''],
    alternativesKey: 'format',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFormats,
    renderer: (model, def, innerExpr) => `${innerExpr} | label_format ${model.params[1]}=\`${model.params[0]}\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `This will change name of label to desired new label. In the example below, label "error_level" will be renamed to "level".

        Example: error_level=\`level\`

        [Read the docs](https://grafana.com/docs/loki/latest/logql/log_queries/#labels-format-expression) for more.
        `
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineContains,
    name: 'Line contains',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: 'Text to find',
      description: 'Find log lines that contains this text',
      minWidth: 20
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('|='),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that contain string \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineContainsNot,
    name: 'Line does not contain',
    params: [{
      name: 'String',
      type: 'string',
      hideName: true,
      placeholder: 'Text to exclude',
      description: 'Find log lines that does not contain this text',
      minWidth: 26
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('!='),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that does not contain string \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineMatchesRegex,
    name: 'Line contains regex match',
    params: [{
      name: 'Regex',
      type: 'string',
      hideName: true,
      placeholder: 'Pattern to match',
      description: 'Find log lines that match this regex pattern',
      minWidth: 30
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('|~'),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that match regex \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LineMatchesRegexNot,
    name: 'Line does not match regex',
    params: [{
      name: 'Regex',
      type: 'string',
      hideName: true,
      placeholder: 'Pattern to exclude',
      description: 'Find log lines that does not match this regex pattern',
      minWidth: 30
    }],
    defaultParams: [''],
    alternativesKey: 'line filter',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LineFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LineFilters,
    renderer: getLineFilterRenderer('!~'),
    addOperationHandler: addLokiOperation,
    explainHandler: op => `Return log lines that does not match regex \`${op.params[0]}\`.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFilter,
    name: 'Label filter expression',
    params: [{
      name: 'Label',
      type: 'string'
    }, {
      name: 'Operator',
      type: 'string',
      options: ['=', '!=', '>', '<', '>=', '<=']
    }, {
      name: 'Value',
      type: 'string'
    }],
    defaultParams: ['', '=', ''],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LabelFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.LabelFilters,
    renderer: labelFilterRenderer,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `Label expression filter allows filtering using original and extracted labels.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.LabelFilterNoErrors,
    name: 'No pipeline errors',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.LabelFilters,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.NoErrors,
    renderer: (model, def, innerExpr) => `${innerExpr} | __error__=\`\``,
    addOperationHandler: addLokiOperation,
    explainHandler: () => `Filter out all formatting and parsing errors.`
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Unwrap,
    name: 'Unwrap',
    params: [{
      name: 'Identifier',
      type: 'string',
      hideName: true,
      minWidth: 16,
      placeholder: 'Label key'
    }],
    defaultParams: [''],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Formats,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.Unwrap,
    renderer: (op, def, innerExpr) => `${innerExpr} | unwrap ${op.params[0]}`,
    addOperationHandler: addLokiOperation,
    explainHandler: op => {
      let label = String(op.params[0]).length > 0 ? op.params[0] : '<label>';
      return `Use the extracted label \`${label}\` as sample values instead of log lines for the subsequent range aggregation.`;
    }
  }, ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }];
  return list;
}

function createRangeOperation(name) {
  const params = [getRangeVectorParamDef()];
  const defaultParams = ['$__interval'];
  let renderer = operationWithRangeVectorRenderer;

  if (name === _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.QuantileOverTime) {
    defaultParams.push('0.95');
    params.push({
      name: 'Quantile',
      type: 'number'
    });
    renderer = operationWithRangeVectorRendererAndParam;
  }

  return {
    id: name,
    name: (0,_prometheus_querybuilder_shared_operationUtils__WEBPACK_IMPORTED_MODULE_0__.getPromAndLokiOperationDisplayName)(name),
    params,
    defaultParams,
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions,
    orderRank: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationOrder.RangeVectorFunction,
    renderer,
    addOperationHandler: addLokiOperation,
    explainHandler: (op, def) => {
      var _FUNCTIONS$find$docum, _FUNCTIONS$find;

      let opDocs = (_FUNCTIONS$find$docum = (_FUNCTIONS$find = _syntax__WEBPACK_IMPORTED_MODULE_1__.FUNCTIONS.find(x => x.insertText === op.id)) === null || _FUNCTIONS$find === void 0 ? void 0 : _FUNCTIONS$find.documentation) !== null && _FUNCTIONS$find$docum !== void 0 ? _FUNCTIONS$find$docum : '';

      if (op.params[0] === '$__interval') {
        return `${opDocs} \`$__interval\` is variable that will be replaced with a calculated interval based on **Max data points**,  **Min interval** and query time range. You find these options you find under **Query options** at the right of the data source select dropdown.`;
      } else {
        return `${opDocs} The [range vector](https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation) is set to \`${op.params[0]}\`.`;
      }
    }
  };
}

function getRangeVectorParamDef() {
  return {
    name: 'Range',
    type: 'string',
    options: ['$__interval', '$__range', '1m', '5m', '10m', '1h', '24h']
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr} [${rangeVector}])`;
}

function operationWithRangeVectorRendererAndParam(model, def, innerExpr) {
  var _model$params2, _params$;

  const params = (_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : [];
  const rangeVector = (_params$ = params[0]) !== null && _params$ !== void 0 ? _params$ : '$__interval';
  const param = params[1];
  return `${def.id}(${param}, ${innerExpr} [${rangeVector}])`;
}

function getLineFilterRenderer(operation) {
  return function lineFilterRenderer(model, def, innerExpr) {
    if (model.params[0] === '') {
      return innerExpr;
    }

    return `${innerExpr} ${operation} \`${model.params[0]}\``;
  };
}

function labelFilterRenderer(model, def, innerExpr) {
  if (model.params[0] === '') {
    return innerExpr;
  }

  if (model.params[1] === '<' || model.params[1] === '>') {
    return `${innerExpr} | ${model.params[0]} ${model.params[1]} ${model.params[2]}`;
  }

  return `${innerExpr} | ${model.params[0]}${model.params[1]}\`${model.params[2]}\``;
}

function pipelineRenderer(model, def, innerExpr) {
  return `${innerExpr} | ${model.id}`;
}

function isRangeVectorFunction(def) {
  return def.category === _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions;
}

function getIndexOfOrLast(operations, queryModeller, condition) {
  const index = operations.findIndex(x => {
    const opDef = queryModeller.getOperationDef(x.id);

    if (!opDef) {
      return false;
    }

    return condition(opDef);
  });
  return index === -1 ? operations.length : index;
}

function addLokiOperation(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  const operations = [...query.operations];
  const existingRangeVectorFunction = operations.find(x => {
    const opDef = modeller.getOperationDef(x.id);

    if (!opDef) {
      return false;
    }

    return isRangeVectorFunction(opDef);
  });

  switch (def.category) {
    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Aggregations:
    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Functions:
      // If we are adding a function but we have not range vector function yet add one
      if (!existingRangeVectorFunction) {
        const placeToInsert = getIndexOfOrLast(operations, modeller, def => def.category === _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.Functions);
        operations.splice(placeToInsert, 0, {
          id: _types__WEBPACK_IMPORTED_MODULE_3__.LokiOperationId.Rate,
          params: ['$__interval']
        });
      }

      operations.push(newOperation);
      break;

    case _types__WEBPACK_IMPORTED_MODULE_3__.LokiVisualQueryOperationCategory.RangeFunctions:
      // If adding a range function and range function is already added replace it
      if (existingRangeVectorFunction) {
        const index = operations.indexOf(existingRangeVectorFunction);
        operations[index] = newOperation;
        break;
      }

    // Add range functions after any formats, line filters and label filters

    default:
      const placeToInsert = getIndexOfOrLast(operations, modeller, x => {
        var _def$orderRank, _x$orderRank;

        return ((_def$orderRank = def.orderRank) !== null && _def$orderRank !== void 0 ? _def$orderRank : 100) < ((_x$orderRank = x.orderRank) !== null && _x$orderRank !== void 0 ? _x$orderRank : 100);
      });
      operations.splice(placeToInsert, 0, newOperation);
      break;
  }

  return Object.assign({}, query, {
    operations
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@grafana-lezer-logql-virtual-9250dbecf8/0/cache/@grafana-lezer-logql-npm-0.0.11-d7d249e74a-0427e59528.zip/node_modules/@grafana/lezer-logql/index.es.js");
/* harmony import */ var _prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/querybuilder/binaryScalarOperations.ts");



function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.replaceVariables)(expr);
  const tree = _grafana_lezer_logql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handleExpression

  const visQuery = {
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);
    context.errors.push({
      text: err.message
    });
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'Matcher':
      {
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.ErrorName);

        if (err) {
          context.errors.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, err));
        }

        break;
      }

    case 'LineFilter':
      {
        const {
          operation,
          error
        } = getLineFilter(expr, node);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'LabelParser':
      {
        visQuery.operations.push(getLabelParser(expr, node));
        break;
      }

    case 'LabelFilter':
      {
        const {
          operation,
          error
        } = getLabelFilter(expr, node);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'JsonExpressionParser':
      {
        // JsonExpressionParser is not supported in query builder
        const error = 'JsonExpressionParser not supported in visual query builder';
        context.errors.push(createNotSupportedError(expr, node, error));
      }

    case 'LineFormatExpr':
      {
        visQuery.operations.push(getLineFormat(expr, node));
        break;
      }

    case 'LabelFormatMatcher':
      {
        visQuery.operations.push(getLabelFormat(expr, node));
        break;
      }

    case 'UnwrapExpr':
      {
        const {
          operation,
          error
        } = getUnwrap(expr, node);

        if (operation) {
          visQuery.operations.push(operation);
        } // Show error for query patterns not supported in visual query builder


        if (error) {
          context.errors.push(createNotSupportedError(expr, node, error));
        }

        break;
      }

    case 'RangeAggregationExpr':
      {
        visQuery.operations.push(handleRangeAggregation(expr, node, context));
        break;
      }

    case 'VectorAggregationExpr':
      {
        visQuery.operations.push(handleVectorAggregation(expr, node, context));
        break;
      }

    case 'BinOpExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, node));
        break;
      }

    default:
      {
        // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.
        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function getLabel(expr, node) {
  const labelNode = node.getChild('Identifier');
  const label = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, labelNode);
  const op = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, labelNode.nextSibling);
  const value = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

function getLineFilter(expr, node) {
  // Check for nodes not supported in visual builder and return error
  const ipLineFilter = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getAllByType)(expr, node, 'Ip');

  if (ipLineFilter.length > 0) {
    return {
      error: 'Matching ip addresses not supported in query builder'
    };
  }

  const mapFilter = {
    '|=': '__line_contains',
    '!=': '__line_contains_not',
    '|~': '__line_matches_regex',
    '!~': '"__line_matches_regex"_not'
  };
  const filter = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('Filter'));
  const filterExpr = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  return {
    operation: {
      id: mapFilter[filter],
      params: [filterExpr]
    }
  };
}

function getLabelParser(expr, node) {
  const parserNode = node.firstChild;
  const parser = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, parserNode);
  const string = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  const params = !!string ? [string] : [];
  return {
    id: parser,
    params
  };
}

function getLabelFilter(expr, node) {
  // Check for nodes not supported in visual builder and return error
  if (node.getChild('Or') || node.getChild('And') || node.getChild('Comma')) {
    return {
      error: 'Label filter with comma, "and", "or" not supported in query builder'
    };
  }

  if (node.firstChild.name === 'IpLabelFilter') {
    return {
      error: 'IpLabelFilter not supported in query builder'
    };
  }

  const id = '__label_filter';

  if (node.firstChild.name === 'UnitFilter') {
    const filter = node.firstChild.firstChild;
    const label = filter.firstChild;
    const op = label.nextSibling;
    const value = op.nextSibling;
    const valueString = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value));
    return {
      operation: {
        id,
        params: [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, label), (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, op), valueString]
      }
    };
  } // In this case it is Matcher or NumberFilter


  const filter = node.firstChild;
  const label = filter.firstChild;
  const op = label.nextSibling;
  const value = op.nextSibling;
  const params = [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, label), (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, op), handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value))]; // Special case of pipe filtering - no errors

  if (params.join('') === `__error__=`) {
    return {
      operation: {
        id: '__label_filter_no_errors',
        params: []
      }
    };
  }

  return {
    operation: {
      id,
      params
    }
  };
}

function getLineFormat(expr, node) {
  const id = 'line_format';
  const string = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('String')));
  return {
    id,
    params: [string]
  };
}

function getLabelFormat(expr, node) {
  const id = 'label_format';
  const identifier = node.getChild('Identifier');
  const op = identifier.nextSibling;
  const value = op.nextSibling;
  let valueString = handleQuotes((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, value));
  return {
    id,
    params: [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, identifier), valueString]
  };
}

function getUnwrap(expr, node) {
  // Check for nodes not supported in visual builder and return error
  if (node.getChild('ConvOp')) {
    return {
      error: 'Unwrap with conversion operator not supported in query builder'
    };
  }

  const id = 'unwrap';
  const string = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node.getChild('Identifier'));
  return {
    operation: {
      id,
      params: [string]
    }
  };
}

function handleRangeAggregation(expr, node, context) {
  const nameNode = node.getChild('RangeOp');
  const funcName = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, nameNode);
  const number = node.getChild('Number');
  const logExpr = node.getChild('LogRangeExpr');
  const params = number !== null && number !== undefined ? [(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, number)] : [];
  let match = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, node).match(/\[(.+)\]/);

  if (match !== null && match !== void 0 && match[1]) {
    params.push(match[1]);
  }

  const op = {
    id: funcName,
    params
  };

  if (logExpr) {
    handleExpression(expr, logExpr, context);
  }

  return op;
}

function handleVectorAggregation(expr, node, context) {
  const nameNode = node.getChild('VectorOp');
  let funcName = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, nameNode);
  const grouping = node.getChild('Grouping');
  const labels = [];

  if (grouping) {
    const byModifier = grouping.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = grouping.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    labels.push(...(0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getAllByType)(expr, grouping, 'Identifier'));
  }

  const metricExpr = node.getChild('MetricExpr');
  const op = {
    id: funcName,
    params: labels
  };

  if (metricExpr) {
    handleExpression(expr, metricExpr, context);
  }

  return op;
}

const operatorToOpName = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_2__.binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {});
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */

function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = operatorToOpName[op];
  const leftNumber = getLastChildWithSelector(left, 'MetricExpr.LiteralExpr.Number');
  const rightNumber = getLastChildWithSelector(right, 'MetricExpr.LiteralExpr.Number');
  const rightBinary = right.getChild('BinOpExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'Number') {
      visQuery.operations.push((0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isIntervalVariableError(node) {
  var _node$parent;

  return (node === null || node === void 0 ? void 0 : (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name) === 'Range';
}

function handleQuotes(string) {
  if (string[0] === `"` && string[string.length - 1] === `"`) {
    return string.replace(/"/g, '').replace(/\\\\/g, '\\');
  }

  return string.replace(/`/g, '');
}
/**
 * Simple helper to traverse the syntax tree. Instead of node.getChild('foo')?.getChild('bar')?.getChild('baz') you
 * can write getChildWithSelector(node, 'foo.bar.baz')
 * @param node
 * @param selector
 */


function getLastChildWithSelector(node, selector) {
  let child = node;
  const children = selector.split('.');

  for (const s of children) {
    child = child.getChild(s);

    if (!child) {
      return null;
    }
  }

  return child;
}
/**
 * Helper function to enrich error text with information that visual query builder doesn't support that logQL
 * @param expr
 * @param node
 * @param error
 */


function createNotSupportedError(expr, node, error) {
  const err = (0,_prometheus_querybuilder_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_1__.makeError)(expr, node);
  err.text = `${error}: ${err.text}`;
  return err;
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/state.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "changeEditorMode": () => (/* binding */ changeEditorMode),
/* harmony export */   "getDefaultEditorMode": () => (/* binding */ getDefaultEditorMode),
/* harmony export */   "getQueryWithDefaults": () => (/* binding */ getQueryWithDefaults)
/* harmony export */ });
/* harmony import */ var app_core_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/core/store.ts");
/* harmony import */ var _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");



const queryEditorModeDefaultLocalStorageKey = 'LokiQueryEditorModeDefault';
function changeEditorMode(query, editorMode, onChange) {
  // If empty query store new mode as default
  if (query.expr === '') {
    app_core_store__WEBPACK_IMPORTED_MODULE_0__["default"].set(queryEditorModeDefaultLocalStorageKey, editorMode);
  }

  onChange(Object.assign({}, query, {
    editorMode
  }));
}
function getDefaultEditorMode(expr) {
  // If we already have an expression default to code view
  if (expr != null && expr !== '') {
    return _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Code;
  }

  const value = app_core_store__WEBPACK_IMPORTED_MODULE_0__["default"].get(queryEditorModeDefaultLocalStorageKey);

  switch (value) {
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Builder:
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Code:
    case _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Explain:
      return value;

    default:
      return _prometheus_querybuilder_shared_types__WEBPACK_IMPORTED_MODULE_1__.QueryEditorMode.Builder;
  }
}
/**
 * Returns query with defaults, and boolean true/false depending on change was required
 */

function getQueryWithDefaults(query) {
  // If no expr (ie new query) then default to builder
  let result = query;

  if (!query.editorMode) {
    result = Object.assign({}, query, {
      editorMode: getDefaultEditorMode(query.expr)
    });
  }

  if (query.expr == null) {
    result = Object.assign({}, result, {
      expr: ''
    });
  }

  if (query.queryType == null) {
    // Default to range query
    result = Object.assign({}, result, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_2__.LokiQueryType.Range
    });
  }

  return result;
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiOperationId": () => (/* binding */ LokiOperationId),
/* harmony export */   "LokiOperationOrder": () => (/* binding */ LokiOperationOrder),
/* harmony export */   "LokiVisualQueryOperationCategory": () => (/* binding */ LokiVisualQueryOperationCategory),
/* harmony export */   "getDefaultEmptyQuery": () => (/* binding */ getDefaultEmptyQuery)
/* harmony export */ });
/**
 * Visual query model
 */
let LokiVisualQueryOperationCategory;

(function (LokiVisualQueryOperationCategory) {
  LokiVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  LokiVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  LokiVisualQueryOperationCategory["Functions"] = "Functions";
  LokiVisualQueryOperationCategory["Formats"] = "Formats";
  LokiVisualQueryOperationCategory["LineFilters"] = "Line filters";
  LokiVisualQueryOperationCategory["LabelFilters"] = "Label filters";
  LokiVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
})(LokiVisualQueryOperationCategory || (LokiVisualQueryOperationCategory = {}));

let LokiOperationId;

(function (LokiOperationId) {
  LokiOperationId["Json"] = "json";
  LokiOperationId["Logfmt"] = "logfmt";
  LokiOperationId["Regexp"] = "regexp";
  LokiOperationId["Pattern"] = "pattern";
  LokiOperationId["Unpack"] = "unpack";
  LokiOperationId["LineFormat"] = "line_format";
  LokiOperationId["LabelFormat"] = "label_format";
  LokiOperationId["Rate"] = "rate";
  LokiOperationId["CountOverTime"] = "count_over_time";
  LokiOperationId["SumOverTime"] = "sum_over_time";
  LokiOperationId["AvgOverTime"] = "avg_over_time";
  LokiOperationId["MaxOverTime"] = "max_over_time";
  LokiOperationId["MinOverTime"] = "min_over_time";
  LokiOperationId["FirstOverTime"] = "first_over_time";
  LokiOperationId["LastOverTime"] = "last_over_time";
  LokiOperationId["StdvarOverTime"] = "stdvar_over_time";
  LokiOperationId["StddevOverTime"] = "stddev_over_time";
  LokiOperationId["QuantileOverTime"] = "quantile_over_time";
  LokiOperationId["BytesRate"] = "bytes_rate";
  LokiOperationId["BytesOverTime"] = "bytes_over_time";
  LokiOperationId["AbsentOverTime"] = "absent_over_time";
  LokiOperationId["Sum"] = "sum";
  LokiOperationId["Avg"] = "avg";
  LokiOperationId["Min"] = "min";
  LokiOperationId["Max"] = "max";
  LokiOperationId["Stddev"] = "stddev";
  LokiOperationId["Stdvar"] = "stdvar";
  LokiOperationId["Count"] = "count";
  LokiOperationId["TopK"] = "topk";
  LokiOperationId["BottomK"] = "bottomk";
  LokiOperationId["LineContains"] = "__line_contains";
  LokiOperationId["LineContainsNot"] = "__line_contains_not";
  LokiOperationId["LineMatchesRegex"] = "__line_matches_regex";
  LokiOperationId["LineMatchesRegexNot"] = "__line_matches_regex_not";
  LokiOperationId["LabelFilter"] = "__label_filter";
  LokiOperationId["LabelFilterNoErrors"] = "__label_filter_no_errors";
  LokiOperationId["Unwrap"] = "unwrap";
  LokiOperationId["Addition"] = "__addition";
  LokiOperationId["Subtraction"] = "__subtraction";
  LokiOperationId["MultiplyBy"] = "__multiply_by";
  LokiOperationId["DivideBy"] = "__divide_by";
  LokiOperationId["Modulo"] = "__modulo";
  LokiOperationId["Exponent"] = "__exponent";
  LokiOperationId["NestedQuery"] = "__nested_query";
  LokiOperationId["EqualTo"] = "__equal_to";
  LokiOperationId["NotEqualTo"] = "__not_equal_to";
  LokiOperationId["GreaterThan"] = "__greater_than";
  LokiOperationId["LessThan"] = "__less_than";
  LokiOperationId["GreaterOrEqual"] = "__greater_or_equal";
  LokiOperationId["LessOrEqual"] = "__less_or_equal";
})(LokiOperationId || (LokiOperationId = {}));

let LokiOperationOrder;

(function (LokiOperationOrder) {
  LokiOperationOrder[LokiOperationOrder["LineFilters"] = 1] = "LineFilters";
  LokiOperationOrder[LokiOperationOrder["LineFormats"] = 2] = "LineFormats";
  LokiOperationOrder[LokiOperationOrder["LabelFilters"] = 3] = "LabelFilters";
  LokiOperationOrder[LokiOperationOrder["Unwrap"] = 4] = "Unwrap";
  LokiOperationOrder[LokiOperationOrder["NoErrors"] = 5] = "NoErrors";
  LokiOperationOrder[LokiOperationOrder["RangeVectorFunction"] = 5] = "RangeVectorFunction";
  LokiOperationOrder[LokiOperationOrder["Last"] = 6] = "Last";
})(LokiOperationOrder || (LokiOperationOrder = {}));

function getDefaultEmptyQuery() {
  return {
    labels: [],
    operations: [{
      id: '__line_contains',
      params: ['']
    }]
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/result_transformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appendResponseToBufferedData": () => (/* binding */ appendResponseToBufferedData),
/* harmony export */   "createMetricLabel": () => (/* binding */ createMetricLabel),
/* harmony export */   "decamelize": () => (/* binding */ decamelize),
/* harmony export */   "enhanceDataFrame": () => (/* binding */ enhanceDataFrame),
/* harmony export */   "lokiPointsToTimeseriesPoints": () => (/* binding */ lokiPointsToTimeseriesPoints),
/* harmony export */   "lokiResultsToTableModel": () => (/* binding */ lokiResultsToTableModel),
/* harmony export */   "lokiStreamResultToDataFrame": () => (/* binding */ lokiStreamResultToDataFrame),
/* harmony export */   "lokiStreamsToDataFrames": () => (/* binding */ lokiStreamsToDataFrames),
/* harmony export */   "processRangeQueryResponse": () => (/* binding */ processRangeQueryResponse),
/* harmony export */   "rangeQueryResponseToDataFrames": () => (/* binding */ rangeQueryResponseToDataFrames)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_core_table_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/core/table_model.ts");
/* harmony import */ var _query_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/loki/query_utils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/loki/types.ts");
/* harmony import */ var _prometheus_legend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");









const UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';
/**
 * Transforms LokiStreamResult structure into a dataFrame. Used when doing standard queries and newer version of Loki.
 */

function lokiStreamResultToDataFrame(stream, reverse, refId) {
  const labels = stream.stream;
  const labelsString = Object.entries(labels).map(([key, val]) => `${key}="${val}"`).sort().join('');
  const times = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]);
  const timesNs = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]);
  const lines = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]);
  const uids = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([]); // We need to store and track all used uids to ensure that uids are unique

  const usedUids = {};

  for (const [ts, line] of stream.values) {
    // num ns epoch in string, we convert it to iso string here so it matches old format
    times.add(new Date(parseInt(ts.slice(0, -6), 10)).toISOString());
    timesNs.add(ts);
    lines.add(line);
    uids.add(createUid(ts, labelsString, line, usedUids, refId));
  }

  return constructDataFrame(times, timesNs, lines, uids, labels, reverse, refId);
}
/**
 * Constructs dataFrame with supplied fields and other data. Also makes sure it is properly reversed if needed.
 */

function constructDataFrame(times, timesNs, lines, uids, labels, reverse, refId) {
  const dataFrame = {
    refId,
    fields: [{
      name: 'ts',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time,
      config: {
        displayName: 'Time'
      },
      values: times
    }, // Time
    {
      name: 'line',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string,
      config: {},
      values: lines,
      labels
    }, // Line - needs to be the first field with string type
    {
      name: 'id',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string,
      config: {},
      values: uids
    }, {
      name: 'tsNs',
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time,
      config: {
        displayName: 'Time ns'
      },
      values: timesNs
    } // Time
    ],
    length: times.length
  };

  if (reverse) {
    const mutableDataFrame = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.MutableDataFrame(dataFrame);
    mutableDataFrame.reverse();
    return mutableDataFrame;
  }

  return dataFrame;
}
/**
 * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be
 * a CircularDataFrame creating a fixed size rolling buffer.
 * TODO: Probably could be unified with the logStreamToDataFrame function.
 * @param response
 * @param data Needs to have ts, line, labels, id as fields
 */


function appendResponseToBufferedData(response, data) {
  // Should we do anything with: response.dropped_entries?
  const streams = response.streams;

  if (!streams || !streams.length) {
    return;
  }

  let baseLabels = {};

  for (const f of data.fields) {
    if (f.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string) {
      if (f.labels) {
        baseLabels = f.labels;
      }

      break;
    }
  }

  const tsField = data.fields[0];
  const tsNsField = data.fields[1];
  const lineField = data.fields[2];
  const labelsField = data.fields[3];
  const idField = data.fields[4]; // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.
  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.

  const usedUids = {};

  for (const stream of streams) {
    // Find unique labels
    const unique = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.findUniqueLabels)(stream.stream, baseLabels);
    const allLabelsString = Object.entries(stream.stream).map(([key, val]) => `${key}="${val}"`).sort().join(''); // Add each line

    for (const [ts, line] of stream.values) {
      tsField.values.add(new Date(parseInt(ts.slice(0, -6), 10)).toISOString());
      tsNsField.values.add(ts);
      lineField.values.add(line);
      labelsField.values.add(unique);
      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));
    }
  }
}

function createUid(ts, labelsString, line, usedUids, refId) {
  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)
  let id = (0,uuid__WEBPACK_IMPORTED_MODULE_7__["default"])(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE); // Check if generated id is unique
  // If not and we've already used it, append it's count after it

  if (id in usedUids) {
    // Increase the count
    const newCount = usedUids[id] + 1;
    usedUids[id] = newCount; // Append count to generated id to make it unique

    id = `${id}_${newCount}`;
  } else {
    // If id is unique and wasn't used, add it to usedUids and start count at 0
    usedUids[id] = 0;
  } // Return unique id


  if (refId) {
    return `${id}_${refId}`;
  }

  return id;
}

function lokiMatrixToTimeSeries(matrixResult, options) {
  const name = createMetricLabel(matrixResult.metric, options);
  return {
    target: name,
    title: name,
    datapoints: lokiPointsToTimeseriesPoints(matrixResult.values),
    tags: matrixResult.metric,
    meta: options.meta,
    refId: options.refId
  };
}

function parsePrometheusFormatSampleValue(value) {
  switch (value) {
    case '+Inf':
      return Number.POSITIVE_INFINITY;

    case '-Inf':
      return Number.NEGATIVE_INFINITY;

    default:
      return parseFloat(value);
  }
}

function lokiPointsToTimeseriesPoints(data) {
  const datapoints = [];

  for (const [time, value] of data) {
    let datapointValue = parsePrometheusFormatSampleValue(value);

    if (isNaN(datapointValue)) {
      datapointValue = null;
    }

    const timestamp = time * 1000;
    datapoints.push([datapointValue, timestamp]);
  }

  return datapoints;
}
function lokiResultsToTableModel(lokiResults, resultCount, refId, meta, valueWithRefId) {
  if (!lokiResults || lokiResults.length === 0) {
    return new app_core_table_model__WEBPACK_IMPORTED_MODULE_3__["default"]();
  } // Collect all labels across all metrics


  const metricLabels = new Set(lokiResults.reduce((acc, cur) => acc.concat(Object.keys(cur.metric)), [])); // Sort metric labels, create columns for them and record their index

  const sortedLabels = [...metricLabels.values()].sort();
  const table = new app_core_table_model__WEBPACK_IMPORTED_MODULE_3__["default"]();
  table.refId = refId;
  table.meta = meta;
  table.columns = [{
    text: 'Time',
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time
  }, ...sortedLabels.map(label => ({
    text: label,
    filterable: true,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string
  })), {
    text: resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value',
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.number
  }]; // Populate rows, set value to empty string when label not present.

  lokiResults.forEach(series => {
    const newSeries = {
      metric: series.metric,
      values: series.value ? [series.value] : series.values
    };

    if (!newSeries.values) {
      return;
    }

    if (!newSeries.metric) {
      table.rows.concat(newSeries.values.map(([a, b]) => [a * 1000, parseFloat(b)]));
    } else {
      table.rows.push(...newSeries.values.map(([a, b]) => [a * 1000, ...sortedLabels.map(label => newSeries.metric[label] || ''), parseFloat(b)]));
    }
  });
  return table;
}
function createMetricLabel(labelData, options) {
  var _options$legendFormat;

  let label = options === undefined || (0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(options.legendFormat) ? getOriginalMetricName(labelData) : (0,_prometheus_legend__WEBPACK_IMPORTED_MODULE_6__.renderLegendFormat)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.getTemplateSrv)().replace((_options$legendFormat = options.legendFormat) !== null && _options$legendFormat !== void 0 ? _options$legendFormat : '', options.scopedVars), labelData);

  if (!label && options) {
    label = options.query;
  }

  return label;
}

function getOriginalMetricName(labelData) {
  const labelPart = Object.entries(labelData).map(label => `${label[0]}="${label[1]}"`).join(',');
  return `{${labelPart}}`;
}

function decamelize(s) {
  return s.replace(/[A-Z]/g, m => ` ${m.toLowerCase()}`);
} // Turn loki stats { metric: value } into meta stat { title: metric, value: value }

function lokiStatsToMetaStat(stats) {
  const result = [];

  if (!stats) {
    return result;
  }

  for (const section in stats) {
    const values = stats[section];

    for (const label in values) {
      const value = values[label];
      let unit;

      if (/time/i.test(label) && value) {
        unit = 's';
      } else if (/bytes.*persecond/i.test(label)) {
        unit = 'Bps';
      } else if (/bytes/i.test(label)) {
        unit = 'decbytes';
      }

      const title = `${(0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(section)}: ${decamelize(label)}`;
      result.push({
        displayName: title,
        value,
        unit
      });
    }
  }

  return result;
}

function lokiStreamsToDataFrames(response, target, limit, config, reverse = false) {
  const data = limit > 0 ? response.data.result : [];
  const stats = lokiStatsToMetaStat(response.data.stats); // Use custom mechanism to identify which stat we want to promote to label

  const custom = {
    lokiQueryStatKey: 'Summary: total bytes processed'
  };
  const meta = {
    searchWords: (0,_query_utils__WEBPACK_IMPORTED_MODULE_4__.getHighlighterExpressionsFromQuery)((0,_query_utils__WEBPACK_IMPORTED_MODULE_4__.formatQuery)(target.expr)),
    limit,
    stats,
    custom,
    preferredVisualisationType: 'logs'
  };
  const series = data.map(stream => {
    const dataFrame = lokiStreamResultToDataFrame(stream, reverse, target.refId);
    enhanceDataFrame(dataFrame, config);

    if (meta.custom && dataFrame.fields.some(f => f.labels && Object.keys(f.labels).some(l => l === '__error__'))) {
      meta.custom.error = 'Error when parsing some of the logs';
    }

    return Object.assign({}, dataFrame, {
      refId: target.refId,
      meta
    });
  });

  if (stats.length && !data.length) {
    return [{
      fields: [],
      length: 0,
      refId: target.refId,
      meta
    }];
  }

  return series;
}
/**
 * Adds new fields and DataLinks to DataFrame based on DataSource instance config.
 */

const enhanceDataFrame = (dataFrame, config) => {
  var _config$derivedFields;

  if (!config) {
    return;
  }

  const derivedFields = (_config$derivedFields = config.derivedFields) !== null && _config$derivedFields !== void 0 ? _config$derivedFields : [];

  if (!derivedFields.length) {
    return;
  }

  const derivedFieldsGrouped = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.groupBy)(derivedFields, 'name');
  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig);
  const view = new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.DataFrameView(dataFrame);
  view.forEach(row => {
    for (const field of newFields) {
      const logMatch = row.line.match(derivedFieldsGrouped[field.name][0].matcherRegex);
      field.values.add(logMatch && logMatch[1]);
    }
  });
  dataFrame.fields = [...dataFrame.fields, ...newFields];
};
/**
 * Transform derivedField config into dataframe field with config that contains link.
 */

function fieldFromDerivedFieldConfig(derivedFieldConfigs) {
  const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.getDataSourceSrv)();
  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {
    // Having field.datasourceUid means it is an internal link.
    if (derivedFieldConfig.datasourceUid) {
      var _dsSettings$name;

      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);
      acc.push({
        // Will be filled out later
        title: derivedFieldConfig.urlDisplayLabel || '',
        url: '',
        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object
        internal: {
          query: {
            query: derivedFieldConfig.url
          },
          datasourceUid: derivedFieldConfig.datasourceUid,
          datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
        }
      });
    } else if (derivedFieldConfig.url) {
      acc.push({
        // We do not know what title to give here so we count on presentation layer to create a title from metadata.
        title: derivedFieldConfig.urlDisplayLabel || '',
        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object
        url: derivedFieldConfig.url
      });
    }

    return acc;
  }, []);
  return {
    name: derivedFieldConfigs[0].name,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.string,
    config: {
      links: dataLinks
    },
    // We are adding values later on
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_1__.ArrayVector([])
  };
}

function rangeQueryResponseToTimeSeries(response, query, target, responseListLength, scopedVars) {
  var _target$legendFormat;

  /** Show results of Loki metric queries only in graph */
  const meta = {
    preferredVisualisationType: 'graph'
  };
  const transformerOptions = {
    format: target.format,
    legendFormat: (_target$legendFormat = target.legendFormat) !== null && _target$legendFormat !== void 0 ? _target$legendFormat : '',
    start: query.start,
    end: query.end,
    step: query.step,
    query: query.query,
    responseListLength,
    refId: target.refId,
    meta,
    valueWithRefId: target.valueWithRefId,
    scopedVars
  };

  switch (response.data.resultType) {
    case _types__WEBPACK_IMPORTED_MODULE_5__.LokiResultType.Vector:
      return response.data.result.map(vecResult => lokiMatrixToTimeSeries({
        metric: vecResult.metric,
        values: [vecResult.value]
      }, transformerOptions));

    case _types__WEBPACK_IMPORTED_MODULE_5__.LokiResultType.Matrix:
      return response.data.result.map(matrixResult => lokiMatrixToTimeSeries(matrixResult, transformerOptions));

    default:
      return [];
  }
}

function rangeQueryResponseToDataFrames(response, query, target, responseListLength, scopedVars) {
  const series = rangeQueryResponseToTimeSeries(response, query, target, responseListLength, scopedVars);
  const frames = series.map(s => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toDataFrame)(s));
  const {
    step
  } = query;

  if (step != null) {
    const intervalMs = step * 1000;
    frames.forEach(frame => {
      frame.fields.forEach(field => {
        if (field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.FieldType.time) {
          field.config.interval = intervalMs;
        }
      });
    });
  }

  return frames;
}
function processRangeQueryResponse(response, target, query, responseListLength, limit, config, scopedVars, reverse = false) {
  switch (response.data.resultType) {
    case _types__WEBPACK_IMPORTED_MODULE_5__.LokiResultType.Stream:
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.of)({
        data: lokiStreamsToDataFrames(response, target, limit, config, reverse),
        key: `${target.refId}_log`
      });

    case _types__WEBPACK_IMPORTED_MODULE_5__.LokiResultType.Vector:
    case _types__WEBPACK_IMPORTED_MODULE_5__.LokiResultType.Matrix:
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.of)({
        data: rangeQueryResponseToDataFrames(response, query, Object.assign({}, target, {
          format: 'time_series'
        }), responseListLength, scopedVars),
        key: target.refId
      });

    default:
      throw new Error(`Unknown result type "${response.data.resultType}".`);
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/streaming.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doLokiChannelStream": () => (/* binding */ doLokiChannelStream),
/* harmony export */   "getLiveStreamKey": () => (/* binding */ getLiveStreamKey)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/defer.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var app_features_live_data_StreamingDataFrame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/features/live/data/StreamingDataFrame.ts");




/**
 * Calculate a unique key for the query.  The key is used to pick a channel and should
 * be unique for each distinct query execution plan.  This key is not secure and is only picked to avoid
 * possible collisions
 */

async function getLiveStreamKey(query) {
  const str = JSON.stringify({
    expr: query.expr
  });
  const msgUint8 = new TextEncoder().encode(str); // encode as (utf-8) Uint8Array

  const hashBuffer = await crypto.subtle.digest('SHA-1', msgUint8); // hash the message

  const hashArray = Array.from(new Uint8Array(hashBuffer.slice(0, 8))); // first 8 bytes

  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
} // This will get both v1 and v2 result formats

function doLokiChannelStream(query, ds, options) {
  var _options$maxDataPoint;

  // maximum time to keep values
  const range = options.range;
  const maxDelta = range.to.valueOf() - range.from.valueOf() + 1000;
  let maxLength = (_options$maxDataPoint = options.maxDataPoints) !== null && _options$maxDataPoint !== void 0 ? _options$maxDataPoint : 1000;

  if (maxLength > 100) {
    // for small buffers, keep them small
    maxLength *= 2;
  }

  let frame = undefined;

  const updateFrame = msg => {
    if (msg !== null && msg !== void 0 && msg.message) {
      const p = msg.message;

      if (!frame) {
        frame = app_features_live_data_StreamingDataFrame__WEBPACK_IMPORTED_MODULE_2__.StreamingDataFrame.fromDataFrameJSON(p, {
          maxLength,
          maxDelta,
          displayNameFormat: query.legendFormat
        });
      } else {
        frame.push(p);
      }
    }

    return frame;
  };

  return (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.defer)(() => getLiveStreamKey(query)).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(key => {
    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getGrafanaLiveSrv)().getStream({
      scope: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.LiveChannelScope.DataSource,
      namespace: ds.uid,
      path: `tail/${key}`,
      data: Object.assign({}, query, {
        timeRange: {
          from: range.from.valueOf().toString(),
          to: range.to.valueOf().toString()
        }
      })
    }).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_5__.map)(evt => {
      const frame = updateFrame(evt);
      return {
        data: frame ? [frame] : [],
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.LoadingState.Streaming
      };
    }));
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/loki/syntax.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOKI_KEYWORDS": () => (/* binding */ LOKI_KEYWORDS),
/* harmony export */   "PIPE_OPERATORS": () => (/* binding */ PIPE_OPERATORS),
/* harmony export */   "PIPE_PARSERS": () => (/* binding */ PIPE_PARSERS),
/* harmony export */   "RANGE_VEC_FUNCTIONS": () => (/* binding */ RANGE_VEC_FUNCTIONS),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "lokiGrammar": () => (/* binding */ lokiGrammar)
/* harmony export */ });
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}];
const PIPE_PARSERS = [{
  label: 'json',
  insertText: 'json',
  documentation: 'Extracting labels from the log line using json parser. Only available in Loki 2.0+.'
}, {
  label: 'regexp',
  insertText: 'regexp ""',
  documentation: 'Extracting labels from the log line using regexp parser. Only available in Loki 2.0+.',
  move: -1
}, {
  label: 'logfmt',
  insertText: 'logfmt',
  documentation: 'Extracting labels from the log line using logfmt parser. Only available in Loki 2.0+.'
}, {
  label: 'pattern',
  insertText: 'pattern',
  documentation: 'Extracting labels from the log line using pattern parser. Only available in Loki 2.3+.'
}];
const PIPE_OPERATORS = [{
  label: 'unwrap',
  insertText: 'unwrap',
  detail: 'unwrap identifier',
  documentation: 'Take labels and use the values as sample data for metric aggregations. Only available in Loki 2.0+.'
}, {
  label: 'unpack',
  insertText: 'unpack',
  detail: 'unpack identifier',
  documentation: 'Parses a JSON log line, unpacking all embedded labels in the pack stage. A special property "_entry" will also be used to replace the original log line. Only available in Loki 2.0+.'
}, {
  label: 'label_format',
  insertText: 'label_format',
  documentation: 'Use to rename, modify or add labels. For example, | label_format foo=bar . Only available in Loki 2.0+.'
}, {
  label: 'line_format',
  insertText: 'line_format',
  documentation: 'Rewrites log line content. For example, | line_format "{{.query}} {{.duration}}" . Only available in Loki 2.0+.'
}];
const RANGE_VEC_FUNCTIONS = [{
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The Ï†-quantile (0 â‰¤ Ï† â‰¤ 1) of the values in the specified interval. Only available in Loki 2.0+.'
}, {
  insertText: 'bytes_over_time',
  label: 'bytes_over_time',
  detail: 'bytes_over_time(range-vector)',
  documentation: 'Counts the amount of bytes used by each log stream for a given range'
}, {
  insertText: 'bytes_rate',
  label: 'bytes_rate',
  detail: 'bytes_rate(range-vector)',
  documentation: 'Calculates the number of bytes per second for each stream.'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: 'Calculates the number of entries per second.'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...RANGE_VEC_FUNCTIONS];
const LOKI_KEYWORDS = [...FUNCTIONS, ...PIPE_OPERATORS, ...PIPE_PARSERS].map(keyword => keyword.label);
const lokiGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((without|by)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-zA-Z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  'context-pipe': {
    pattern: /\s\|[^=~]\s?\w*/i,
    inside: {
      'pipe-operator': {
        pattern: /\|/i,
        alias: 'operator'
      },
      'pipe-operations': {
        pattern: new RegExp(`${[...PIPE_PARSERS, ...PIPE_OPERATORS].map(f => f.label).join('|')}`, 'i'),
        alias: 'keyword'
      }
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=\])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  quote: {
    pattern: /"(?:\\.|[^\\"])*"/,
    alias: 'string',
    greedy: true
  },
  backticks: {
    pattern: /`(?:\\.|[^\\`])*`/,
    alias: 'string',
    greedy: true
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: /\s?(\|[=~]?|!=?|<(?:=>?|<|>)?|>[>=]?)\s?/i,
  punctuation: /[{}(),.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lokiGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/loki/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiQueryType": () => (/* binding */ LokiQueryType),
/* harmony export */   "LokiResultType": () => (/* binding */ LokiResultType)
/* harmony export */ });
let LokiResultType;

(function (LokiResultType) {
  LokiResultType["Stream"] = "streams";
  LokiResultType["Vector"] = "vector";
  LokiResultType["Matrix"] = "matrix";
})(LokiResultType || (LokiResultType = {}));

let LokiQueryType;

(function (LokiQueryType) {
  LokiQueryType["Range"] = "range";
  LokiQueryType["Instant"] = "instant";
  LokiQueryType["Stream"] = "stream";
})(LokiQueryType || (LokiQueryType = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _querybuilder_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");




/**
 * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.
 *
 * It uses PromQL parser to find instances of metric and labels, alters them and then splices them back into the query.
 * Ideally we could use the parse -> change -> render is a simple 3 steps but right now building the visual query
 * object does not support all possible queries.
 *
 * So instead this just operates on substrings of the query with labels and operates just on those. This makes this
 * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.
 * @param query
 * @param key
 * @param value
 * @param operator
 */
function addLabelToQuery(query, key, value, operator = '=') {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  }

  const vectorSelectorPositions = getVectorSelectorPositions(query);

  if (!vectorSelectorPositions.length) {
    return query;
  }

  const filter = toLabelFilter(key, value, operator);
  return addFilter(query, vectorSelectorPositions, filter);
}

/**
 * Parse the string and get all VectorSelector positions in the query together with parsed representation of the vector
 * selector.
 * @param query
 */
function getVectorSelectorPositions(query) {
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(query);
  const positions = [];
  tree.iterate({
    enter: (type, from, to, get) => {
      if (type.name === 'VectorSelector') {
        const visQuery = (0,_querybuilder_parsing__WEBPACK_IMPORTED_MODULE_1__.buildVisualQueryFromString)(query.substring(from, to));
        positions.push({
          query: visQuery.query,
          from,
          to
        });
        return false;
      }
    }
  });
  return positions;
}

function toLabelFilter(key, value, operator) {
  // We need to make sure that we convert the value back to string because it may be a number
  const transformedValue = value === Infinity ? '+Inf' : value.toString();
  return {
    label: key,
    op: operator,
    value: transformedValue
  };
}

function addFilter(query, vectorSelectorPositions, filter) {
  const modeller = new _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__.PromQueryModeller();
  let newQuery = '';
  let prev = 0;

  for (let i = 0; i < vectorSelectorPositions.length; i++) {
    // This is basically just doing splice on a string for each matched vector selector.
    const match = vectorSelectorPositions[i];
    const isLast = i === vectorSelectorPositions.length - 1;
    const start = query.substring(prev, match.from);
    const end = isLast ? query.substring(match.to) : '';

    if (!labelExists(match.query.labels, filter)) {
      // We don't want to add duplicate labels.
      match.query.labels.push(filter);
    }

    const newLabels = modeller.renderQuery(match.query);
    newQuery += start + newLabels + end;
    prev = match.to;
  }

  return newQuery;
}
/**
 * Check if label exists in the list of labels but ignore the operator.
 * @param labels
 * @param filter
 */


function labelExists(labels, filter) {
  return labels.find(label => label.label === filter.label && label.value === filter.value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/datasource.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANNOTATION_QUERY_STEP_DEFAULT": () => (/* binding */ ANNOTATION_QUERY_STEP_DEFAULT),
/* harmony export */   "PrometheusDatasource": () => (/* binding */ PrometheusDatasource),
/* harmony export */   "alignRange": () => (/* binding */ alignRange),
/* harmony export */   "extractRuleMappingFromGroups": () => (/* binding */ extractRuleMappingFromGroups),
/* harmony export */   "prometheusRegularEscape": () => (/* binding */ prometheusRegularEscape),
/* harmony export */   "prometheusSpecialRegexEscape": () => (/* binding */ prometheusSpecialRegexEscape)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/util/pipe.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/tap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/catchError.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.7.1-726274dc4d-f362c5a2cf.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_core_utils_explore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/utils/explore.ts");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/templating/template_srv.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _query_hints__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/prometheus/query_hints.ts");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/prometheus/result_transformer.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _variables__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/prometheus/variables.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/features/alerting/unified/api/buildInfo.ts");
/* harmony import */ var app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/types/unified-alerting-dto.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Badge, _Badge2, _Tooltip, _div, _div2;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


























const ANNOTATION_QUERY_STEP_DEFAULT = '60s';
const GET_AND_POST_METADATA_ENDPOINTS = ['api/v1/query', 'api/v1/query_range', 'api/v1/series', 'api/v1/labels'];
class PrometheusDatasource extends _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.DataSourceWithBackend {
  constructor(instanceSettings, templateSrv = (0,app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_7__.getTemplateSrv)(), timeSrv = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__.getTimeSrv)(), languageProvider) {
    var _instanceSettings$jso, _instanceSettings$jso2;

    super(instanceSettings);
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "editorSrc", void 0);

    _defineProperty(this, "ruleMappings", void 0);

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "directUrl", void 0);

    _defineProperty(this, "access", void 0);

    _defineProperty(this, "basicAuth", void 0);

    _defineProperty(this, "withCredentials", void 0);

    _defineProperty(this, "metricsNameCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_2___default())({
      max: 10
    }));

    _defineProperty(this, "interval", void 0);

    _defineProperty(this, "queryTimeout", void 0);

    _defineProperty(this, "httpMethod", void 0);

    _defineProperty(this, "languageProvider", void 0);

    _defineProperty(this, "exemplarTraceIdDestinations", void 0);

    _defineProperty(this, "lookupsDisabled", void 0);

    _defineProperty(this, "customQueryParameters", void 0);

    _defineProperty(this, "exemplarsAvailable", void 0);

    _defineProperty(this, "subType", void 0);

    _defineProperty(this, "rulerEnabled", void 0);

    _defineProperty(this, "init", async () => {
      this.loadRules();
      this.exemplarsAvailable = await this.areExemplarsAvailable();
    });

    _defineProperty(this, "prepareTargets", (options, start, end) => {
      const queries = [];
      const activeTargets = [];
      const clonedTargets = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(options.targets);

      for (const target of clonedTargets) {
        if (!target.expr || target.hide) {
          continue;
        }

        target.requestId = options.panelId + target.refId;
        const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // In Explore, we run both (instant and range) queries if both are true (selected) or both are undefined (legacy Explore queries)

        if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore && target.range === target.instant) {
          // Create instant target
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
          instantTarget.format = 'table';
          instantTarget.instant = true;
          instantTarget.range = false;
          instantTarget.valueWithRefId = true;
          delete instantTarget.maxDataPoints;
          instantTarget.requestId += '_instant'; // Create range target

          const rangeTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
          rangeTarget.format = 'time_series';
          rangeTarget.instant = false;
          instantTarget.range = true; // Create exemplar query

          if (target.exemplar) {
            // Only create exemplar target for different metric names
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
              exemplarTarget.instant = false;
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            instantTarget.exemplar = false;
            rangeTarget.exemplar = false;
          } // Add both targets to activeTargets and queries arrays


          activeTargets.push(instantTarget, rangeTarget);
          queries.push(this.createQuery(instantTarget, options, start, end), this.createQuery(rangeTarget, options, start, end)); // If running only instant query in Explore, format as table
        } else if (target.instant && options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
          instantTarget.format = 'table';
          queries.push(this.createQuery(instantTarget, options, start, end));
          activeTargets.push(instantTarget);
        } else {
          // It doesn't make sense to query for exemplars in dashboard if only instant is selected
          if (target.exemplar && !target.instant) {
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            target.exemplar = false;
          }

          queries.push(this.createQuery(target, options, start, end));
          activeTargets.push(target);
        }
      }

      return {
        queries,
        activeTargets
      };
    });

    _defineProperty(this, "handleErrors", (err, target) => {
      const error = {
        message: err && err.statusText || 'Unknown error during query transaction. Please check JS console logs.',
        refId: target.refId
      };

      if (err.data) {
        if (typeof err.data === 'string') {
          error.message = err.data;
        } else if (err.data.error) {
          error.message = (0,app_core_utils_explore__WEBPACK_IMPORTED_MODULE_5__.safeStringifyValue)(err.data.error);
        }
      } else if (err.message) {
        error.message = err.message;
      } else if (typeof err === 'string') {
        error.message = err;
      }

      error.status = err.status;
      error.statusText = err.statusText;
      return error;
    });

    _defineProperty(this, "processAnnotationResponse", (options, data) => {
      const frames = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.toDataQueryResponse)({
        data: data
      }).data;

      if (!frames || !frames.length) {
        return [];
      }

      const annotation = options.annotation;
      const {
        tagKeys = '',
        titleFormat = '',
        textFormat = ''
      } = annotation;
      const step = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(annotation.step || ANNOTATION_QUERY_STEP_DEFAULT) * 1000;
      const tagKeysArray = tagKeys.split(',');
      const eventList = [];

      for (const frame of frames) {
        const timeField = frame.fields[0];
        const valueField = frame.fields[1];
        const labels = (valueField === null || valueField === void 0 ? void 0 : valueField.labels) || {};
        const tags = Object.keys(labels).filter(label => tagKeysArray.includes(label)).map(label => labels[label]);
        const timeValueTuple = [];
        let idx = 0;
        valueField.values.toArray().forEach(value => {
          let timeStampValue;
          let valueValue;
          const time = timeField.values.get(idx); // If we want to use value as a time, we use value as timeStampValue and valueValue will be 1

          if (options.annotation.useValueForTime) {
            timeStampValue = Math.floor(parseFloat(value));
            valueValue = 1;
          } else {
            timeStampValue = Math.floor(parseFloat(time));
            valueValue = parseFloat(value);
          }

          idx++;
          timeValueTuple.push([timeStampValue, valueValue]);
        });
        const activeValues = timeValueTuple.filter(value => value[1] >= 1);
        const activeValuesTimestamps = activeValues.map(value => value[0]); // Instead of creating singular annotation for each active event we group events into region if they are less
        // or equal to `step` apart.

        let latestEvent = null;

        for (const timestamp of activeValuesTimestamps) {
          var _latestEvent$timeEnd;

          // We already have event `open` and we have new event that is inside the `step` so we just update the end.
          if (latestEvent && ((_latestEvent$timeEnd = latestEvent.timeEnd) !== null && _latestEvent$timeEnd !== void 0 ? _latestEvent$timeEnd : 0) + step >= timestamp) {
            latestEvent.timeEnd = timestamp;
            continue;
          } // Event exists but new one is outside of the `step` so we add it to eventList.


          if (latestEvent) {
            eventList.push(latestEvent);
          } // We start a new region.


          latestEvent = {
            time: timestamp,
            timeEnd: timestamp,
            annotation,
            title: (0,_legend__WEBPACK_IMPORTED_MODULE_16__.renderLegendFormat)(titleFormat, labels),
            tags,
            text: (0,_legend__WEBPACK_IMPORTED_MODULE_16__.renderLegendFormat)(textFormat, labels)
          };
        }

        if (latestEvent) {
          // Finish up last point if we have one
          latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];
          eventList.push(latestEvent);
        }
      }

      return eventList;
    });

    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.type = 'prometheus';
    this.subType = app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus;
    this.rulerEnabled = false;
    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';
    this.id = instanceSettings.id;
    this.url = instanceSettings.url;
    this.access = instanceSettings.access;
    this.basicAuth = instanceSettings.basicAuth;
    this.withCredentials = instanceSettings.withCredentials;
    this.interval = instanceSettings.jsonData.timeInterval || '15s';
    this.queryTimeout = instanceSettings.jsonData.queryTimeout;
    this.httpMethod = instanceSettings.jsonData.httpMethod || 'POST'; // `directUrl` is never undefined, we set it at https://github.com/grafana/grafana/blob/main/pkg/api/frontendsettings.go#L108
    // here we "fall back" to this.url to make typescript happy, but it should never happen

    this.directUrl = (_instanceSettings$jso = instanceSettings.jsonData.directUrl) !== null && _instanceSettings$jso !== void 0 ? _instanceSettings$jso : this.url;
    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;
    this.ruleMappings = {};
    this.languageProvider = languageProvider !== null && languageProvider !== void 0 ? languageProvider : new _language_provider__WEBPACK_IMPORTED_MODULE_9__["default"](this);
    this.lookupsDisabled = (_instanceSettings$jso2 = instanceSettings.jsonData.disableMetricsLookup) !== null && _instanceSettings$jso2 !== void 0 ? _instanceSettings$jso2 : false;
    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);
    this.variables = new _variables__WEBPACK_IMPORTED_MODULE_14__.PrometheusVariableSupport(this, this.templateSrv, this.timeSrv);
    this.exemplarsAvailable = true;
  }

  getQueryDisplayText(query) {
    return query.expr;
  }

  _addTracingHeaders(httpOptions, options) {
    httpOptions.headers = {};
    const proxyMode = !this.url.match(/^http/);

    if (proxyMode) {
      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;
      httpOptions.headers['X-Panel-Id'] = options.panelId;
    }
  }
  /**
   * Any request done from this data source should go through here as it contains some common processing for the
   * request. Any processing done here needs to be also copied on the backend as this goes through data source proxy
   * but not through the same code as alerting.
   */


  _request(url, data, overrides = {}) {
    data = data || {};

    for (const [key, value] of this.customQueryParameters) {
      if (data[key] == null) {
        data[key] = value;
      }
    }

    const options = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.defaults)(overrides, {
      url: this.url + url,
      method: this.httpMethod,
      headers: {}
    });

    if (options.method === 'GET') {
      if (data && Object.keys(data).length) {
        options.url = options.url + (options.url.search(/\?/) >= 0 ? '&' : '?') + Object.entries(data).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');
      }
    } else {
      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
      options.data = data;
    }

    if (this.basicAuth || this.withCredentials) {
      options.withCredentials = true;
    }

    if (this.basicAuth) {
      options.headers.Authorization = this.basicAuth;
    }

    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch(options);
  }

  async importFromAbstractQueries(abstractQueries) {
    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));
  }

  async exportToAbstractQueries(queries) {
    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));
  } // Use this for tab completion features, wont publish response to other components


  async metadataRequest(url, params = {}) {
    // If URL includes endpoint that supports POST and GET method, try to use configured method. This might fail as POST is supported only in v2.10+.
    if (GET_AND_POST_METADATA_ENDPOINTS.some(endpoint => url.includes(endpoint))) {
      try {
        return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this._request(url, params, {
          method: this.httpMethod,
          hideFromInspector: true
        }));
      } catch (err) {
        // If status code of error is Method Not Allowed (405) and HTTP method is POST, retry with GET
        if (this.httpMethod === 'POST' && err.status === 405) {
          console.warn(`Couldn't use configured POST HTTP method for this request. Trying to use GET method instead.`);
        } else {
          throw err;
        }
      }
    }

    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this._request(url, params, {
      method: 'GET',
      hideFromInspector: true
    })); // toPromise until we change getTagValues, getTagKeys to Observable
  }

  interpolateQueryExpr(value = [], variable) {
    // if no multi or include all do not regexEscape
    if (!variable.multi && !variable.includeAll) {
      return prometheusRegularEscape(value);
    }

    if (typeof value === 'string') {
      return prometheusSpecialRegexEscape(value);
    }

    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));

    if (escapedValues.length === 1) {
      return escapedValues[0];
    }

    return '(' + escapedValues.join('|') + ')';
  }

  targetContainsTemplate(target) {
    return this.templateSrv.containsTemplate(target.expr);
  }

  shouldRunExemplarQuery(target, request) {
    if (target.exemplar) {
      // We check all already processed targets and only create exemplar target for not used metric names
      const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // Remove targets that weren't processed yet (in targets array they are after current target)

      const currentTargetIdx = request.targets.findIndex(t => t.refId === target.refId);
      const targets = request.targets.slice(0, currentTargetIdx);

      if (!metricName || metricName && !targets.some(t => t.expr.includes(metricName))) {
        return true;
      }

      return false;
    }

    return false;
  }

  processTargetV2(target, request) {
    const processedTarget = Object.assign({}, target, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_13__.PromQueryType.timeSeriesQuery,
      exemplar: this.shouldRunExemplarQuery(target, request),
      requestId: request.panelId + target.refId,
      // We need to pass utcOffsetSec to backend to calculate aligned range
      utcOffsetSec: this.timeSrv.timeRange().to.utcOffset() * 60
    });
    return processedTarget;
  }

  query(request) {
    if (this.access === 'proxy') {
      const targets = request.targets.map(target => this.processTargetV2(target, request));
      return super.query(Object.assign({}, request, {
        targets
      })).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => (0,_result_transformer__WEBPACK_IMPORTED_MODULE_12__.transformV2)(response, request, {
        exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
      }))); // Run queries trough browser/proxy
    } else {
      const start = this.getPrometheusTime(request.range.from, false);
      const end = this.getPrometheusTime(request.range.to, true);
      const {
        queries,
        activeTargets
      } = this.prepareTargets(request, start, end); // No valid targets, return the empty result to save a round trip.

      if (!queries || !queries.length) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }

      if (request.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
        return this.exploreQuery(queries, activeTargets, end);
      }

      return this.panelsQuery(queries, activeTargets, end, request.requestId, request.scopedVars);
    }
  }

  exploreQuery(queries, activeTargets, end) {
    let runningQueriesCount = queries.length;
    const subQueries = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.pipe)( // Decrease the counter here. We assume that each request returns only single value and then completes
      // (should hold until there is some streaming requests involved).
      (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_25__.tap)(() => runningQueriesCount--), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_12__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return {
          data,
          key: query.requestId,
          state: runningQueriesCount === 0 ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Loading
        };
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(...subQueries);
  }

  panelsQuery(queries, activeTargets, end, requestId, scopedVars) {
    const observables = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.pipe)((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_12__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          scopedVars,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return data;
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_28__.forkJoin)(observables).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(results => {
      const data = results.reduce((result, current) => {
        return [...result, ...current];
      }, []);
      return {
        data,
        key: requestId,
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
      };
    }));
  }

  runQuery(query, end, filter) {
    if (query.instant) {
      return this.performInstantQuery(query, end).pipe(filter);
    }

    if (query.exemplar) {
      return this.getExemplars(query).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(() => {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }), filter);
    }

    return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filter);
  }

  createQuery(target, options, start, end) {
    const query = {
      hinting: target.hinting,
      instant: target.instant,
      exemplar: target.exemplar,
      step: 0,
      expr: '',
      requestId: target.requestId,
      refId: target.refId,
      start: 0,
      end: 0
    };
    const range = Math.ceil(end - start); // options.interval is the dynamically calculated interval

    let interval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(options.interval); // Minimum interval ("Min step"), if specified for the query, or same as interval otherwise.

    const minInterval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval || options.interval, options.scopedVars)); // Scrape interval as specified for the query ("Min step") or otherwise taken from the datasource.
    // Min step field can have template variables in it, make sure to replace it.

    const scrapeInterval = target.interval ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars)) : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.interval);
    const intervalFactor = target.intervalFactor || 1; // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits

    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);
    let scopedVars = Object.assign({}, options.scopedVars, this.getRangeScopedVars(options.range), this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval)); // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars

    if (interval !== adjustedInterval) {
      interval = adjustedInterval;
      scopedVars = Object.assign({}, options.scopedVars, Object.assign({
        __interval: {
          text: interval + 's',
          value: interval + 's'
        },
        __interval_ms: {
          text: interval * 1000,
          value: interval * 1000
        }
      }, this.getRateIntervalScopedVariable(interval, scrapeInterval), this.getRangeScopedVars(options.range)));
    }

    query.step = interval;
    let expr = target.expr; // Apply adhoc filters

    expr = this.enhanceExprWithAdHocFilters(expr); // Only replace vars in expression after having (possibly) updated interval vars

    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr); // Align query interval with step to allow query caching and to ensure
    // that about-same-time query results look the same.

    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);
    query.start = adjusted.start;
    query.end = adjusted.end;

    this._addTracingHeaders(query, options);

    return query;
  }

  getRateIntervalScopedVariable(interval, scrapeInterval) {
    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.
    if (scrapeInterval === 0) {
      scrapeInterval = 15;
    }

    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);
    return {
      __rate_interval: {
        text: rateInterval + 's',
        value: rateInterval + 's'
      }
    };
  }

  adjustInterval(interval, minInterval, range, intervalFactor) {
    // Prometheus will drop queries that might return more than 11000 data points.
    // Calculate a safe interval as an additional minimum to take into account.
    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1
    // If this is the case take the ceil of the value.
    let safeInterval = range / 11000;

    if (safeInterval > 1) {
      safeInterval = Math.ceil(safeInterval);
    }

    return Math.max(interval * intervalFactor, minInterval, safeInterval);
  }

  performTimeSeriesQuery(query, start, end) {
    if (start > end) {
      throw {
        message: 'Invalid time range'
      };
    }

    const url = '/api/v1/query_range';
    const data = {
      query: query.expr,
      start,
      end,
      step: query.step
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_30__.throwError)(this.handleErrors(err, query));
    }));
  }

  performInstantQuery(query, time) {
    const url = '/api/v1/query';
    const data = {
      query: query.expr,
      time
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_30__.throwError)(this.handleErrors(err, query));
    }));
  }

  metricFindQuery(query) {
    if (!query) {
      return Promise.resolve([]);
    }

    const scopedVars = Object.assign({
      __interval: {
        text: this.interval,
        value: this.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval)
      }
    }, this.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_15__["default"](this, interpolated);
    return metricFindQuery.process();
  }

  getRangeScopedVars(range = this.timeSrv.timeRange()) {
    const msRange = range.to.diff(range.from);
    const sRange = Math.round(msRange / 1000);
    return {
      __range_ms: {
        text: msRange,
        value: msRange
      },
      __range_s: {
        text: sRange,
        value: sRange
      },
      __range: {
        text: sRange + 's',
        value: sRange + 's'
      }
    };
  }

  async annotationQuery(options) {
    const annotation = options.annotation;
    const {
      expr = ''
    } = annotation;

    if (!expr) {
      return Promise.resolve([]);
    }

    const step = options.annotation.step || ANNOTATION_QUERY_STEP_DEFAULT;
    const queryModel = {
      expr,
      range: true,
      instant: false,
      exemplar: false,
      interval: step,
      queryType: _types__WEBPACK_IMPORTED_MODULE_13__.PromQueryType.timeSeriesQuery,
      refId: 'X',
      datasource: this.getRef()
    };
    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch({
      url: '/api/ds/query',
      method: 'POST',
      data: {
        from: (this.getPrometheusTime(options.range.from, false) * 1000).toString(),
        to: (this.getPrometheusTime(options.range.to, true) * 1000).toString(),
        queries: [this.applyTemplateVariables(queryModel, {})]
      },
      requestId: `prom-query-${annotation.name}`
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(rsp => {
      return this.processAnnotationResponse(options, rsp.data);
    })));
  }

  getExemplars(query) {
    const url = '/api/v1/query_exemplars';
    return this._request(url, {
      query: query.expr,
      start: query.start.toString(),
      end: query.end.toString()
    }, {
      requestId: query.requestId,
      headers: query.headers
    });
  }

  async getSubtitle() {
    const buildInfo = await this.getBuildInfo();
    return buildInfo ? this.getBuildInfoMessage(buildInfo) : null;
  }

  async getTagKeys(options) {
    if (options !== null && options !== void 0 && options.series) {
      // Get tags for the provided series only
      const seriesLabels = await Promise.all(options.series.map(series => this.languageProvider.fetchSeriesLabels(series)));
      const uniqueLabels = [...new Set(...seriesLabels.map(value => Object.keys(value)))];
      return uniqueLabels.map(value => ({
        text: value
      }));
    } else {
      var _result$data$data$map, _result$data, _result$data$data;

      // Get all tags
      const result = await this.metadataRequest('/api/v1/labels');
      return (_result$data$data$map = result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$data = _result$data.data) === null || _result$data$data === void 0 ? void 0 : _result$data$data.map(value => ({
        text: value
      }))) !== null && _result$data$data$map !== void 0 ? _result$data$data$map : [];
    }
  }

  async getTagValues(options = {}) {
    var _result$data$data$map2, _result$data2, _result$data2$data;

    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);
    return (_result$data$data$map2 = result === null || result === void 0 ? void 0 : (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : (_result$data2$data = _result$data2.data) === null || _result$data2$data === void 0 ? void 0 : _result$data2$data.map(value => ({
      text: value
    }))) !== null && _result$data$data$map2 !== void 0 ? _result$data$data$map2 : [];
  }

  async getBuildInfo() {
    try {
      const buildInfo = await (0,app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_17__.fetchDataSourceBuildInfo)(this);
      return buildInfo;
    } catch (error) {
      // We don't want to break the rest of functionality if build info does not work correctly
      return undefined;
    }
  }

  getBuildInfoMessage(buildInfo) {
    var _buildInfo$applicatio, _buildInfo$applicatio2;

    const enabled = _Badge || (_Badge = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Badge, {
      color: "green",
      icon: "check",
      text: "Ruler API enabled"
    }));

    const disabled = _Badge2 || (_Badge2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Badge, {
      color: "orange",
      icon: "exclamation-triangle",
      text: "Ruler API not enabled"
    }));

    const unsupported = _Tooltip || (_Tooltip = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Tooltip, {
      placement: "top",
      content: "Prometheus does not allow editing rules, connect to either a Mimir or Cortex datasource to manage alerts via Grafana.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Badge, {
          color: "red",
          icon: "exclamation-triangle",
          text: "Ruler API not supported"
        })
      })
    }));

    const LOGOS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Cortex]: '/public/app/plugins/datasource/prometheus/img/cortex_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Mimir]: '/public/app/plugins/datasource/prometheus/img/mimir_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus]: '/public/app/plugins/datasource/prometheus/img/prometheus_logo.svg'
    };
    const COLORS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Cortex]: 'blue',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Mimir]: 'orange',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus]: 'red'
    }; // this will inform the user about what "subtype" the datasource is; Mimir, Cortex or vanilla Prometheus

    const applicationSubType = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Badge, {
      text: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)("span", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("img", {
          style: {
            width: 14,
            height: 14,
            verticalAlign: 'text-bottom'
          },
          src: LOGOS[(_buildInfo$applicatio = buildInfo.application) !== null && _buildInfo$applicatio !== void 0 ? _buildInfo$applicatio : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus]
        }), ' ', buildInfo.application]
      }),
      color: COLORS[(_buildInfo$applicatio2 = buildInfo.application) !== null && _buildInfo$applicatio2 !== void 0 ? _buildInfo$applicatio2 : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus]
    });

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'max-content max-content',
        rowGap: '0.5rem',
        columnGap: '2rem',
        marginTop: '1rem'
      },
      children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: "Type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: applicationSubType
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.Fragment, {
        children: [_div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: "Ruler API"
        })), buildInfo.application === app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: unsupported
        }), buildInfo.application !== app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: buildInfo.features.rulerApiEnabled ? enabled : disabled
        })]
      })]
    });
  }

  async testDatasource() {
    const now = new Date().getTime();
    const request = {
      targets: [{
        refId: 'test',
        expr: '1+1',
        instant: true
      }],
      requestId: `${this.id}-health`,
      scopedVars: {},
      dashboardId: 0,
      panelId: 0,
      interval: '1m',
      intervalMs: 60000,
      maxDataPoints: 1,
      range: {
        from: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now - 1000),
        to: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now)
      }
    };
    const buildInfo = await this.getBuildInfo();
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this.query(request)).then(res => {
      if (!res || !res.data || res.state !== _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done) {
        var _res$error;

        return {
          status: 'error',
          message: `Error reading Prometheus: ${res === null || res === void 0 ? void 0 : (_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message}`
        };
      } else {
        return {
          status: 'success',
          message: 'Data source is working',
          details: buildInfo && {
            verboseMessage: this.getBuildInfoMessage(buildInfo)
          }
        };
      }
    }).catch(err => {
      console.error('Prometheus Error', err);
      return {
        status: 'error',
        message: err.message
      };
    });
  }

  interpolateVariablesInQueries(queries, scopedVars) {
    let expandedQueries = queries;

    if (queries && queries.length) {
      expandedQueries = queries.map(query => {
        const expandedQuery = Object.assign({}, query, {
          datasource: this.getRef(),
          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),
          interval: this.templateSrv.replace(query.interval, scopedVars)
        });
        return expandedQuery;
      });
    }

    return expandedQueries;
  }

  getQueryHints(query, result) {
    var _query$expr;

    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_11__.getQueryHints)((_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '', result, this);
  }

  getInitHints() {
    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_11__.getInitHints)(this);
  }

  async loadRules() {
    try {
      var _res$data, _res$data$data;

      const res = await this.metadataRequest('/api/v1/rules');
      const groups = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : (_res$data$data = _res$data.data) === null || _res$data$data === void 0 ? void 0 : _res$data$data.groups;

      if (groups) {
        this.ruleMappings = extractRuleMappingFromGroups(groups);
      }
    } catch (e) {
      console.log('Rules API is experimental. Ignore next error.');
      console.error(e);
    }
  }

  async areExemplarsAvailable() {
    try {
      const res = await this.metadataRequest('/api/v1/query_exemplars', {
        query: 'test'
      });

      if (res.data.status === 'success') {
        return true;
      }

      return false;
    } catch (err) {
      return false;
    }
  }

  modifyQuery(query, action) {
    var _query$expr2;

    let expression = (_query$expr2 = query.expr) !== null && _query$expr2 !== void 0 ? _query$expr2 : '';

    switch (action.type) {
      case 'ADD_FILTER':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_8__.addLabelToQuery)(expression, action.key, action.value);
          break;
        }

      case 'ADD_FILTER_OUT':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_8__.addLabelToQuery)(expression, action.key, action.value, '!=');
          break;
        }

      case 'ADD_HISTOGRAM_QUANTILE':
        {
          expression = `histogram_quantile(0.95, sum(rate(${expression}[$__rate_interval])) by (le))`;
          break;
        }

      case 'ADD_RATE':
        {
          expression = `rate(${expression}[$__rate_interval])`;
          break;
        }

      case 'ADD_SUM':
        {
          expression = `sum(${expression.trim()}) by ($1)`;
          break;
        }

      case 'EXPAND_RULES':
        {
          if (action.mapping) {
            expression = (0,_language_utils__WEBPACK_IMPORTED_MODULE_10__.expandRecordingRules)(expression, action.mapping);
          }

          break;
        }

      default:
        break;
    }

    return Object.assign({}, query, {
      expr: expression
    });
  }

  getPrometheusTime(date, roundUp) {
    if (typeof date === 'string') {
      date = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateMath.parse(date, roundUp);
    }

    return Math.ceil(date.valueOf() / 1000);
  }

  getTimeRangeParams() {
    const range = this.timeSrv.timeRange();
    return {
      start: this.getPrometheusTime(range.from, false).toString(),
      end: this.getPrometheusTime(range.to, true).toString()
    };
  }

  getOriginalMetricName(labelData) {
    return (0,_result_transformer__WEBPACK_IMPORTED_MODULE_12__.getOriginalMetricName)(labelData);
  }

  enhanceExprWithAdHocFilters(expr) {
    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    const finalQuery = adhocFilters.reduce((acc, filter) => {
      const {
        key,
        operator
      } = filter;
      let {
        value
      } = filter;

      if (operator === '=~' || operator === '!~') {
        value = prometheusRegularEscape(value);
      }

      return (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_8__.addLabelToQuery)(acc, key, value, operator);
    }, expr);
    return finalQuery;
  } // Used when running queries trough backend


  filterQuery(query) {
    if (query.hide || !query.expr) {
      return false;
    }

    return true;
  } // Used when running queries trough backend


  applyTemplateVariables(target, scopedVars) {
    const variables = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(scopedVars); // We want to interpolate these variables on backend

    delete variables.__interval;
    delete variables.__interval_ms; //Add ad hoc filters

    const expr = this.enhanceExprWithAdHocFilters(target.expr);
    return Object.assign({}, target, {
      legendFormat: this.templateSrv.replace(target.legendFormat, variables),
      expr: this.templateSrv.replace(expr, variables, this.interpolateQueryExpr),
      interval: this.templateSrv.replace(target.interval, variables)
    });
  }

  getVariables() {
    return this.templateSrv.getVariables().map(v => `$${v.name}`);
  }

  interpolateString(string) {
    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);
  }

}
/**
 * Align query range to step.
 * Rounds start and end down to a multiple of step.
 * @param start Timestamp marking the beginning of the range.
 * @param end Timestamp marking the end of the range.
 * @param step Interval to align start and end with.
 * @param utcOffsetSec Number of seconds current timezone is offset from UTC
 */

function alignRange(start, end, step, utcOffsetSec) {
  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;
  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;
  return {
    end: alignedEnd,
    start: alignedStart
  };
}
function extractRuleMappingFromGroups(groups) {
  return groups.reduce((mapping, group) => group.rules.filter(rule => rule.type === 'recording').reduce((acc, rule) => Object.assign({}, acc, {
    [rule.name]: rule.query
  }), mapping), {});
} // NOTE: these two functions are very similar to the escapeLabelValueIn* functions
// in language_utils.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.

function prometheusRegularEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\').replace(/'/g, "\\\\'") : value;
}
function prometheusSpecialRegexEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\\\\\').replace(/[$^*{}\[\]\'+?.()|]/g, '\\\\$&') : value;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUGGESTIONS_LIMIT": () => (/* binding */ SUGGESTIONS_LIMIT),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ PromQlLanguageProvider),
/* harmony export */   "getMetadataString": () => (/* binding */ getMetadataString)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.7.1-726274dc4d-f362c5a2cf.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_KEYS = ['job', 'instance'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 5;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h
// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.

const SUGGESTIONS_LIMIT = 10000;

const wrapLabel = label => ({
  label
});

const setFunctionKind = suggestion => {
  suggestion.kind = 'function';
  return suggestion;
};

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);
  const count = historyForItem.length;
  const recent = historyForItem[0];
  let hint = `Queried ${count} times in the last 24h.`;

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}

function addMetricsMetadata(metric, metadata) {
  const item = {
    label: metric
  };

  if (metadata && metadata[metric]) {
    item.documentation = getMetadataString(metric, metadata);
  }

  return item;
}

function getMetadataString(metric, metadata) {
  if (!metadata[metric]) {
    return undefined;
  }

  const {
    type,
    help
  } = metadata[metric];
  return `${type.toUpperCase()}: ${help}`;
}
const PREFIX_DELIMITER_REGEX = /(="|!="|=~"|!~"|\{|\[|\(|\+|-|\/|\*|%|\^|\band\b|\bor\b|\bunless\b|==|>=|!=|<=|>|<|=|~|,)/;
class PromQlLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LanguageProvider {
  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "histogramMetrics", void 0);

    _defineProperty(this, "timeRange", void 0);

    _defineProperty(this, "metrics", void 0);

    _defineProperty(this, "metricsMetadata", void 0);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "labelKeys", []);

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "request", async (url, defaultValue, params = {}) => {
      try {
        const res = await this.datasource.metadataRequest(url, params);
        return res.data.data;
      } catch (error) {
        console.error(error);
      }

      return defaultValue;
    });

    _defineProperty(this, "start", async () => {
      if (this.datasource.lookupsDisabled) {
        return [];
      } // TODO #33976: make those requests parallel


      await this.fetchLabels();
      this.metrics = (await this.fetchLabelValues('__name__')) || [];
      await this.loadMetricsMetadata();
      this.histogramMetrics = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processHistogramMetrics)(this.metrics).sort();
      return [];
    });

    _defineProperty(this, "provideCompletionItems", async ({
      prefix,
      text,
      value,
      labelKey,
      wrapperClasses
    }, context = {}) => {
      const emptyResult = {
        suggestions: []
      };

      if (!value) {
        return emptyResult;
      } // Local text properties


      const empty = value.document.text.length === 0;
      const selectedLines = value.document.getTextsAtRange(value.selection);
      const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
      const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

      const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

      const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

      const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

      const safePrefix = prefix && !text.match(/^[\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

      const operatorsPattern = /[+\-*/^%]/;
      const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

      if (wrapperClasses.includes('context-range')) {
        // Suggestions for metric[|]
        return this.getRangeCompletionItems();
      } else if (wrapperClasses.includes('context-labels')) {
        // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}
        return this.getLabelCompletionItems({
          prefix,
          text,
          value,
          labelKey,
          wrapperClasses
        });
      } else if (wrapperClasses.includes('context-aggregation')) {
        // Suggestions for sum(metric) by (|)
        return this.getAggregationCompletionItems(value);
      } else if (empty) {
        // Suggestions for empty query field
        return this.getEmptyCompletionItems(context);
      } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
        // Show term suggestions in a couple of scenarios
        return this.getBeginningCompletionItems(context);
      } else if (prefixUnrecognized && safePrefix) {
        // Show term suggestions in a couple of scenarios
        return this.getTermCompletionItems();
      }

      return emptyResult;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getEmptyCompletionItems", context => {
      const {
        history
      } = context;
      const suggestions = [];

      if (history && history.length) {
        const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
        suggestions.push({
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
          skipSort: true,
          label: 'History',
          items: historyItems
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const {
        metrics,
        metricsMetadata
      } = this;
      const suggestions = [];
      suggestions.push({
        searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
        label: 'Functions',
        items: _promql__WEBPACK_IMPORTED_MODULE_6__.FUNCTIONS.map(setFunctionKind)
      });

      if (metrics && metrics.length) {
        suggestions.push({
          label: 'Metrics',
          items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getAggregationCompletionItems", async value => {
      const suggestions = []; // Stitch all query lines together to support multi-line queries

      let queryOffset;
      const queryText = value.document.getBlocks().reduce((text, block) => {
        if (text === undefined) {
          return '';
        }

        if (!block) {
          return text;
        }

        const blockText = block === null || block === void 0 ? void 0 : block.getText();

        if (value.anchorBlock.key === block.key) {
          // Newline characters are not accounted for but this is irrelevant
          // for the purpose of extracting the selector string
          queryOffset = value.selection.anchor.offset + text.length;
        }

        return text + blockText;
      }, ''); // Try search for selector part on the left-hand side, such as `sum (m) by (l)`

      const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);
      let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);
      let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex); // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`

      if (openParensSelectorIndex === -1) {
        const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);
        closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);
        openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);
      }

      const result = {
        suggestions,
        context: 'context-aggregation'
      }; // Suggestions are useless for alternative aggregation clauses without a selector in context

      if (openParensSelectorIndex === -1) {
        return result;
      } // Range vector syntax not accounted for by subsequent parse so discard it if present


      const selectorString = queryText.slice(openParensSelectorIndex + 1, closeParensSelectorIndex).replace(/\[[^\]]+\]$/, '');
      const selector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(selectorString, selectorString.length - 2).selector;
      const series = await this.getSeries(selector);
      const labelKeys = Object.keys(series);

      if (labelKeys.length > 0) {
        const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(labelKeys);
        suggestions.push({
          label: `Labels${limitInfo}`,
          items: labelKeys.map(wrapLabel),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return result;
    });

    _defineProperty(this, "getLabelCompletionItems", async ({
      text,
      wrapperClasses,
      labelKey,
      value
    }) => {
      if (!value) {
        return {
          suggestions: []
        };
      }

      const suggestions = [];
      const line = value.anchorBlock.getText();
      const cursorOffset = value.selection.anchor.offset;
      const suffix = line.substr(cursorOffset);
      const prefix = line.substr(0, cursorOffset);
      const isValueStart = text.match(/^(=|=~|!=|!~)/);
      const isValueEnd = suffix.match(/^"?[,}]|$/); // Detect cursor in front of value, e.g., {key=|"}

      const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^"/); // Don't suggest anything at the beginning or inside a value

      const isValueEmpty = isValueStart && isValueEnd;
      const hasValuePrefix = isValueEnd && !isValueStart;

      if (!isValueEmpty && !hasValuePrefix || isPreValue) {
        return {
          suggestions
        };
      } // Get normalized selector


      let selector;
      let parsedSelector;

      try {
        parsedSelector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(line, cursorOffset);
        selector = parsedSelector.selector;
      } catch {
        selector = EMPTY_SELECTOR;
      }

      const containsMetric = selector.includes('__name__=');
      const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
      let series = {}; // Query labels for selector

      if (selector) {
        series = await this.getSeries(selector, !containsMetric);
      }

      if (Object.keys(series).length === 0) {
        console.warn(`Server did not return any values for selector = ${selector}`);
        return {
          suggestions
        };
      }

      let context;

      if (text && isValueStart || wrapperClasses.includes('attr-value')) {
        // Label values
        if (labelKey && series[labelKey]) {
          context = 'context-label-values';
          const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(series[labelKey]);
          suggestions.push({
            label: `Label values for "${labelKey}"${limitInfo}`,
            items: series[labelKey].map(wrapLabel),
            searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
          });
        }
      } else {
        // Label keys
        const labelKeys = series ? Object.keys(series) : containsMetric ? null : DEFAULT_KEYS;

        if (labelKeys) {
          const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

          if (possibleKeys.length) {
            context = 'context-labels';
            const newItems = possibleKeys.map(key => ({
              label: key
            }));
            const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(newItems);
            const newSuggestion = {
              label: `Labels${limitInfo}`,
              items: newItems,
              searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
            };
            suggestions.push(newSuggestion);
          }
        }
      }

      return {
        context,
        suggestions
      };
    });

    _defineProperty(this, "fetchLabelValues", async key => {
      const params = this.datasource.getTimeRangeParams();
      const url = `/api/v1/label/${this.datasource.interpolateString(key)}/values`;
      return await this.request(url, [], params);
    });

    _defineProperty(this, "fetchSeriesLabels", async (name, withName) => {
      const interpolatedName = this.datasource.interpolateString(name);
      const range = this.datasource.getTimeRangeParams();
      const urlParams = Object.assign({}, range, {
        'match[]': interpolatedName
      });
      const url = `/api/v1/series`; // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.
      // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
      // millisecond while still actually getting all the keys for the correct interval. This still can create problems
      // when user does not the newest values for a minute if already cached.

      const cacheParams = new URLSearchParams({
        'match[]': interpolatedName,
        start: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.start, 10)).toString(),
        end: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.end, 10)).toString(),
        withName: withName ? 'true' : 'false'
      });
      const cacheKey = `/api/v1/series?${cacheParams.toString()}`;
      let value = this.labelsCache.get(cacheKey);

      if (!value) {
        const data = await this.request(url, [], urlParams);
        const {
          values
        } = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processLabels)(data, withName);
        value = values;
        this.labelsCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = '/api/v1/series';
      const range = this.datasource.getTimeRangeParams();
      const params = Object.assign({}, range, {
        'match[]': match
      });
      return await this.request(url, {}, params);
    });

    _defineProperty(this, "fetchDefaultSeries", (0,lodash__WEBPACK_IMPORTED_MODULE_0__.once)(async () => {
      const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));
      return DEFAULT_KEYS.reduce((acc, key, i) => Object.assign({}, acc, {
        [key]: values[i]
      }), {});
    }));

    this.datasource = datasource;
    this.histogramMetrics = [];
    this.timeRange = {
      start: 0,
      end: 0
    };
    this.metrics = [];
    Object.assign(this, initialValues);
  } // Strip syntax chars so that typeahead suggestions can work on clean inputs


  cleanText(s) {
    const parts = s.split(PREFIX_DELIMITER_REGEX);
    const last = parts.pop();
    return last.trimLeft().replace(/"$/, '').replace(/^"/, '');
  }

  get syntax() {
    return _promql__WEBPACK_IMPORTED_MODULE_6__["default"];
  }

  async loadMetricsMetadata() {
    this.metricsMetadata = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.fixSummariesMetadata)(await this.request('/api/v1/metadata', {}));
  }

  getLabelKeys() {
    return this.labelKeys;
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [..._promql__WEBPACK_IMPORTED_MODULE_6__.RATE_RANGES]
      }]
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.toPromLikeQuery)(labelBasedQuery);
  }

  exportToAbstractQuery(query) {
    const promQuery = query.expr;

    if (!promQuery || promQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_2___default().tokenize(promQuery, _promql__WEBPACK_IMPORTED_MODULE_6__["default"]);
    const labelMatchers = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.extractLabelMatchers)(tokens);
    const nameLabelValue = getNameLabelValue(promQuery, tokens);

    if (nameLabelValue && nameLabelValue.length > 0) {
      labelMatchers.push({
        name: '__name__',
        operator: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.AbstractLabelOperator.Equal,
        value: nameLabelValue
      });
    }

    return {
      refId: query.refId,
      labelMatchers
    };
  }

  async getSeries(selector, withName) {
    if (this.datasource.lookupsDisabled) {
      return {};
    }

    try {
      if (selector === EMPTY_SELECTOR) {
        return await this.fetchDefaultSeries();
      } else {
        return await this.fetchSeriesLabels(selector, withName);
      }
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return {};
    }
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = '/api/v1/labels';
    const params = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, [], params);

    if (Array.isArray(res)) {
      this.labelKeys = res.slice().sort();
    }

    return [];
  }
  /**
   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   * @param withName
   */


}

function getNameLabelValue(promQuery, tokens) {
  let nameLabelValue = '';

  for (let prop in tokens) {
    if (typeof tokens[prop] === 'string') {
      nameLabelValue = tokens[prop];
      break;
    }
  }

  return nameLabelValue;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLimitInfo": () => (/* binding */ addLimitInfo),
/* harmony export */   "escapeLabelValueInExactSelector": () => (/* binding */ escapeLabelValueInExactSelector),
/* harmony export */   "escapeLabelValueInRegexSelector": () => (/* binding */ escapeLabelValueInRegexSelector),
/* harmony export */   "expandRecordingRules": () => (/* binding */ expandRecordingRules),
/* harmony export */   "extractLabelMatchers": () => (/* binding */ extractLabelMatchers),
/* harmony export */   "fixSummariesMetadata": () => (/* binding */ fixSummariesMetadata),
/* harmony export */   "labelRegexp": () => (/* binding */ labelRegexp),
/* harmony export */   "limitSuggestions": () => (/* binding */ limitSuggestions),
/* harmony export */   "parseSelector": () => (/* binding */ parseSelector),
/* harmony export */   "processHistogramMetrics": () => (/* binding */ processHistogramMetrics),
/* harmony export */   "processLabels": () => (/* binding */ processLabels),
/* harmony export */   "roundMsToMin": () => (/* binding */ roundMsToMin),
/* harmony export */   "roundSecToMin": () => (/* binding */ roundSecToMin),
/* harmony export */   "selectorRegexp": () => (/* binding */ selectorRegexp),
/* harmony export */   "toPromLikeExpr": () => (/* binding */ toPromLikeExpr),
/* harmony export */   "toPromLikeQuery": () => (/* binding */ toPromLikeQuery)
/* harmony export */ });
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const processHistogramMetrics = metrics => {
  const resultSet = new Set();
  const regexp = new RegExp('_bucket($|:)');

  for (let index = 0; index < metrics.length; index++) {
    const metric = metrics[index];
    const isHistogramValue = regexp.test(metric);

    if (isHistogramValue) {
      resultSet.add(metric);
    }
  }

  return [...resultSet];
};
function processLabels(labels, withName = false) {
  // For processing we are going to use sets as they have significantly better performance than arrays
  // After we process labels, we will convert sets to arrays and return object with label values in arrays
  const valueSet = {};
  labels.forEach(label => {
    const {
      __name__
    } = label,
          rest = _objectWithoutPropertiesLoose(label, _excluded);

    if (withName) {
      valueSet['__name__'] = valueSet['__name__'] || new Set();

      if (!valueSet['__name__'].has(__name__)) {
        valueSet['__name__'].add(__name__);
      }
    }

    Object.keys(rest).forEach(key => {
      if (!valueSet[key]) {
        valueSet[key] = new Set();
      }

      if (!valueSet[key].has(rest[key])) {
        valueSet[key].add(rest[key]);
      }
    });
  }); // valueArray that we are going to return in the object

  const valueArray = {};
  limitSuggestions(Object.keys(valueSet)).forEach(key => {
    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));
  });
  return {
    values: valueArray,
    keys: Object.keys(valueArray)
  };
} // const cleanSelectorRegexp = /\{(\w+="[^"\n]*?")(,\w+="[^"\n]*?")*\}/;

const selectorRegexp = /\{[^}]*?(\}|$)/;
const labelRegexp = /\b(\w+)(!?=~?)("[^"\n]*?")/g;
function parseSelector(query, cursorOffset = 1) {
  if (!query.match(selectorRegexp)) {
    // Special matcher for metrics
    if (query.match(/^[A-Za-z:][\w:]*$/)) {
      return {
        selector: `{__name__="${query}"}`,
        labelKeys: ['__name__']
      };
    }

    throw new Error('Query must contain a selector: ' + query);
  } // Check if inside a selector


  const prefix = query.slice(0, cursorOffset);
  const prefixOpen = prefix.lastIndexOf('{');
  const prefixClose = prefix.lastIndexOf('}');

  if (prefixOpen === -1) {
    throw new Error('Not inside selector, missing open brace: ' + prefix);
  }

  if (prefixClose > -1 && prefixClose > prefixOpen) {
    throw new Error('Not inside selector, previous selector already closed: ' + prefix);
  }

  const suffix = query.slice(cursorOffset);
  const suffixCloseIndex = suffix.indexOf('}');
  const suffixClose = suffixCloseIndex + cursorOffset;
  const suffixOpenIndex = suffix.indexOf('{');
  const suffixOpen = suffixOpenIndex + cursorOffset;

  if (suffixClose === -1) {
    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);
  }

  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {
    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);
  } // Extract clean labels to form clean selector, incomplete labels are dropped


  const selector = query.slice(prefixOpen, suffixClose);
  const labels = {};
  selector.replace(labelRegexp, (label, key, operator, value) => {
    const labelOffset = query.indexOf(label);
    const valueStart = labelOffset + key.length + operator.length + 1;
    const valueEnd = labelOffset + key.length + operator.length + value.length - 1; // Skip label if cursor is in value

    if (cursorOffset < valueStart || cursorOffset > valueEnd) {
      labels[key] = {
        value,
        operator
      };
    }

    return '';
  }); // Add metric if there is one before the selector

  const metricPrefix = query.slice(0, prefixOpen);
  const metricMatch = metricPrefix.match(/[A-Za-z:][\w:]*$/);

  if (metricMatch) {
    labels['__name__'] = {
      value: `"${metricMatch[0]}"`,
      operator: '='
    };
  } // Build sorted selector


  const labelKeys = Object.keys(labels).sort();
  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');
  const selectorString = ['{', cleanSelector, '}'].join('');
  return {
    labelKeys,
    selector: selectorString
  };
}
function expandRecordingRules(query, mapping) {
  const ruleNames = Object.keys(mapping);
  const rulesRegex = new RegExp(`(\\s|^)(${ruleNames.join('|')})(\\s|$|\\(|\\[|\\{)`, 'ig');
  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`); // Split query into array, so if query uses operators, we can correctly add labels to each individual part.

  const queryArray = expandedQuery.split(/(\+|\-|\*|\/|\%|\^)/); // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.

  const invalidLabelsRegex = /(\)\{|\}\{|\]\{)/;
  const correctlyExpandedQueryArray = queryArray.map(query => {
    return addLabelsToExpression(query, invalidLabelsRegex);
  });
  return correctlyExpandedQueryArray.join('');
}

function addLabelsToExpression(expr, invalidLabelsRegexp) {
  var _match$index;

  const match = expr.match(invalidLabelsRegexp);

  if (!match) {
    return expr;
  } // Split query into 2 parts - before the invalidLabelsRegex match and after.


  const indexOfRegexMatch = (_match$index = match.index) !== null && _match$index !== void 0 ? _match$index : 0;
  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);
  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1); // Create arrayOfLabelObjects with label objects that have key, operator and value.

  const arrayOfLabelObjects = [];
  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {
    arrayOfLabelObjects.push({
      key,
      operator,
      value
    });
    return '';
  }); // Loop through all label objects and add them to query.
  // As a starting point we have valid query without the labels.

  let result = exprBeforeRegexMatch;
  arrayOfLabelObjects.filter(Boolean).forEach(obj => {
    // Remove extra set of quotes from obj.value
    const value = obj.value.slice(1, -1);
    result = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_0__.addLabelToQuery)(result, obj.key, value, obj.operator);
  });
  return result;
}
/**
 * Adds metadata for synthetic metrics for which the API does not provide metadata.
 * See https://github.com/grafana/grafana/issues/22337 for details.
 *
 * @param metadata HELP and TYPE metadata from /api/v1/metadata
 */


function fixSummariesMetadata(metadata) {
  if (!metadata) {
    return metadata;
  }

  const baseMetadata = {};
  const summaryMetadata = {};

  for (const metric in metadata) {
    // NOTE: based on prometheus-documentation, we can receive
    // multiple metadata-entries for the given metric, it seems
    // it happens when the same metric is on multiple targets
    // and their help-text differs
    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)
    // for now we just use the first entry.
    const item = metadata[metric][0];
    baseMetadata[metric] = item;

    if (item.type === 'histogram') {
      summaryMetadata[`${metric}_bucket`] = {
        type: 'counter',
        help: `Cumulative counters for the observation buckets (${item.help})`
      };
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the histogram metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the histogram metric (${item.help})`
      };
    }

    if (item.type === 'summary') {
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the base metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the base metric (${item.help})`
      };
    }
  } // Synthetic series


  const syntheticMetadata = {};
  syntheticMetadata['ALERTS'] = {
    type: 'counter',
    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.'
  };
  return Object.assign({}, baseMetadata, summaryMetadata, syntheticMetadata);
}
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}
function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}
function limitSuggestions(items) {
  return items.slice(0, _language_provider__WEBPACK_IMPORTED_MODULE_1__.SUGGESTIONS_LIMIT);
}
function addLimitInfo(items) {
  return items && items.length >= _language_provider__WEBPACK_IMPORTED_MODULE_1__.SUGGESTIONS_LIMIT ? `, limited to the first ${_language_provider__WEBPACK_IMPORTED_MODULE_1__.SUGGESTIONS_LIMIT} received items` : '';
} // NOTE: the following 2 exported functions are very similar to the prometheus*Escape
// functions in datasource.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.
// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),
// so every character that matches something in that list has to be escaped.
// the list of metacharacters is: *+?()|\.[]{}^$
// we make a javascript regular expression that matches those characters:

const RE2_METACHARACTERS = /[*+?()|\\.\[\]{}^$]/g;

function escapePrometheusRegexp(value) {
  return value.replace(RE2_METACHARACTERS, '\\$&');
} // based on the openmetrics-documentation, the 3 symbols we have to handle are:
// - \n ... the newline character
// - \  ... the backslash character
// - "  ... the double-quote character


function escapeLabelValueInExactSelector(labelValue) {
  return labelValue.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
}
function escapeLabelValueInRegexSelector(labelValue) {
  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));
}
const FromPromLikeMap = {
  '=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.Equal,
  '!=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqual,
  '=~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.EqualRegEx,
  '!~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqualRegEx
};
const ToPromLikeMap = (0,lodash__WEBPACK_IMPORTED_MODULE_4__.invert)(FromPromLikeMap);
function toPromLikeExpr(labelBasedQuery) {
  const expr = labelBasedQuery.labelMatchers.map(selector => {
    const operator = ToPromLikeMap[selector.operator];

    if (operator) {
      return `${selector.name}${operator}"${selector.value}"`;
    } else {
      return '';
    }
  }).filter(e => e !== '').join(', ');
  return expr ? `{${expr}}` : '';
}
function toPromLikeQuery(labelBasedQuery) {
  return {
    refId: labelBasedQuery.refId,
    expr: toPromLikeExpr(labelBasedQuery),
    range: true
  };
}
function extractLabelMatchers(tokens) {
  const labelMatchers = [];

  for (let prop in tokens) {
    if (tokens[prop] instanceof prismjs__WEBPACK_IMPORTED_MODULE_3__.Token) {
      let token = tokens[prop];

      if (token.type === 'context-labels') {
        let labelKey = '';
        let labelValue = '';
        let labelOperator = '';
        let contentTokens = token.content;

        for (let currentToken in contentTokens) {
          if (typeof contentTokens[currentToken] === 'string') {
            let currentStr;
            currentStr = contentTokens[currentToken];

            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {
              labelOperator = currentStr;
            }
          } else if (contentTokens[currentToken] instanceof prismjs__WEBPACK_IMPORTED_MODULE_3__.Token) {
            switch (contentTokens[currentToken].type) {
              case 'label-key':
                labelKey = contentTokens[currentToken].content;
                break;

              case 'label-value':
                labelValue = contentTokens[currentToken].content;
                labelValue = labelValue.substring(1, labelValue.length - 1);
                const labelComparator = FromPromLikeMap[labelOperator];

                if (labelComparator) {
                  labelMatchers.push({
                    name: labelKey,
                    operator: labelComparator,
                    value: labelValue
                  });
                }

                break;
            }
          }
        }
      }
    }
  }

  return labelMatchers;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/metric_find_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PrometheusMetricFindQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class PrometheusMetricFindQuery {
  constructor(datasource, query) {
    this.datasource = datasource;
    this.query = query;

    _defineProperty(this, "range", void 0);

    this.datasource = datasource;
    this.query = query;
    this.datasource = datasource;
    this.query = query;
    this.range = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__.getTimeSrv)().timeRange();
  }

  process() {
    const labelNamesRegex = /^label_names\(\)\s*$/;
    const labelValuesRegex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\)\s*$/;
    const metricNamesRegex = /^metrics\((.+)\)\s*$/;
    const queryResultRegex = /^query_result\((.+)\)\s*$/;
    const labelNamesQuery = this.query.match(labelNamesRegex);

    if (labelNamesQuery) {
      return this.labelNamesQuery();
    }

    const labelValuesQuery = this.query.match(labelValuesRegex);

    if (labelValuesQuery) {
      if (labelValuesQuery[1]) {
        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);
      } else {
        return this.labelValuesQuery(labelValuesQuery[2]);
      }
    }

    const metricNamesQuery = this.query.match(metricNamesRegex);

    if (metricNamesQuery) {
      return this.metricNameQuery(metricNamesQuery[1]);
    }

    const queryResultQuery = this.query.match(queryResultRegex);

    if (queryResultQuery) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.lastValueFrom)(this.queryResultQuery(queryResultQuery[1]));
    } // if query contains full metric name, return metric name and label list


    return this.metricNameAndLabelsQuery(this.query);
  }

  labelNamesQuery() {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/labels`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
        return {
          text: value
        };
      });
    });
  }

  labelValuesQuery(label, metric) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    let url;

    if (!metric) {
      const params = {
        start: start.toString(),
        end: end.toString()
      }; // return label values globally

      url = `/api/v1/label/${label}/values`;
      return this.datasource.metadataRequest(url, params).then(result => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
          return {
            text: value
          };
        });
      });
    } else {
      const params = {
        'match[]': metric,
        start: start.toString(),
        end: end.toString()
      };
      url = `/api/v1/series`;
      return this.datasource.metadataRequest(url, params).then(result => {
        const _labels = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
          return metric[label] || '';
        }).filter(label => {
          return label !== '';
        });

        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.uniq)(_labels).map(metric => {
          return {
            text: metric,
            expandable: true
          };
        });
      });
    }
  }

  metricNameQuery(metricFilterPattern) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/label/__name__/values`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(result.data.data).filter(metricName => {
        const r = new RegExp(metricFilterPattern);
        return r.test(metricName);
      }).map(matchedMetricName => {
        return {
          text: matchedMetricName,
          expandable: true
        };
      }).value();
    });
  }

  queryResultQuery(query) {
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const instantQuery = {
      expr: query
    };
    return this.datasource.performInstantQuery(instantQuery, end).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data.result, metricData => {
        let text = metricData.metric.__name__ || '';
        delete metricData.metric.__name__;
        text += '{' + (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(metricData.metric, (v, k) => {
          return k + '="' + v + '"';
        }).join(',') + '}';
        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;
        return {
          text: text,
          expandable: true
        };
      });
    }));
  }

  metricNameAndLabelsQuery(query) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      'match[]': query,
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/series`;
    const self = this;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
        return {
          text: self.datasource.getOriginalMetricName(metric),
          expandable: true
        };
      });
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/promql.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOGICAL_OPERATORS": () => (/* binding */ LOGICAL_OPERATORS),
/* harmony export */   "OPERATORS": () => (/* binding */ OPERATORS),
/* harmony export */   "PROM_KEYWORDS": () => (/* binding */ PROM_KEYWORDS),
/* harmony export */   "RATE_RANGES": () => (/* binding */ RATE_RANGES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "promqlGrammar": () => (/* binding */ promqlGrammar)
/* harmony export */ });
// When changing RATE_RANGES, check if Loki/LogQL ranges should be changed too
// @see public/app/plugins/datasource/loki/language_provider.ts
const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__rate_interval',
  sortValue: '$__rate_interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];
const LOGICAL_OPERATORS = ['or', 'and', 'unless'];
const TRIGONOMETRIC_FUNCTIONS = [{
  label: 'acos',
  insertText: 'acos',
  detail: 'acos(v instant-vector)',
  documentation: 'calculates the arccosine of all elements in v'
}, {
  label: 'acosh',
  insertText: 'acosh',
  detail: 'acosh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic cosine of all elements in v'
}, {
  label: 'asin',
  insertText: 'asin',
  detail: 'asin(v instant-vector)',
  documentation: 'calculates the arcsine of all elements in v'
}, {
  label: 'asinh',
  insertText: 'asinh',
  detail: 'asinh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic sine of all elements in v'
}, {
  label: 'atan',
  insertText: 'atan',
  detail: 'atan(v instant-vector)',
  documentation: 'calculates the arctangent of all elements in v'
}, {
  label: 'atanh',
  insertText: 'atanh',
  detail: 'atanh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic tangent of all elements in v'
}, {
  label: 'cos',
  insertText: 'cos',
  detail: 'cos(v instant-vector)',
  documentation: 'calculates the cosine of all elements in v'
}, {
  label: 'cosh',
  insertText: 'cosh',
  detail: 'cosh(v instant-vector)',
  documentation: 'calculates the hyperbolic cosine of all elements in v'
}, {
  label: 'sin',
  insertText: 'sin',
  detail: 'sin(v instant-vector)',
  documentation: 'calculates the sine of all elements in v'
}, {
  label: 'sinh',
  insertText: 'sinh',
  detail: 'sinh(v instant-vector)',
  documentation: 'calculates the hyperbolic sine of all elements in v'
}, {
  label: 'tan',
  insertText: 'tan',
  detail: 'tan(v instant-vector)',
  documentation: 'calculates the tangent of all elements in v'
}, {
  label: 'tanh',
  insertText: 'tanh',
  detail: 'tanh(v instant-vector)',
  documentation: 'calculates the hyperbolic tangent of all elements in v'
}];
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'group',
  insertText: 'group',
  documentation: 'All values in the resulting vector are 1'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'count_values',
  insertText: 'count_values',
  documentation: 'Count number of elements with the same value'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}, {
  label: 'quantile',
  insertText: 'quantile',
  documentation: 'Calculate Ï†-quantile (0 â‰¤ Ï† â‰¤ 1) over dimensions'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...TRIGONOMETRIC_FUNCTIONS, {
  insertText: 'abs',
  label: 'abs',
  detail: 'abs(v instant-vector)',
  documentation: 'Returns the input vector with all sample values converted to their absolute value.'
}, {
  insertText: 'absent',
  label: 'absent',
  detail: 'absent(v instant-vector)',
  documentation: 'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.'
}, {
  insertText: 'absent_over_time',
  label: 'absent_over_time',
  detail: 'absent(v range-vector)',
  documentation: 'Returns an empty vector if the range vector passed to it has any elements and a 1-element vector with the value 1 if the range vector passed to it has no elements.'
}, {
  insertText: 'ceil',
  label: 'ceil',
  detail: 'ceil(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.'
}, {
  insertText: 'changes',
  label: 'changes',
  detail: 'changes(v range-vector)',
  documentation: 'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.'
}, {
  insertText: 'clamp',
  label: 'clamp',
  detail: 'clamp(v instant-vector, min scalar, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min` and an upper limit of `max`.'
}, {
  insertText: 'clamp_max',
  label: 'clamp_max',
  detail: 'clamp_max(v instant-vector, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.'
}, {
  insertText: 'clamp_min',
  label: 'clamp_min',
  detail: 'clamp_min(v instant-vector, min scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.'
}, {
  insertText: 'count_scalar',
  label: 'count_scalar',
  detail: 'count_scalar(v instant-vector)',
  documentation: 'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.'
}, {
  insertText: 'deg',
  label: 'deg',
  detail: 'deg(v instant-vector)',
  documentation: 'Converts radians to degrees for all elements in v'
}, {
  insertText: 'day_of_month',
  label: 'day_of_month',
  detail: 'day_of_month(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.'
}, {
  insertText: 'day_of_week',
  label: 'day_of_week',
  detail: 'day_of_week(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.'
}, {
  insertText: 'days_in_month',
  label: 'days_in_month',
  detail: 'days_in_month(v=vector(time()) instant-vector)',
  documentation: 'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.'
}, {
  insertText: 'delta',
  label: 'delta',
  detail: 'delta(v range-vector)',
  documentation: 'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.'
}, {
  insertText: 'deriv',
  label: 'deriv',
  detail: 'deriv(v range-vector)',
  documentation: 'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.'
}, {
  insertText: 'drop_common_labels',
  label: 'drop_common_labels',
  detail: 'drop_common_labels(instant-vector)',
  documentation: 'Drops all labels that have the same name and value across all series in the input vector.'
}, {
  insertText: 'exp',
  label: 'exp',
  detail: 'exp(v instant-vector)',
  documentation: 'Calculates the exponential function for all elements in `v`.\nSpecial cases are:\n* `Exp(+Inf) = +Inf` \n* `Exp(NaN) = NaN`'
}, {
  insertText: 'floor',
  label: 'floor',
  detail: 'floor(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.'
}, {
  insertText: 'histogram_quantile',
  label: 'histogram_quantile',
  detail: 'histogram_quantile(Ï† float, b instant-vector)',
  documentation: 'Calculates the Ï†-quantile (0 â‰¤ Ï† â‰¤ 1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.'
}, {
  insertText: 'holt_winters',
  label: 'holt_winters',
  detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',
  documentation: 'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.'
}, {
  insertText: 'hour',
  label: 'hour',
  detail: 'hour(v=vector(time()) instant-vector)',
  documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.'
}, {
  insertText: 'idelta',
  label: 'idelta',
  detail: 'idelta(v range-vector)',
  documentation: 'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.'
}, {
  insertText: 'increase',
  label: 'increase',
  detail: 'increase(v range-vector)',
  documentation: 'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.'
}, {
  insertText: 'irate',
  label: 'irate',
  detail: 'irate(v range-vector)',
  documentation: 'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.'
}, {
  insertText: 'label_join',
  label: 'label_join',
  detail: 'label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)',
  documentation: 'For each timeseries in `v`, joins all the values of all the `src_labels` using `separator` and returns the timeseries with the label `dst_label` containing the joined value. There can be any number of `src_labels` in this function.'
}, {
  insertText: 'label_replace',
  label: 'label_replace',
  detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',
  documentation: "For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged."
}, {
  insertText: 'ln',
  label: 'ln',
  detail: 'ln(v instant-vector)',
  documentation: 'Calculates the natural logarithm for all elements in `v`.\nSpecial cases are:\n * `ln(+Inf) = +Inf`\n * `ln(0) = -Inf`\n * `ln(x < 0) = NaN`\n * `ln(NaN) = NaN`'
}, {
  insertText: 'log2',
  label: 'log2',
  detail: 'log2(v instant-vector)',
  documentation: 'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'log10',
  label: 'log10',
  detail: 'log10(v instant-vector)',
  documentation: 'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'minute',
  label: 'minute',
  detail: 'minute(v=vector(time()) instant-vector)',
  documentation: 'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.'
}, {
  insertText: 'month',
  label: 'month',
  detail: 'month(v=vector(time()) instant-vector)',
  documentation: 'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.'
}, {
  insertText: 'pi',
  label: 'pi',
  detail: 'pi()',
  documentation: 'Returns pi'
}, {
  insertText: 'predict_linear',
  label: 'predict_linear',
  detail: 'predict_linear(v range-vector, t scalar)',
  documentation: 'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.'
}, {
  insertText: 'rad',
  label: 'rad',
  detail: 'rad(v instant-vector)',
  documentation: 'Converts degrees to radians for all elements in v'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: "Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period."
}, {
  insertText: 'resets',
  label: 'resets',
  detail: 'resets(v range-vector)',
  documentation: 'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.'
}, {
  insertText: 'round',
  label: 'round',
  detail: 'round(v instant-vector, to_nearest=1 scalar)',
  documentation: 'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.'
}, {
  insertText: 'scalar',
  label: 'scalar',
  detail: 'scalar(v instant-vector)',
  documentation: 'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.'
}, {
  insertText: 'sgn',
  label: 'sgn',
  detail: 'sgn(v instant-vector)',
  documentation: 'Returns a vector with all sample values converted to their sign, defined as this: 1 if v is positive, -1 if v is negative and 0 if v is equal to zero.'
}, {
  insertText: 'sort',
  label: 'sort',
  detail: 'sort(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in ascending order.'
}, {
  insertText: 'sort_desc',
  label: 'sort_desc',
  detail: 'sort_desc(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in descending order.'
}, {
  insertText: 'sqrt',
  label: 'sqrt',
  detail: 'sqrt(v instant-vector)',
  documentation: 'Calculates the square root of all elements in `v`.'
}, {
  insertText: 'time',
  label: 'time',
  detail: 'time()',
  documentation: 'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.'
}, {
  insertText: 'timestamp',
  label: 'timestamp',
  detail: 'timestamp(v instant-vector)',
  documentation: 'Returns the timestamp of each of the samples of the given vector as the number of seconds since January 1, 1970 UTC.'
}, {
  insertText: 'vector',
  label: 'vector',
  detail: 'vector(s scalar)',
  documentation: 'Returns the scalar `s` as a vector with no labels.'
}, {
  insertText: 'year',
  label: 'year',
  detail: 'year(v=vector(time()) instant-vector)',
  documentation: 'Returns the year for each of the given times in UTC.'
}, {
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average value of all points in the specified interval.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum value of all points in the specified interval.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum value of all points in the specified interval.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The Ï†-quantile (0 â‰¤ Ï† â‰¤ 1) of the values in the specified interval.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval.'
}, {
  insertText: 'last_over_time',
  label: 'last_over_time',
  detail: 'last_over_time(range-vector)',
  documentation: 'The most recent point value in specified interval.'
}];
const PROM_KEYWORDS = FUNCTIONS.map(keyword => keyword.label);
const promqlGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((by|without)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  idList: {
    pattern: /\d+(\|\d+)+/,
    alias: 'number'
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: new RegExp(`/[-+*/=%^~]|&&?|\\|?\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:${OPERATORS.join('|')})\\b`, 'i'),
  punctuation: /[{};()`,.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (promqlGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/query_hints.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUM_HINT_THRESHOLD_COUNT": () => (/* binding */ SUM_HINT_THRESHOLD_COUNT),
/* harmony export */   "getInitHints": () => (/* binding */ getInitHints),
/* harmony export */   "getQueryHints": () => (/* binding */ getQueryHints)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Number of time series results needed before starting to suggest sum aggregation hints
 */
const SUM_HINT_THRESHOLD_COUNT = 20;
function getQueryHints(query, series, datasource) {
  const hints = []; // ..._bucket metric needs a histogram_quantile()

  const histogramMetric = query.trim().match(/^\w+_bucket$|^\w+_bucket{.*}$/);

  if (histogramMetric) {
    const label = 'Selected metric has buckets.';
    hints.push({
      type: 'HISTOGRAM_QUANTILE',
      label,
      fix: {
        label: 'Consider calculating aggregated quantile by adding histogram_quantile().',
        action: {
          type: 'ADD_HISTOGRAM_QUANTILE',
          query
        }
      }
    });
  } // Check for need of rate()


  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {
    var _datasource$languageP, _datasource$languageP2;

    // Use metric metadata for exact types
    const nameMatch = query.match(/\b(\w+_(total|sum|count))\b/);
    let counterNameMetric = nameMatch ? nameMatch[1] : '';
    const metricsMetadata = (_datasource$languageP = datasource === null || datasource === void 0 ? void 0 : (_datasource$languageP2 = datasource.languageProvider) === null || _datasource$languageP2 === void 0 ? void 0 : _datasource$languageP2.metricsMetadata) !== null && _datasource$languageP !== void 0 ? _datasource$languageP : {};
    const metricMetadataKeys = Object.keys(metricsMetadata);
    let certain = false;

    if (metricMetadataKeys.length > 0) {
      var _metricMetadataKeys$f;

      counterNameMetric = (_metricMetadataKeys$f = metricMetadataKeys.find(metricName => {
        // Only considering first type information, could be non-deterministic
        const metadata = metricsMetadata[metricName];

        if (metadata.type.toLowerCase() === 'counter') {
          const metricRegex = new RegExp(`\\b${metricName}\\b`);

          if (query.match(metricRegex)) {
            certain = true;
            return true;
          }
        }

        return false;
      })) !== null && _metricMetadataKeys$f !== void 0 ? _metricMetadataKeys$f : '';
    }

    if (counterNameMetric) {
      // FixableQuery consists of metric name and optionally label-value pairs. We are not offering fix for complex queries yet.
      const fixableQuery = query.trim().match(/^\w+$|^\w+{.*}$/);
      const verb = certain ? 'is' : 'looks like';
      let label = `Selected metric ${verb} a counter.`;
      let fix;

      if (fixableQuery) {
        fix = {
          label: 'Consider calculating rate of counter by adding rate().',
          action: {
            type: 'ADD_RATE',
            query
          }
        };
      } else {
        label = `${label} Consider calculating rate of counter by adding rate().`;
      }

      hints.push({
        type: 'APPLY_RATE',
        label,
        fix
      });
    }
  } // Check for recording rules expansion


  if (datasource && datasource.ruleMappings) {
    const mapping = datasource.ruleMappings;
    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {
      if (query.search(ruleName) > -1) {
        return Object.assign({}, acc, {
          [ruleName]: mapping[ruleName]
        });
      }

      return acc;
    }, {});

    if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.size)(mappingForQuery) > 0) {
      const label = 'Query contains recording rules.';
      hints.push({
        type: 'EXPAND_RULES',
        label,
        fix: {
          label: 'Expand rules',
          action: {
            type: 'EXPAND_RULES',
            query,
            mapping: mappingForQuery
          }
        }
      });
    }
  }

  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {
    const simpleMetric = query.trim().match(/^\w+$/);

    if (simpleMetric) {
      hints.push({
        type: 'ADD_SUM',
        label: 'Many time series results returned.',
        fix: {
          label: 'Consider aggregating with sum().',
          action: {
            type: 'ADD_SUM',
            query: query,
            preventSubmit: true
          }
        }
      });
    }
  }

  return hints;
}
function getInitHints(datasource) {
  const hints = []; // Hint if using Loki as Prometheus data source

  if (datasource.directUrl.includes('/loki') && !datasource.languageProvider.metrics.length) {
    hints.push({
      label: `Using Loki as a Prometheus data source is no longer supported. You must use the Loki data source for your Loki instance.`,
      type: 'INFO'
    });
  } // Hint for big disabled lookups


  if (datasource.lookupsDisabled) {
    hints.push({
      label: `Labels and metrics lookup was disabled in data source settings.`,
      type: 'INFO'
    });
  }

  return hints;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryModeller": () => (/* binding */ PromQueryModeller),
/* harmony export */   "promQueryModeller": () => (/* binding */ promQueryModeller)
/* harmony export */ });
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _aggregations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");





class PromQueryModeller extends _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__.LokiAndPromQueryModellerBase {
  constructor() {
    super(() => {
      const allOperations = [...(0,_operations__WEBPACK_IMPORTED_MODULE_2__.getOperationDefinitions)(), ...(0,_aggregations__WEBPACK_IMPORTED_MODULE_1__.getAggregationOperations)()];

      for (const op of allOperations) {
        const func = _promql__WEBPACK_IMPORTED_MODULE_0__.FUNCTIONS.find(x => x.insertText === op.id);

        if (func) {
          op.documentation = func.documentation;
        }
      }

      return allOperations;
    });
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Functions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Trigonometric, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Time]);
  }

  getQueryPatterns() {
    return [{
      name: 'Rate then sum',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: 'sum',
        params: []
      }]
    }, {
      name: 'Rate then sum by(label) then avg',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['']
      }, {
        id: 'avg',
        params: []
      }]
    }, {
      name: 'Histogram quantile on rate',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }, {
      name: 'Histogram quantile on increase ',
      operations: [{
        id: 'increase',
        params: ['$__rate_interval']
      }, {
        id: '__max_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }];
  }

}
const promQueryModeller = new PromQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAggregationOperations": () => (/* binding */ getAggregationOperations)
/* harmony export */ });
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");



function getAggregationOperations() {
  return [...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sum), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Avg), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Min), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Max), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Count), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.TopK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.BottomK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountValues, {
    params: [{
      name: 'Identifier',
      type: 'string'
    }],
    defaultParams: ['count']
  }), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.SumOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AvgOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MinOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MaxOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LastOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.PresentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AbsentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.StddevOverTime)];
}

function createAggregationOverTime(name) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)()],
    defaultParams: ['$__interval'],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: _operations__WEBPACK_IMPORTED_MODULE_0__.addOperationWithRangeVector
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}]; // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.push({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.push(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_0__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      bool = model.params[1] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelParamEditor": () => (/* binding */ LabelParamEditor)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/datasource.tsx");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function LabelParamEditor({
  onChange,
  index,
  operationIndex,
  value,
  query,
  datasource
}) {
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
    inputId: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_5__.getOperationParamId)(operationIndex, index),
    menuShouldPortal: true,
    autoFocus: value === '' ? true : undefined,
    openMenuOnFocus: true,
    onOpenMenu: async () => {
      setState({
        isLoading: true
      });
      const options = await loadGroupByLabels(query, datasource);
      setState({
        options,
        isLoading: undefined
      });
    },
    isLoading: state.isLoading,
    allowCustomValue: true,
    noOptionsMessage: "No labels found",
    loadingMessage: "Loading labels",
    options: state.options,
    value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.toOption)(value),
    onChange: value => onChange(index, value.value)
  });
}

async function loadGroupByLabels(query, datasource) {
  let labels = query.labels; // This function is used by both Prometheus and Loki and this the only difference

  if (datasource instanceof _datasource__WEBPACK_IMPORTED_MODULE_3__.PrometheusDatasource) {
    labels = [{
      label: '__name__',
      op: '=',
      value: query.metric
    }, ...query.labels];
  }

  const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__.promQueryModeller.renderLabels(labels);
  const result = await datasource.languageProvider.fetchSeriesLabels(expr);
  return Object.keys(result).map(x => ({
    label: x,
    value: x
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addOperationWithRangeVector": () => (/* binding */ addOperationWithRangeVector),
/* harmony export */   "createFunction": () => (/* binding */ createFunction),
/* harmony export */   "createRangeFunction": () => (/* binding */ createRangeFunction),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions),
/* harmony export */   "operationWithRangeVectorRenderer": () => (/* binding */ operationWithRangeVectorRenderer)
/* harmony export */ });
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");




function getOperationDefinitions() {
  const list = [{
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.HistogramQuantile,
    name: 'Histogram quantile',
    params: [{
      name: 'Quantile',
      type: 'number',
      options: [0.99, 0.95, 0.9, 0.75, 0.5, 0.25]
    }],
    defaultParams: [0.9],
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LabelReplace,
    name: 'Label replace',
    params: [{
      name: 'Destination label',
      type: 'string'
    }, {
      name: 'Replacement',
      type: 'string'
    }, {
      name: 'Source label',
      type: 'string'
    }, {
      name: 'Regex',
      type: 'string'
    }],
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    defaultParams: ['', '$1', '', '(.*)'],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererRight,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Ln,
    name: 'Ln',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  }, createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Changes), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Rate, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Irate), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Increase, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Idelta), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Delta), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.HoltWinters,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)(), {
      name: 'Smoothing Factor',
      type: 'number'
    }, {
      name: 'Trend Factor',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5, 0.5],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.PredictLinear,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)(), {
      name: 'Seconds from now',
      type: 'number'
    }],
    defaultParams: ['$__interval', 60],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.QuantileOverTime,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)(), {
      name: 'Quantile',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.rangeRendererLeftWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_3__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }, createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Absent
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Acos,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Acosh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Asin,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Asinh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Atan,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Atanh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Ceil
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Clamp,
    name: 'Clamp',
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }, {
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1, 1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.ClampMax,
    params: [{
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.ClampMin,
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Cos,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Cosh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.DayOfMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.DayOfWeek,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.DaysInMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Deg
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Deriv), //
  createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Exp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Floor
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Group
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Hour
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LabelJoin,
    params: [{
      name: 'Destination Label',
      type: 'string',
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_0__.LabelParamEditor
    }, {
      name: 'Separator',
      type: 'string'
    }, {
      name: 'Source Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_0__.LabelParamEditor
    }],
    defaultParams: ['', ',', ''],
    renderer: labelJoinRenderer,
    addOperationHandler: labelJoinAddOperationHandler
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Log10
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Log2
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Minute
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Month
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Pi,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Quantile,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererLeft
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Rad
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Resets), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Round,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    params: [{
      name: 'To Nearest',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Scalar
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sgn
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sin,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sinh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sort
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.SortDesc
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sqrt
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Stddev
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Tan,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Tanh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Time,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Timestamp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Vector,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: model => `${model.id}(${model.params[0]})`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Year
  })];
  return list;
}
function createFunction(definition) {
  var _definition$name, _definition$params, _definition$defaultPa, _definition$category, _definition$renderer, _definition$addOperat;

  return Object.assign({}, definition, {
    id: definition.id,
    name: (_definition$name = definition.name) !== null && _definition$name !== void 0 ? _definition$name : (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(definition.id),
    params: (_definition$params = definition.params) !== null && _definition$params !== void 0 ? _definition$params : [],
    defaultParams: (_definition$defaultPa = definition.defaultParams) !== null && _definition$defaultPa !== void 0 ? _definition$defaultPa : [],
    category: (_definition$category = definition.category) !== null && _definition$category !== void 0 ? _definition$category : _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    renderer: (_definition$renderer = definition.renderer) !== null && _definition$renderer !== void 0 ? _definition$renderer : definition.params ? _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererRight : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererLeft,
    addOperationHandler: (_definition$addOperat = definition.addOperationHandler) !== null && _definition$addOperat !== void 0 ? _definition$addOperat : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  });
}
function createRangeFunction(name, withRateInterval = false) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)(withRateInterval)],
    defaultParams: [withRateInterval ? '$__rate_interval' : '$__interval'],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  };
}

function operationTypeChangedHandlerForRangeFunction(operation, newDef) {
  // validate current parameter
  if (operation.params[0] === '$__rate_interval' && newDef.defaultParams[0] !== '$__rate_interval') {
    operation.params = newDef.defaultParams;
  } else if (operation.params[0] === '$__interval' && newDef.defaultParams[0] !== '$__interval') {
    operation.params = newDef.defaultParams;
  }

  return operation;
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}
/**
 * Since there can only be one operation with range vector this will replace the current one (if one was added )
 */

function addOperationWithRangeVector(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };

  if (query.operations.length > 0) {
    // If operation exists it has to be in the registry so no point to check if it was found
    const firstOp = modeller.getOperationDef(query.operations[0].id);

    if (firstOp.addOperationHandler === addOperationWithRangeVector) {
      return Object.assign({}, query, {
        operations: [newOperation, ...query.operations.slice(1)]
      });
    }
  }

  return Object.assign({}, query, {
    operations: [newOperation, ...query.operations]
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

function labelJoinRenderer(model, def, innerExpr) {
  if (typeof model.params[1] !== 'string') {
    throw 'The separator must be a string';
  }

  const separator = `"${model.params[1]}"`;
  return `${model.id}(${innerExpr}, "${model.params[0]}", ${separator}, "${model.params.slice(2).join(separator)}")`;
}

function labelJoinAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");



/**
 * Parses a PromQL query into a visual query model.
 *
 * It traverses the tree and uses sort of state machine to update the query model. The query model is modified
 * during the traversal and sent to each handler as context.
 *
 * @param expr
 */

function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.replaceVariables)(expr);
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handlers.

  const visQuery = {
    metric: '',
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);
    context.errors.push({
      text: err.message
    });
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}

/**
 * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node
 * handled here does not necessarily need to be of type == Expr.
 * @param expr
 * @param node
 * @param context
 */
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'MetricIdentifier':
      {
        // Expectation is that there is only one of those per query.
        visQuery.metric = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node);
        break;
      }

    case 'LabelMatcher':
      {
        // Same as MetricIdentifier should be just one per query.
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName);

        if (err) {
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, err));
        }

        break;
      }

    case 'FunctionCall':
      {
        handleFunction(expr, node, context);
        break;
      }

    case 'AggregateExpr':
      {
        handleAggregation(expr, node, context);
        break;
      }

    case 'BinaryExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        break;
      }

    default:
      {
        if (node.name === 'ParenExpr') {
          // We don't support parenthesis in the query to group expressions. We just report error but go on with the
          // parsing.
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        } // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.


        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function isIntervalVariableError(node) {
  var _node$prevSibling, _node$prevSibling2, _node$prevSibling2$fi;

  return ((_node$prevSibling = node.prevSibling) === null || _node$prevSibling === void 0 ? void 0 : _node$prevSibling.name) === 'Expr' && ((_node$prevSibling2 = node.prevSibling) === null || _node$prevSibling2 === void 0 ? void 0 : (_node$prevSibling2$fi = _node$prevSibling2.firstChild) === null || _node$prevSibling2$fi === void 0 ? void 0 : _node$prevSibling2$fi.name) === 'VectorSelector';
}

function getLabel(expr, node) {
  const label = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('LabelName'));
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('MatchOp'));
  const value = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('StringLiteral')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

const rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];
/**
 * Handle function call which is usually and identifier and its body > arguments.
 * @param expr
 * @param node
 * @param context
 */

function handleFunction(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('FunctionIdentifier');
  const funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const params = [];
  let interval = ''; // This is a bit of a shortcut to get the interval argument. Reasons are
  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in
  //   the query model.
  // - it is easier to handle template variables this way as template variable is an error for the parser

  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {
    let match = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).match(/\[(.+)\]/);

    if (match !== null && match !== void 0 && match[1]) {
      interval = match[1];
      params.push(match[1]);
    }
  }

  const op = {
    id: funcName,
    params
  }; // We unshift operations to keep the more natural order that we want to have in the visual query editor.

  visQuery.operations.unshift(op);

  if (callArgs) {
    if ((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, callArgs) === interval + ']') {
      // This is a special case where we have a function with a single argument and it is the interval.
      // This happens when you start adding operations in query builder and did not set a metric yet.
      return;
    }

    updateFunctionArgs(expr, callArgs, context, op);
  }
}
/**
 * Handle aggregation as they are distinct type from other functions.
 * @param expr
 * @param node
 * @param context
 */


function handleAggregation(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('AggregateOp');
  let funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const modifier = node.getChild('AggregateModifier');
  const labels = [];

  if (modifier) {
    const byModifier = modifier.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = modifier.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    labels.push(...(0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getAllByType)(expr, modifier, 'GroupingLabel'));
  }

  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const op = {
    id: funcName,
    params: []
  };
  visQuery.operations.unshift(op);
  updateFunctionArgs(expr, callArgs, context, op); // We add labels after params in the visual query editor.

  op.params.push(...labels);
}
/**
 * Handle (probably) all types of arguments that function or aggregation can have.
 *
 *  FunctionCallArgs are nested bit weirdly basically its [firstArg, ...rest] where rest is again FunctionCallArgs so
 *  we cannot just get all the children and iterate them as arguments we have to again recursively traverse through
 *  them.
 *
 * @param expr
 * @param node
 * @param context
 * @param op - We need the operation to add the params to as an additional context.
 */


function updateFunctionArgs(expr, node, context, op) {
  if (!node) {
    return;
  }

  switch (node.name) {
    // In case we have an expression we don't know what kind so we have to look at the child as it can be anything.
    case 'Expr': // FunctionCallArgs are nested bit weirdly as mentioned so we have to go one deeper in this case.

    case 'FunctionCallArgs':
      {
        let child = node.firstChild;

        while (child) {
          updateFunctionArgs(expr, child, context, op);
          child = child.nextSibling;
        }

        break;
      }

    case 'NumberLiteral':
      {
        op.params.push(parseFloat((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node)));
        break;
      }

    case 'StringLiteral':
      {
        op.params.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).replace(/"/g, ''));
        break;
      }

    default:
      {
        // Means we get to something that does not seem like simple function arg and is probably nested query so jump
        // back to main context
        handleExpression(expr, node, context);
      }
  }
}

const operatorToOpName = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__.binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {});
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */

function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = operatorToOpName[op];
  const leftNumber = left.getChild('NumberLiteral');
  const rightNumber = right.getChild('NumberLiteral');
  const rightBinary = right.getChild('BinaryExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'NumberLiteral') {
      visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        metric: '',
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutoSizeInput": () => (/* binding */ AutoSizeInput)
/* harmony export */ });
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["defaultValue", "minWidth", "maxWidth", "onCommitChange", "onKeyDown", "onBlur"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




const AutoSizeInput = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref) => {
  const {
    defaultValue = '',
    minWidth = 10,
    maxWidth,
    onCommitChange,
    onKeyDown,
    onBlur
  } = props,
        restProps = _objectWithoutPropertiesLoose(props, _excluded);

  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_1__.useState(defaultValue);
  const [inputWidth, setInputWidth] = react__WEBPACK_IMPORTED_MODULE_1__.useState(minWidth);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    setInputWidth(getWidthFor(value.toString(), minWidth, maxWidth));
  }, [value, maxWidth, minWidth]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.Input, Object.assign({}, restProps, {
    ref: ref,
    value: value.toString(),
    onChange: event => {
      setValue(event.currentTarget.value);
    },
    width: inputWidth,
    onBlur: event => {
      if (onCommitChange) {
        onCommitChange(event);
      }

      if (onBlur) {
        onBlur(event);
      }
    },
    onKeyDown: event => {
      if (event.key === 'Enter' && onCommitChange) {
        onCommitChange(event);
      }

      if (onKeyDown) {
        onKeyDown(event);
      }
    },
    "data-testid": 'autosize-input'
  }));
});

function getWidthFor(value, minWidth, maxWidth) {
  if (!value) {
    return minWidth;
  }

  const extraSpace = 3;
  const realWidth = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.measureText)(value.toString(), 14).width / 8 + extraSpace;

  if (minWidth && realWidth < minWidth) {
    return minWidth;
  }

  if (maxWidth && realWidth > maxWidth) {
    return realWidth;
  }

  return realWidth;
}

AutoSizeInput.displayName = 'AutoSizeInput';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilterItem": () => (/* binding */ LabelFilterItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function LabelFilterItem({
  item,
  defaultOp,
  onChange,
  onDelete,
  onGetLabelNames,
  onGetLabelValues
}) {
  var _item$op2;

  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});

  const isMultiSelect = () => {
    return item.op === operators[0].label;
  };

  const getValue = item => {
    if (item && item.value) {
      if (item.value.indexOf('|') > 0) {
        return item.value.split('|').map(x => ({
          label: x,
          value: x
        }));
      }

      return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(item.value);
    }

    return null;
  };

  const getOptions = () => {
    if (!state.labelValues && item && item.value && item.value.indexOf('|') > 0) {
      return getValue(item);
    }

    return state.labelValues;
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": "prometheus-dimensions-filter-item",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.InputGroup, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
        inputId: "prometheus-dimensions-filter-item-key",
        width: "auto",
        value: item.label ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(item.label) : null,
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelNames: true
          });
          const labelNames = await onGetLabelNames(item);
          setState({
            labelNames,
            isLoadingLabelNames: undefined
          });
        },
        isLoading: state.isLoadingLabelNames,
        options: state.labelNames,
        onChange: change => {
          if (change.label) {
            var _item$op;

            onChange(Object.assign({}, item, {
              op: (_item$op = item.op) !== null && _item$op !== void 0 ? _item$op : defaultOp,
              label: change.label
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)((_item$op2 = item.op) !== null && _item$op2 !== void 0 ? _item$op2 : defaultOp),
        options: operators,
        width: "auto",
        onChange: change => {
          if (change.value != null) {
            onChange(Object.assign({}, item, {
              op: change.value
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
        inputId: "prometheus-dimensions-filter-item-value",
        width: "auto",
        value: getValue(item),
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelValues: true
          });
          const labelValues = await onGetLabelValues(item);
          setState(Object.assign({}, state, {
            labelValues,
            isLoadingLabelValues: undefined
          }));
        },
        isMulti: isMultiSelect(),
        isLoading: state.isLoadingLabelValues,
        options: getOptions(),
        onChange: change => {
          if (change.value) {
            var _item$op3;

            onChange(Object.assign({}, item, {
              value: change.value,
              op: (_item$op3 = item.op) !== null && _item$op3 !== void 0 ? _item$op3 : defaultOp
            }));
          } else {
            var _item$op4;

            const changes = change.map(change => {
              return change.label;
            }).join('|');
            onChange(Object.assign({}, item, {
              value: changes,
              op: (_item$op4 = item.op) !== null && _item$op4 !== void 0 ? _item$op4 : defaultOp
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.AccessoryButton, {
        "aria-label": "remove",
        icon: "times",
        variant: "secondary",
        onClick: onDelete
      })]
    })
  });
}
const operators = [{
  label: '=~',
  value: '=~'
}, {
  label: '=',
  value: '='
}, {
  label: '!=',
  value: '!='
}, {
  label: '!~',
  value: '!~'
}];

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilters": () => (/* binding */ LabelFilters)
/* harmony export */ });
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function LabelFilters({
  labelsFilters,
  onChange,
  onGetLabelNames,
  onGetLabelValues
}) {
  const defaultOp = '=';
  const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([{
    op: defaultOp
  }]);
  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {
    if (labelsFilters.length > 0) {
      setItems(labelsFilters);
    } else {
      setItems([{
        op: defaultOp
      }]);
    }
  }, [labelsFilters]);

  const onLabelsChange = newItems => {
    setItems(newItems); // Extract full label filters with both label & value

    const newLabels = newItems.filter(x => x.label != null && x.value != null);

    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_1__.isEqual)(newLabels, labelsFilters)) {
      onChange(newLabels);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_0__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_0__.EditorField, {
      label: "Labels",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_0__.EditorList, {
        items: items,
        onChange: onLabelsChange,
        renderItem: (item, onChangeItem, onDelete) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__.LabelFilterItem, {
          item: item,
          defaultOp: defaultOp,
          onChange: onChangeItem,
          onDelete: onDelete,
          onGetLabelNames: onGetLabelNames,
          onGetLabelValues: onGetLabelValues
        })
      })
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAndPromQueryModellerBase": () => (/* binding */ LokiAndPromQueryModellerBase)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class LokiAndPromQueryModellerBase {
  constructor(getOperations) {
    _defineProperty(this, "operationsRegisty", void 0);

    _defineProperty(this, "categories", []);

    this.operationsRegisty = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(getOperations);
  }

  setOperationCategories(categories) {
    this.categories = categories;
  }

  getOperationsForCategory(category) {
    return this.operationsRegisty.list().filter(op => op.category === category && !op.hideFromList);
  }

  getAlternativeOperations(key) {
    return this.operationsRegisty.list().filter(op => op.alternativesKey === key);
  }

  getCategories() {
    return this.categories;
  }

  getOperationDef(id) {
    return this.operationsRegisty.getIfExists(id);
  }

  renderOperations(queryString, operations) {
    for (const operation of operations) {
      const def = this.operationsRegisty.getIfExists(operation.id);

      if (!def) {
        throw new Error(`Could not find operation ${operation.id} in the registry`);
      }

      queryString = def.renderer(operation, def, queryString);
    }

    return queryString;
  }

  renderBinaryQueries(queryString, binaryQueries) {
    if (binaryQueries) {
      for (const binQuery of binaryQueries) {
        queryString = `${this.renderBinaryQuery(queryString, binQuery)}`;
      }
    }

    return queryString;
  }

  renderBinaryQuery(leftOperand, binaryQuery) {
    let result = leftOperand + ` ${binaryQuery.operator} `;

    if (binaryQuery.vectorMatches) {
      result += `${binaryQuery.vectorMatchesType}(${binaryQuery.vectorMatches}) `;
    }

    return result + this.renderQuery(binaryQuery.query, true);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '';
    }

    let expr = '{';

    for (const filter of labels) {
      if (expr !== '{') {
        expr += ', ';
      }

      expr += `${filter.label}${filter.op}"${filter.value}"`;
    }

    return expr + `}`;
  }

  renderQuery(query, nested) {
    var _query$metric, _query$binaryQueries, _query$binaryQueries2;

    let queryString = `${(_query$metric = query.metric) !== null && _query$metric !== void 0 ? _query$metric : ''}${this.renderLabels(query.labels)}`;
    queryString = this.renderOperations(queryString, query.operations);

    if (!nested && this.hasBinaryOp(query) && Boolean((_query$binaryQueries = query.binaryQueries) === null || _query$binaryQueries === void 0 ? void 0 : _query$binaryQueries.length)) {
      queryString = `(${queryString})`;
    }

    queryString = this.renderBinaryQueries(queryString, query.binaryQueries);

    if (nested && (this.hasBinaryOp(query) || Boolean((_query$binaryQueries2 = query.binaryQueries) === null || _query$binaryQueries2 === void 0 ? void 0 : _query$binaryQueries2.length))) {
      queryString = `(${queryString})`;
    }

    return queryString;
  }

  hasBinaryOp(query) {
    return query.operations.find(op => {
      const def = this.getOperationDef(op.id);
      return (def === null || def === void 0 ? void 0 : def.category) === _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps;
    }) !== undefined;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationEditor": () => (/* binding */ OperationEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _OperationHeader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx");
/* harmony import */ var _OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










function OperationEditor({
  operation,
  index,
  onRemove,
  onChange,
  onRunQuery,
  queryModeller,
  query,
  datasource,
  highlight
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const def = queryModeller.getOperationDef(operation.id);
  const shouldHighlight = useHighlight(highlight);

  if (!def) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("span", {
      children: ["Operation ", operation.id, " not found"]
    });
  }

  const onParamValueChanged = (paramIdx, value) => {
    const update = Object.assign({}, operation, {
      params: [...operation.params]
    });
    update.params[paramIdx] = value;
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const onAddRestParam = () => {
    const update = Object.assign({}, operation, {
      params: [...operation.params, '']
    });
    callParamChangedThenOnChange(def, update, index, operation.params.length, onChange);
  };

  const onRemoveRestParam = paramIdx => {
    const update = Object.assign({}, operation, {
      params: [...operation.params.slice(0, paramIdx), ...operation.params.slice(paramIdx + 1)]
    });
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const operationElements = [];

  for (let paramIndex = 0; paramIndex < operation.params.length; paramIndex++) {
    const paramDef = def.params[Math.min(def.params.length - 1, paramIndex)];
    const Editor = (0,_OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__.getOperationParamEditor)(paramDef);
    operationElements.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
      className: styles.paramRow,
      children: [!paramDef.hideName && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.paramName,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("label", {
          htmlFor: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_6__.getOperationParamId)(index, paramIndex),
          children: paramDef.name
        }), paramDef.description && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tooltip, {
          placement: "top",
          content: paramDef.description,
          theme: "info",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, {
            name: "info-circle",
            size: "sm",
            className: styles.infoIcon
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.paramValue,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
          gap: 0.5,
          direction: "row",
          alignItems: "center",
          wrap: false,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Editor, {
            index: paramIndex,
            paramDef: paramDef,
            value: operation.params[paramIndex],
            operation: operation,
            operationIndex: index,
            onChange: onParamValueChanged,
            onRunQuery: onRunQuery,
            query: query,
            datasource: datasource
          }), paramDef.restParam && (operation.params.length > def.params.length || paramDef.optional) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "data-testid": `operations.${index}.remove-rest-param`,
            size: "sm",
            fill: "text",
            icon: "times",
            variant: "secondary",
            title: `Remove ${paramDef.name}`,
            onClick: () => onRemoveRestParam(paramIndex)
          })]
        })
      })]
    }, `${paramIndex}-1`));
  } // Handle adding button for rest params


  let restParam;

  if (def.params.length > 0) {
    const lastParamDef = def.params[def.params.length - 1];

    if (lastParamDef.restParam) {
      restParam = renderAddRestParamButton(lastParamDef, onAddRestParam, index, operation.params.length, styles);
    }
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__.Draggable, {
    draggableId: `operation-${index}`,
    index: index,
    children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", Object.assign({
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.card, shouldHighlight && styles.cardHighlight),
      ref: provided.innerRef
    }, provided.draggableProps, {
      "data-testid": `operations.${index}.wrapper`,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_OperationHeader__WEBPACK_IMPORTED_MODULE_4__.OperationHeader, {
        operation: operation,
        dragHandleProps: provided.dragHandleProps,
        def: def,
        index: index,
        onChange: onChange,
        onRemove: onRemove,
        queryModeller: queryModeller
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.body,
        children: operationElements
      }), restParam, index < query.operations.length - 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.arrow,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowLine
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowArrow
        })]
      })]
    }))
  });
}
/**
 * When highlight is switched on makes sure it is switched of right away, so we just flash the highlight and then fade
 * out.
 * @param highlight
 */

function useHighlight(highlight) {
  const [keepHighlight, setKeepHighlight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {
    let t;

    if (highlight) {
      t = setTimeout(() => {
        setKeepHighlight(false);
      }, 1);
    } else {
      setKeepHighlight(true);
    }

    return () => clearTimeout(t);
  }, [highlight]);
  return keepHighlight && highlight;
}

function renderAddRestParamButton(paramDef, onAddRestParam, operationIndex, paramIndex, styles) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
    className: styles.restParam,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
      size: "sm",
      icon: "plus",
      title: `Add ${paramDef.name}`,
      variant: "secondary",
      onClick: onAddRestParam,
      "data-testid": `operations.${operationIndex}.add-rest-param`,
      children: paramDef.name
    })
  }, `${paramIndex}-2`);
}

function callParamChangedThenOnChange(def, operation, operationIndex, paramIndex, onChange) {
  if (def.paramChangedHandler) {
    onChange(operationIndex, def.paramChangedHandler(paramIndex, operation, def));
  } else {
    onChange(operationIndex, operation);
  }
}

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.medium}`,
      display: 'flex',
      flexDirection: 'column',
      cursor: 'grab',
      borderRadius: theme.shape.borderRadius(1),
      marginBottom: theme.spacing(1),
      position: 'relative',
      transition: 'all 1s ease-in 0s'
    }),
    cardHighlight: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      boxShadow: `0px 0px 4px 0px ${theme.colors.primary.border}`,
      border: `1px solid ${theme.colors.primary.border}`
    }),
    infoIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(0.5),
      color: theme.colors.text.secondary,
      ':hover': {
        color: theme.colors.text.primary
      }
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      margin: theme.spacing(1, 1, 0.5, 1),
      display: 'table'
    }),
    paramRow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramRow',
      display: 'table-row',
      verticalAlign: 'middle'
    }),
    paramName: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'table-cell',
      padding: theme.spacing(0, 1, 0, 0),
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      verticalAlign: 'middle',
      height: '32px'
    }),
    paramValue: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramValue',
      display: 'table-cell',
      verticalAlign: 'middle'
    }),
    restParam: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(0, 1, 1, 1)
    }),
    arrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      position: 'absolute',
      top: '0',
      right: '-18px',
      display: 'flex'
    }),
    arrowLine: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      height: '2px',
      width: '8px',
      backgroundColor: theme.colors.border.strong,
      position: 'relative',
      top: '14px'
    }),
    arrowArrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      width: 0,
      height: 0,
      borderTop: `5px solid transparent`,
      borderBottom: `5px solid transparent`,
      borderLeft: `7px solid ${theme.colors.border.strong}`,
      position: 'relative',
      top: '10px'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationExplainedBox": () => (/* binding */ OperationExplainedBox)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function OperationExplainedBox({
  title,
  stepNumber,
  markdown,
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: styles.box,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.stepNumber,
      children: stepNumber
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.boxInner,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.header,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: title
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.body,
        children: [markdown && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          dangerouslySetInnerHTML: {
            __html: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.renderMarkdown)(markdown)
          }
        }), children]
      })]
    })]
  });
}

const getStyles = theme => {
  return {
    box: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.secondary,
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      position: 'relative',
      marginBottom: theme.spacing(0.5)
    }),
    boxInner: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(4)
    }),
    stepNumber: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontWeight: theme.typography.fontWeightMedium,
      background: theme.colors.secondary.main,
      width: '20px',
      height: '20px',
      borderRadius: '50%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'absolute',
      top: '10px',
      left: '11px',
      fontSize: theme.typography.bodySmall.fontSize
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingBottom: theme.spacing(0.5),
      display: 'flex',
      alignItems: 'center',
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      'p:last-child': {
        margin: 0
      },
      a: {
        color: theme.colors.text.link,
        textDecoration: 'underline'
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationHeader": () => (/* binding */ OperationHeader)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;









const OperationHeader = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3__.memo(({
  operation,
  def,
  index,
  onChange,
  onRemove,
  queryModeller,
  dragHandleProps
}) => {
  var _def$name;

  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({});

  const onToggleSwitcher = () => {
    if (state.isOpen) {
      setState(Object.assign({}, state, {
        isOpen: false
      }));
    } else {
      const alternatives = queryModeller.getAlternativeOperations(def.alternativesKey).map(alt => ({
        label: alt.name,
        value: alt
      }));
      setState({
        isOpen: true,
        alternatives
      });
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: styles.header,
    children: [!state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", Object.assign({}, dragHandleProps, {
        children: (_def$name = def.name) !== null && _def$name !== void 0 ? _def$name : def.id
      })), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: `${styles.operationHeaderButtons} operation-header-show-on-hover`,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          icon: "angle-down",
          size: "sm",
          onClick: onToggleSwitcher,
          fill: "text",
          variant: "secondary",
          title: "Click to view alternative operations"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__.OperationInfoButton, {
          def: def,
          operation: operation
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          icon: "times",
          size: "sm",
          onClick: () => onRemove(index),
          fill: "text",
          variant: "secondary",
          title: "Remove operation"
        })]
      })]
    }), state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.selectWrapper,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
        autoFocus: true,
        openMenuOnFocus: true,
        placeholder: "Replace with",
        options: state.alternatives,
        isOpen: true,
        onCloseMenu: onToggleSwitcher,
        onChange: value => {
          if (value.value) {
            // Operation should exist if it is selectable
            const newDef = queryModeller.getOperationDef(value.value.id);
            let changedOp = Object.assign({}, operation, {
              id: value.value.id
            });
            onChange(index, def.changeTypeHandler ? def.changeTypeHandler(changedOp, newDef) : changedOp);
          }
        }
      })
    })]
  });
});
OperationHeader.displayName = 'OperationHeader';

const getStyles = theme => {
  return {
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      borderBottom: `1px solid ${theme.colors.border.medium}`,
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      display: 'flex',
      alignItems: 'center',
      '&:hover .operation-header-show-on-hover': (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
        opacity: 1
      })
    }),
    operationHeaderButtons: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      transition: theme.transitions.create(['opacity'], {
        duration: theme.transitions.duration.short
      })
    }),
    selectWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingRight: theme.spacing(2)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationInfoButton": () => (/* binding */ OperationInfoButton)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-popper-tooltip-virtual-d9d7047333/0/cache/react-popper-tooltip-npm-4.3.1-91318ee546-82ae84c3b7.zip/node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;










const OperationInfoButton = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.memo(({
  def,
  operation
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const [show, setShow] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(false);
  const {
    getTooltipProps,
    setTooltipRef,
    setTriggerRef,
    visible
  } = (0,react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__.usePopperTooltip)({
    placement: 'top',
    visible: show,
    offset: [0, 16],
    onVisibleChange: setShow,
    interactive: true,
    trigger: ['click']
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
      title: "Click to show description",
      ref: setTriggerRef,
      icon: "info-circle",
      size: "sm",
      variant: "secondary",
      fill: "text"
    }), visible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Portal, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
        ref: setTooltipRef
      }, getTooltipProps(), {
        className: styles.docBox,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: styles.docBoxHeader,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
            children: def.renderer(operation, def, '<expr>')
          }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
            grow: 1
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            icon: "times",
            onClick: () => setShow(false),
            fill: "text",
            variant: "secondary",
            title: "Remove operation"
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.docBoxBody,
          dangerouslySetInnerHTML: {
            __html: getOperationDocs(def, operation)
          }
        })]
      }))
    })]
  });
});
OperationInfoButton.displayName = 'OperationDocs';

const getStyles = theme => {
  return {
    docBox: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      overflow: 'hidden',
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.strong}`,
      boxShadow: theme.shadows.z3,
      maxWidth: '600px',
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      zIndex: theme.zIndex.tooltip
    }),
    docBoxHeader: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.h5.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace,
      paddingBottom: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    docBoxBody: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      // The markdown paragraph has a marginBottom this removes it
      marginBottom: theme.spacing(-1),
      color: theme.colors.text.secondary
    }),
    signature: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.bodySmall.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    dropdown: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      color: theme.colors.text.secondary
    })
  };
};

function getOperationDocs(def, op) {
  var _def$documentation;

  return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.renderMarkdown)(def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs');
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationList": () => (/* binding */ OperationList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useMountedState.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _OperationEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









function OperationList({
  query,
  datasource,
  queryModeller,
  onChange,
  onRunQuery
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    operations
  } = query;
  const opsToHighlight = useOperationsHighlight(operations);
  const [cascaderOpen, setCascaderOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);

  const onOperationChange = (index, update) => {
    const updatedList = [...operations];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...operations.slice(0, index), ...operations.slice(index + 1)];
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const addOptions = queryModeller.getCategories().map(category => {
    return {
      value: category,
      label: category,
      items: queryModeller.getOperationsForCategory(category).map(operation => ({
        value: operation.id,
        label: operation.name,
        isLeaf: true
      }))
    };
  });

  const onAddOperation = value => {
    const operationDef = queryModeller.getOperationDef(value);

    if (!operationDef) {
      return;
    }

    onChange(operationDef.addOperationHandler(operationDef, query, queryModeller));
    setCascaderOpen(false);
  };

  const onDragEnd = result => {
    if (!result.destination) {
      return;
    }

    const updatedList = [...operations];
    const element = updatedList[result.source.index];
    updatedList.splice(result.source.index, 1);
    updatedList.splice(result.destination.index, 0, element);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onCascaderBlur = () => {
    setCascaderOpen(false);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 1,
    direction: "column",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
      gap: 1,
      children: [operations.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
        onDragEnd: onDragEnd,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
          droppableId: "sortable-field-mappings",
          direction: "horizontal",
          children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
            className: styles.operationList,
            ref: provided.innerRef
          }, provided.droppableProps, {
            children: [operations.map((op, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationEditor__WEBPACK_IMPORTED_MODULE_4__.OperationEditor, {
              queryModeller: queryModeller,
              index: index,
              operation: op,
              query: query,
              datasource: datasource,
              onChange: onOperationChange,
              onRemove: onRemove,
              onRunQuery: onRunQuery,
              highlight: opsToHighlight[index]
            }, op.id + index)), provided.placeholder]
          }))
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: styles.addButton,
        children: cascaderOpen ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Cascader, {
          options: addOptions,
          onSelect: onAddOperation,
          onBlur: onCascaderBlur,
          autoFocus: true,
          alwaysOpen: true,
          hideActiveLevelLabel: true,
          placeholder: 'Search'
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          icon: 'plus',
          variant: 'secondary',
          onClick: () => setCascaderOpen(true),
          title: 'Add operation',
          children: "Operations"
        })
      })]
    })
  });
}
/**
 * Returns indexes of operations that should be highlighted. We check the diff of operations added but at the same time
 * we want to highlight operations only after the initial render, so we check for mounted state and calculate the diff
 * only after.
 * @param operations
 */

function useOperationsHighlight(operations) {
  const isMounted = (0,react_use__WEBPACK_IMPORTED_MODULE_7__["default"])();
  const prevOperations = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])(operations);

  if (!isMounted()) {
    return operations.map(() => false);
  }

  if (!prevOperations) {
    return operations.map(() => true);
  }

  let newOps = [];

  if (prevOperations.length - 1 === operations.length && operations.every(op => prevOperations.includes(op))) {
    // In case we remove one op and does not change any ops then don't highlight anything.
    return operations.map(() => false);
  }

  if (prevOperations.length + 1 === operations.length && prevOperations.every(op => operations.includes(op))) {
    // If we add a single op just find it and highlight just that.
    const newOp = operations.find(op => !prevOperations.includes(op));
    newOps = operations.map(op => {
      return op === newOp;
    });
  } else {
    // Default diff of all ops.
    newOps = operations.map((op, index) => {
      var _prevOperations$index;

      return !isSameOp(op.id, (_prevOperations$index = prevOperations[index]) === null || _prevOperations$index === void 0 ? void 0 : _prevOperations$index.id);
    });
  }

  return newOps;
}

function isSameOp(op1, op2) {
  return op1 === op2 || `__${op1}_by` === op2 || op1 === `__${op2}_by`;
}

const getStyles = theme => {
  return {
    heading: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'heading',
      fontSize: 12,
      fontWeight: theme.typography.fontWeightMedium,
      marginBottom: 0
    }),
    operationList: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'operationList',
      display: 'flex',
      flexWrap: 'wrap',
      gap: theme.spacing(2)
    }),
    addButton: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'addButton',
      width: 126,
      paddingBottom: theme.spacing(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationListExplained": () => (/* binding */ OperationListExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function OperationListExplained({
  query,
  queryModeller,
  stepNumber
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
    children: query.operations.map((op, index) => {
      var _def$documentation;

      const def = queryModeller.getOperationDef(op.id);

      if (!def) {
        return `Operation ${op.id} not found`;
      }

      const title = def.renderer(op, def, '<expr>');
      const body = def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs';
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__.OperationExplainedBox, {
        stepNumber: index + stepNumber,
        title: title,
        markdown: body
      }, index);
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOperationParamEditor": () => (/* binding */ getOperationParamEditor)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function getOperationParamEditor(paramDef) {
  if (paramDef.editor) {
    return paramDef.editor;
  }

  if (paramDef.options) {
    return SelectInputParamEditor;
  }

  switch (paramDef.type) {
    case 'boolean':
      return BoolInputParamEditor;

    case 'number':
    case 'string':
    default:
      return SimpleInputParamEditor;
  }
}

function SimpleInputParamEditor(props) {
  var _props$value;

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(props.operationIndex, props.index),
    defaultValue: (_props$value = props.value) === null || _props$value === void 0 ? void 0 : _props$value.toString(),
    minWidth: props.paramDef.minWidth,
    placeholder: props.paramDef.placeholder,
    title: props.paramDef.description,
    onCommitChange: evt => {
      props.onChange(props.index, evt.currentTarget.value);
    }
  });
}

function BoolInputParamEditor(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Checkbox, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(props.operationIndex, props.index),
    value: props.value,
    onChange: evt => props.onChange(props.index, evt.currentTarget.checked)
  });
}

function SelectInputParamEditor({
  paramDef,
  value,
  index,
  operationIndex,
  onChange
}) {
  var _selectOptions$, _selectOptions$find;

  let selectOptions = paramDef.options;

  if (!((_selectOptions$ = selectOptions[0]) !== null && _selectOptions$ !== void 0 && _selectOptions$.label)) {
    selectOptions = paramDef.options.map(option => ({
      label: option.toString(),
      value: option
    }));
  }

  let valueOption = (_selectOptions$find = selectOptions.find(x => x.value === value)) !== null && _selectOptions$find !== void 0 ? _selectOptions$find : (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.toOption)(value);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(operationIndex, index),
    menuShouldPortal: true,
    value: valueOption,
    options: selectOptions,
    placeholder: paramDef.placeholder,
    allowCustomValue: true,
    onChange: value => onChange(index, value.value)
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationsEditorRow": () => (/* binding */ OperationsEditorRow)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function OperationsEditorRow({
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: styles.root,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
      gap: 1,
      children: children
    })
  });
}

const getStyles = theme => {
  return {
    root: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(1, 1, 0, 1),
      backgroundColor: theme.colors.background.secondary,
      borderRadius: theme.shape.borderRadius(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorModeToggle": () => (/* binding */ QueryEditorModeToggle)
/* harmony export */ });
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const editorModes = [{
  label: 'Explain',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Explain
}, {
  label: 'Builder',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder,
  component: () => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.Tag, {
    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.css)({
      fontSize: 10,
      padding: '1px 5px',
      verticalAlign: 'text-bottom'
    }),
    name: 'Beta',
    colorIndex: 1
  })
}, {
  label: 'Code',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code
}];
function QueryEditorModeToggle({
  mode,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": 'QueryEditorModeToggle',
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.RadioButtonGroup, {
      options: editorModes,
      size: "sm",
      value: mode,
      onChange: onChange
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryOptionGroup": () => (/* binding */ QueryOptionGroup)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useToggle.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryOptionGroup({
  title,
  children,
  collapsedInfo
}) {
  const [isOpen, toggleOpen] = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(false);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.header,
      onClick: toggleOpen,
      title: "Click to edit options",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.toggle,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
          name: isOpen ? 'angle-down' : 'angle-right'
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h6", {
        className: styles.title,
        children: title
      }), !isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.description,
        children: collapsedInfo.map((x, i) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: x
        }, i))
      })]
    }), isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.body,
      children: children
    })]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      display: 'flex',
      cursor: 'pointer',
      alignItems: 'baseline',
      color: theme.colors.text.primary,
      '&:hover': {
        background: theme.colors.emphasize(theme.colors.background.primary, 0.03)
      }
    }),
    title: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      flexGrow: 1,
      overflow: 'hidden',
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      margin: 0
    }),
    description: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      paddingLeft: theme.spacing(2),
      gap: theme.spacing(2),
      display: 'flex'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      display: 'flex',
      paddingTop: theme.spacing(2),
      gap: theme.spacing(2),
      flexWrap: 'wrap'
    }),
    toggle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      color: theme.colors.text.secondary,
      marginRight: `${theme.spacing(1)}`
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAggregationOperation": () => (/* binding */ createAggregationOperation),
/* harmony export */   "createAggregationOperationWithParam": () => (/* binding */ createAggregationOperationWithParam),
/* harmony export */   "defaultAddOperationHandler": () => (/* binding */ defaultAddOperationHandler),
/* harmony export */   "functionRendererLeft": () => (/* binding */ functionRendererLeft),
/* harmony export */   "functionRendererRight": () => (/* binding */ functionRendererRight),
/* harmony export */   "getOperationParamId": () => (/* binding */ getOperationParamId),
/* harmony export */   "getPromAndLokiOperationDisplayName": () => (/* binding */ getPromAndLokiOperationDisplayName),
/* harmony export */   "getRangeVectorParamDef": () => (/* binding */ getRangeVectorParamDef),
/* harmony export */   "rangeRendererLeftWithParams": () => (/* binding */ rangeRendererLeftWithParams),
/* harmony export */   "rangeRendererRightWithParams": () => (/* binding */ rangeRendererRightWithParams)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/pluralize-npm-8.0.0-f5f044ed52-08931d4a6a.zip/node_modules/pluralize/pluralize.js");
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pluralize__WEBPACK_IMPORTED_MODULE_3__);




function functionRendererLeft(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.push(innerExpr);
  }

  return str + params.join(', ') + ')';
}
function functionRendererRight(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.unshift(innerExpr);
  }

  return str + params.join(', ') + ')';
}

function rangeRendererWithParams(model, def, innerExpr, renderLeft) {
  var _, _model$params;

  if (def.params.length < 2) {
    throw `Cannot render a function with params of length [${def.params.length}]`;
  }

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m'; // Next frame the remaining parameters, but get rid of the first one because it's used to move the
  // instant vector into a range vector.

  const params = renderParams(Object.assign({}, model, {
    params: model.params.slice(1)
  }), Object.assign({}, def, {
    params: def.params.slice(1),
    defaultParams: def.defaultParams.slice(1)
  }), innerExpr);
  const str = model.id + '('; // Depending on the renderLeft variable, render parameters to the left or right
  // renderLeft === true (renderLeft) => (param1, param2, rangeVector[...])
  // renderLeft === false (renderRight) => (rangeVector[...], param1, param2)

  if (innerExpr) {
    renderLeft ? params.push(`${innerExpr}[${rangeVector}]`) : params.unshift(`${innerExpr}[${rangeVector}]`);
  } // stick everything together


  return str + params.join(', ') + ')';
}

function rangeRendererRightWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, false);
}
function rangeRendererLeftWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, true);
}

function renderParams(model, def, innerExpr) {
  var _model$params2;

  return ((_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : []).map((value, index) => {
    const paramDef = def.params[index];

    if (paramDef.type === 'string') {
      return '"' + value + '"';
    }

    return value;
  });
}

function defaultAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}
function getPromAndLokiOperationDisplayName(funcName) {
  return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(funcName.replace(/_/g, ' '));
}
function getOperationParamId(operationIndex, paramIndex) {
  return `operations.${operationIndex}.param.${paramIndex}`;
}
function getRangeVectorParamDef(withRateInterval = false) {
  const param = {
    name: 'Range',
    type: 'string',
    options: [{
      label: '$__interval',
      value: '$__interval' // tooltip: 'Dynamic interval based on max data points, scrape and min interval',

    }, {
      label: '1m',
      value: '1m'
    }, {
      label: '5m',
      value: '5m'
    }, {
      label: '10m',
      value: '10m'
    }, {
      label: '1h',
      value: '1h'
    }, {
      label: '24h',
      value: '24h'
    }]
  };

  if (withRateInterval) {
    param.options.unshift({
      label: '$__rate_interval',
      value: '$__rate_interval' // tooltip: 'Always above 4x scrape interval',

    });
  }

  return param;
}
/**
 * This function is shared between Prometheus and Loki variants
 */

function createAggregationOperation(name, overrides = {}) {
  const operations = [Object.assign({
    id: name,
    name: getPromAndLokiOperationDisplayName(name),
    params: [{
      name: 'By label',
      type: 'string',
      restParam: true,
      optional: true
    }],
    defaultParams: [],
    alternativesKey: 'plain aggregations',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Aggregations,
    renderer: functionRendererLeft,
    paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),
    explainHandler: getAggregationExplainer(name, ''),
    addOperationHandler: defaultAddOperationHandler
  }, overrides), Object.assign({
    id: `__${name}_by`,
    name: `${getPromAndLokiOperationDisplayName(name)} by`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationByRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'by'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides), Object.assign({
    id: `__${name}_without`,
    name: `${getPromAndLokiOperationDisplayName(name)} without`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationWithoutRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'without'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides)];
  return operations;
}
function createAggregationOperationWithParam(name, paramsDef, overrides = {}) {
  const operations = createAggregationOperation(name, overrides);
  operations[0].params.unshift(...paramsDef.params);
  operations[1].params.unshift(...paramsDef.params);
  operations[2].params.unshift(...paramsDef.params);
  operations[0].defaultParams = paramsDef.defaultParams;
  operations[1].defaultParams = [...paramsDef.defaultParams, ''];
  operations[2].defaultParams = [...paramsDef.defaultParams, ''];
  operations[1].renderer = getAggregationByRendererWithParameter(name);
  operations[2].renderer = getAggregationByRendererWithParameter(name);
  return operations;
}

function getAggregationByRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;
  };
}

function getAggregationWithoutRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;
  };
}
/**
 * Very simple poc implementation, needs to be modified to support all aggregation operators
 */


function getAggregationExplainer(aggregationName, mode) {
  return function aggregationExplainer(model) {
    const labels = model.params.map(label => `\`${label}\``).join(' and ');
    const labelWord = pluralize__WEBPACK_IMPORTED_MODULE_3___default()('label', model.params.length);

    switch (mode) {
      case 'by':
        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;

      case 'without':
        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;

      default:
        return `Calculates ${aggregationName} over the dimensions.`;
    }
  };
}

function getAggregationByRendererWithParameter(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    function mapType(p) {
      if (typeof p === 'string') {
        return `\"${p}\"`;
      }

      return p;
    }

    const params = model.params.slice(0, -1);
    const restParams = model.params.slice(1);
    return `${aggregation} by(${restParams.join(', ')}) (${params.map(mapType).join(', ')}, ${innerExpr})`;
  };
}
/**
 * This function will transform operations without labels to their plan aggregation operation
 */


function getLastLabelRemovedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // If definition has more params then is defined there are no optional rest params anymore.
    // We then transform this operation into a different one
    if (op.params.length < def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

function getOnLabelAddedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the
    // case of just simple aggregation without label. When user adds the label it now has the same number of params
    // as it's definition, and now we can change it to it's `_by` variant.
    if (op.params.length === def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorName": () => (/* binding */ ErrorName),
/* harmony export */   "getAllByType": () => (/* binding */ getAllByType),
/* harmony export */   "getLeftMostChild": () => (/* binding */ getLeftMostChild),
/* harmony export */   "getString": () => (/* binding */ getString),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "makeBinOp": () => (/* binding */ makeBinOp),
/* harmony export */   "makeError": () => (/* binding */ makeError),
/* harmony export */   "replaceVariables": () => (/* binding */ replaceVariables)
/* harmony export */ });
// This is used for error type for some reason
const ErrorName = 'âš ';
function getLeftMostChild(cur) {
  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;
}
function makeError(expr, node) {
  var _node$parent;

  return {
    text: getString(expr, node),
    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact
    //  placement of the error for the user. We need some translation table to positions before the variable
    //  replace.
    from: node.from,
    to: node.to,
    parentType: (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name
  };
} // Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service

/*
 * This regex matches 3 types of variable reference with an optional format specifier
 * \$(\w+)                          $var1
 * \[\[([\s\S]+?)(?::(\w+))?\]\]    [[var2]] or [[var2:fmt2]]
 * \${(\w+)(?::(\w+))?}             ${var3} or ${var3:fmt3}
 */

const variableRegex = /\$(\w+)|\[\[([\s\S]+?)(?::(\w+))?\]\]|\${(\w+)(?:\.([^:^\}]+))?(?::([^\}]+))?}/g;
/**
 * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at
 * the same time we can get the variable and it's format back from it.
 * @param expr
 */

function replaceVariables(expr) {
  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {
    const fmt = fmt2 || fmt3;
    let variable = var1;
    let varType = '0';

    if (var2) {
      variable = var2;
      varType = '1';
    }

    if (var3) {
      variable = var3;
      varType = '2';
    }

    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');
  });
}
const varTypeFunc = [(v, f) => `\$${v}`, (v, f) => `[[${v}${f ? `:${f}` : ''}]]`, (v, f) => `\$\{${v}${f ? `:${f}` : ''}\}`];
/**
 * Get back the text with variables in their original format.
 * @param expr
 */

function returnVariables(expr) {
  return expr.replace(/__V_(\d)__(.+?)__V__(?:__F__(\w+)__F__)?/g, (match, type, v, f) => {
    return varTypeFunc[parseInt(type, 10)](v, f);
  });
}
/**
 * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node
 * and then based on that get it from the expression.
 * @param expr
 * @param node
 */


function getString(expr, node) {
  if (!node) {
    return '';
  }

  return returnVariables(expr.substring(node.from, node.to));
}
/**
 * Create simple scalar binary op object.
 * @param opDef - definition of the op to be created
 * @param expr
 * @param numberNode - the node for the scalar
 * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.
 */

function makeBinOp(opDef, expr, numberNode, hasBool) {
  const params = [parseFloat(getString(expr, numberNode))];

  if (opDef.comparison) {
    params.push(hasBool);
  }

  return {
    id: opDef.id,
    params
  };
}
/**
 * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be
 * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would
 * not be safe is it would also find arguments of nested functions.
 * @param expr
 * @param cur
 * @param type
 */

function getAllByType(expr, cur, type) {
  if (cur.name === type) {
    return [getString(expr, cur)];
  }

  const values = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    values.push(...getAllByType(expr, child, type));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  return values;
} // Debugging function for convenience. Gives you nice output similar to linux tree util.
// @ts-ignore

function log(expr, cur) {
  if (!cur) {
    console.log('<empty>');
    return;
  }

  const json = toJson(expr, cur);
  const text = jsonToText(json);

  if (!text) {
    console.log('<empty>');
    return;
  }

  console.log(text);
}

function toJson(expr, cur) {
  const treeJson = {};
  const name = nodeToString(expr, cur);
  const children = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    children.push(toJson(expr, child));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  treeJson.name = name;
  treeJson.children = children;
  return treeJson;
}

function jsonToText(node, context = {
  lastChild: true,
  indent: ''
}) {
  const name = node.name;
  const {
    lastChild,
    indent
  } = context;
  const newIndent = indent !== '' ? indent + (lastChild ? 'â””â”€' : 'â”œâ”€') : '';
  let text = newIndent + name;
  const children = node.children;
  children.forEach((child, index) => {
    const isLastChild = index === children.length - 1;
    text += '\n' + jsonToText(child, {
      lastChild: isLastChild,
      indent: indent + (lastChild ? '  ' : 'â”‚ ')
    });
  });
  return text;
}

function nodeToString(expr, node) {
  return node.name + ': ' + getString(expr, node);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorMode": () => (/* binding */ QueryEditorMode)
/* harmony export */ });
/**
 * Shared types that can be reused by Loki and other data sources
 */
let QueryEditorMode;

(function (QueryEditorMode) {
  QueryEditorMode["Code"] = "code";
  QueryEditorMode["Builder"] = "builder";
  QueryEditorMode["Explain"] = "explain";
})(QueryEditorMode || (QueryEditorMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromOperationId": () => (/* binding */ PromOperationId),
/* harmony export */   "PromVisualQueryOperationCategory": () => (/* binding */ PromVisualQueryOperationCategory)
/* harmony export */ });
/**
 * Visual query model
 */
let PromVisualQueryOperationCategory;

(function (PromVisualQueryOperationCategory) {
  PromVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  PromVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  PromVisualQueryOperationCategory["Functions"] = "Functions";
  PromVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
  PromVisualQueryOperationCategory["Trigonometric"] = "Trigonometric";
  PromVisualQueryOperationCategory["Time"] = "Time Functions";
})(PromVisualQueryOperationCategory || (PromVisualQueryOperationCategory = {}));

let PromOperationId;

(function (PromOperationId) {
  PromOperationId["Abs"] = "abs";
  PromOperationId["Absent"] = "absent";
  PromOperationId["AbsentOverTime"] = "absent_over_time";
  PromOperationId["Acos"] = "acos";
  PromOperationId["Acosh"] = "acosh";
  PromOperationId["Asin"] = "asin";
  PromOperationId["Asinh"] = "asinh";
  PromOperationId["Atan"] = "atan";
  PromOperationId["Atanh"] = "atanh";
  PromOperationId["Avg"] = "avg";
  PromOperationId["AvgOverTime"] = "avg_over_time";
  PromOperationId["BottomK"] = "bottomk";
  PromOperationId["Ceil"] = "ceil";
  PromOperationId["Changes"] = "changes";
  PromOperationId["Clamp"] = "clamp";
  PromOperationId["ClampMax"] = "clamp_max";
  PromOperationId["ClampMin"] = "clamp_min";
  PromOperationId["Cos"] = "cos";
  PromOperationId["Cosh"] = "cosh";
  PromOperationId["Count"] = "count";
  PromOperationId["CountOverTime"] = "count_over_time";
  PromOperationId["CountScalar"] = "count_scalar";
  PromOperationId["CountValues"] = "count_values";
  PromOperationId["DayOfMonth"] = "day_of_month";
  PromOperationId["DayOfWeek"] = "day_of_week";
  PromOperationId["DaysInMonth"] = "days_in_month";
  PromOperationId["Deg"] = "deg";
  PromOperationId["Delta"] = "delta";
  PromOperationId["Deriv"] = "deriv";
  PromOperationId["DropCommonLabels"] = "drop_common_labels";
  PromOperationId["Exp"] = "exp";
  PromOperationId["Floor"] = "floor";
  PromOperationId["Group"] = "group";
  PromOperationId["HistogramQuantile"] = "histogram_quantile";
  PromOperationId["HoltWinters"] = "holt_winters";
  PromOperationId["Hour"] = "hour";
  PromOperationId["Idelta"] = "idelta";
  PromOperationId["Increase"] = "increase";
  PromOperationId["Irate"] = "irate";
  PromOperationId["LabelJoin"] = "label_join";
  PromOperationId["LabelReplace"] = "label_replace";
  PromOperationId["Last"] = "last";
  PromOperationId["LastOverTime"] = "last_over_time";
  PromOperationId["Ln"] = "ln";
  PromOperationId["Log10"] = "log10";
  PromOperationId["Log2"] = "log2";
  PromOperationId["Max"] = "max";
  PromOperationId["MaxOverTime"] = "max_over_time";
  PromOperationId["Min"] = "min";
  PromOperationId["MinOverTime"] = "min_over_time";
  PromOperationId["Minute"] = "minute";
  PromOperationId["Month"] = "month";
  PromOperationId["Pi"] = "pi";
  PromOperationId["PredictLinear"] = "predict_linear";
  PromOperationId["Present"] = "present";
  PromOperationId["PresentOverTime"] = "present_over_time";
  PromOperationId["Quantile"] = "quantile";
  PromOperationId["QuantileOverTime"] = "quantile_over_time";
  PromOperationId["Rad"] = "rad";
  PromOperationId["Rate"] = "rate";
  PromOperationId["Resets"] = "resets";
  PromOperationId["Round"] = "round";
  PromOperationId["Scalar"] = "scalar";
  PromOperationId["Sgn"] = "sgn";
  PromOperationId["Sin"] = "sin";
  PromOperationId["Sinh"] = "sinh";
  PromOperationId["Sort"] = "sort";
  PromOperationId["SortDesc"] = "sort_desc";
  PromOperationId["Sqrt"] = "sqrt";
  PromOperationId["Stddev"] = "stddev";
  PromOperationId["StddevOverTime"] = "stddev_over_time";
  PromOperationId["Sum"] = "sum";
  PromOperationId["SumOverTime"] = "sum_over_time";
  PromOperationId["Tan"] = "tan";
  PromOperationId["Tanh"] = "tanh";
  PromOperationId["Time"] = "time";
  PromOperationId["Timestamp"] = "timestamp";
  PromOperationId["TopK"] = "topk";
  PromOperationId["Vector"] = "vector";
  PromOperationId["Year"] = "year";
  PromOperationId["Addition"] = "__addition";
  PromOperationId["Subtraction"] = "__subtraction";
  PromOperationId["MultiplyBy"] = "__multiply_by";
  PromOperationId["DivideBy"] = "__divide_by";
  PromOperationId["Modulo"] = "__modulo";
  PromOperationId["Exponent"] = "__exponent";
  PromOperationId["NestedQuery"] = "__nested_query";
  PromOperationId["EqualTo"] = "__equal_to";
  PromOperationId["NotEqualTo"] = "__not_equal_to";
  PromOperationId["GreaterThan"] = "__greater_than";
  PromOperationId["LessThan"] = "__less_than";
  PromOperationId["GreaterOrEqual"] = "__greater_or_equal";
  PromOperationId["LessOrEqual"] = "__less_or_equal";
})(PromOperationId || (PromOperationId = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/result_transformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOriginalMetricName": () => (/* binding */ getOriginalMetricName),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformDFToTable": () => (/* binding */ transformDFToTable),
/* harmony export */   "transformV2": () => (/* binding */ transformV2)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/d3-npm-5.15.0-0c7696026f-7342d82e55.zip/node_modules/d3/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







const POSITIVE_INFINITY_SAMPLE_VALUE = '+Inf';
const NEGATIVE_INFINITY_SAMPLE_VALUE = '-Inf';

const isTableResult = (dataFrame, options) => {
  var _dataFrame$meta, _dataFrame$meta$custo, _dataFrame$meta2, _dataFrame$meta2$cust;

  // We want to process vector and scalar results in Explore as table
  if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.CoreApp.Explore && (((_dataFrame$meta = dataFrame.meta) === null || _dataFrame$meta === void 0 ? void 0 : (_dataFrame$meta$custo = _dataFrame$meta.custom) === null || _dataFrame$meta$custo === void 0 ? void 0 : _dataFrame$meta$custo.resultType) === 'vector' || ((_dataFrame$meta2 = dataFrame.meta) === null || _dataFrame$meta2 === void 0 ? void 0 : (_dataFrame$meta2$cust = _dataFrame$meta2.custom) === null || _dataFrame$meta2$cust === void 0 ? void 0 : _dataFrame$meta2$cust.resultType) === 'scalar')) {
    return true;
  } // We want to process all dataFrames with target.format === 'table' as table


  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'table';
};

const isHeatmapResult = (dataFrame, options) => {
  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'heatmap';
}; // V2 result trasnformer used to transform query results from queries that were run trough prometheus backend


function transformV2(response, request, options) {
  const [tableFrames, framesWithoutTable] = (0,lodash__WEBPACK_IMPORTED_MODULE_2__.partition)(response.data, df => isTableResult(df, request));
  const processedTableFrames = transformDFToTable(tableFrames);
  const [exemplarFrames, framesWithoutTableAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_2__.partition)(framesWithoutTable, df => {
    var _df$meta, _df$meta$custom;

    return ((_df$meta = df.meta) === null || _df$meta === void 0 ? void 0 : (_df$meta$custom = _df$meta.custom) === null || _df$meta$custom === void 0 ? void 0 : _df$meta$custom.resultType) === 'exemplar';
  }); // EXEMPLAR FRAMES: We enrich exemplar frames with data links and add dataTopic meta info

  const {
    exemplarTraceIdDestinations: destinations
  } = options;
  const processedExemplarFrames = exemplarFrames.map(dataFrame => {
    if (destinations !== null && destinations !== void 0 && destinations.length) {
      for (const exemplarTraceIdDestination of destinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$ = traceIDField.config.links) !== null && _traceIDField$config$ !== void 0 && _traceIDField$config$.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataTopic.Annotations
      })
    });
  });
  const [heatmapResults, framesWithoutTableHeatmapsAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_2__.partition)(framesWithoutTableAndExemplars, df => isHeatmapResult(df, request));
  const processedHeatmapFrames = mergeHeatmapFrames(transformToHistogramOverTime(heatmapResults.sort(sortSeriesByLabel))); // Everything else is processed as time_series result and graph preferredVisualisationType

  const otherFrames = framesWithoutTableHeatmapsAndExemplars.map(dataFrame => {
    const df = Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        preferredVisualisationType: 'graph'
      })
    });
    return df;
  });
  return Object.assign({}, response, {
    data: [...otherFrames, ...processedTableFrames, ...processedHeatmapFrames, ...processedExemplarFrames]
  });
}
function transformDFToTable(dfs) {
  // If no dataFrames or if 1 dataFrames with no values, return original dataFrame
  if (dfs.length === 0 || dfs.length === 1 && dfs[0].length === 0) {
    return dfs;
  } // Group results by refId and process dataFrames with the same refId as 1 dataFrame


  const dataFramesByRefId = (0,lodash__WEBPACK_IMPORTED_MODULE_2__.groupBy)(dfs, 'refId');
  const refIds = Object.keys(dataFramesByRefId);
  const frames = refIds.map(refId => {
    // Create timeField, valueField and labelFields
    const valueText = getValueText(refIds.length, refId);
    const valueField = getValueField({
      data: [],
      valueName: valueText
    });
    const timeField = getTimeField([]);
    const labelFields = []; // Fill labelsFields with labels from dataFrames

    dataFramesByRefId[refId].forEach(df => {
      var _frameValueField$labe;

      const frameValueField = df.fields[1];
      const promLabels = (_frameValueField$labe = frameValueField.labels) !== null && _frameValueField$labe !== void 0 ? _frameValueField$labe : {};
      Object.keys(promLabels).sort().forEach(label => {
        // If we don't have label in labelFields, add it
        if (!labelFields.some(l => l.name === label)) {
          const numberField = label === 'le';
          labelFields.push({
            name: label,
            config: {
              filterable: true
            },
            type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string,
            values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector()
          });
        }
      });
    }); // Fill valueField, timeField and labelFields with values

    dataFramesByRefId[refId].forEach(df => {
      df.fields[0].values.toArray().forEach(value => timeField.values.add(value));
      df.fields[1].values.toArray().forEach(value => {
        var _df$fields$1$labels;

        valueField.values.add(parseSampleValue(value));
        const labelsForField = (_df$fields$1$labels = df.fields[1].labels) !== null && _df$fields$1$labels !== void 0 ? _df$fields$1$labels : {};
        labelFields.forEach(field => field.values.add(getLabelValue(labelsForField, field.name)));
      });
    });
    const fields = [timeField, ...labelFields, valueField];
    return {
      refId,
      fields,
      meta: Object.assign({}, dfs[0].meta, {
        preferredVisualisationType: 'table'
      }),
      length: timeField.values.length
    };
  });
  return frames;
}

function getValueText(responseLength, refId = '') {
  return responseLength > 1 ? `Value #${refId}` : 'Value';
}

function transform(response, transformOptions) {
  // Create options object from transformOptions
  const options = {
    format: transformOptions.target.format,
    step: transformOptions.query.step,
    legendFormat: transformOptions.target.legendFormat,
    start: transformOptions.query.start,
    end: transformOptions.query.end,
    query: transformOptions.query.expr,
    responseListLength: transformOptions.responseListLength,
    scopedVars: transformOptions.scopedVars,
    refId: transformOptions.target.refId,
    valueWithRefId: transformOptions.target.valueWithRefId,
    meta: {
      // Fix for showing of Prometheus results in Explore table
      preferredVisualisationType: transformOptions.query.instant ? 'table' : 'graph'
    }
  };
  const prometheusResult = response.data.data;

  if ((0,_types__WEBPACK_IMPORTED_MODULE_4__.isExemplarData)(prometheusResult)) {
    var _transformOptions$exe;

    const events = [];
    prometheusResult.forEach(exemplarData => {
      const data = exemplarData.exemplars.map(exemplar => {
        return Object.assign({
          [_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_TIME_FIELD_NAME]: exemplar.timestamp * 1000,
          [_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME]: exemplar.value
        }, exemplar.labels, exemplarData.seriesLabels);
      });
      events.push(...data);
    }); // Grouping exemplars by step

    const sampledExemplars = sampleExemplars(events, options);
    const dataFrame = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayDataFrame(sampledExemplars);
    dataFrame.meta = {
      dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataTopic.Annotations
    }; // Add data links if configured

    if ((_transformOptions$exe = transformOptions.exemplarTraceIdDestinations) !== null && _transformOptions$exe !== void 0 && _transformOptions$exe.length) {
      for (const exemplarTraceIdDestination of transformOptions.exemplarTraceIdDestinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$2;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$2 = traceIDField.config.links) !== null && _traceIDField$config$2 !== void 0 && _traceIDField$config$2.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return [dataFrame];
  }

  if (!(prometheusResult !== null && prometheusResult !== void 0 && prometheusResult.result)) {
    return [];
  } // Return early if result type is scalar


  if (prometheusResult.resultType === 'scalar') {
    return [{
      meta: options.meta,
      refId: options.refId,
      length: 1,
      fields: [getTimeField([prometheusResult.result]), getValueField({
        data: [prometheusResult.result]
      })]
    }];
  } // Return early again if the format is table, this needs special transformation.


  if (options.format === 'table') {
    const tableData = transformMetricDataToTable(prometheusResult.result, options);
    return [tableData];
  } // Process matrix and vector results to DataFrame


  const dataFrame = [];
  prometheusResult.result.forEach(data => dataFrame.push(transformToDataFrame(data, options))); // When format is heatmap use the already created data frames and transform it more

  if (options.format === 'heatmap') {
    return mergeHeatmapFrames(transformToHistogramOverTime(dataFrame.sort(sortSeriesByLabel)));
  } // Return matrix or vector result as DataFrame[]


  return dataFrame;
}

function getDataLinks(options) {
  const dataLinks = [];

  if (options.datasourceUid) {
    var _dsSettings$name;

    const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getDataSourceSrv)();
    const dsSettings = dataSourceSrv.getInstanceSettings(options.datasourceUid);
    dataLinks.push({
      title: options.urlDisplayLabel || `Query with ${dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name}`,
      url: '',
      internal: {
        query: {
          query: '${__value.raw}',
          queryType: 'traceId'
        },
        datasourceUid: options.datasourceUid,
        datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
      }
    });
  }

  if (options.url) {
    dataLinks.push({
      title: options.urlDisplayLabel || `Go to ${options.url}`,
      url: options.url,
      targetBlank: true
    });
  }

  return dataLinks;
}
/**
 * Reduce the density of the exemplars by making sure that the highest value exemplar is included
 * and then only the ones that are 2 times the standard deviation of the all the values.
 * This makes sure not to show too many dots near each other.
 */


function sampleExemplars(events, options) {
  const step = options.step || 15;
  const bucketedExemplars = {};
  const values = [];

  for (const exemplar of events) {
    // Align exemplar timestamp to nearest step second
    const alignedTs = String(Math.floor(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_TIME_FIELD_NAME] / 1000 / step) * step * 1000);

    if (!bucketedExemplars[alignedTs]) {
      // New bucket found
      bucketedExemplars[alignedTs] = [];
    }

    bucketedExemplars[alignedTs].push(exemplar);
    values.push(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME]);
  } // Getting exemplars from each bucket


  const standardDeviation = (0,d3__WEBPACK_IMPORTED_MODULE_3__.deviation)(values);
  const sampledBuckets = Object.keys(bucketedExemplars).sort();
  const sampledExemplars = [];

  for (const ts of sampledBuckets) {
    const exemplarsInBucket = bucketedExemplars[ts];

    if (exemplarsInBucket.length === 1) {
      sampledExemplars.push(exemplarsInBucket[0]);
    } else {
      // Choose which values to sample
      const bucketValues = exemplarsInBucket.map(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME]).sort(d3__WEBPACK_IMPORTED_MODULE_3__.descending);
      const sampledBucketValues = bucketValues.reduce((acc, curr) => {
        if (acc.length === 0) {
          // First value is max and is always added
          acc.push(curr);
        } else {
          // Then take values only when at least 2 standard deviation distance to previously taken value
          const prev = acc[acc.length - 1];

          if (standardDeviation && prev - curr >= 2 * standardDeviation) {
            acc.push(curr);
          }
        }

        return acc;
      }, []); // Find the exemplars for the sampled values

      sampledExemplars.push(...sampledBucketValues.map(value => exemplarsInBucket.find(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME] === value)));
    }
  }

  return sampledExemplars;
}
/**
 * Transforms matrix and vector result from Prometheus result to DataFrame
 */


function transformToDataFrame(data, options) {
  const {
    name,
    labels
  } = createLabelInfo(data.metric, options);
  const fields = [];

  if ((0,_types__WEBPACK_IMPORTED_MODULE_4__.isMatrixData)(data)) {
    const stepMs = options.step ? options.step * 1000 : NaN;
    let baseTimestamp = options.start * 1000;
    const dps = [];

    for (const value of data.values) {
      let dpValue = parseSampleValue(value[1]);

      if (isNaN(dpValue)) {
        dpValue = null;
      }

      const timestamp = value[0] * 1000;

      for (let t = baseTimestamp; t < timestamp; t += stepMs) {
        dps.push([t, null]);
      }

      baseTimestamp = timestamp + stepMs;
      dps.push([timestamp, dpValue]);
    }

    const endTimestamp = options.end * 1000;

    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {
      dps.push([t, null]);
    }

    fields.push(getTimeField(dps, true));
    fields.push(getValueField({
      data: dps,
      parseValue: false,
      labels,
      displayNameFromDS: name
    }));
  } else {
    fields.push(getTimeField([data.value]));
    fields.push(getValueField({
      data: [data.value],
      labels,
      displayNameFromDS: name
    }));
  }

  return {
    meta: options.meta,
    refId: options.refId,
    length: fields[0].values.length,
    fields,
    name
  };
}

function transformMetricDataToTable(md, options) {
  if (!md || md.length === 0) {
    return {
      meta: options.meta,
      refId: options.refId,
      length: 0,
      fields: []
    };
  }

  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';
  const timeField = getTimeField([]);
  const metricFields = Object.keys(md.reduce((acc, series) => Object.assign({}, acc, series.metric), {})).sort().map(label => {
    // Labels have string field type, otherwise table tries to figure out the type which can result in unexpected results
    // Only "le" label has a number field type
    const numberField = label === 'le';
    return {
      name: label,
      config: {
        filterable: true
      },
      type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string,
      values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector()
    };
  });
  const valueField = getValueField({
    data: [],
    valueName: valueText
  });
  md.forEach(d => {
    if ((0,_types__WEBPACK_IMPORTED_MODULE_4__.isMatrixData)(d)) {
      d.values.forEach(val => {
        timeField.values.add(val[0] * 1000);
        metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
        valueField.values.add(parseSampleValue(val[1]));
      });
    } else {
      timeField.values.add(d.value[0] * 1000);
      metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
      valueField.values.add(parseSampleValue(d.value[1]));
    }
  });
  return {
    meta: options.meta,
    refId: options.refId,
    length: timeField.values.length,
    fields: [timeField, ...metricFields, valueField]
  };
}

function getLabelValue(metric, label) {
  if (metric.hasOwnProperty(label)) {
    if (label === 'le') {
      return parseSampleValue(metric[label]);
    }

    return metric[label];
  }

  return '';
}

function getTimeField(data, isMs = false) {
  return {
    name: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_TIME_FIELD_NAME,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector(data.map(val => isMs ? val[0] : val[0] * 1000))
  };
}

function getValueField({
  data,
  valueName = _grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME,
  parseValue = true,
  labels,
  displayNameFromDS
}) {
  return {
    name: valueName,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number,
    display: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getDisplayProcessor)(),
    config: {
      displayNameFromDS
    },
    labels,
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector(data.map(val => parseValue ? parseSampleValue(val[1]) : val[1]))
  };
}

function createLabelInfo(labels, options) {
  if (options !== null && options !== void 0 && options.legendFormat) {
    const title = (0,_legend__WEBPACK_IMPORTED_MODULE_5__.renderLegendFormat)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getTemplateSrv)().replace(options.legendFormat, options === null || options === void 0 ? void 0 : options.scopedVars), labels);
    return {
      name: title,
      labels
    };
  }

  const {
    __name__
  } = labels,
        labelsWithoutName = _objectWithoutPropertiesLoose(labels, _excluded);

  const labelPart = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.formatLabels)(labelsWithoutName);
  let title = `${__name__ !== null && __name__ !== void 0 ? __name__ : ''}${labelPart}`;

  if (!title) {
    title = options.query;
  }

  return {
    name: title,
    labels: labelsWithoutName
  };
}

function getOriginalMetricName(labelData) {
  const metricName = labelData.__name__ || '';
  delete labelData.__name__;
  const labelPart = Object.entries(labelData).map(label => `${label[0]}="${label[1]}"`).join(',');
  return `${metricName}{${labelPart}}`;
}

function mergeHeatmapFrames(frames) {
  if (frames.length === 0) {
    return [];
  }

  const timeField = frames[0].fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time);
  const countFields = frames.map(frame => {
    let field = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number);
    return Object.assign({}, field, {
      name: field.config.displayNameFromDS
    });
  });
  return [Object.assign({}, frames[0], {
    meta: Object.assign({}, frames[0].meta, {
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataFrameType.HeatmapBuckets
    }),
    fields: [timeField, ...countFields]
  })];
}

function transformToHistogramOverTime(seriesList) {
  /*      t1 = timestamp1, t2 = timestamp2 etc.
            t1  t2  t3          t1  t2  t3
    le10    10  10  0     =>    10  10  0
    le20    20  10  30    =>    10  0   30
    le30    30  10  35    =>    10  0   5
    */
  for (let i = seriesList.length - 1; i > 0; i--) {
    const topSeries = seriesList[i].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME);
    const bottomSeries = seriesList[i - 1].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME);

    if (!topSeries || !bottomSeries) {
      throw new Error('Prometheus heatmap transform error: data should be a time series');
    }

    for (let j = 0; j < topSeries.values.length; j++) {
      const bottomPoint = bottomSeries.values.get(j) || [0];
      topSeries.values.toArray()[j] -= bottomPoint;
    }
  }

  return seriesList;
}

function sortSeriesByLabel(s1, s2) {
  let le1, le2;

  try {
    var _s1$name, _s2$name;

    // fail if not integer. might happen with bad queries
    le1 = parseSampleValue((_s1$name = s1.name) !== null && _s1$name !== void 0 ? _s1$name : '');
    le2 = parseSampleValue((_s2$name = s2.name) !== null && _s2$name !== void 0 ? _s2$name : '');
  } catch (err) {
    console.error(err);
    return 0;
  }

  if (le1 > le2) {
    return 1;
  }

  if (le1 < le2) {
    return -1;
  }

  return 0;
}

function parseSampleValue(value) {
  switch (value) {
    case POSITIVE_INFINITY_SAMPLE_VALUE:
      return Number.POSITIVE_INFINITY;

    case NEGATIVE_INFINITY_SAMPLE_VALUE:
      return Number.NEGATIVE_INFINITY;

    default:
      return parseFloat(value);
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegendFormatMode": () => (/* binding */ LegendFormatMode),
/* harmony export */   "PromQueryType": () => (/* binding */ PromQueryType),
/* harmony export */   "isExemplarData": () => (/* binding */ isExemplarData),
/* harmony export */   "isMatrixData": () => (/* binding */ isMatrixData)
/* harmony export */ });
let PromQueryType;

(function (PromQueryType) {
  PromQueryType["timeSeriesQuery"] = "timeSeriesQuery";
})(PromQueryType || (PromQueryType = {}));

function isMatrixData(result) {
  return 'values' in result;
}
function isExemplarData(result) {
  if (result == null || !Array.isArray(result)) {
    return false;
  }

  return result.length ? 'exemplars' in result[0] : false;
}

/**
 * Auto = query.legendFormat == '__auto'
 * Verbose = query.legendFormat == null/undefined/''
 * Custom query.legendFormat.length > 0 && query.legendFormat !== '__auto'
 */
let LegendFormatMode;

(function (LegendFormatMode) {
  LegendFormatMode["Auto"] = "__auto";
  LegendFormatMode["Verbose"] = "__verbose";
  LegendFormatMode["Custom"] = "__custom";
})(LegendFormatMode || (LegendFormatMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/variables.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusVariableSupport": () => (/* binding */ PrometheusVariableSupport)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/from.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");
/* harmony import */ var _features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");






class PrometheusVariableSupport extends _grafana_data__WEBPACK_IMPORTED_MODULE_0__.StandardVariableSupport {
  constructor(datasource, templateSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getTemplateSrv)(), timeSrv = (0,_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_3__.getTimeSrv)()) {
    super();
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.query = this.query.bind(this);
  }

  query(request) {
    const query = request.targets[0].expr;

    if (!query) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)({
        data: []
      });
    }

    const scopedVars = Object.assign({}, request.scopedVars, {
      __interval: {
        text: this.datasource.interval,
        value: this.datasource.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval)
      }
    }, this.datasource.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.datasource.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_2__["default"](this.datasource, interpolated);
    const metricFindStream = (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(metricFindQuery.process());
    return metricFindStream.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(results => ({
      data: results
    })));
  }

  toDataQuery(query) {
    return {
      refId: 'PrometheusDatasource-VariableQuery',
      expr: query.query
    };
  }

}

/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

function usePrevious(state) {
    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
        ref.current = state;
    });
    return ref.current;
}


/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useToggle.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

var toggleReducer = function (state, nextValue) {
    return typeof nextValue === 'boolean' ? nextValue : !state;
};
var useToggle = function (initialValue) {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(toggleReducer, initialValue);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useToggle);


/***/ }),

/***/ "./.yarn/cache/lru-cache-npm-7.7.1-726274dc4d-f362c5a2cf.zip/node_modules/lru-cache/index.js":
/***/ ((module) => {

const perf = typeof performance === 'object' && performance &&
  typeof performance.now === 'function' ? performance : Date

const hasAbortController = typeof AbortController !== 'undefined'

/* istanbul ignore next - minimal backwards compatibility polyfill */
const AC = hasAbortController ? AbortController : Object.assign(
  class AbortController {
    constructor () { this.signal = new AC.AbortSignal }
    abort () { this.signal.aborted = true }
  },
  { AbortSignal: class AbortSignal { constructor () { this.aborted = false }}}
)

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const shouldWarn = code => typeof process === 'object' &&
  process &&
  !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  process.emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max => !isPosInt(max) ? null
: max <= Math.pow(2, 8) ? Uint8Array
: max <= Math.pow(2, 16) ? Uint16Array
: max <= Math.pow(2, 32) ? Uint32Array
: max <= Number.MAX_SAFE_INTEGER ? ZeroArray
: null

class ZeroArray extends Array {
  constructor (size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor (max) {
    const UintArray = max ? getUintArray(max) : Array
    this.heap = new UintArray(max)
    this.length = 0
  }
  push (n) {
    this.heap[this.length++] = n
  }
  pop () {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor (options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      sizeCalculation,
      fetchMethod,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const {
      length,
      maxAge,
      stale,
    } = options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize) {
        throw new TypeError('cannot set sizeCalculation without setting maxSize')
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculating set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError('fetchMethod must be a function if specified')
    }


    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL

    if (this.maxSize !== 0) {
      if (!isPosInt(this.maxSize)) {
        throw new TypeError('maxSize must be a positive integer if specified')
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.updateAgeOnGet = !!updateAgeOnGet
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0
      ? ttlResolution : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError('ttl must be a positive integer if specified')
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError('At least one of max, maxSize, or ttl is required')
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        process.emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL (key) {
    return this.has(key) ? Infinity : 0
  }

  initializeTTLTracking () {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl) => {
      this.starts[index] = ttl !== 0 ? perf.now() : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = (index) => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution)
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = (key) => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity
        : ((this.starts[index] + this.ttls[index]) - (cachedNow || getNow()))
    }

    this.isStale = (index) => {
      return this.ttls[index] !== 0 && this.starts[index] !== 0 &&
        ((cachedNow || getNow()) - this.starts[index] > this.ttls[index])
    }
  }
  updateItemAge (index) {}
  setItemTTL (index, ttl) {}
  isStale (index) { return false }

  initializeSizeTracking () {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index => this.calculatedSize -= this.sizes[index]
    this.requireSize = (k, v, size, sizeCalculation) => {
      if (sizeCalculation && !size) {
        size = sizeCalculation(v, k)
      }
      if (!isPosInt(size)) {
        throw new TypeError('size must be positive integer')
      }
      return size
    }
    this.addItemSize = (index, v, k, size) => {
      this.sizes[index] = size
      const maxSize = this.maxSize - this.sizes[index]
      while (this.calculatedSize > maxSize) {
        this.evict()
      }
      this.calculatedSize += this.sizes[index]
    }
    this.delete = k => {
      if (this.size !== 0) {
        const index = this.keyMap.get(k)
        if (index !== undefined) {
          this.calculatedSize -= this.sizes[index]
        }
      }
      return LRUCache.prototype.delete.call(this, k)
    }
  }
  removeItemSize (index) {}
  addItemSize (index, v, k, size) {}
  requireSize (k, v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError('cannot set size without setting maxSize on cache')
    }
  }

  *indexes ({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes ({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex (index) {
    return this.keyMap.get(this.keyList[index]) === index
  }

  *entries () {
    for (const i of this.indexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }
  *rentries () {
    for (const i of this.rindexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }

  *keys () {
    for (const i of this.indexes()) {
      yield this.keyList[i]
    }
  }
  *rkeys () {
    for (const i of this.rindexes()) {
      yield this.keyList[i]
    }
  }

  *values () {
    for (const i of this.indexes()) {
      yield this.valList[i]
    }
  }
  *rvalues () {
    for (const i of this.rindexes()) {
      yield this.valList[i]
    }
  }

  [Symbol.iterator] () {
    return this.entries()
  }

  find (fn, getOptions = {}) {
    for (const i of this.indexes()) {
      if (fn(this.valList[i], this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach (fn, thisp = this) {
    for (const i of this.indexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  rforEach (fn, thisp = this) {
    for (const i of this.rindexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  get prune () {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale () {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump () {
    const arr = []
    for (const i of this.indexes()) {
      const key = this.keyList[i]
      const value = this.valList[i]
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load (arr) {
    this.clear()
    for (const [key, entry] of arr) {
      this.set(key, entry.value, entry)
    }
  }

  dispose (v, k, reason) {}

  set (k, v, {
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
  } = {}) {
    size = this.requireSize(k, v, size, sizeCalculation)
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size ++
      this.addItemSize(index, v, k, size)
      noUpdateTTL = false
    } else {
      // update
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort()
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, v, k, size)
      }
      this.moveToTail(index)
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl)
    }
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex () {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max) {
      return this.evict()
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop () {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict()
      return val
    }
  }

  evict () {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort()
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size --
    return head
  }

  has (k) {
    return this.keyMap.has(k) && !this.isStale(this.keyMap.get(k))
  }

  // like get(), but without any LRU updating or TTL expiration
  peek (k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      return this.valList[index]
    }
  }

  backgroundFetch (k, index, options) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AbortController()
    const fetchOpts = {
      signal: ac.signal,
      options,
    }
    const p = Promise.resolve(this.fetchMethod(k, v, fetchOpts)).then(v => {
      if (!ac.signal.aborted) {
        this.set(k, v, fetchOpts.options)
      }
      return v
    })
    p.__abortController = ac
    p.__staleWhileFetching = v
    if (index === undefined) {
      this.set(k, p, fetchOpts.options)
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch (p) {
    return p && typeof p === 'object' && typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching')
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch (k, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
  } = {}) {
    if (!this.fetchMethod) {
      return this.get(k, {allowStale, updateAgeOnGet})
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      return this.backgroundFetch(k, index, options)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        return allowStale && v.__staleWhileFetching !== undefined
          ? v.__staleWhileFetching : v
      }

      if (!this.isStale(index)) {
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return v
      }

      // ok, it is stale, and not already fetching
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options)
      return allowStale && p.__staleWhileFetching !== undefined
        ? p.__staleWhileFetching : p
    }
  }

  get (k, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
  } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      if (this.isStale(index)) {
        // delete only if not an in-flight background fetch
        if (!fetching) {
          this.delete(k)
          return allowStale ? value : undefined
        } else {
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching,
        // so we just return undefined
        if (fetching) {
          return undefined
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    }
  }

  connect (p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail (index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del () {
    deprecatedMethod('del', 'delete')
    return this.delete
  }
  delete (k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort()
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size --
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear () {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort()
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }
  get reset () {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length () {
    deprecatedProperty('length', 'size')
    return this.size
  }
}

module.exports = LRUCache


/***/ }),

/***/ "./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketSubject": () => (/* binding */ WebSocketSubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/tslib-npm-2.3.1-0e21e18015-de17a98d46.zip/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subject.js");
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscriber.js");
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Observable.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");






var DEFAULT_WEBSOCKET_CONFIG = {
    url: '',
    deserializer: function (e) { return JSON.parse(e.data); },
    serializer: function (value) { return JSON.stringify(value); },
};
var WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';
var WebSocketSubject = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(WebSocketSubject, _super);
    function WebSocketSubject(urlConfigOrSource, destination) {
        var _this = _super.call(this) || this;
        _this._socket = null;
        if (urlConfigOrSource instanceof _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable) {
            _this.destination = destination;
            _this.source = urlConfigOrSource;
        }
        else {
            var config = (_this._config = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, DEFAULT_WEBSOCKET_CONFIG));
            _this._output = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
            if (typeof urlConfigOrSource === 'string') {
                config.url = urlConfigOrSource;
            }
            else {
                for (var key in urlConfigOrSource) {
                    if (urlConfigOrSource.hasOwnProperty(key)) {
                        config[key] = urlConfigOrSource[key];
                    }
                }
            }
            if (!config.WebSocketCtor && WebSocket) {
                config.WebSocketCtor = WebSocket;
            }
            else if (!config.WebSocketCtor) {
                throw new Error('no WebSocket constructor can be found');
            }
            _this.destination = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject();
        }
        return _this;
    }
    WebSocketSubject.prototype.lift = function (operator) {
        var sock = new WebSocketSubject(this._config, this.destination);
        sock.operator = operator;
        sock.source = this;
        return sock;
    };
    WebSocketSubject.prototype._resetState = function () {
        this._socket = null;
        if (!this.source) {
            this.destination = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject();
        }
        this._output = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
    };
    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
        var self = this;
        return new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function (observer) {
            try {
                self.next(subMsg());
            }
            catch (err) {
                observer.error(err);
            }
            var subscription = self.subscribe({
                next: function (x) {
                    try {
                        if (messageFilter(x)) {
                            observer.next(x);
                        }
                    }
                    catch (err) {
                        observer.error(err);
                    }
                },
                error: function (err) { return observer.error(err); },
                complete: function () { return observer.complete(); },
            });
            return function () {
                try {
                    self.next(unsubMsg());
                }
                catch (err) {
                    observer.error(err);
                }
                subscription.unsubscribe();
            };
        });
    };
    WebSocketSubject.prototype._connectSocket = function () {
        var _this = this;
        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;
        var observer = this._output;
        var socket = null;
        try {
            socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);
            this._socket = socket;
            if (binaryType) {
                this._socket.binaryType = binaryType;
            }
        }
        catch (e) {
            observer.error(e);
            return;
        }
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription(function () {
            _this._socket = null;
            if (socket && socket.readyState === 1) {
                socket.close();
            }
        });
        socket.onopen = function (evt) {
            var _socket = _this._socket;
            if (!_socket) {
                socket.close();
                _this._resetState();
                return;
            }
            var openObserver = _this._config.openObserver;
            if (openObserver) {
                openObserver.next(evt);
            }
            var queue = _this.destination;
            _this.destination = _Subscriber__WEBPACK_IMPORTED_MODULE_5__.Subscriber.create(function (x) {
                if (socket.readyState === 1) {
                    try {
                        var serializer = _this._config.serializer;
                        socket.send(serializer(x));
                    }
                    catch (e) {
                        _this.destination.error(e);
                    }
                }
            }, function (err) {
                var closingObserver = _this._config.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                if (err && err.code) {
                    socket.close(err.code, err.reason);
                }
                else {
                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));
                }
                _this._resetState();
            }, function () {
                var closingObserver = _this._config.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                socket.close();
                _this._resetState();
            });
            if (queue && queue instanceof _ReplaySubject__WEBPACK_IMPORTED_MODULE_3__.ReplaySubject) {
                subscription.add(queue.subscribe(_this.destination));
            }
        };
        socket.onerror = function (e) {
            _this._resetState();
            observer.error(e);
        };
        socket.onclose = function (e) {
            if (socket === _this._socket) {
                _this._resetState();
            }
            var closeObserver = _this._config.closeObserver;
            if (closeObserver) {
                closeObserver.next(e);
            }
            if (e.wasClean) {
                observer.complete();
            }
            else {
                observer.error(e);
            }
        };
        socket.onmessage = function (e) {
            try {
                var deserializer = _this._config.deserializer;
                observer.next(deserializer(e));
            }
            catch (err) {
                observer.error(err);
            }
        };
    };
    WebSocketSubject.prototype._subscribe = function (subscriber) {
        var _this = this;
        var source = this.source;
        if (source) {
            return source.subscribe(subscriber);
        }
        if (!this._socket) {
            this._connectSocket();
        }
        this._output.subscribe(subscriber);
        subscriber.add(function () {
            var _socket = _this._socket;
            if (_this._output.observers.length === 0) {
                if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
                    _socket.close();
                }
                _this._resetState();
            }
        });
        return subscriber;
    };
    WebSocketSubject.prototype.unsubscribe = function () {
        var _socket = this._socket;
        if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {
            _socket.close();
        }
        this._resetState();
        _super.prototype.unsubscribe.call(this);
    };
    return WebSocketSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_2__.AnonymousSubject));

//# sourceMappingURL=WebSocketSubject.js.map

/***/ }),

/***/ "./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "webSocket": () => (/* binding */ webSocket)
/* harmony export */ });
/* harmony import */ var _WebSocketSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js");

function webSocket(urlConfigOrSource) {
    return new _WebSocketSubject__WEBPACK_IMPORTED_MODULE_0__.WebSocketSubject(urlConfigOrSource);
}
//# sourceMappingURL=webSocket.js.map

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/parse.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/sha1.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v35.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v5.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/uuid-npm-8.3.2-eca0baba53-5575a8a75c.zip/node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "./.yarn/__virtual__/@grafana-lezer-logql-virtual-9250dbecf8/0/cache/@grafana-lezer-logql-npm-0.0.11-d7d249e74a-0427e59528.zip/node_modules/@grafana/lezer-logql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "And": () => (/* binding */ And),
/* harmony export */   "Avg": () => (/* binding */ Avg),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinOpExpr": () => (/* binding */ BinOpExpr),
/* harmony export */   "BinOpModifier": () => (/* binding */ BinOpModifier),
/* harmony export */   "Bool": () => (/* binding */ Bool),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk),
/* harmony export */   "By": () => (/* binding */ By),
/* harmony export */   "Bytes": () => (/* binding */ Bytes),
/* harmony export */   "BytesConv": () => (/* binding */ BytesConv),
/* harmony export */   "BytesFilter": () => (/* binding */ BytesFilter),
/* harmony export */   "BytesOverTime": () => (/* binding */ BytesOverTime),
/* harmony export */   "BytesRate": () => (/* binding */ BytesRate),
/* harmony export */   "ConvOp": () => (/* binding */ ConvOp),
/* harmony export */   "Count": () => (/* binding */ Count),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "DurationConv": () => (/* binding */ DurationConv),
/* harmony export */   "DurationFilter": () => (/* binding */ DurationFilter),
/* harmony export */   "DurationSecondsConv": () => (/* binding */ DurationSecondsConv),
/* harmony export */   "Eq": () => (/* binding */ Eq),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Filter": () => (/* binding */ Filter),
/* harmony export */   "FilterOp": () => (/* binding */ FilterOp),
/* harmony export */   "FirstOverTime": () => (/* binding */ FirstOverTime),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight),
/* harmony export */   "Grouping": () => (/* binding */ Grouping),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring),
/* harmony export */   "Ip": () => (/* binding */ Ip),
/* harmony export */   "IpLabelFilter": () => (/* binding */ IpLabelFilter),
/* harmony export */   "Json": () => (/* binding */ Json),
/* harmony export */   "JsonExpression": () => (/* binding */ JsonExpression),
/* harmony export */   "JsonExpressionList": () => (/* binding */ JsonExpressionList),
/* harmony export */   "JsonExpressionParser": () => (/* binding */ JsonExpressionParser),
/* harmony export */   "LabelFilter": () => (/* binding */ LabelFilter),
/* harmony export */   "LabelFormat": () => (/* binding */ LabelFormat),
/* harmony export */   "LabelFormatExpr": () => (/* binding */ LabelFormatExpr),
/* harmony export */   "LabelFormatMatcher": () => (/* binding */ LabelFormatMatcher),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelParser": () => (/* binding */ LabelParser),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LabelReplaceExpr": () => (/* binding */ LabelReplaceExpr),
/* harmony export */   "Labels": () => (/* binding */ Labels),
/* harmony export */   "LabelsFormat": () => (/* binding */ LabelsFormat),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "LineFilter": () => (/* binding */ LineFilter),
/* harmony export */   "LineFilters": () => (/* binding */ LineFilters),
/* harmony export */   "LineFormat": () => (/* binding */ LineFormat),
/* harmony export */   "LineFormatExpr": () => (/* binding */ LineFormatExpr),
/* harmony export */   "LiteralExpr": () => (/* binding */ LiteralExpr),
/* harmony export */   "LogExpr": () => (/* binding */ LogExpr),
/* harmony export */   "LogQL": () => (/* binding */ LogQL),
/* harmony export */   "LogRangeExpr": () => (/* binding */ LogRangeExpr),
/* harmony export */   "Logfmt": () => (/* binding */ Logfmt),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "Matcher": () => (/* binding */ Matcher),
/* harmony export */   "Matchers": () => (/* binding */ Matchers),
/* harmony export */   "Max": () => (/* binding */ Max),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricExpr": () => (/* binding */ MetricExpr),
/* harmony export */   "Min": () => (/* binding */ Min),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "Nre": () => (/* binding */ Nre),
/* harmony export */   "Number": () => (/* binding */ Number),
/* harmony export */   "NumberFilter": () => (/* binding */ NumberFilter),
/* harmony export */   "Offset": () => (/* binding */ Offset),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On),
/* harmony export */   "OnOrIgnoringModifier": () => (/* binding */ OnOrIgnoringModifier),
/* harmony export */   "Or": () => (/* binding */ Or),
/* harmony export */   "Pattern": () => (/* binding */ Pattern),
/* harmony export */   "Pipe": () => (/* binding */ Pipe),
/* harmony export */   "PipeExact": () => (/* binding */ PipeExact),
/* harmony export */   "PipeMatch": () => (/* binding */ PipeMatch),
/* harmony export */   "PipelineExpr": () => (/* binding */ PipelineExpr),
/* harmony export */   "PipelineStage": () => (/* binding */ PipelineStage),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "RangeAggregationExpr": () => (/* binding */ RangeAggregationExpr),
/* harmony export */   "RangeOp": () => (/* binding */ RangeOp),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Re": () => (/* binding */ Re),
/* harmony export */   "Regexp": () => (/* binding */ Regexp),
/* harmony export */   "Selector": () => (/* binding */ Selector),
/* harmony export */   "Stddev": () => (/* binding */ Stddev),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "String": () => (/* binding */ String),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "Sum": () => (/* binding */ Sum),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Topk": () => (/* binding */ Topk),
/* harmony export */   "UnitFilter": () => (/* binding */ UnitFilter),
/* harmony export */   "Unless": () => (/* binding */ Unless),
/* harmony export */   "Unpack": () => (/* binding */ Unpack),
/* harmony export */   "Unwrap": () => (/* binding */ Unwrap),
/* harmony export */   "UnwrapExpr": () => (/* binding */ UnwrapExpr),
/* harmony export */   "VectorAggregationExpr": () => (/* binding */ VectorAggregationExpr),
/* harmony export */   "VectorOp": () => (/* binding */ VectorOp),
/* harmony export */   "Without": () => (/* binding */ Without),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const Json$1 = 1,
  Logfmt$1 = 2,
  Unpack$1 = 3,
  Pattern$1 = 4,
  Regexp$1 = 5,
  Unwrap$1 = 6,
  Ip$1 = 7,
  LabelFormat$1 = 8,
  LineFormat$1 = 9,
  LabelReplace$1 = 10,
  Offset$1 = 11,
  Bool$1 = 12,
  On$1 = 13,
  Ignoring$1 = 14,
  GroupLeft$1 = 15,
  GroupRight$1 = 16,
  BytesConv$1 = 17,
  DurationConv$1 = 18,
  DurationSecondsConv$1 = 19,
  By$1 = 20,
  Without$1 = 21,
  And$1 = 22,
  Or$1 = 23,
  Unless$1 = 24,
  Sum$1 = 25,
  Avg$1 = 26,
  Count$1 = 27,
  Max$1 = 28,
  Min$1 = 29,
  Stddev$1 = 30,
  Stdvar$1 = 31,
  Bottomk$1 = 32,
  Topk$1 = 33;

const keywordTokens = {
    json: Json$1,
    logfmt : Logfmt$1,
    unpack: Unpack$1,
    pattern : Pattern$1,
    regexp : Regexp$1,
    ip : Ip$1,
    label_format : LabelFormat$1,
    line_format : LineFormat$1,
    label_replace: LabelReplace$1,
    offset: Offset$1,
    bool: Bool$1,
    on: On$1,
    ignoring: Ignoring$1,
    group_left: GroupLeft$1,
    group_right: GroupRight$1,
    unwrap: Unwrap$1,
    bytes: BytesConv$1,
    duration: DurationConv$1,
    duration_seconds: DurationSecondsConv$1
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};


const contextualKeywordTokens = {
    by: By$1,
    without: Without$1,
    and: And$1,
    or: Or$1,
    unless: Unless$1,
    sum: Sum$1,
    avg: Avg$1,
    count: Count$1,
    max: Max$1,
    min: Min$1,
    stddev: Stddev$1,
    stdvar: Stdvar$1,
    bottomk: Bottomk$1,
    topk: Topk$1
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,count_over_time:255, rate:257, bytes_over_time:259, bytes_rate:261, avg_over_time:263, sum_over_time:265, min_over_time:267, max_over_time:269, stddev_over_time:271, stdvar_over_time:273, quantile_over_time:275, first_over_time:277, last_over_time:279, absent_over_time:281};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "@jOYQPOOO#VQPO'#DSO$fQPO'#DROYQPO'#DROOQO'#EO'#EOO$sQPO'#D}OOQO'#Eg'#EgO$xQPO'#EfQ%TQPOOOOQO'#Eu'#EuO&UQPO'#EuO&ZQPO'#EvOOQO'#D|'#D|OOQO'#DQ'#DQOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^O&`QPO'#DUOOQO'#DT'#DTO&nQPO,59nOOQO'#Da'#DaO&vQPO'#D`O'OQPO'#D_OOQO'#D^'#D^O(lQPO'#D^OOQO'#D]'#D]O*hQPO,59mO+vQPO,59mO+}QPO,5:hO,UQPO,5:iO,aQPO'#EdO.`QPO,5;QO.gQPO,5;QO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SOOQO,5;a,5;aOYQPO,5;bO0rQPO,59pO0wQPO1G/YOOQO1G/Y1G/YOOQO'#Dd'#DdOOQO,59z,59zO1PQPO,59zOOQO,59y,59yO1UQPO'#DUO1sQPO'#DfOOQO'#Df'#DfO3dQPO'#DfO3iQPO'#DmOOQO'#Dl'#DlOOQO'#Dj'#DjO)RQPO'#DjO4QQPO,59xO5nQPO'#DxO5sQPO'#DyOOQO,59x,59xOOQO,59w,59wOOQO1G/X1G/XOOQO1G0S1G0SO5xQPO'#E_O,XQPO'#E_O6aQPO1G0TO6fQPO1G0TO6kQPO,5;OO6sQPO1G0lO8OQPO1G0lO8VQPO1G0lO8^QPO'#EjO:`QPO'#EiO:jQPO'#EiOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nO:tQPO1G0|OOQO1G/[1G/[OOQO1G/Z1G/ZOOQO7+$t7+$tO:{QPO1G/fO;QQPO,59pO;WQPO,5:`O;`QPO'#DiO;eQPO'#DhOOQO,5:R,5:ROOQO,5:Q,5:QO=RQPO,5:XO=WQPO,5:UO)RQPO,5:UO)RQPO,5:UOOQO,5:d,5:dO=fQPO'#D{OOQO'#Dz'#DzO=kQPO,5:eO?XQPO'#D^O5xQPO,5:yO?`QPO'#E`O?eQPO'#EbO@OQPO,5:yO6[QPO,5:yO@YQPO,5:yO@aQPO,5:yO@fQPO7+%oO,XQPO7+%oOOQO'#Ee'#EeOAvQPO1G0jOOQO1G0j1G0jOBOQPO7+&WOYQPO7+&WOC`QPO7+&WOCgQPO7+&WOCnQQO'#EkOOQO,5;U,5;UOEpQPO,5;TOEwQPO,5;TOGYQPO7+&YOGaQPO7+&YOOQO7+&Y7+&YOGnQPO7+&YOGuQPO7+&YOHzQPO7+&YOI[QPO7+&hOIaQPO7+%QOIfQPO1G/qOOQO1G/z1G/zOOQO1G/|1G/|OIkQPO,5:TOIpQPO,5:SOOQO1G/s1G/sOOQO1G/p1G/pOIuQPO1G/pOKcQPO,5:gO5sQPO,5:fOKkQPO,5:|OKyQPO1G0eO6[QPO1G0eOLRQPO,5:zO)RQPO,5:|OLWQPO1G0eOL_QPO'#EaOLWQPO1G0eOOQO1G0e1G0eOLdQPO1G0eO6[QPO1G0eOLkQPO1G0eOOQO<<IZ<<IZOLsQPO<<IZOLxQPO,5;POOQO7+&U7+&UOOQO<<Ir<<IrOL}QPO<<IrOYQPO<<IrOOQO'#Em'#EmOMUQPO,5;VOOQO'#El'#ElOOQO,5;V,5;VOOQO1G0o1G0oOM^QPO1G0oO! ZQPO<<JSOOQO<<Hl<<HlO! `QPO7+%]OOQO1G/o1G/oOOQO1G/n1G/nOOQO1G0R1G0ROOQO1G0Q1G0QOOQO'#Ec'#EcOOQO1G0h1G0hO! eQPO1G0hOOQO7+&P7+&POOQO1G0f1G0fO! jQPO1G0hOOQO,5:{,5:{O! {QPO7+&PO6[QPO7+&PO!!SQPO7+&PO!!bQPOAN>uOOQO1G0k1G0kO!#rQPOAN?^O!%SQPOAN?^O!%ZQQO1G0qOOQO1G0q1G0qOOQO7+&Z7+&ZO!%cQPOAN?nO!%hQPO<<HwO!%mQPO7+&SOOQO<<Ik<<IkO!%rQPO<<IkO!%zQPO<<IkO!&VQPO'#EbOOQOG24aG24aOOQOG24xG24xOOQO1G0r1G0rOOQO7+&]7+&]O!&[QPOG25YOOQOAN>cAN>cO!&aQPO<<InOOQOAN?VAN?VO!&fQPOLD*tOOQOAN?YAN?YOOQO,5:e,5:eO!&kQPO!$'N`O!&pQPO!)9CzO!&uQPO!.K9fOOQO!4//Q!4//QO5sQPO'#DyO!&zQPO'#D^O!'lQPO,59mO!'vQPO'#DROYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nOYQPO1G0nO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO.lQPO,5;SO!)RQPO7+&YO!)YQPO7+&YO!)gQPO7+&YO!*oQPO7+&YO!*vQPO7+&YO!)nQPO'#Eh",
  stateData: "!+T~O#mOSrOS~OYZOiUOjUOkUOlUOmUOnUOoUOpUOqUO!kXO#cYO#dYO#nPO#qRO#s^O#t_O#u`O#vaO#wbO#xcO#ydO#zeO#{fO#|gO#}hO$OiO$PjO$QkO~OylO~O|oO!OoO!UoO!VoOfuXguXhuX!buX!duX!euX!fuX!guX#cuX#duX#euX#fuX#guX#huX~O!XsO#kuX#ruX~P#[O#qxO~OdyOeyO#qzO~Of}Og|Oh}O|!RO!b!RO!d!RO!e!RO!f!RO!g!RO#c!OO#d!OO#e!PO#f!PO#g!PO#h!QO~O!k!SO~O#q!TO~Oz!UO|!UO}!UO!O!UO~O#o!VO#p!WO~OV!XO{!YO~O|oO!OoO!UoO!VoOf!RXg!RXh!RX!X!RX!b!RX!d!RX!e!RX!f!RX!g!RX#c!RX#d!RX#e!RX#f!RX#g!RX#h!RX#k!RX#r!RXU!RX$R!RX#o!RX~OP!^OQ!_OR!_OS!`OT!`OW!gOX!fOb!aOy!]O#q!dO~O|oO!OoO!UoO!VoOfuaguahua!bua!dua!eua!fua!gua#cua#dua#eua#fua#gua#hua~O!XsO#kua#rua~P)^OftXgtXhtX|tX!btX!dtX!etX!ftX!gtX#ctX#dtX#etX#ftX#gtX#htX~O#r!jO~P*uO#r!kO~P*uO!k!oO#nPO#q!mO~O#q!pO~OYZOiUOjUOkUOlUOmUOnUOoUOpUOqUO#cYO#dYO#nPO#qRO#s^O#t_O#u`O#vaO#wbO#xcO#ydO#zeO#{fO#|gO#}hO$OiO$PjO$QkO~O!k!rO~P,fO#q!sO~O[!vO]!tO^!tOY#]Pi#]Pj#]Pk#]Pl#]Pm#]Pn#]Po#]Pp#]Pq#]P!k#]P#c#]P#d#]P#n#]P#q#]P#s#]P#t#]P#u#]P#v#]P#w#]P#x#]P#y#]P#z#]P#{#]P#|#]P#}#]P$O#]P$P#]P$Q#]P~O{#OO~OylO#p#QO~O#q#RO~Oz#SO|#SO}!UO!O!UO!b#TO!d#TO!e#TO!f#TO!g#TO~Oy#UOf!YXg!YXh!YX|!YX!O!YX!U!YX!V!YX!X!YX!b!YX!d!YX!e!YX!f!YX!g!YX#c!YX#d!YX#e!YX#f!YX#g!YX#h!YX#k!YX#r!YXU!YX$R!YX#o!YX~O{#XO~Oz#YO|#YO!b#YO!d#YO!e#YO!f#YO!g#YO~Of#[Og#]O#o#[Oh!Qa|!Qa!O!Qa!U!Qa!V!Qa!X!Qa!b!Qa!d!Qa!e!Qa!f!Qa!g!Qa#c!Qa#d!Qa#e!Qa#f!Qa#g!Qa#h!Qa#k!Qa#r!QaU!Qa$R!Qa~O{#^O~Oy#_O~OU#eO|oO!OoO!UoO!VoO!X#bO$R#dO~O#r#jO~O#o#kO~Oy#lO#r#nO~O#r#oO~P*uOf#iXg#iXh#iX|#iX!b#iX!d#iX!e#iX!f#iX!g#iX#c#iX#d#iX#e#iX#f#iX#g#iX#h#iX#r#iX~O#o#pO~P6zO!k#rO~P,fO#q#sO~OY#]Xi#]Xj#]Xk#]Xl#]Xm#]Xn#]Xo#]Xp#]Xq#]X!k#]X#c#]X#d#]X#n#]X#q#]X#s#]X#t#]X#u#]X#v#]X#w#]X#x#]X#y#]X#z#]X#{#]X#|#]X#}#]X$O#]X$P#]X$Q#]X~O_#uO`#uO~P8cO]!tO^!tO~P8cO#o#}O~P*uO{$OO~OV$PO{#OO!i$QO!k$RO~Oz$SO~O#o$TOf![Xg![Xh![X|![X!O![X!U![X!V![X!X![X!b![X!d![X!e![X!f![X!g![X#c![X#d![X#e![X#f![X#g![X#h![X#k![X#r![XU![X$R![X~O!c$UO~Of#[Og#]O#o#[O#r$VO~Oz$XO~O#o$YOf!mag!mah!ma|!ma!O!ma!U!ma!V!ma!X!ma!b!ma!d!ma!e!ma!f!ma!g!ma#c!ma#d!ma#e!ma#f!ma#g!ma#h!ma#k!ma#r!maU!ma$R!ma~OU$ZO~P(lO!c$^O~O!X$_O~OU#eO|oO!OoO!UoO!VoO!X#bO~OZ$aO#r#Ra~P?jO#r$eO~P5xO#r$cO~OdyOeyOf!qqg!qqh!qq|!qq!b!qq!d!qq!e!qq!f!qq!g!qq#c!qq#d!qq#e!qq#f!qq#g!qq#h!qq#k!qq#r!qq#o!qq~O#o$iO#r$jO~OdyOeyOf#Yqg#Yqh#Yq|#Yq!b#Yq!d#Yq!e#Yq!f#Yq!g#Yq#c#Yq#d#Yq#e#Yq#f#Yq#g#Yq#h#Yq#k#Yq#r#Yq#o#Yq~O#r$kO~P*uO#o$mO~P6zO#b$nO#r$qO~OY#]ai#]aj#]ak#]al#]am#]an#]ao#]ap#]aq#]a!k#]a#c#]a#d#]a#n#]a#s#]a#t#]a#u#]a#v#]a#w#]a#x#]a#y#]a#z#]a#{#]a#|#]a#}#]a$O#]a$P#]a$Q#]a~O#q#sO~PCvO_$sO`$sO#q#]a~PCvOf}Oh}O|!RO!b!RO!d!RO!e!RO!f!RO!g!RO#c!OO#d!OO#e#[q#f#[q#g#[q#h#[q#k#[q#r#[q~Og#[q~PFUOf#[qg#[qh#[q~PF[Og|O~PFUO#k#[q#r#[q~P%TOf#[qg#[qh#[q|#[q!b#[q!d#[q!e#[q!f#[q!g#[q#e#[q#f#[q#g#[q#h#[q~O#c!OO#d!OO#k#[q#r#[q~PHPO{$tO~O#r$uO~O#q$vO~O{$wO~Oy#UO~Of#[O#o#[Og!^ih!^i|!^i!O!^i!U!^i!V!^i!X!^i!b!^i!d!^i!e!^i!f!^i!g!^i#c!^i#d!^i#e!^i#f!^i#g!^i#h!^i#k!^i#r!^iU!^i$R!^i~Oy$yO{$yO~Oa${Ob${Oc${Oy$|O~OZ$aO#r#Ri~O$S%PO~O#r#Ri~P?jO!c%RO~O#r%TO~P5xO#r%TO$R#dO~O#r%VO~Oy%WO~O#r%XO~P*uO#o%ZO#r%[O~O#q#sOY#]ii#]ij#]ik#]il#]im#]in#]io#]ip#]iq#]i!k#]i#c#]i#d#]i#n#]i#s#]i#t#]i#u#]i#v#]i#w#]i#x#]i#y#]i#z#]i#{#]i#|#]i#}#]i$O#]i$P#]i$Q#]i~O#o%^O~O{%_O~O#q%`O~Of#[Og#]O#o#[O$R#Ui#r#Ui~O#r#Rq~P?jOU#eOZ%cO!X%dO#r#Rq~OdyOeyOf!q!Rg!q!Rh!q!R|!q!R!b!q!R!d!q!R!e!q!R!f!q!R!g!q!R#c!q!R#d!q!R#e!q!R#f!q!R#g!q!R#h!q!R#k!q!R#r!q!R#o!q!R~OdyOeyOf#Y!Rg#Y!Rh#Y!R|#Y!R!b#Y!R!d#Y!R!e#Y!R!f#Y!R!g#Y!R#c#Y!R#d#Y!R#e#Y!R#f#Y!R#g#Y!R#h#Y!R#k#Y!R#r#Y!R#o#Y!R~O#r%fO~P*uO#b$nO#r%hO~O{%iO~O#r%jO~Oy%kO~OZ$aO#r#Ry~OU#eO!X%dO!c%RO~OU$ZO~O#o%mO~O#r%nO~O{%pO~O#o%qO~O{%rO~O#r%sO~OP!^OQ!_OR!_OS!`OT!`OW%tOX!fOb!aOy!]O#q!dO~O!X%uO#oua~P)^O!X%uO#ouX~P#[Of&POh&PO|&TO!b&TO!d&TO!e&TO!f&TO!g&TO#c&QO#d&QO#e#[q#f#[q#g#[q#h#[q#o#[q~Og#[q~P!(QOf#[qg#[qh#[q~P!(WOg&OO~P!(QOf&POg&OOh&PO|&TO!b&TO!d&TO!e&TO!f&TO!g&TO#c&QO#d&QO#e&RO#f&RO#g&RO#h&SO~O#o#[q~P!)nO#c&QO#d&QO#o#[q~PHPO",
  goto: "/Y#kPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#l$k%S%r%uPPPPPP&U&h&x'W'iPP'xP'{'{(Q(T(Z(l(l(uPPPPPP(uP(lP'{'{)O)U)]*O*e*z*z*z*z*z*z*z*z*z*z*z*z*z*z+a+j+},Z,s,v-V*O-Y*O-o.e.v/P/SPPPPPPP*O*O[WORz!s#p$mQ#w!wQ#x!xS#y!y%zQ#z!zQ#{!{Q#|!|Q&U%xQ&V%yQ&W%{Q&X%|Q&Y%}R&Z!Tt]Oz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}RvRjQORz!T!s!w!x!y!z!{!|#p$mS!lx#kQ#h!m]%w%x%y%z%{%|%}RnPQmP^!cs!d#[#]#b$_%uR#P!VQuQQ#c!lQ$`#fQ$d#hQ%S$bR%v%w[tQ!l#f#h$b%w]!iu#c$`$d%S%virQu!l#c#f#h$`$b$d%S%v%whqQu!l#c#f#h$`$b$d%S%v%wR![qkpQqu!l#c#f#h$`$b$d%S%v%wR!ZpV!hs#b%uR#W!^Q#V!^R$x$TU!es#b%uQ#Z!dQ$V#[Q$W#]R%Q$__!cs!d#[#]#b$_%u_!bs!d#[#]#b$_%uQ#a!gR%o%tS#`!g%tR$z$Yj]O!w!x!y!z!{!|%x%y%z%{%|%}QwRQ!qzQ!}!TQ#q!sQ$l#pR%Y$mw[ORz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}wTORz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}wSORz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}Q!nxQ#i!mR$h#kS#f!l#hW$[#c#g$d$fQ%O$]Q%U$eR%b%TQ$b#fQ%O$[Q%a%UR%l%bQ#g!lS$]#c$dQ$c#fQ$f#hS%O$`$bS%a%S%UR%l%cR$}$ZQ{VQ$g#jQ$k#oQ%e%VR%f%XR#m!pwVORz!T!s!w!x!y!z!{!|#p$m%x%y%z%{%|%}Q!w|Q!x}Q!y!OQ!z!PQ!{!QQ!|!RQ%x&OQ%y&PQ%z&QQ%{&RQ%|&SR%}&Th!u|}!O!P!Q!R&O&P&Q&R&S&TR#v!vQ#t!tQ$r#uR%]$sR$o#sQ$p#sR%g%Z",
  nodeNames: "âš  Json Logfmt Unpack Pattern Regexp Unwrap Ip LabelFormat LineFormat LabelReplace Offset Bool On Ignoring GroupLeft GroupRight BytesConv DurationConv DurationSecondsConv By Without And Or Unless Sum Avg Count Max Min Stddev Stdvar Bottomk Topk LineComment LogQL Expr LogExpr Selector Matchers Matcher Identifier Eq String Neq Re Nre PipelineExpr PipelineStage LineFilters LineFilter Filter PipeExact PipeMatch FilterOp Pipe LabelParser JsonExpressionParser JsonExpressionList JsonExpression LabelFilter IpLabelFilter UnitFilter DurationFilter Gtr Duration Gte Lss Lte Eql BytesFilter Bytes NumberFilter Number LineFormatExpr LabelFormatExpr LabelsFormat LabelFormatMatcher MetricExpr RangeAggregationExpr RangeOp CountOverTime Rate BytesOverTime BytesRate AvgOverTime SumOverTime MinOverTime MaxOverTime StddevOverTime StdvarOverTime QuantileOverTime FirstOverTime LastOverTime AbsentOverTime LogRangeExpr Range OffsetExpr UnwrapExpr ConvOp Grouping Labels VectorAggregationExpr VectorOp BinOpExpr BinOpModifier OnOrIgnoringModifier GroupingLabels GroupingLabelList GroupingLabel LabelName Add Sub Mul Div Mod Pow LiteralExpr LabelReplaceExpr",
  maxTerm: 142,
  skippedNodes: [0,34],
  repeatNodeCount: 0,
  tokenData: "3{~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&{}!O'Q!O!P'V!P!Q(V!Q!R([!R![)r![!]0r!^!_1W!_!`1e!`!a1z!c!}2X!}#O2o#P#Q2t#Q#R2y#R#S2X#S#T3O#T#o2X#o#p3[#p#q3a#q#r3v#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY#m~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO|~~$tO!O~~$yU{~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO{~~%ePO~$t~%mQr~OY%hZ~%h~%xO#g~~%}U{~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO#q~~&qO#r~~&vO#e~~&{O#c~~'QO#o~~'VO#d~~'YP!Q![']~'bR!k~!Q![']!g!h'k#X#Y'k~'nR{|'w}!O'w!Q!['}~'zP!Q!['}~(SP!k~!Q!['}~([O#f~~(ae!k~!O!P']!Q![)r!g!h+V!i!j+t!m!n+t!o!p+t!r!s+t!v!w+t#U#V+i#W#X+}#X#Y.P#Z#[.c#[#],f#_#`.c#a#b.l#d#e.c#g#h-n#h#i.c#k#l.}#l#m0W#m#n/i~)wd!k~!O!P']!Q![)r!g!h+V!i!j+t!m!n+t!o!p+t!r!s+t!v!w+t#U#V+i#W#X+}#X#Y.P#Z#[.c#[#],f#_#`.c#a#b.l#d#e.c#g#h-n#h#i.c#k#l.}#m#n/i~+YT{|'w}!O'w!Q!['}!d!e+i#]#^+n~+nO!i~~+qP#U#V+i~+wQ!d!e+i#]#^+n~,SP!c~!Q![,V~,YS!Q![,V#[#],f#a#b,z#g#h-n~,kP!c~!Q![,n~,qR!Q![,n#a#b,z#g#h-n~-PQ!c~!Q![-V#g#h-i~-YR!Q![-V#a#b-c#g#h-n~-fP#g#h-i~-nO!c~~-sP!c~!Q![-v~-yQ!Q![-v#a#b-c~.ST{|'w}!O'w!Q!['}#U#V+i#]#^+n~.fQ#U#V+i#]#^+n~.qS!c~!Q![-V#U#V+i#]#^+n#g#h-i~/SP!c~!Q![/V~/YT!Q![/V#W#X+}#[#],f#a#b,z#g#h-n~/nP!c~!Q![/q~/tU!Q![/q#W#X+}#[#],f#a#b,z#g#h-n#k#l.}~0ZR!Q![0d!c!i0d#T#Z0d~0iR!k~!Q![0d!c!i0d#T#Z0dP0wTyP!Q![0r![!]0r!c!}0r#R#S0r#T#o0r~1]P!e~!_!`1`~1eO!f~~1jQz~!_!`1p#r#s1u~1uO!g~~1zO}~~2PP!b~!_!`2S~2XO!d~R2`TyP#bQ!Q![2X![!]0r!c!}2X#R#S2X#T#o2X~2tO$R~~2yO$S~~3OO#h~~3RRO#S3O#S#T%]#T~3O~3aO#n~~3fQ!X~!_!`3l#r#s3q~3qO!U~~3vO!V~~3{O#p~",
  tokenizers: [0, 1],
  topRules: {"LogQL":[0,35]},
  specialized: [{term: 41, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 41, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 41, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const Json = 1,
  Logfmt = 2,
  Unpack = 3,
  Pattern = 4,
  Regexp = 5,
  Unwrap = 6,
  Ip = 7,
  LabelFormat = 8,
  LineFormat = 9,
  LabelReplace = 10,
  Offset = 11,
  Bool = 12,
  On = 13,
  Ignoring = 14,
  GroupLeft = 15,
  GroupRight = 16,
  BytesConv = 17,
  DurationConv = 18,
  DurationSecondsConv = 19,
  By = 20,
  Without = 21,
  And = 22,
  Or = 23,
  Unless = 24,
  Sum = 25,
  Avg = 26,
  Count = 27,
  Max = 28,
  Min = 29,
  Stddev = 30,
  Stdvar = 31,
  Bottomk = 32,
  Topk = 33,
  LineComment = 34,
  LogQL = 35,
  Expr = 36,
  LogExpr = 37,
  Selector = 38,
  Matchers = 39,
  Matcher = 40,
  Identifier = 41,
  Eq = 42,
  String = 43,
  Neq = 44,
  Re = 45,
  Nre = 46,
  PipelineExpr = 47,
  PipelineStage = 48,
  LineFilters = 49,
  LineFilter = 50,
  Filter = 51,
  PipeExact = 52,
  PipeMatch = 53,
  FilterOp = 54,
  Pipe = 55,
  LabelParser = 56,
  JsonExpressionParser = 57,
  JsonExpressionList = 58,
  JsonExpression = 59,
  LabelFilter = 60,
  IpLabelFilter = 61,
  UnitFilter = 62,
  DurationFilter = 63,
  Gtr = 64,
  Duration = 65,
  Gte = 66,
  Lss = 67,
  Lte = 68,
  Eql = 69,
  BytesFilter = 70,
  Bytes = 71,
  NumberFilter = 72,
  Number = 73,
  LineFormatExpr = 74,
  LabelFormatExpr = 75,
  LabelsFormat = 76,
  LabelFormatMatcher = 77,
  MetricExpr = 78,
  RangeAggregationExpr = 79,
  RangeOp = 80,
  CountOverTime = 81,
  Rate = 82,
  BytesOverTime = 83,
  BytesRate = 84,
  AvgOverTime = 85,
  SumOverTime = 86,
  MinOverTime = 87,
  MaxOverTime = 88,
  StddevOverTime = 89,
  StdvarOverTime = 90,
  QuantileOverTime = 91,
  FirstOverTime = 92,
  LastOverTime = 93,
  AbsentOverTime = 94,
  LogRangeExpr = 95,
  Range = 96,
  OffsetExpr = 97,
  UnwrapExpr = 98,
  ConvOp = 99,
  Grouping = 100,
  Labels = 101,
  VectorAggregationExpr = 102,
  VectorOp = 103,
  BinOpExpr = 104,
  BinOpModifier = 105,
  OnOrIgnoringModifier = 106,
  GroupingLabels = 107,
  GroupingLabelList = 108,
  GroupingLabel = 109,
  LabelName = 110,
  Add = 111,
  Sub = 112,
  Mul = 113,
  Div = 114,
  Mod = 115,
  Pow = 116,
  LiteralExpr = 117,
  LabelReplaceExpr = 118;




/***/ }),

/***/ "./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Abs": () => (/* binding */ Abs),
/* harmony export */   "Absent": () => (/* binding */ Absent),
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Acos": () => (/* binding */ Acos),
/* harmony export */   "Acosh": () => (/* binding */ Acosh),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "AggregateExpr": () => (/* binding */ AggregateExpr),
/* harmony export */   "AggregateModifier": () => (/* binding */ AggregateModifier),
/* harmony export */   "AggregateOp": () => (/* binding */ AggregateOp),
/* harmony export */   "And": () => (/* binding */ And$1),
/* harmony export */   "Asin": () => (/* binding */ Asin),
/* harmony export */   "Asinh": () => (/* binding */ Asinh),
/* harmony export */   "At": () => (/* binding */ At),
/* harmony export */   "AtModifierPreprocessors": () => (/* binding */ AtModifierPreprocessors),
/* harmony export */   "Atan": () => (/* binding */ Atan),
/* harmony export */   "Atan2": () => (/* binding */ Atan2$1),
/* harmony export */   "Atanh": () => (/* binding */ Atanh),
/* harmony export */   "Avg": () => (/* binding */ Avg$1),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinModifiers": () => (/* binding */ BinModifiers),
/* harmony export */   "BinaryExpr": () => (/* binding */ BinaryExpr),
/* harmony export */   "Bool": () => (/* binding */ Bool$1),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk$1),
/* harmony export */   "By": () => (/* binding */ By$1),
/* harmony export */   "Ceil": () => (/* binding */ Ceil),
/* harmony export */   "Changes": () => (/* binding */ Changes),
/* harmony export */   "Clamp": () => (/* binding */ Clamp),
/* harmony export */   "ClampMax": () => (/* binding */ ClampMax),
/* harmony export */   "ClampMin": () => (/* binding */ ClampMin),
/* harmony export */   "Cos": () => (/* binding */ Cos),
/* harmony export */   "Cosh": () => (/* binding */ Cosh),
/* harmony export */   "Count": () => (/* binding */ Count$1),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "CountValues": () => (/* binding */ CountValues$1),
/* harmony export */   "DayOfMonth": () => (/* binding */ DayOfMonth),
/* harmony export */   "DayOfWeek": () => (/* binding */ DayOfWeek),
/* harmony export */   "DaysInMonth": () => (/* binding */ DaysInMonth),
/* harmony export */   "Deg": () => (/* binding */ Deg),
/* harmony export */   "Delta": () => (/* binding */ Delta),
/* harmony export */   "Deriv": () => (/* binding */ Deriv),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "End": () => (/* binding */ End$1),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "EqlRegex": () => (/* binding */ EqlRegex),
/* harmony export */   "EqlSingle": () => (/* binding */ EqlSingle),
/* harmony export */   "Exp": () => (/* binding */ Exp),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Floor": () => (/* binding */ Floor),
/* harmony export */   "FunctionCall": () => (/* binding */ FunctionCall),
/* harmony export */   "FunctionCallArgs": () => (/* binding */ FunctionCallArgs),
/* harmony export */   "FunctionCallBody": () => (/* binding */ FunctionCallBody),
/* harmony export */   "FunctionIdentifier": () => (/* binding */ FunctionIdentifier),
/* harmony export */   "Group": () => (/* binding */ Group$1),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft$1),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight$1),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "HistogramQuantile": () => (/* binding */ HistogramQuantile),
/* harmony export */   "HoltWinters": () => (/* binding */ HoltWinters),
/* harmony export */   "Hour": () => (/* binding */ Hour),
/* harmony export */   "Idelta": () => (/* binding */ Idelta),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring$1),
/* harmony export */   "Increase": () => (/* binding */ Increase),
/* harmony export */   "Irate": () => (/* binding */ Irate),
/* harmony export */   "LabelJoin": () => (/* binding */ LabelJoin),
/* harmony export */   "LabelMatchList": () => (/* binding */ LabelMatchList),
/* harmony export */   "LabelMatcher": () => (/* binding */ LabelMatcher),
/* harmony export */   "LabelMatchers": () => (/* binding */ LabelMatchers),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "Ln": () => (/* binding */ Ln),
/* harmony export */   "Log10": () => (/* binding */ Log10),
/* harmony export */   "Log2": () => (/* binding */ Log2),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "MatchOp": () => (/* binding */ MatchOp),
/* harmony export */   "MatrixSelector": () => (/* binding */ MatrixSelector),
/* harmony export */   "Max": () => (/* binding */ Max$1),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricIdentifier": () => (/* binding */ MetricIdentifier),
/* harmony export */   "MetricName": () => (/* binding */ MetricName),
/* harmony export */   "Min": () => (/* binding */ Min$1),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Minute": () => (/* binding */ Minute),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Month": () => (/* binding */ Month),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "NeqRegex": () => (/* binding */ NeqRegex),
/* harmony export */   "NumberLiteral": () => (/* binding */ NumberLiteral),
/* harmony export */   "Offset": () => (/* binding */ Offset$1),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On$1),
/* harmony export */   "OnOrIgnoring": () => (/* binding */ OnOrIgnoring),
/* harmony export */   "Or": () => (/* binding */ Or$1),
/* harmony export */   "ParenExpr": () => (/* binding */ ParenExpr),
/* harmony export */   "Pi": () => (/* binding */ Pi),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "PredictLinear": () => (/* binding */ PredictLinear),
/* harmony export */   "PresentOverTime": () => (/* binding */ PresentOverTime),
/* harmony export */   "PromQL": () => (/* binding */ PromQL),
/* harmony export */   "Quantile": () => (/* binding */ Quantile$1),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Rad": () => (/* binding */ Rad),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Resets": () => (/* binding */ Resets),
/* harmony export */   "Round": () => (/* binding */ Round),
/* harmony export */   "Scalar": () => (/* binding */ Scalar),
/* harmony export */   "Sgn": () => (/* binding */ Sgn),
/* harmony export */   "Sin": () => (/* binding */ Sin),
/* harmony export */   "Sinh": () => (/* binding */ Sinh),
/* harmony export */   "Sort": () => (/* binding */ Sort),
/* harmony export */   "SortDesc": () => (/* binding */ SortDesc),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "Start": () => (/* binding */ Start$1),
/* harmony export */   "Stddev": () => (/* binding */ Stddev$1),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar$1),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "StepInvariantExpr": () => (/* binding */ StepInvariantExpr),
/* harmony export */   "StringLiteral": () => (/* binding */ StringLiteral),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "SubqueryExpr": () => (/* binding */ SubqueryExpr),
/* harmony export */   "Sum": () => (/* binding */ Sum$1),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Tan": () => (/* binding */ Tan),
/* harmony export */   "Tanh": () => (/* binding */ Tanh),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "Timestamp": () => (/* binding */ Timestamp),
/* harmony export */   "Topk": () => (/* binding */ Topk$1),
/* harmony export */   "UnaryExpr": () => (/* binding */ UnaryExpr),
/* harmony export */   "UnaryOp": () => (/* binding */ UnaryOp),
/* harmony export */   "Unless": () => (/* binding */ Unless$1),
/* harmony export */   "Vector": () => (/* binding */ Vector),
/* harmony export */   "VectorSelector": () => (/* binding */ VectorSelector),
/* harmony export */   "Without": () => (/* binding */ Without$1),
/* harmony export */   "Year": () => (/* binding */ Year),
/* harmony export */   "inf": () => (/* binding */ inf$1),
/* harmony export */   "nan": () => (/* binding */ nan$1),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf = 146,
  nan = 147,
  Bool = 1,
  Ignoring = 2,
  On = 3,
  GroupLeft = 4,
  GroupRight = 5,
  Offset = 6,
  Atan2 = 7,
  Avg = 8,
  Bottomk = 9,
  Count = 10,
  CountValues = 11,
  Group = 12,
  Max = 13,
  Min = 14,
  Quantile = 15,
  Stddev = 16,
  Stdvar = 17,
  Sum = 18,
  Topk = 19,
  By = 20,
  Without = 21,
  And = 22,
  Or = 23,
  Unless = 24,
  Start = 25,
  End = 26;

// Copyright 2021 The Prometheus Authors

const keywordTokens = {
    inf: inf,
    nan: nan,
    bool: Bool,
    ignoring: Ignoring,
    on: On,
    group_left: GroupLeft,
    group_right: GroupRight,
    offset: Offset,
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};

const contextualKeywordTokens = {
    avg: Avg,
    atan2: Atan2,
    bottomk: Bottomk,
    count: Count,
    count_values: CountValues,
    group: Group,
    max: Max,
    min: Min,
    quantile: Quantile,
    stddev: Stddev,
    stdvar: Stdvar,
    sum: Sum,
    topk: Topk,
    by: By,
    without: Without,
    and: And,
    or: Or,
    unless: Unless,
    start: Start,
    end: End,
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,absent_over_time:307, absent:309, abs:311, acos:313, acosh:315, asin:317, asinh:319, atan:321, atanh:323, avg_over_time:325, ceil:327, changes:329, clamp:331, clamp_max:333, clamp_min:335, cos:337, cosh:339, count_over_time:341, days_in_month:343, day_of_month:345, day_of_week:347, deg:349, delta:351, deriv:353, exp:355, floor:357, histogram_quantile:359, holt_winters:361, hour:363, idelta:365, increase:367, irate:369, label_replace:371, label_join:373, last_over_time:375, ln:377, log10:379, log2:381, max_over_time:383, min_over_time:385, minute:387, month:389, pi:391, predict_linear:393, present_over_time:395, quantile_over_time:397, rad:399, rate:401, resets:403, round:405, scalar:407, sgn:409, sin:411, sinh:413, sort:415, sort_desc:417, sqrt:419, stddev_over_time:421, stdvar_over_time:423, sum_over_time:425, tan:427, tanh:429, timestamp:431, time:433, vector:435, year:437};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "6[OYQPOOO&{QPOOOOQO'#C{'#C{O'QQPO'#CzQ']QQOOOOQO'#De'#DeO'WQPO'#DdOOQO'#E}'#E}O(jQPO'#FTOYQPO'#FPOYQPO'#FSOOQO'#FV'#FVO.fQSO'#FWO.nQQO'#FUOOQO'#FU'#FUOOQO'#Cy'#CyOOQO'#Df'#DfOOQO'#Dh'#DhOOQO'#Di'#DiOOQO'#Dj'#DjOOQO'#Dk'#DkOOQO'#Dl'#DlOOQO'#Dm'#DmOOQO'#Dn'#DnOOQO'#Do'#DoOOQO'#Dp'#DpOOQO'#Dq'#DqOOQO'#Dr'#DrOOQO'#Ds'#DsOOQO'#Dt'#DtOOQO'#Du'#DuOOQO'#Dv'#DvOOQO'#Dw'#DwOOQO'#Dx'#DxOOQO'#Dy'#DyOOQO'#Dz'#DzOOQO'#D{'#D{OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^OOQO'#E_'#E_OOQO'#E`'#E`OOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO'#Ee'#EeOOQO'#Ef'#EfOOQO'#Eg'#EgOOQO'#Eh'#EhOOQO'#Ei'#EiOOQO'#Ej'#EjOOQO'#Ek'#EkOOQO'#El'#ElOOQO'#Em'#EmOOQO'#En'#EnOOQO'#Eo'#EoOOQO'#Ep'#EpOOQO'#Eq'#EqOOQO'#Er'#ErOOQO'#Es'#EsOOQO'#Et'#EtOOQO'#Eu'#EuOOQO'#Ev'#EvOOQO'#Ew'#EwOOQO'#Ex'#ExOOQO'#Ey'#EyOOQO'#Ez'#EzQOQPOOO0XQPO'#C|O0^QPO'#DRO'WQPO,59fO0eQQO,59fO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO7}QQO,5;gO8SQQO,5;jO8[QPO,5;yOOQO,5:O,5:OOOQO,5;i,5;iO8sQQO,5;kO8zQQO,5;nO:bQPO'#FYO:pQPO,5;rOOQO'#FX'#FXOOQO,5;r,5;rOOQO,5;p,5;pO:xQSO'#C}OOQO,59h,59hO;QQPO,59mO;YQQO'#DSOOQO,59m,59mOOQO1G/Q1G/QO0XQPO'#DWOAVQPO'#DVOAaQPO'#DVOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOAkQSO1G1ROOQO1G1U1G1UOAsQQO1G1UOAxQPO'#E}OOQO'#Fa'#FaOOQO1G1e1G1eOBTQPO1G1eOOQO1G1V1G1VOOQO'#FZ'#FZOBYQPO,5;tOB_QSO1G1^OOQO1G1^1G1^OOQO'#DP'#DPOBgQPO,59iOOQO'#DO'#DOOOQO,59i,59iOYQPO,59nOOQO1G/X1G/XOOQO,59r,59rOH_QPO,59qOHfQPO,59qOI}QQO7+$uOJ_QQO7+$uOKsQQO7+$uOLZQQO7+$uOMrQQO7+$uOOQO7+&m7+&mON]QQO7+&sOOQO7+&p7+&pONeQPO7+'POOQO1G1`1G1`OOQO1G1_1G1_OOQO7+&x7+&xONjQSO1G/TOOQO1G/T1G/TONrQQO1G/YOOQO1G/]1G/]ON|QPO1G/]OOQO<<J_<<J_O!&oQPO<<J_OOQO<<Jk<<JkOOQO1G/U1G/UOOQO7+$o7+$oOOQO7+$w7+$wOOQOAN?yAN?y",
  stateData: "!&t~O$ZOSkOS~OWQOXQOYQOZQO[QO]QO^QO_QO`QOaQObQOcQO!ZZO#t_O$WVO$XVO$[XO$_`O$`aO$abO$bcO$cdO$deO$efO$fgO$ghO$hiO$ijO$jkO$klO$lmO$mnO$noO$opO$pqO$qrO$rsO$stO$tuO$uvO$vwO$wxO$xyO$yzO$z{O${|O$|}O$}!OO%O!PO%P!QO%Q!RO%R!SO%S!TO%T!UO%U!VO%V!WO%W!XO%X!YO%Y!ZO%Z![O%[!]O%]!^O%^!_O%_!`O%`!aO%a!bO%b!cO%c!dO%d!eO%e!fO%f!gO%g!hO%h!iO%i!jO%j!kO%k!lO%l!mO%m!nO%n!oO%o!pO%p!qO%q!rO%r!sO%uWO%vWO%wVO%y[O~O!ZZO~Od!uOe!uO$[!vO~OU#POV!yOf!|Og!}Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O$S#QO%s#OO~O$W#SO$X#SO%w#SOW#wXX#wXY#wXZ#wX[#wX]#wX^#wX_#wX`#wXa#wXb#wXc#wX!Z#wX#t#wX$W#wX$X#wX$[#wX$_#wX$`#wX$a#wX$b#wX$c#wX$d#wX$e#wX$f#wX$g#wX$h#wX$i#wX$j#wX$k#wX$l#wX$m#wX$n#wX$o#wX$p#wX$q#wX$r#wX$s#wX$t#wX$u#wX$v#wX$w#wX$x#wX$y#wX$z#wX${#wX$|#wX$}#wX%O#wX%P#wX%Q#wX%R#wX%S#wX%T#wX%U#wX%V#wX%W#wX%X#wX%Y#wX%Z#wX%[#wX%]#wX%^#wX%_#wX%`#wX%a#wX%b#wX%c#wX%d#wX%e#wX%f#wX%g#wX%h#wX%i#wX%j#wX%k#wX%l#wX%m#wX%n#wX%o#wX%p#wX%q#wX%r#wX%u#wX%v#wX%w#wX%y#wX~Ot#VO%z#YO~O%y[OU#xXV#xXf#xXg#xXh#xXx#xX{#xX|#xX}#xX!O#xX!P#xX!Q#xX!R#xX!S#xX!T#xX!U#xX!V#xX$S#xX$V#xX%s#xX$^#xX$]#xX~O$[#[O~O$^#`O~PYOd!uOe!uOUnaVnafnagnahnaxna{na|na}na!Ona!Pna!Qna!Rna!Sna!Tna!Una!Vna$Sna$Vna%sna$^na$]na~OP#dOQ#bOR#bOWyPXyPYyPZyP[yP]yP^yP_yP`yPayPbyPcyP!ZyP#tyP$WyP$XyP$[yP$_yP$`yP$ayP$byP$cyP$dyP$eyP$fyP$gyP$hyP$iyP$jyP$kyP$lyP$myP$nyP$oyP$pyP$qyP$ryP$syP$tyP$uyP$vyP$wyP$xyP$yyP$zyP${yP$|yP$}yP%OyP%PyP%QyP%RyP%SyP%TyP%UyP%VyP%WyP%XyP%YyP%ZyP%[yP%]yP%^yP%_yP%`yP%ayP%byP%cyP%dyP%eyP%fyP%gyP%hyP%iyP%jyP%kyP%lyP%myP%nyP%oyP%pyP%qyP%ryP%uyP%vyP%wyP%yyP~O#p#jO~O!P#lO#p#kO~Oi#nOj#nO$WVO$XVO%u#mO%v#mO%wVO~O$^#qO~P']Ox!yOU#vaV#vaf#vag#vah#va{#va|#va}#va!O#va!P#va!Q#va!R#va!S#va!T#va!U#va!V#va$S#va$V#va%s#va$^#va$]#va~O!V#rO$O#rO$P#rO$Q#rO~O$]#tO%z#uO~Ot#vO$^#yO~O$]#zO$^#{O~O$]vX$^vX~P']OWyXXyXYyXZyX[yX]yX^yX_yX`yXayXbyXcyX!ZyX#tyX$WyX$XyX$[yX$_yX$`yX$ayX$byX$cyX$dyX$eyX$fyX$gyX$hyX$iyX$jyX$kyX$lyX$myX$nyX$oyX$pyX$qyX$ryX$syX$tyX$uyX$vyX$wyX$xyX$yyX$zyX${yX$|yX$}yX%OyX%PyX%QyX%RyX%SyX%TyX%UyX%VyX%WyX%XyX%YyX%ZyX%[yX%]yX%^yX%_yX%`yX%ayX%byX%cyX%dyX%eyX%fyX%gyX%hyX%iyX%jyX%kyX%lyX%myX%nyX%oyX%pyX%qyX%ryX%uyX%vyX%wyX%yyX~OS#}OT#}O~P;dOQ#bOR#bO~P;dO%t$UO%x$VO~O#p$WO~O$W#SO$X#SO%w#SO~O$[$XO~O#t$YO~Ot#VO%z$[O~O$]$]O$^$^O~OWyaXyaYyaZya[ya]ya^ya_ya`yaayabyacya!Zya#tya$Wya$Xya$_ya$`ya$aya$bya$cya$dya$eya$fya$gya$hya$iya$jya$kya$lya$mya$nya$oya$pya$qya$rya$sya$tya$uya$vya$wya$xya$yya$zya${ya$|ya$}ya%Oya%Pya%Qya%Rya%Sya%Tya%Uya%Vya%Wya%Xya%Yya%Zya%[ya%]ya%^ya%_ya%`ya%aya%bya%cya%dya%eya%fya%gya%hya%iya%jya%kya%lya%mya%nya%oya%pya%qya%rya%uya%vya%wya%yya~O$[#[O~PBoOS$aOT$aO$[ya~PBoOx!yOUwqfwqgwqhwq!Owq!Pwq!Qwq!Rwq!Swq!Twq!Uwq!Vwq$Swq$Vwq%swq$^wq$]wq~OVwq{wq|wq}wq~PHsOV!yO{!yO|!yO}!yO~PHsOV!yOx!yO{!yO|!yO}!yO!O!zO!P!zOUwqfwqgwqhwq$Swq$Vwq%swq$^wq$]wq~O!Qwq!Rwq!Swq!Twq!Uwq!Vwq~PJoO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~PJoOV!yOf!|Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~OUwqgwq$Swq$Vwq%swq$^wq$]wq~PLqO#p$cO%t$bO~O$^$dO~Ot#vO$^$fO~O$]vi$^vi~P']O$[#[OWyiXyiYyiZyi[yi]yi^yi_yi`yiayibyicyi!Zyi#tyi$Wyi$Xyi$_yi$`yi$ayi$byi$cyi$dyi$eyi$fyi$gyi$hyi$iyi$jyi$kyi$lyi$myi$nyi$oyi$pyi$qyi$ryi$syi$tyi$uyi$vyi$wyi$xyi$yyi$zyi${yi$|yi$}yi%Oyi%Pyi%Qyi%Ryi%Syi%Tyi%Uyi%Vyi%Wyi%Xyi%Yyi%Zyi%[yi%]yi%^yi%_yi%`yi%ayi%byi%cyi%dyi%eyi%fyi%gyi%hyi%iyi%jyi%kyi%lyi%myi%nyi%oyi%pyi%qyi%ryi%uyi%vyi%wyi%yyi~O%t$hO~O",
  goto: "(u$UPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$V$u%R%_%e%q%tP%z&T$uP&W&gPPPPPPPPPPP$u&q&}P&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}$uP'Z$u$uP$u$u'j$u'v(V(f(i(oPPP$uP(rQSOQ#TXQ#UYQ#_!vQ$P#eQ$Q#fQ$R#gQ$S#hQ$T#iR$_#ze_OXY!v#e#f#g#h#i#zeROXY!v#e#f#g#h#i#zQ!wRR#a!xQ#]!uQ#|#bQ$`#}R$g$aR#w#[Q#x#[R$e$]Q!xRQ#RUR#a!wR#^!vQ#e!yQ#f!zQ#g!{Q#h!|R#i!}Y#c!y!z!{!|!}R$O#deUOXY!v#e#f#g#h#i#zeTOXY!v#e#f#g#h#i#zd_OXY!v#e#f#g#h#i#zR#o#QeYOXY!v#e#f#g#h#i#zd]OXY!v#e#f#g#h#i#zR!tPd^OXY!v#e#f#g#h#i#zR#Z]R#W[Q#X[R$Z#tR#s#VR#p#Q",
  nodeNames: "âš  Bool Ignoring On GroupLeft GroupRight Offset Atan2 Avg Bottomk Count CountValues Group Max Min Quantile Stddev Stdvar Sum Topk By Without And Or Unless Start End LineComment PromQL Expr AggregateExpr AggregateOp AggregateModifier GroupingLabels GroupingLabelList GroupingLabel LabelName FunctionCallBody FunctionCallArgs BinaryExpr Pow BinModifiers OnOrIgnoring Mul Div Mod Add Sub Eql Gte Gtr Lte Lss Neq FunctionCall FunctionIdentifier AbsentOverTime Identifier Absent Abs Acos Acosh Asin Asinh Atan Atanh AvgOverTime Ceil Changes Clamp ClampMax ClampMin Cos Cosh CountOverTime DaysInMonth DayOfMonth DayOfWeek Deg Delta Deriv Exp Floor HistogramQuantile HoltWinters Hour Idelta Increase Irate LabelReplace LabelJoin LastOverTime Ln Log10 Log2 MaxOverTime MinOverTime Minute Month Pi PredictLinear PresentOverTime QuantileOverTime Rad Rate Resets Round Scalar Sgn Sin Sinh Sort SortDesc Sqrt StddevOverTime StdvarOverTime SumOverTime Tan Tanh Timestamp Time Vector Year MatrixSelector Duration NumberLiteral OffsetExpr ParenExpr StringLiteral SubqueryExpr UnaryExpr UnaryOp VectorSelector MetricIdentifier LabelMatchers LabelMatchList LabelMatcher MatchOp EqlSingle EqlRegex NeqRegex StepInvariantExpr At AtModifierPreprocessors MetricName",
  maxTerm: 226,
  skippedNodes: [0,27],
  repeatNodeCount: 0,
  tokenData: "1R~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&}}!O'S!O!P'Z!P!Q(Z!Q!R(`!R![)W![!]-r!^!_.n!_!`.{!`!a/b!b!c/o!c!}/t!}#O0[#P#Q0a#Q#R0f#R#S/t#S#T0k#T#o/t#o#p0w#q#r0|#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY$Z~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO!V~~$tO$Q~~$yU#t~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO#t~~%ePO~$t~%mQk~OY%hZ~%h~%xO}~~%}U#t~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO$[~~&qO$^~~&vO{~R&}O%vP!OQ~'SO$]~R'ZO%uP!PQP'^P!Q!['aP'fR%wP!Q!['a!g!h'o#X#Y'oP'rR{|'{}!O'{!Q![(RP(OP!Q![(RP(WP%wP!Q![(R~(`O|~R(eZ%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#l#m-W#m#n,iR)]Y%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#m#n,iQ*QP#pQ!Q![*TQ*WS!Q![*T#[#]*d#a#b*x#g#h+lQ*iP#pQ!Q![*lQ*oR!Q![*l#a#b*x#g#h+lQ*}Q#pQ!Q![+T#g#h+gQ+WR!Q![+T#a#b+a#g#h+lQ+dP#g#h+gQ+lO#pQQ+qP#pQ!Q![+tQ+wQ!Q![+t#a#b+aQ,SP#pQ!Q![,VQ,YT!Q![,V#W#X){#[#]*d#a#b*x#g#h+lQ,nP#pQ!Q![,qQ,tU!Q![,q#W#X){#[#]*d#a#b*x#g#h+l#k#l+}P-ZR!Q![-d!c!i-d#T#Z-dP-iR%wP!Q![-d!c!i-d#T#Z-dV-yT%xS!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.YR._T!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.Y~.sP!U~!_!`.v~.{O!T~~/QQ$OP!_!`/W#r#s/]Q/]O!QQ~/bO$P~~/gP!S~!_!`/j~/oO!R~~/tO$S~V/{T!ZRtS!Q![/t![!].Y!c!}/t#R#S/t#T#o/t~0aO%s~~0fO%t~~0kOx~~0nRO#S0k#S#T%]#T~0k~0|O%y~~1RO%z~",
  tokenizers: [0, 1, 2],
  topRules: {"PromQL":[0,28],"MetricName":[1,144]},
  specialized: [{term: 57, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 57, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 57, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf$1 = 146,
  nan$1 = 147,
  Bool$1 = 1,
  Ignoring$1 = 2,
  On$1 = 3,
  GroupLeft$1 = 4,
  GroupRight$1 = 5,
  Offset$1 = 6,
  Atan2$1 = 7,
  Avg$1 = 8,
  Bottomk$1 = 9,
  Count$1 = 10,
  CountValues$1 = 11,
  Group$1 = 12,
  Max$1 = 13,
  Min$1 = 14,
  Quantile$1 = 15,
  Stddev$1 = 16,
  Stdvar$1 = 17,
  Sum$1 = 18,
  Topk$1 = 19,
  By$1 = 20,
  Without$1 = 21,
  And$1 = 22,
  Or$1 = 23,
  Unless$1 = 24,
  Start$1 = 25,
  End$1 = 26,
  LineComment = 27,
  PromQL = 28,
  Expr = 29,
  AggregateExpr = 30,
  AggregateOp = 31,
  AggregateModifier = 32,
  GroupingLabels = 33,
  GroupingLabelList = 34,
  GroupingLabel = 35,
  LabelName = 36,
  FunctionCallBody = 37,
  FunctionCallArgs = 38,
  BinaryExpr = 39,
  Pow = 40,
  BinModifiers = 41,
  OnOrIgnoring = 42,
  Mul = 43,
  Div = 44,
  Mod = 45,
  Add = 46,
  Sub = 47,
  Eql = 48,
  Gte = 49,
  Gtr = 50,
  Lte = 51,
  Lss = 52,
  Neq = 53,
  FunctionCall = 54,
  FunctionIdentifier = 55,
  AbsentOverTime = 56,
  Identifier = 57,
  Absent = 58,
  Abs = 59,
  Acos = 60,
  Acosh = 61,
  Asin = 62,
  Asinh = 63,
  Atan = 64,
  Atanh = 65,
  AvgOverTime = 66,
  Ceil = 67,
  Changes = 68,
  Clamp = 69,
  ClampMax = 70,
  ClampMin = 71,
  Cos = 72,
  Cosh = 73,
  CountOverTime = 74,
  DaysInMonth = 75,
  DayOfMonth = 76,
  DayOfWeek = 77,
  Deg = 78,
  Delta = 79,
  Deriv = 80,
  Exp = 81,
  Floor = 82,
  HistogramQuantile = 83,
  HoltWinters = 84,
  Hour = 85,
  Idelta = 86,
  Increase = 87,
  Irate = 88,
  LabelReplace = 89,
  LabelJoin = 90,
  LastOverTime = 91,
  Ln = 92,
  Log10 = 93,
  Log2 = 94,
  MaxOverTime = 95,
  MinOverTime = 96,
  Minute = 97,
  Month = 98,
  Pi = 99,
  PredictLinear = 100,
  PresentOverTime = 101,
  QuantileOverTime = 102,
  Rad = 103,
  Rate = 104,
  Resets = 105,
  Round = 106,
  Scalar = 107,
  Sgn = 108,
  Sin = 109,
  Sinh = 110,
  Sort = 111,
  SortDesc = 112,
  Sqrt = 113,
  StddevOverTime = 114,
  StdvarOverTime = 115,
  SumOverTime = 116,
  Tan = 117,
  Tanh = 118,
  Timestamp = 119,
  Time = 120,
  Vector = 121,
  Year = 122,
  MatrixSelector = 123,
  Duration = 124,
  NumberLiteral = 125,
  OffsetExpr = 126,
  ParenExpr = 127,
  StringLiteral = 128,
  SubqueryExpr = 129,
  UnaryExpr = 130,
  UnaryOp = 131,
  VectorSelector = 132,
  MetricIdentifier = 133,
  LabelMatchers = 134,
  LabelMatchList = 135,
  LabelMatcher = 136,
  MatchOp = 137,
  EqlSingle = 138,
  EqlRegex = 139,
  NeqRegex = 140,
  StepInvariantExpr = 141,
  At = 142,
  AtModifierPreprocessors = 143,
  MetricName = 144;




/***/ }),

/***/ "./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultBufferLength": () => (/* binding */ DefaultBufferLength),
/* harmony export */   "MountedTree": () => (/* binding */ MountedTree),
/* harmony export */   "NodeProp": () => (/* binding */ NodeProp),
/* harmony export */   "NodeSet": () => (/* binding */ NodeSet),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "Tree": () => (/* binding */ Tree),
/* harmony export */   "TreeBuffer": () => (/* binding */ TreeBuffer),
/* harmony export */   "TreeCursor": () => (/* binding */ TreeCursor),
/* harmony export */   "TreeFragment": () => (/* binding */ TreeFragment),
/* harmony export */   "parseMixed": () => (/* binding */ parseMixed)
/* harmony export */ });
// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node (1024).
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.
class NodeProp {
    /// Create a new node prop type.
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.
NodeProp.contextHash = new NodeProp({ perNode: true });
/// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)
NodeProp.lookAhead = new NodeProp({ perNode: true });
/// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages.
NodeProp.mounted = new NodeProp({ perNode: true });
/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.
class MountedTree {
    constructor(
    /// The inner tree.
    tree, 
    /// If this is null, this tree replaces the entire node (it will
    /// be included in the regular iteration instead of its host
    /// node). If not, only the given ranges are considered to be
    /// covered by this tree. This is used for trees that are mixed in
    /// a way that isn't strictly hierarchical. Such mounted trees are
    /// only entered by [`resolveInner`](#common.Tree.resolveInner)
    /// and [`enter`](#common.SyntaxNode.enter).
    overlay, 
    /// The parser used to create this subtree.
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
}
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#common.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#common.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.
class Tree {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    constructor(
    /// The type of the top node.
    type, 
    /// This node's child nodes.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length, 
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /// @internal
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /// @internal
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular
    /// cursors, doesn't skip through
    /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't
    /// automatically enter mounted nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, 1 /* Full */);
    }
    /// Get a [syntax node](#common.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#common.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /// Like [`resolve`](#common.Tree.resolve), but will enter
    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    /// pointing into the innermost overlaid tree at the given position
    /// (with parent links going through all parent structure, including
    /// the host trees).
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, that node will
    /// not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor(), get = () => c.node;;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to, get);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Get the value of the given [node prop](#common.NodeProp) for this
    /// node. Works with both per-node and per-type props.
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
    /// format that can be passed to the [`Tree`](#common.Tree)
    /// constructor.
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /// Balance the direct children of this tree, producing a copy of
    /// which may have children grouped into subtrees with type
    /// [`NodeType.none`](#common.NodeType^none).
    balance(config = {}) {
        return this.children.length <= 8 /* BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer.
    constructor(
    /// The buffer's content.
    buffer, 
    /// The total length of the group of nodes in the buffer.
    length, 
    /// The node set used in this buffer.
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /// @internal
    get type() { return NodeType.none; }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /// @internal
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI);
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
        }
        return new TreeBuffer(copy, to - from, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Before */: return from < pos;
        case -1 /* AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Around */: return from < pos && to > pos;
        case 1 /* AtOrAfter */: return from <= pos && to > pos;
        case 2 /* After */: return to > pos;
        case 4 /* DontCare */: return true;
    }
}
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
            break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        }
        else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, overlays);
        if (!inner)
            return node;
        node = inner;
    }
}
class TreeNode {
    constructor(node, _from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        this.node = node;
        this._from = _from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get from() { return this._from; }
    get to() { return this._from + this.node.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent._from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & 2 /* NoEnterBuffer */)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & 1 /* Full */) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent.node.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }
    enter(pos, side, overlays = true, buffers = true) {
        let mounted;
        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return this.node; }
    toTree() { return this.node; }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }
    enter(pos, side, overlays, buffers = true) {
        if (!buffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, 
    /// @internal
    mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }
    /// Move the cursor to the first child that ends after `pos`.
    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }
    /// Move to the last child that starts before `pos`.
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }
    /// Move the cursor to the child around `pos`. If side is -1 the
    /// child may end at that position, when 1 it may start there. This
    /// will also enter [overlaid](#common.MountedTree.overlay)
    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    /// set to false.
    enter(pos, side, overlays = true, buffers = true) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1 /* Full */), buffers));
        return buffers ? this.enterChild(1, pos, side) : false;
    }
    /// Move to the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                    let child = parent.node.children[i];
                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty or `enter` is false, its next sibling or
    /// the next sibling of the first parent node that has one.
    next(enter = true) { return this.move(1, enter); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by its last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev(enter = true) { return this.move(-1, enter); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#common.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#common.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}

/// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.
class TreeFragment {
    /// Construct a tree fragment.
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    /// Whether the end of the fragment represents the end of a
    /// full-document parse, or the start of a change.
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the resulting
    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    /// true.
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/// A superclass that parsers should extend.
class Parser {
    /// Start a parse, returning a [partial parse](#common.PartialParse)
    /// object. [`fragments`](#common.TreeFragment) can be passed in to
    /// make the parse incremental.
    ///
    /// By default, the entire input is parsed. You can pass `ranges`,
    /// which should be a sorted array of non-empty, non-overlapping
    /// ranges, to parse only those ranges. The tree returned in that
    /// case will start at `ranges[0].from`.
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /// Run a full parse, returning the resulting tree.
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
///
/// The nesting function is passed a cursor to provide context for a
/// node, but _should not_ move that cursor, only inspect its
/// properties and optionally access its
/// [node object](#common.TreeCursor.node).
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, ranges) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);
        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Full */;
            }
            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                    if (ranges.length)
                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length)
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;
    }
    return 0 /* None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, depth = 0;
    // Scan up to the nearest tree
    do {
        cursor.parent();
        depth++;
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let i = 0, base = cursor.tree, off = 0;
    for (;; i++) {
        off = base.positions[i] + cursor.from;
        if (off <= node.from && off + base.children[i].length >= node.to)
            break;
    }
    let buf = base.children[i], b = buf.buffer;
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length) {
        let i = startI;
        while (b[i + 2] + off <= node.from)
            i = b[i + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i, children, positions, innerOffset);
        let from = b[i + 1], to = b[i + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    // Move the cursor back to the target node
    for (let d = 0; d <= depth; d++)
        cursor.childAfter(node.from);
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.fullCursor();
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
        }
    }
    return result;
}




/***/ }),

/***/ "./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextTracker": () => (/* binding */ ContextTracker),
/* harmony export */   "ExternalTokenizer": () => (/* binding */ ExternalTokenizer),
/* harmony export */   "InputStream": () => (/* binding */ InputStream),
/* harmony export */   "LRParser": () => (/* binding */ LRParser),
/* harmony export */   "Stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js");


/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// The parse that this stack is part of @internal
    p, 
    /// Holds state, input pos, buffer index triplets for all but the
    /// top state @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    /// @internal
    curContext, 
    /// @internal
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /// The stack's current [context](#lr.ContextTracker) value, if
    /// any. Its type will depend on the context tracker's type
    /// parameter, or it will be `null` if there is no context
    /// tracker.
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.p;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special caseâ€”they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        let start = this.pos;
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /// @internal
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Delete */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(s, this.pos);
            stack.shiftContext(nextStates[i], this.pos);
            stack.score -= 200 /* Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        let { parser } = this.p;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
                return false;
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.p.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /// @internal
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    /// @internal
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /// @internal
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /// @internal
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
var Recover;
(function (Recover) {
    Recover[Recover["Insert"] = 200] = "Insert";
    Recover[Recover["Delete"] = 190] = "Delete";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/// [Tokenizers](#lr.ExternalTokenizer) interact with the input
/// through this interface. It presents the input as a stream of
/// characters, tracking lookahead and hiding the complexity of
/// [ranges](#common.Parser.parse^ranges) from tokenizer code.
class InputStream {
    /// @internal
    constructor(
    /// @internal
    input, 
    /// @internal
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /// @internal
        this.chunk = "";
        /// @internal
        this.chunkOff = 0;
        /// Backup chunk
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /// The character code of the next code unit in the input, or -1
        /// when the stream is at the end of the input.
        this.next = -1;
        /// @internal
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /// Look at a code unit near the stream position. `.peek(0)` equals
    /// `.next`, `.peek(-1)` gives you the previous character, and so
    /// on.
    ///
    /// Note that looking around during tokenizing creates dependencies
    /// on potentially far-away content, which may reduce the
    /// effectiveness incremental parsingâ€”when looking forwardâ€”or even
    /// cause invalid reparses when looking backward more than 25 code
    /// units, since the library does not track lookbehind.
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /// Accept a token. By default, the end of the token is set to the
    /// current stream position, but you can pass an offset (relative to
    /// the stream position) to change that.
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /// Move the stream forward N (defaults to 1) code units. Returns
    /// the new value of [`next`](#lr.InputStream.next).
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /// @internal
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /// @internal
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) { readToken(this.data, input, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// `@external tokens` declarations in the grammar should resolve to
/// an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream, scans for the types of tokens it
    /// recognizes at the stream's position, and calls
    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    /// one.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                    input.acceptToken(term);
                    break;
                }
            }
        // Do a binary search on the state's edges
        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(({"NODE_ENV":"development"}).LOG);
let stackIDs = null;
var Safety;
(function (Safety) {
    Safety[Safety["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
    let cursor = tree.fullCursor();
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        tokenizer.token(this.stream.reset(stack.pos, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Err */;
            token.end = Math.min(stack.p.stream.end, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    // When two stacks have been running independently long enough to
    // add this many elements to their buffers, prune one.
    Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    // Once a stack reaches this depth (in .stack.length) force-reduce
    // it back to CutTo to avoid creating trees that overflow the stack
    // on recursive traversal.
    Rec[Rec["CutDepth"] = 15000] = "CutDepth";
    Rec[Rec["CutTo"] = 9000] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 15000 /* CutDepth */) {
            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/// Context trackers are used to track stateful context (such as
/// indentation in the Python grammar, or parent elements in the XML
/// grammar) needed by external tokenizers. You declare them in a
/// grammar file as `@context exportName from "module"`.
///
/// Context values should be immutable, and can be updated (replaced)
/// on shift or reduce actions.
///
/// The export used in a `@context` declaration should be of this
/// type.
class ContextTracker {
    /// Define a context tracker.
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
    /// @internal
    constructor(spec) {
        super();
        /// @internal
        this.wrappers = [];
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.strict = false;
        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// The type of top node produced by the parser.
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUs4ZSxnQ0FBWjs7V0FBWUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7R0FBQUEscUNBQUFBOztBQVVMLElBQUtELGVBQVo7O1dBQVlBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0dBQUFBLG9CQUFBQTs7QUFzREwsSUFBSzJKLGtCQUFaOztXQUFZQTtBQUFBQSxFQUFBQSxtQkFBQUE7QUFBQUEsRUFBQUEsbUJBQUFBO0FBQUFBLEVBQUFBLG1CQUFBQTtBQUFBQSxFQUFBQSxtQkFBQUE7QUFBQUEsRUFBQUEsbUJBQUFBO0FBQUFBLEVBQUFBLG1CQUFBQTtBQUFB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QUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFBQUEsRUFBQUE7QUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUNBQW1DOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLCtCQUErQixJQUFJO0FBQ2pEO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0JBQStCLElBQUk7QUFDbEQ7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtCQUErQixJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZ2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlOeHRDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1REFBdUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5STs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdHBEMUM7O0FBRS9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQTJELElBQUksU0FBUyxFQUFFLG1DQUFtQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQTZEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUEwRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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cEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsOEJBQThCLHFDQUFxQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvTG9raUFubm90YXRpb25zUXVlcnlDdHJsLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9hZGRfbGFiZWxfdG9fcXVlcnkudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvYmFja2VuZFJlc3VsdFRyYW5zZm9ybWVyLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvTG9raUNoZWF0U2hlZXQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvTG9raUV4cGxvcmVRdWVyeUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29tcG9uZW50cy9Mb2tpTGFiZWxCcm93c2VyLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb21wb25lbnRzL0xva2lPcHRpb25GaWVsZHMudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb21wb25lbnRzL0xva2lRdWVyeUVkaXRvckJ5QXBwLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb21wb25lbnRzL0xva2lRdWVyeUVkaXRvckZvckFsZXJ0aW5nLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb21wb25lbnRzL0xva2lRdWVyeUZpZWxkLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb25maWd1cmF0aW9uL0NvbmZpZ0VkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvY29uZmlndXJhdGlvbi9EZWJ1Z1NlY3Rpb24udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbmZpZ3VyYXRpb24vRGVyaXZlZEZpZWxkLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9jb25maWd1cmF0aW9uL0Rlcml2ZWRGaWVsZHMudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2NvbmZpZ3VyYXRpb24vTWF4TGluZXNGaWVsZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvZGF0YXNvdXJjZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9sYW5ndWFnZV9wcm92aWRlci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9sYW5ndWFnZV91dGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9saXZlX3N0cmVhbXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbWFrZUlkRmllbGQudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbWFrZVRhYmxlRnJhbWVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL21vZHVsZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeV91dGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvTG9raVF1ZXJ5TW9kZWxsZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5kLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Mb2tpUXVlcnlCdWlsZGVyT3B0aW9ucy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5Q29kZUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL05lc3RlZFF1ZXJ5LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9OZXN0ZWRRdWVyeUxpc3QudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1F1ZXJ5UHJldmlldy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL29wZXJhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL3BhcnNpbmcudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvcXVlcnlidWlsZGVyL3N0YXRlLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3F1ZXJ5YnVpbGRlci90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS9yZXN1bHRfdHJhbnNmb3JtZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvc3RyZWFtaW5nLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL3N5bnRheC50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvbG9raS90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9hZGRfbGFiZWxfdG9fcXVlcnkudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvZGF0YXNvdXJjZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbGFuZ3VhZ2VfcHJvdmlkZXIudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbGFuZ3VhZ2VfdXRpbHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbWV0cmljX2ZpbmRfcXVlcnkudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcHJvbXFsLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5X2hpbnRzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9Qcm9tUXVlcnlNb2RlbGxlci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvYWdncmVnYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9iaW5hcnlTY2FsYXJPcGVyYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9vcGVyYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9wYXJzaW5nLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvQXV0b1NpemVJbnB1dC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9MYWJlbEZpbHRlckl0ZW0udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTGFiZWxGaWx0ZXJzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25FZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uRXhwbGFpbmVkQm94LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkhlYWRlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25JbmZvQnV0dG9uLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkxpc3QudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uTGlzdEV4cGxhaW5lZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25QYXJhbUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25zRWRpdG9yUm93LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL1F1ZXJ5RWRpdG9yTW9kZVRvZ2dsZS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL29wZXJhdGlvblV0aWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvcGFyc2luZ1V0aWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3Jlc3VsdF90cmFuc2Zvcm1lci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy92YXJpYWJsZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LXVzZS12aXJ0dWFsLTAwMzI2ZTcwYmEvMC9jYWNoZS9yZWFjdC11c2UtbnBtLTE3LjMuMi1hMDMyY2JlYjAxLTczNzk0NjBmNTEuemlwL25vZGVfbW9kdWxlcy9yZWFjdC11c2UvZXNtL3VzZVByZXZpb3VzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC11c2UtdmlydHVhbC0wMDMyNmU3MGJhLzAvY2FjaGUvcmVhY3QtdXNlLW5wbS0xNy4zLjItYTAzMmNiZWIwMS03Mzc5NDYwZjUxLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtdXNlL2VzbS91c2VUb2dnbGUuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2xydS1jYWNoZS1ucG0tNy43LjEtNzI2Mjc0ZGM0ZC1mMzYyYzVhMmNmLnppcC9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9yeGpzLW5wbS03LjUuNS1kMDU0NmIxY2NiLWUwMzRmNjA4MDUuemlwL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS9XZWJTb2NrZXRTdWJqZWN0LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9yeGpzLW5wbS03LjUuNS1kMDU0NmIxY2NiLWUwMzRmNjA4MDUuemlwL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3V1aWQtbnBtLTguMy4yLWVjYTBiYWJhNTMtNTU3NWE4YTc1Yy56aXAvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9wYXJzZS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvdXVpZC1ucG0tOC4zLjItZWNhMGJhYmE1My01NTc1YThhNzVjLnppcC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3NoYTEuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3V1aWQtbnBtLTguMy4yLWVjYTBiYWJhNTMtNTU3NWE4YTc1Yy56aXAvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MzUuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL3V1aWQtbnBtLTguMy4yLWVjYTBiYWJhNTMtNTU3NWE4YTc1Yy56aXAvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NS5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vQGdyYWZhbmEtbGV6ZXItbG9ncWwtdmlydHVhbC05MjUwZGJlY2Y4LzAvY2FjaGUvQGdyYWZhbmEtbGV6ZXItbG9ncWwtbnBtLTAuMC4xMS1kN2QyNDllNzRhLTA0MjdlNTk1MjguemlwL25vZGVfbW9kdWxlcy9AZ3JhZmFuYS9sZXplci1sb2dxbC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vX192aXJ0dWFsX18vbGV6ZXItcHJvbXFsLXZpcnR1YWwtZWFmODhhYTc3YS8wL2NhY2hlL2xlemVyLXByb21xbC1ucG0tMC4yMi4wLTg2N2RhNmFmYWEtY2RjZTA1NDcwMC56aXAvbm9kZV9tb2R1bGVzL2xlemVyLXByb21xbC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGxlemVyLWNvbW1vbi1ucG0tMC4xNS4xMi02MjAxNzI3MmIwLWRhZTY1ODE2MTguemlwL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL0BsZXplci1sci1ucG0tMC4xNS44LThjNDgxYzM5Y2QtZTc0MTIyNWQ2YS56aXAvbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExva2lRdWVyeSB9IGZyb20gJy4vdHlwZXMnO1xuLyoqXG4gKiBKdXN0IGEgc2ltcGxlIHdyYXBwZXIgZm9yIGEgcmVhY3QgY29tcG9uZW50IHRoYXQgaXMgYWN0dWFsbHkgaW1wbGVtZW50aW5nIHRoZSBxdWVyeSBlZGl0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2tpQW5ub3RhdGlvbnNRdWVyeUN0cmwge1xuICBzdGF0aWMgdGVtcGxhdGVVcmwgPSAncGFydGlhbHMvYW5ub3RhdGlvbnMuZWRpdG9yLmh0bWwnO1xuICBkZWNsYXJlIGFubm90YXRpb246IGFueTtcblxuICAvKiogQG5nSW5qZWN0ICovXG4gIGNvbnN0cnVjdG9yKCRzY29wZTogYW55KSB7XG4gICAgdGhpcy5hbm5vdGF0aW9uID0gJHNjb3BlLmN0cmwuYW5ub3RhdGlvbjtcbiAgICB0aGlzLmFubm90YXRpb24udGFyZ2V0ID0gdGhpcy5hbm5vdGF0aW9uLnRhcmdldCB8fCB7fTtcbiAgICB0aGlzLm9uUXVlcnlDaGFuZ2UgPSB0aGlzLm9uUXVlcnlDaGFuZ2UuYmluZCh0aGlzKTtcbiAgfVxuXG4gIG9uUXVlcnlDaGFuZ2UocXVlcnk6IExva2lRdWVyeSkge1xuICAgIHRoaXMuYW5ub3RhdGlvbi5leHByID0gcXVlcnkuZXhwcjtcbiAgICB0aGlzLmFubm90YXRpb24ubWF4TGluZXMgPSBxdWVyeS5tYXhMaW5lcztcbiAgICB0aGlzLmFubm90YXRpb24uaW5zdGFudCA9IHF1ZXJ5Lmluc3RhbnQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNoYWluLCBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IExPS0lfS0VZV09SRFMgfSBmcm9tICcuL3N5bnRheCc7XG5pbXBvcnQgeyBQUk9NX0tFWVdPUkRTLCBPUEVSQVRPUlMsIExPR0lDQUxfT1BFUkFUT1JTIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3Byb21xbCc7XG5cbmNvbnN0IGJ1aWx0SW5Xb3JkcyA9IFsuLi5QUk9NX0tFWVdPUkRTLCAuLi5PUEVSQVRPUlMsIC4uLkxPR0lDQUxfT1BFUkFUT1JTLCAuLi5MT0tJX0tFWVdPUkRTXTtcblxuLy8gV2Ugd2FudCB0byBleHRyYWN0IGFsbCBwb3NzaWJsZSBtZXRyaWNzIGFuZCBhbHNvIGtleXdvcmRzXG5jb25zdCBtZXRyaWNzQW5kS2V5d29yZHNSZWdleHAgPSAvKFtBLVphLXo6XVtcXHc6XSopXFxiKD8hW1xcXXs9IVwiLF0pL2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMYWJlbFRvUXVlcnkoXG4gIHF1ZXJ5OiBzdHJpbmcsXG4gIGtleTogc3RyaW5nLFxuICB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLFxuICBvcGVyYXRvcj86IHN0cmluZyxcbiAgaGFzTm9NZXRyaWNzPzogYm9vbGVhblxuKTogc3RyaW5nIHtcbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGxhYmVsIHRvIGFkZCB0byBxdWVyeS4nKTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgY29udmVydCB0aGUgdmFsdWUgYmFjayB0byBzdHJpbmcgYmVjYXVzZSBpdCBtYXkgYmUgYSBudW1iZXJcbiAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZSA9IHZhbHVlID09PSBJbmZpbml0eSA/ICcrSW5mJyA6IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgLy8gQWRkIGVtcHR5IHNlbGVjdG9ycyB0byBiYXJlIG1ldHJpYyBuYW1lc1xuICBsZXQgcHJldmlvdXNXb3JkOiBzdHJpbmc7XG5cbiAgcXVlcnkgPSBxdWVyeS5yZXBsYWNlKG1ldHJpY3NBbmRLZXl3b3Jkc1JlZ2V4cCwgKG1hdGNoLCB3b3JkLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBpc01ldHJpYyA9IGlzV29yZE1ldHJpYyhxdWVyeSwgd29yZCwgb2Zmc2V0LCBwcmV2aW91c1dvcmQsIGhhc05vTWV0cmljcyk7XG4gICAgcHJldmlvdXNXb3JkID0gd29yZDtcblxuICAgIHJldHVybiBpc01ldHJpYyA/IGAke3dvcmR9e31gIDogd29yZDtcbiAgfSk7XG5cbiAgLy9UaGlzIGlzIGEgUmVnRXhwIGZvciBzdHJlYW0gc2VsZWN0b3IgLSBlLmcuIHtqb2I9XCJncmFmYW5hXCJ9XG4gIGNvbnN0IHNlbGVjdG9yUmVnZXhwID0gLyhcXCQpP3soW157XSopfS9nO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgbGV0IHN1ZmZpeCA9ICcnO1xuXG4gIGxldCBtYXRjaCA9IHNlbGVjdG9yUmVnZXhwLmV4ZWMocXVlcnkpO1xuICAvKiBcbiAgICBUaGVyZSBhcmUgMiBwb3NzaWJsZSBmYWxzZSBwb3NpdGl2ZSBzY2VuYXJpb3M6IFxuICAgIFxuICAgIDEuIFdlIG1hdGNoIEdyYWZhbmEncyB2YXJpYWJsZXMgd2l0aCAkeyBzeW50YXggLSBzdWNoIGFzJHtfX3JhdGVfc30uIFRvIGZpbHRlciB0aGVzZSBvdXQgd2UgY291bGQgdXNlIG5lZ2F0aXZlIGxvb2tiZWhpbmQsXG4gICAgYnV0IFNhZmFyaSBicm93c2VyIGN1cnJlbnRseSBkb2Vzbid0IHN1cHBvcnQgaXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGhhY2sgdGhpcyBieSBjcmVhdGluZyAyIG1hdGNoaW5nIGdyb3Vwcy4gXG4gICAgKFxcJCkgaXMgZm9yIHRoZSBHcmFmYW5hJ3MgdmFyaWFibGVzIGFuZCBpZiB3ZSBtYXRjaCBpdCwgd2Uga25vdyB0aGlzIGlzIG5vdCBhIHN0cmVhbSBzZWxlY3RvciBhbmQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgbGFiZWwuXG5cbiAgICAyLiBMb2cgcXVlcmllcyBjYW4gaW5jbHVkZSB7ey5sYWJlbH19IHN5bnRheCB3aGVuIGxpbmVfZm9ybWF0IGlzIHVzZWQuIFdlIG5lZWQgdG8gZmlsdGVyIHRoZXNlIG91dCBieSBjaGVja2luZ1xuICAgIGlmIG1hdGNoIHN0YXJ0cyB3aXRoIFwiey5cIlxuICAqL1xuICB3aGlsZSAobWF0Y2gpIHtcbiAgICBjb25zdCBwcmVmaXggPSBxdWVyeS5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KTtcbiAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzJdLmxlbmd0aCArIDI7XG4gICAgc3VmZml4ID0gcXVlcnkuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuXG4gICAgLy8gRmlsdGVyaW5nIG91ciBmYWxzZSBwb3NpdGl2ZXNcbiAgICBpZiAobWF0Y2hbMF0uc3RhcnRzV2l0aCgney4nKSB8fCBtYXRjaFsxXSkge1xuICAgICAgcGFydHMucHVzaChwcmVmaXgpO1xuICAgICAgcGFydHMucHVzaChtYXRjaFswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGRpZG4ndCBtYXRjaCBmaXJzdCBncm91cCwgd2UgYXJlIGluc2lkZSBzZWxlY3RvciBhbmQgd2Ugd2FudCB0byBhZGQgbGFiZWxzXG4gICAgICBjb25zdCBzZWxlY3RvciA9IG1hdGNoWzJdO1xuICAgICAgY29uc3Qgc2VsZWN0b3JXaXRoTGFiZWwgPSBhZGRMYWJlbFRvU2VsZWN0b3Ioc2VsZWN0b3IsIGtleSwgdHJhbnNmb3JtZWRWYWx1ZSwgb3BlcmF0b3IpO1xuICAgICAgcGFydHMucHVzaChwcmVmaXgsIHNlbGVjdG9yV2l0aExhYmVsKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IHNlbGVjdG9yUmVnZXhwLmV4ZWMocXVlcnkpO1xuICB9XG5cbiAgcGFydHMucHVzaChzdWZmaXgpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG5cbmNvbnN0IGxhYmVsUmVnZXhwID0gLyhcXHcrKVxccyooPXwhPXw9fnwhfilcXHMqKFwiW15cIl0qXCIpL2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMYWJlbFRvU2VsZWN0b3Ioc2VsZWN0b3I6IHN0cmluZywgbGFiZWxLZXk6IHN0cmluZywgbGFiZWxWYWx1ZTogc3RyaW5nLCBsYWJlbE9wZXJhdG9yPzogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnNlZExhYmVscyA9IFtdO1xuXG4gIC8vIFNwbGl0IHNlbGVjdG9yIGludG8gbGFiZWxzXG4gIGlmIChzZWxlY3Rvcikge1xuICAgIGxldCBtYXRjaCA9IGxhYmVsUmVnZXhwLmV4ZWMoc2VsZWN0b3IpO1xuICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgcGFyc2VkTGFiZWxzLnB1c2goeyBrZXk6IG1hdGNoWzFdLCBvcGVyYXRvcjogbWF0Y2hbMl0sIHZhbHVlOiBtYXRjaFszXSB9KTtcbiAgICAgIG1hdGNoID0gbGFiZWxSZWdleHAuZXhlYyhzZWxlY3Rvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIG5ldyBsYWJlbFxuICBjb25zdCBvcGVyYXRvckZvckxhYmVsS2V5ID0gbGFiZWxPcGVyYXRvciB8fCAnPSc7XG4gIHBhcnNlZExhYmVscy5wdXNoKHsga2V5OiBsYWJlbEtleSwgb3BlcmF0b3I6IG9wZXJhdG9yRm9yTGFiZWxLZXksIHZhbHVlOiBgXCIke2xhYmVsVmFsdWV9XCJgIH0pO1xuXG4gIC8vIFNvcnQgbGFiZWxzIGJ5IGtleSBhbmQgcHV0IHRoZW0gdG9nZXRoZXJcbiAgY29uc3QgZm9ybWF0dGVkID0gY2hhaW4ocGFyc2VkTGFiZWxzKVxuICAgIC51bmlxV2l0aChpc0VxdWFsKVxuICAgIC5jb21wYWN0KClcbiAgICAuc29ydEJ5KCdrZXknKVxuICAgIC5tYXAoKHsga2V5LCBvcGVyYXRvciwgdmFsdWUgfSkgPT4gYCR7a2V5fSR7b3BlcmF0b3J9JHt2YWx1ZX1gKVxuICAgIC52YWx1ZSgpXG4gICAgLmpvaW4oJywnKTtcblxuICByZXR1cm4gYHske2Zvcm1hdHRlZH19YDtcbn1cblxuZnVuY3Rpb24gaXNQb3NpdGlvbkluc2lkZUNoYXJzKHRleHQ6IHN0cmluZywgcG9zaXRpb246IG51bWJlciwgb3BlbkNoYXI6IHN0cmluZywgY2xvc2VDaGFyOiBzdHJpbmcpIHtcbiAgY29uc3QgbmV4dFNlbGVjdG9yU3RhcnQgPSB0ZXh0LnNsaWNlKHBvc2l0aW9uKS5pbmRleE9mKG9wZW5DaGFyKTtcbiAgY29uc3QgbmV4dFNlbGVjdG9yRW5kID0gdGV4dC5zbGljZShwb3NpdGlvbikuaW5kZXhPZihjbG9zZUNoYXIpO1xuICByZXR1cm4gbmV4dFNlbGVjdG9yRW5kID4gLTEgJiYgKG5leHRTZWxlY3RvclN0YXJ0ID09PSAtMSB8fCBuZXh0U2VsZWN0b3JTdGFydCA+IG5leHRTZWxlY3RvckVuZCk7XG59XG5cbmZ1bmN0aW9uIGlzV29yZE1ldHJpYyhxdWVyeTogc3RyaW5nLCB3b3JkOiBzdHJpbmcsIG9mZnNldDogbnVtYmVyLCBwcmV2aW91c1dvcmQ6IHN0cmluZywgaGFzTm9NZXRyaWNzPzogYm9vbGVhbikge1xuICBjb25zdCBpbnNpZGVTZWxlY3RvciA9IGlzUG9zaXRpb25JbnNpZGVDaGFycyhxdWVyeSwgb2Zmc2V0LCAneycsICd9Jyk7XG4gIC8vIEhhbmRsZSBcInN1bSBieSAoa2V5KSAobWV0cmljKVwiXG4gIGNvbnN0IHByZXZpb3VzV29yZElzS2V5V29yZCA9IHByZXZpb3VzV29yZCAmJiBPUEVSQVRPUlMuaW5kZXhPZihwcmV2aW91c1dvcmQpID4gLTE7XG4gIC8vIENoZWNrIGZvciBjb2xvbiBhcyBhcyBcIndvcmQgYm91bmRhcnlcIiBzeW1ib2xcbiAgY29uc3QgaXNDb2xvbkJvdW5kZWQgPSB3b3JkLmVuZHNXaXRoKCc6Jyk7XG4gIC8vIENoZWNrIGZvciB3b3JkcyB0aGF0IHN0YXJ0IHdpdGggXCIgd2hpY2ggbWVhbnMgdGhhdCB0aGV5IGFyZSBub3QgbWV0cmljc1xuICBjb25zdCBzdGFydHNXaXRoUXVvdGUgPSBxdWVyeVtvZmZzZXQgLSAxXSA9PT0gJ1wiJztcbiAgLy8gQ2hlY2sgZm9yIHRlbXBsYXRlIHZhcmlhYmxlc1xuICBjb25zdCBpc1RlbXBsYXRlVmFyaWFibGUgPSBxdWVyeVtvZmZzZXQgLSAxXSA9PT0gJyQnO1xuICAvLyBDaGVjayBmb3IgdGltZSB1bml0c1xuICBjb25zdCBpc1RpbWVVbml0ID0gWydzJywgJ20nLCAnaCcsICdkJywgJ3cnXS5pbmNsdWRlcyh3b3JkKSAmJiBCb29sZWFuKE51bWJlcihxdWVyeVtvZmZzZXQgLSAxXSkpO1xuXG4gIGlmIChcbiAgICAhaGFzTm9NZXRyaWNzICYmXG4gICAgIWluc2lkZVNlbGVjdG9yICYmXG4gICAgIWlzQ29sb25Cb3VuZGVkICYmXG4gICAgIXByZXZpb3VzV29yZElzS2V5V29yZCAmJlxuICAgICFzdGFydHNXaXRoUXVvdGUgJiZcbiAgICAhaXNUZW1wbGF0ZVZhcmlhYmxlICYmXG4gICAgIWlzVGltZVVuaXQgJiZcbiAgICBidWlsdEluV29yZHMuaW5kZXhPZih3b3JkKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhZGRMYWJlbFRvUXVlcnk7XG4iLCJpbXBvcnQgeyBEYXRhUXVlcnlSZXF1ZXN0LCBEYXRhUXVlcnlSZXNwb25zZSwgRGF0YUZyYW1lLCBpc0RhdGFGcmFtZSwgRmllbGRUeXBlLCBRdWVyeVJlc3VsdE1ldGEgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raVF1ZXJ5VHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgbWFrZVRhYmxlRnJhbWVzIH0gZnJvbSAnLi9tYWtlVGFibGVGcmFtZXMnO1xuaW1wb3J0IHsgZm9ybWF0UXVlcnksIGdldEhpZ2hsaWdodGVyRXhwcmVzc2lvbnNGcm9tUXVlcnkgfSBmcm9tICcuL3F1ZXJ5X3V0aWxzJztcbmltcG9ydCB7IG1ha2VJZEZpZWxkIH0gZnJvbSAnLi9tYWtlSWRGaWVsZCc7XG5cbmZ1bmN0aW9uIGlzTWV0cmljRnJhbWUoZnJhbWU6IERhdGFGcmFtZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gZnJhbWUuZmllbGRzLmV2ZXJ5KChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLnRpbWUgfHwgZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLm51bWJlcik7XG59XG5cbi8vIHJldHVybnMgYSBuZXcgZnJhbWUsIHdpdGggbWV0YSBtZXJnZWQgd2l0aCBpdCdzIG9yaWdpbmFsIG1ldGFcbmZ1bmN0aW9uIHNldEZyYW1lTWV0YShmcmFtZTogRGF0YUZyYW1lLCBtZXRhOiBRdWVyeVJlc3VsdE1ldGEpOiBEYXRhRnJhbWUge1xuICBjb25zdCB7IG1ldGE6IG9sZE1ldGEsIC4uLnJlc3QgfSA9IGZyYW1lO1xuICAvLyBtZXRhIG1heWJlIGJlIHVuZGVmaW5lZCwgd2UgbmVlZCB0byBoYW5kbGUgdGhhdFxuICBjb25zdCBuZXdNZXRhID0geyAuLi5vbGRNZXRhLCAuLi5tZXRhIH07XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICBtZXRhOiBuZXdNZXRhLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzU3RyZWFtRnJhbWUoZnJhbWU6IERhdGFGcmFtZSwgcXVlcnk6IExva2lRdWVyeSB8IHVuZGVmaW5lZCk6IERhdGFGcmFtZSB7XG4gIGNvbnN0IG1ldGE6IFF1ZXJ5UmVzdWx0TWV0YSA9IHtcbiAgICBwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZTogJ2xvZ3MnLFxuICAgIHNlYXJjaFdvcmRzOiBxdWVyeSAhPT0gdW5kZWZpbmVkID8gZ2V0SGlnaGxpZ2h0ZXJFeHByZXNzaW9uc0Zyb21RdWVyeShmb3JtYXRRdWVyeShxdWVyeS5leHByKSkgOiB1bmRlZmluZWQsXG4gICAgY3VzdG9tOiB7XG4gICAgICAvLyB1c2VkIGJ5IGxvZ3NfbW9kZWxcbiAgICAgIGxva2lRdWVyeVN0YXRLZXk6ICdTdW1tYXJ5OiB0b3RhbCBieXRlcyBwcm9jZXNzZWQnLFxuICAgIH0sXG4gIH07XG4gIGNvbnN0IG5ld0ZyYW1lID0gc2V0RnJhbWVNZXRhKGZyYW1lLCBtZXRhKTtcbiAgY29uc3QgbmV3RmllbGRzID0gZnJhbWUuZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAvLyB0aGUgbmFub3NlY29uZC10aW1lc3RhbXAgZmllbGQgbXVzdCBoYXZlIGEgdHlwZS10aW1lXG4gICAgaWYgKGZpZWxkLm5hbWUgPT09ICd0c05zJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmllbGQsXG4gICAgICAgIHR5cGU6IEZpZWxkVHlwZS50aW1lLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gd2UgYWRkIGEgY2FsY3VsYXRlZCBpZC1maWVsZFxuICBuZXdGaWVsZHMucHVzaChtYWtlSWRGaWVsZChmcmFtZSkpO1xuXG4gIHJldHVybiB7XG4gICAgLi4ubmV3RnJhbWUsXG4gICAgZmllbGRzOiBuZXdGaWVsZHMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTdHJlYW1zRnJhbWVzKGZyYW1lczogRGF0YUZyYW1lW10sIHF1ZXJ5TWFwOiBNYXA8c3RyaW5nLCBMb2tpUXVlcnk+KTogRGF0YUZyYW1lW10ge1xuICByZXR1cm4gZnJhbWVzLm1hcCgoZnJhbWUpID0+IHtcbiAgICBjb25zdCBxdWVyeSA9IGZyYW1lLnJlZklkICE9PSB1bmRlZmluZWQgPyBxdWVyeU1hcC5nZXQoZnJhbWUucmVmSWQpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBwcm9jZXNzU3RyZWFtRnJhbWUoZnJhbWUsIHF1ZXJ5KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NNZXRyaWNJbnN0YW50RnJhbWVzKGZyYW1lczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIHJldHVybiBmcmFtZXMubGVuZ3RoID4gMCA/IG1ha2VUYWJsZUZyYW1lcyhmcmFtZXMpIDogW107XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NNZXRyaWNSYW5nZUZyYW1lcyhmcmFtZXM6IERhdGFGcmFtZVtdKTogRGF0YUZyYW1lW10ge1xuICBjb25zdCBtZXRhOiBRdWVyeVJlc3VsdE1ldGEgPSB7IHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAnZ3JhcGgnIH07XG4gIHJldHVybiBmcmFtZXMubWFwKChmcmFtZSkgPT4gc2V0RnJhbWVNZXRhKGZyYW1lLCBtZXRhKSk7XG59XG5cbi8vIHdlIHNwbGl0IHRoZSBmcmFtZXMgaW50byAzIGdyb3VwcywgYmVjYXVzZSB3ZSB3aWxsIGhhbmRsZVxuLy8gZWFjaCBncm91cCBzbGlnaHRseSBkaWZmZXJlbnRseVxuZnVuY3Rpb24gZ3JvdXBGcmFtZXMoXG4gIGZyYW1lczogRGF0YUZyYW1lW10sXG4gIHF1ZXJ5TWFwOiBNYXA8c3RyaW5nLCBMb2tpUXVlcnk+XG4pOiB7XG4gIHN0cmVhbXNGcmFtZXM6IERhdGFGcmFtZVtdO1xuICBtZXRyaWNJbnN0YW50RnJhbWVzOiBEYXRhRnJhbWVbXTtcbiAgbWV0cmljUmFuZ2VGcmFtZXM6IERhdGFGcmFtZVtdO1xufSB7XG4gIGNvbnN0IHN0cmVhbXNGcmFtZXM6IERhdGFGcmFtZVtdID0gW107XG4gIGNvbnN0IG1ldHJpY0luc3RhbnRGcmFtZXM6IERhdGFGcmFtZVtdID0gW107XG4gIGNvbnN0IG1ldHJpY1JhbmdlRnJhbWVzOiBEYXRhRnJhbWVbXSA9IFtdO1xuXG4gIGZyYW1lcy5mb3JFYWNoKChmcmFtZSkgPT4ge1xuICAgIGlmICghaXNNZXRyaWNGcmFtZShmcmFtZSkpIHtcbiAgICAgIHN0cmVhbXNGcmFtZXMucHVzaChmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzSW5zdGFudEZyYW1lID0gZnJhbWUucmVmSWQgIT0gbnVsbCAmJiBxdWVyeU1hcC5nZXQoZnJhbWUucmVmSWQpPy5xdWVyeVR5cGUgPT09IExva2lRdWVyeVR5cGUuSW5zdGFudDtcbiAgICAgIGlmIChpc0luc3RhbnRGcmFtZSkge1xuICAgICAgICBtZXRyaWNJbnN0YW50RnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0cmljUmFuZ2VGcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4geyBzdHJlYW1zRnJhbWVzLCBtZXRyaWNJbnN0YW50RnJhbWVzLCBtZXRyaWNSYW5nZUZyYW1lcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQmFja2VuZFJlc3VsdChcbiAgcmVzcG9uc2U6IERhdGFRdWVyeVJlc3BvbnNlLFxuICByZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT5cbik6IERhdGFRdWVyeVJlc3BvbnNlIHtcbiAgY29uc3QgeyBkYXRhLCAuLi5yZXN0IH0gPSByZXNwb25zZTtcblxuICAvLyBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlLCBkYXRhIGlzIGFuIGFycmF5IG9mIGJhc2ljYWxseSBhbnl0aGluZy5cbiAgLy8gd2UgZG8ga25vdyB0aGF0IHRoZXkgaGF2ZSB0byBiZSBkYXRhZnJhbWVzLCBzbyB3ZSBtYWtlIGEgcXVpY2sgY2hlY2ssXG4gIC8vIHRoaXMgd2F5IHdlIGNhbiBiZSBzdXJlLCBhbmQgYWxzbyB0eXBlc2NyaXB0IGlzIGhhcHB5LlxuICBjb25zdCBkYXRhRnJhbWVzID0gZGF0YS5tYXAoKGQpID0+IHtcbiAgICBpZiAoIWlzRGF0YUZyYW1lKGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zZm9ybWF0aW9uIG9ubHkgc3VwcG9ydHMgZGF0YWZyYW1lIHJlc3BvbnNlcycpO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfSk7XG5cbiAgY29uc3QgcXVlcnlNYXAgPSBuZXcgTWFwKHJlcXVlc3QudGFyZ2V0cy5tYXAoKHF1ZXJ5KSA9PiBbcXVlcnkucmVmSWQsIHF1ZXJ5XSkpO1xuXG4gIGNvbnN0IHsgc3RyZWFtc0ZyYW1lcywgbWV0cmljSW5zdGFudEZyYW1lcywgbWV0cmljUmFuZ2VGcmFtZXMgfSA9IGdyb3VwRnJhbWVzKGRhdGFGcmFtZXMsIHF1ZXJ5TWFwKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnJlc3QsXG4gICAgZGF0YTogW1xuICAgICAgLi4ucHJvY2Vzc01ldHJpY1JhbmdlRnJhbWVzKG1ldHJpY1JhbmdlRnJhbWVzKSxcbiAgICAgIC4uLnByb2Nlc3NNZXRyaWNJbnN0YW50RnJhbWVzKG1ldHJpY0luc3RhbnRGcmFtZXMpLFxuICAgICAgLi4ucHJvY2Vzc1N0cmVhbXNGcmFtZXMoc3RyZWFtc0ZyYW1lcywgcXVlcnlNYXApLFxuICAgIF0sXG4gIH07XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHNodWZmbGUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JIZWxwUHJvcHMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCBMb2tpTGFuZ3VhZ2VQcm92aWRlciBmcm9tICcuLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBMb2tpUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfRVhBTVBMRVMgPSBbJ3tqb2I9XCJkZWZhdWx0L3Byb21ldGhldXNcIn0nXTtcbmNvbnN0IFBSRUZFUlJFRF9MQUJFTFMgPSBbJ2pvYicsICdhcHAnLCAnazhzX2FwcCddO1xuY29uc3QgRVhBTVBMRVNfTElNSVQgPSA1O1xuXG5jb25zdCBMT0dRTF9FWEFNUExFUyA9IFtcbiAge1xuICAgIHRpdGxlOiAnTG9nIHBpcGVsaW5lJyxcbiAgICBleHByZXNzaW9uOiAne2pvYj1cIm15c3FsXCJ9IHw9IFwibWV0cmljc1wiIHwgbG9nZm10IHwgZHVyYXRpb24gPiAxMHMnLFxuICAgIGxhYmVsOlxuICAgICAgJ1RoaXMgcXVlcnkgdGFyZ2V0cyB0aGUgTXlTUUwgam9iLCBmaWx0ZXJzIG91dCBsb2dzIHRoYXQgZG9u4oCZdCBjb250YWluIHRoZSB3b3JkIFwibWV0cmljc1wiIGFuZCBwYXJzZXMgZWFjaCBsb2cgbGluZSB0byBleHRyYWN0IG1vcmUgbGFiZWxzIGFuZCBmaWx0ZXJzIHdpdGggdGhlbS4nLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdDb3VudCBvdmVyIHRpbWUnLFxuICAgIGV4cHJlc3Npb246ICdjb3VudF9vdmVyX3RpbWUoe2pvYj1cIm15c3FsXCJ9WzVtXSknLFxuICAgIGxhYmVsOiAnVGhpcyBxdWVyeSBjb3VudHMgYWxsIHRoZSBsb2cgbGluZXMgd2l0aGluIHRoZSBsYXN0IGZpdmUgbWludXRlcyBmb3IgdGhlIE15U1FMIGpvYi4nLFxuICB9LFxuICB7XG4gICAgdGl0bGU6ICdSYXRlJyxcbiAgICBleHByZXNzaW9uOiAncmF0ZSgoe2pvYj1cIm15c3FsXCJ9IHw9IFwiZXJyb3JcIiAhPSBcInRpbWVvdXRcIilbMTBzXSknLFxuICAgIGxhYmVsOlxuICAgICAgJ1RoaXMgcXVlcnkgZ2V0cyB0aGUgcGVyLXNlY29uZCByYXRlIG9mIGFsbCBub24tdGltZW91dCBlcnJvcnMgd2l0aGluIHRoZSBsYXN0IHRlbiBzZWNvbmRzIGZvciB0aGUgTXlTUUwgam9iLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FnZ3JlZ2F0ZSwgY291bnQsIGFuZCBncm91cCcsXG4gICAgZXhwcmVzc2lvbjogJ3N1bShjb3VudF9vdmVyX3RpbWUoe2pvYj1cIm15c3FsXCJ9WzVtXSkpIGJ5IChsZXZlbCknLFxuICAgIGxhYmVsOiAnR2V0IHRoZSBjb3VudCBvZiBsb2dzIGR1cmluZyB0aGUgbGFzdCBmaXZlIG1pbnV0ZXMsIGdyb3VwaW5nIGJ5IGxldmVsLicsXG4gIH0sXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2tpQ2hlYXRTaGVldCBleHRlbmRzIFB1cmVDb21wb25lbnQ8UXVlcnlFZGl0b3JIZWxwUHJvcHM8TG9raVF1ZXJ5PiwgeyB1c2VyRXhhbXBsZXM6IHN0cmluZ1tdIH0+IHtcbiAgZGVjbGFyZSB1c2VyTGFiZWxUaW1lcjogTm9kZUpTLlRpbWVvdXQ7XG4gIHN0YXRlID0ge1xuICAgIHVzZXJFeGFtcGxlczogW10sXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zY2hlZHVsZVVzZXJMYWJlbENoZWNraW5nKCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy51c2VyTGFiZWxUaW1lcik7XG4gIH1cblxuICBzY2hlZHVsZVVzZXJMYWJlbENoZWNraW5nKCkge1xuICAgIHRoaXMudXNlckxhYmVsVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tVc2VyTGFiZWxzLCAxMDAwKTtcbiAgfVxuXG4gIGNoZWNrVXNlckxhYmVscyA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBTZXQgZXhhbXBsZSBmcm9tIHVzZXIgbGFiZWxzXG4gICAgY29uc3QgcHJvdmlkZXI6IExva2lMYW5ndWFnZVByb3ZpZGVyID0gdGhpcy5wcm9wcy5kYXRhc291cmNlPy5sYW5ndWFnZVByb3ZpZGVyO1xuICAgIGlmIChwcm92aWRlci5zdGFydGVkKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSBwcm92aWRlci5nZXRMYWJlbEtleXMoKSB8fCBbXTtcbiAgICAgIGNvbnN0IHByZWZlcnJlZExhYmVsID0gUFJFRkVSUkVEX0xBQkVMUy5maW5kKChsKSA9PiBsYWJlbHMuaW5jbHVkZXMobCkpO1xuICAgICAgaWYgKHByZWZlcnJlZExhYmVsKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGF3YWl0IHByb3ZpZGVyLmdldExhYmVsVmFsdWVzKHByZWZlcnJlZExhYmVsKTtcbiAgICAgICAgY29uc3QgdXNlckV4YW1wbGVzID0gc2h1ZmZsZSh2YWx1ZXMpXG4gICAgICAgICAgLnNsaWNlKDAsIEVYQU1QTEVTX0xJTUlUKVxuICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiBgeyR7cHJlZmVycmVkTGFiZWx9PVwiJHt2YWx1ZX1cIn1gKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHVzZXJFeGFtcGxlcyB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2hlZHVsZVVzZXJMYWJlbENoZWNraW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlckV4cHJlc3Npb24oZXhwcjogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBvbkNsaWNrRXhhbXBsZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX2V4YW1wbGVcIiBrZXk9e2V4cHJ9IG9uQ2xpY2s9eyhlKSA9PiBvbkNsaWNrRXhhbXBsZSh7IHJlZklkOiAnQScsIGV4cHIgfSl9PlxuICAgICAgICA8Y29kZT57ZXhwcn08L2NvZGU+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgdXNlckV4YW1wbGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGhhc1VzZXJFeGFtcGxlcyA9IHVzZXJFeGFtcGxlcy5sZW5ndGggPiAwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxoMj5Mb2tpIENoZWF0IFNoZWV0PC9oMj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX190aXRsZVwiPlNlZSB5b3VyIGxvZ3M8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX2xhYmVsXCI+XG4gICAgICAgICAgICBTdGFydCBieSBzZWxlY3RpbmcgYSBsb2cgc3RyZWFtIGZyb20gdGhlIExvZyBicm93c2VyLCBvciBhbHRlcm5hdGl2ZWx5IHlvdSBjYW4gd3JpdGUgYSBzdHJlYW0gc2VsZWN0b3IgaW50b1xuICAgICAgICAgICAgdGhlIHF1ZXJ5IGZpZWxkLlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHtoYXNVc2VyRXhhbXBsZXMgPyAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoZWF0LXNoZWV0LWl0ZW1fX2xhYmVsXCI+SGVyZSBhcmUgc29tZSBleGFtcGxlIHN0cmVhbXMgZnJvbSB5b3VyIGxvZ3M6PC9kaXY+XG4gICAgICAgICAgICAgIHt1c2VyRXhhbXBsZXMubWFwKChleGFtcGxlKSA9PiB0aGlzLnJlbmRlckV4cHJlc3Npb24oZXhhbXBsZSkpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj5IZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBsb2cgc3RyZWFtOjwvZGl2PlxuICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJFeHByZXNzaW9uKERFRkFVTFRfRVhBTVBMRVNbMF0pfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fdGl0bGVcIj5Db21iaW5lIHN0cmVhbSBzZWxlY3RvcnM8L2Rpdj5cbiAgICAgICAgICB7dGhpcy5yZW5kZXJFeHByZXNzaW9uKCd7YXBwPVwiY2Fzc2FuZHJhXCIsbmFtZXNwYWNlPVwicHJvZFwifScpfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj5SZXR1cm5zIGFsbCBsb2cgbGluZXMgZnJvbSBzdHJlYW1zIHRoYXQgaGF2ZSBib3RoIGxhYmVscy48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX190aXRsZVwiPkZpbHRlcmluZyBmb3Igc2VhcmNoIHRlcm1zLjwvZGl2PlxuICAgICAgICAgIHt0aGlzLnJlbmRlckV4cHJlc3Npb24oJ3thcHA9XCJjYXNzYW5kcmFcIn0gfH4gXCIoZHVyYXRpb258bGF0ZW5jeSlzKig9fGlzfG9mKXMqW2QuXStcIicpfVxuICAgICAgICAgIHt0aGlzLnJlbmRlckV4cHJlc3Npb24oJ3thcHA9XCJjYXNzYW5kcmFcIn0gfD0gXCJleGFjdCBtYXRjaFwiJyl9XG4gICAgICAgICAge3RoaXMucmVuZGVyRXhwcmVzc2lvbigne2FwcD1cImNhc3NhbmRyYVwifSAhPSBcImRvIG5vdCBtYXRjaFwiJyl9XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19sYWJlbFwiPlxuICAgICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC8jbG9nLXBpcGVsaW5lXCIgdGFyZ2V0PVwibG9ncWxcIj5cbiAgICAgICAgICAgICAgTG9nUUxcbiAgICAgICAgICAgIDwvYT57JyAnfVxuICAgICAgICAgICAgc3VwcG9ydHMgZXhhY3QgYW5kIHJlZ3VsYXIgZXhwcmVzc2lvbiBmaWx0ZXJzLlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAge0xPR1FMX0VYQU1QTEVTLm1hcCgoaXRlbSkgPT4gKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbVwiIGtleT17aXRlbS5leHByZXNzaW9ufT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fdGl0bGVcIj57aXRlbS50aXRsZX08L2Rpdj5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckV4cHJlc3Npb24oaXRlbS5leHByZXNzaW9uKX1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj57aXRlbS5sYWJlbH08L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBMaWJyYXJpZXNcbmltcG9ydCBSZWFjdCwgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBUeXBlc1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgTG9raURhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlGaWVsZCB9IGZyb20gJy4vTG9raVF1ZXJ5RmllbGQnO1xuaW1wb3J0IHsgTG9raU9wdGlvbkZpZWxkcyB9IGZyb20gJy4vTG9raU9wdGlvbkZpZWxkcyc7XG5cbnR5cGUgUHJvcHMgPSBRdWVyeUVkaXRvclByb3BzPExva2lEYXRhc291cmNlLCBMb2tpUXVlcnksIExva2lPcHRpb25zPjtcblxuZXhwb3J0IGNvbnN0IExva2lFeHBsb3JlUXVlcnlFZGl0b3IgPSBtZW1vKChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyBxdWVyeSwgZGF0YSwgZGF0YXNvdXJjZSwgaGlzdG9yeSwgb25DaGFuZ2UsIG9uUnVuUXVlcnksIHJhbmdlIH0gPSBwcm9wcztcblxuICByZXR1cm4gKFxuICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uQmx1cj17KCkgPT4ge319XG4gICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgaGlzdG9yeT17aGlzdG9yeX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICByYW5nZT17cmFuZ2V9XG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgICBFeHRyYUZpZWxkRWxlbWVudD17XG4gICAgICAgIDxMb2tpT3B0aW9uRmllbGRzXG4gICAgICAgICAgbGluZUxpbWl0VmFsdWU9e3F1ZXJ5Py5tYXhMaW5lcz8udG9TdHJpbmcoKSB8fCAnJ31cbiAgICAgICAgICByZXNvbHV0aW9uPXtxdWVyeS5yZXNvbHV0aW9uIHx8IDF9XG4gICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAvPlxuICAgICAgfVxuICAgIC8+XG4gICk7XG59KTtcblxuTG9raUV4cGxvcmVRdWVyeUVkaXRvci5kaXNwbGF5TmFtZSA9ICdMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yJztcblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ2xva2ktZWRpdG9yLWV4cGxvcmUnLFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyBDaGFuZ2VFdmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7XG4gIEJ1dHRvbixcbiAgSGlnaGxpZ2h0UGFydCxcbiAgSG9yaXpvbnRhbEdyb3VwLFxuICBJbnB1dCxcbiAgTGFiZWwsXG4gIExvYWRpbmdQbGFjZWhvbGRlcixcbiAgd2l0aFRoZW1lMixcbiAgQnJvd3NlckxhYmVsIGFzIExva2lMYWJlbCxcbiAgZnV6enlNYXRjaCxcbn0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IExva2lMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4uL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCBQcm9tUWxMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4uLy4uL3Byb21ldGhldXMvbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBGaXhlZFNpemVMaXN0IH0gZnJvbSAncmVhY3Qtd2luZG93JztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHNvcnRCeSB9IGZyb20gJ2xvZGFzaCc7XG5cbi8vIEhhcmQgbGltaXQgb24gbGFiZWxzIHRvIHJlbmRlclxuY29uc3QgTUFYX0xBQkVMX0NPVU5UID0gMTAwMDtcbmNvbnN0IE1BWF9WQUxVRV9DT1VOVCA9IDEwMDAwO1xuY29uc3QgTUFYX0FVVE9fU0VMRUNUID0gNDtcbmNvbnN0IEVNUFRZX1NFTEVDVE9SID0gJ3t9JztcblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUHJvcHMge1xuICAvLyBUT0RPICMzMzk3NjogSXMgaXQgcG9zc2libGUgdG8gdXNlIGEgY29tbW9uIGludGVyZmFjZSBoZXJlPyBGb3IgZXhhbXBsZTogTGFiZWxzTGFuZ3VhZ2VQcm92aWRlclxuICBsYW5ndWFnZVByb3ZpZGVyOiBMb2tpTGFuZ3VhZ2VQcm92aWRlciB8IFByb21RbExhbmd1YWdlUHJvdmlkZXI7XG4gIG9uQ2hhbmdlOiAoc2VsZWN0b3I6IHN0cmluZykgPT4gdm9pZDtcbiAgdGhlbWU6IEdyYWZhbmFUaGVtZTI7XG4gIGF1dG9TZWxlY3Q/OiBudW1iZXI7XG4gIGhpZGU/OiAoKSA9PiB2b2lkO1xuICBsYXN0VXNlZExhYmVsczogc3RyaW5nW107XG4gIHN0b3JlTGFzdFVzZWRMYWJlbHM6IChsYWJlbHM6IHN0cmluZ1tdKSA9PiB2b2lkO1xuICBkZWxldGVMYXN0VXNlZExhYmVsczogKCkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIEJyb3dzZXJTdGF0ZSB7XG4gIGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW107XG4gIHNlYXJjaFRlcm06IHN0cmluZztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGVycm9yOiBzdHJpbmc7XG4gIHZhbGlkYXRpb25TdGF0dXM6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEZhY2V0dGFibGVWYWx1ZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgc2VsZWN0ZWQ/OiBib29sZWFuO1xuICBoaWdobGlnaHRQYXJ0cz86IEhpZ2hsaWdodFBhcnRbXTtcbiAgb3JkZXI/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0YWJsZUxhYmVsIHtcbiAgbmFtZTogc3RyaW5nO1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIGxvYWRpbmc/OiBib29sZWFuO1xuICB2YWx1ZXM/OiBGYWNldHRhYmxlVmFsdWVbXTtcbiAgaGlkZGVuPzogYm9vbGVhbjtcbiAgZmFjZXRzPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTZWxlY3RvcihsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdKTogc3RyaW5nIHtcbiAgY29uc3Qgc2VsZWN0ZWRMYWJlbHMgPSBbXTtcbiAgZm9yIChjb25zdCBsYWJlbCBvZiBsYWJlbHMpIHtcbiAgICBpZiAobGFiZWwuc2VsZWN0ZWQgJiYgbGFiZWwudmFsdWVzICYmIGxhYmVsLnZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFZhbHVlcyA9IGxhYmVsLnZhbHVlcy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZS5zZWxlY3RlZCkubWFwKCh2YWx1ZSkgPT4gdmFsdWUubmFtZSk7XG4gICAgICBpZiAoc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBzZWxlY3RlZExhYmVscy5wdXNoKGAke2xhYmVsLm5hbWV9PX5cIiR7c2VsZWN0ZWRWYWx1ZXMuam9pbignfCcpfVwiYCk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzZWxlY3RlZExhYmVscy5wdXNoKGAke2xhYmVsLm5hbWV9PVwiJHtzZWxlY3RlZFZhbHVlc1swXX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWyd7Jywgc2VsZWN0ZWRMYWJlbHMuam9pbignLCcpLCAnfSddLmpvaW4oJycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmFjZXRMYWJlbHMoXG4gIGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10sXG4gIHBvc3NpYmxlTGFiZWxzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4sXG4gIGxhc3RGYWNldHRlZD86IHN0cmluZ1xuKTogU2VsZWN0YWJsZUxhYmVsW10ge1xuICByZXR1cm4gbGFiZWxzLm1hcCgobGFiZWwpID0+IHtcbiAgICBjb25zdCBwb3NzaWJsZVZhbHVlcyA9IHBvc3NpYmxlTGFiZWxzW2xhYmVsLm5hbWVdO1xuICAgIGlmIChwb3NzaWJsZVZhbHVlcykge1xuICAgICAgbGV0IGV4aXN0aW5nVmFsdWVzOiBGYWNldHRhYmxlVmFsdWVbXTtcbiAgICAgIGlmIChsYWJlbC5uYW1lID09PSBsYXN0RmFjZXR0ZWQgJiYgbGFiZWwudmFsdWVzKSB7XG4gICAgICAgIC8vIEZhY2V0dGluZyB0aGlzIGxhYmVsLCBzaG93IGFsbCB2YWx1ZXNcbiAgICAgICAgZXhpc3RpbmdWYWx1ZXMgPSBsYWJlbC52YWx1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZWVwIHNlbGVjdGlvbiBpbiBvdGhlciBmYWNldHNcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChcbiAgICAgICAgICBsYWJlbC52YWx1ZXM/LmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5uYW1lKSB8fCBbXVxuICAgICAgICApO1xuICAgICAgICAvLyBWYWx1ZXMgZm9yIHRoaXMgbGFiZWwgaGF2ZSBub3QgYmVlbiByZXF1ZXN0ZWQgeWV0LCBsZXQncyB1c2UgdGhlIGZhY2V0dGVkIG9uZXMgYXMgdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgICAgIGV4aXN0aW5nVmFsdWVzID0gcG9zc2libGVWYWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgbmFtZTogdmFsdWUsIHNlbGVjdGVkOiBzZWxlY3RlZFZhbHVlcy5oYXModmFsdWUpIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmxhYmVsLCBsb2FkaW5nOiBmYWxzZSwgdmFsdWVzOiBleGlzdGluZ1ZhbHVlcywgZmFjZXRzOiBleGlzdGluZ1ZhbHVlcy5sZW5ndGggfTtcbiAgICB9XG5cbiAgICAvLyBMYWJlbCBpcyBmYWNldHRlZCBvdXQsIGhpZGUgYWxsIHZhbHVlc1xuICAgIHJldHVybiB7IC4uLmxhYmVsLCBsb2FkaW5nOiBmYWxzZSwgaGlkZGVuOiAhcG9zc2libGVWYWx1ZXMsIHZhbHVlczogdW5kZWZpbmVkLCBmYWNldHM6IDAgfTtcbiAgfSk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgd3JhcHBlcjogY3NzYFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2Vjb25kYXJ5fTtcbiAgICBwYWRkaW5nOiAke3RoZW1lLnNwYWNpbmcoMil9O1xuICAgIHdpZHRoOiAxMDAlO1xuICBgLFxuICBsaXN0OiBjc3NgXG4gICAgbWFyZ2luLXRvcDogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBtYXgtaGVpZ2h0OiAyMDBweDtcbiAgICBvdmVyZmxvdzogYXV0bztcbiAgYCxcbiAgc2VjdGlvbjogY3NzYFxuICAgICYgKyAmIHtcbiAgICAgIG1hcmdpbjogJHt0aGVtZS5zcGFjaW5nKDIsIDApfTtcbiAgICB9XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBgLFxuICBzZWxlY3RvcjogY3NzYFxuICAgIGZvbnQtZmFtaWx5OiAke3RoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZX07XG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgYCxcbiAgc3RhdHVzOiBjc3NgXG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nKDAuNSl9O1xuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgIC8qIHVzaW5nIGFic29sdXRlIHBvc2l0aW9uaW5nIGJlY2F1c2UgZmxleCBpbnRlcmZlcmVzIHdpdGggZWxsaXBzaXMgKi9cbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDUwJTtcbiAgICByaWdodDogMDtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDEwMG1zIGxpbmVhcjtcbiAgICBvcGFjaXR5OiAwO1xuICBgLFxuICBzdGF0dXNTaG93aW5nOiBjc3NgXG4gICAgb3BhY2l0eTogMTtcbiAgYCxcbiAgZXJyb3I6IGNzc2BcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMuZXJyb3IubWFpbn07XG4gIGAsXG4gIHZhbHVlTGlzdDogY3NzYFxuICAgIG1hcmdpbi1yaWdodDogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgYCxcbiAgdmFsdWVMaXN0V3JhcHBlcjogY3NzYFxuICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLm1lZGl1bX07XG4gICAgbWFyZ2luOiAke3RoZW1lLnNwYWNpbmcoMSwgMCl9O1xuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZygxLCAwLCAxLCAxKX07XG4gIGAsXG4gIHZhbHVlTGlzdEFyZWE6IGNzc2BcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBtYXJnaW4tdG9wOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICBgLFxuICB2YWx1ZVRpdGxlOiBjc3NgXG4gICAgbWFyZ2luLWxlZnQ6IC0ke3RoZW1lLnNwYWNpbmcoMC41KX07XG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nKDEpfTtcbiAgYCxcbiAgdmFsaWRhdGlvblN0YXR1czogY3NzYFxuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZygwLjUpfTtcbiAgICBtYXJnaW4tYm90dG9tOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0Lm1heENvbnRyYXN0fTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gIGAsXG59KTtcblxuZXhwb3J0IGNsYXNzIFVudGhlbWVkTG9raUxhYmVsQnJvd3NlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxCcm93c2VyUHJvcHMsIEJyb3dzZXJTdGF0ZT4ge1xuICBzdGF0ZTogQnJvd3NlclN0YXRlID0ge1xuICAgIGxhYmVsczogW10gYXMgU2VsZWN0YWJsZUxhYmVsW10sXG4gICAgc2VhcmNoVGVybTogJycsXG4gICAgc3RhdHVzOiAnUmVhZHknLFxuICAgIGVycm9yOiAnJyxcbiAgICB2YWxpZGF0aW9uU3RhdHVzOiAnJyxcbiAgfTtcblxuICBvbkNoYW5nZVNlYXJjaCA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgc2VhcmNoVGVybTogZXZlbnQudGFyZ2V0LnZhbHVlIH0pO1xuICB9O1xuXG4gIG9uQ2xpY2tSdW5Mb2dzUXVlcnkgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHNlbGVjdG9yKTtcbiAgfTtcblxuICBvbkNsaWNrUnVuTWV0cmljc1F1ZXJ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgY29uc3QgcXVlcnkgPSBgcmF0ZSgke3NlbGVjdG9yfVskX19pbnRlcnZhbF0pYDtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHF1ZXJ5KTtcbiAgfTtcblxuICBvbkNsaWNrQ2xlYXIgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSBzdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4gKHtcbiAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgIHZhbHVlczogdW5kZWZpbmVkLFxuICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBmYWNldHM6IHVuZGVmaW5lZCxcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB7IGxhYmVscywgc2VhcmNoVGVybTogJycsIHN0YXR1czogJycsIGVycm9yOiAnJywgdmFsaWRhdGlvblN0YXR1czogJycgfTtcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLmRlbGV0ZUxhc3RVc2VkTGFiZWxzKCk7XG4gIH07XG5cbiAgb25DbGlja0xhYmVsID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVG9nZ2xlIHNlbGVjdGVkIHN0YXRlXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSAhbGFiZWwuc2VsZWN0ZWQ7XG4gICAgbGV0IG5leHRWYWx1ZTogUGFydGlhbDxTZWxlY3RhYmxlTGFiZWw+ID0geyBzZWxlY3RlZCB9O1xuICAgIGlmIChsYWJlbC52YWx1ZXMgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAvLyBEZXNlbGVjdCBhbGwgdmFsdWVzIGlmIGxhYmVsIHdhcyBkZXNlbGVjdGVkXG4gICAgICBjb25zdCB2YWx1ZXMgPSBsYWJlbC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgLi4udmFsdWUsIHNlbGVjdGVkOiBmYWxzZSB9KSk7XG4gICAgICBuZXh0VmFsdWUgPSB7IC4uLm5leHRWYWx1ZSwgZmFjZXRzOiAwLCB2YWx1ZXMgfTtcbiAgICB9XG4gICAgLy8gUmVzZXR0aW5nIHNlYXJjaCB0byBwcmV2ZW50IGVtcHR5IHJlc3VsdHNcbiAgICB0aGlzLnNldFN0YXRlKHsgc2VhcmNoVGVybTogJycgfSk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIG5leHRWYWx1ZSwgJycsICgpID0+IHRoaXMuZG9GYWNldHRpbmdGb3JMYWJlbChuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja1ZhbHVlID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwgfHwgIWxhYmVsLnZhbHVlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXNldHRpbmcgc2VhcmNoIHRvIHByZXZlbnQgZW1wdHkgcmVzdWx0c1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWFyY2hUZXJtOiAnJyB9KTtcbiAgICAvLyBUb2dnbGluZyB2YWx1ZSBmb3Igc2VsZWN0ZWQgbGFiZWwsIGxlYXZpbmcgb3RoZXIgdmFsdWVzIGludGFjdFxuICAgIGNvbnN0IHZhbHVlcyA9IGxhYmVsLnZhbHVlcy5tYXAoKHYpID0+ICh7IC4uLnYsIHNlbGVjdGVkOiB2Lm5hbWUgPT09IHZhbHVlID8gIXYuc2VsZWN0ZWQgOiB2LnNlbGVjdGVkIH0pKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyB2YWx1ZXMgfSwgJycsICgpID0+IHRoaXMuZG9GYWNldHRpbmcobmFtZSkpO1xuICB9O1xuXG4gIG9uQ2xpY2tWYWxpZGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGJ1aWxkU2VsZWN0b3IodGhpcy5zdGF0ZS5sYWJlbHMpO1xuICAgIHRoaXMudmFsaWRhdGVTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG5cbiAgdXBkYXRlTGFiZWxTdGF0ZShuYW1lOiBzdHJpbmcsIHVwZGF0ZWRGaWVsZHM6IFBhcnRpYWw8U2VsZWN0YWJsZUxhYmVsPiwgc3RhdHVzID0gJycsIGNiPzogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gc3RhdGUubGFiZWxzLm1hcCgobGFiZWwpID0+IHtcbiAgICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgLi4udXBkYXRlZEZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0pO1xuICAgICAgLy8gTmV3IHN0YXR1cyBvdmVycmlkZXMgZXJyb3JzXG4gICAgICBjb25zdCBlcnJvciA9IHN0YXR1cyA/ICcnIDogc3RhdGUuZXJyb3I7XG4gICAgICByZXR1cm4geyBsYWJlbHMsIHN0YXR1cywgZXJyb3IsIHZhbGlkYXRpb25TdGF0dXM6ICcnIH07XG4gICAgfSwgY2IpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBsYW5ndWFnZVByb3ZpZGVyLCBhdXRvU2VsZWN0ID0gTUFYX0FVVE9fU0VMRUNULCBsYXN0VXNlZExhYmVscyB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAobGFuZ3VhZ2VQcm92aWRlcikge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRMYWJlbHM6IHN0cmluZ1tdID0gbGFzdFVzZWRMYWJlbHM7XG4gICAgICBsYW5ndWFnZVByb3ZpZGVyLnN0YXJ0KCkudGhlbigoKSA9PiB7XG4gICAgICAgIGxldCByYXdMYWJlbHM6IHN0cmluZ1tdID0gbGFuZ3VhZ2VQcm92aWRlci5nZXRMYWJlbEtleXMoKTtcbiAgICAgICAgaWYgKHJhd0xhYmVscy5sZW5ndGggPiBNQVhfTEFCRUxfQ09VTlQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IGBUb28gbWFueSBsYWJlbHMgZm91bmQgKHNob3dpbmcgb25seSAke01BWF9MQUJFTF9DT1VOVH0gb2YgJHtyYXdMYWJlbHMubGVuZ3RofSlgO1xuICAgICAgICAgIHJhd0xhYmVscyA9IHJhd0xhYmVscy5zbGljZSgwLCBNQVhfTEFCRUxfQ09VTlQpO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdXRvLXNlbGVjdCBhbGwgbGFiZWxzIGlmIGxhYmVsIGxpc3QgaXMgc21hbGwgZW5vdWdoXG4gICAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSByYXdMYWJlbHMubWFwKChsYWJlbCwgaSwgYXJyKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICAgIHNlbGVjdGVkOiAoYXJyLmxlbmd0aCA8PSBhdXRvU2VsZWN0ICYmIHNlbGVjdGVkTGFiZWxzLmxlbmd0aCA9PT0gMCkgfHwgc2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobGFiZWwpLFxuICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFByZS1mZXRjaCB2YWx1ZXMgZm9yIHNlbGVjdGVkIGxhYmVsc1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmxhYmVscy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgRU1QVFlfU0VMRUNUT1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nRm9yTGFiZWwobmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbC5zZWxlY3RlZCkubWFwKChsYWJlbCkgPT4gbGFiZWwubmFtZSk7XG4gICAgdGhpcy5wcm9wcy5zdG9yZUxhc3RVc2VkTGFiZWxzKHNlbGVjdGVkTGFiZWxzKTtcbiAgICBpZiAobGFiZWwuc2VsZWN0ZWQpIHtcbiAgICAgIC8vIFJlZmV0Y2ggdmFsdWVzIGZvciBuZXdseSBzZWxlY3RlZCBsYWJlbC4uLlxuICAgICAgaWYgKCFsYWJlbC52YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5mZXRjaFZhbHVlcyhuYW1lLCBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgbmVlZCB0byBmYWNldCB3aGVuIGRlc2VsZWN0aW5nIGxhYmVsc1xuICAgICAgdGhpcy5kb0ZhY2V0dGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nID0gKGxhc3RGYWNldHRlZD86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgLy8gQ2xlYXIgdXAgZmFjZXR0aW5nXG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gdGhpcy5zdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgZmFjZXRzOiAwLCB2YWx1ZXM6IHVuZGVmaW5lZCwgaGlkZGVuOiBmYWxzZSB9O1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgLy8gR2V0IGZyZXNoIHNldCBvZiB2YWx1ZXNcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMuZm9yRWFjaCgobGFiZWwpID0+IGxhYmVsLnNlbGVjdGVkICYmIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgc2VsZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEbyBmYWNldHRpbmdcbiAgICAgIHRoaXMuZmV0Y2hTZXJpZXMoc2VsZWN0b3IsIGxhc3RGYWNldHRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGFzeW5jIGZldGNoVmFsdWVzKG5hbWU6IHN0cmluZywgc2VsZWN0b3I6IHN0cmluZykge1xuICAgIGNvbnN0IHsgbGFuZ3VhZ2VQcm92aWRlciB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyBsb2FkaW5nOiB0cnVlIH0sIGBGZXRjaGluZyB2YWx1ZXMgZm9yICR7bmFtZX1gKTtcbiAgICB0cnkge1xuICAgICAgbGV0IHJhd1ZhbHVlcyA9IGF3YWl0IGxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxWYWx1ZXMobmFtZSk7XG4gICAgICAvLyBJZiBzZWxlY3RvciBjaGFuZ2VkLCBjbGVhciBsb2FkaW5nIHN0YXRlIGFuZCBkaXNjYXJkIHJlc3VsdCBieSByZXR1cm5pbmcgZWFybHlcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscykpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgbG9hZGluZzogZmFsc2UgfSwgJycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmF3VmFsdWVzLmxlbmd0aCA+IE1BWF9WQUxVRV9DT1VOVCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IGBUb28gbWFueSB2YWx1ZXMgZm9yICR7bmFtZX0gKHNob3dpbmcgb25seSAke01BWF9WQUxVRV9DT1VOVH0gb2YgJHtyYXdWYWx1ZXMubGVuZ3RofSlgO1xuICAgICAgICByYXdWYWx1ZXMgPSByYXdWYWx1ZXMuc2xpY2UoMCwgTUFYX1ZBTFVFX0NPVU5UKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVzOiBGYWNldHRhYmxlVmFsdWVbXSA9IHJhd1ZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoeyBuYW1lOiB2YWx1ZSB9KSk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobmFtZSwgeyB2YWx1ZXMsIGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmZXRjaFNlcmllcyhzZWxlY3Rvcjogc3RyaW5nLCBsYXN0RmFjZXR0ZWQ/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiB0cnVlIH0sIGBGYWNldHRpbmcgbGFiZWxzIGZvciAke3NlbGVjdG9yfWApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcG9zc2libGVMYWJlbHMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzTGFiZWxzKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgIC8vIElmIHNlbGVjdG9yIGNoYW5nZWQsIGNsZWFyIGxvYWRpbmcgc3RhdGUgYW5kIGRpc2NhcmQgcmVzdWx0IGJ5IHJldHVybmluZyBlYXJseVxuICAgICAgaWYgKHNlbGVjdG9yICE9PSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSkge1xuICAgICAgICBpZiAobGFzdEZhY2V0dGVkKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMocG9zc2libGVMYWJlbHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IGBFbXB0eSByZXN1bHRzLCBubyBtYXRjaGluZyBsYWJlbCBmb3IgJHtzZWxlY3Rvcn1gIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gZmFjZXRMYWJlbHModGhpcy5zdGF0ZS5sYWJlbHMsIHBvc3NpYmxlTGFiZWxzLCBsYXN0RmFjZXR0ZWQpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVscywgZXJyb3I6ICcnIH0pO1xuICAgICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsU3RhdGUobGFzdEZhY2V0dGVkLCB7IGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZVNlbGVjdG9yKHNlbGVjdG9yOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbGlkYXRpb25TdGF0dXM6IGBWYWxpZGF0aW5nIHNlbGVjdG9yICR7c2VsZWN0b3J9YCwgZXJyb3I6ICcnIH0pO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmZldGNoU2VyaWVzKHNlbGVjdG9yKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsaWRhdGlvblN0YXR1czogYFNlbGVjdG9yIGlzIHZhbGlkICgke3N0cmVhbXMubGVuZ3RofSBzdHJlYW1zIGZvdW5kKWAgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB0aGVtZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGxhYmVscywgc2VhcmNoVGVybSwgc3RhdHVzLCBlcnJvciwgdmFsaWRhdGlvblN0YXR1cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDxMb2FkaW5nUGxhY2Vob2xkZXIgdGV4dD1cIkxvYWRpbmcgbGFiZWxzLi4uXCIgLz47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlcyh0aGVtZSk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKTtcbiAgICBjb25zdCBlbXB0eSA9IHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUjtcblxuICAgIGxldCBzZWxlY3RlZExhYmVscyA9IGxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbC5zZWxlY3RlZCAmJiBsYWJlbC52YWx1ZXMpO1xuICAgIGlmIChzZWFyY2hUZXJtKSB7XG4gICAgICBzZWxlY3RlZExhYmVscyA9IHNlbGVjdGVkTGFiZWxzLm1hcCgobGFiZWwpID0+IHtcbiAgICAgICAgY29uc3Qgc2VhcmNoUmVzdWx0cyA9IGxhYmVsLnZhbHVlcyEuZmlsdGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gc2VsZWN0ZWQgdmFsdWVzXG4gICAgICAgICAgaWYgKHZhbHVlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YWx1ZS5oaWdobGlnaHRQYXJ0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmdXp6eU1hdGNoUmVzdWx0ID0gZnV6enlNYXRjaCh2YWx1ZS5uYW1lLnRvTG93ZXJDYXNlKCksIHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgaWYgKGZ1enp5TWF0Y2hSZXN1bHQuZm91bmQpIHtcbiAgICAgICAgICAgIHZhbHVlLmhpZ2hsaWdodFBhcnRzID0gZnV6enlNYXRjaFJlc3VsdC5yYW5nZXM7XG4gICAgICAgICAgICB2YWx1ZS5vcmRlciA9IGZ1enp5TWF0Y2hSZXN1bHQuZGlzdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgICAgdmFsdWVzOiBzb3J0Qnkoc2VhcmNoUmVzdWx0cywgKHZhbHVlKSA9PiAodmFsdWUuc2VsZWN0ZWQgPyAtSW5maW5pdHkgOiB2YWx1ZS5vcmRlcikpLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGhpZ2hsaWdodCBwYXJ0cyB3aGVuIHNlYXJjaFRlcm0gaXMgY2xlYXJlZFxuICAgICAgc2VsZWN0ZWRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVsc1xuICAgICAgICAuZmlsdGVyKChsYWJlbCkgPT4gbGFiZWwuc2VsZWN0ZWQgJiYgbGFiZWwudmFsdWVzKVxuICAgICAgICAubWFwKChsYWJlbCkgPT4gKHtcbiAgICAgICAgICAuLi5sYWJlbCxcbiAgICAgICAgICB2YWx1ZXM6IGxhYmVsPy52YWx1ZXMgPyBsYWJlbC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHsgLi4udmFsdWUsIGhpZ2hsaWdodFBhcnRzOiB1bmRlZmluZWQgfSkpIDogW10sXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICA8TGFiZWwgZGVzY3JpcHRpb249XCJXaGljaCBsYWJlbHMgd291bGQgeW91IGxpa2UgdG8gY29uc2lkZXIgZm9yIHlvdXIgc2VhcmNoP1wiPlxuICAgICAgICAgICAgMS4gU2VsZWN0IGxhYmVscyB0byBzZWFyY2ggaW5cbiAgICAgICAgICA8L0xhYmVsPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubGlzdH0+XG4gICAgICAgICAgICB7bGFiZWxzLm1hcCgobGFiZWwpID0+IChcbiAgICAgICAgICAgICAgPExva2lMYWJlbFxuICAgICAgICAgICAgICAgIGtleT17bGFiZWwubmFtZX1cbiAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgIGxvYWRpbmc9e2xhYmVsLmxvYWRpbmd9XG4gICAgICAgICAgICAgICAgYWN0aXZlPXtsYWJlbC5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICBoaWRkZW49e2xhYmVsLmhpZGRlbn1cbiAgICAgICAgICAgICAgICBmYWNldHM9e2xhYmVsLmZhY2V0c31cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tMYWJlbH1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICA8TGFiZWwgZGVzY3JpcHRpb249XCJDaG9vc2UgdGhlIGxhYmVsIHZhbHVlcyB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHVzZSBmb3IgdGhlIHF1ZXJ5LiBVc2UgdGhlIHNlYXJjaCBmaWVsZCB0byBmaW5kIHZhbHVlcyBhY3Jvc3Mgc2VsZWN0ZWQgbGFiZWxzLlwiPlxuICAgICAgICAgICAgMi4gRmluZCB2YWx1ZXMgZm9yIHRoZSBzZWxlY3RlZCBsYWJlbHNcbiAgICAgICAgICA8L0xhYmVsPlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8SW5wdXQgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VTZWFyY2h9IGFyaWEtbGFiZWw9XCJGaWx0ZXIgZXhwcmVzc2lvbiBmb3IgdmFsdWVzXCIgdmFsdWU9e3NlYXJjaFRlcm19IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3RBcmVhfT5cbiAgICAgICAgICAgIHtzZWxlY3RlZExhYmVscy5tYXAoKGxhYmVsKSA9PiAoXG4gICAgICAgICAgICAgIDxkaXYgcm9sZT1cImxpc3RcIiBrZXk9e2xhYmVsLm5hbWV9IGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdFdyYXBwZXJ9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsdWVUaXRsZX0gYXJpYS1sYWJlbD17YFZhbHVlcyBmb3IgJHtsYWJlbC5uYW1lfWB9PlxuICAgICAgICAgICAgICAgICAgPExva2lMYWJlbFxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsYWJlbC5sb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2xhYmVsLnNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICBoaWRkZW49e2xhYmVsLmhpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAgLy9JZiBubyBmYWNldHMsIHdlIHdhbnQgdG8gc2hvdyBudW1iZXIgb2YgYWxsIGxhYmVsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBmYWNldHM9e2xhYmVsLmZhY2V0cyB8fCBsYWJlbC52YWx1ZXM/Lmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrTGFiZWx9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxGaXhlZFNpemVMaXN0XG4gICAgICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1Db3VudD17bGFiZWwudmFsdWVzPy5sZW5ndGggfHwgMH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1TaXplPXsyOH1cbiAgICAgICAgICAgICAgICAgIGl0ZW1LZXk9eyhpKSA9PiAobGFiZWwudmFsdWVzIGFzIEZhY2V0dGFibGVWYWx1ZVtdKVtpXS5uYW1lfVxuICAgICAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlTGlzdH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7KHsgaW5kZXgsIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsYWJlbC52YWx1ZXM/LltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMb2tpTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17bGFiZWwubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e3ZhbHVlPy5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0UGFydHM9e3ZhbHVlPy5oaWdobGlnaHRQYXJ0c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm09e3NlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA8L0ZpeGVkU2l6ZUxpc3Q+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlY3Rpb259PlxuICAgICAgICAgIDxMYWJlbD4zLiBSZXN1bHRpbmcgc2VsZWN0b3I8L0xhYmVsPlxuICAgICAgICAgIDxkaXYgYXJpYS1sYWJlbD1cInNlbGVjdG9yXCIgY2xhc3NOYW1lPXtzdHlsZXMuc2VsZWN0b3J9PlxuICAgICAgICAgICAge3NlbGVjdG9yfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHt2YWxpZGF0aW9uU3RhdHVzICYmIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmFsaWRhdGlvblN0YXR1c30+e3ZhbGlkYXRpb25TdGF0dXN9PC9kaXY+fVxuICAgICAgICAgIDxIb3Jpem9udGFsR3JvdXA+XG4gICAgICAgICAgICA8QnV0dG9uIGFyaWEtbGFiZWw9XCJVc2Ugc2VsZWN0b3IgYXMgbG9ncyBidXR0b25cIiBkaXNhYmxlZD17ZW1wdHl9IG9uQ2xpY2s9e3RoaXMub25DbGlja1J1bkxvZ3NRdWVyeX0+XG4gICAgICAgICAgICAgIFNob3cgbG9nc1xuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJVc2Ugc2VsZWN0b3IgYXMgbWV0cmljcyBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tSdW5NZXRyaWNzUXVlcnl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFNob3cgbG9ncyByYXRlXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlZhbGlkYXRlIHN1Ym1pdCBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tWYWxpZGF0ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgVmFsaWRhdGUgc2VsZWN0b3JcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBhcmlhLWxhYmVsPVwiU2VsZWN0b3IgY2xlYXIgYnV0dG9uXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMub25DbGlja0NsZWFyfT5cbiAgICAgICAgICAgICAgQ2xlYXJcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2N4KHN0eWxlcy5zdGF0dXMsIChzdGF0dXMgfHwgZXJyb3IpICYmIHN0eWxlcy5zdGF0dXNTaG93aW5nKX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZXJyb3IgPyBzdHlsZXMuZXJyb3IgOiAnJ30+e2Vycm9yIHx8IHN0YXR1c308L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L0hvcml6b250YWxHcm91cD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpTGFiZWxCcm93c2VyID0gd2l0aFRoZW1lMihVbnRoZW1lZExva2lMYWJlbEJyb3dzZXIpO1xuIiwiLy8gTGlicmFyaWVzXG5pbXBvcnQgUmVhY3QsIHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNzcywgY3ggfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnbG9kYXNoJztcblxuLy8gVHlwZXNcbmltcG9ydCB7IElubGluZUZvcm1MYWJlbCwgUmFkaW9CdXR0b25Hcm91cCwgSW5saW5lRmllbGQsIElucHV0LCBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5LCBMb2tpUXVlcnlUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExva2lPcHRpb25GaWVsZHNQcm9wcyB7XG4gIGxpbmVMaW1pdFZhbHVlOiBzdHJpbmc7XG4gIHJlc29sdXRpb246IG51bWJlcjtcbiAgcXVlcnk6IExva2lRdWVyeTtcbiAgb25DaGFuZ2U6ICh2YWx1ZTogTG9raVF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xuICBydW5PbkJsdXI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgcXVlcnlUeXBlT3B0aW9uczogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPExva2lRdWVyeVR5cGU+PiA9IFtcbiAgeyB2YWx1ZTogTG9raVF1ZXJ5VHlwZS5SYW5nZSwgbGFiZWw6ICdSYW5nZScsIGRlc2NyaXB0aW9uOiAnUnVuIHF1ZXJ5IG92ZXIgYSByYW5nZSBvZiB0aW1lLicgfSxcbiAge1xuICAgIHZhbHVlOiBMb2tpUXVlcnlUeXBlLkluc3RhbnQsXG4gICAgbGFiZWw6ICdJbnN0YW50JyxcbiAgICBkZXNjcmlwdGlvbjogJ1J1biBxdWVyeSBhZ2FpbnN0IGEgc2luZ2xlIHBvaW50IGluIHRpbWUuIEZvciB0aGlzIHF1ZXJ5LCB0aGUgXCJUb1wiIHRpbWUgaXMgdXNlZC4nLFxuICB9LFxuXTtcblxuaWYgKGNvbmZpZy5mZWF0dXJlVG9nZ2xlcy5sb2tpTGl2ZSkge1xuICBxdWVyeVR5cGVPcHRpb25zLnB1c2goe1xuICAgIHZhbHVlOiBMb2tpUXVlcnlUeXBlLlN0cmVhbSxcbiAgICBsYWJlbDogJ1N0cmVhbScsXG4gICAgZGVzY3JpcHRpb246ICdSdW4gYSBxdWVyeSBhbmQga2VlcCBzZW5kaW5nIHJlc3VsdHMgb24gYW4gaW50ZXJ2YWwnLFxuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVTT0xVVElPTjogU2VsZWN0YWJsZVZhbHVlPG51bWJlcj4gPSB7XG4gIHZhbHVlOiAxLFxuICBsYWJlbDogJzEvMScsXG59O1xuXG5leHBvcnQgY29uc3QgUkVTT0xVVElPTl9PUFRJT05TOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPj4gPSBbREVGQVVMVF9SRVNPTFVUSU9OXS5jb25jYXQoXG4gIG1hcChbMiwgMywgNCwgNSwgMTBdLCAodmFsdWU6IG51bWJlcikgPT4gKHtcbiAgICB2YWx1ZSxcbiAgICBsYWJlbDogJzEvJyArIHZhbHVlLFxuICB9KSlcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBMb2tpT3B0aW9uRmllbGRzKHByb3BzOiBMb2tpT3B0aW9uRmllbGRzUHJvcHMpIHtcbiAgY29uc3QgeyBsaW5lTGltaXRWYWx1ZSwgcmVzb2x1dGlvbiwgb25SdW5RdWVyeSwgcnVuT25CbHVyLCBvbkNoYW5nZSB9ID0gcHJvcHM7XG4gIGNvbnN0IHF1ZXJ5ID0gcHJvcHMucXVlcnkgPz8ge307XG4gIGxldCBxdWVyeVR5cGUgPSBxdWVyeS5xdWVyeVR5cGUgPz8gKHF1ZXJ5Lmluc3RhbnQgPyBMb2tpUXVlcnlUeXBlLkluc3RhbnQgOiBMb2tpUXVlcnlUeXBlLlJhbmdlKTtcblxuICBmdW5jdGlvbiBvbkNoYW5nZVF1ZXJ5TGltaXQodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IG5leHRRdWVyeSA9IHsgLi4ucXVlcnksIG1heExpbmVzOiBwcmVwcm9jZXNzTWF4TGluZXModmFsdWUpIH07XG4gICAgb25DaGFuZ2UobmV4dFF1ZXJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUXVlcnlUeXBlQ2hhbmdlKHF1ZXJ5VHlwZTogTG9raVF1ZXJ5VHlwZSkge1xuICAgIGNvbnN0IHsgaW5zdGFudCwgcmFuZ2UsIC4uLnJlc3QgfSA9IHF1ZXJ5O1xuICAgIG9uQ2hhbmdlKHsgLi4ucmVzdCwgcXVlcnlUeXBlIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25NYXhMaW5lc0NoYW5nZShlOiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50Pikge1xuICAgIGlmIChxdWVyeS5tYXhMaW5lcyAhPT0gcHJlcHJvY2Vzc01heExpbmVzKGUuY3VycmVudFRhcmdldC52YWx1ZSkpIHtcbiAgICAgIG9uQ2hhbmdlUXVlcnlMaW1pdChlLmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmV0dXJuS2V5RG93bihlOiBSZWFjdC5LZXlib2FyZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSB7XG4gICAgaWYgKGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICBvblJ1blF1ZXJ5KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXNvbHV0aW9uQ2hhbmdlKG9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPG51bWJlcj4pIHtcbiAgICBjb25zdCBuZXh0UXVlcnkgPSB7IC4uLnF1ZXJ5LCByZXNvbHV0aW9uOiBvcHRpb24udmFsdWUgfTtcbiAgICBvbkNoYW5nZShuZXh0UXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGFyaWEtbGFiZWw9XCJMb2tpIGV4dHJhIGZpZWxkXCIgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgIHsvKlF1ZXJ5IHR5cGUgZmllbGQqL31cbiAgICAgIDxkaXZcbiAgICAgICAgZGF0YS10ZXN0aWQ9XCJxdWVyeVR5cGVGaWVsZFwiXG4gICAgICAgIGNsYXNzTmFtZT17Y3goXG4gICAgICAgICAgJ2dmLWZvcm0gZXhwbG9yZS1pbnB1dC1tYXJnaW4nLFxuICAgICAgICAgIGNzc2BcbiAgICAgICAgICAgIGZsZXgtd3JhcDogbm93cmFwO1xuICAgICAgICAgIGBcbiAgICAgICAgKX1cbiAgICAgICAgYXJpYS1sYWJlbD1cIlF1ZXJ5IHR5cGUgZmllbGRcIlxuICAgICAgPlxuICAgICAgICA8SW5saW5lRm9ybUxhYmVsIHdpZHRoPVwiYXV0b1wiPlF1ZXJ5IHR5cGU8L0lubGluZUZvcm1MYWJlbD5cblxuICAgICAgICA8UmFkaW9CdXR0b25Hcm91cFxuICAgICAgICAgIG9wdGlvbnM9e3F1ZXJ5VHlwZU9wdGlvbnN9XG4gICAgICAgICAgdmFsdWU9e3F1ZXJ5VHlwZX1cbiAgICAgICAgICBvbkNoYW5nZT17KHR5cGU6IExva2lRdWVyeVR5cGUpID0+IHtcbiAgICAgICAgICAgIG9uUXVlcnlUeXBlQ2hhbmdlKHR5cGUpO1xuICAgICAgICAgICAgaWYgKHJ1bk9uQmx1cikge1xuICAgICAgICAgICAgICBvblJ1blF1ZXJ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgICAgey8qTGluZSBsaW1pdCBmaWVsZCovfVxuICAgICAgPGRpdlxuICAgICAgICBkYXRhLXRlc3RpZD1cImxpbmVMaW1pdEZpZWxkXCJcbiAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAnZ2YtZm9ybScsXG4gICAgICAgICAgY3NzYFxuICAgICAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAgICAgICAgYFxuICAgICAgICApfVxuICAgICAgICBhcmlhLWxhYmVsPVwiTGluZSBsaW1pdCBmaWVsZFwiXG4gICAgICA+XG4gICAgICAgIDxJbmxpbmVGaWVsZCBsYWJlbD1cIkxpbmUgbGltaXRcIiB0b29sdGlwPXsnVXBwZXIgbGltaXQgZm9yIG51bWJlciBvZiBsb2cgbGluZXMgcmV0dXJuZWQgYnkgcXVlcnkuJ30+XG4gICAgICAgICAgPElucHV0XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC00XCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiYXV0b1wiXG4gICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgIG1pbj17MH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbk1heExpbmVzQ2hhbmdlfVxuICAgICAgICAgICAgb25LZXlEb3duPXtvblJldHVybktleURvd259XG4gICAgICAgICAgICB2YWx1ZT17bGluZUxpbWl0VmFsdWV9XG4gICAgICAgICAgICBvbkJsdXI9eygpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJ1bk9uQmx1cikge1xuICAgICAgICAgICAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgICA8SW5saW5lRmllbGRcbiAgICAgICAgICBsYWJlbD1cIlJlc29sdXRpb25cIlxuICAgICAgICAgIHRvb2x0aXA9e1xuICAgICAgICAgICAgJ1Jlc29sdXRpb24gMS8xIHNldHMgc3RlcCBwYXJhbWV0ZXIgb2YgTG9raSBtZXRyaWNzIHJhbmdlIHF1ZXJpZXMgc3VjaCB0aGF0IGVhY2ggcGl4ZWwgY29ycmVzcG9uZHMgdG8gb25lIGRhdGEgcG9pbnQuIEZvciBiZXR0ZXIgcGVyZm9ybWFuY2UsIGxvd2VyIHJlc29sdXRpb25zIGNhbiBiZSBwaWNrZWQuIDEvMiBvbmx5IHJldHJpZXZlcyBhIGRhdGEgcG9pbnQgZm9yIGV2ZXJ5IG90aGVyIHBpeGVsLCBhbmQgMS8xMCByZXRyaWV2ZXMgb25lIGRhdGEgcG9pbnQgcGVyIDEwIHBpeGVscy4nXG4gICAgICAgICAgfVxuICAgICAgICA+XG4gICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgaXNTZWFyY2hhYmxlPXtmYWxzZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvblJlc29sdXRpb25DaGFuZ2V9XG4gICAgICAgICAgICBvcHRpb25zPXtSRVNPTFVUSU9OX09QVElPTlN9XG4gICAgICAgICAgICB2YWx1ZT17cmVzb2x1dGlvbn1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgcmVzb2x1dGlvblwiXG4gICAgICAgICAgICBtZW51U2hvdWxkUG9ydGFsXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9JbmxpbmVGaWVsZD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vKExva2lPcHRpb25GaWVsZHMpO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2Vzc01heExpbmVzKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZW1wdHkgaW5wdXQgLSBmYWxscyBiYWNrIHRvIGRhdGFTb3VyY2UubWF4TGluZXMgbGltaXRcbiAgICByZXR1cm4gTmFOO1xuICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgKGlzTmFOKCt2YWx1ZSkgfHwgK3ZhbHVlIDwgMCkpIHtcbiAgICAvLyBpbnB1dCB3aXRoIGF0IGxlYXN0IDEgY2hhcmFjdGVyIGFuZCB0aGF0IGlzIGVpdGhlciBpbmNvcnJlY3QgKHZhbHVlIGluIHRoZSBpbnB1dCBmaWVsZCBpcyBub3QgYSBudW1iZXIpIG9yIG5lZ2F0aXZlXG4gICAgLy8gZmFsbHMgYmFjayB0byB0aGUgbGltaXQgb2YgMCBsaW5lc1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlZmF1bHQgY2FzZSAtIGNvcnJlY3QgaW5wdXRcbiAgICByZXR1cm4gK3ZhbHVlO1xuICB9XG59XG4iLCIvLyBMaWJyYXJpZXNcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8vIFR5cGVzXG5pbXBvcnQgeyBJbmxpbmVGb3JtTGFiZWwgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBMb2tpUXVlcnlGaWVsZCB9IGZyb20gJy4vTG9raVF1ZXJ5RmllbGQnO1xuaW1wb3J0IHsgTG9raU9wdGlvbkZpZWxkcyB9IGZyb20gJy4vTG9raU9wdGlvbkZpZWxkcyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTG9raVF1ZXJ5RWRpdG9yKHByb3BzOiBMb2tpUXVlcnlFZGl0b3JQcm9wcykge1xuICBjb25zdCB7IHF1ZXJ5LCBkYXRhLCBkYXRhc291cmNlLCBvbkNoYW5nZSwgb25SdW5RdWVyeSwgcmFuZ2UgfSA9IHByb3BzO1xuXG4gIGNvbnN0IG9uTGVnZW5kQ2hhbmdlID0gKGU6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbmV4dFF1ZXJ5ID0geyAuLi5xdWVyeSwgbGVnZW5kRm9ybWF0OiBlLmN1cnJlbnRUYXJnZXQudmFsdWUgfTtcbiAgICBvbkNoYW5nZShuZXh0UXVlcnkpO1xuICB9O1xuXG4gIGNvbnN0IGxlZ2VuZEZpZWxkID0gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICA8SW5saW5lRm9ybUxhYmVsXG4gICAgICAgICAgd2lkdGg9ezZ9XG4gICAgICAgICAgdG9vbHRpcD1cIkNvbnRyb2xzIHRoZSBuYW1lIG9mIHRoZSB0aW1lIHNlcmllcywgdXNpbmcgbmFtZSBvciBwYXR0ZXJuLiBGb3IgZXhhbXBsZVxuICAgICAgICB7e2hvc3RuYW1lfX0gd2lsbCBiZSByZXBsYWNlZCB3aXRoIGxhYmVsIHZhbHVlIGZvciB0aGUgbGFiZWwgaG9zdG5hbWUuIFRoZSBsZWdlbmQgb25seSBhcHBsaWVzIHRvIG1ldHJpYyBxdWVyaWVzLlwiXG4gICAgICAgID5cbiAgICAgICAgICBMZWdlbmRcbiAgICAgICAgPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJnZi1mb3JtLWlucHV0XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cImxlZ2VuZCBmb3JtYXRcIlxuICAgICAgICAgIHZhbHVlPXtxdWVyeS5sZWdlbmRGb3JtYXQgfHwgJyd9XG4gICAgICAgICAgb25DaGFuZ2U9e29uTGVnZW5kQ2hhbmdlfVxuICAgICAgICAgIG9uQmx1cj17b25SdW5RdWVyeX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPExva2lRdWVyeUZpZWxkXG4gICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgIG9uQmx1cj17b25SdW5RdWVyeX1cbiAgICAgIGhpc3Rvcnk9e1tdfVxuICAgICAgZGF0YT17ZGF0YX1cbiAgICAgIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLmVkaXRvcn1cbiAgICAgIHJhbmdlPXtyYW5nZX1cbiAgICAgIEV4dHJhRmllbGRFbGVtZW50PXtcbiAgICAgICAgPD5cbiAgICAgICAgICA8TG9raU9wdGlvbkZpZWxkc1xuICAgICAgICAgICAgbGluZUxpbWl0VmFsdWU9e3F1ZXJ5Py5tYXhMaW5lcz8udG9TdHJpbmcoKSB8fCAnJ31cbiAgICAgICAgICAgIHJlc29sdXRpb249e3F1ZXJ5Py5yZXNvbHV0aW9uIHx8IDF9XG4gICAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgcnVuT25CbHVyPXt0cnVlfVxuICAgICAgICAgIC8+XG4gICAgICAgICAge2xlZ2VuZEZpZWxkfVxuICAgICAgICA8Lz5cbiAgICAgIH1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgY29uc3QgdGVzdElkcyA9IHtcbiAgZWRpdG9yOiAnbG9raS1lZGl0b3InLFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ29yZUFwcCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvciB9IGZyb20gJy4vTG9raVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvckZvckFsZXJ0aW5nIH0gZnJvbSAnLi9Mb2tpUXVlcnlFZGl0b3JGb3JBbGVydGluZyc7XG5pbXBvcnQgeyBMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yIH0gZnJvbSAnLi9Mb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvclNlbGVjdG9yIH0gZnJvbSAnLi4vcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3InO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBMb2tpUXVlcnlFZGl0b3JCeUFwcChwcm9wczogTG9raVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgeyBhcHAgfSA9IHByb3BzO1xuXG4gIHN3aXRjaCAoYXBwKSB7XG4gICAgY2FzZSBDb3JlQXBwLkNsb3VkQWxlcnRpbmc6XG4gICAgICByZXR1cm4gPExva2lRdWVyeUVkaXRvckZvckFsZXJ0aW5nIHsuLi5wcm9wc30gLz47XG4gICAgY2FzZSBDb3JlQXBwLkV4cGxvcmU6XG4gICAgICBpZiAoY29uZmlnLmZlYXR1cmVUb2dnbGVzLmxva2lRdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgcmV0dXJuIDxMb2tpUXVlcnlFZGl0b3JTZWxlY3RvciB7Li4ucHJvcHN9IC8+O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDxMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yIHsuLi5wcm9wc30gLz47XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjb25maWcuZmVhdHVyZVRvZ2dsZXMubG9raVF1ZXJ5QnVpbGRlcikge1xuICAgICAgICByZXR1cm4gPExva2lRdWVyeUVkaXRvclNlbGVjdG9yIHsuLi5wcm9wc30gLz47XG4gICAgICB9XG4gICAgICByZXR1cm4gPExva2lRdWVyeUVkaXRvciB7Li4ucHJvcHN9IC8+O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW8oTG9raVF1ZXJ5RWRpdG9yQnlBcHApO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExva2lRdWVyeUZpZWxkIH0gZnJvbSAnLi9Mb2tpUXVlcnlGaWVsZCc7XG5pbXBvcnQgeyBMb2tpUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTG9raVF1ZXJ5RWRpdG9yRm9yQWxlcnRpbmcocHJvcHM6IExva2lRdWVyeUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IHsgcXVlcnksIGRhdGEsIGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSBwcm9wcztcblxuICByZXR1cm4gKFxuICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICBvbkJsdXI9e29uUnVuUXVlcnl9XG4gICAgICBoaXN0b3J5PXtbXX1cbiAgICAgIGRhdGE9e2RhdGF9XG4gICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIGEgTG9raSBxdWVyeVwiXG4gICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGVkaXRvcjogJ2xva2ktZWRpdG9yLWNsb3VkLWFsZXJ0aW5nJyxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgU2xhdGVQcmlzbSxcbiAgVHlwZWFoZWFkT3V0cHV0LFxuICBTdWdnZXN0aW9uc1N0YXRlLFxuICBRdWVyeUZpZWxkLFxuICBUeXBlYWhlYWRJbnB1dCxcbiAgQnJhY2VzUGx1Z2luLFxuICBET01VdGlsLFxuICBJY29uLFxufSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBQbHVnaW4sIE5vZGUgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBMb2tpTGFiZWxCcm93c2VyIH0gZnJvbSAnLi9Mb2tpTGFiZWxCcm93c2VyJztcbmltcG9ydCB7IFF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMYW5ndWFnZU1hcCwgbGFuZ3VhZ2VzIGFzIHByaXNtTGFuZ3VhZ2VzIH0gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgTG9raUxhbmd1YWdlUHJvdmlkZXIgZnJvbSAnLi4vbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgc2hvdWxkUmVmcmVzaExhYmVscyB9IGZyb20gJy4uL2xhbmd1YWdlX3V0aWxzJztcbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBMb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyIH0gZnJvbSAnYXBwL2NvcmUvY29tcG9uZW50cy9Mb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyJztcblxuY29uc3QgTEFTVF9VU0VEX0xBQkVMU19LRVkgPSAnZ3JhZmFuYS5kYXRhc291cmNlcy5sb2tpLmJyb3dzZXIubGFiZWxzJztcblxuZnVuY3Rpb24gZ2V0Q2hvb3NlclRleHQoaGFzU3ludGF4OiBib29sZWFuLCBoYXNMb2dMYWJlbHM6IGJvb2xlYW4pIHtcbiAgaWYgKCFoYXNTeW50YXgpIHtcbiAgICByZXR1cm4gJ0xvYWRpbmcgbGFiZWxzLi4uJztcbiAgfVxuICBpZiAoIWhhc0xvZ0xhYmVscykge1xuICAgIHJldHVybiAnKE5vIGxvZ3MgZm91bmQpJztcbiAgfVxuICByZXR1cm4gJ0xvZyBicm93c2VyJztcbn1cblxuZnVuY3Rpb24gd2lsbEFwcGx5U3VnZ2VzdGlvbihzdWdnZXN0aW9uOiBzdHJpbmcsIHsgdHlwZWFoZWFkQ29udGV4dCwgdHlwZWFoZWFkVGV4dCB9OiBTdWdnZXN0aW9uc1N0YXRlKTogc3RyaW5nIHtcbiAgLy8gTW9kaWZ5IHN1Z2dlc3Rpb24gYmFzZWQgb24gY29udGV4dFxuICBzd2l0Y2ggKHR5cGVhaGVhZENvbnRleHQpIHtcbiAgICBjYXNlICdjb250ZXh0LWxhYmVscyc6IHtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gRE9NVXRpbC5nZXROZXh0Q2hhcmFjdGVyKCk7XG4gICAgICBpZiAoIW5leHRDaGFyIHx8IG5leHRDaGFyID09PSAnfScgfHwgbmV4dENoYXIgPT09ICcsJykge1xuICAgICAgICBzdWdnZXN0aW9uICs9ICc9JztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ2NvbnRleHQtbGFiZWwtdmFsdWVzJzoge1xuICAgICAgLy8gQWx3YXlzIGFkZCBxdW90ZXMgYW5kIHJlbW92ZSBleGlzdGluZyBvbmVzIGluc3RlYWRcbiAgICAgIGlmICghdHlwZWFoZWFkVGV4dC5tYXRjaCgvXighPz1+P1wifFwiKS8pKSB7XG4gICAgICAgIHN1Z2dlc3Rpb24gPSBgXCIke3N1Z2dlc3Rpb259YDtcbiAgICAgIH1cbiAgICAgIGlmIChET01VdGlsLmdldE5leHRDaGFyYWN0ZXIoKSAhPT0gJ1wiJykge1xuICAgICAgICBzdWdnZXN0aW9uID0gYCR7c3VnZ2VzdGlvbn1cImA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiBzdWdnZXN0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lRdWVyeUZpZWxkUHJvcHMgZXh0ZW5kcyBRdWVyeUVkaXRvclByb3BzPExva2lEYXRhc291cmNlLCBMb2tpUXVlcnksIExva2lPcHRpb25zPiB7XG4gIEV4dHJhRmllbGRFbGVtZW50PzogUmVhY3ROb2RlO1xuICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgJ2RhdGEtdGVzdGlkJz86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIExva2lRdWVyeUZpZWxkU3RhdGUge1xuICBsYWJlbHNMb2FkZWQ6IGJvb2xlYW47XG4gIGxhYmVsQnJvd3NlclZpc2libGU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBMb2tpUXVlcnlGaWVsZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8TG9raVF1ZXJ5RmllbGRQcm9wcywgTG9raVF1ZXJ5RmllbGRTdGF0ZT4ge1xuICBwbHVnaW5zOiBQbHVnaW5bXTtcbiAgX2lzTW91bnRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBMb2tpUXVlcnlGaWVsZFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHsgbGFiZWxzTG9hZGVkOiBmYWxzZSwgbGFiZWxCcm93c2VyVmlzaWJsZTogZmFsc2UgfTtcblxuICAgIHRoaXMucGx1Z2lucyA9IFtcbiAgICAgIEJyYWNlc1BsdWdpbigpLFxuICAgICAgU2xhdGVQcmlzbShcbiAgICAgICAge1xuICAgICAgICAgIG9ubHlJbjogKG5vZGU6IE5vZGUpID0+IG5vZGUub2JqZWN0ID09PSAnYmxvY2snICYmIG5vZGUudHlwZSA9PT0gJ2NvZGVfYmxvY2snLFxuICAgICAgICAgIGdldFN5bnRheDogKG5vZGU6IE5vZGUpID0+ICdsb2dxbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHsgLi4uKHByaXNtTGFuZ3VhZ2VzIGFzIExhbmd1YWdlTWFwKSwgbG9ncWw6IHRoaXMucHJvcHMuZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldFN5bnRheCgpIH1cbiAgICAgICksXG4gICAgXTtcbiAgfVxuXG4gIGFzeW5jIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgYXdhaXQgdGhpcy5wcm9wcy5kYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKTtcbiAgICBpZiAodGhpcy5faXNNb3VudGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzTG9hZGVkOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogTG9raVF1ZXJ5RmllbGRQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhbmdlLFxuICAgICAgZGF0YXNvdXJjZTogeyBsYW5ndWFnZVByb3ZpZGVyIH0sXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcmVmcmVzaExhYmVscyA9IHNob3VsZFJlZnJlc2hMYWJlbHMocmFuZ2UsIHByZXZQcm9wcy5yYW5nZSk7XG4gICAgLy8gV2Ugd2FudCB0byByZWZyZXNoIGxhYmVscyB3aGVuIHJhbmdlIGNoYW5nZXMgKHdlIHJvdW5kIHVwIGludGVydmFscyB0byBhIG1pbnV0ZSlcbiAgICBpZiAocmVmcmVzaExhYmVscykge1xuICAgICAgbGFuZ3VhZ2VQcm92aWRlci5mZXRjaExhYmVscygpO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2hhbmdlTGFiZWxCcm93c2VyID0gKHNlbGVjdG9yOiBzdHJpbmcpID0+IHtcbiAgICB0aGlzLm9uQ2hhbmdlUXVlcnkoc2VsZWN0b3IsIHRydWUpO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbEJyb3dzZXJWaXNpYmxlOiBmYWxzZSB9KTtcbiAgfTtcblxuICBvbkNoYW5nZVF1ZXJ5ID0gKHZhbHVlOiBzdHJpbmcsIG92ZXJyaWRlPzogYm9vbGVhbikgPT4ge1xuICAgIC8vIFNlbmQgdGV4dCBjaGFuZ2UgdG8gcGFyZW50XG4gICAgY29uc3QgeyBxdWVyeSwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBjb25zdCBuZXh0UXVlcnkgPSB7IC4uLnF1ZXJ5LCBleHByOiB2YWx1ZSB9O1xuICAgICAgb25DaGFuZ2UobmV4dFF1ZXJ5KTtcblxuICAgICAgaWYgKG92ZXJyaWRlICYmIG9uUnVuUXVlcnkpIHtcbiAgICAgICAgb25SdW5RdWVyeSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvbkNsaWNrQ2hvb3NlckJ1dHRvbiA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKChzdGF0ZSkgPT4gKHsgbGFiZWxCcm93c2VyVmlzaWJsZTogIXN0YXRlLmxhYmVsQnJvd3NlclZpc2libGUgfSkpO1xuICB9O1xuXG4gIG9uVHlwZWFoZWFkID0gYXN5bmMgKHR5cGVhaGVhZDogVHlwZWFoZWFkSW5wdXQpOiBQcm9taXNlPFR5cGVhaGVhZE91dHB1dD4gPT4ge1xuICAgIGNvbnN0IHsgZGF0YXNvdXJjZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4geyBzdWdnZXN0aW9uczogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2tpTGFuZ3VhZ2VQcm92aWRlciA9IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlciBhcyBMb2tpTGFuZ3VhZ2VQcm92aWRlcjtcbiAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBwcmVmaXgsIHRleHQsIHZhbHVlLCB3cmFwcGVyQ2xhc3NlcywgbGFiZWxLZXkgfSA9IHR5cGVhaGVhZDtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxva2lMYW5ndWFnZVByb3ZpZGVyLnByb3ZpZGVDb21wbGV0aW9uSXRlbXMoXG4gICAgICB7IHRleHQsIHZhbHVlLCBwcmVmaXgsIHdyYXBwZXJDbGFzc2VzLCBsYWJlbEtleSB9LFxuICAgICAgeyBoaXN0b3J5IH1cbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIEV4dHJhRmllbGRFbGVtZW50LFxuICAgICAgcXVlcnksXG4gICAgICBkYXRhc291cmNlLFxuICAgICAgcGxhY2Vob2xkZXIgPSAnRW50ZXIgYSBMb2tpIHF1ZXJ5IChydW4gd2l0aCBTaGlmdCtFbnRlciknLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgeyBsYWJlbHNMb2FkZWQsIGxhYmVsQnJvd3NlclZpc2libGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbG9raUxhbmd1YWdlUHJvdmlkZXIgPSBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIgYXMgTG9raUxhbmd1YWdlUHJvdmlkZXI7XG4gICAgY29uc3QgY2xlYW5UZXh0ID0gZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyID8gbG9raUxhbmd1YWdlUHJvdmlkZXIuY2xlYW5UZXh0IDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGhhc0xvZ0xhYmVscyA9IGxva2lMYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsS2V5cygpLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgY2hvb3NlclRleHQgPSBnZXRDaG9vc2VyVGV4dChsYWJlbHNMb2FkZWQsIGhhc0xvZ0xhYmVscyk7XG4gICAgY29uc3QgYnV0dG9uRGlzYWJsZWQgPSAhKGxhYmVsc0xvYWRlZCAmJiBoYXNMb2dMYWJlbHMpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyPHN0cmluZ1tdPiBzdG9yYWdlS2V5PXtMQVNUX1VTRURfTEFCRUxTX0tFWX0gZGVmYXVsdFZhbHVlPXtbXX0+XG4gICAgICAgIHsobGFzdFVzZWRMYWJlbHMsIG9uTGFzdFVzZWRMYWJlbHNTYXZlLCBvbkxhc3RVc2VkTGFiZWxzRGVsZXRlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZSBnZi1mb3JtLWlubGluZS0teHMtdmlldy1mbGV4LWNvbHVtbiBmbGV4LWdyb3ctMVwiXG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9e3RoaXMucHJvcHNbJ2RhdGEtdGVzdGlkJ119XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZi1mb3JtLWxhYmVsIHF1ZXJ5LWtleXdvcmQgcG9pbnRlclwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tDaG9vc2VyQnV0dG9ufVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2J1dHRvbkRpc2FibGVkfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtjaG9vc2VyVGV4dH1cbiAgICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9e2xhYmVsQnJvd3NlclZpc2libGUgPyAnYW5nbGUtZG93bicgOiAnYW5nbGUtcmlnaHQnfSAvPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybSBnZi1mb3JtLS1ncm93IGZsZXgtc2hyaW5rLTEgbWluLXdpZHRoLTE1XCI+XG4gICAgICAgICAgICAgICAgICA8UXVlcnlGaWVsZFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUGx1Z2lucz17dGhpcy5wbHVnaW5zfVxuICAgICAgICAgICAgICAgICAgICBjbGVhblRleHQ9e2NsZWFuVGV4dH1cbiAgICAgICAgICAgICAgICAgICAgcXVlcnk9e3F1ZXJ5LmV4cHJ9XG4gICAgICAgICAgICAgICAgICAgIG9uVHlwZWFoZWFkPXt0aGlzLm9uVHlwZWFoZWFkfVxuICAgICAgICAgICAgICAgICAgICBvbldpbGxBcHBseVN1Z2dlc3Rpb249e3dpbGxBcHBseVN1Z2dlc3Rpb259XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlUXVlcnl9XG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cj17dGhpcy5wcm9wcy5vbkJsdXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uUnVuUXVlcnk9e3RoaXMucHJvcHMub25SdW5RdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgICAgICBwb3J0YWxPcmlnaW49XCJsb2tpXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7bGFiZWxCcm93c2VyVmlzaWJsZSAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgICAgICA8TG9raUxhYmVsQnJvd3NlclxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVByb3ZpZGVyPXtsb2tpTGFuZ3VhZ2VQcm92aWRlcn1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2VMYWJlbEJyb3dzZXJ9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RVc2VkTGFiZWxzPXtsYXN0VXNlZExhYmVscyB8fCBbXX1cbiAgICAgICAgICAgICAgICAgICAgc3RvcmVMYXN0VXNlZExhYmVscz17b25MYXN0VXNlZExhYmVsc1NhdmV9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUxhc3RVc2VkTGFiZWxzPXtvbkxhc3RVc2VkTGFiZWxzRGVsZXRlfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICB7RXh0cmFGaWVsZEVsZW1lbnR9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgICApO1xuICAgICAgICB9fVxuICAgICAgPC9Mb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyPlxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEYXRhU291cmNlUGx1Z2luT3B0aW9uc0VkaXRvclByb3BzLCBEYXRhU291cmNlU2V0dGluZ3MgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEFsZXJ0aW5nU2V0dGluZ3MsIERhdGFTb3VyY2VIdHRwU2V0dGluZ3MgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBMb2tpT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IE1heExpbmVzRmllbGQgfSBmcm9tICcuL01heExpbmVzRmllbGQnO1xuaW1wb3J0IHsgRGVyaXZlZEZpZWxkcyB9IGZyb20gJy4vRGVyaXZlZEZpZWxkcyc7XG5pbXBvcnQgeyBnZXRBbGxBbGVydG1hbmFnZXJEYXRhU291cmNlcyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9hbGVydGluZy91bmlmaWVkL3V0aWxzL2FsZXJ0bWFuYWdlcic7XG5cbmV4cG9ydCB0eXBlIFByb3BzID0gRGF0YVNvdXJjZVBsdWdpbk9wdGlvbnNFZGl0b3JQcm9wczxMb2tpT3B0aW9ucz47XG5cbmNvbnN0IG1ha2VKc29uVXBkYXRlciA9XG4gIDxUIGV4dGVuZHMgYW55PihmaWVsZDoga2V5b2YgTG9raU9wdGlvbnMpID0+XG4gIChvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8TG9raU9wdGlvbnM+LCB2YWx1ZTogVCk6IERhdGFTb3VyY2VTZXR0aW5nczxMb2tpT3B0aW9ucz4gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAganNvbkRhdGE6IHtcbiAgICAgICAgLi4ub3B0aW9ucy5qc29uRGF0YSxcbiAgICAgICAgW2ZpZWxkXTogdmFsdWUsXG4gICAgICB9LFxuICAgIH07XG4gIH07XG5cbmNvbnN0IHNldE1heExpbmVzID0gbWFrZUpzb25VcGRhdGVyKCdtYXhMaW5lcycpO1xuY29uc3Qgc2V0RGVyaXZlZEZpZWxkcyA9IG1ha2VKc29uVXBkYXRlcignZGVyaXZlZEZpZWxkcycpO1xuXG5leHBvcnQgY29uc3QgQ29uZmlnRWRpdG9yID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICBjb25zdCB7IG9wdGlvbnMsIG9uT3B0aW9uc0NoYW5nZSB9ID0gcHJvcHM7XG4gIGNvbnN0IGFsZXJ0bWFuYWdlcnMgPSBnZXRBbGxBbGVydG1hbmFnZXJEYXRhU291cmNlcygpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxEYXRhU291cmNlSHR0cFNldHRpbmdzXG4gICAgICAgIGRlZmF1bHRVcmw9eydodHRwOi8vbG9jYWxob3N0OjMxMDAnfVxuICAgICAgICBkYXRhU291cmNlQ29uZmlnPXtvcHRpb25zfVxuICAgICAgICBzaG93QWNjZXNzT3B0aW9ucz17ZmFsc2V9XG4gICAgICAgIG9uQ2hhbmdlPXtvbk9wdGlvbnNDaGFuZ2V9XG4gICAgICAvPlxuXG4gICAgICA8QWxlcnRpbmdTZXR0aW5nczxMb2tpT3B0aW9ucz5cbiAgICAgICAgYWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXM9e2FsZXJ0bWFuYWdlcnN9XG4gICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XG4gICAgICAgIG9uT3B0aW9uc0NoYW5nZT17b25PcHRpb25zQ2hhbmdlfVxuICAgICAgLz5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWdyb3VwXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgIDxNYXhMaW5lc0ZpZWxkXG4gICAgICAgICAgICAgIHZhbHVlPXtvcHRpb25zLmpzb25EYXRhLm1heExpbmVzIHx8ICcnfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiBvbk9wdGlvbnNDaGFuZ2Uoc2V0TWF4TGluZXMob3B0aW9ucywgdmFsdWUpKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxEZXJpdmVkRmllbGRzXG4gICAgICAgIHZhbHVlPXtvcHRpb25zLmpzb25EYXRhLmRlcml2ZWRGaWVsZHN9XG4gICAgICAgIG9uQ2hhbmdlPXsodmFsdWUpID0+IG9uT3B0aW9uc0NoYW5nZShzZXREZXJpdmVkRmllbGRzKG9wdGlvbnMsIHZhbHVlKSl9XG4gICAgICAvPlxuICAgIDwvPlxuICApO1xufTtcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBMZWdhY3lGb3JtcyB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmNvbnN0IHsgRm9ybUZpZWxkIH0gPSBMZWdhY3lGb3JtcztcbmltcG9ydCB7IERlcml2ZWRGaWVsZENvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEFycmF5VmVjdG9yLCBGaWVsZCwgRmllbGRUeXBlLCBMaW5rTW9kZWwgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGdldEZpZWxkTGlua3NGb3JFeHBsb3JlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZmVhdHVyZXMvZXhwbG9yZS91dGlscy9saW5rcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGRlcml2ZWRGaWVsZHM/OiBEZXJpdmVkRmllbGRDb25maWdbXTtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufTtcbmV4cG9ydCBjb25zdCBEZWJ1Z1NlY3Rpb24gPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgZGVyaXZlZEZpZWxkcywgY2xhc3NOYW1lIH0gPSBwcm9wcztcbiAgY29uc3QgW2RlYnVnVGV4dCwgc2V0RGVidWdUZXh0XSA9IHVzZVN0YXRlKCcnKTtcblxuICBsZXQgZGVidWdGaWVsZHM6IERlYnVnRmllbGRbXSA9IFtdO1xuICBpZiAoZGVidWdUZXh0ICYmIGRlcml2ZWRGaWVsZHMpIHtcbiAgICBkZWJ1Z0ZpZWxkcyA9IG1ha2VEZWJ1Z0ZpZWxkcyhkZXJpdmVkRmllbGRzLCBkZWJ1Z1RleHQpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgbGFiZWxXaWR0aD17MTJ9XG4gICAgICAgIGxhYmVsPXsnRGVidWcgbG9nIG1lc3NhZ2UnfVxuICAgICAgICBpbnB1dEVsPXtcbiAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsnUGFzdGUgYW4gZXhhbXBsZSBsb2cgbGluZSBoZXJlIHRvIHRlc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb2YgeW91ciBkZXJpdmVkIGZpZWxkcyd9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICAgICAgICAnZ2YtZm9ybS1pbnB1dCBnZi1mb3JtLXRleHRhcmVhJyxcbiAgICAgICAgICAgICAgY3NzYFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICBgXG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgdmFsdWU9e2RlYnVnVGV4dH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHNldERlYnVnVGV4dChldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAvPlxuICAgICAgICB9XG4gICAgICAvPlxuICAgICAgeyEhZGVidWdGaWVsZHMubGVuZ3RoICYmIDxEZWJ1Z0ZpZWxkcyBmaWVsZHM9e2RlYnVnRmllbGRzfSAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbnR5cGUgRGVidWdGaWVsZEl0ZW1Qcm9wcyA9IHtcbiAgZmllbGRzOiBEZWJ1Z0ZpZWxkW107XG59O1xuY29uc3QgRGVidWdGaWVsZHMgPSAoeyBmaWVsZHMgfTogRGVidWdGaWVsZEl0ZW1Qcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDx0YWJsZSBjbGFzc05hbWU9eydmaWx0ZXItdGFibGUnfT5cbiAgICAgIDx0aGVhZD5cbiAgICAgICAgPHRyPlxuICAgICAgICAgIDx0aD5OYW1lPC90aD5cbiAgICAgICAgICA8dGg+VmFsdWU8L3RoPlxuICAgICAgICAgIDx0aD5Vcmw8L3RoPlxuICAgICAgICA8L3RyPlxuICAgICAgPC90aGVhZD5cbiAgICAgIDx0Ym9keT5cbiAgICAgICAge2ZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlOiBhbnkgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgICBpZiAoZmllbGQuZXJyb3IpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmhyZWYpIHtcbiAgICAgICAgICAgIHZhbHVlID0gPGEgaHJlZj17ZmllbGQuaHJlZn0+e3ZhbHVlfTwvYT47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dHIga2V5PXtgJHtmaWVsZC5uYW1lfT0ke2ZpZWxkLnZhbHVlfWB9PlxuICAgICAgICAgICAgICA8dGQ+e2ZpZWxkLm5hbWV9PC90ZD5cbiAgICAgICAgICAgICAgPHRkPnt2YWx1ZX08L3RkPlxuICAgICAgICAgICAgICA8dGQ+e2ZpZWxkLmhyZWYgPyA8YSBocmVmPXtmaWVsZC5ocmVmfT57ZmllbGQuaHJlZn08L2E+IDogJyd9PC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8L3Rib2R5PlxuICAgIDwvdGFibGU+XG4gICk7XG59O1xuXG50eXBlIERlYnVnRmllbGQgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZXJyb3I/OiBhbnk7XG4gIHZhbHVlPzogc3RyaW5nO1xuICBocmVmPzogc3RyaW5nO1xufTtcblxuZnVuY3Rpb24gbWFrZURlYnVnRmllbGRzKGRlcml2ZWRGaWVsZHM6IERlcml2ZWRGaWVsZENvbmZpZ1tdLCBkZWJ1Z1RleHQ6IHN0cmluZyk6IERlYnVnRmllbGRbXSB7XG4gIHJldHVybiBkZXJpdmVkRmllbGRzXG4gICAgLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLm5hbWUgJiYgZmllbGQubWF0Y2hlclJlZ2V4KVxuICAgIC5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0ZXN0TWF0Y2ggPSBkZWJ1Z1RleHQubWF0Y2goZmllbGQubWF0Y2hlclJlZ2V4KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXN0TWF0Y2ggJiYgdGVzdE1hdGNoWzFdO1xuICAgICAgICBsZXQgbGluazogTGlua01vZGVsPEZpZWxkPiB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChmaWVsZC51cmwgJiYgdmFsdWUpIHtcbiAgICAgICAgICBsaW5rID0gZ2V0RmllbGRMaW5rc0ZvckV4cGxvcmUoe1xuICAgICAgICAgICAgZmllbGQ6IHtcbiAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yKFt2YWx1ZV0pLFxuICAgICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICBsaW5rczogW3sgdGl0bGU6ICcnLCB1cmw6IGZpZWxkLnVybCB9XSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb3dJbmRleDogMCxcbiAgICAgICAgICAgIHJhbmdlOiB7fSBhcyBhbnksXG4gICAgICAgICAgfSlbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlIHx8ICc8bm8gbWF0Y2g+JyxcbiAgICAgICAgICBocmVmOiBsaW5rICYmIGxpbmsuaHJlZixcbiAgICAgICAgfSBhcyBEZWJ1Z0ZpZWxkO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICB9IGFzIERlYnVnRmllbGQ7XG4gICAgICB9XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBCdXR0b24sIERhdGFMaW5rSW5wdXQsIHN0eWxlc0ZhY3RvcnksIExlZ2FjeUZvcm1zIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgVmFyaWFibGVTdWdnZXN0aW9uIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBEYXRhU291cmNlUGlja2VyIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBEZXJpdmVkRmllbGRDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB1c2VQcmV2aW91cyB9IGZyb20gJ3JlYWN0LXVzZSc7XG5cbmNvbnN0IHsgU3dpdGNoLCBGb3JtRmllbGQgfSA9IExlZ2FjeUZvcm1zO1xuXG5jb25zdCBnZXRTdHlsZXMgPSBzdHlsZXNGYWN0b3J5KCgpID0+ICh7XG4gIHJvdzogY3NzYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xuICBgLFxuICBuYW1lRmllbGQ6IGNzc2BcbiAgICBmbGV4OiAyO1xuICBgLFxuICByZWdleEZpZWxkOiBjc3NgXG4gICAgZmxleDogMztcbiAgYCxcbiAgdXJsRmllbGQ6IGNzc2BcbiAgICBmbGV4OiAxO1xuICBgLFxuICB1cmxEaXNwbGF5TGFiZWxGaWVsZDogY3NzYFxuICAgIGZsZXg6IDE7XG4gIGAsXG59KSk7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHZhbHVlOiBEZXJpdmVkRmllbGRDb25maWc7XG4gIG9uQ2hhbmdlOiAodmFsdWU6IERlcml2ZWRGaWVsZENvbmZpZykgPT4gdm9pZDtcbiAgb25EZWxldGU6ICgpID0+IHZvaWQ7XG4gIHN1Z2dlc3Rpb25zOiBWYXJpYWJsZVN1Z2dlc3Rpb25bXTtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufTtcbmV4cG9ydCBjb25zdCBEZXJpdmVkRmllbGQgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgdmFsdWUsIG9uQ2hhbmdlLCBvbkRlbGV0ZSwgc3VnZ2VzdGlvbnMsIGNsYXNzTmFtZSB9ID0gcHJvcHM7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlcygpO1xuICBjb25zdCBbc2hvd0ludGVybmFsTGluaywgc2V0U2hvd0ludGVybmFsTGlua10gPSB1c2VTdGF0ZSghIXZhbHVlLmRhdGFzb3VyY2VVaWQpO1xuICBjb25zdCBwcmV2aW91c1VpZCA9IHVzZVByZXZpb3VzKHZhbHVlLmRhdGFzb3VyY2VVaWQpO1xuXG4gIC8vIEZvcmNlIGludGVybmFsIGxpbmsgdmlzaWJpbGl0eSBjaGFuZ2UgaWYgdWlkIGNoYW5nZWQgb3V0c2lkZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXByZXZpb3VzVWlkICYmIHZhbHVlLmRhdGFzb3VyY2VVaWQgJiYgIXNob3dJbnRlcm5hbExpbmspIHtcbiAgICAgIHNldFNob3dJbnRlcm5hbExpbmsodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c1VpZCAmJiAhdmFsdWUuZGF0YXNvdXJjZVVpZCAmJiBzaG93SW50ZXJuYWxMaW5rKSB7XG4gICAgICBzZXRTaG93SW50ZXJuYWxMaW5rKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtwcmV2aW91c1VpZCwgdmFsdWUuZGF0YXNvdXJjZVVpZCwgc2hvd0ludGVybmFsTGlua10pO1xuXG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChmaWVsZDoga2V5b2YgdHlwZW9mIHZhbHVlKSA9PiAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgb25DaGFuZ2Uoe1xuICAgICAgLi4udmFsdWUsXG4gICAgICBbZmllbGRdOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnJvd30+XG4gICAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5uYW1lRmllbGR9XG4gICAgICAgICAgbGFiZWxXaWR0aD17NX1cbiAgICAgICAgICAvLyBBIGJpdCBvZiBhIGhhY2sgdG8gcHJldmVudCB1c2luZyBkZWZhdWx0IHZhbHVlIGZvciB0aGUgd2lkdGggZnJvbSBGb3JtRmllbGRcbiAgICAgICAgICBpbnB1dFdpZHRoPXtudWxsfVxuICAgICAgICAgIGxhYmVsPVwiTmFtZVwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZS5uYW1lfVxuICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2UoJ25hbWUnKX1cbiAgICAgICAgLz5cbiAgICAgICAgPEZvcm1GaWVsZFxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnJlZ2V4RmllbGR9XG4gICAgICAgICAgaW5wdXRXaWR0aD17bnVsbH1cbiAgICAgICAgICBsYWJlbD1cIlJlZ2V4XCJcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgdmFsdWU9e3ZhbHVlLm1hdGNoZXJSZWdleH1cbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlKCdtYXRjaGVyUmVnZXgnKX1cbiAgICAgICAgICB0b29sdGlwPXtcbiAgICAgICAgICAgICdVc2UgdG8gcGFyc2UgYW5kIGNhcHR1cmUgc29tZSBwYXJ0IG9mIHRoZSBsb2cgbWVzc2FnZS4gWW91IGNhbiB1c2UgdGhlIGNhcHR1cmVkIGdyb3VwcyBpbiB0aGUgdGVtcGxhdGUuJ1xuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIHZhcmlhbnQ9XCJkZXN0cnVjdGl2ZVwiXG4gICAgICAgICAgdGl0bGU9XCJSZW1vdmUgZmllbGRcIlxuICAgICAgICAgIGljb249XCJ0aW1lc1wiXG4gICAgICAgICAgb25DbGljaz17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25EZWxldGUoKTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgICBgfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm93fT5cbiAgICAgICAgPEZvcm1GaWVsZFxuICAgICAgICAgIGxhYmVsPXtzaG93SW50ZXJuYWxMaW5rID8gJ1F1ZXJ5JyA6ICdVUkwnfVxuICAgICAgICAgIGlucHV0RWw9e1xuICAgICAgICAgICAgPERhdGFMaW5rSW5wdXRcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3Nob3dJbnRlcm5hbExpbmsgPyAnJHtfX3ZhbHVlLnJhd30nIDogJ2h0dHA6Ly9leGFtcGxlLmNvbS8ke19fdmFsdWUucmF3fSd9XG4gICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZS51cmwgfHwgJyd9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsobmV3VmFsdWUpID0+XG4gICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICB1cmw6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbnM9e3N1Z2dlc3Rpb25zfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudXJsRmllbGR9XG4gICAgICAgIC8+XG4gICAgICAgIDxGb3JtRmllbGRcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy51cmxEaXNwbGF5TGFiZWxGaWVsZH1cbiAgICAgICAgICBpbnB1dFdpZHRoPXtudWxsfVxuICAgICAgICAgIGxhYmVsPVwiVVJMIExhYmVsXCJcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgdmFsdWU9e3ZhbHVlLnVybERpc3BsYXlMYWJlbH1cbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlKCd1cmxEaXNwbGF5TGFiZWwnKX1cbiAgICAgICAgICB0b29sdGlwPXsnVXNlIHRvIG92ZXJyaWRlIHRoZSBidXR0b24gbGFiZWwgd2hlbiB0aGlzIGRlcml2ZWQgZmllbGQgaXMgZm91bmQgaW4gYSBsb2cuJ31cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnJvd30+XG4gICAgICAgIDxTd2l0Y2hcbiAgICAgICAgICBsYWJlbD1cIkludGVybmFsIGxpbmtcIlxuICAgICAgICAgIGNoZWNrZWQ9e3Nob3dJbnRlcm5hbExpbmt9XG4gICAgICAgICAgb25DaGFuZ2U9eygpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG93SW50ZXJuYWxMaW5rKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhc291cmNlVWlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0U2hvd0ludGVybmFsTGluayghc2hvd0ludGVybmFsTGluayk7XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICB7c2hvd0ludGVybmFsTGluayAmJiAoXG4gICAgICAgICAgPERhdGFTb3VyY2VQaWNrZXJcbiAgICAgICAgICAgIHRyYWNpbmc9e3RydWV9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGRzKSA9PlxuICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YXNvdXJjZVVpZDogZHMudWlkLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudD17dmFsdWUuZGF0YXNvdXJjZVVpZH1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEJ1dHRvbiwgdXNlVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgVmFyaWFibGVPcmlnaW4sIERhdGFMaW5rQnVpbHRJblZhcnMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IERlcml2ZWRGaWVsZENvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IERlcml2ZWRGaWVsZCB9IGZyb20gJy4vRGVyaXZlZEZpZWxkJztcbmltcG9ydCB7IERlYnVnU2VjdGlvbiB9IGZyb20gJy4vRGVidWdTZWN0aW9uJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICBpbmZvVGV4dDogY3NzYFxuICAgIHBhZGRpbmctYm90dG9tOiAke3RoZW1lLnNwYWNpbmcoMil9O1xuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG4gIGAsXG4gIGRlcml2ZWRGaWVsZDogY3NzYFxuICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZygxKX07XG4gIGAsXG59KTtcblxudHlwZSBQcm9wcyA9IHtcbiAgdmFsdWU/OiBEZXJpdmVkRmllbGRDb25maWdbXTtcbiAgb25DaGFuZ2U6ICh2YWx1ZTogRGVyaXZlZEZpZWxkQ29uZmlnW10pID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgY29uc3QgRGVyaXZlZEZpZWxkcyA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyB2YWx1ZSwgb25DaGFuZ2UgfSA9IHByb3BzO1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lMigpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhlbWUpO1xuXG4gIGNvbnN0IFtzaG93RGVidWcsIHNldFNob3dEZWJ1Z10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGgzIGNsYXNzTmFtZT1cInBhZ2UtaGVhZGluZ1wiPkRlcml2ZWQgZmllbGRzPC9oMz5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pbmZvVGV4dH0+XG4gICAgICAgIERlcml2ZWQgZmllbGRzIGNhbiBiZSB1c2VkIHRvIGV4dHJhY3QgbmV3IGZpZWxkcyBmcm9tIGEgbG9nIG1lc3NhZ2UgYW5kIGNyZWF0ZSBhIGxpbmsgZnJvbSBpdHMgdmFsdWUuXG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWdyb3VwXCI+XG4gICAgICAgIHt2YWx1ZSAmJlxuICAgICAgICAgIHZhbHVlLm1hcCgoZmllbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8RGVyaXZlZEZpZWxkXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuZGVyaXZlZEZpZWxkfVxuICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsobmV3RmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlcml2ZWRGaWVsZHMgPSBbLi4udmFsdWVdO1xuICAgICAgICAgICAgICAgICAgbmV3RGVyaXZlZEZpZWxkcy5zcGxpY2UoaW5kZXgsIDEsIG5ld0ZpZWxkKTtcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld0Rlcml2ZWRGaWVsZHMpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb25EZWxldGU9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlcml2ZWRGaWVsZHMgPSBbLi4udmFsdWVdO1xuICAgICAgICAgICAgICAgICAgbmV3RGVyaXZlZEZpZWxkcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3RGVyaXZlZEZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBzdWdnZXN0aW9ucz17W1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogRGF0YUxpbmtCdWlsdEluVmFycy52YWx1ZVJhdyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdSYXcgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnRXhhY3Qgc3RyaW5nIGNhcHR1cmVkIGJ5IHRoZSByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFZhcmlhYmxlT3JpZ2luLlZhbHVlLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KX1cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XG4gICAgICAgICAgICBgfVxuICAgICAgICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgICAgICAgb25DbGljaz17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0Rlcml2ZWRGaWVsZHMgPSBbLi4uKHZhbHVlIHx8IFtdKSwgeyBuYW1lOiAnJywgbWF0Y2hlclJlZ2V4OiAnJyB9XTtcbiAgICAgICAgICAgICAgb25DaGFuZ2UobmV3RGVyaXZlZEZpZWxkcyk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIEFkZFxuICAgICAgICAgIDwvQnV0dG9uPlxuXG4gICAgICAgICAge3ZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgPEJ1dHRvbiB2YXJpYW50PVwic2Vjb25kYXJ5XCIgdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IHNldFNob3dEZWJ1Zyghc2hvd0RlYnVnKX0+XG4gICAgICAgICAgICAgIHtzaG93RGVidWcgPyAnSGlkZSBleGFtcGxlIGxvZyBtZXNzYWdlJyA6ICdTaG93IGV4YW1wbGUgbG9nIG1lc3NhZ2UnfVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAge3Nob3dEZWJ1ZyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAgICAgIDxEZWJ1Z1NlY3Rpb25cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICAgICAgICAgICAgYH1cbiAgICAgICAgICAgIGRlcml2ZWRGaWVsZHM9e3ZhbHVlfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8Lz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTGVnYWN5Rm9ybXMgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5jb25zdCB7IEZvcm1GaWVsZCB9ID0gTGVnYWN5Rm9ybXM7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIG9uQ2hhbmdlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBjb25zdCBNYXhMaW5lc0ZpZWxkID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICBjb25zdCB7IHZhbHVlLCBvbkNoYW5nZSB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPEZvcm1GaWVsZFxuICAgICAgbGFiZWw9XCJNYXhpbXVtIGxpbmVzXCJcbiAgICAgIGxhYmVsV2lkdGg9ezExfVxuICAgICAgaW5wdXRXaWR0aD17MjB9XG4gICAgICBpbnB1dEVsPXtcbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbnB1dCB3aWR0aC04IGdmLWZvcm0taW5wdXQtLWhhcy1oZWxwLWljb25cIlxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiBvbkNoYW5nZShldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBzcGVsbENoZWNrPXtmYWxzZX1cbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIjEwMDBcIlxuICAgICAgICAvPlxuICAgICAgfVxuICAgICAgdG9vbHRpcD17XG4gICAgICAgIDw+XG4gICAgICAgICAgTG9raSBxdWVyaWVzIG11c3QgY29udGFpbiBhIGxpbWl0IG9mIHRoZSBtYXhpbXVtIG51bWJlciBvZiBsaW5lcyByZXR1cm5lZCAoZGVmYXVsdDogMTAwMCkuIEluY3JlYXNlIHRoaXMgbGltaXRcbiAgICAgICAgICB0byBoYXZlIGEgYmlnZ2VyIHJlc3VsdCBzZXQgZm9yIGFkLWhvYyBhbmFseXNpcy4gRGVjcmVhc2UgdGhpcyBsaW1pdCBpZiB5b3VyIGJyb3dzZXIgYmVjb21lcyBzbHVnZ2lzaCB3aGVuXG4gICAgICAgICAgZGlzcGxheWluZyB0aGUgbG9nIHJlc3VsdHMuXG4gICAgICAgIDwvPlxuICAgICAgfVxuICAgIC8+XG4gICk7XG59O1xuIiwiLy8gTGlicmFyaWVzXG5pbXBvcnQgeyBjbG9uZURlZXAsIGlzRW1wdHksIG1hcCBhcyBsb2Rhc2hNYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgbGFzdFZhbHVlRnJvbSwgbWVyZ2UsIE9ic2VydmFibGUsIG9mLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCBQcmlzbSBmcm9tICdwcmlzbWpzJztcblxuLy8gVHlwZXNcbmltcG9ydCB7XG4gIEFubm90YXRpb25FdmVudCxcbiAgQW5ub3RhdGlvblF1ZXJ5UmVxdWVzdCxcbiAgQ29yZUFwcCxcbiAgRGF0YUZyYW1lLFxuICBEYXRhRnJhbWVWaWV3LFxuICBEYXRhUXVlcnlFcnJvcixcbiAgRGF0YVF1ZXJ5UmVxdWVzdCxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIERhdGFTb3VyY2VJbnN0YW5jZVNldHRpbmdzLFxuICBEYXRhU291cmNlV2l0aExvZ3NDb250ZXh0U3VwcG9ydCxcbiAgRGF0YVNvdXJjZVdpdGhMb2dzVm9sdW1lU3VwcG9ydCxcbiAgRGF0YVNvdXJjZVdpdGhRdWVyeUV4cG9ydFN1cHBvcnQsXG4gIERhdGFTb3VyY2VXaXRoUXVlcnlJbXBvcnRTdXBwb3J0LFxuICBkYXRlTWF0aCxcbiAgRGF0ZVRpbWUsXG4gIEZpZWxkQ2FjaGUsXG4gIEFic3RyYWN0UXVlcnksXG4gIEZpZWxkVHlwZSxcbiAgZ2V0TG9nTGV2ZWxGcm9tS2V5LFxuICBMYWJlbHMsXG4gIExvYWRpbmdTdGF0ZSxcbiAgTG9nTGV2ZWwsXG4gIExvZ1Jvd01vZGVsLFxuICBRdWVyeVJlc3VsdE1ldGEsXG4gIFNjb3BlZFZhcnMsXG4gIFRpbWVSYW5nZSxcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBCYWNrZW5kU3J2UmVxdWVzdCwgRmV0Y2hFcnJvciwgZ2V0QmFja2VuZFNydiwgY29uZmlnLCBEYXRhU291cmNlV2l0aEJhY2tlbmQgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IGdldFRlbXBsYXRlU3J2LCBUZW1wbGF0ZVNydiB9IGZyb20gJ2FwcC9mZWF0dXJlcy90ZW1wbGF0aW5nL3RlbXBsYXRlX3Nydic7XG5pbXBvcnQgeyBhZGRMYWJlbFRvUXVlcnkgfSBmcm9tICcuL2FkZF9sYWJlbF90b19xdWVyeSc7XG5pbXBvcnQgeyBnZXRUaW1lU3J2LCBUaW1lU3J2IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9zZXJ2aWNlcy9UaW1lU3J2JztcbmltcG9ydCB7IGNvbnZlcnRUb1dlYlNvY2tldFVybCB9IGZyb20gJ2FwcC9jb3JlL3V0aWxzL2V4cGxvcmUnO1xuaW1wb3J0IHtcbiAgbG9raVJlc3VsdHNUb1RhYmxlTW9kZWwsXG4gIGxva2lTdHJlYW1SZXN1bHRUb0RhdGFGcmFtZSxcbiAgbG9raVN0cmVhbXNUb0RhdGFGcmFtZXMsXG4gIHByb2Nlc3NSYW5nZVF1ZXJ5UmVzcG9uc2UsXG59IGZyb20gJy4vcmVzdWx0X3RyYW5zZm9ybWVyJztcbmltcG9ydCB7IHRyYW5zZm9ybUJhY2tlbmRSZXN1bHQgfSBmcm9tICcuL2JhY2tlbmRSZXN1bHRUcmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBhZGRQYXJzZWRMYWJlbFRvUXVlcnksIGdldE5vcm1hbGl6ZWRMb2tpUXVlcnksIHF1ZXJ5SGFzUGlwZVBhcnNlciB9IGZyb20gJy4vcXVlcnlfdXRpbHMnO1xuXG5pbXBvcnQge1xuICBMb2tpT3B0aW9ucyxcbiAgTG9raVF1ZXJ5LFxuICBMb2tpUXVlcnlUeXBlLFxuICBMb2tpUmFuZ2VRdWVyeVJlcXVlc3QsXG4gIExva2lSZXN1bHRUeXBlLFxuICBMb2tpU3RyZWFtUmVzcG9uc2UsXG4gIExva2lTdHJlYW1SZXN1bHQsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgTGl2ZVN0cmVhbXMsIExva2lMaXZlVGFyZ2V0IH0gZnJvbSAnLi9saXZlX3N0cmVhbXMnO1xuaW1wb3J0IExhbmd1YWdlUHJvdmlkZXIgZnJvbSAnLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBzZXJpYWxpemVQYXJhbXMgfSBmcm9tICcuLi8uLi8uLi9jb3JlL3V0aWxzL2ZldGNoJztcbmltcG9ydCB7IFJvd0NvbnRleHRPcHRpb25zIH0gZnJvbSAnQGdyYWZhbmEvdWkvc3JjL2NvbXBvbmVudHMvTG9ncy9Mb2dSb3dDb250ZXh0UHJvdmlkZXInO1xuaW1wb3J0IHN5bnRheCBmcm9tICcuL3N5bnRheCc7XG5pbXBvcnQgeyBERUZBVUxUX1JFU09MVVRJT04gfSBmcm9tICcuL2NvbXBvbmVudHMvTG9raU9wdGlvbkZpZWxkcyc7XG5pbXBvcnQgeyBxdWVyeUxvZ3NWb2x1bWUgfSBmcm9tICdhcHAvY29yZS9sb2dzX21vZGVsJztcbmltcG9ydCB7IGRvTG9raUNoYW5uZWxTdHJlYW0gfSBmcm9tICcuL3N0cmVhbWluZyc7XG5pbXBvcnQgeyByZW5kZXJMZWdlbmRGb3JtYXQgfSBmcm9tICcuLi9wcm9tZXRoZXVzL2xlZ2VuZCc7XG5cbmV4cG9ydCB0eXBlIFJhbmdlUXVlcnlPcHRpb25zID0gRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+IHwgQW5ub3RhdGlvblF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX0xJTkVTID0gMTAwMDtcbmV4cG9ydCBjb25zdCBMT0tJX0VORFBPSU5UID0gJy9sb2tpL2FwaS92MSc7XG5jb25zdCBOU19JTl9NUyA9IDEwMDAwMDA7XG5cbmNvbnN0IFJBTkdFX1FVRVJZX0VORFBPSU5UID0gYCR7TE9LSV9FTkRQT0lOVH0vcXVlcnlfcmFuZ2VgO1xuY29uc3QgSU5TVEFOVF9RVUVSWV9FTkRQT0lOVCA9IGAke0xPS0lfRU5EUE9JTlR9L3F1ZXJ5YDtcblxuY29uc3QgREVGQVVMVF9RVUVSWV9QQVJBTVM6IFBhcnRpYWw8TG9raVJhbmdlUXVlcnlSZXF1ZXN0PiA9IHtcbiAgZGlyZWN0aW9uOiAnQkFDS1dBUkQnLFxuICBsaW1pdDogREVGQVVMVF9NQVhfTElORVMsXG4gIHF1ZXJ5OiAnJyxcbn07XG5cbmV4cG9ydCBjbGFzcyBMb2tpRGF0YXNvdXJjZVxuICBleHRlbmRzIERhdGFTb3VyY2VXaXRoQmFja2VuZDxMb2tpUXVlcnksIExva2lPcHRpb25zPlxuICBpbXBsZW1lbnRzXG4gICAgRGF0YVNvdXJjZVdpdGhMb2dzQ29udGV4dFN1cHBvcnQsXG4gICAgRGF0YVNvdXJjZVdpdGhMb2dzVm9sdW1lU3VwcG9ydDxMb2tpUXVlcnk+LFxuICAgIERhdGFTb3VyY2VXaXRoUXVlcnlJbXBvcnRTdXBwb3J0PExva2lRdWVyeT4sXG4gICAgRGF0YVNvdXJjZVdpdGhRdWVyeUV4cG9ydFN1cHBvcnQ8TG9raVF1ZXJ5Plxue1xuICBwcml2YXRlIHN0cmVhbXMgPSBuZXcgTGl2ZVN0cmVhbXMoKTtcbiAgbGFuZ3VhZ2VQcm92aWRlcjogTGFuZ3VhZ2VQcm92aWRlcjtcbiAgbWF4TGluZXM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGluc3RhbmNlU2V0dGluZ3M6IERhdGFTb3VyY2VJbnN0YW5jZVNldHRpbmdzPExva2lPcHRpb25zPixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRlbXBsYXRlU3J2OiBUZW1wbGF0ZVNydiA9IGdldFRlbXBsYXRlU3J2KCksXG4gICAgcHJpdmF0ZSByZWFkb25seSB0aW1lU3J2OiBUaW1lU3J2ID0gZ2V0VGltZVNydigpXG4gICkge1xuICAgIHN1cGVyKGluc3RhbmNlU2V0dGluZ3MpO1xuXG4gICAgdGhpcy5sYW5ndWFnZVByb3ZpZGVyID0gbmV3IExhbmd1YWdlUHJvdmlkZXIodGhpcyk7XG4gICAgY29uc3Qgc2V0dGluZ3NEYXRhID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YSB8fCB7fTtcbiAgICB0aGlzLm1heExpbmVzID0gcGFyc2VJbnQoc2V0dGluZ3NEYXRhLm1heExpbmVzID8/ICcwJywgMTApIHx8IERFRkFVTFRfTUFYX0xJTkVTO1xuICB9XG5cbiAgX3JlcXVlc3QoYXBpVXJsOiBzdHJpbmcsIGRhdGE/OiBhbnksIG9wdGlvbnM/OiBQYXJ0aWFsPEJhY2tlbmRTcnZSZXF1ZXN0Pik6IE9ic2VydmFibGU8UmVjb3JkPHN0cmluZywgYW55Pj4ge1xuICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmluc3RhbmNlU2V0dGluZ3MudXJsO1xuICAgIGNvbnN0IHBhcmFtcyA9IGRhdGEgPyBzZXJpYWxpemVQYXJhbXMoZGF0YSkgOiAnJztcbiAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfSR7YXBpVXJsfSR7cGFyYW1zLmxlbmd0aCA/IGA/JHtwYXJhbXN9YCA6ICcnfWA7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2VTZXR0aW5ncy53aXRoQ3JlZGVudGlhbHMgfHwgdGhpcy5pbnN0YW5jZVNldHRpbmdzLmJhc2ljQXV0aCkge1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgd2l0aENyZWRlbnRpYWxzOiB0cnVlIH07XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZVNldHRpbmdzLmJhc2ljQXV0aCkge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7IC4uLm9wdGlvbnMuaGVhZGVycywgQXV0aG9yaXphdGlvbjogdGhpcy5pbnN0YW5jZVNldHRpbmdzLmJhc2ljQXV0aCB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXEgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdXJsLFxuICAgIH07XG5cbiAgICByZXR1cm4gZ2V0QmFja2VuZFNydigpLmZldGNoPFJlY29yZDxzdHJpbmcsIGFueT4+KHJlcSk7XG4gIH1cblxuICBnZXRMb2dzVm9sdW1lRGF0YVByb3ZpZGVyKHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8TG9raVF1ZXJ5Pik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpc0xvZ3NWb2x1bWVBdmFpbGFibGUgPSByZXF1ZXN0LnRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQuZXhwciAmJiAhaXNNZXRyaWNzUXVlcnkodGFyZ2V0LmV4cHIpKTtcbiAgICBpZiAoIWlzTG9nc1ZvbHVtZUF2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dzVm9sdW1lUmVxdWVzdCA9IGNsb25lRGVlcChyZXF1ZXN0KTtcbiAgICBsb2dzVm9sdW1lUmVxdWVzdC50YXJnZXRzID0gbG9nc1ZvbHVtZVJlcXVlc3QudGFyZ2V0c1xuICAgICAgLmZpbHRlcigodGFyZ2V0KSA9PiB0YXJnZXQuZXhwciAmJiAhaXNNZXRyaWNzUXVlcnkodGFyZ2V0LmV4cHIpKVxuICAgICAgLm1hcCgodGFyZ2V0KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgIGluc3RhbnQ6IGZhbHNlLFxuICAgICAgICAgIHZvbHVtZVF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIGV4cHI6IGBzdW0gYnkgKGxldmVsKSAoY291bnRfb3Zlcl90aW1lKCR7dGFyZ2V0LmV4cHJ9WyRfX2ludGVydmFsXSkpYCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHF1ZXJ5TG9nc1ZvbHVtZSh0aGlzLCBsb2dzVm9sdW1lUmVxdWVzdCwge1xuICAgICAgZXh0cmFjdExldmVsLFxuICAgICAgcmFuZ2U6IHJlcXVlc3QucmFuZ2UsXG4gICAgICB0YXJnZXRzOiByZXF1ZXN0LnRhcmdldHMsXG4gICAgfSk7XG4gIH1cblxuICBxdWVyeShyZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4pOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiB7XG4gICAgY29uc3Qgc3ViUXVlcmllczogQXJyYXk8T2JzZXJ2YWJsZTxEYXRhUXVlcnlSZXNwb25zZT4+ID0gW107XG4gICAgY29uc3Qgc2NvcGVkVmFycyA9IHtcbiAgICAgIC4uLnJlcXVlc3Quc2NvcGVkVmFycyxcbiAgICAgIC4uLnRoaXMuZ2V0UmFuZ2VTY29wZWRWYXJzKHJlcXVlc3QucmFuZ2UpLFxuICAgIH07XG5cbiAgICBjb25zdCBzaG91bGRSdW5CYWNrZW5kUXVlcnkgPSBjb25maWcuZmVhdHVyZVRvZ2dsZXMubG9raUJhY2tlbmRNb2RlICYmIHJlcXVlc3QuYXBwID09PSBDb3JlQXBwLkV4cGxvcmU7XG5cbiAgICBpZiAoc2hvdWxkUnVuQmFja2VuZFF1ZXJ5KSB7XG4gICAgICAvLyB3ZSBcImZpeFwiIHRoZSBsb2tpIHF1ZXJpZXMgdG8gaGF2ZSBgLnF1ZXJ5VHlwZWAgYW5kIG5vdCBoYXZlIGAuaW5zdGFudGAgYW5kIGAucmFuZ2VgXG4gICAgICBjb25zdCBmaXhlZFJlcXVlc3QgPSB7XG4gICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgIHRhcmdldHM6IHJlcXVlc3QudGFyZ2V0cy5tYXAoZ2V0Tm9ybWFsaXplZExva2lRdWVyeSksXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHN1cGVyLnF1ZXJ5KGZpeGVkUmVxdWVzdCkucGlwZShtYXAoKHJlc3BvbnNlKSA9PiB0cmFuc2Zvcm1CYWNrZW5kUmVzdWx0KHJlc3BvbnNlLCBmaXhlZFJlcXVlc3QpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWRUYXJnZXRzID0gcmVxdWVzdC50YXJnZXRzXG4gICAgICAuZmlsdGVyKCh0YXJnZXQpID0+IHRhcmdldC5leHByICYmICF0YXJnZXQuaGlkZSlcbiAgICAgIC5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICBjb25zdCBleHByID0gdGhpcy5hZGRBZEhvY0ZpbHRlcnModGFyZ2V0LmV4cHIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICBleHByOiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UoZXhwciwgc2NvcGVkVmFycywgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwciksXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIGZpbHRlcmVkVGFyZ2V0cykge1xuICAgICAgaWYgKHRhcmdldC5pbnN0YW50IHx8IHRhcmdldC5xdWVyeVR5cGUgPT09IExva2lRdWVyeVR5cGUuSW5zdGFudCkge1xuICAgICAgICBzdWJRdWVyaWVzLnB1c2godGhpcy5ydW5JbnN0YW50UXVlcnkodGFyZ2V0LCByZXF1ZXN0LCBmaWx0ZXJlZFRhcmdldHMubGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBjb25maWcuZmVhdHVyZVRvZ2dsZXMubG9raUxpdmUgJiZcbiAgICAgICAgdGFyZ2V0LnF1ZXJ5VHlwZSA9PT0gTG9raVF1ZXJ5VHlwZS5TdHJlYW0gJiZcbiAgICAgICAgcmVxdWVzdC5yYW5nZVJhdz8udG8gPT09ICdub3cnXG4gICAgICApIHtcbiAgICAgICAgc3ViUXVlcmllcy5wdXNoKGRvTG9raUNoYW5uZWxTdHJlYW0odGFyZ2V0LCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJRdWVyaWVzLnB1c2godGhpcy5ydW5SYW5nZVF1ZXJ5KHRhcmdldCwgcmVxdWVzdCwgZmlsdGVyZWRUYXJnZXRzLmxlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHZhbGlkIHRhcmdldHMsIHJldHVybiB0aGUgZW1wdHkgcmVzdWx0IHRvIHNhdmUgYSByb3VuZCB0cmlwLlxuICAgIGlmIChpc0VtcHR5KHN1YlF1ZXJpZXMpKSB7XG4gICAgICByZXR1cm4gb2Yoe1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgc3RhdGU6IExvYWRpbmdTdGF0ZS5Eb25lLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlKC4uLnN1YlF1ZXJpZXMpO1xuICB9XG5cbiAgcnVuSW5zdGFudFF1ZXJ5ID0gKFxuICAgIHRhcmdldDogTG9raVF1ZXJ5LFxuICAgIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8TG9raVF1ZXJ5PixcbiAgICByZXNwb25zZUxpc3RMZW5ndGggPSAxXG4gICk6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCB0aW1lTnMgPSB0aGlzLmdldFRpbWUob3B0aW9ucy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgcXVlcnlMaW1pdCA9IGlzTWV0cmljc1F1ZXJ5KHRhcmdldC5leHByKSA/IG9wdGlvbnMubWF4RGF0YVBvaW50cyA6IHRhcmdldC5tYXhMaW5lcztcbiAgICBjb25zdCBxdWVyeSA9IHtcbiAgICAgIHF1ZXJ5OiB0YXJnZXQuZXhwcixcbiAgICAgIHRpbWU6IGAke3RpbWVOcyArICgxZTkgLSAodGltZU5zICUgMWU5KSl9YCxcbiAgICAgIGxpbWl0OiBNYXRoLm1pbihxdWVyeUxpbWl0IHx8IEluZmluaXR5LCB0aGlzLm1heExpbmVzKSxcbiAgICB9O1xuXG4gICAgLyoqIFVzZWQgb25seSBmb3IgcmVzdWx0cyBvZiBtZXRyaWNzIGluc3RhbnQgcXVlcmllcyAqL1xuICAgIGNvbnN0IG1ldGE6IFF1ZXJ5UmVzdWx0TWV0YSA9IHtcbiAgICAgIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAndGFibGUnLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChJTlNUQU5UX1FVRVJZX0VORFBPSU5ULCBxdWVyeSkucGlwZShcbiAgICAgIG1hcCgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuZGF0YS5yZXN1bHRUeXBlID09PSBMb2tpUmVzdWx0VHlwZS5TdHJlYW0pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogcmVzcG9uc2UuZGF0YVxuICAgICAgICAgICAgICA/IGxva2lTdHJlYW1zVG9EYXRhRnJhbWVzKFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSBhcyBMb2tpU3RyZWFtUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICBxdWVyeS5saW1pdCxcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIGtleTogYCR7dGFyZ2V0LnJlZklkfV9pbnN0YW50YCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBbbG9raVJlc3VsdHNUb1RhYmxlTW9kZWwocmVzcG9uc2UuZGF0YS5kYXRhLnJlc3VsdCwgcmVzcG9uc2VMaXN0TGVuZ3RoLCB0YXJnZXQucmVmSWQsIG1ldGEsIHRydWUpXSxcbiAgICAgICAgICBrZXk6IGAke3RhcmdldC5yZWZJZH1faW5zdGFudGAsXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhyb3dFcnJvcigoKSA9PiB0aGlzLnByb2Nlc3NFcnJvcihlcnIsIHRhcmdldCkpKVxuICAgICk7XG4gIH07XG5cbiAgY3JlYXRlUmFuZ2VRdWVyeSh0YXJnZXQ6IExva2lRdWVyeSwgb3B0aW9uczogUmFuZ2VRdWVyeU9wdGlvbnMsIGxpbWl0OiBudW1iZXIpOiBMb2tpUmFuZ2VRdWVyeVJlcXVlc3Qge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGFyZ2V0LmV4cHI7XG4gICAgbGV0IHJhbmdlOiB7IHN0YXJ0PzogbnVtYmVyOyBlbmQ/OiBudW1iZXI7IHN0ZXA/OiBudW1iZXIgfSA9IHt9O1xuICAgIGlmIChvcHRpb25zLnJhbmdlKSB7XG4gICAgICBjb25zdCBzdGFydE5zID0gdGhpcy5nZXRUaW1lKG9wdGlvbnMucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgICAgY29uc3QgZW5kTnMgPSB0aGlzLmdldFRpbWUob3B0aW9ucy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgICBjb25zdCByYW5nZU1zID0gTWF0aC5jZWlsKChlbmROcyAtIHN0YXJ0TnMpIC8gMWU2KTtcblxuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRhcmdldC5yZXNvbHV0aW9uIHx8IChERUZBVUxUX1JFU09MVVRJT04udmFsdWUgYXMgbnVtYmVyKTtcblxuICAgICAgY29uc3QgYWRqdXN0ZWRJbnRlcnZhbCA9XG4gICAgICAgIHRoaXMuYWRqdXN0SW50ZXJ2YWwoKG9wdGlvbnMgYXMgRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+KS5pbnRlcnZhbE1zIHx8IDEwMDAsIHJlc29sdXRpb24sIHJhbmdlTXMpIC8gMTAwMDtcbiAgICAgIC8vIFdlIHdhbnQgdG8gY2VpbCB0byAzIGRlY2ltYWwgcGxhY2VzXG4gICAgICBjb25zdCBzdGVwID0gTWF0aC5jZWlsKGFkanVzdGVkSW50ZXJ2YWwgKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgIHJhbmdlID0ge1xuICAgICAgICBzdGFydDogc3RhcnROcyxcbiAgICAgICAgZW5kOiBlbmROcyxcbiAgICAgICAgc3RlcCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkRFRkFVTFRfUVVFUllfUEFSQU1TLFxuICAgICAgLi4ucmFuZ2UsXG4gICAgICBxdWVyeSxcbiAgICAgIGxpbWl0LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gc2VuZCBhIHF1ZXJ5IHRvIC9sb2tpL2FwaS92MS9xdWVyeV9yYW5nZVxuICAgKi9cbiAgcnVuUmFuZ2VRdWVyeSA9IChcbiAgICB0YXJnZXQ6IExva2lRdWVyeSxcbiAgICBvcHRpb25zOiBSYW5nZVF1ZXJ5T3B0aW9ucyxcbiAgICByZXNwb25zZUxpc3RMZW5ndGggPSAxXG4gICk6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+ID0+IHtcbiAgICAvLyBGb3IgbWV0cmljIHF1ZXJ5IHdlIHVzZSBtYXhEYXRhUG9pbnRzIGZyb20gdGhlIHJlcXVlc3Qgb3B0aW9ucyB3aGljaCBzaG91bGQgYmUgc29tZXRoaW5nIGxpa2Ugd2lkdGggb2YgdGhlXG4gICAgLy8gdmlzdWFsaXNhdGlvbiBpbiBwaXhlbHMuIEluIGNhc2Ugb2YgbG9ncyByZXF1ZXN0IHdlIGVpdGhlciB1c2UgbGluZXMgbGltaXQgZGVmaW5lZCBpbiB0aGUgcXVlcnkgdGFyZ2V0IG9yXG4gICAgLy8gZ2xvYmFsIGxpbWl0IGRlZmluZWQgZm9yIHRoZSBkYXRhIHNvdXJjZSB3aGljaCBldmVyIGlzIGxvd2VyLlxuICAgIGxldCBtYXhEYXRhUG9pbnRzID0gaXNNZXRyaWNzUXVlcnkodGFyZ2V0LmV4cHIpXG4gICAgICA/IC8vIFdlIGZhbGxiYWNrIHRvIG1heExpbmVzIGhlcmUgYmVjYXVzZSBtYXhEYXRhUG9pbnRzIGlzIGRlZmluZWQgYXMgcG9zc2libHkgdW5kZWZpbmVkLiBOb3Qgc3VyZSB0aGF0IGNhblxuICAgICAgICAvLyBhY3R1YWxseSBoYXBwZW4gYm90aCBEYXNoYm9hcmRzIGFuZCBFeHBsb3JlIHNob3VsZCBzZW5kIHNvbWUgdmFsdWUgaGVyZS4gSWYgbm90IG1heExpbmVzIGRvZXMgbm90IG1ha2UgdGhhdFxuICAgICAgICAvLyBtdWNoIHNlbnNlIGJ1dCBub3IgYW55IG90aGVyIGFyYml0cmFyeSB2YWx1ZS5cbiAgICAgICAgKG9wdGlvbnMgYXMgRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+KS5tYXhEYXRhUG9pbnRzIHx8IHRoaXMubWF4TGluZXNcbiAgICAgIDogLy8gSWYgdXNlciB3YW50cyBtYXhMaW5lcyAwIHdlIHN0aWxsIGZhbGxiYWNrIHRvIGRhdGEgc291cmNlIGxpbWl0LiBJIHRoaW5rIHRoYXQgbWFrZXMgc2Vuc2UgYXMgd2h5IHdvdWxkIGFueW9uZVxuICAgICAgICAvLyB3YW50IHRvIGRvIGEgcXVlcnkgYW5kIG5vdCBzZWUgYW55IHJlc3VsdHM/XG4gICAgICAgIHRhcmdldC5tYXhMaW5lcyB8fCB0aGlzLm1heExpbmVzO1xuXG4gICAgaWYgKChvcHRpb25zIGFzIERhdGFRdWVyeVJlcXVlc3Q8TG9raVF1ZXJ5PikubGl2ZVN0cmVhbWluZykge1xuICAgICAgcmV0dXJuIHRoaXMucnVuTGl2ZVF1ZXJ5KHRhcmdldCwgbWF4RGF0YVBvaW50cyk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5jcmVhdGVSYW5nZVF1ZXJ5KHRhcmdldCwgb3B0aW9ucywgbWF4RGF0YVBvaW50cyk7XG5cbiAgICBjb25zdCBoZWFkZXJzID0gdGFyZ2V0LnZvbHVtZVF1ZXJ5ID8geyAnWC1RdWVyeS1UYWdzJzogJ1NvdXJjZT1sb2d2b2xoaXN0JyB9IDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoUkFOR0VfUVVFUllfRU5EUE9JTlQsIHF1ZXJ5LCB7IGhlYWRlcnMgfSkucGlwZShcbiAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhyb3dFcnJvcigoKSA9PiB0aGlzLnByb2Nlc3NFcnJvcihlcnIsIHRhcmdldCkpKSxcbiAgICAgIHN3aXRjaE1hcCgocmVzcG9uc2UpID0+XG4gICAgICAgIHByb2Nlc3NSYW5nZVF1ZXJ5UmVzcG9uc2UoXG4gICAgICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgcmVzcG9uc2VMaXN0TGVuZ3RoLFxuICAgICAgICAgIG1heERhdGFQb2ludHMsXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLFxuICAgICAgICAgIChvcHRpb25zIGFzIERhdGFRdWVyeVJlcXVlc3Q8TG9raVF1ZXJ5Pikuc2NvcGVkVmFycyxcbiAgICAgICAgICAob3B0aW9ucyBhcyBEYXRhUXVlcnlSZXF1ZXN0PExva2lRdWVyeT4pLnJldmVyc2VcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgY3JlYXRlTGl2ZVRhcmdldCh0YXJnZXQ6IExva2lRdWVyeSwgbWF4RGF0YVBvaW50czogbnVtYmVyKTogTG9raUxpdmVUYXJnZXQge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGFyZ2V0LmV4cHI7XG4gICAgY29uc3QgYmFzZVVybCA9IHRoaXMuaW5zdGFuY2VTZXR0aW5ncy51cmw7XG4gICAgY29uc3QgcGFyYW1zID0gc2VyaWFsaXplUGFyYW1zKHsgcXVlcnkgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcnksXG4gICAgICB1cmw6IGNvbnZlcnRUb1dlYlNvY2tldFVybChgJHtiYXNlVXJsfS9sb2tpL2FwaS92MS90YWlsPyR7cGFyYW1zfWApLFxuICAgICAgcmVmSWQ6IHRhcmdldC5yZWZJZCxcbiAgICAgIHNpemU6IG1heERhdGFQb2ludHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGxpdmUgcXVlcmllcyB3aGljaCBpbiB0aGlzIGNhc2UgbWVhbnMgY3JlYXRpbmcgYSB3ZWJzb2NrZXQgYW5kIGxpc3RlbmluZyBvbiBpdCBmb3IgbmV3IGxvZ3MuXG4gICAqIFRoaXMgcmV0dXJucyBhIGJpdCBkaWZmZXJlbnQgZGF0YUZyYW1lIHRoYW4gcnVuUXVlcmllcyBhcyBpdCByZXR1cm5zIHNpbmdsZSBkYXRhZnJhbWUgZXZlbiBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcbiAgICogTG9raSBzdHJlYW1zLCBzZXRzIG9ubHkgY29tbW9uIGxhYmVscyBvbiBkYXRhZnJhbWUubGFiZWxzIGFuZCBoYXMgYWRkaXRpb25hbCBkYXRhZnJhbWUuZmllbGRzLmxhYmVscyBmb3IgdW5pcXVlXG4gICAqIGxhYmVscyBwZXIgcm93LlxuICAgKi9cbiAgcnVuTGl2ZVF1ZXJ5ID0gKHRhcmdldDogTG9raVF1ZXJ5LCBtYXhEYXRhUG9pbnRzOiBudW1iZXIpOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiA9PiB7XG4gICAgY29uc3QgbGl2ZVRhcmdldCA9IHRoaXMuY3JlYXRlTGl2ZVRhcmdldCh0YXJnZXQsIG1heERhdGFQb2ludHMpO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtcy5nZXRTdHJlYW0obGl2ZVRhcmdldCkucGlwZShcbiAgICAgIG1hcCgoZGF0YSkgPT4gKHtcbiAgICAgICAgZGF0YTogZGF0YSB8fCBbXSxcbiAgICAgICAga2V5OiBgbG9raS0ke2xpdmVUYXJnZXQucmVmSWR9YCxcbiAgICAgICAgc3RhdGU6IExvYWRpbmdTdGF0ZS5TdHJlYW1pbmcsXG4gICAgICB9KSksXG4gICAgICBjYXRjaEVycm9yKChlcnI6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcigoKSA9PiBgTGl2ZSB0YWlsaW5nIHdhcyBzdG9wcGVkIGR1ZSB0byBmb2xsb3dpbmcgZXJyb3I6ICR7ZXJyLnJlYXNvbn1gKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICBnZXRSYW5nZVNjb3BlZFZhcnMocmFuZ2U6IFRpbWVSYW5nZSA9IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKSkge1xuICAgIGNvbnN0IG1zUmFuZ2UgPSByYW5nZS50by5kaWZmKHJhbmdlLmZyb20pO1xuICAgIGNvbnN0IHNSYW5nZSA9IE1hdGgucm91bmQobXNSYW5nZSAvIDEwMDApO1xuICAgIHJldHVybiB7XG4gICAgICBfX3JhbmdlX21zOiB7IHRleHQ6IG1zUmFuZ2UsIHZhbHVlOiBtc1JhbmdlIH0sXG4gICAgICBfX3JhbmdlX3M6IHsgdGV4dDogc1JhbmdlLCB2YWx1ZTogc1JhbmdlIH0sXG4gICAgICBfX3JhbmdlOiB7IHRleHQ6IHNSYW5nZSArICdzJywgdmFsdWU6IHNSYW5nZSArICdzJyB9LFxuICAgIH07XG4gIH1cblxuICBpbnRlcnBvbGF0ZVZhcmlhYmxlc0luUXVlcmllcyhxdWVyaWVzOiBMb2tpUXVlcnlbXSwgc2NvcGVkVmFyczogU2NvcGVkVmFycyk6IExva2lRdWVyeVtdIHtcbiAgICBsZXQgZXhwYW5kZWRRdWVyaWVzID0gcXVlcmllcztcbiAgICBpZiAocXVlcmllcyAmJiBxdWVyaWVzLmxlbmd0aCkge1xuICAgICAgZXhwYW5kZWRRdWVyaWVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiAoe1xuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgZGF0YXNvdXJjZTogdGhpcy5nZXRSZWYoKSxcbiAgICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LmV4cHIsIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpLFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRlZFF1ZXJpZXM7XG4gIH1cblxuICBnZXRRdWVyeURpc3BsYXlUZXh0KHF1ZXJ5OiBMb2tpUXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnkuZXhwcjtcbiAgfVxuXG4gIGdldFRpbWVSYW5nZVBhcmFtcygpIHtcbiAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aGlzLnRpbWVTcnYudGltZVJhbmdlKCk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHRpbWVSYW5nZS5mcm9tLnZhbHVlT2YoKSAqIE5TX0lOX01TLCBlbmQ6IHRpbWVSYW5nZS50by52YWx1ZU9mKCkgKiBOU19JTl9NUyB9O1xuICB9XG5cbiAgYXN5bmMgaW1wb3J0RnJvbUFic3RyYWN0UXVlcmllcyhhYnN0cmFjdFF1ZXJpZXM6IEFic3RyYWN0UXVlcnlbXSk6IFByb21pc2U8TG9raVF1ZXJ5W10+IHtcbiAgICBhd2FpdCB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKTtcbiAgICBjb25zdCBleGlzdGluZ0tleXMgPSB0aGlzLmxhbmd1YWdlUHJvdmlkZXIubGFiZWxLZXlzO1xuXG4gICAgaWYgKGV4aXN0aW5nS2V5cyAmJiBleGlzdGluZ0tleXMubGVuZ3RoKSB7XG4gICAgICBhYnN0cmFjdFF1ZXJpZXMgPSBhYnN0cmFjdFF1ZXJpZXMubWFwKChhYnN0cmFjdFF1ZXJ5KSA9PiB7XG4gICAgICAgIGFic3RyYWN0UXVlcnkubGFiZWxNYXRjaGVycyA9IGFic3RyYWN0UXVlcnkubGFiZWxNYXRjaGVycy5maWx0ZXIoKGxhYmVsTWF0Y2hlcikgPT4ge1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ0tleXMuaW5jbHVkZXMobGFiZWxNYXRjaGVyLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFic3RyYWN0UXVlcnk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWJzdHJhY3RRdWVyaWVzLm1hcCgoYWJzdHJhY3RRdWVyeSkgPT4gdGhpcy5sYW5ndWFnZVByb3ZpZGVyLmltcG9ydEZyb21BYnN0cmFjdFF1ZXJ5KGFic3RyYWN0UXVlcnkpKTtcbiAgfVxuXG4gIGFzeW5jIGV4cG9ydFRvQWJzdHJhY3RRdWVyaWVzKHF1ZXJpZXM6IExva2lRdWVyeVtdKTogUHJvbWlzZTxBYnN0cmFjdFF1ZXJ5W10+IHtcbiAgICByZXR1cm4gcXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuZXhwb3J0VG9BYnN0cmFjdFF1ZXJ5KHF1ZXJ5KSk7XG4gIH1cblxuICBhc3luYyBtZXRhZGF0YVJlcXVlc3QodXJsOiBzdHJpbmcsIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlcj4pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBsYXN0VmFsdWVGcm9tKHRoaXMuX3JlcXVlc3QodXJsLCBwYXJhbXMsIHsgaGlkZUZyb21JbnNwZWN0b3I6IHRydWUgfSkpO1xuICAgIHJldHVybiByZXMuZGF0YS5kYXRhIHx8IHJlcy5kYXRhLnZhbHVlcyB8fCBbXTtcbiAgfVxuXG4gIGFzeW5jIG1ldHJpY0ZpbmRRdWVyeShxdWVyeTogc3RyaW5nKSB7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJwb2xhdGVkID0gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LCB7fSwgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvY2Vzc01ldHJpY0ZpbmRRdWVyeShpbnRlcnBvbGF0ZWQpO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc01ldHJpY0ZpbmRRdWVyeShxdWVyeTogc3RyaW5nKSB7XG4gICAgY29uc3QgbGFiZWxOYW1lc1JlZ2V4ID0gL15sYWJlbF9uYW1lc1xcKFxcKVxccyokLztcbiAgICBjb25zdCBsYWJlbFZhbHVlc1JlZ2V4ID0gL15sYWJlbF92YWx1ZXNcXCgoPzooLispLFxccyopPyhbYS16QS1aX11bYS16QS1aMC05X10qKVxcKVxccyokLztcblxuICAgIGNvbnN0IGxhYmVsTmFtZXMgPSBxdWVyeS5tYXRjaChsYWJlbE5hbWVzUmVnZXgpO1xuICAgIGlmIChsYWJlbE5hbWVzKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5sYWJlbE5hbWVzUXVlcnkoKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFZhbHVlcyA9IHF1ZXJ5Lm1hdGNoKGxhYmVsVmFsdWVzUmVnZXgpO1xuICAgIGlmIChsYWJlbFZhbHVlcykge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBxdWVyeSBleHByLCB1c2UgL3NlcmllcyBlbmRwb2ludFxuICAgICAgaWYgKGxhYmVsVmFsdWVzWzFdKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxhYmVsVmFsdWVzU2VyaWVzUXVlcnkobGFiZWxWYWx1ZXNbMV0sIGxhYmVsVmFsdWVzWzJdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxhYmVsVmFsdWVzUXVlcnkobGFiZWxWYWx1ZXNbMl0pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG5cbiAgYXN5bmMgbGFiZWxOYW1lc1F1ZXJ5KCkge1xuICAgIGNvbnN0IHVybCA9IGAke0xPS0lfRU5EUE9JTlR9L2xhYmVsYDtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVzdWx0Lm1hcCgodmFsdWU6IHN0cmluZykgPT4gKHsgdGV4dDogdmFsdWUgfSkpO1xuICB9XG5cbiAgYXN5bmMgbGFiZWxWYWx1ZXNRdWVyeShsYWJlbDogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCB1cmwgPSBgJHtMT0tJX0VORFBPSU5UfS9sYWJlbC8ke2xhYmVsfS92YWx1ZXNgO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVzdWx0Lm1hcCgodmFsdWU6IHN0cmluZykgPT4gKHsgdGV4dDogdmFsdWUgfSkpO1xuICB9XG5cbiAgYXN5bmMgbGFiZWxWYWx1ZXNTZXJpZXNRdWVyeShleHByOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcpIHtcbiAgICBjb25zdCB0aW1lUGFyYW1zID0gdGhpcy5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAuLi50aW1lUGFyYW1zLFxuICAgICAgJ21hdGNoW10nOiBleHByLFxuICAgIH07XG4gICAgY29uc3QgdXJsID0gYCR7TE9LSV9FTkRQT0lOVH0vc2VyaWVzYDtcbiAgICBjb25zdCBzdHJlYW1zID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICByZXN1bHQuZm9yRWFjaCgoc3RyZWFtOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSA9PiB7XG4gICAgICBpZiAoc3RyZWFtW2xhYmVsXSkge1xuICAgICAgICBzdHJlYW1zLmFkZCh7IHRleHQ6IHN0cmVhbVtsYWJlbF0gfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShzdHJlYW1zKTtcbiAgfVxuXG4gIC8vIEJ5IGltcGxlbWVudGluZyBnZXRUYWdLZXlzIGFuZCBnZXRUYWdWYWx1ZXMgd2UgYWRkIGFkLWhvYyBmaWx0dGVycyBmdW5jdGlvbmFsaXR5XG4gIGFzeW5jIGdldFRhZ0tleXMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubGFiZWxOYW1lc1F1ZXJ5KCk7XG4gIH1cblxuICBhc3luYyBnZXRUYWdWYWx1ZXMob3B0aW9uczogYW55ID0ge30pIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5sYWJlbFZhbHVlc1F1ZXJ5KG9wdGlvbnMua2V5KTtcbiAgfVxuXG4gIGludGVycG9sYXRlUXVlcnlFeHByKHZhbHVlOiBhbnksIHZhcmlhYmxlOiBhbnkpIHtcbiAgICAvLyBpZiBubyBtdWx0aSBvciBpbmNsdWRlIGFsbCBkbyBub3QgcmVnZXhFc2NhcGVcbiAgICBpZiAoIXZhcmlhYmxlLm11bHRpICYmICF2YXJpYWJsZS5pbmNsdWRlQWxsKSB7XG4gICAgICByZXR1cm4gbG9raVJlZ3VsYXJFc2NhcGUodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbG9raVNwZWNpYWxSZWdleEVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXNjYXBlZFZhbHVlcyA9IGxvZGFzaE1hcCh2YWx1ZSwgbG9raVNwZWNpYWxSZWdleEVzY2FwZSk7XG4gICAgcmV0dXJuIGVzY2FwZWRWYWx1ZXMuam9pbignfCcpO1xuICB9XG5cbiAgbW9kaWZ5UXVlcnkocXVlcnk6IExva2lRdWVyeSwgYWN0aW9uOiBhbnkpOiBMb2tpUXVlcnkge1xuICAgIGxldCBleHByZXNzaW9uID0gcXVlcnkuZXhwciA/PyAnJztcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdBRERfRklMVEVSJzoge1xuICAgICAgICBleHByZXNzaW9uID0gdGhpcy5hZGRMYWJlbFRvUXVlcnkoZXhwcmVzc2lvbiwgYWN0aW9uLmtleSwgYWN0aW9uLnZhbHVlLCAnPScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0FERF9GSUxURVJfT1VUJzoge1xuICAgICAgICBleHByZXNzaW9uID0gdGhpcy5hZGRMYWJlbFRvUXVlcnkoZXhwcmVzc2lvbiwgYWN0aW9uLmtleSwgYWN0aW9uLnZhbHVlLCAnIT0nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4ucXVlcnksIGV4cHI6IGV4cHJlc3Npb24gfTtcbiAgfVxuXG4gIGdldFRpbWUoZGF0ZTogc3RyaW5nIHwgRGF0ZVRpbWUsIHJvdW5kVXA6IGJvb2xlYW4pIHtcbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRlID0gZGF0ZU1hdGgucGFyc2UoZGF0ZSwgcm91bmRVcCkhO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmNlaWwoZGF0ZS52YWx1ZU9mKCkgKiAxZTYpO1xuICB9XG5cbiAgZ2V0TG9nUm93Q29udGV4dCA9IChyb3c6IExvZ1Jvd01vZGVsLCBvcHRpb25zPzogUm93Q29udGV4dE9wdGlvbnMpOiBQcm9taXNlPHsgZGF0YTogRGF0YUZyYW1lW10gfT4gPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMucHJlcGFyZUxvZ1Jvd0NvbnRleHRRdWVyeVRhcmdldChcbiAgICAgIHJvdyxcbiAgICAgIChvcHRpb25zICYmIG9wdGlvbnMubGltaXQpIHx8IDEwLFxuICAgICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5kaXJlY3Rpb24pIHx8ICdCQUNLV0FSRCdcbiAgICApO1xuXG4gICAgY29uc3QgcmV2ZXJzZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXJlY3Rpb24gPT09ICdGT1JXQVJEJztcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIHRoaXMuX3JlcXVlc3QoUkFOR0VfUVVFUllfRU5EUE9JTlQsIHRhcmdldCkucGlwZShcbiAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXJyb3I6IERhdGFRdWVyeUVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGR1cmluZyBjb250ZXh0IHF1ZXJ5LiBQbGVhc2UgY2hlY2sgSlMgY29uc29sZSBsb2dzLicsXG4gICAgICAgICAgICBzdGF0dXM6IGVyci5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBlcnIuc3RhdHVzVGV4dCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KSxcbiAgICAgICAgc3dpdGNoTWFwKChyZXMpID0+XG4gICAgICAgICAgb2Yoe1xuICAgICAgICAgICAgZGF0YTogcmVzLmRhdGFcbiAgICAgICAgICAgICAgPyByZXMuZGF0YS5kYXRhLnJlc3VsdC5tYXAoKHN0cmVhbTogTG9raVN0cmVhbVJlc3VsdCkgPT4gbG9raVN0cmVhbVJlc3VsdFRvRGF0YUZyYW1lKHN0cmVhbSwgcmV2ZXJzZSkpXG4gICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcHJlcGFyZUxvZ1Jvd0NvbnRleHRRdWVyeVRhcmdldCA9IChyb3c6IExvZ1Jvd01vZGVsLCBsaW1pdDogbnVtYmVyLCBkaXJlY3Rpb246ICdCQUNLV0FSRCcgfCAnRk9SV0FSRCcpID0+IHtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuZ2V0TGFiZWxLZXlzKCk7XG4gICAgY29uc3QgcXVlcnkgPSBPYmplY3Qua2V5cyhyb3cubGFiZWxzKVxuICAgICAgLm1hcCgobGFiZWw6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAobGFiZWxzLmluY2x1ZGVzKGxhYmVsKSkge1xuICAgICAgICAgIC8vIGVzY2FwZSBiYWNrc2xhc2hlcyBpbiBsYWJlbCBhcyB1c2VycyBjYW4ndCBlc2NhcGUgdGhlbSBieSB0aGVtc2VsdmVzXG4gICAgICAgICAgcmV0dXJuIGAke2xhYmVsfT1cIiR7cm93LmxhYmVsc1tsYWJlbF0ucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSlcbiAgICAgIC8vIEZpbHRlciBlbXB0eSBzdHJpbmdzXG4gICAgICAuZmlsdGVyKChsYWJlbCkgPT4gISFsYWJlbClcbiAgICAgIC5qb2luKCcsJyk7XG5cbiAgICBjb25zdCBjb250ZXh0VGltZUJ1ZmZlciA9IDIgKiA2MCAqIDYwICogMTAwMDsgLy8gMmggYnVmZmVyXG4gICAgY29uc3QgY29tbW9uVGFyZ2V0T3B0aW9ucyA9IHtcbiAgICAgIGxpbWl0LFxuICAgICAgcXVlcnk6IGB7JHtxdWVyeX19YCxcbiAgICAgIGV4cHI6IGB7JHtxdWVyeX19YCxcbiAgICAgIGRpcmVjdGlvbixcbiAgICB9O1xuXG4gICAgY29uc3QgZmllbGRDYWNoZSA9IG5ldyBGaWVsZENhY2hlKHJvdy5kYXRhRnJhbWUpO1xuICAgIGNvbnN0IG5zRmllbGQgPSBmaWVsZENhY2hlLmdldEZpZWxkQnlOYW1lKCd0c05zJykhO1xuICAgIGNvbnN0IG5zVGltZXN0YW1wID0gbnNGaWVsZC52YWx1ZXMuZ2V0KHJvdy5yb3dJbmRleCk7XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSAnQkFDS1dBUkQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb21tb25UYXJnZXRPcHRpb25zLFxuICAgICAgICAvLyBjb252ZXJ0IHRvIG5zLCB3ZSBsb29zZSBzb21lIHByZWNpc2lvbiBoZXJlIGJ1dCBpdCBpcyBub3QgdGhhdCBpbXBvcnRhbnQgYXQgdGhlIGZhciBwb2ludHMgb2YgdGhlIGNvbnRleHRcbiAgICAgICAgc3RhcnQ6IHJvdy50aW1lRXBvY2hNcyAtIGNvbnRleHRUaW1lQnVmZmVyICsgJzAwMDAwMCcsXG4gICAgICAgIGVuZDogbnNUaW1lc3RhbXAsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbW1vblRhcmdldE9wdGlvbnMsXG4gICAgICAgIC8vIHN0YXJ0IHBhcmFtIGluIExva2kgQVBJIGlzIGluY2x1c2l2ZSBzbyB3ZSdsbCBoYXZlIHRvIGZpbHRlciBvdXQgdGhlIHJvdyB0aGF0IHRoaXMgcmVxdWVzdCBpcyBiYXNlZCBmcm9tXG4gICAgICAgIC8vIGFuZCBhbnkgb3RoZXIgdGhhdCB3ZXJlIGxvZ2dlZCBpbiB0aGUgc2FtZSBucyBidXQgYmVmb3JlIHRoZSByb3cuIFJpZ2h0IG5vdyB0aGVzZSByb3dzIHdpbGwgYmUgbG9zdFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBhcmUgYmVmb3JlIGJ1dCBjYW1lIGl0IGhlIHJlc3BvbnNlIHRoYXQgc2hvdWxkIHJldHVybiBvbmx5IHJvd3MgYWZ0ZXIuXG4gICAgICAgIHN0YXJ0OiBuc1RpbWVzdGFtcCxcbiAgICAgICAgLy8gY29udmVydCB0byBucywgd2UgbG9vc2Ugc29tZSBwcmVjaXNpb24gaGVyZSBidXQgaXQgaXMgbm90IHRoYXQgaW1wb3J0YW50IGF0IHRoZSBmYXIgcG9pbnRzIG9mIHRoZSBjb250ZXh0XG4gICAgICAgIGVuZDogcm93LnRpbWVFcG9jaE1zICsgY29udGV4dFRpbWVCdWZmZXIgKyAnMDAwMDAwJyxcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHRlc3REYXRhc291cmNlKCkge1xuICAgIC8vIENvbnNpZGVyIG9ubHkgbGFzdCAxMCBtaW51dGVzIG90aGVyd2lzZSByZXF1ZXN0IHRha2VzIHRvbyBsb25nXG4gICAgY29uc3Qgc3RhcnRNcyA9IERhdGUubm93KCkgLSAxMCAqIDYwICogMTAwMDtcbiAgICBjb25zdCBzdGFydCA9IGAke3N0YXJ0TXN9MDAwMDAwYDsgLy8gQVBJIGV4cGVjdHMgbmFub3NlY29uZHNcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIHRoaXMuX3JlcXVlc3QoYCR7TE9LSV9FTkRQT0lOVH0vbGFiZWxgLCB7IHN0YXJ0IH0pLnBpcGUoXG4gICAgICAgIG1hcCgocmVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWVzOiBhbnlbXSA9IHJlcz8uZGF0YT8uZGF0YSB8fCByZXM/LmRhdGE/LnZhbHVlcyB8fCBbXTtcbiAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID1cbiAgICAgICAgICAgIHZhbHVlcy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgID8geyBzdGF0dXM6ICdzdWNjZXNzJywgbWVzc2FnZTogJ0RhdGEgc291cmNlIGNvbm5lY3RlZCBhbmQgbGFiZWxzIGZvdW5kLicgfVxuICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICAgICAgICdEYXRhIHNvdXJjZSBjb25uZWN0ZWQsIGJ1dCBubyBsYWJlbHMgcmVjZWl2ZWQuIFZlcmlmeSB0aGF0IExva2kgYW5kIFByb210YWlsIGlzIGNvbmZpZ3VyZWQgcHJvcGVybHkuJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB0ZXN0UmVzdWx0O1xuICAgICAgICB9KSxcbiAgICAgICAgY2F0Y2hFcnJvcigoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgICBsZXQgbWVzc2FnZSA9ICdMb2tpOiAnO1xuICAgICAgICAgIGlmIChlcnIuc3RhdHVzVGV4dCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBlcnIuc3RhdHVzVGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSAnQ2Fubm90IGNvbm5lY3QgdG8gTG9raSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVyci5zdGF0dXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYC4gJHtlcnIuc3RhdHVzfWA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVyci5kYXRhICYmIGVyci5kYXRhLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYC4gJHtlcnIuZGF0YS5tZXNzYWdlfWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChlcnIuZGF0YSkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBgLiAke2Vyci5kYXRhfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvZih7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgYW5ub3RhdGlvblF1ZXJ5KG9wdGlvbnM6IGFueSk6IFByb21pc2U8QW5ub3RhdGlvbkV2ZW50W10+IHtcbiAgICBjb25zdCB7XG4gICAgICBleHByLFxuICAgICAgbWF4TGluZXMsXG4gICAgICBpbnN0YW50LFxuICAgICAgc3RlcEludGVydmFsLFxuICAgICAgdGFnS2V5cyA9ICcnLFxuICAgICAgdGl0bGVGb3JtYXQgPSAnJyxcbiAgICAgIHRleHRGb3JtYXQgPSAnJyxcbiAgICB9ID0gb3B0aW9ucy5hbm5vdGF0aW9uO1xuXG4gICAgaWYgKCFleHByKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJwb2xhdGVkRXhwciA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShleHByLCB7fSwgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gICAgY29uc3QgcXVlcnkgPSB7XG4gICAgICByZWZJZDogYGFubm90YXRpb24tJHtvcHRpb25zLmFubm90YXRpb24ubmFtZX1gLFxuICAgICAgZXhwcjogaW50ZXJwb2xhdGVkRXhwcixcbiAgICAgIG1heExpbmVzLFxuICAgICAgaW5zdGFudCxcbiAgICAgIHN0ZXBJbnRlcnZhbCxcbiAgICAgIHF1ZXJ5VHlwZTogaW5zdGFudCA/IExva2lRdWVyeVR5cGUuSW5zdGFudCA6IExva2lRdWVyeVR5cGUuUmFuZ2UsXG4gICAgfTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGluc3RhbnRcbiAgICAgID8gYXdhaXQgbGFzdFZhbHVlRnJvbSh0aGlzLnJ1bkluc3RhbnRRdWVyeShxdWVyeSwgb3B0aW9ucyBhcyBhbnkpKVxuICAgICAgOiBhd2FpdCBsYXN0VmFsdWVGcm9tKHRoaXMucnVuUmFuZ2VRdWVyeShxdWVyeSwgb3B0aW9ucyBhcyBhbnkpKTtcblxuICAgIGNvbnN0IGFubm90YXRpb25zOiBBbm5vdGF0aW9uRXZlbnRbXSA9IFtdO1xuICAgIGNvbnN0IHNwbGl0S2V5czogc3RyaW5nW10gPSB0YWdLZXlzLnNwbGl0KCcsJykuZmlsdGVyKCh2OiBzdHJpbmcpID0+IHYgIT09ICcnKTtcblxuICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZGF0YSkge1xuICAgICAgY29uc3QgbGFiZWxzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZyYW1lLmZpZWxkcykge1xuICAgICAgICBpZiAoZmllbGQubGFiZWxzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGQubGFiZWxzKSkge1xuICAgICAgICAgICAgbGFiZWxzW2tleV0gPSBTdHJpbmcodmFsdWUpLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFnczogc3RyaW5nW10gPSBbXG4gICAgICAgIC4uLm5ldyBTZXQoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMobGFiZWxzKS5yZWR1Y2UoKGFjYzogc3RyaW5nW10sIFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BsaXRLZXlzLmxlbmd0aCAmJiAhc3BsaXRLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjYy5wdXNoLmFwcGx5KGFjYywgW3ZhbF0pO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LCBbXSlcbiAgICAgICAgKSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YUZyYW1lVmlldzx7IHRzOiBzdHJpbmc7IGxpbmU6IHN0cmluZyB9PihmcmFtZSk7XG5cbiAgICAgIHZpZXcuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgIGFubm90YXRpb25zLnB1c2goe1xuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJvdy50cykudmFsdWVPZigpLFxuICAgICAgICAgIHRpdGxlOiByZW5kZXJMZWdlbmRGb3JtYXQodGl0bGVGb3JtYXQsIGxhYmVscyksXG4gICAgICAgICAgdGV4dDogcmVuZGVyTGVnZW5kRm9ybWF0KHRleHRGb3JtYXQsIGxhYmVscykgfHwgcm93LmxpbmUsXG4gICAgICAgICAgdGFncyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gIH1cblxuICBzaG93Q29udGV4dFRvZ2dsZShyb3c/OiBMb2dSb3dNb2RlbCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAocm93ICYmIHJvdy5zZWFyY2hXb3JkcyAmJiByb3cuc2VhcmNoV29yZHMubGVuZ3RoID4gMCkgPT09IHRydWU7XG4gIH1cblxuICBwcm9jZXNzRXJyb3IoZXJyOiBGZXRjaEVycm9yLCB0YXJnZXQ6IExva2lRdWVyeSkge1xuICAgIGxldCBlcnJvciA9IGNsb25lRGVlcChlcnIpO1xuICAgIGlmIChlcnIuZGF0YS5tZXNzYWdlLmluY2x1ZGVzKCdlc2NhcGUnKSAmJiB0YXJnZXQuZXhwci5pbmNsdWRlcygnXFxcXCcpKSB7XG4gICAgICBlcnJvci5kYXRhLm1lc3NhZ2UgPSBgRXJyb3I6ICR7ZXJyLmRhdGEubWVzc2FnZX0uIE1ha2Ugc3VyZSB0aGF0IGFsbCBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCBcXFxcLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBlc2NhcGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnMgdmlzaXQgTG9nUUwgZG9jdW1lbnRhdGlvbiBhdCBodHRwczovL2dyYWZhbmEuY29tL2RvY3MvbG9raS9sYXRlc3QvbG9ncWwvLmA7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIGFkanVzdEludGVydmFsKGR5bmFtaWNJbnRlcnZhbDogbnVtYmVyLCByZXNvbHV0aW9uOiBudW1iZXIsIHJhbmdlOiBudW1iZXIpIHtcbiAgICAvLyBMb2tpIHdpbGwgZHJvcCBxdWVyaWVzIHRoYXQgbWlnaHQgcmV0dXJuIG1vcmUgdGhhbiAxMTAwMCBkYXRhIHBvaW50cy5cbiAgICAvLyBDYWxpYnJhdGUgaW50ZXJ2YWwgaWYgaXQgaXMgdG9vIHNtYWxsLlxuICAgIGxldCBzYWZlSW50ZXJ2YWwgPSByYW5nZSAvIDExMDAwO1xuICAgIGlmIChzYWZlSW50ZXJ2YWwgPiAxKSB7XG4gICAgICBzYWZlSW50ZXJ2YWwgPSBNYXRoLmNlaWwoc2FmZUludGVydmFsKTtcbiAgICB9XG5cbiAgICBsZXQgYWRqdXN0ZWRJbnRlcnZhbCA9IE1hdGgubWF4KHJlc29sdXRpb24gKiBkeW5hbWljSW50ZXJ2YWwsIHNhZmVJbnRlcnZhbCk7XG4gICAgcmV0dXJuIGFkanVzdGVkSW50ZXJ2YWw7XG4gIH1cblxuICBhZGRBZEhvY0ZpbHRlcnMocXVlcnlFeHByOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhZGhvY0ZpbHRlcnMgPSB0aGlzLnRlbXBsYXRlU3J2LmdldEFkaG9jRmlsdGVycyh0aGlzLm5hbWUpO1xuICAgIGxldCBleHByID0gcXVlcnlFeHByO1xuXG4gICAgZXhwciA9IGFkaG9jRmlsdGVycy5yZWR1Y2UoKGFjYzogc3RyaW5nLCBmaWx0ZXI6IHsga2V5PzogYW55OyBvcGVyYXRvcj86IGFueTsgdmFsdWU/OiBhbnkgfSkgPT4ge1xuICAgICAgY29uc3QgeyBrZXksIG9wZXJhdG9yIH0gPSBmaWx0ZXI7XG4gICAgICBsZXQgeyB2YWx1ZSB9ID0gZmlsdGVyO1xuICAgICAgaWYgKG9wZXJhdG9yID09PSAnPX4nIHx8IG9wZXJhdG9yID09PSAnIX4nKSB7XG4gICAgICAgIHZhbHVlID0gbG9raVJlZ3VsYXJFc2NhcGUodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hZGRMYWJlbFRvUXVlcnkoYWNjLCBrZXksIHZhbHVlLCBvcGVyYXRvciwgdHJ1ZSk7XG4gICAgfSwgZXhwcik7XG5cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGFkZExhYmVsVG9RdWVyeShcbiAgICBxdWVyeUV4cHI6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLFxuICAgIG9wZXJhdG9yOiBzdHJpbmcsXG4gICAgLy8gT3ZlcnJpZGUgdG8gbWFrZSBzdXJlIHRoYXQgd2UgdXNlIGxhYmVsIGFzIGFjdHVhbCBsYWJlbCBhbmQgbm90IHBhcnNlZCBsYWJlbFxuICAgIG5vdFBhcnNlZExhYmVsT3ZlcnJpZGU/OiBib29sZWFuXG4gICkge1xuICAgIGlmIChxdWVyeUhhc1BpcGVQYXJzZXIocXVlcnlFeHByKSAmJiAhaXNNZXRyaWNzUXVlcnkocXVlcnlFeHByKSAmJiAhbm90UGFyc2VkTGFiZWxPdmVycmlkZSkge1xuICAgICAgLy8gSWYgcXVlcnkgaGFzIHBhcnNlciwgd2UgdHJlYXQgYWxsIGxhYmVscyBhcyBwYXJzZWQgYW5kIHVzZSB8IGtleT1cInZhbHVlXCIgc3ludGF4XG4gICAgICByZXR1cm4gYWRkUGFyc2VkTGFiZWxUb1F1ZXJ5KHF1ZXJ5RXhwciwga2V5LCB2YWx1ZSwgb3BlcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkTGFiZWxUb1F1ZXJ5KHF1ZXJ5RXhwciwga2V5LCB2YWx1ZSwgb3BlcmF0b3IsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgd2hlbiBydW5uaW5nIHF1ZXJpZXMgdGhyb3VnaCBiYWNrZW5kXG4gIGZpbHRlclF1ZXJ5KHF1ZXJ5OiBMb2tpUXVlcnkpOiBib29sZWFuIHtcbiAgICBpZiAocXVlcnkuaGlkZSB8fCBxdWVyeS5leHByID09PSAnJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFVzZWQgd2hlbiBydW5uaW5nIHF1ZXJpZXMgdGhyb3VnaCBiYWNrZW5kXG4gIGFwcGx5VGVtcGxhdGVWYXJpYWJsZXModGFyZ2V0OiBMb2tpUXVlcnksIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnMpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICAvLyBXZSB3YW50IHRvIGludGVycG9sYXRlIHRoZXNlIHZhcmlhYmxlcyBvbiBiYWNrZW5kXG4gICAgY29uc3QgeyBfX2ludGVydmFsLCBfX2ludGVydmFsX21zLCAuLi5yZXN0IH0gPSBzY29wZWRWYXJzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIGxlZ2VuZEZvcm1hdDogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5sZWdlbmRGb3JtYXQsIHJlc3QpLFxuICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5leHByLCByZXN0LCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKSxcbiAgICB9O1xuICB9XG5cbiAgaW50ZXJwb2xhdGVTdHJpbmcoc3RyaW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHN0cmluZywgdW5kZWZpbmVkLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVTcnYuZ2V0VmFyaWFibGVzKCkubWFwKCh2KSA9PiBgJCR7di5uYW1lfWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2tpUmVndWxhckVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLycvZywgXCJcXFxcXFxcXCdcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9raVNwZWNpYWxSZWdleEVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxva2lSZWd1bGFyRXNjYXBlKHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcXFxcXFxcXFwnKS5yZXBsYWNlKC9bJF4qe31cXFtcXF0rPy4oKXxdL2csICdcXFxcXFxcXCQmJykpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHF1ZXJ5IGV4cHJlc3Npb24gdXNlcyBmdW5jdGlvbiBhbmQgc28gc2hvdWxkIHJldHVybiBhIHRpbWUgc2VyaWVzIGluc3RlYWQgb2YgbG9ncy5cbiAqIFNvbWV0aW1lcyBpbXBvcnRhbnQgdG8ga25vdyB0aGF0IGJlZm9yZSB3ZSBhY3R1YWxseSBkbyB0aGUgcXVlcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc01ldHJpY3NRdWVyeShxdWVyeTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gUHJpc20udG9rZW5pemUocXVlcnksIHN5bnRheCk7XG4gIHJldHVybiB0b2tlbnMuc29tZSgodCkgPT4ge1xuICAgIC8vIE5vdCBzdXJlIGluIHdoaWNoIGNhc2VzIGl0IGNhbiBiZSBzdHJpbmcgbWF5YmUgaWYgbm90aGluZyBtYXRjaGVkIHdoaWNoIG1lYW5zIGl0IHNob3VsZCBub3QgYmUgYSBmdW5jdGlvblxuICAgIHJldHVybiB0eXBlb2YgdCAhPT0gJ3N0cmluZycgJiYgdC50eXBlID09PSAnZnVuY3Rpb24nO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdExldmVsKGRhdGFGcmFtZTogRGF0YUZyYW1lKTogTG9nTGV2ZWwge1xuICBsZXQgdmFsdWVGaWVsZDtcbiAgdHJ5IHtcbiAgICB2YWx1ZUZpZWxkID0gbmV3IEZpZWxkQ2FjaGUoZGF0YUZyYW1lKS5nZXRGaXJzdEZpZWxkT2ZUeXBlKEZpZWxkVHlwZS5udW1iZXIpO1xuICB9IGNhdGNoIHt9XG4gIHJldHVybiB2YWx1ZUZpZWxkPy5sYWJlbHMgPyBnZXRMb2dMZXZlbEZyb21MYWJlbHModmFsdWVGaWVsZC5sYWJlbHMpIDogTG9nTGV2ZWwudW5rbm93bjtcbn1cblxuZnVuY3Rpb24gZ2V0TG9nTGV2ZWxGcm9tTGFiZWxzKGxhYmVsczogTGFiZWxzKTogTG9nTGV2ZWwge1xuICBjb25zdCBsYWJlbE5hbWVzID0gWydsZXZlbCcsICdsdmwnLCAnbG9nbGV2ZWwnXTtcbiAgbGV0IGxldmVsTGFiZWw7XG4gIGZvciAobGV0IGxhYmVsTmFtZSBvZiBsYWJlbE5hbWVzKSB7XG4gICAgaWYgKGxhYmVsTmFtZSBpbiBsYWJlbHMpIHtcbiAgICAgIGxldmVsTGFiZWwgPSBsYWJlbE5hbWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVsTGFiZWwgPyBnZXRMb2dMZXZlbEZyb21LZXkobGFiZWxzW2xldmVsTGFiZWxdKSA6IExvZ0xldmVsLnVua25vd247XG59XG4iLCIvLyBMaWJyYXJpZXNcbmltcG9ydCB7IGNoYWluLCBkaWZmZXJlbmNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcblxuLy8gU2VydmljZXMgJiBVdGlsc1xuaW1wb3J0IHtcbiAgZXh0cmFjdExhYmVsTWF0Y2hlcnMsXG4gIHBhcnNlU2VsZWN0b3IsXG4gIHByb2Nlc3NMYWJlbHMsXG4gIHRvUHJvbUxpa2VFeHByLFxufSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IHN5bnRheCwgeyBGVU5DVElPTlMsIFBJUEVfUEFSU0VSUywgUElQRV9PUEVSQVRPUlMgfSBmcm9tICcuL3N5bnRheCc7XG5cbi8vIFR5cGVzXG5pbXBvcnQgeyBMb2tpUXVlcnksIExva2lRdWVyeVR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGRhdGVUaW1lLCBBYnNvbHV0ZVRpbWVSYW5nZSwgTGFuZ3VhZ2VQcm92aWRlciwgSGlzdG9yeUl0ZW0sIEFic3RyYWN0UXVlcnkgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgTG9raURhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgQ29tcGxldGlvbkl0ZW0sIFR5cGVhaGVhZElucHV0LCBUeXBlYWhlYWRPdXRwdXQsIENvbXBsZXRpb25JdGVtR3JvdXAgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgUHJpc20sIHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuXG5jb25zdCBERUZBVUxUX0tFWVMgPSBbJ2pvYicsICduYW1lc3BhY2UnXTtcbmNvbnN0IEVNUFRZX1NFTEVDVE9SID0gJ3t9JztcbmNvbnN0IEhJU1RPUllfSVRFTV9DT1VOVCA9IDEwO1xuY29uc3QgSElTVE9SWV9DT1VOVF9DVVRPRkYgPSAxMDAwICogNjAgKiA2MCAqIDI0OyAvLyAyNGhcbmNvbnN0IE5TX0lOX01TID0gMTAwMDAwMDtcblxuLy8gV2hlbiBjaGFuZ2luZyBSQVRFX1JBTkdFUywgY2hlY2sgaWYgUHJvbWV0aGV1cy9Qcm9tUUwgcmFuZ2VzIHNob3VsZCBiZSBjaGFuZ2VkIHRvb1xuLy8gQHNlZSBwdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3Byb21xbC50c1xuY29uc3QgUkFURV9SQU5HRVM6IENvbXBsZXRpb25JdGVtW10gPSBbXG4gIHsgbGFiZWw6ICckX19pbnRlcnZhbCcsIHNvcnRWYWx1ZTogJyRfX2ludGVydmFsJyB9LFxuICB7IGxhYmVsOiAnJF9fcmFuZ2UnLCBzb3J0VmFsdWU6ICckX19yYW5nZScgfSxcbiAgeyBsYWJlbDogJzFtJywgc29ydFZhbHVlOiAnMDA6MDE6MDAnIH0sXG4gIHsgbGFiZWw6ICc1bScsIHNvcnRWYWx1ZTogJzAwOjA1OjAwJyB9LFxuICB7IGxhYmVsOiAnMTBtJywgc29ydFZhbHVlOiAnMDA6MTA6MDAnIH0sXG4gIHsgbGFiZWw6ICczMG0nLCBzb3J0VmFsdWU6ICcwMDozMDowMCcgfSxcbiAgeyBsYWJlbDogJzFoJywgc29ydFZhbHVlOiAnMDE6MDA6MDAnIH0sXG4gIHsgbGFiZWw6ICcxZCcsIHNvcnRWYWx1ZTogJzI0OjAwOjAwJyB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IExBQkVMX1JFRlJFU0hfSU5URVJWQUwgPSAxMDAwICogMzA7IC8vIDMwc2VjXG5cbmNvbnN0IHdyYXBMYWJlbCA9IChsYWJlbDogc3RyaW5nKSA9PiAoeyBsYWJlbCwgZmlsdGVyVGV4dDogYFxcXCIke2xhYmVsfVxcXCJgIH0pO1xuXG5leHBvcnQgdHlwZSBMb2tpSGlzdG9yeUl0ZW0gPSBIaXN0b3J5SXRlbTxMb2tpUXVlcnk+O1xuXG50eXBlIFR5cGVhaGVhZENvbnRleHQgPSB7XG4gIGhpc3Rvcnk/OiBMb2tpSGlzdG9yeUl0ZW1bXTtcbiAgYWJzb2x1dGVSYW5nZT86IEFic29sdXRlVGltZVJhbmdlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEhpc3RvcnlNZXRhZGF0YShpdGVtOiBDb21wbGV0aW9uSXRlbSwgaGlzdG9yeTogTG9raUhpc3RvcnlJdGVtW10pOiBDb21wbGV0aW9uSXRlbSB7XG4gIGNvbnN0IGN1dG9mZlRzID0gRGF0ZS5ub3coKSAtIEhJU1RPUllfQ09VTlRfQ1VUT0ZGO1xuICBjb25zdCBoaXN0b3J5Rm9ySXRlbSA9IGhpc3RvcnkuZmlsdGVyKChoKSA9PiBoLnRzID4gY3V0b2ZmVHMgJiYgaC5xdWVyeS5leHByID09PSBpdGVtLmxhYmVsKTtcbiAgbGV0IGhpbnQgPSBgUXVlcmllZCAke2hpc3RvcnlGb3JJdGVtLmxlbmd0aH0gdGltZXMgaW4gdGhlIGxhc3QgMjRoLmA7XG4gIGNvbnN0IHJlY2VudCA9IGhpc3RvcnlGb3JJdGVtWzBdO1xuXG4gIGlmIChyZWNlbnQpIHtcbiAgICBjb25zdCBsYXN0UXVlcmllZCA9IGRhdGVUaW1lKHJlY2VudC50cykuZnJvbU5vdygpO1xuICAgIGhpbnQgPSBgJHtoaW50fSBMYXN0IHF1ZXJpZWQgJHtsYXN0UXVlcmllZH0uYDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uaXRlbSxcbiAgICBkb2N1bWVudGF0aW9uOiBoaW50LFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2tpTGFuZ3VhZ2VQcm92aWRlciBleHRlbmRzIExhbmd1YWdlUHJvdmlkZXIge1xuICBsYWJlbEtleXM6IHN0cmluZ1tdO1xuICBsYWJlbEZldGNoVHM6IG51bWJlcjtcbiAgc3RhcnRlZCA9IGZhbHNlO1xuICBkYXRhc291cmNlOiBMb2tpRGF0YXNvdXJjZTtcbiAgbG9va3Vwc0Rpc2FibGVkID0gZmFsc2U7IC8vIER5bmFtaWNhbGx5IHNldCB0byB0cnVlIGZvciBiaWcvc2xvdyBpbnN0YW5jZXNcblxuICAvKipcbiAgICogIENhY2hlIGZvciBsYWJlbHMgb2Ygc2VyaWVzLiBUaGlzIGlzIGJpdCBzaW1wbGlzdGljIGluIHRoZSBzZW5zZSB0aGF0IGl0IGp1c3QgY291bnRzIHJlc3BvbnNlcyBlYWNoIGFzIGEgMSBhbmQgZG9lc1xuICAgKiAgbm90IGFjY291bnQgZm9yIGRpZmZlcmVudCBzaXplIG9mIGEgcmVzcG9uc2UuIElmIHRoYXQgaXMgbmVlZGVkIGEgYGxlbmd0aGAgZnVuY3Rpb24gY2FuIGJlIGFkZGVkIGluIHRoZSBvcHRpb25zLlxuICAgKiAgMTAgYXMgYSBtYXggc2l6ZSBpcyB0b3RhbGx5IGFyYml0cmFyeSByaWdodCBub3cuXG4gICAqL1xuICBwcml2YXRlIHNlcmllc0NhY2hlID0gbmV3IExSVTxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4oeyBtYXg6IDEwIH0pO1xuICBwcml2YXRlIGxhYmVsc0NhY2hlID0gbmV3IExSVTxzdHJpbmcsIHN0cmluZ1tdPih7IG1heDogMTAgfSk7XG5cbiAgY29uc3RydWN0b3IoZGF0YXNvdXJjZTogTG9raURhdGFzb3VyY2UsIGluaXRpYWxWYWx1ZXM/OiBhbnkpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5kYXRhc291cmNlID0gZGF0YXNvdXJjZTtcbiAgICB0aGlzLmxhYmVsS2V5cyA9IFtdO1xuICAgIHRoaXMubGFiZWxGZXRjaFRzID0gMDtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW5pdGlhbFZhbHVlcyk7XG4gIH1cblxuICAvLyBTdHJpcCBzeW50YXggY2hhcnNcbiAgY2xlYW5UZXh0ID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC9be31bXFxdPVwiKCksIX4rXFwtKi9eJVxcfF0vZywgJycpLnRyaW0oKTtcblxuICBnZXRTeW50YXgoKTogR3JhbW1hciB7XG4gICAgcmV0dXJuIHN5bnRheDtcbiAgfVxuXG4gIHJlcXVlc3QgPSBhc3luYyAodXJsOiBzdHJpbmcsIHBhcmFtcz86IGFueSk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgbGFuZ3VhZ2UgcHJvdmlkZXIgYnkgZmV0Y2hpbmcgc2V0IG9mIGxhYmVscy4gV2l0aG91dCB0aGlzIGluaXRpYWxpc2F0aW9uIHRoZSBwcm92aWRlciB3b3VsZCByZXR1cm5cbiAgICoganVzdCBhIHNldCBvZiBoYXJkY29kZWQgZGVmYXVsdCBsYWJlbHMgb24gcHJvdmlkZUNvbXBsZXRpb25JdGVtcyBvciBhIHJlY2VudCBxdWVyaWVzIGZyb20gaGlzdG9yeS5cbiAgICovXG4gIHN0YXJ0ID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5zdGFydFRhc2spIHtcbiAgICAgIHRoaXMuc3RhcnRUYXNrID0gdGhpcy5mZXRjaExhYmVscygpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGFydFRhc2s7XG4gIH07XG5cbiAgZ2V0TGFiZWxLZXlzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbEtleXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHN1Z2dlc3Rpb25zIGJhc2VkIG9uIGlucHV0IHRoYXQgY2FuIGJlIHRoZW4gcGx1Z2dlZCBpbnRvIGEgdHlwZWFoZWFkIGRyb3Bkb3duLlxuICAgKiBLZWVwIHRoaXMgRE9NLWZyZWUgZm9yIHRlc3RpbmdcbiAgICogQHBhcmFtIGlucHV0XG4gICAqIEBwYXJhbSBjb250ZXh0IElzIG9wdGlvbmFsIGluIHR5cGVzIGJ1dCBpcyByZXF1aXJlZCBpbiBjYXNlIHdlIGFyZSBkb2luZyBnZXRMYWJlbENvbXBsZXRpb25JdGVtc1xuICAgKiBAcGFyYW0gY29udGV4dC5hYnNvbHV0ZVJhbmdlIFJlcXVpcmVkIGluIGNhc2Ugd2UgYXJlIGRvaW5nIGdldExhYmVsQ29tcGxldGlvbkl0ZW1zXG4gICAqIEBwYXJhbSBjb250ZXh0Lmhpc3RvcnkgT3B0aW9uYWwgdXNlZCBvbmx5IGluIGdldEVtcHR5Q29tcGxldGlvbkl0ZW1zXG4gICAqL1xuICBhc3luYyBwcm92aWRlQ29tcGxldGlvbkl0ZW1zKGlucHV0OiBUeXBlYWhlYWRJbnB1dCwgY29udGV4dD86IFR5cGVhaGVhZENvbnRleHQpOiBQcm9taXNlPFR5cGVhaGVhZE91dHB1dD4ge1xuICAgIGNvbnN0IHsgd3JhcHBlckNsYXNzZXMsIHZhbHVlLCBwcmVmaXgsIHRleHQgfSA9IGlucHV0O1xuICAgIGNvbnN0IGVtcHR5UmVzdWx0OiBUeXBlYWhlYWRPdXRwdXQgPSB7IHN1Z2dlc3Rpb25zOiBbXSB9O1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0O1xuICAgIH1cblxuICAgIC8vIExvY2FsIHRleHQgcHJvcGVydGllc1xuICAgIGNvbnN0IGVtcHR5ID0gdmFsdWU/LmRvY3VtZW50LnRleHQubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IHNlbGVjdGVkTGluZXMgPSB2YWx1ZS5kb2N1bWVudC5nZXRUZXh0c0F0UmFuZ2UodmFsdWUuc2VsZWN0aW9uKTtcbiAgICBjb25zdCBjdXJyZW50TGluZSA9IHNlbGVjdGVkTGluZXMuc2l6ZSA9PT0gMSA/IHNlbGVjdGVkTGluZXMuZmlyc3QoKS5nZXRUZXh0KCkgOiBudWxsO1xuXG4gICAgY29uc3QgbmV4dENoYXJhY3RlciA9IGN1cnJlbnRMaW5lID8gY3VycmVudExpbmVbdmFsdWUuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXRdIDogbnVsbDtcblxuICAgIC8vIFN5bnRheCBzcGFucyBoYXZlIDMgY2xhc3NlcyBieSBkZWZhdWx0LiBNb3JlIGluZGljYXRlIGEgcmVjb2duaXplZCB0b2tlblxuICAgIGNvbnN0IHRva2VuUmVjb2duaXplZCA9IHdyYXBwZXJDbGFzc2VzLmxlbmd0aCA+IDM7XG5cbiAgICAvLyBOb24tZW1wdHkgcHJlZml4LCBidXQgbm90IGluc2lkZSBrbm93biB0b2tlblxuICAgIGNvbnN0IHByZWZpeFVucmVjb2duaXplZCA9IHByZWZpeCAmJiAhdG9rZW5SZWNvZ25pemVkO1xuXG4gICAgLy8gUHJldmVudCBzdWdnZXN0aW9ucyBpbiBgZnVuY3Rpb24ofHN1ZmZpeClgXG4gICAgY29uc3Qgbm9TdWZmaXggPSAhbmV4dENoYXJhY3RlciB8fCBuZXh0Q2hhcmFjdGVyID09PSAnKSc7XG5cbiAgICAvLyBQcmVmaXggaXMgc2FmZSBpZiBpdCBkb2VzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3cgYSBjb21wbGV0ZSBleHByZXNzaW9uIGFuZCBoYXMgbm8gdGV4dCBhZnRlciBpdFxuICAgIGNvbnN0IHNhZmVQcmVmaXggPSBwcmVmaXggJiYgIXRleHQubWF0Y2goL15bJ1wifj1cXF19KVxcc10rJC8pICYmIG5vU3VmZml4O1xuXG4gICAgLy8gQWJvdXQgdG8gdHlwZSBuZXh0IG9wZXJhbmQgaWYgcHJlY2VkZWQgYnkgYmluYXJ5IG9wZXJhdG9yXG4gICAgY29uc3Qgb3BlcmF0b3JzUGF0dGVybiA9IC9bK1xcLSovXiVdLztcbiAgICBjb25zdCBpc05leHRPcGVyYW5kID0gdGV4dC5tYXRjaChvcGVyYXRvcnNQYXR0ZXJuKTtcblxuICAgIC8vIERldGVybWluZSBjYW5kaWRhdGVzIGJ5IENTUyBjb250ZXh0XG4gICAgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LXJhbmdlJykpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBtZXRyaWNbfF1cbiAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlQ29tcGxldGlvbkl0ZW1zKCk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1sYWJlbHMnKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIHt8fSBhbmQge2Zvbz18fVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2NvbnRleHQtcGlwZScpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQaXBlQ29tcGxldGlvbkl0ZW0oKTtcbiAgICB9IGVsc2UgaWYgKGVtcHR5KSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3IgZW1wdHkgcXVlcnkgZmllbGRcbiAgICAgIHJldHVybiB0aGlzLmdldEVtcHR5Q29tcGxldGlvbkl0ZW1zKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocHJlZml4VW5yZWNvZ25pemVkICYmIG5vU3VmZml4ICYmICFpc05leHRPcGVyYW5kKSB7XG4gICAgICAvLyBTaG93IHRlcm0gc3VnZ2VzdGlvbnMgaW4gYSBjb3VwbGUgb2Ygc2NlbmFyaW9zXG4gICAgICByZXR1cm4gdGhpcy5nZXRCZWdpbm5pbmdDb21wbGV0aW9uSXRlbXMoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXhVbnJlY29nbml6ZWQgJiYgc2FmZVByZWZpeCkge1xuICAgICAgLy8gU2hvdyB0ZXJtIHN1Z2dlc3Rpb25zIGluIGEgY291cGxlIG9mIHNjZW5hcmlvc1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGVybUNvbXBsZXRpb25JdGVtcygpO1xuICAgIH1cblxuICAgIHJldHVybiBlbXB0eVJlc3VsdDtcbiAgfVxuXG4gIGdldEJlZ2lubmluZ0NvbXBsZXRpb25JdGVtcyA9IChjb250ZXh0PzogVHlwZWFoZWFkQ29udGV4dCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Z2dlc3Rpb25zOiBbLi4udGhpcy5nZXRFbXB0eUNvbXBsZXRpb25JdGVtcyhjb250ZXh0KS5zdWdnZXN0aW9ucywgLi4udGhpcy5nZXRUZXJtQ29tcGxldGlvbkl0ZW1zKCkuc3VnZ2VzdGlvbnNdLFxuICAgIH07XG4gIH07XG5cbiAgZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMoY29udGV4dD86IFR5cGVhaGVhZENvbnRleHQpOiBUeXBlYWhlYWRPdXRwdXQge1xuICAgIGNvbnN0IGhpc3RvcnkgPSBjb250ZXh0Py5oaXN0b3J5O1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gW107XG5cbiAgICBpZiAoaGlzdG9yeT8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoaXN0b3J5SXRlbXMgPSBjaGFpbihoaXN0b3J5KVxuICAgICAgICAubWFwKChoKSA9PiBoLnF1ZXJ5LmV4cHIpXG4gICAgICAgIC5maWx0ZXIoKVxuICAgICAgICAudW5pcSgpXG4gICAgICAgIC50YWtlKEhJU1RPUllfSVRFTV9DT1VOVClcbiAgICAgICAgLm1hcCh3cmFwTGFiZWwpXG4gICAgICAgIC5tYXAoKGl0ZW0pID0+IGFkZEhpc3RvcnlNZXRhZGF0YShpdGVtLCBoaXN0b3J5KSlcbiAgICAgICAgLnZhbHVlKCk7XG5cbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICBwcmVmaXhNYXRjaDogdHJ1ZSxcbiAgICAgICAgc2tpcFNvcnQ6IHRydWUsXG4gICAgICAgIGxhYmVsOiAnSGlzdG9yeScsXG4gICAgICAgIGl0ZW1zOiBoaXN0b3J5SXRlbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICB9XG5cbiAgZ2V0VGVybUNvbXBsZXRpb25JdGVtcyA9ICgpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gW107XG5cbiAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgIHByZWZpeE1hdGNoOiB0cnVlLFxuICAgICAgbGFiZWw6ICdGdW5jdGlvbnMnLFxuICAgICAgaXRlbXM6IEZVTkNUSU9OUy5tYXAoKHN1Z2dlc3Rpb24pID0+ICh7IC4uLnN1Z2dlc3Rpb24sIGtpbmQ6ICdmdW5jdGlvbicgfSkpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBnZXRQaXBlQ29tcGxldGlvbkl0ZW0gPSAoKTogVHlwZWFoZWFkT3V0cHV0ID0+IHtcbiAgICBjb25zdCBzdWdnZXN0aW9ucyA9IFtdO1xuXG4gICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICBsYWJlbDogJ09wZXJhdG9ycycsXG4gICAgICBpdGVtczogUElQRV9PUEVSQVRPUlMubWFwKChzdWdnZXN0aW9uKSA9PiAoeyAuLi5zdWdnZXN0aW9uLCBraW5kOiAnb3BlcmF0b3JzJyB9KSksXG4gICAgfSk7XG5cbiAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgIGxhYmVsOiAnUGFyc2VycycsXG4gICAgICBpdGVtczogUElQRV9QQVJTRVJTLm1hcCgoc3VnZ2VzdGlvbikgPT4gKHsgLi4uc3VnZ2VzdGlvbiwga2luZDogJ3BhcnNlcnMnIH0pKSxcbiAgICB9KTtcblxuICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gIH07XG5cbiAgZ2V0UmFuZ2VDb21wbGV0aW9uSXRlbXMoKTogVHlwZWFoZWFkT3V0cHV0IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dDogJ2NvbnRleHQtcmFuZ2UnLFxuICAgICAgc3VnZ2VzdGlvbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiAnUmFuZ2UgdmVjdG9yJyxcbiAgICAgICAgICBpdGVtczogWy4uLlJBVEVfUkFOR0VTXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldExhYmVsQ29tcGxldGlvbkl0ZW1zKHsgdGV4dCwgd3JhcHBlckNsYXNzZXMsIGxhYmVsS2V5LCB2YWx1ZSB9OiBUeXBlYWhlYWRJbnB1dCk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiB7XG4gICAgbGV0IGNvbnRleHQgPSAnY29udGV4dC1sYWJlbHMnO1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4geyBjb250ZXh0LCBzdWdnZXN0aW9uczogW10gfTtcbiAgICB9XG4gICAgY29uc3QgbGluZSA9IHZhbHVlLmFuY2hvckJsb2NrLmdldFRleHQoKTtcbiAgICBjb25zdCBjdXJzb3JPZmZzZXQgPSB2YWx1ZS5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBpc1ZhbHVlU3RhcnQgPSB0ZXh0Lm1hdGNoKC9eKD18PX58IT18IX4pLyk7XG5cbiAgICAvLyBHZXQgbm9ybWFsaXplZCBzZWxlY3RvclxuICAgIGxldCBzZWxlY3RvcjtcbiAgICBsZXQgcGFyc2VkU2VsZWN0b3I7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihsaW5lLCBjdXJzb3JPZmZzZXQpO1xuICAgICAgc2VsZWN0b3IgPSBwYXJzZWRTZWxlY3Rvci5zZWxlY3RvcjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHNlbGVjdG9yID0gRU1QVFlfU0VMRUNUT1I7XG4gICAgfVxuXG4gICAgaWYgKCFsYWJlbEtleSAmJiBzZWxlY3RvciA9PT0gRU1QVFlfU0VMRUNUT1IpIHtcbiAgICAgIC8vIHN0YXJ0IHRhc2sgZ2V0cyBhbGwgbGFiZWxzXG4gICAgICBhd2FpdCB0aGlzLnN0YXJ0KCk7XG4gICAgICBjb25zdCBhbGxMYWJlbHMgPSB0aGlzLmdldExhYmVsS2V5cygpO1xuICAgICAgcmV0dXJuIHsgY29udGV4dCwgc3VnZ2VzdGlvbnM6IFt7IGxhYmVsOiBgTGFiZWxzYCwgaXRlbXM6IGFsbExhYmVscy5tYXAod3JhcExhYmVsKSB9XSB9O1xuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHBhcnNlZFNlbGVjdG9yID8gcGFyc2VkU2VsZWN0b3IubGFiZWxLZXlzIDogW107XG5cbiAgICBsZXQgbGFiZWxWYWx1ZXM7XG4gICAgLy8gUXVlcnkgbGFiZWxzIGZvciBzZWxlY3RvclxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUiAmJiBsYWJlbEtleSkge1xuICAgICAgICBjb25zdCBsYWJlbFZhbHVlc0ZvcktleSA9IGF3YWl0IHRoaXMuZ2V0TGFiZWxWYWx1ZXMobGFiZWxLZXkpO1xuICAgICAgICBsYWJlbFZhbHVlcyA9IHsgW2xhYmVsS2V5XTogbGFiZWxWYWx1ZXNGb3JLZXkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsVmFsdWVzID0gYXdhaXQgdGhpcy5nZXRTZXJpZXNMYWJlbHMoc2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbGFiZWxWYWx1ZXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihgU2VydmVyIGRpZCBub3QgcmV0dXJuIGFueSB2YWx1ZXMgZm9yIHNlbGVjdG9yID0gJHtzZWxlY3Rvcn1gKTtcbiAgICAgIHJldHVybiB7IGNvbnRleHQsIHN1Z2dlc3Rpb25zIH07XG4gICAgfVxuXG4gICAgaWYgKCh0ZXh0ICYmIGlzVmFsdWVTdGFydCkgfHwgd3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2F0dHItdmFsdWUnKSkge1xuICAgICAgLy8gTGFiZWwgdmFsdWVzXG4gICAgICBpZiAobGFiZWxLZXkgJiYgbGFiZWxWYWx1ZXNbbGFiZWxLZXldKSB7XG4gICAgICAgIGNvbnRleHQgPSAnY29udGV4dC1sYWJlbC12YWx1ZXMnO1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBsYWJlbDogYExhYmVsIHZhbHVlcyBmb3IgXCIke2xhYmVsS2V5fVwiYCxcbiAgICAgICAgICAvLyBGaWx0ZXIgdG8gcHJldmVudCBwcmV2aW91c2x5IHNlbGVjdGVkIHZhbHVlcyBmcm9tIGJlaW5nIHJlcGVhdGVkbHkgc3VnZ2VzdGVkXG4gICAgICAgICAgaXRlbXM6IGxhYmVsVmFsdWVzW2xhYmVsS2V5XS5tYXAod3JhcExhYmVsKS5maWx0ZXIoKHsgZmlsdGVyVGV4dCB9KSA9PiBmaWx0ZXJUZXh0ICE9PSB0ZXh0KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExhYmVsIGtleXNcbiAgICAgIGNvbnN0IGxhYmVsS2V5cyA9IGxhYmVsVmFsdWVzID8gT2JqZWN0LmtleXMobGFiZWxWYWx1ZXMpIDogREVGQVVMVF9LRVlTO1xuICAgICAgaWYgKGxhYmVsS2V5cykge1xuICAgICAgICBjb25zdCBwb3NzaWJsZUtleXMgPSBkaWZmZXJlbmNlKGxhYmVsS2V5cywgZXhpc3RpbmdLZXlzKTtcbiAgICAgICAgaWYgKHBvc3NpYmxlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBuZXdJdGVtcyA9IHBvc3NpYmxlS2V5cy5tYXAoKGtleSkgPT4gKHsgbGFiZWw6IGtleSB9KSk7XG4gICAgICAgICAgY29uc3QgbmV3U3VnZ2VzdGlvbjogQ29tcGxldGlvbkl0ZW1Hcm91cCA9IHsgbGFiZWw6IGBMYWJlbHNgLCBpdGVtczogbmV3SXRlbXMgfTtcbiAgICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKG5ld1N1Z2dlc3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29udGV4dCwgc3VnZ2VzdGlvbnMgfTtcbiAgfVxuXG4gIGltcG9ydEZyb21BYnN0cmFjdFF1ZXJ5KGxhYmVsQmFzZWRRdWVyeTogQWJzdHJhY3RRdWVyeSk6IExva2lRdWVyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkOiBsYWJlbEJhc2VkUXVlcnkucmVmSWQsXG4gICAgICBleHByOiB0b1Byb21MaWtlRXhwcihsYWJlbEJhc2VkUXVlcnkpLFxuICAgICAgcXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlLlJhbmdlLFxuICAgIH07XG4gIH1cblxuICBleHBvcnRUb0Fic3RyYWN0UXVlcnkocXVlcnk6IExva2lRdWVyeSk6IEFic3RyYWN0UXVlcnkge1xuICAgIGNvbnN0IGxva2lRdWVyeSA9IHF1ZXJ5LmV4cHI7XG4gICAgaWYgKCFsb2tpUXVlcnkgfHwgbG9raVF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgcmVmSWQ6IHF1ZXJ5LnJlZklkLCBsYWJlbE1hdGNoZXJzOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShsb2tpUXVlcnksIHN5bnRheCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkOiBxdWVyeS5yZWZJZCxcbiAgICAgIGxhYmVsTWF0Y2hlcnM6IGV4dHJhY3RMYWJlbE1hdGNoZXJzKHRva2VucyksXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFNlcmllc0xhYmVscyhzZWxlY3Rvcjogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMubG9va3Vwc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hTZXJpZXNMYWJlbHMoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgbGFiZWwga2V5c1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hMYWJlbHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHVybCA9ICcvbG9raS9hcGkvdjEvbGFiZWwnO1xuICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICB0aGlzLmxhYmVsRmV0Y2hUcyA9IERhdGUubm93KCkudmFsdWVPZigpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgdGltZVJhbmdlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSByZXNcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAuZmlsdGVyKChsYWJlbCkgPT4gbGFiZWwgIT09ICdfX25hbWVfXycpO1xuICAgICAgdGhpcy5sYWJlbEtleXMgPSBsYWJlbHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXN5bmMgcmVmcmVzaExvZ0xhYmVscyhmb3JjZVJlZnJlc2g/OiBib29sZWFuKSB7XG4gICAgaWYgKCh0aGlzLmxhYmVsS2V5cyAmJiBEYXRlLm5vdygpLnZhbHVlT2YoKSAtIHRoaXMubGFiZWxGZXRjaFRzID4gTEFCRUxfUkVGUkVTSF9JTlRFUlZBTCkgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgICBhd2FpdCB0aGlzLmZldGNoTGFiZWxzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxhYmVscyBmb3IgYSBzZWxlY3Rvci4gVGhpcyBpcyBjYWNoZWQgYnkgaXQncyBhcmdzIGJ1dCBhbHNvIGJ5IHRoZSBnbG9iYWwgdGltZVJhbmdlIGN1cnJlbnRseSBzZWxlY3RlZCBhc1xuICAgKiB0aGV5IGNhbiBjaGFuZ2Ugb3ZlciByZXF1ZXN0ZWQgdGltZS5cbiAgICogQHBhcmFtIG5hbWVcbiAgICovXG4gIGZldGNoU2VyaWVzTGFiZWxzID0gYXN5bmMgKG1hdGNoOiBzdHJpbmcpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4gPT4ge1xuICAgIGNvbnN0IGludGVycG9sYXRlZE1hdGNoID0gdGhpcy5kYXRhc291cmNlLmludGVycG9sYXRlU3RyaW5nKG1hdGNoKTtcbiAgICBjb25zdCB1cmwgPSAnL2xva2kvYXBpL3YxL3Nlcmllcyc7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2VuZXJhdGVDYWNoZUtleSh1cmwsIHN0YXJ0LCBlbmQsIGludGVycG9sYXRlZE1hdGNoKTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnNlcmllc0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgLy8gQ2xlYXIgdmFsdWUgd2hlbiByZXF1ZXN0aW5nIG5ldyBvbmUuIEVtcHR5IG9iamVjdCBiZWluZyB0cnV0aHkgYWxzbyBtYWtlcyBzdXJlIHdlIGRvbid0IHJlcXVlc3QgdHdpY2UuXG4gICAgICB0aGlzLnNlcmllc0NhY2hlLnNldChjYWNoZUtleSwge30pO1xuICAgICAgY29uc3QgcGFyYW1zID0geyAnbWF0Y2hbXSc6IGludGVycG9sYXRlZE1hdGNoLCBzdGFydCwgZW5kIH07XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICAgIGNvbnN0IHsgdmFsdWVzIH0gPSBwcm9jZXNzTGFiZWxzKGRhdGEpO1xuICAgICAgdmFsdWUgPSB2YWx1ZXM7XG4gICAgICB0aGlzLnNlcmllc0NhY2hlLnNldChjYWNoZUtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoIHNlcmllcyBmb3IgYSBzZWxlY3Rvci4gVXNlIHRoaXMgZm9yIHJhdyByZXN1bHRzLiBVc2UgZmV0Y2hTZXJpZXNMYWJlbHMoKSB0byBnZXQgbGFiZWxzLlxuICAgKiBAcGFyYW0gbWF0Y2hcbiAgICovXG4gIGZldGNoU2VyaWVzID0gYXN5bmMgKG1hdGNoOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PFJlY29yZDxzdHJpbmcsIHN0cmluZz4+PiA9PiB7XG4gICAgY29uc3QgdXJsID0gJy9sb2tpL2FwaS92MS9zZXJpZXMnO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgJ21hdGNoW10nOiBtYXRjaCwgc3RhcnQsIGVuZCB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCBwYXJhbXMpO1xuICB9O1xuXG4gIC8vIENhY2hlIGtleSBpcyBhIGJpdCBkaWZmZXJlbnQgaGVyZS4gV2Ugcm91bmQgdXAgdG8gYSBtaW51dGUgdGhlIGludGVydmFscy5cbiAgLy8gVGhlIHJvdW5kaW5nIG1heSBzZWVtIHN0cmFuZ2UgYnV0IG1ha2VzIHJlbGF0aXZlIGludGVydmFscyBsaWtlIG5vdy0xaCBsZXNzIHByb25lIHRvIG5lZWQgc2VwYXJhdGUgcmVxdWVzdCBldmVyeVxuICAvLyBtaWxsaXNlY29uZCB3aGlsZSBzdGlsbCBhY3R1YWxseSBnZXR0aW5nIGFsbCB0aGUga2V5cyBmb3IgdGhlIGNvcnJlY3QgaW50ZXJ2YWwuIFRoaXMgc3RpbGwgY2FuIGNyZWF0ZSBwcm9ibGVtc1xuICAvLyB3aGVuIHVzZXIgZG9lcyBub3QgdGhlIG5ld2VzdCB2YWx1ZXMgZm9yIGEgbWludXRlIGlmIGFscmVhZHkgY2FjaGVkLlxuICBnZW5lcmF0ZUNhY2hlS2V5KHVybDogc3RyaW5nLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgcGFyYW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFt1cmwsIHRoaXMucm91bmRUaW1lKHN0YXJ0KSwgdGhpcy5yb3VuZFRpbWUoZW5kKSwgcGFyYW1dLmpvaW4oKTtcbiAgfVxuXG4gIC8vIFJvdW5kIG5hbm9zIGVwb2NoIHRvIG5lYXJlc3QgNSBtaW51dGUgaW50ZXJ2YWxcbiAgcm91bmRUaW1lKG5hbm9zOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBuYW5vcyA/IE1hdGguZmxvb3IobmFub3MgLyBOU19JTl9NUyAvIDEwMDAgLyA2MCAvIDUpIDogMDtcbiAgfVxuXG4gIGFzeW5jIGdldExhYmVsVmFsdWVzKGtleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoa2V5KTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoTGFiZWxWYWx1ZXMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkS2V5ID0gdGhpcy5kYXRhc291cmNlLmludGVycG9sYXRlU3RyaW5nKGtleSk7XG4gICAgY29uc3QgdXJsID0gYC9sb2tpL2FwaS92MS9sYWJlbC8ke2ludGVycG9sYXRlZEtleX0vdmFsdWVzYDtcbiAgICBjb25zdCByYW5nZVBhcmFtcyA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlUGFyYW1zO1xuXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdlbmVyYXRlQ2FjaGVLZXkodXJsLCBzdGFydCwgZW5kLCBpbnRlcnBvbGF0ZWRLZXkpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgc3RhcnQsIGVuZCB9O1xuXG4gICAgbGV0IGxhYmVsVmFsdWVzID0gdGhpcy5sYWJlbHNDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghbGFiZWxWYWx1ZXMpIHtcbiAgICAgIC8vIENsZWFyIHZhbHVlIHdoZW4gcmVxdWVzdGluZyBuZXcgb25lLiBFbXB0eSBvYmplY3QgYmVpbmcgdHJ1dGh5IGFsc28gbWFrZXMgc3VyZSB3ZSBkb24ndCByZXF1ZXN0IHR3aWNlLlxuICAgICAgdGhpcy5sYWJlbHNDYWNoZS5zZXQoY2FjaGVLZXksIFtdKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICAgIGxhYmVsVmFsdWVzID0gcmVzLnNsaWNlKCkuc29ydCgpO1xuICAgICAgICB0aGlzLmxhYmVsc0NhY2hlLnNldChjYWNoZUtleSwgbGFiZWxWYWx1ZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFZhbHVlcyA/PyBbXTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgVGltZVJhbmdlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmZ1bmN0aW9uIHJvdW5kTXNUb01pbihtaWxsaXNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiByb3VuZFNlY1RvTWluKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiByb3VuZFNlY1RvTWluKHNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRSZWZyZXNoTGFiZWxzKHJhbmdlPzogVGltZVJhbmdlLCBwcmV2UmFuZ2U/OiBUaW1lUmFuZ2UpOiBib29sZWFuIHtcbiAgaWYgKHJhbmdlICYmIHByZXZSYW5nZSkge1xuICAgIGNvbnN0IHNhbWVNaW51dGVGcm9tID0gcm91bmRNc1RvTWluKHJhbmdlLmZyb20udmFsdWVPZigpKSA9PT0gcm91bmRNc1RvTWluKHByZXZSYW5nZS5mcm9tLnZhbHVlT2YoKSk7XG4gICAgY29uc3Qgc2FtZU1pbnV0ZVRvID0gcm91bmRNc1RvTWluKHJhbmdlLnRvLnZhbHVlT2YoKSkgPT09IHJvdW5kTXNUb01pbihwcmV2UmFuZ2UudG8udmFsdWVPZigpKTtcbiAgICAvLyBJZiBib3RoIGFyZSBzYW1lLCBkb24ndCBuZWVkIHRvIHJlZnJlc2hcbiAgICByZXR1cm4gIShzYW1lTWludXRlRnJvbSAmJiBzYW1lTWludXRlVG8pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IERhdGFGcmFtZSwgRmllbGRUeXBlLCBwYXJzZUxhYmVscywgS2V5VmFsdWUsIENpcmN1bGFyRGF0YUZyYW1lIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCB0aHJvd0Vycm9yLCB0aW1lciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgd2ViU29ja2V0IH0gZnJvbSAncnhqcy93ZWJTb2NrZXQnO1xuaW1wb3J0IHsgTG9raVRhaWxSZXNwb25zZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZmluYWxpemUsIG1hcCwgcmV0cnlXaGVuLCBtZXJnZU1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGFwcGVuZFJlc3BvbnNlVG9CdWZmZXJlZERhdGEgfSBmcm9tICcuL3Jlc3VsdF90cmFuc2Zvcm1lcic7XG5cbi8qKlxuICogTWFwcyBkaXJlY3RseSB0byBhIHF1ZXJ5IGluIHRoZSBVSSAocmVmSWQgaXMga2V5KVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExva2lMaXZlVGFyZ2V0IHtcbiAgcXVlcnk6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIHJlZklkOiBzdHJpbmc7XG4gIHNpemU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDYWNoZSBvZiB3ZWJzb2NrZXQgc3RyZWFtcyB0aGF0IGNhbiBiZSByZXR1cm5lZCBhcyBvYnNlcnZhYmxlLiBJbiBjYXNlIHRoZXJlIGFscmVhZHkgaXMgYSBzdHJlYW0gZm9yIHBhcnRpY3VsYXJcbiAqIHRhcmdldCBpdCBpcyByZXR1cm5lZCBhbmQgb24gc3Vic2NyaXB0aW9uIHJldHVybnMgdGhlIGxhdGVzdCBkYXRhRnJhbWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBMaXZlU3RyZWFtcyB7XG4gIHByaXZhdGUgc3RyZWFtczogS2V5VmFsdWU8T2JzZXJ2YWJsZTxEYXRhRnJhbWVbXT4+ID0ge307XG5cbiAgZ2V0U3RyZWFtKHRhcmdldDogTG9raUxpdmVUYXJnZXQsIHJldHJ5SW50ZXJ2YWwgPSA1MDAwKTogT2JzZXJ2YWJsZTxEYXRhRnJhbWVbXT4ge1xuICAgIGxldCBzdHJlYW0gPSB0aGlzLnN0cmVhbXNbdGFyZ2V0LnVybF07XG5cbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBuZXcgQ2lyY3VsYXJEYXRhRnJhbWUoeyBjYXBhY2l0eTogdGFyZ2V0LnNpemUgfSk7XG4gICAgZGF0YS5hZGRGaWVsZCh7IG5hbWU6ICd0cycsIHR5cGU6IEZpZWxkVHlwZS50aW1lLCBjb25maWc6IHsgZGlzcGxheU5hbWU6ICdUaW1lJyB9IH0pO1xuICAgIGRhdGEuYWRkRmllbGQoeyBuYW1lOiAndHNOcycsIHR5cGU6IEZpZWxkVHlwZS50aW1lLCBjb25maWc6IHsgZGlzcGxheU5hbWU6ICdUaW1lIG5zJyB9IH0pO1xuICAgIGRhdGEuYWRkRmllbGQoeyBuYW1lOiAnbGluZScsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcgfSkubGFiZWxzID0gcGFyc2VMYWJlbHModGFyZ2V0LnF1ZXJ5KTtcbiAgICBkYXRhLmFkZEZpZWxkKHsgbmFtZTogJ2xhYmVscycsIHR5cGU6IEZpZWxkVHlwZS5vdGhlciB9KTsgLy8gVGhlIGxhYmVscyBmb3IgZWFjaCBsaW5lXG4gICAgZGF0YS5hZGRGaWVsZCh7IG5hbWU6ICdpZCcsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcgfSk7XG4gICAgZGF0YS5tZXRhID0geyAuLi5kYXRhLm1ldGEsIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAnbG9ncycgfTtcbiAgICBkYXRhLnJlZklkID0gdGFyZ2V0LnJlZklkO1xuXG4gICAgc3RyZWFtID0gd2ViU29ja2V0PExva2lUYWlsUmVzcG9uc2U+KHRhcmdldC51cmwpLnBpcGUoXG4gICAgICBtYXAoKHJlc3BvbnNlOiBMb2tpVGFpbFJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGFwcGVuZFJlc3BvbnNlVG9CdWZmZXJlZERhdGEocmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICByZXR1cm4gW2RhdGFdO1xuICAgICAgfSksXG4gICAgICByZXRyeVdoZW4oKGF0dGVtcHRzOiBPYnNlcnZhYmxlPGFueT4pID0+XG4gICAgICAgIGF0dGVtcHRzLnBpcGUoXG4gICAgICAgICAgbWVyZ2VNYXAoKGVycm9yLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXRyeUF0dGVtcHQgPSBpICsgMTtcbiAgICAgICAgICAgIC8vIENvZGUgMTAwNiBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgYSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWJub3JtYWxseS5cbiAgICAgICAgICAgIC8vIEFkZGVkIGhhcmQgbGltaXQgb2YgMzAgb24gbnVtYmVyIG9mIHJldHJpZXMuXG4gICAgICAgICAgICAvLyBJZiBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWJub3JtYWxseSwgYW5kIHdlIHdpc2ggdG8gcmV0cnksIG90aGVyd2lzZSB0aHJvdyBlcnJvci5cbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAxMDA2ICYmIHJldHJ5QXR0ZW1wdCA8IDMwKSB7XG4gICAgICAgICAgICAgIGlmIChyZXRyeUF0dGVtcHQgPiAxMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG1vcmUgdGhhbiAxMCB0aW1lcyByZXRyaWVkLCBjb25zb2wud2FybiwgYnV0IGtlZXAgcmVjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgYFdlYnNvY2tldCBjb25uZWN0aW9uIGlzIGJlaW5nIGRpc3J1cHRlZC4gV2Uga2VlcCByZWNvbm5lY3RpbmcgYnV0IGNvbnNpZGVyIHN0YXJ0aW5nIG5ldyBsaXZlIHRhaWxpbmcgYWdhaW4uIEVycm9yOiAke2Vycm9yLnJlYXNvbn1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBSZXRyeSBldmVyeSA1c1xuICAgICAgICAgICAgICByZXR1cm4gdGltZXIocmV0cnlJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGZpbmFsaXplKCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtc1t0YXJnZXQudXJsXTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN0cmVhbXNbdGFyZ2V0LnVybF0gPSBzdHJlYW07XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG59XG4iLCJpbXBvcnQgeyB2NSBhcyB1dWlkdjUgfSBmcm9tICd1dWlkJztcblxuaW1wb3J0IHsgQXJyYXlWZWN0b3IsIERhdGFGcmFtZSwgRmllbGQsIEZpZWxkVHlwZSwgTGFiZWxzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmNvbnN0IFVVSURfTkFNRVNQQUNFID0gJzZlYzk0NmRhLTBmNDktNDdhOC05ODNhLTFkNzZkMTdlN2M5Mic7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVpZCh0ZXh0OiBzdHJpbmcsIHVzZWRVaWRzOiBNYXA8c3RyaW5nLCBudW1iZXI+LCByZWZJZD86IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGlkID0gdXVpZHY1KHRleHQsIFVVSURfTkFNRVNQQUNFKTtcblxuICAvLyBjaGVjayBob3cgbWFueSB0aW1lcyBoYXZlIHdlIHNlZW4gdGhpcyBpZCBiZWZvcmUsXG4gIC8vIHNldCB0aGUgY291bnQgdG8gemVybywgaWYgbmV2ZXIuXG4gIGNvbnN0IGNvdW50ID0gdXNlZFVpZHMuZ2V0KGlkKSA/PyAwO1xuXG4gIC8vIGlmIHdlIGhhdmUgc2VlbiB0aGlzIGlkIGJlZm9yZSwgd2UgbmVlZCB0byBtYWtlXG4gIC8vIGl0IHVuaXF1ZSBieSBhcHBlbmRpbmcgdGhlIHNlZW4tY291bnRcbiAgLy8gKHN0YXJ0cyB3aXRoIDEsIGFuZCBnb2VzIHVwKVxuICBjb25zdCB1bmlxdWVJZCA9IGNvdW50ID4gMCA/IGAke2lkfV8ke2NvdW50fWAgOiBpZDtcblxuICAvLyB3ZSBpbmNyZW1lbnQgdGhlIGNvdW50ZXIgZm9yIHRoaXMgaWQsIHRvIGJlIHVzZWQgd2hlbiB3ZSBhcmUgY2FsbGVkIHRoZSBuZXh0IHRpbWVcbiAgdXNlZFVpZHMuc2V0KGlkLCBjb3VudCArIDEpO1xuXG4gIC8vIHdlIGFkZCByZWZJZCB0byB0aGUgZW5kLCBpZiBpdCBpcyBhdmFpbGFibGVcbiAgcmV0dXJuIHJlZklkICE9PSB1bmRlZmluZWQgPyBgJHt1bmlxdWVJZH1fJHtyZWZJZH1gIDogdW5pcXVlSWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSWRGaWVsZChmcmFtZTogRGF0YUZyYW1lKTogRmllbGQge1xuICBjb25zdCBhbGxMYWJlbHM6IExhYmVscyA9IHt9O1xuXG4gIC8vIGNvbGxlY3QgbGFiZWxzIGZyb20gZXZlcnkgZmllbGRcbiAgZnJhbWUuZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihhbGxMYWJlbHMsIGZpZWxkLmxhYmVscyk7XG4gIH0pO1xuXG4gIGNvbnN0IGxhYmVsc1N0cmluZyA9IE9iamVjdC5lbnRyaWVzKGFsbExhYmVscylcbiAgICAubWFwKChba2V5LCB2YWxdKSA9PiBgJHtrZXl9PVwiJHt2YWx9XCJgKVxuICAgIC5zb3J0KClcbiAgICAuam9pbignJyk7XG5cbiAgY29uc3QgdXNlZFVpZHMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBmcmFtZTtcblxuICBjb25zdCB1aWRzOiBzdHJpbmdbXSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gIC8vIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgZGF0YWZyYW1lIFwicm93IGJ5IHJvd1wiXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBmcmFtZS5maWVsZHMubWFwKChmKSA9PiBTdHJpbmcoZi52YWx1ZXMuZ2V0KGkpKSk7XG4gICAgY29uc3QgdGV4dCA9IGAke2xhYmVsc1N0cmluZ31fJHtyb3cuam9pbignXycpfWA7XG4gICAgY29uc3QgdWlkID0gY3JlYXRlVWlkKHRleHQsIHVzZWRVaWRzLCBmcmFtZS5yZWZJZCk7XG4gICAgdWlkc1tpXSA9IHVpZDtcbiAgfVxuXG4gIHJldHVybiB7IG5hbWU6ICdpZCcsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsIGNvbmZpZzoge30sIHZhbHVlczogbmV3IEFycmF5VmVjdG9yKHVpZHMpIH07XG59XG4iLCJpbXBvcnQgeyBEYXRhRnJhbWUsIEZpZWxkLCBGaWVsZFR5cGUsIEFycmF5VmVjdG9yIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBncm91cEJ5IH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VUYWJsZUZyYW1lcyhpbnN0YW50TWV0cmljRnJhbWVzOiBEYXRhRnJhbWVbXSk6IERhdGFGcmFtZVtdIHtcbiAgLy8gZmlyc3Qgd2UgcmVtb3ZlIGZyYW1lcyB0aGF0IGhhdmUgbm8gcmVmSWRcbiAgLy8gKHdlIHdpbGwgZ3JvdXAgdGhlbSBieSByZWZJZCwgc28gd2UgbmVlZCBpdCB0byBiZSBzZXQpXG4gIGNvbnN0IGZyYW1lc1dpdGhSZWZJZCA9IGluc3RhbnRNZXRyaWNGcmFtZXMuZmlsdGVyKChmKSA9PiBmLnJlZklkICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IGZyYW1lc0J5UmVmSWQgPSBncm91cEJ5KGZyYW1lc1dpdGhSZWZJZCwgKGZyYW1lKSA9PiBmcmFtZS5yZWZJZCk7XG5cbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGZyYW1lc0J5UmVmSWQpLm1hcCgoW3JlZklkLCBmcmFtZXNdKSA9PiBtYWtlVGFibGVGcmFtZShmcmFtZXMsIHJlZklkKSk7XG59XG5cbnR5cGUgTnVtYmVyRmllbGQgPSBGaWVsZDxudW1iZXIsIEFycmF5VmVjdG9yPG51bWJlcj4+O1xudHlwZSBTdHJpbmdGaWVsZCA9IEZpZWxkPHN0cmluZywgQXJyYXlWZWN0b3I8c3RyaW5nPj47XG5cbmZ1bmN0aW9uIG1ha2VUYWJsZUZyYW1lKGluc3RhbnRNZXRyaWNGcmFtZXM6IERhdGFGcmFtZVtdLCByZWZJZDogc3RyaW5nKTogRGF0YUZyYW1lIHtcbiAgY29uc3QgdGFibGVUaW1lRmllbGQ6IE51bWJlckZpZWxkID0geyBuYW1lOiAnVGltZScsIGNvbmZpZzoge30sIHZhbHVlczogbmV3IEFycmF5VmVjdG9yKCksIHR5cGU6IEZpZWxkVHlwZS50aW1lIH07XG4gIGNvbnN0IHRhYmxlVmFsdWVGaWVsZDogTnVtYmVyRmllbGQgPSB7XG4gICAgbmFtZTogYFZhbHVlICMke3JlZklkfWAsXG4gICAgY29uZmlnOiB7fSxcbiAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcigpLFxuICAgIHR5cGU6IEZpZWxkVHlwZS5udW1iZXIsXG4gIH07XG5cbiAgLy8gU29ydCBtZXRyaWMgbGFiZWxzLCBjcmVhdGUgY29sdW1ucyBmb3IgdGhlbSBhbmQgcmVjb3JkIHRoZWlyIGluZGV4XG4gIGNvbnN0IGFsbExhYmVsTmFtZXMgPSBuZXcgU2V0KFxuICAgIGluc3RhbnRNZXRyaWNGcmFtZXMubWFwKChmcmFtZSkgPT4gZnJhbWUuZmllbGRzLm1hcCgoZmllbGQpID0+IE9iamVjdC5rZXlzKGZpZWxkLmxhYmVscyA/PyB7fSkpLmZsYXQoKSkuZmxhdCgpXG4gICk7XG5cbiAgY29uc3Qgc29ydGVkTGFiZWxOYW1lcyA9IEFycmF5LmZyb20oYWxsTGFiZWxOYW1lcykuc29ydCgpO1xuXG4gIGNvbnN0IGxhYmVsRmllbGRzOiBTdHJpbmdGaWVsZFtdID0gc29ydGVkTGFiZWxOYW1lcy5tYXAoKGxhYmVsTmFtZSkgPT4gKHtcbiAgICBuYW1lOiBsYWJlbE5hbWUsXG4gICAgY29uZmlnOiB7IGZpbHRlcmFibGU6IHRydWUgfSxcbiAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcigpLFxuICAgIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsXG4gIH0pKTtcblxuICBpbnN0YW50TWV0cmljRnJhbWVzLmZvckVhY2goKGZyYW1lKSA9PiB7XG4gICAgY29uc3QgdGltZUZpZWxkID0gZnJhbWUuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09PSBGaWVsZFR5cGUudGltZSk7XG4gICAgY29uc3QgdmFsdWVGaWVsZCA9IGZyYW1lLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLm51bWJlcik7XG4gICAgaWYgKHRpbWVGaWVsZCA9PSBudWxsIHx8IHZhbHVlRmllbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVBcnJheSA9IHRpbWVGaWVsZC52YWx1ZXMudG9BcnJheSgpO1xuICAgIGNvbnN0IHZhbHVlQXJyYXkgPSB2YWx1ZUZpZWxkLnZhbHVlcy50b0FycmF5KCk7XG5cbiAgICBmb3IgKGxldCB4IG9mIHRpbWVBcnJheSkge1xuICAgICAgdGFibGVUaW1lRmllbGQudmFsdWVzLmFkZCh4KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB4IG9mIHZhbHVlQXJyYXkpIHtcbiAgICAgIHRhYmxlVmFsdWVGaWVsZC52YWx1ZXMuYWRkKHgpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVscyA9IHZhbHVlRmllbGQubGFiZWxzID8/IHt9O1xuXG4gICAgZm9yIChsZXQgZiBvZiBsYWJlbEZpZWxkcykge1xuICAgICAgY29uc3QgdGV4dCA9IGxhYmVsc1tmLm5hbWVdID8/ICcnO1xuICAgICAgLy8gd2UgaW5zZXJ0IHRoZSBsYWJlbHMgYXMgbWFueSB0aW1lcyBhcyB3ZSBoYXZlIHZhbHVlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGYudmFsdWVzLmFkZCh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgZmllbGRzOiBbdGFibGVUaW1lRmllbGQsIC4uLmxhYmVsRmllbGRzLCB0YWJsZVZhbHVlRmllbGRdLFxuICAgIHJlZklkLFxuICAgIG1ldGE6IHsgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICd0YWJsZScgfSxcbiAgICBsZW5ndGg6IHRhYmxlVGltZUZpZWxkLnZhbHVlcy5sZW5ndGgsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBEYXRhU291cmNlUGx1Z2luIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBMb2tpRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5cbmltcG9ydCBMb2tpQ2hlYXRTaGVldCBmcm9tICcuL2NvbXBvbmVudHMvTG9raUNoZWF0U2hlZXQnO1xuaW1wb3J0IExva2lRdWVyeUVkaXRvckJ5QXBwIGZyb20gJy4vY29tcG9uZW50cy9Mb2tpUXVlcnlFZGl0b3JCeUFwcCc7XG5pbXBvcnQgeyBMb2tpQW5ub3RhdGlvbnNRdWVyeUN0cmwgfSBmcm9tICcuL0xva2lBbm5vdGF0aW9uc1F1ZXJ5Q3RybCc7XG5pbXBvcnQgeyBDb25maWdFZGl0b3IgfSBmcm9tICcuL2NvbmZpZ3VyYXRpb24vQ29uZmlnRWRpdG9yJztcblxuZXhwb3J0IGNvbnN0IHBsdWdpbiA9IG5ldyBEYXRhU291cmNlUGx1Z2luKExva2lEYXRhc291cmNlKVxuICAuc2V0UXVlcnlFZGl0b3IoTG9raVF1ZXJ5RWRpdG9yQnlBcHApXG4gIC5zZXRDb25maWdFZGl0b3IoQ29uZmlnRWRpdG9yKVxuICAuc2V0UXVlcnlFZGl0b3JIZWxwKExva2lDaGVhdFNoZWV0KVxuICAuc2V0QW5ub3RhdGlvblF1ZXJ5Q3RybChMb2tpQW5ub3RhdGlvbnNRdWVyeUN0cmwpO1xuIiwiaW1wb3J0IHsgZXNjYXBlUmVnRXhwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFBJUEVfUEFSU0VSUyB9IGZyb20gJy4vc3ludGF4JztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raVF1ZXJ5VHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UXVlcnkoc2VsZWN0b3I6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtzZWxlY3RvciB8fCAnJ31gLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHNlYXJjaCB0ZXJtcyBmcm9tIGEgTG9nUUwgcXVlcnkuXG4gKiBFLmcuLCBge30gfD0gZm9vIHw9YmFyICE9IGJhemAgcmV0dXJucyBgWydmb28nLCAnYmFyJ11gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZXJFeHByZXNzaW9uc0Zyb21RdWVyeShpbnB1dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBsZXQgZXhwcmVzc2lvbiA9IGlucHV0O1xuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgLy8gQ29uc3VtZSBmaWx0ZXIgZXhwcmVzc2lvbiBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgd2hpbGUgKGV4cHJlc3Npb24pIHtcbiAgICBjb25zdCBmaWx0ZXJTdGFydCA9IGV4cHJlc3Npb24uc2VhcmNoKC9cXHw9fFxcfH58IT18IX4vKTtcbiAgICAvLyBOb3RoaW5nIG1vcmUgdG8gc2VhcmNoXG4gICAgaWYgKGZpbHRlclN0YXJ0ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIERyb3AgdGVybXMgZm9yIG5lZ2F0aXZlIGZpbHRlcnNcbiAgICBjb25zdCBmaWx0ZXJPcGVyYXRvciA9IGV4cHJlc3Npb24uc2xpY2UoZmlsdGVyU3RhcnQsIGZpbHRlclN0YXJ0ICsgMik7XG4gICAgY29uc3Qgc2tpcCA9IGV4cHJlc3Npb24uc2xpY2UoZmlsdGVyU3RhcnQpLnNlYXJjaCgvIT18IX4vKSA9PT0gMDtcbiAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zbGljZShmaWx0ZXJTdGFydCArIDIpO1xuICAgIGlmIChza2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgbW9yZSBjaGFpbmVkXG4gICAgY29uc3QgZmlsdGVyRW5kID0gZXhwcmVzc2lvbi5zZWFyY2goL1xcfD18XFx8fnwhPXwhfi8pO1xuICAgIGxldCBmaWx0ZXJUZXJtO1xuICAgIGlmIChmaWx0ZXJFbmQgPT09IC0xKSB7XG4gICAgICBmaWx0ZXJUZXJtID0gZXhwcmVzc2lvbi50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbHRlclRlcm0gPSBleHByZXNzaW9uLnNsaWNlKDAsIGZpbHRlckVuZCkudHJpbSgpO1xuICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uc2xpY2UoZmlsdGVyRW5kKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdW90ZWRUZXJtID0gZmlsdGVyVGVybS5tYXRjaCgvXCIoLio/KVwiLyk7XG4gICAgY29uc3QgYmFja3RpY2tlZFRlcm0gPSBmaWx0ZXJUZXJtLm1hdGNoKC9gKC4qPylgLyk7XG4gICAgY29uc3QgdGVybSA9IHF1b3RlZFRlcm0gfHwgYmFja3RpY2tlZFRlcm07XG5cbiAgICBpZiAodGVybSkge1xuICAgICAgY29uc3QgdW53cmFwcGVkRmlsdGVyVGVybSA9IHRlcm1bMV07XG4gICAgICBjb25zdCByZWdleE9wZXJhdG9yID0gZmlsdGVyT3BlcmF0b3IgPT09ICd8fic7XG5cbiAgICAgIC8vIE9ubHkgZmlsdGVyIGV4cHJlc3Npb25zIHdpdGggfH4gb3BlcmF0b3IgYXJlIHRyZWF0ZWQgYXMgcmVndWxhciBleHByZXNzaW9uc1xuICAgICAgaWYgKHJlZ2V4T3BlcmF0b3IpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyBiYWNrdGlja3MsIExva2kgZG9lc24ndCByZXF1aXJlIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIHdlIGNhbiBqdXN0IHB1c2ggcmVndWxhciBleHByZXNzaW9uIHRvIGhpZ2hsaWdodHMgYXJyYXlcbiAgICAgICAgLy8gV2hlbiB1c2luZyBxdW90ZXMsIHdlIGhhdmUgZXh0cmEgYmFja3NsYXNoIGVzY2FwaW5nIGFuZCB3ZSBuZWVkIHRvIHJlcGxhY2UgXFxcXCB3aXRoIFxcXG4gICAgICAgIHJlc3VsdHMucHVzaChiYWNrdGlja2VkVGVybSA/IHVud3JhcHBlZEZpbHRlclRlcm0gOiB1bndyYXBwZWRGaWx0ZXJUZXJtLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBlc2NhcGUgdGhpcyBzdHJpbmcgc28gaXQgaXMgbm90IG1hdGNoZWQgYXMgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgIHJlc3VsdHMucHVzaChlc2NhcGVSZWdFeHAodW53cmFwcGVkRmlsdGVyVGVybSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5SGFzUGlwZVBhcnNlcihleHByOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgcGFyc2VycyA9IFBJUEVfUEFSU0VSUy5tYXAoKHBhcnNlcikgPT4gYCR7cGFyc2VyLmxhYmVsfWApLmpvaW4oJ3wnKTtcbiAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChgXFxcXFxcfFxcXFxcXHM/KCR7cGFyc2Vyc30pYCk7XG4gIHJldHVybiByZWdleHAudGVzdChleHByKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBhcnNlZExhYmVsVG9RdWVyeShleHByOiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBvcGVyYXRvcjogc3RyaW5nKSB7XG4gIHJldHVybiBleHByICsgYCB8ICR7a2V5fSR7b3BlcmF0b3J9XCIke3ZhbHVlLnRvU3RyaW5nKCl9XCJgO1xufVxuXG4vLyB3ZSBhcmUgbWlncmF0aW5nIGZyb20gYC5pbnN0YW50YCBhbmQgYC5yYW5nZWAgdG8gYC5xdWVyeVR5cGVgXG4vLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgcXVlcnkgb2JqZWN0IHRoYXQ6XG4vLyAtIGhhcyBgLnF1ZXJ5VHlwZWBcbi8vIC0gZG9lcyBub3QgaGF2ZSBgLmluc3RhbnRgXG4vLyAtIGRvZXMgbm90IGhhdmUgYC5yYW5nZWBcbmV4cG9ydCBmdW5jdGlvbiBnZXROb3JtYWxpemVkTG9raVF1ZXJ5KHF1ZXJ5OiBMb2tpUXVlcnkpOiBMb2tpUXVlcnkge1xuICAvLyBpZiBxdWVyeVR5cGUgZXhpc3RzLCBpdCBpcyByZXNwZWN0ZWRcbiAgaWYgKHF1ZXJ5LnF1ZXJ5VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgeyBpbnN0YW50LCByYW5nZSwgLi4ucmVzdCB9ID0gcXVlcnk7XG4gICAgcmV0dXJuIHJlc3Q7XG4gIH1cblxuICAvLyBpZiBubyBxdWVyeVR5cGUsIGFuZCBpbnN0YW50PT09dHJ1ZSwgaXQncyBpbnN0YW50XG4gIGlmIChxdWVyeS5pbnN0YW50ID09PSB0cnVlKSB7XG4gICAgY29uc3QgeyBpbnN0YW50LCByYW5nZSwgLi4ucmVzdCB9ID0gcXVlcnk7XG4gICAgcmV0dXJuIHsgLi4ucmVzdCwgcXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlLkluc3RhbnQgfTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSBpdCBpcyByYW5nZVxuICBjb25zdCB7IGluc3RhbnQsIHJhbmdlLCAuLi5yZXN0IH0gPSBxdWVyeTtcbiAgcmV0dXJuIHsgLi4ucmVzdCwgcXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlLlJhbmdlIH07XG59XG4iLCJpbXBvcnQgeyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIH0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIgfSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbnMgfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuaW1wb3J0IHsgTG9raU9wZXJhdGlvbklkLCBMb2tpUXVlcnlQYXR0ZXJuLCBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgTG9raVF1ZXJ5TW9kZWxsZXIgZXh0ZW5kcyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbnMpO1xuXG4gICAgdGhpcy5zZXRPcGVyYXRpb25DYXRlZ29yaWVzKFtcbiAgICAgIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkFnZ3JlZ2F0aW9ucyxcbiAgICAgIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgICAgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRm9ybWF0cyxcbiAgICAgIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxhYmVsRmlsdGVycyxcbiAgICAgIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxpbmVGaWx0ZXJzLFxuICAgIF0pO1xuICB9XG5cbiAgcmVuZGVyTGFiZWxzKGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSkge1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ3t9JztcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucmVuZGVyTGFiZWxzKGxhYmVscyk7XG4gIH1cblxuICBnZXRRdWVyeVBhdHRlcm5zKCk6IExva2lRdWVyeVBhdHRlcm5bXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0xvZyBxdWVyeSBhbmQgbGFiZWwgZmlsdGVyJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lTWF0Y2hlc1JlZ2V4LCBwYXJhbXM6IFsnJ10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTG9nZm10LCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyTm9FcnJvcnMsIHBhcmFtczogW10gfSxcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGaWx0ZXIsIHBhcmFtczogWycnLCAnPScsICcnXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1RpbWUgc2VyaWVzIHF1ZXJ5IG9uIHZhbHVlIGluc2lkZSBsb2cgbGluZScsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZU1hdGNoZXNSZWdleCwgcGFyYW1zOiBbJyddIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLkxvZ2ZtdCwgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5MYWJlbEZpbHRlck5vRXJyb3JzLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLlVud3JhcCwgcGFyYW1zOiBbJyddIH0sXG4gICAgICAgICAgeyBpZDogTG9raU9wZXJhdGlvbklkLlN1bU92ZXJUaW1lLCBwYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6IExva2lPcGVyYXRpb25JZC5TdW0sIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbG9raVF1ZXJ5TW9kZWxsZXIgPSBuZXcgTG9raVF1ZXJ5TW9kZWxsZXIoKTtcbiIsImltcG9ydCB7IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyIH0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL29wZXJhdGlvblV0aWxzJztcbmltcG9ydCB7XG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZixcbn0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IExva2lPcGVyYXRpb25JZCwgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGJpbmFyeVNjYWxhckRlZnMgPSBbXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkFkZGl0aW9uLFxuICAgIG5hbWU6ICdBZGQgc2NhbGFyJyxcbiAgICBzaWduOiAnKycsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLlN1YnRyYWN0aW9uLFxuICAgIG5hbWU6ICdTdWJ0cmFjdCBzY2FsYXInLFxuICAgIHNpZ246ICctJyxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTXVsdGlwbHlCeSxcbiAgICBuYW1lOiAnTXVsdGlwbHkgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnKicsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkRpdmlkZUJ5LFxuICAgIG5hbWU6ICdEaXZpZGUgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnLycsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLk1vZHVsbyxcbiAgICBuYW1lOiAnTW9kdWxvIGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJyUnLFxuICB9LFxuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5FeHBvbmVudCxcbiAgICBuYW1lOiAnRXhwb25lbnQnLFxuICAgIHNpZ246ICdeJyxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuRXF1YWxUbyxcbiAgICBuYW1lOiAnRXF1YWwgdG8nLFxuICAgIHNpZ246ICc9PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTm90RXF1YWxUbyxcbiAgICBuYW1lOiAnTm90IGVxdWFsIHRvJyxcbiAgICBzaWduOiAnIT0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogTG9raU9wZXJhdGlvbklkLkdyZWF0ZXJUaGFuLFxuICAgIG5hbWU6ICdHcmVhdGVyIHRoYW4nLFxuICAgIHNpZ246ICc+JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IExva2lPcGVyYXRpb25JZC5MZXNzVGhhbixcbiAgICBuYW1lOiAnTGVzcyB0aGFuJyxcbiAgICBzaWduOiAnPCcsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuR3JlYXRlck9yRXF1YWwsXG4gICAgbmFtZTogJ0dyZWF0ZXIgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc+PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTGVzc09yRXF1YWwsXG4gICAgbmFtZTogJ0xlc3Mgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc8PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbl07XG5cbi8vIE5vdCBzdXJlIGFib3V0IHRoaXMgb25lLiBJdCBjb3VsZCBhbHNvIGJlIGEgbW9yZSBnZW5lcmljICdTaW1wbGUgbWF0aCBvcGVyYXRpb24nIHdoZXJlIHVzZXIgc3BlY2lmaWVzXG4vLyBib3RoIHRoZSBvcGVyYXRvciBhbmQgdGhlIG9wZXJhbmQgaW4gYSBzaW5nbGUgaW5wdXRcbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJPcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IGJpbmFyeVNjYWxhckRlZnMubWFwKChvcERlZikgPT4ge1xuICBjb25zdCBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW10gPSBbeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XTtcbiAgY29uc3QgZGVmYXVsdFBhcmFtczogYW55W10gPSBbMl07XG4gIGlmIChvcERlZi5jb21wYXJpc29uKSB7XG4gICAgcGFyYW1zLnVuc2hpZnQoe1xuICAgICAgbmFtZTogJ0Jvb2wnLFxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVzY3JpcHRpb246ICdJZiBjaGVja2VkIGNvbXBhcmlzb24gd2lsbCByZXR1cm4gMCBvciAxIGZvciB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gZmlsdGVyaW5nLicsXG4gICAgfSk7XG4gICAgZGVmYXVsdFBhcmFtcy51bnNoaWZ0KGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaWQ6IG9wRGVmLmlkLFxuICAgIG5hbWU6IG9wRGVmLm5hbWUsXG4gICAgcGFyYW1zLFxuICAgIGRlZmF1bHRQYXJhbXMsXG4gICAgYWx0ZXJuYXRpdmVzS2V5OiAnYmluYXJ5IHNjYWxhciBvcGVyYXRpb25zJyxcbiAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgIHJlbmRlcmVyOiBnZXRTaW1wbGVCaW5hcnlSZW5kZXJlcihvcERlZi5zaWduKSxcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRTaW1wbGVCaW5hcnlSZW5kZXJlcihvcGVyYXRvcjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaW5hcnlSZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICBsZXQgcGFyYW0gPSBtb2RlbC5wYXJhbXNbMF07XG4gICAgbGV0IGJvb2wgPSAnJztcbiAgICBpZiAobW9kZWwucGFyYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgcGFyYW0gPSBtb2RlbC5wYXJhbXNbMV07XG4gICAgICBib29sID0gbW9kZWwucGFyYW1zWzBdID8gJyBib29sJyA6ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtpbm5lckV4cHJ9ICR7b3BlcmF0b3J9JHtib29sfSAke3BhcmFtfWA7XG4gIH07XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTG9raVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgTG9raURhdGFzb3VyY2UgfSBmcm9tICcuLi8uLi9kYXRhc291cmNlJztcbmltcG9ydCB7IExhYmVsRmlsdGVycyB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xhYmVsRmlsdGVycyc7XG5pbXBvcnQgeyBPcGVyYXRpb25MaXN0IH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uTGlzdCc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IGxva2lRdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vTG9raVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JSb3cgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgUXVlcnlQcmV2aWV3IH0gZnJvbSAnLi9RdWVyeVByZXZpZXcnO1xuaW1wb3J0IHsgT3BlcmF0aW9uc0VkaXRvclJvdyB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbnNFZGl0b3JSb3cnO1xuaW1wb3J0IHsgTmVzdGVkUXVlcnlMaXN0IH0gZnJvbSAnLi9OZXN0ZWRRdWVyeUxpc3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IExva2lWaXN1YWxRdWVyeTtcbiAgZGF0YXNvdXJjZTogTG9raURhdGFzb3VyY2U7XG4gIG9uQ2hhbmdlOiAodXBkYXRlOiBMb2tpVmlzdWFsUXVlcnkpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIG5lc3RlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBMb2tpUXVlcnlCdWlsZGVyID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgZGF0YXNvdXJjZSwgcXVlcnksIG5lc3RlZCwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfSkgPT4ge1xuICBjb25zdCBvbkNoYW5nZUxhYmVscyA9IChsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pID0+IHtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBsYWJlbHMgfSk7XG4gIH07XG5cbiAgY29uc3Qgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zID0gYXN5bmMgKG9wdGlvbnNQcm9taXNlOiBQcm9taXNlPHN0cmluZ1tdPik6IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgb3B0aW9uc1Byb21pc2U7XG4gICAgcmV0dXJuIFsuLi5kYXRhc291cmNlLmdldFZhcmlhYmxlcygpLCAuLi5vcHRpb25zXS5tYXAoKHZhbHVlKSA9PiAoeyBsYWJlbDogdmFsdWUsIHZhbHVlIH0pKTtcbiAgfTtcblxuICBjb25zdCBvbkdldExhYmVsTmFtZXMgPSBhc3luYyAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBjb25zdCBsYWJlbHNUb0NvbnNpZGVyID0gcXVlcnkubGFiZWxzLmZpbHRlcigoeCkgPT4geCAhPT0gZm9yTGFiZWwpO1xuXG4gICAgaWYgKGxhYmVsc1RvQ29uc2lkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIucmVmcmVzaExvZ0xhYmVscygpO1xuICAgICAgcmV0dXJuIGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5nZXRMYWJlbEtleXMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHByID0gbG9raVF1ZXJ5TW9kZWxsZXIucmVuZGVyTGFiZWxzKGxhYmVsc1RvQ29uc2lkZXIpO1xuICAgIGNvbnN0IHNlcmllcyA9IGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhleHByKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VyaWVzKS5zb3J0KCk7XG4gIH07XG5cbiAgY29uc3Qgb25HZXRMYWJlbFZhbHVlcyA9IGFzeW5jIChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IHtcbiAgICBpZiAoIWZvckxhYmVsLmxhYmVsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxzVG9Db25zaWRlciA9IHF1ZXJ5LmxhYmVscy5maWx0ZXIoKHgpID0+IHggIT09IGZvckxhYmVsKTtcbiAgICBpZiAobGFiZWxzVG9Db25zaWRlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hMYWJlbFZhbHVlcyhmb3JMYWJlbC5sYWJlbCk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwciA9IGxva2lRdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHNUb0NvbnNpZGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoZXhwcik7XG4gICAgY29uc3QgZm9yTGFiZWxJbnRlcnBvbGF0ZWQgPSBkYXRhc291cmNlLmludGVycG9sYXRlU3RyaW5nKGZvckxhYmVsLmxhYmVsKTtcbiAgICByZXR1cm4gcmVzdWx0W2ZvckxhYmVsSW50ZXJwb2xhdGVkXSA/PyBbXTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8RWRpdG9yUm93PlxuICAgICAgICA8TGFiZWxGaWx0ZXJzXG4gICAgICAgICAgb25HZXRMYWJlbE5hbWVzPXsoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PlxuICAgICAgICAgICAgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zKG9uR2V0TGFiZWxOYW1lcyhmb3JMYWJlbCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIG9uR2V0TGFiZWxWYWx1ZXM9eyhmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+XG4gICAgICAgICAgICB3aXRoVGVtcGxhdGVWYXJpYWJsZU9wdGlvbnMob25HZXRMYWJlbFZhbHVlcyhmb3JMYWJlbCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGxhYmVsc0ZpbHRlcnM9e3F1ZXJ5LmxhYmVsc31cbiAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VMYWJlbHN9XG4gICAgICAgIC8+XG4gICAgICA8L0VkaXRvclJvdz5cbiAgICAgIDxPcGVyYXRpb25zRWRpdG9yUm93PlxuICAgICAgICA8T3BlcmF0aW9uTGlzdFxuICAgICAgICAgIHF1ZXJ5TW9kZWxsZXI9e2xva2lRdWVyeU1vZGVsbGVyfVxuICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlIGFzIERhdGFTb3VyY2VBcGl9XG4gICAgICAgIC8+XG4gICAgICA8L09wZXJhdGlvbnNFZGl0b3JSb3c+XG4gICAgICB7cXVlcnkuYmluYXJ5UXVlcmllcyAmJiBxdWVyeS5iaW5hcnlRdWVyaWVzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8TmVzdGVkUXVlcnlMaXN0IHF1ZXJ5PXtxdWVyeX0gZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0gb25DaGFuZ2U9e29uQ2hhbmdlfSBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fSAvPlxuICAgICAgKX1cbiAgICAgIHshbmVzdGVkICYmIChcbiAgICAgICAgPEVkaXRvclJvdz5cbiAgICAgICAgICA8UXVlcnlQcmV2aWV3IHF1ZXJ5PXtxdWVyeX0gLz5cbiAgICAgICAgPC9FZGl0b3JSb3c+XG4gICAgICApfVxuICAgIDwvPlxuICApO1xufSk7XG5cbkxva2lRdWVyeUJ1aWxkZXIuZGlzcGxheU5hbWUgPSAnTG9raVF1ZXJ5QnVpbGRlcic7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTG9raVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgbG9raVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Mb2tpUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBPcGVyYXRpb25MaXN0RXhwbGFpbmVkIH0gZnJvbSAnYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uTGlzdEV4cGxhaW5lZCc7XG5pbXBvcnQgeyBPcGVyYXRpb25FeHBsYWluZWRCb3ggfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25FeHBsYWluZWRCb3gnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IExva2lWaXN1YWxRdWVyeTtcbiAgbmVzdGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IExva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBxdWVyeSwgbmVzdGVkIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXswfSBkaXJlY3Rpb249XCJjb2x1bW5cIj5cbiAgICAgIDxPcGVyYXRpb25FeHBsYWluZWRCb3ggc3RlcE51bWJlcj17MX0gdGl0bGU9e2Ake2xva2lRdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhxdWVyeS5sYWJlbHMpfWB9PlxuICAgICAgICBGZXRjaCBhbGwgbG9nIGxpbmVzIG1hdGNoaW5nIGxhYmVsIGZpbHRlcnMuXG4gICAgICA8L09wZXJhdGlvbkV4cGxhaW5lZEJveD5cbiAgICAgIDxPcGVyYXRpb25MaXN0RXhwbGFpbmVkPExva2lWaXN1YWxRdWVyeT4gc3RlcE51bWJlcj17Mn0gcXVlcnlNb2RlbGxlcj17bG9raVF1ZXJ5TW9kZWxsZXJ9IHF1ZXJ5PXtxdWVyeX0gLz5cbiAgICA8L1N0YWNrPlxuICApO1xufSk7XG5cbkxva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQuZGlzcGxheU5hbWUgPSAnTG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCc7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRWRpdG9yUm93LCBFZGl0b3JGaWVsZCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFJhZGlvQnV0dG9uR3JvdXAsIFNlbGVjdCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raVF1ZXJ5VHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFF1ZXJ5T3B0aW9uR3JvdXAgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwJztcbmltcG9ydCB7IHByZXByb2Nlc3NNYXhMaW5lcywgcXVlcnlUeXBlT3B0aW9ucywgUkVTT0xVVElPTl9PUFRJT05TIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Mb2tpT3B0aW9uRmllbGRzJztcbmltcG9ydCB7IEF1dG9TaXplSW5wdXQgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9BdXRvU2l6ZUlucHV0JztcbmltcG9ydCB7IGlzTWV0cmljc1F1ZXJ5IH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogTG9raVF1ZXJ5O1xuICBvbkNoYW5nZTogKHVwZGF0ZTogTG9raVF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgTG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBxdWVyeSwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfSkgPT4ge1xuICBjb25zdCBvblF1ZXJ5VHlwZUNoYW5nZSA9ICh2YWx1ZTogTG9raVF1ZXJ5VHlwZSkgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIHF1ZXJ5VHlwZTogdmFsdWUgfSk7XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVzb2x1dGlvbkNoYW5nZSA9IChvcHRpb246IFNlbGVjdGFibGVWYWx1ZTxudW1iZXI+KSA9PiB7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgcmVzb2x1dGlvbjogb3B0aW9uLnZhbHVlIH0pO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBjb25zdCBvbkxlZ2VuZEZvcm1hdENoYW5nZWQgPSAoZXZ0OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBsZWdlbmRGb3JtYXQ6IGV2dC5jdXJyZW50VGFyZ2V0LnZhbHVlIH0pO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBvbk1heExpbmVzQ2hhbmdlKGU6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSB7XG4gICAgY29uc3QgbmV3TWF4TGluZXMgPSBwcmVwcm9jZXNzTWF4TGluZXMoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgICBpZiAocXVlcnkubWF4TGluZXMgIT09IG5ld01heExpbmVzKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBtYXhMaW5lczogbmV3TWF4TGluZXMgfSk7XG4gICAgICBvblJ1blF1ZXJ5KCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHF1ZXJ5VHlwZSA9IHF1ZXJ5LnF1ZXJ5VHlwZSA/PyAocXVlcnkuaW5zdGFudCA/IExva2lRdWVyeVR5cGUuSW5zdGFudCA6IExva2lRdWVyeVR5cGUuUmFuZ2UpO1xuICBsZXQgc2hvd01heExpbmVzID0gIWlzTWV0cmljc1F1ZXJ5KHF1ZXJ5LmV4cHIpO1xuXG4gIHJldHVybiAoXG4gICAgPEVkaXRvclJvdz5cbiAgICAgIDxRdWVyeU9wdGlvbkdyb3VwIHRpdGxlPVwiT3B0aW9uc1wiIGNvbGxhcHNlZEluZm89e2dldENvbGxhcHNlZEluZm8ocXVlcnksIHF1ZXJ5VHlwZSwgc2hvd01heExpbmVzKX0+XG4gICAgICAgIDxFZGl0b3JGaWVsZFxuICAgICAgICAgIGxhYmVsPVwiTGVnZW5kXCJcbiAgICAgICAgICB0b29sdGlwPVwiU2VyaWVzIG5hbWUgb3ZlcnJpZGUgb3IgdGVtcGxhdGUuIEV4LiB7e2hvc3RuYW1lfX0gd2lsbCBiZSByZXBsYWNlZCB3aXRoIGxhYmVsIHZhbHVlIGZvciBob3N0bmFtZS5cIlxuICAgICAgICA+XG4gICAgICAgICAgPEF1dG9TaXplSW5wdXRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwie3tsYWJlbH19XCJcbiAgICAgICAgICAgIGlkPVwibG9raS1xdWVyeS1lZGl0b3ItbGVnZW5kLWZvcm1hdFwiXG4gICAgICAgICAgICB0eXBlPVwic3RyaW5nXCJcbiAgICAgICAgICAgIG1pbldpZHRoPXsxNH1cbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17cXVlcnkubGVnZW5kRm9ybWF0fVxuICAgICAgICAgICAgb25Db21taXRDaGFuZ2U9e29uTGVnZW5kRm9ybWF0Q2hhbmdlZH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJUeXBlXCI+XG4gICAgICAgICAgPFJhZGlvQnV0dG9uR3JvdXAgb3B0aW9ucz17cXVlcnlUeXBlT3B0aW9uc30gdmFsdWU9e3F1ZXJ5VHlwZX0gb25DaGFuZ2U9e29uUXVlcnlUeXBlQ2hhbmdlfSAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICB7c2hvd01heExpbmVzICYmIChcbiAgICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJMaW5lIGxpbWl0XCIgdG9vbHRpcD1cIlVwcGVyIGxpbWl0IGZvciBudW1iZXIgb2YgbG9nIGxpbmVzIHJldHVybmVkIGJ5IHF1ZXJ5LlwiPlxuICAgICAgICAgICAgPEF1dG9TaXplSW5wdXRcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2lkdGgtNFwiXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiYXV0b1wiXG4gICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgICBtaW49ezB9XG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17cXVlcnkubWF4TGluZXM/LnRvU3RyaW5nKCkgPz8gJyd9XG4gICAgICAgICAgICAgIG9uQ29tbWl0Q2hhbmdlPXtvbk1heExpbmVzQ2hhbmdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgICApfVxuICAgICAgICA8RWRpdG9yRmllbGQgbGFiZWw9XCJSZXNvbHV0aW9uXCI+XG4gICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgaXNTZWFyY2hhYmxlPXtmYWxzZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvblJlc29sdXRpb25DaGFuZ2V9XG4gICAgICAgICAgICBvcHRpb25zPXtSRVNPTFVUSU9OX09QVElPTlN9XG4gICAgICAgICAgICB2YWx1ZT17cXVlcnkucmVzb2x1dGlvbiB8fCAxfVxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNlbGVjdCByZXNvbHV0aW9uXCJcbiAgICAgICAgICAgIG1lbnVTaG91bGRQb3J0YWxcbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgPC9RdWVyeU9wdGlvbkdyb3VwPlxuICAgIDwvRWRpdG9yUm93PlxuICApO1xufSk7XG5cbmZ1bmN0aW9uIGdldENvbGxhcHNlZEluZm8ocXVlcnk6IExva2lRdWVyeSwgcXVlcnlUeXBlOiBMb2tpUXVlcnlUeXBlLCBzaG93TWF4TGluZXM6IGJvb2xlYW4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHF1ZXJ5VHlwZUxhYmVsID0gcXVlcnlUeXBlT3B0aW9ucy5maW5kKCh4KSA9PiB4LnZhbHVlID09PSBxdWVyeVR5cGUpO1xuICBjb25zdCByZXNvbHV0aW9uTGFiZWwgPSBSRVNPTFVUSU9OX09QVElPTlMuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gKHF1ZXJ5LnJlc29sdXRpb24gPz8gMSkpO1xuXG4gIGNvbnN0IGl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGlmIChxdWVyeS5sZWdlbmRGb3JtYXQpIHtcbiAgICBpdGVtcy5wdXNoKGBMZWdlbmQ6ICR7cXVlcnkubGVnZW5kRm9ybWF0fWApO1xuICB9XG5cbiAgaWYgKHF1ZXJ5LnJlc29sdXRpb24pIHtcbiAgICBpdGVtcy5wdXNoKGBSZXNvbHV0aW9uOiAke3Jlc29sdXRpb25MYWJlbD8ubGFiZWx9YCk7XG4gIH1cblxuICBpdGVtcy5wdXNoKGBUeXBlOiAke3F1ZXJ5VHlwZUxhYmVsPy5sYWJlbH1gKTtcblxuICBpZiAoc2hvd01heExpbmVzICYmIHF1ZXJ5Lm1heExpbmVzKSB7XG4gICAgaXRlbXMucHVzaChgTGluZSBsaW1pdDogJHtxdWVyeS5tYXhMaW5lc31gKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtcztcbn1cblxuTG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMuZGlzcGxheU5hbWUgPSAnTG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMnO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRlc3RJZHMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0xva2lRdWVyeUVkaXRvcic7XG5pbXBvcnQgeyB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IExva2lRdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy90eXBlcyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlGaWVsZCB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvTG9raVF1ZXJ5RmllbGQnO1xuXG5leHBvcnQgZnVuY3Rpb24gTG9raVF1ZXJ5Q29kZUVkaXRvcih7IHF1ZXJ5LCBkYXRhc291cmNlLCByYW5nZSwgb25SdW5RdWVyeSwgb25DaGFuZ2UsIGRhdGEgfTogTG9raVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgIDxMb2tpUXVlcnlGaWVsZFxuICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgIHJhbmdlPXtyYW5nZX1cbiAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICBoaXN0b3J5PXtbXX1cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZWRpdG9yfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB3cmFwcGVyIHN0eWxpbmcgY2FuIGJlIHJlbW92ZWQgYWZ0ZXIgdGhlIG9sZCBQcm9tUXVlcnlFZGl0b3IgaXMgcmVtb3ZlZC5cbiAgICAvLyBUaGlzIGlzIHJlbW92aW5nIG1hcmdpbiBib3R0b20gb24gdGhlIG9sZCBsZWdhY3kgaW5saW5lIGZvcm0gc3R5bGVzXG4gICAgd3JhcHBlcjogY3NzYFxuICAgICAgLmdmLWZvcm0ge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgfVxuICAgIGAsXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIsIExvYWRpbmdTdGF0ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9ySGVhZGVyLCBFZGl0b3JSb3dzLCBGbGV4SXRlbSwgSW5saW5lU2VsZWN0LCBTcGFjZSB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIHVzZVN0eWxlczIsIENvbmZpcm1Nb2RhbCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSB9IGZyb20gJ2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL1F1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSc7XG5pbXBvcnQgeyBRdWVyeUVkaXRvck1vZGUgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5RWRpdG9yUHJvcHMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL3R5cGVzJztcbmltcG9ydCB7IExva2lRdWVyeSB9IGZyb20gJy4uLy4uL3R5cGVzJztcblxuaW1wb3J0IHsgbG9raVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Mb2tpUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBnZXRRdWVyeVdpdGhEZWZhdWx0cyB9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7IGdldERlZmF1bHRFbXB0eVF1ZXJ5LCBMb2tpVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMb2tpUXVlcnlCdWlsZGVyIH0gZnJvbSAnLi9Mb2tpUXVlcnlCdWlsZGVyJztcbmltcG9ydCB7IExva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQgfSBmcm9tICcuL0xva2lRdWVyeUJ1aWxkZXJFeHBsYWluZCc7XG5pbXBvcnQgeyBMb2tpUXVlcnlCdWlsZGVyT3B0aW9ucyB9IGZyb20gJy4vTG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5Q29kZUVkaXRvciB9IGZyb20gJy4vTG9raVF1ZXJ5Q29kZUVkaXRvcic7XG5pbXBvcnQgeyBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyB9IGZyb20gJy4uL3BhcnNpbmcnO1xuXG5leHBvcnQgY29uc3QgTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3IgPSBSZWFjdC5tZW1vPExva2lRdWVyeUVkaXRvclByb3BzPigocHJvcHMpID0+IHtcbiAgY29uc3QgeyBvbkNoYW5nZSwgb25SdW5RdWVyeSwgZGF0YSB9ID0gcHJvcHM7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgcXVlcnkgPSBnZXRRdWVyeVdpdGhEZWZhdWx0cyhwcm9wcy5xdWVyeSk7XG4gIGNvbnN0IFt2aXN1YWxRdWVyeSwgc2V0VmlzdWFsUXVlcnldID0gdXNlU3RhdGU8TG9raVZpc3VhbFF1ZXJ5PihxdWVyeS52aXN1YWxRdWVyeSA/PyBnZXREZWZhdWx0RW1wdHlRdWVyeSgpKTtcbiAgY29uc3QgW3BhcnNlTW9kYWxPcGVuLCBzZXRQYXJzZU1vZGFsT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtwZW5kaW5nQ2hhbmdlLCBzZXRQZW5kaW5nQ2hhbmdlXSA9IHVzZVN0YXRlPExva2lRdWVyeSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICBjb25zdCBvbkVkaXRvck1vZGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAobmV3TWV0cmljRWRpdG9yTW9kZTogUXVlcnlFZGl0b3JNb2RlKSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSB7IC4uLnF1ZXJ5LCBlZGl0b3JNb2RlOiBuZXdNZXRyaWNFZGl0b3JNb2RlIH07XG4gICAgICBpZiAobmV3TWV0cmljRWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcocXVlcnkuZXhwcik7XG4gICAgICAgIGNoYW5nZS52aXN1YWxRdWVyeSA9IHJlc3VsdC5xdWVyeTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGVycm9ycywgZ2l2ZSB1c2VyIGEgY2hhbmNlIHRvIGRlY2lkZSBpZiB0aGV5IHdhbnQgdG8gZ28gdG8gYnVpbGRlciBhcyB0aGF0IGNhbiBsb29zZSBzb21lIGRhdGEuXG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIHNldFBhcnNlTW9kYWxPcGVuKHRydWUpO1xuICAgICAgICAgIHNldFBlbmRpbmdDaGFuZ2UoY2hhbmdlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmlzdWFsUXVlcnkoY2hhbmdlLnZpc3VhbFF1ZXJ5KTtcbiAgICAgIH1cbiAgICAgIG9uQ2hhbmdlKGNoYW5nZSk7XG4gICAgfSxcbiAgICBbb25DaGFuZ2UsIHF1ZXJ5XVxuICApO1xuXG4gIGNvbnN0IG9uQ2hhbmdlVmlld01vZGVsID0gKHVwZGF0ZWRRdWVyeTogTG9raVZpc3VhbFF1ZXJ5KSA9PiB7XG4gICAgc2V0VmlzdWFsUXVlcnkodXBkYXRlZFF1ZXJ5KTtcblxuICAgIG9uQ2hhbmdlKHtcbiAgICAgIC4uLnF1ZXJ5LFxuICAgICAgZXhwcjogbG9raVF1ZXJ5TW9kZWxsZXIucmVuZGVyUXVlcnkodXBkYXRlZFF1ZXJ5KSxcbiAgICAgIHZpc3VhbFF1ZXJ5OiB1cGRhdGVkUXVlcnksXG4gICAgICBlZGl0b3JNb2RlOiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcixcbiAgICB9KTtcbiAgfTtcblxuICAvLyBJZiBubyBleHByIChpZSBuZXcgcXVlcnkpIHRoZW4gZGVmYXVsdCB0byBidWlsZGVyXG4gIGNvbnN0IGVkaXRvck1vZGUgPSBxdWVyeS5lZGl0b3JNb2RlID8/IChxdWVyeS5leHByID8gUXVlcnlFZGl0b3JNb2RlLkNvZGUgOiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcik7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPENvbmZpcm1Nb2RhbFxuICAgICAgICBpc09wZW49e3BhcnNlTW9kYWxPcGVufVxuICAgICAgICB0aXRsZT1cIlF1ZXJ5IHBhcnNpbmdcIlxuICAgICAgICBib2R5PVwiVGhlcmUgd2VyZSBlcnJvcnMgd2hpbGUgdHJ5aW5nIHRvIHBhcnNlIHRoZSBxdWVyeS4gQ29udGludWluZyB0byB2aXN1YWwgYnVpbGRlciBtYXkgbG9vc2Ugc29tZSBwYXJ0cyBvZiB0aGUgcXVlcnkuXCJcbiAgICAgICAgY29uZmlybVRleHQ9XCJDb250aW51ZVwiXG4gICAgICAgIG9uQ29uZmlybT17KCkgPT4ge1xuICAgICAgICAgIHNldFZpc3VhbFF1ZXJ5KHBlbmRpbmdDaGFuZ2UhLnZpc3VhbFF1ZXJ5ISk7XG4gICAgICAgICAgb25DaGFuZ2UocGVuZGluZ0NoYW5nZSEpO1xuICAgICAgICAgIHNldFBhcnNlTW9kYWxPcGVuKGZhbHNlKTtcbiAgICAgICAgfX1cbiAgICAgICAgb25EaXNtaXNzPXsoKSA9PiBzZXRQYXJzZU1vZGFsT3BlbihmYWxzZSl9XG4gICAgICAvPlxuICAgICAgPEVkaXRvckhlYWRlcj5cbiAgICAgICAgPEZsZXhJdGVtIGdyb3c9ezF9IC8+XG4gICAgICAgIDxCdXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5ydW5RdWVyeX1cbiAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgIGZpbGw9XCJvdXRsaW5lXCJcbiAgICAgICAgICBvbkNsaWNrPXtvblJ1blF1ZXJ5fVxuICAgICAgICAgIGljb249e2RhdGE/LnN0YXRlID09PSBMb2FkaW5nU3RhdGUuTG9hZGluZyA/ICdmYSBmYS1zcGlubmVyJyA6IHVuZGVmaW5lZH1cbiAgICAgICAgICBkaXNhYmxlZD17ZGF0YT8uc3RhdGUgPT09IExvYWRpbmdTdGF0ZS5Mb2FkaW5nfVxuICAgICAgICA+XG4gICAgICAgICAgUnVuIHF1ZXJ5XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8SW5saW5lU2VsZWN0XG4gICAgICAgICAgdmFsdWU9e251bGx9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJRdWVyeSBwYXR0ZXJuc1wiXG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIG9uQ2hhbmdlPXsoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBvbkNoYW5nZVZpZXdNb2RlbCh7XG4gICAgICAgICAgICAgIC4uLnZpc3VhbFF1ZXJ5LFxuICAgICAgICAgICAgICBvcGVyYXRpb25zOiB2YWx1ZT8ub3BlcmF0aW9ucyEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIG9wdGlvbnM9e2xva2lRdWVyeU1vZGVsbGVyLmdldFF1ZXJ5UGF0dGVybnMoKS5tYXAoKHgpID0+ICh7IGxhYmVsOiB4Lm5hbWUsIHZhbHVlOiB4IH0pKX1cbiAgICAgICAgLz5cbiAgICAgICAgPFF1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSBtb2RlPXtlZGl0b3JNb2RlfSBvbkNoYW5nZT17b25FZGl0b3JNb2RlQ2hhbmdlfSAvPlxuICAgICAgPC9FZGl0b3JIZWFkZXI+XG4gICAgICA8U3BhY2Ugdj17MC41fSAvPlxuICAgICAgPEVkaXRvclJvd3M+XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQ29kZSAmJiA8TG9raVF1ZXJ5Q29kZUVkaXRvciB7Li4ucHJvcHN9IC8+fVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIgJiYgKFxuICAgICAgICAgIDxMb2tpUXVlcnlCdWlsZGVyXG4gICAgICAgICAgICBkYXRhc291cmNlPXtwcm9wcy5kYXRhc291cmNlfVxuICAgICAgICAgICAgcXVlcnk9e3Zpc3VhbFF1ZXJ5fVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlVmlld01vZGVsfVxuICAgICAgICAgICAgb25SdW5RdWVyeT17cHJvcHMub25SdW5RdWVyeX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICB7ZWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gJiYgPExva2lRdWVyeUJ1aWxkZXJFeHBsYWluZWQgcXVlcnk9e3Zpc3VhbFF1ZXJ5fSAvPn1cbiAgICAgICAge2VkaXRvck1vZGUgIT09IFF1ZXJ5RWRpdG9yTW9kZS5FeHBsYWluICYmIChcbiAgICAgICAgICA8TG9raVF1ZXJ5QnVpbGRlck9wdGlvbnMgcXVlcnk9e3F1ZXJ5fSBvbkNoYW5nZT17b25DaGFuZ2V9IG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9IC8+XG4gICAgICAgICl9XG4gICAgICA8L0VkaXRvclJvd3M+XG4gICAgPC8+XG4gICk7XG59KTtcblxuTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3IuZGlzcGxheU5hbWUgPSAnTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3InO1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBydW5RdWVyeTogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgfSksXG4gICAgc3dpdGNoTGFiZWw6IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yUm93cywgRmxleEl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgU2VsZWN0LCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGJpbmFyeVNjYWxhckRlZnMgfSBmcm9tICcuLi9iaW5hcnlTY2FsYXJPcGVyYXRpb25zJztcbmltcG9ydCB7IExva2lWaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBMb2tpUXVlcnlCdWlsZGVyIH0gZnJvbSAnLi9Mb2tpUXVlcnlCdWlsZGVyJztcbmltcG9ydCB7IEF1dG9TaXplSW5wdXQgfSBmcm9tICdhcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9BdXRvU2l6ZUlucHV0JztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG5lc3RlZFF1ZXJ5OiBMb2tpVmlzdWFsUXVlcnlCaW5hcnk7XG4gIGRhdGFzb3VyY2U6IExva2lEYXRhc291cmNlO1xuICBpbmRleDogbnVtYmVyO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogTG9raVZpc3VhbFF1ZXJ5QmluYXJ5KSA9PiB2b2lkO1xuICBvblJlbW92ZTogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBOZXN0ZWRRdWVyeSA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IG5lc3RlZFF1ZXJ5LCBpbmRleCwgZGF0YXNvdXJjZSwgb25DaGFuZ2UsIG9uUmVtb3ZlLCBvblJ1blF1ZXJ5IH0pID0+IHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jYXJkfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5uYW1lfT5PcGVyYXRvcjwvZGl2PlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICBvcHRpb25zPXtvcGVyYXRvcnN9XG4gICAgICAgICAgdmFsdWU9e3RvT3B0aW9uKG5lc3RlZFF1ZXJ5Lm9wZXJhdG9yKX1cbiAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBvbkNoYW5nZShpbmRleCwge1xuICAgICAgICAgICAgICAuLi5uZXN0ZWRRdWVyeSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IHZhbHVlLnZhbHVlISxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmFtZX0+VmVjdG9yIG1hdGNoZXM8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52ZWN0b3JNYXRjaFdyYXBwZXJ9PlxuICAgICAgICAgIDxTZWxlY3Q8TG9raVZpc3VhbFF1ZXJ5QmluYXJ5Wyd2ZWN0b3JNYXRjaGVzVHlwZSddPlxuICAgICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICAgIHZhbHVlPXtuZXN0ZWRRdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSB8fCAnb24nfVxuICAgICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgICAgb3B0aW9ucz17W1xuICAgICAgICAgICAgICB7IHZhbHVlOiAnb24nLCBsYWJlbDogJ29uJyB9LFxuICAgICAgICAgICAgICB7IHZhbHVlOiAnaWdub3JpbmcnLCBsYWJlbDogJ2lnbm9yaW5nJyB9LFxuICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsodmFsKSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCB7XG4gICAgICAgICAgICAgICAgLi4ubmVzdGVkUXVlcnksXG4gICAgICAgICAgICAgICAgdmVjdG9yTWF0Y2hlc1R5cGU6IHZhbC52YWx1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEF1dG9TaXplSW5wdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZlY3Rvck1hdGNoSW5wdXR9XG4gICAgICAgICAgICBtaW5XaWR0aD17MjB9XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU9e25lc3RlZFF1ZXJ5LnZlY3Rvck1hdGNoZXN9XG4gICAgICAgICAgICBvbkNvbW1pdENoYW5nZT17KGV2dCkgPT4ge1xuICAgICAgICAgICAgICBvbkNoYW5nZShpbmRleCwge1xuICAgICAgICAgICAgICAgIC4uLm5lc3RlZFF1ZXJ5LFxuICAgICAgICAgICAgICAgIHZlY3Rvck1hdGNoZXM6IGV2dC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHZlY3Rvck1hdGNoZXNUeXBlOiBuZXN0ZWRRdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSB8fCAnb24nLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICA8SWNvbkJ1dHRvbiBuYW1lPVwidGltZXNcIiBzaXplPVwic21cIiBvbkNsaWNrPXsoKSA9PiBvblJlbW92ZShpbmRleCl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9keX0+XG4gICAgICAgIDxFZGl0b3JSb3dzPlxuICAgICAgICAgIDxMb2tpUXVlcnlCdWlsZGVyXG4gICAgICAgICAgICBxdWVyeT17bmVzdGVkUXVlcnkucXVlcnl9XG4gICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgbmVzdGVkPXt0cnVlfVxuICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsodXBkYXRlKSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4LCB7IC4uLm5lc3RlZFF1ZXJ5LCBxdWVyeTogdXBkYXRlIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvclJvd3M+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn0pO1xuXG5jb25zdCBvcGVyYXRvcnMgPSBiaW5hcnlTY2FsYXJEZWZzLm1hcCgoZGVmKSA9PiAoeyBsYWJlbDogZGVmLnNpZ24sIHZhbHVlOiBkZWYuc2lnbiB9KSk7XG5cbk5lc3RlZFF1ZXJ5LmRpc3BsYXlOYW1lID0gJ05lc3RlZFF1ZXJ5JztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY2FyZDogY3NzKHtcbiAgICAgIGxhYmVsOiAnY2FyZCcsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgIH0pLFxuICAgIGhlYWRlcjogY3NzKHtcbiAgICAgIGxhYmVsOiAnaGVhZGVyJyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMC41LCAwLjUsIDAuNSwgMSksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICB9KSxcbiAgICBuYW1lOiBjc3Moe1xuICAgICAgbGFiZWw6ICduYW1lJyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH0pLFxuICAgIGJvZHk6IGNzcyh7XG4gICAgICBsYWJlbDogJ2JvZHknLFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgfSksXG4gICAgdmVjdG9yTWF0Y2hJbnB1dDogY3NzKHtcbiAgICAgIGxhYmVsOiAndmVjdG9yTWF0Y2hJbnB1dCcsXG4gICAgICBtYXJnaW5MZWZ0OiAtMSxcbiAgICB9KSxcbiAgICB2ZWN0b3JNYXRjaFdyYXBwZXI6IGNzcyh7XG4gICAgICBsYWJlbDogJ3ZlY3Rvck1hdGNoV3JhcHBlcicsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExva2lEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBMb2tpVmlzdWFsUXVlcnksIExva2lWaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IE5lc3RlZFF1ZXJ5IH0gZnJvbSAnLi9OZXN0ZWRRdWVyeSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5O1xuICBkYXRhc291cmNlOiBMb2tpRGF0YXNvdXJjZTtcbiAgb25DaGFuZ2U6IChxdWVyeTogTG9raVZpc3VhbFF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTmVzdGVkUXVlcnlMaXN0KHsgcXVlcnksIGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH06IFByb3BzKSB7XG4gIGNvbnN0IG5lc3RlZFF1ZXJpZXMgPSBxdWVyeS5iaW5hcnlRdWVyaWVzID8/IFtdO1xuXG4gIGNvbnN0IG9uTmVzdGVkUXVlcnlVcGRhdGUgPSAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBMb2tpVmlzdWFsUXVlcnlCaW5hcnkpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5uZXN0ZWRRdWVyaWVzXTtcbiAgICB1cGRhdGVkTGlzdC5zcGxpY2UoaW5kZXgsIDEsIHVwZGF0ZSk7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgYmluYXJ5UXVlcmllczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25SZW1vdmUgPSAoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm5lc3RlZFF1ZXJpZXMuc2xpY2UoMCwgaW5kZXgpLCAuLi5uZXN0ZWRRdWVyaWVzLnNsaWNlKGluZGV4ICsgMSldO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGJpbmFyeVF1ZXJpZXM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGRpcmVjdGlvbj1cImNvbHVtblwiIGdhcD17MX0+XG4gICAgICB7bmVzdGVkUXVlcmllcy5tYXAoKG5lc3RlZFF1ZXJ5LCBpbmRleCkgPT4gKFxuICAgICAgICA8TmVzdGVkUXVlcnlcbiAgICAgICAgICBrZXk9e2luZGV4LnRvU3RyaW5nKCl9XG4gICAgICAgICAgbmVzdGVkUXVlcnk9e25lc3RlZFF1ZXJ5fVxuICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICBvbkNoYW5nZT17b25OZXN0ZWRRdWVyeVVwZGF0ZX1cbiAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgIG9uUmVtb3ZlPXtvblJlbW92ZX1cbiAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAvPlxuICAgICAgKSl9XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBMb2tpVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB1c2VUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEVkaXRvckZpZWxkLCBFZGl0b3JGaWVsZEdyb3VwIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCBQcmlzbSBmcm9tICdwcmlzbWpzJztcbmltcG9ydCB7IGxva2lHcmFtbWFyIH0gZnJvbSAnLi4vLi4vc3ludGF4JztcbmltcG9ydCB7IGxva2lRdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vTG9raVF1ZXJ5TW9kZWxsZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IExva2lWaXN1YWxRdWVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFF1ZXJ5UHJldmlldyh7IHF1ZXJ5IH06IFByb3BzKSB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUyKCk7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlcyh0aGVtZSk7XG4gIGNvbnN0IGhpZ2h0bGlnaHRlZCA9IFByaXNtLmhpZ2hsaWdodChsb2tpUXVlcnlNb2RlbGxlci5yZW5kZXJRdWVyeShxdWVyeSksIGxva2lHcmFtbWFyLCAnbG9raXFsJyk7XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIlF1ZXJ5IHRleHRcIj5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17Y3goc3R5bGVzLmVkaXRvckZpZWxkLCAncHJpc20tc3ludGF4LWhpZ2hsaWdodCcpfVxuICAgICAgICAgIGFyaWEtbGFiZWw9XCJzZWxlY3RvclwiXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBoaWdodGxpZ2h0ZWQgfX1cbiAgICAgICAgLz5cbiAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgPC9FZGl0b3JGaWVsZEdyb3VwPlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlZGl0b3JGaWVsZDogY3NzKHtcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMC4yNSwgMSksXG4gICAgICBmb250RmFtaWx5OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHlNb25vc3BhY2UsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgfSksXG4gIH07XG59O1xuIiwiaW1wb3J0IHtcbiAgY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24sXG4gIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtLFxuICBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lLFxufSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHtcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxuICBWaXN1YWxRdWVyeU1vZGVsbGVyLFxufSBmcm9tICcuLi8uLi9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgRlVOQ1RJT05TIH0gZnJvbSAnLi4vc3ludGF4JztcbmltcG9ydCB7IGJpbmFyeVNjYWxhck9wZXJhdGlvbnMgfSBmcm9tICcuL2JpbmFyeVNjYWxhck9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgTG9raU9wZXJhdGlvbklkLCBMb2tpT3BlcmF0aW9uT3JkZXIsIExva2lWaXN1YWxRdWVyeSwgTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdGlvbkRlZmluaXRpb25zKCk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3QgYWdncmVnYXRpb25zID0gW1xuICAgIExva2lPcGVyYXRpb25JZC5TdW0sXG4gICAgTG9raU9wZXJhdGlvbklkLk1pbixcbiAgICBMb2tpT3BlcmF0aW9uSWQuTWF4LFxuICAgIExva2lPcGVyYXRpb25JZC5BdmcsXG4gICAgTG9raU9wZXJhdGlvbklkLlN0ZGRldixcbiAgICBMb2tpT3BlcmF0aW9uSWQuU3RkdmFyLFxuICAgIExva2lPcGVyYXRpb25JZC5Db3VudCxcbiAgXS5mbGF0TWFwKChvcElkKSA9PlxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKG9wSWQsIHtcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MYXN0LFxuICAgIH0pXG4gICk7XG5cbiAgY29uc3QgYWdncmVnYXRpb25zV2l0aFBhcmFtID0gW0xva2lPcGVyYXRpb25JZC5Ub3BLLCBMb2tpT3BlcmF0aW9uSWQuQm90dG9tS10uZmxhdE1hcCgob3BJZCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShcbiAgICAgIG9wSWQsXG4gICAgICB7XG4gICAgICAgIHBhcmFtczogW3sgbmFtZTogJ0stdmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgICAgZGVmYXVsdFBhcmFtczogWzVdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGFzdCxcbiAgICAgIH1cbiAgICApO1xuICB9KTtcblxuICBjb25zdCBsaXN0OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IFtcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuUmF0ZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkNvdW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5TdW1PdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkJ5dGVzUmF0ZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkJ5dGVzT3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5BYnNlbnRPdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkF2Z092ZXJUaW1lKSxcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuTWF4T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5NaW5PdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLkZpcnN0T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5MYXN0T3ZlclRpbWUpLFxuICAgIGNyZWF0ZVJhbmdlT3BlcmF0aW9uKExva2lPcGVyYXRpb25JZC5TdGR2YXJPdmVyVGltZSksXG4gICAgY3JlYXRlUmFuZ2VPcGVyYXRpb24oTG9raU9wZXJhdGlvbklkLlN0ZGRldk92ZXJUaW1lKSxcbiAgICBjcmVhdGVSYW5nZU9wZXJhdGlvbihMb2tpT3BlcmF0aW9uSWQuUXVhbnRpbGVPdmVyVGltZSksXG4gICAgLi4uYWdncmVnYXRpb25zLFxuICAgIC4uLmFnZ3JlZ2F0aW9uc1dpdGhQYXJhbSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkpzb24sXG4gICAgICBuYW1lOiAnSnNvbicsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTG9nZm10LFxuICAgICAgbmFtZTogJ0xvZ2ZtdCcsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIGV4dHJhY3QgYWxsIGtleXMgYW5kIHZhbHVlcyBmcm9tIGEgW2xvZ2ZtdF0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNsb2dmbXQpIGZvcm1hdHRlZCBsb2cgbGluZSBhcyBsYWJlbHMuIFRoZSBleHRyYWN0ZWQgbGFiZWxzIGNhbiBiZSB1c2VkIGluIGxhYmVsIGZpbHRlciBleHByZXNzaW9ucyBhbmQgdXNlZCBhcyB2YWx1ZXMgZm9yIGEgcmFuZ2UgYWdncmVnYXRpb24gdmlhIHRoZSB1bndyYXAgb3BlcmF0aW9uLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLlJlZ2V4cCxcbiAgICAgIG5hbWU6ICdSZWdleHAnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU3RyaW5nJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBoaWRlTmFtZTogdHJ1ZSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJzxyZT4nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIHJlZ2V4cCBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIGEgbG9nIGxpbmUuJyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2Zvcm1hdCcsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRm9ybWF0cyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGb3JtYXRzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCByZWdleHAgXFxgJHttb2RlbC5wYXJhbXNbMF19XFxgYCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT5cbiAgICAgICAgYFRoZSBbcmVnZXhwIHBhcnNlcl0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNyZWd1bGFyLWV4cHJlc3Npb24pIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciB8IHJlZ2V4cCBcIjxyZT5cIiB3aGljaCBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIHVzaW5nIHRoZSBHb2xhbmcgUkUyIHN5bnRheC4gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtdXN0IGNvbnRhaW4gYSBsZWFzdCBvbmUgbmFtZWQgc3ViLW1hdGNoIChlLmcgKD9QPG5hbWU+cmUpKSwgZWFjaCBzdWItbWF0Y2ggd2lsbCBleHRyYWN0IGEgZGlmZmVyZW50IGxhYmVsLiBUaGUgZXhwcmVzc2lvbiBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBsb2cgbGluZS4gVGhlIGV4dHJhY3RlZCBsYWJlbHMgY2FuIGJlIHVzZWQgaW4gbGFiZWwgZmlsdGVyIGV4cHJlc3Npb25zIGFuZCB1c2VkIGFzIHZhbHVlcyBmb3IgYSByYW5nZSBhZ2dyZWdhdGlvbiB2aWEgdGhlIHVud3JhcCBvcGVyYXRpb24uYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuUGF0dGVybixcbiAgICAgIG5hbWU6ICdQYXR0ZXJuJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1N0cmluZycsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgaGlkZU5hbWU6IHRydWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICc8cGF0dGVybi1leHByZXNzaW9uPicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiBhIGxvZyBsaW5lLicsXG4gICAgICAgICAgbWluV2lkdGg6IDIwLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJ10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwsIGRlZiwgaW5uZXJFeHByKSA9PiBgJHtpbm5lckV4cHJ9IHwgcGF0dGVybiBcXGAke21vZGVsLnBhcmFtc1swXX1cXGBgLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhlIFtwYXR0ZXJuIHBhcnNlcl0oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyNwYXR0ZXJuKSBhbGxvd3MgdGhlIGV4cGxpY2l0IGV4dHJhY3Rpb24gb2YgZmllbGRzIGZyb20gbG9nIGxpbmVzIGJ5IGRlZmluaW5nIGEgcGF0dGVybiBleHByZXNzaW9uICh8IHBhdHRlcm4gXFxgPHBhdHRlcm4tZXhwcmVzc2lvbj5cXGApLiBUaGUgZXhwcmVzc2lvbiBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBsb2cgbGluZS4gVGhlIGV4dHJhY3RlZCBsYWJlbHMgY2FuIGJlIHVzZWQgaW4gbGFiZWwgZmlsdGVyIGV4cHJlc3Npb25zIGFuZCB1c2VkIGFzIHZhbHVlcyBmb3IgYSByYW5nZSBhZ2dyZWdhdGlvbiB2aWEgdGhlIHVud3JhcCBvcGVyYXRpb24uYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuVW5wYWNrLFxuICAgICAgbmFtZTogJ1VucGFjaycsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdmb3JtYXQnLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRm9ybWF0cyxcbiAgICAgIHJlbmRlcmVyOiBwaXBlbGluZVJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIGV4dHJhY3QgYWxsIGtleXMgYW5kIHZhbHVlcyBmcm9tIGEgSlNPTiBsb2cgbGluZSwgW3VucGFja2luZ10oaHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2xva2kvbGF0ZXN0L2xvZ3FsL2xvZ19xdWVyaWVzLyN1bnBhY2spIGFsbCBlbWJlZGRlZCBsYWJlbHMgaW4gdGhlIHBhY2sgc3RhZ2UuIFRoZSBleHRyYWN0ZWQgbGFiZWxzIGNhbiBiZSB1c2VkIGluIGxhYmVsIGZpbHRlciBleHByZXNzaW9ucyBhbmQgdXNlZCBhcyB2YWx1ZXMgZm9yIGEgcmFuZ2UgYWdncmVnYXRpb24gdmlhIHRoZSB1bndyYXAgb3BlcmF0aW9uLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxpbmVGb3JtYXQsXG4gICAgICBuYW1lOiAnTGluZSBmb3JtYXQnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU3RyaW5nJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBoaWRlTmFtZTogdHJ1ZSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJ3t7LnN0YXR1c19jb2RlfX0nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBsaW5lIHRlbXBsYXRlIHRoYXQgY2FuIHJlZmVyIHRvIHN0cmVhbSBsYWJlbHMgYW5kIGV4dHJhY3RlZCBsYWJlbHMuJyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2Zvcm1hdCcsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRm9ybWF0cyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGb3JtYXRzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCBsaW5lX2Zvcm1hdCBcXGAke21vZGVsLnBhcmFtc1swXX1cXGBgLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAoKSA9PlxuICAgICAgICBgVGhpcyB3aWxsIHJlcGxhY2UgbG9nIGxpbmUgdXNpbmcgYSBzcGVjaWZpZWQgdGVtcGxhdGUuIFRoZSB0ZW1wbGF0ZSBjYW4gcmVmZXIgdG8gc3RyZWFtIGxhYmVscyBhbmQgZXh0cmFjdGVkIGxhYmVscy5cblxuICAgICAgICBFeGFtcGxlOiBcXGB7ey5zdGF0dXNfY29kZX19IC0ge3subWVzc2FnZX19XFxgXG5cbiAgICAgICAgW1JlYWQgdGhlIGRvY3NdKGh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC9sb2dfcXVlcmllcy8jbGluZS1mb3JtYXQtZXhwcmVzc2lvbikgZm9yIG1vcmUuXG4gICAgICAgIGAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRm9ybWF0LFxuICAgICAgbmFtZTogJ0xhYmVsIGZvcm1hdCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgeyBuYW1lOiAnTGFiZWwnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdSZW5hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnZm9ybWF0JyxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Gb3JtYXRzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGluZUZvcm1hdHMsXG4gICAgICByZW5kZXJlcjogKG1vZGVsLCBkZWYsIGlubmVyRXhwcikgPT4gYCR7aW5uZXJFeHByfSB8IGxhYmVsX2Zvcm1hdCAke21vZGVsLnBhcmFtc1sxXX09XFxgJHttb2RlbC5wYXJhbXNbMF19XFxgYCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT5cbiAgICAgICAgYFRoaXMgd2lsbCBjaGFuZ2UgbmFtZSBvZiBsYWJlbCB0byBkZXNpcmVkIG5ldyBsYWJlbC4gSW4gdGhlIGV4YW1wbGUgYmVsb3csIGxhYmVsIFwiZXJyb3JfbGV2ZWxcIiB3aWxsIGJlIHJlbmFtZWQgdG8gXCJsZXZlbFwiLlxuXG4gICAgICAgIEV4YW1wbGU6IGVycm9yX2xldmVsPVxcYGxldmVsXFxgXG5cbiAgICAgICAgW1JlYWQgdGhlIGRvY3NdKGh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC9sb2dfcXVlcmllcy8jbGFiZWxzLWZvcm1hdC1leHByZXNzaW9uKSBmb3IgbW9yZS5cbiAgICAgICAgYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnMsXG4gICAgICBuYW1lOiAnTGluZSBjb250YWlucycsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTdHJpbmcnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGhpZGVOYW1lOiB0cnVlLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnVGV4dCB0byBmaW5kJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZpbmQgbG9nIGxpbmVzIHRoYXQgY29udGFpbnMgdGhpcyB0ZXh0JyxcbiAgICAgICAgICBtaW5XaWR0aDogMjAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ2xpbmUgZmlsdGVyJyxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MaW5lRmlsdGVycyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLkxpbmVGaWx0ZXJzLFxuICAgICAgcmVuZGVyZXI6IGdldExpbmVGaWx0ZXJSZW5kZXJlcignfD0nKSxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKG9wKSA9PiBgUmV0dXJuIGxvZyBsaW5lcyB0aGF0IGNvbnRhaW4gc3RyaW5nIFxcYCR7b3AucGFyYW1zWzBdfVxcYC5gLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5MaW5lQ29udGFpbnNOb3QsXG4gICAgICBuYW1lOiAnTGluZSBkb2VzIG5vdCBjb250YWluJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1N0cmluZycsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgaGlkZU5hbWU6IHRydWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICdUZXh0IHRvIGV4Y2x1ZGUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmluZCBsb2cgbGluZXMgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoaXMgdGV4dCcsXG4gICAgICAgICAgbWluV2lkdGg6IDI2LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJ10sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdsaW5lIGZpbHRlcicsXG4gICAgICBjYXRlZ29yeTogTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuTGluZUZpbHRlcnMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MaW5lRmlsdGVycyxcbiAgICAgIHJlbmRlcmVyOiBnZXRMaW5lRmlsdGVyUmVuZGVyZXIoJyE9JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRMb2tpT3BlcmF0aW9uLFxuICAgICAgZXhwbGFpbkhhbmRsZXI6IChvcCkgPT4gYFJldHVybiBsb2cgbGluZXMgdGhhdCBkb2VzIG5vdCBjb250YWluIHN0cmluZyBcXGAke29wLnBhcmFtc1swXX1cXGAuYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTGluZU1hdGNoZXNSZWdleCxcbiAgICAgIG5hbWU6ICdMaW5lIGNvbnRhaW5zIHJlZ2V4IG1hdGNoJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1JlZ2V4JyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBoaWRlTmFtZTogdHJ1ZSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJ1BhdHRlcm4gdG8gbWF0Y2gnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmluZCBsb2cgbGluZXMgdGhhdCBtYXRjaCB0aGlzIHJlZ2V4IHBhdHRlcm4nLFxuICAgICAgICAgIG1pbldpZHRoOiAzMCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnbGluZSBmaWx0ZXInLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxpbmVGaWx0ZXJzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGluZUZpbHRlcnMsXG4gICAgICByZW5kZXJlcjogZ2V0TGluZUZpbHRlclJlbmRlcmVyKCd8ficpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAob3ApID0+IGBSZXR1cm4gbG9nIGxpbmVzIHRoYXQgbWF0Y2ggcmVnZXggXFxgJHtvcC5wYXJhbXNbMF19XFxgLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxpbmVNYXRjaGVzUmVnZXhOb3QsXG4gICAgICBuYW1lOiAnTGluZSBkb2VzIG5vdCBtYXRjaCByZWdleCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdSZWdleCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgaGlkZU5hbWU6IHRydWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICdQYXR0ZXJuIHRvIGV4Y2x1ZGUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmluZCBsb2cgbGluZXMgdGhhdCBkb2VzIG5vdCBtYXRjaCB0aGlzIHJlZ2V4IHBhdHRlcm4nLFxuICAgICAgICAgIG1pbldpZHRoOiAzMCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnbGluZSBmaWx0ZXInLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxpbmVGaWx0ZXJzLFxuICAgICAgb3JkZXJSYW5rOiBMb2tpT3BlcmF0aW9uT3JkZXIuTGluZUZpbHRlcnMsXG4gICAgICByZW5kZXJlcjogZ2V0TGluZUZpbHRlclJlbmRlcmVyKCchficpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAob3ApID0+IGBSZXR1cm4gbG9nIGxpbmVzIHRoYXQgZG9lcyBub3QgbWF0Y2ggcmVnZXggXFxgJHtvcC5wYXJhbXNbMF19XFxgLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLkxhYmVsRmlsdGVyLFxuICAgICAgbmFtZTogJ0xhYmVsIGZpbHRlciBleHByZXNzaW9uJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7IG5hbWU6ICdMYWJlbCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsgbmFtZTogJ09wZXJhdG9yJywgdHlwZTogJ3N0cmluZycsIG9wdGlvbnM6IFsnPScsICchPScsICc+JywgJzwnLCAnPj0nLCAnPD0nXSB9LFxuICAgICAgICB7IG5hbWU6ICdWYWx1ZScsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnLCAnPScsICcnXSxcbiAgICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5MYWJlbEZpbHRlcnMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5MYWJlbEZpbHRlcnMsXG4gICAgICByZW5kZXJlcjogbGFiZWxGaWx0ZXJSZW5kZXJlcixcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT4gYExhYmVsIGV4cHJlc3Npb24gZmlsdGVyIGFsbG93cyBmaWx0ZXJpbmcgdXNpbmcgb3JpZ2luYWwgYW5kIGV4dHJhY3RlZCBsYWJlbHMuYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBMb2tpT3BlcmF0aW9uSWQuTGFiZWxGaWx0ZXJOb0Vycm9ycyxcbiAgICAgIG5hbWU6ICdObyBwaXBlbGluZSBlcnJvcnMnLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFtdLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkxhYmVsRmlsdGVycyxcbiAgICAgIG9yZGVyUmFuazogTG9raU9wZXJhdGlvbk9yZGVyLk5vRXJyb3JzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGAke2lubmVyRXhwcn0gfCBfX2Vycm9yX189XFxgXFxgYCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgICBleHBsYWluSGFuZGxlcjogKCkgPT4gYEZpbHRlciBvdXQgYWxsIGZvcm1hdHRpbmcgYW5kIHBhcnNpbmcgZXJyb3JzLmAsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogTG9raU9wZXJhdGlvbklkLlVud3JhcCxcbiAgICAgIG5hbWU6ICdVbndyYXAnLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnSWRlbnRpZmllcicsIHR5cGU6ICdzdHJpbmcnLCBoaWRlTmFtZTogdHJ1ZSwgbWluV2lkdGg6IDE2LCBwbGFjZWhvbGRlcjogJ0xhYmVsIGtleScgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZvcm1hdHMsXG4gICAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5VbndyYXAsXG4gICAgICByZW5kZXJlcjogKG9wLCBkZWYsIGlubmVyRXhwcikgPT4gYCR7aW5uZXJFeHByfSB8IHVud3JhcCAke29wLnBhcmFtc1swXX1gLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTG9raU9wZXJhdGlvbixcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiAob3ApID0+IHtcbiAgICAgICAgbGV0IGxhYmVsID0gU3RyaW5nKG9wLnBhcmFtc1swXSkubGVuZ3RoID4gMCA/IG9wLnBhcmFtc1swXSA6ICc8bGFiZWw+JztcbiAgICAgICAgcmV0dXJuIGBVc2UgdGhlIGV4dHJhY3RlZCBsYWJlbCBcXGAke2xhYmVsfVxcYCBhcyBzYW1wbGUgdmFsdWVzIGluc3RlYWQgb2YgbG9nIGxpbmVzIGZvciB0aGUgc3Vic2VxdWVudCByYW5nZSBhZ2dyZWdhdGlvbi5gO1xuICAgICAgfSxcbiAgICB9LFxuICAgIC4uLmJpbmFyeVNjYWxhck9wZXJhdGlvbnMsXG4gICAge1xuICAgICAgaWQ6IExva2lPcGVyYXRpb25JZC5OZXN0ZWRRdWVyeSxcbiAgICAgIG5hbWU6ICdCaW5hcnkgb3BlcmF0aW9uIHdpdGggcXVlcnknLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFtdLFxuICAgICAgY2F0ZWdvcnk6IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwsIGRlZiwgaW5uZXJFeHByKSA9PiBpbm5lckV4cHIsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGROZXN0ZWRRdWVyeUhhbmRsZXIsXG4gICAgfSxcbiAgXTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmFuZ2VPcGVyYXRpb24obmFtZTogc3RyaW5nKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHtcbiAgY29uc3QgcGFyYW1zID0gW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYoKV07XG4gIGNvbnN0IGRlZmF1bHRQYXJhbXMgPSBbJyRfX2ludGVydmFsJ107XG4gIGxldCByZW5kZXJlciA9IG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyO1xuXG4gIGlmIChuYW1lID09PSBMb2tpT3BlcmF0aW9uSWQuUXVhbnRpbGVPdmVyVGltZSkge1xuICAgIGRlZmF1bHRQYXJhbXMucHVzaCgnMC45NScpO1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIG5hbWU6ICdRdWFudGlsZScsXG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICB9KTtcbiAgICByZW5kZXJlciA9IG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyQW5kUGFyYW07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBuYW1lLFxuICAgIG5hbWU6IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUobmFtZSksXG4gICAgcGFyYW1zLFxuICAgIGRlZmF1bHRQYXJhbXMsXG4gICAgYWx0ZXJuYXRpdmVzS2V5OiAncmFuZ2UgZnVuY3Rpb24nLFxuICAgIGNhdGVnb3J5OiBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICBvcmRlclJhbms6IExva2lPcGVyYXRpb25PcmRlci5SYW5nZVZlY3RvckZ1bmN0aW9uLFxuICAgIHJlbmRlcmVyLFxuICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZExva2lPcGVyYXRpb24sXG4gICAgZXhwbGFpbkhhbmRsZXI6IChvcCwgZGVmKSA9PiB7XG4gICAgICBsZXQgb3BEb2NzID0gRlVOQ1RJT05TLmZpbmQoKHgpID0+IHguaW5zZXJ0VGV4dCA9PT0gb3AuaWQpPy5kb2N1bWVudGF0aW9uID8/ICcnO1xuXG4gICAgICBpZiAob3AucGFyYW1zWzBdID09PSAnJF9faW50ZXJ2YWwnKSB7XG4gICAgICAgIHJldHVybiBgJHtvcERvY3N9IFxcYCRfX2ludGVydmFsXFxgIGlzIHZhcmlhYmxlIHRoYXQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgY2FsY3VsYXRlZCBpbnRlcnZhbCBiYXNlZCBvbiAqKk1heCBkYXRhIHBvaW50cyoqLCAgKipNaW4gaW50ZXJ2YWwqKiBhbmQgcXVlcnkgdGltZSByYW5nZS4gWW91IGZpbmQgdGhlc2Ugb3B0aW9ucyB5b3UgZmluZCB1bmRlciAqKlF1ZXJ5IG9wdGlvbnMqKiBhdCB0aGUgcmlnaHQgb2YgdGhlIGRhdGEgc291cmNlIHNlbGVjdCBkcm9wZG93bi5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke29wRG9jc30gVGhlIFtyYW5nZSB2ZWN0b3JdKGh0dHBzOi8vZ3JhZmFuYS5jb20vZG9jcy9sb2tpL2xhdGVzdC9sb2dxbC9tZXRyaWNfcXVlcmllcy8jcmFuZ2UtdmVjdG9yLWFnZ3JlZ2F0aW9uKSBpcyBzZXQgdG8gXFxgJHtvcC5wYXJhbXNbMF19XFxgLmA7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1JhbmdlJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25zOiBbJyRfX2ludGVydmFsJywgJyRfX3JhbmdlJywgJzFtJywgJzVtJywgJzEwbScsICcxaCcsICcyNGgnXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIGxldCByYW5nZVZlY3RvciA9IChtb2RlbC5wYXJhbXMgPz8gW10pWzBdID8/ICckX19pbnRlcnZhbCc7XG4gIHJldHVybiBgJHtkZWYuaWR9KCR7aW5uZXJFeHByfSBbJHtyYW5nZVZlY3Rvcn1dKWA7XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyQW5kUGFyYW0oXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHBhcmFtcyA9IG1vZGVsLnBhcmFtcyA/PyBbXTtcbiAgY29uc3QgcmFuZ2VWZWN0b3IgPSBwYXJhbXNbMF0gPz8gJyRfX2ludGVydmFsJztcbiAgY29uc3QgcGFyYW0gPSBwYXJhbXNbMV07XG4gIHJldHVybiBgJHtkZWYuaWR9KCR7cGFyYW19LCAke2lubmVyRXhwcn0gWyR7cmFuZ2VWZWN0b3J9XSlgO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lRmlsdGVyUmVuZGVyZXIob3BlcmF0aW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmVGaWx0ZXJSZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICBpZiAobW9kZWwucGFyYW1zWzBdID09PSAnJykge1xuICAgICAgcmV0dXJuIGlubmVyRXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIGAke2lubmVyRXhwcn0gJHtvcGVyYXRpb259IFxcYCR7bW9kZWwucGFyYW1zWzBdfVxcYGA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxhYmVsRmlsdGVyUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gIGlmIChtb2RlbC5wYXJhbXNbMF0gPT09ICcnKSB7XG4gICAgcmV0dXJuIGlubmVyRXhwcjtcbiAgfVxuXG4gIGlmIChtb2RlbC5wYXJhbXNbMV0gPT09ICc8JyB8fCBtb2RlbC5wYXJhbXNbMV0gPT09ICc+Jykge1xuICAgIHJldHVybiBgJHtpbm5lckV4cHJ9IHwgJHttb2RlbC5wYXJhbXNbMF19ICR7bW9kZWwucGFyYW1zWzFdfSAke21vZGVsLnBhcmFtc1syXX1gO1xuICB9XG5cbiAgcmV0dXJuIGAke2lubmVyRXhwcn0gfCAke21vZGVsLnBhcmFtc1swXX0ke21vZGVsLnBhcmFtc1sxXX1cXGAke21vZGVsLnBhcmFtc1syXX1cXGBgO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZVJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICByZXR1cm4gYCR7aW5uZXJFeHByfSB8ICR7bW9kZWwuaWR9YDtcbn1cblxuZnVuY3Rpb24gaXNSYW5nZVZlY3RvckZ1bmN0aW9uKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmKSB7XG4gIHJldHVybiBkZWYuY2F0ZWdvcnkgPT09IExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleE9mT3JMYXN0KFxuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXSxcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcixcbiAgY29uZGl0aW9uOiAoZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCBpbmRleCA9IG9wZXJhdGlvbnMuZmluZEluZGV4KCh4KSA9PiB7XG4gICAgY29uc3Qgb3BEZWYgPSBxdWVyeU1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZih4LmlkKTtcbiAgICBpZiAoIW9wRGVmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb24ob3BEZWYpO1xuICB9KTtcblxuICByZXR1cm4gaW5kZXggPT09IC0xID8gb3BlcmF0aW9ucy5sZW5ndGggOiBpbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExva2lPcGVyYXRpb24oXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5LFxuICBtb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlclxuKTogTG9raVZpc3VhbFF1ZXJ5IHtcbiAgY29uc3QgbmV3T3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBwYXJhbXM6IGRlZi5kZWZhdWx0UGFyYW1zLFxuICB9O1xuXG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBbLi4ucXVlcnkub3BlcmF0aW9uc107XG5cbiAgY29uc3QgZXhpc3RpbmdSYW5nZVZlY3RvckZ1bmN0aW9uID0gb3BlcmF0aW9ucy5maW5kKCh4KSA9PiB7XG4gICAgY29uc3Qgb3BEZWYgPSBtb2RlbGxlci5nZXRPcGVyYXRpb25EZWYoeC5pZCk7XG4gICAgaWYgKCFvcERlZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNSYW5nZVZlY3RvckZ1bmN0aW9uKG9wRGVmKTtcbiAgfSk7XG5cbiAgc3dpdGNoIChkZWYuY2F0ZWdvcnkpIHtcbiAgICBjYXNlIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkFnZ3JlZ2F0aW9uczpcbiAgICBjYXNlIExva2lWaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9uczpcbiAgICAgIC8vIElmIHdlIGFyZSBhZGRpbmcgYSBmdW5jdGlvbiBidXQgd2UgaGF2ZSBub3QgcmFuZ2UgdmVjdG9yIGZ1bmN0aW9uIHlldCBhZGQgb25lXG4gICAgICBpZiAoIWV4aXN0aW5nUmFuZ2VWZWN0b3JGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwbGFjZVRvSW5zZXJ0ID0gZ2V0SW5kZXhPZk9yTGFzdChcbiAgICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICAgIG1vZGVsbGVyLFxuICAgICAgICAgIChkZWYpID0+IGRlZi5jYXRlZ29yeSA9PT0gTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zXG4gICAgICAgICk7XG4gICAgICAgIG9wZXJhdGlvbnMuc3BsaWNlKHBsYWNlVG9JbnNlcnQsIDAsIHsgaWQ6IExva2lPcGVyYXRpb25JZC5SYXRlLCBwYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSB9KTtcbiAgICAgIH1cbiAgICAgIG9wZXJhdGlvbnMucHVzaChuZXdPcGVyYXRpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9uczpcbiAgICAgIC8vIElmIGFkZGluZyBhIHJhbmdlIGZ1bmN0aW9uIGFuZCByYW5nZSBmdW5jdGlvbiBpcyBhbHJlYWR5IGFkZGVkIHJlcGxhY2UgaXRcbiAgICAgIGlmIChleGlzdGluZ1JhbmdlVmVjdG9yRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvcGVyYXRpb25zLmluZGV4T2YoZXhpc3RpbmdSYW5nZVZlY3RvckZ1bmN0aW9uKTtcbiAgICAgICAgb3BlcmF0aW9uc1tpbmRleF0gPSBuZXdPcGVyYXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gQWRkIHJhbmdlIGZ1bmN0aW9ucyBhZnRlciBhbnkgZm9ybWF0cywgbGluZSBmaWx0ZXJzIGFuZCBsYWJlbCBmaWx0ZXJzXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnN0IHBsYWNlVG9JbnNlcnQgPSBnZXRJbmRleE9mT3JMYXN0KFxuICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICBtb2RlbGxlcixcbiAgICAgICAgKHgpID0+IChkZWYub3JkZXJSYW5rID8/IDEwMCkgPCAoeC5vcmRlclJhbmsgPz8gMTAwKVxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvbnMuc3BsaWNlKHBsYWNlVG9JbnNlcnQsIDAsIG5ld09wZXJhdGlvbik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgb3BlcmF0aW9ucyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTmVzdGVkUXVlcnlIYW5kbGVyKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBxdWVyeTogTG9raVZpc3VhbFF1ZXJ5KTogTG9raVZpc3VhbFF1ZXJ5IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5xdWVyeSxcbiAgICBiaW5hcnlRdWVyaWVzOiBbXG4gICAgICAuLi4ocXVlcnkuYmluYXJ5UXVlcmllcyA/PyBbXSksXG4gICAgICB7XG4gICAgICAgIG9wZXJhdG9yOiAnLycsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnQGdyYWZhbmEvbGV6ZXItbG9ncWwnO1xuaW1wb3J0IHsgU3ludGF4Tm9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHtcbiAgRXJyb3JOYW1lLFxuICBnZXRBbGxCeVR5cGUsXG4gIGdldExlZnRNb3N0Q2hpbGQsXG4gIGdldFN0cmluZyxcbiAgbWFrZUJpbk9wLFxuICBtYWtlRXJyb3IsXG4gIHJlcGxhY2VWYXJpYWJsZXMsXG59IGZyb20gJy4uLy4uL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9wYXJzaW5nVXRpbHMnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB9IGZyb20gJy4uLy4uL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBiaW5hcnlTY2FsYXJEZWZzIH0gZnJvbSAnLi9iaW5hcnlTY2FsYXJPcGVyYXRpb25zJztcbmltcG9ydCB7IExva2lWaXN1YWxRdWVyeSwgTG9raVZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmludGVyZmFjZSBDb250ZXh0IHtcbiAgcXVlcnk6IExva2lWaXN1YWxRdWVyeTtcbiAgZXJyb3JzOiBQYXJzaW5nRXJyb3JbXTtcbn1cblxuaW50ZXJmYWNlIFBhcnNpbmdFcnJvciB7XG4gIHRleHQ6IHN0cmluZztcbiAgZnJvbT86IG51bWJlcjtcbiAgdG8/OiBudW1iZXI7XG4gIHBhcmVudFR5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhleHByOiBzdHJpbmcpOiBDb250ZXh0IHtcbiAgY29uc3QgcmVwbGFjZWRFeHByID0gcmVwbGFjZVZhcmlhYmxlcyhleHByKTtcbiAgY29uc3QgdHJlZSA9IHBhcnNlci5wYXJzZShyZXBsYWNlZEV4cHIpO1xuICBjb25zdCBub2RlID0gdHJlZS50b3BOb2RlO1xuXG4gIC8vIFRoaXMgd2lsbCBiZSBtb2RpZmllZCBpbiB0aGUgaGFuZGxlRXhwcmVzc2lvblxuICBjb25zdCB2aXNRdWVyeTogTG9raVZpc3VhbFF1ZXJ5ID0ge1xuICAgIGxhYmVsczogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gIH07XG5cbiAgY29uc3QgY29udGV4dDogQ29udGV4dCA9IHtcbiAgICBxdWVyeTogdmlzUXVlcnksXG4gICAgZXJyb3JzOiBbXSxcbiAgfTtcblxuICB0cnkge1xuICAgIGhhbmRsZUV4cHJlc3Npb24ocmVwbGFjZWRFeHByLCBub2RlLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gTm90IGlkZWFsIHRvIGxvZyBpdCBoZXJlLCBidXQgb3RoZXJ3aXNlIHdlIHdvdWxkIGxvc2UgdGhlIHN0YWNrIHRyYWNlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBjb250ZXh0LmVycm9ycy5wdXNoKHtcbiAgICAgIHRleHQ6IGVyci5tZXNzYWdlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBlbXB0eSBxdWVyeSwgd2Ugd2FudCB0byByZXNldCBlcnJvcnNcbiAgaWYgKGlzRW1wdHlRdWVyeShjb250ZXh0LnF1ZXJ5KSkge1xuICAgIGNvbnRleHQuZXJyb3JzID0gW107XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVFeHByZXNzaW9uKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSwgY29udGV4dDogQ29udGV4dCkge1xuICBjb25zdCB2aXNRdWVyeSA9IGNvbnRleHQucXVlcnk7XG4gIHN3aXRjaCAobm9kZS5uYW1lKSB7XG4gICAgY2FzZSAnTWF0Y2hlcic6IHtcbiAgICAgIHZpc1F1ZXJ5LmxhYmVscy5wdXNoKGdldExhYmVsKGV4cHIsIG5vZGUpKTtcbiAgICAgIGNvbnN0IGVyciA9IG5vZGUuZ2V0Q2hpbGQoRXJyb3JOYW1lKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgZXJyKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMaW5lRmlsdGVyJzoge1xuICAgICAgY29uc3QgeyBvcGVyYXRpb24sIGVycm9yIH0gPSBnZXRMaW5lRmlsdGVyKGV4cHIsIG5vZGUpO1xuICAgICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIFNob3cgZXJyb3IgZm9yIHF1ZXJ5IHBhdHRlcm5zIG5vdCBzdXBwb3J0ZWQgaW4gdmlzdWFsIHF1ZXJ5IGJ1aWxkZXJcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGNyZWF0ZU5vdFN1cHBvcnRlZEVycm9yKGV4cHIsIG5vZGUsIGVycm9yKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbFBhcnNlcic6IHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChnZXRMYWJlbFBhcnNlcihleHByLCBub2RlKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbEZpbHRlcic6IHtcbiAgICAgIGNvbnN0IHsgb3BlcmF0aW9uLCBlcnJvciB9ID0gZ2V0TGFiZWxGaWx0ZXIoZXhwciwgbm9kZSk7XG4gICAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gU2hvdyBlcnJvciBmb3IgcXVlcnkgcGF0dGVybnMgbm90IHN1cHBvcnRlZCBpbiB2aXN1YWwgcXVlcnkgYnVpbGRlclxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoZXhwciwgbm9kZSwgZXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0pzb25FeHByZXNzaW9uUGFyc2VyJzoge1xuICAgICAgLy8gSnNvbkV4cHJlc3Npb25QYXJzZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBxdWVyeSBidWlsZGVyXG4gICAgICBjb25zdCBlcnJvciA9ICdKc29uRXhwcmVzc2lvblBhcnNlciBub3Qgc3VwcG9ydGVkIGluIHZpc3VhbCBxdWVyeSBidWlsZGVyJztcblxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcihleHByLCBub2RlLCBlcnJvcikpO1xuICAgIH1cblxuICAgIGNhc2UgJ0xpbmVGb3JtYXRFeHByJzoge1xuICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKGdldExpbmVGb3JtYXQoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTGFiZWxGb3JtYXRNYXRjaGVyJzoge1xuICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKGdldExhYmVsRm9ybWF0KGV4cHIsIG5vZGUpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1Vud3JhcEV4cHInOiB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbiwgZXJyb3IgfSA9IGdldFVud3JhcChleHByLCBub2RlKTtcbiAgICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgICAvLyBTaG93IGVycm9yIGZvciBxdWVyeSBwYXR0ZXJucyBub3Qgc3VwcG9ydGVkIGluIHZpc3VhbCBxdWVyeSBidWlsZGVyXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChjcmVhdGVOb3RTdXBwb3J0ZWRFcnJvcihleHByLCBub2RlLCBlcnJvcikpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdSYW5nZUFnZ3JlZ2F0aW9uRXhwcic6IHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChoYW5kbGVSYW5nZUFnZ3JlZ2F0aW9uKGV4cHIsIG5vZGUsIGNvbnRleHQpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1ZlY3RvckFnZ3JlZ2F0aW9uRXhwcic6IHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChoYW5kbGVWZWN0b3JBZ2dyZWdhdGlvbihleHByLCBub2RlLCBjb250ZXh0KSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdCaW5PcEV4cHInOiB7XG4gICAgICBoYW5kbGVCaW5hcnkoZXhwciwgbm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEVycm9yTmFtZToge1xuICAgICAgaWYgKGlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yKG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgLy8gQW55IG90aGVyIG5vZGVzIHdlIGp1c3QgaWdub3JlIGFuZCBnbyB0byBpdCdzIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSBmaW5lIGFzIHRoZXJlIGFyZSBsb3QncyBvZiB3cmFwcGVyXG4gICAgICAvLyBub2RlcyB0aGF0IGNhbiBiZSBza2lwcGVkLlxuICAgICAgLy8gVE9ETzogdGhlcmUgYXJlIHByb2JhYmx5IGNhc2VzIHdoZXJlIHdlIHdpbGwganVzdCBza2lwIG5vZGVzIHdlIGRvbid0IHN1cHBvcnQgYW5kIHdlIHNob3VsZCBiZSBhYmxlIHRvXG4gICAgICAvLyAgZGV0ZWN0IHRob3NlIGFuZCByZXBvcnQgYmFjay5cbiAgICAgIGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIGNoaWxkLCBjb250ZXh0KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWwoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBjb25zdCBsYWJlbE5vZGUgPSBub2RlLmdldENoaWxkKCdJZGVudGlmaWVyJyk7XG4gIGNvbnN0IGxhYmVsID0gZ2V0U3RyaW5nKGV4cHIsIGxhYmVsTm9kZSk7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIGxhYmVsTm9kZSEubmV4dFNpYmxpbmcpO1xuICBjb25zdCB2YWx1ZSA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdTdHJpbmcnKSkucmVwbGFjZSgvXCIvZywgJycpO1xuXG4gIHJldHVybiB7XG4gICAgbGFiZWwsXG4gICAgb3AsXG4gICAgdmFsdWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExpbmVGaWx0ZXIoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogeyBvcGVyYXRpb24/OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247IGVycm9yPzogc3RyaW5nIH0ge1xuICAvLyBDaGVjayBmb3Igbm9kZXMgbm90IHN1cHBvcnRlZCBpbiB2aXN1YWwgYnVpbGRlciBhbmQgcmV0dXJuIGVycm9yXG4gIGNvbnN0IGlwTGluZUZpbHRlciA9IGdldEFsbEJ5VHlwZShleHByLCBub2RlLCAnSXAnKTtcbiAgaWYgKGlwTGluZUZpbHRlci5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiAnTWF0Y2hpbmcgaXAgYWRkcmVzc2VzIG5vdCBzdXBwb3J0ZWQgaW4gcXVlcnkgYnVpbGRlcicsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IG1hcEZpbHRlcjogYW55ID0ge1xuICAgICd8PSc6ICdfX2xpbmVfY29udGFpbnMnLFxuICAgICchPSc6ICdfX2xpbmVfY29udGFpbnNfbm90JyxcbiAgICAnfH4nOiAnX19saW5lX21hdGNoZXNfcmVnZXgnLFxuICAgICchfic6ICdcIl9fbGluZV9tYXRjaGVzX3JlZ2V4XCJfbm90JyxcbiAgfTtcbiAgY29uc3QgZmlsdGVyID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ0ZpbHRlcicpKTtcbiAgY29uc3QgZmlsdGVyRXhwciA9IGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgbm9kZS5nZXRDaGlsZCgnU3RyaW5nJykpKTtcblxuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvbjoge1xuICAgICAgaWQ6IG1hcEZpbHRlcltmaWx0ZXJdLFxuICAgICAgcGFyYW1zOiBbZmlsdGVyRXhwcl0sXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWxQYXJzZXIoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uIHtcbiAgY29uc3QgcGFyc2VyTm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgY29uc3QgcGFyc2VyID0gZ2V0U3RyaW5nKGV4cHIsIHBhcnNlck5vZGUpO1xuXG4gIGNvbnN0IHN0cmluZyA9IGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgbm9kZS5nZXRDaGlsZCgnU3RyaW5nJykpKTtcbiAgY29uc3QgcGFyYW1zID0gISFzdHJpbmcgPyBbc3RyaW5nXSA6IFtdO1xuICByZXR1cm4ge1xuICAgIGlkOiBwYXJzZXIsXG4gICAgcGFyYW1zLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbEZpbHRlcihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiB7IG9wZXJhdGlvbj86IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gIC8vIENoZWNrIGZvciBub2RlcyBub3Qgc3VwcG9ydGVkIGluIHZpc3VhbCBidWlsZGVyIGFuZCByZXR1cm4gZXJyb3JcbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ09yJykgfHwgbm9kZS5nZXRDaGlsZCgnQW5kJykgfHwgbm9kZS5nZXRDaGlsZCgnQ29tbWEnKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogJ0xhYmVsIGZpbHRlciB3aXRoIGNvbW1hLCBcImFuZFwiLCBcIm9yXCIgbm90IHN1cHBvcnRlZCBpbiBxdWVyeSBidWlsZGVyJyxcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLmZpcnN0Q2hpbGQhLm5hbWUgPT09ICdJcExhYmVsRmlsdGVyJykge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogJ0lwTGFiZWxGaWx0ZXIgbm90IHN1cHBvcnRlZCBpbiBxdWVyeSBidWlsZGVyJyxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgaWQgPSAnX19sYWJlbF9maWx0ZXInO1xuICBpZiAobm9kZS5maXJzdENoaWxkIS5uYW1lID09PSAnVW5pdEZpbHRlcicpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSBub2RlLmZpcnN0Q2hpbGQhLmZpcnN0Q2hpbGQ7XG4gICAgY29uc3QgbGFiZWwgPSBmaWx0ZXIhLmZpcnN0Q2hpbGQ7XG4gICAgY29uc3Qgb3AgPSBsYWJlbCEubmV4dFNpYmxpbmc7XG4gICAgY29uc3QgdmFsdWUgPSBvcCEubmV4dFNpYmxpbmc7XG4gICAgY29uc3QgdmFsdWVTdHJpbmcgPSBoYW5kbGVRdW90ZXMoZ2V0U3RyaW5nKGV4cHIsIHZhbHVlKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIGlkLFxuICAgICAgICBwYXJhbXM6IFtnZXRTdHJpbmcoZXhwciwgbGFiZWwpLCBnZXRTdHJpbmcoZXhwciwgb3ApLCB2YWx1ZVN0cmluZ10sXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgLy8gSW4gdGhpcyBjYXNlIGl0IGlzIE1hdGNoZXIgb3IgTnVtYmVyRmlsdGVyXG4gIGNvbnN0IGZpbHRlciA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgY29uc3QgbGFiZWwgPSBmaWx0ZXIhLmZpcnN0Q2hpbGQ7XG4gIGNvbnN0IG9wID0gbGFiZWwhLm5leHRTaWJsaW5nO1xuICBjb25zdCB2YWx1ZSA9IG9wIS5uZXh0U2libGluZztcbiAgY29uc3QgcGFyYW1zID0gW2dldFN0cmluZyhleHByLCBsYWJlbCksIGdldFN0cmluZyhleHByLCBvcCksIGhhbmRsZVF1b3RlcyhnZXRTdHJpbmcoZXhwciwgdmFsdWUpKV07XG5cbiAgLy8gU3BlY2lhbCBjYXNlIG9mIHBpcGUgZmlsdGVyaW5nIC0gbm8gZXJyb3JzXG4gIGlmIChwYXJhbXMuam9pbignJykgPT09IGBfX2Vycm9yX189YCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgaWQ6ICdfX2xhYmVsX2ZpbHRlcl9ub19lcnJvcnMnLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIGlkLFxuICAgICAgcGFyYW1zLFxuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExpbmVGb3JtYXQoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uIHtcbiAgY29uc3QgaWQgPSAnbGluZV9mb3JtYXQnO1xuICBjb25zdCBzdHJpbmcgPSBoYW5kbGVRdW90ZXMoZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ1N0cmluZycpKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICBwYXJhbXM6IFtzdHJpbmddLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbEZvcm1hdChleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24ge1xuICBjb25zdCBpZCA9ICdsYWJlbF9mb3JtYXQnO1xuICBjb25zdCBpZGVudGlmaWVyID0gbm9kZS5nZXRDaGlsZCgnSWRlbnRpZmllcicpO1xuICBjb25zdCBvcCA9IGlkZW50aWZpZXIhLm5leHRTaWJsaW5nO1xuICBjb25zdCB2YWx1ZSA9IG9wIS5uZXh0U2libGluZztcblxuICBsZXQgdmFsdWVTdHJpbmcgPSBoYW5kbGVRdW90ZXMoZ2V0U3RyaW5nKGV4cHIsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICBwYXJhbXM6IFtnZXRTdHJpbmcoZXhwciwgaWRlbnRpZmllciksIHZhbHVlU3RyaW5nXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VW53cmFwKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSk6IHsgb3BlcmF0aW9uPzogUXVlcnlCdWlsZGVyT3BlcmF0aW9uOyBlcnJvcj86IHN0cmluZyB9IHtcbiAgLy8gQ2hlY2sgZm9yIG5vZGVzIG5vdCBzdXBwb3J0ZWQgaW4gdmlzdWFsIGJ1aWxkZXIgYW5kIHJldHVybiBlcnJvclxuICBpZiAobm9kZS5nZXRDaGlsZCgnQ29udk9wJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICdVbndyYXAgd2l0aCBjb252ZXJzaW9uIG9wZXJhdG9yIG5vdCBzdXBwb3J0ZWQgaW4gcXVlcnkgYnVpbGRlcicsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGlkID0gJ3Vud3JhcCc7XG4gIGNvbnN0IHN0cmluZyA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdJZGVudGlmaWVyJykpO1xuXG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uOiB7XG4gICAgICBpZCxcbiAgICAgIHBhcmFtczogW3N0cmluZ10sXG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmFuZ2VBZ2dyZWdhdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdSYW5nZU9wJyk7XG4gIGNvbnN0IGZ1bmNOYW1lID0gZ2V0U3RyaW5nKGV4cHIsIG5hbWVOb2RlKTtcbiAgY29uc3QgbnVtYmVyID0gbm9kZS5nZXRDaGlsZCgnTnVtYmVyJyk7XG4gIGNvbnN0IGxvZ0V4cHIgPSBub2RlLmdldENoaWxkKCdMb2dSYW5nZUV4cHInKTtcbiAgY29uc3QgcGFyYW1zID0gbnVtYmVyICE9PSBudWxsICYmIG51bWJlciAhPT0gdW5kZWZpbmVkID8gW2dldFN0cmluZyhleHByLCBudW1iZXIpXSA6IFtdO1xuXG4gIGxldCBtYXRjaCA9IGdldFN0cmluZyhleHByLCBub2RlKS5tYXRjaCgvXFxbKC4rKVxcXS8pO1xuICBpZiAobWF0Y2g/LlsxXSkge1xuICAgIHBhcmFtcy5wdXNoKG1hdGNoWzFdKTtcbiAgfVxuXG4gIGNvbnN0IG9wID0ge1xuICAgIGlkOiBmdW5jTmFtZSxcbiAgICBwYXJhbXMsXG4gIH07XG5cbiAgaWYgKGxvZ0V4cHIpIHtcbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIGxvZ0V4cHIsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG9wO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVWZWN0b3JBZ2dyZWdhdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdWZWN0b3JPcCcpO1xuICBsZXQgZnVuY05hbWUgPSBnZXRTdHJpbmcoZXhwciwgbmFtZU5vZGUpO1xuXG4gIGNvbnN0IGdyb3VwaW5nID0gbm9kZS5nZXRDaGlsZCgnR3JvdXBpbmcnKTtcbiAgY29uc3QgbGFiZWxzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGlmIChncm91cGluZykge1xuICAgIGNvbnN0IGJ5TW9kaWZpZXIgPSBncm91cGluZy5nZXRDaGlsZChgQnlgKTtcbiAgICBpZiAoYnlNb2RpZmllciAmJiBmdW5jTmFtZSkge1xuICAgICAgZnVuY05hbWUgPSBgX18ke2Z1bmNOYW1lfV9ieWA7XG4gICAgfVxuXG4gICAgY29uc3Qgd2l0aG91dE1vZGlmaWVyID0gZ3JvdXBpbmcuZ2V0Q2hpbGQoYFdpdGhvdXRgKTtcbiAgICBpZiAod2l0aG91dE1vZGlmaWVyKSB7XG4gICAgICBmdW5jTmFtZSA9IGBfXyR7ZnVuY05hbWV9X3dpdGhvdXRgO1xuICAgIH1cblxuICAgIGxhYmVscy5wdXNoKC4uLmdldEFsbEJ5VHlwZShleHByLCBncm91cGluZywgJ0lkZW50aWZpZXInKSk7XG4gIH1cblxuICBjb25zdCBtZXRyaWNFeHByID0gbm9kZS5nZXRDaGlsZCgnTWV0cmljRXhwcicpO1xuICBjb25zdCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyBpZDogZnVuY05hbWUsIHBhcmFtczogbGFiZWxzIH07XG5cbiAgaWYgKG1ldHJpY0V4cHIpIHtcbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIG1ldHJpY0V4cHIsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG9wO1xufVxuXG5jb25zdCBvcGVyYXRvclRvT3BOYW1lID0gYmluYXJ5U2NhbGFyRGVmcy5yZWR1Y2UoKGFjYywgZGVmKSA9PiB7XG4gIGFjY1tkZWYuc2lnbl0gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBjb21wYXJpc29uOiBkZWYuY29tcGFyaXNvbixcbiAgfTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfT4pO1xuXG4vKipcbiAqIFJpZ2h0IG5vdyBiaW5hcnkgZXhwcmVzc2lvbnMgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5IGluIHZpc3VhbCBxdWVyeS4gQXMgYWRkaXRpb25hbCBvcGVyYXRpb24gaW4gY2FzZSBpdCBpc1xuICoganVzdCBvcGVyYXRpb24gd2l0aCBzY2FsYXIgb3IgaXQgY3JlYXRlcyBhIGJpbmFyeVF1ZXJ5IHdoZW4gaXQncyAyIHF1ZXJpZXMuXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUJpbmFyeShleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBsZWZ0ID0gbm9kZS5maXJzdENoaWxkITtcbiAgY29uc3Qgb3AgPSBnZXRTdHJpbmcoZXhwciwgbGVmdC5uZXh0U2libGluZyk7XG4gIGNvbnN0IGJpbk1vZGlmaWVyID0gZ2V0QmluYXJ5TW9kaWZpZXIoZXhwciwgbm9kZS5nZXRDaGlsZCgnQmluTW9kaWZpZXJzJykpO1xuXG4gIGNvbnN0IHJpZ2h0ID0gbm9kZS5sYXN0Q2hpbGQhO1xuXG4gIGNvbnN0IG9wRGVmID0gb3BlcmF0b3JUb09wTmFtZVtvcF07XG5cbiAgY29uc3QgbGVmdE51bWJlciA9IGdldExhc3RDaGlsZFdpdGhTZWxlY3RvcihsZWZ0LCAnTWV0cmljRXhwci5MaXRlcmFsRXhwci5OdW1iZXInKTtcbiAgY29uc3QgcmlnaHROdW1iZXIgPSBnZXRMYXN0Q2hpbGRXaXRoU2VsZWN0b3IocmlnaHQsICdNZXRyaWNFeHByLkxpdGVyYWxFeHByLk51bWJlcicpO1xuXG4gIGNvbnN0IHJpZ2h0QmluYXJ5ID0gcmlnaHQuZ2V0Q2hpbGQoJ0Jpbk9wRXhwcicpO1xuXG4gIGlmIChsZWZ0TnVtYmVyKSB7XG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgYWxyZWFkeSBoYW5kbGVkIGluIGNhc2UgcGFyZW50IGlzIGJpbmFyeSBleHByZXNzaW9uIGFzIGl0IGhhcyB0byBiZSBhZGRlZCB0byBwYXJlbnRcbiAgICAvLyAgaWYgcXVlcnkgc3RhcnRzIHdpdGggYSBudW1iZXIgdGhhdCBpc24ndCBoYW5kbGVkIG5vdy5cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGlzIGlzIGJpbmFyeSB3ZSBkb24ndCByZWFsbHkga25vdyBpZiB0aGVyZSBpcyBhIHF1ZXJ5IG9yIGp1c3QgY2hhaW5lZCBzY2FsYXJzLiBTb1xuICAgIC8vIHdlIGhhdmUgdG8gdHJhdmVyc2UgYSBiaXQgZGVlcGVyIHRvIGtub3dcbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIGxlZnQsIGNvbnRleHQpO1xuICB9XG5cbiAgaWYgKHJpZ2h0TnVtYmVyKSB7XG4gICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKG1ha2VCaW5PcChvcERlZiwgZXhwciwgcmlnaHQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICB9IGVsc2UgaWYgKHJpZ2h0QmluYXJ5KSB7XG4gICAgLy8gRHVlIHRvIHRoZSB3YXkgYmluYXJ5IG9wcyBhcmUgcGFyc2VkIHdlIGNhbiBnZXQgYSBiaW5hcnkgb3BlcmF0aW9uIG9uIHRoZSByaWdodCB0aGF0IHN0YXJ0cyB3aXRoIGEgbnVtYmVyIHdoaWNoXG4gICAgLy8gaXMgYSBmYWN0b3IgZm9yIGEgY3VycmVudCBiaW5hcnkgb3BlcmF0aW9uLiBTbyB3ZSBoYXZlIHRvIGFkZCBpdCBhcyBhbiBvcGVyYXRpb24gbm93LlxuICAgIGNvbnN0IGxlZnRNb3N0Q2hpbGQgPSBnZXRMZWZ0TW9zdENoaWxkKHJpZ2h0KTtcbiAgICBpZiAobGVmdE1vc3RDaGlsZD8ubmFtZSA9PT0gJ051bWJlcicpIHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChtYWtlQmluT3Aob3BEZWYsIGV4cHIsIGxlZnRNb3N0Q2hpbGQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFkZGVkIHRoZSBmaXJzdCBudW1iZXIgbGl0ZXJhbCBhcyBvcGVyYXRpb24gaGVyZSB3ZSBzdGlsbCBjYW4gY29udGludWUgYW5kIGhhbmRsZSB0aGUgcmVzdCBhcyB0aGUgZmlyc3RcbiAgICAvLyBudW1iZXIgd2lsbCBiZSBqdXN0IHNraXBwZWQuXG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmlzUXVlcnkuYmluYXJ5UXVlcmllcyA9IHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMgfHwgW107XG4gICAgY29uc3QgYmluUXVlcnk6IExva2lWaXN1YWxRdWVyeUJpbmFyeSA9IHtcbiAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChiaW5Nb2RpZmllcj8uaXNNYXRjaGVyKSB7XG4gICAgICBiaW5RdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSA9IGJpbk1vZGlmaWVyLm1hdGNoVHlwZTtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXMgPSBiaW5Nb2RpZmllci5tYXRjaGVzO1xuICAgIH1cbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzLnB1c2goYmluUXVlcnkpO1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgcmlnaHQsIHtcbiAgICAgIHF1ZXJ5OiBiaW5RdWVyeS5xdWVyeSxcbiAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TW9kaWZpZXIoXG4gIGV4cHI6IHN0cmluZyxcbiAgbm9kZTogU3ludGF4Tm9kZSB8IG51bGxcbik6XG4gIHwgeyBpc0Jvb2w6IHRydWU7IGlzTWF0Y2hlcjogZmFsc2UgfVxuICB8IHsgaXNCb29sOiBmYWxzZTsgaXNNYXRjaGVyOiB0cnVlOyBtYXRjaGVzOiBzdHJpbmc7IG1hdGNoVHlwZTogJ2lnbm9yaW5nJyB8ICdvbicgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ0Jvb2wnKSkge1xuICAgIHJldHVybiB7IGlzQm9vbDogdHJ1ZSwgaXNNYXRjaGVyOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoZXIgPSBub2RlLmdldENoaWxkKCdPbk9ySWdub3JpbmcnKTtcbiAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgdGhpcyBjb3VsZCBiZSwgbWF5YmUgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gZ2V0U3RyaW5nKGV4cHIsIG1hdGNoZXIuZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxzJyk/LmdldENoaWxkKCdHcm91cGluZ0xhYmVsTGlzdCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaGVyOiB0cnVlLFxuICAgICAgaXNCb29sOiBmYWxzZSxcbiAgICAgIG1hdGNoZXM6IGxhYmVscyxcbiAgICAgIG1hdGNoVHlwZTogbWF0Y2hlci5nZXRDaGlsZCgnT24nKSA/ICdvbicgOiAnaWdub3JpbmcnLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3Iobm9kZTogU3ludGF4Tm9kZSkge1xuICByZXR1cm4gbm9kZT8ucGFyZW50Py5uYW1lID09PSAnUmFuZ2UnO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVRdW90ZXMoc3RyaW5nOiBzdHJpbmcpIHtcbiAgaWYgKHN0cmluZ1swXSA9PT0gYFwiYCAmJiBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSBgXCJgKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cIi9nLCAnJykucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL2AvZywgJycpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBoZWxwZXIgdG8gdHJhdmVyc2UgdGhlIHN5bnRheCB0cmVlLiBJbnN0ZWFkIG9mIG5vZGUuZ2V0Q2hpbGQoJ2ZvbycpPy5nZXRDaGlsZCgnYmFyJyk/LmdldENoaWxkKCdiYXonKSB5b3VcbiAqIGNhbiB3cml0ZSBnZXRDaGlsZFdpdGhTZWxlY3Rvcihub2RlLCAnZm9vLmJhci5iYXonKVxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBzZWxlY3RvclxuICovXG5mdW5jdGlvbiBnZXRMYXN0Q2hpbGRXaXRoU2VsZWN0b3Iobm9kZTogU3ludGF4Tm9kZSwgc2VsZWN0b3I6IHN0cmluZykge1xuICBsZXQgY2hpbGQ6IFN5bnRheE5vZGUgfCBudWxsID0gbm9kZTtcbiAgY29uc3QgY2hpbGRyZW4gPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xuICBmb3IgKGNvbnN0IHMgb2YgY2hpbGRyZW4pIHtcbiAgICBjaGlsZCA9IGNoaWxkLmdldENoaWxkKHMpO1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGVucmljaCBlcnJvciB0ZXh0IHdpdGggaW5mb3JtYXRpb24gdGhhdCB2aXN1YWwgcXVlcnkgYnVpbGRlciBkb2Vzbid0IHN1cHBvcnQgdGhhdCBsb2dRTFxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gZXJyb3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBlcnJvcjogc3RyaW5nKSB7XG4gIGNvbnN0IGVyciA9IG1ha2VFcnJvcihleHByLCBub2RlKTtcbiAgZXJyLnRleHQgPSBgJHtlcnJvcn06ICR7ZXJyLnRleHR9YDtcbiAgcmV0dXJuIGVycjtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVF1ZXJ5KHF1ZXJ5OiBMb2tpVmlzdWFsUXVlcnkpIHtcbiAgaWYgKHF1ZXJ5LmxhYmVscy5sZW5ndGggPT09IDAgJiYgcXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgc3RvcmUgZnJvbSAnYXBwL2NvcmUvc3RvcmUnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IExva2lRdWVyeSwgTG9raVF1ZXJ5VHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgcXVlcnlFZGl0b3JNb2RlRGVmYXVsdExvY2FsU3RvcmFnZUtleSA9ICdMb2tpUXVlcnlFZGl0b3JNb2RlRGVmYXVsdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VFZGl0b3JNb2RlKHF1ZXJ5OiBMb2tpUXVlcnksIGVkaXRvck1vZGU6IFF1ZXJ5RWRpdG9yTW9kZSwgb25DaGFuZ2U6IChxdWVyeTogTG9raVF1ZXJ5KSA9PiB2b2lkKSB7XG4gIC8vIElmIGVtcHR5IHF1ZXJ5IHN0b3JlIG5ldyBtb2RlIGFzIGRlZmF1bHRcbiAgaWYgKHF1ZXJ5LmV4cHIgPT09ICcnKSB7XG4gICAgc3RvcmUuc2V0KHF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXksIGVkaXRvck1vZGUpO1xuICB9XG5cbiAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgZWRpdG9yTW9kZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRFZGl0b3JNb2RlKGV4cHI6IHN0cmluZykge1xuICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZXhwcmVzc2lvbiBkZWZhdWx0IHRvIGNvZGUgdmlld1xuICBpZiAoZXhwciAhPSBudWxsICYmIGV4cHIgIT09ICcnKSB7XG4gICAgcmV0dXJuIFF1ZXJ5RWRpdG9yTW9kZS5Db2RlO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBzdG9yZS5nZXQocXVlcnlFZGl0b3JNb2RlRGVmYXVsdExvY2FsU3RvcmFnZUtleSkgYXMgUXVlcnlFZGl0b3JNb2RlO1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcjpcbiAgICBjYXNlIFF1ZXJ5RWRpdG9yTW9kZS5Db2RlOlxuICAgIGNhc2UgUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW46XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBRdWVyeUVkaXRvck1vZGUuQnVpbGRlcjtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgcXVlcnkgd2l0aCBkZWZhdWx0cywgYW5kIGJvb2xlYW4gdHJ1ZS9mYWxzZSBkZXBlbmRpbmcgb24gY2hhbmdlIHdhcyByZXF1aXJlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlXaXRoRGVmYXVsdHMocXVlcnk6IExva2lRdWVyeSk6IExva2lRdWVyeSB7XG4gIC8vIElmIG5vIGV4cHIgKGllIG5ldyBxdWVyeSkgdGhlbiBkZWZhdWx0IHRvIGJ1aWxkZXJcbiAgbGV0IHJlc3VsdCA9IHF1ZXJ5O1xuXG4gIGlmICghcXVlcnkuZWRpdG9yTW9kZSkge1xuICAgIHJlc3VsdCA9IHsgLi4ucXVlcnksIGVkaXRvck1vZGU6IGdldERlZmF1bHRFZGl0b3JNb2RlKHF1ZXJ5LmV4cHIpIH07XG4gIH1cblxuICBpZiAocXVlcnkuZXhwciA9PSBudWxsKSB7XG4gICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIGV4cHI6ICcnIH07XG4gIH1cblxuICBpZiAocXVlcnkucXVlcnlUeXBlID09IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHRvIHJhbmdlIHF1ZXJ5XG4gICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIHF1ZXJ5VHlwZTogTG9raVF1ZXJ5VHlwZS5SYW5nZSB9O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7IFZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi4vLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB9IGZyb20gJy4uLy4uL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5cbi8qKlxuICogVmlzdWFsIHF1ZXJ5IG1vZGVsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVZpc3VhbFF1ZXJ5IHtcbiAgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbiAgYmluYXJ5UXVlcmllcz86IExva2lWaXN1YWxRdWVyeUJpbmFyeVtdO1xufVxuXG5leHBvcnQgdHlwZSBMb2tpVmlzdWFsUXVlcnlCaW5hcnkgPSBWaXN1YWxRdWVyeUJpbmFyeTxMb2tpVmlzdWFsUXVlcnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIExva2lRdWVyeVBhdHRlcm4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdO1xufVxuXG5leHBvcnQgZW51bSBMb2tpVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB7XG4gIEFnZ3JlZ2F0aW9ucyA9ICdBZ2dyZWdhdGlvbnMnLFxuICBSYW5nZUZ1bmN0aW9ucyA9ICdSYW5nZSBmdW5jdGlvbnMnLFxuICBGdW5jdGlvbnMgPSAnRnVuY3Rpb25zJyxcbiAgRm9ybWF0cyA9ICdGb3JtYXRzJyxcbiAgTGluZUZpbHRlcnMgPSAnTGluZSBmaWx0ZXJzJyxcbiAgTGFiZWxGaWx0ZXJzID0gJ0xhYmVsIGZpbHRlcnMnLFxuICBCaW5hcnlPcHMgPSAnQmluYXJ5IG9wZXJhdGlvbnMnLFxufVxuXG5leHBvcnQgZW51bSBMb2tpT3BlcmF0aW9uSWQge1xuICBKc29uID0gJ2pzb24nLFxuICBMb2dmbXQgPSAnbG9nZm10JyxcbiAgUmVnZXhwID0gJ3JlZ2V4cCcsXG4gIFBhdHRlcm4gPSAncGF0dGVybicsXG4gIFVucGFjayA9ICd1bnBhY2snLFxuICBMaW5lRm9ybWF0ID0gJ2xpbmVfZm9ybWF0JyxcbiAgTGFiZWxGb3JtYXQgPSAnbGFiZWxfZm9ybWF0JyxcbiAgUmF0ZSA9ICdyYXRlJyxcbiAgQ291bnRPdmVyVGltZSA9ICdjb3VudF9vdmVyX3RpbWUnLFxuICBTdW1PdmVyVGltZSA9ICdzdW1fb3Zlcl90aW1lJyxcbiAgQXZnT3ZlclRpbWUgPSAnYXZnX292ZXJfdGltZScsXG4gIE1heE92ZXJUaW1lID0gJ21heF9vdmVyX3RpbWUnLFxuICBNaW5PdmVyVGltZSA9ICdtaW5fb3Zlcl90aW1lJyxcbiAgRmlyc3RPdmVyVGltZSA9ICdmaXJzdF9vdmVyX3RpbWUnLFxuICBMYXN0T3ZlclRpbWUgPSAnbGFzdF9vdmVyX3RpbWUnLFxuICBTdGR2YXJPdmVyVGltZSA9ICdzdGR2YXJfb3Zlcl90aW1lJyxcbiAgU3RkZGV2T3ZlclRpbWUgPSAnc3RkZGV2X292ZXJfdGltZScsXG4gIFF1YW50aWxlT3ZlclRpbWUgPSAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgQnl0ZXNSYXRlID0gJ2J5dGVzX3JhdGUnLFxuICBCeXRlc092ZXJUaW1lID0gJ2J5dGVzX292ZXJfdGltZScsXG4gIEFic2VudE92ZXJUaW1lID0gJ2Fic2VudF9vdmVyX3RpbWUnLFxuICBTdW0gPSAnc3VtJyxcbiAgQXZnID0gJ2F2ZycsXG4gIE1pbiA9ICdtaW4nLFxuICBNYXggPSAnbWF4JyxcbiAgU3RkZGV2ID0gJ3N0ZGRldicsXG4gIFN0ZHZhciA9ICdzdGR2YXInLFxuICBDb3VudCA9ICdjb3VudCcsXG4gIFRvcEsgPSAndG9waycsXG4gIEJvdHRvbUsgPSAnYm90dG9taycsXG4gIExpbmVDb250YWlucyA9ICdfX2xpbmVfY29udGFpbnMnLFxuICBMaW5lQ29udGFpbnNOb3QgPSAnX19saW5lX2NvbnRhaW5zX25vdCcsXG4gIExpbmVNYXRjaGVzUmVnZXggPSAnX19saW5lX21hdGNoZXNfcmVnZXgnLFxuICBMaW5lTWF0Y2hlc1JlZ2V4Tm90ID0gJ19fbGluZV9tYXRjaGVzX3JlZ2V4X25vdCcsXG4gIExhYmVsRmlsdGVyID0gJ19fbGFiZWxfZmlsdGVyJyxcbiAgTGFiZWxGaWx0ZXJOb0Vycm9ycyA9ICdfX2xhYmVsX2ZpbHRlcl9ub19lcnJvcnMnLFxuICBVbndyYXAgPSAndW53cmFwJyxcbiAgLy8gQmluYXJ5IG9wc1xuICBBZGRpdGlvbiA9ICdfX2FkZGl0aW9uJyxcbiAgU3VidHJhY3Rpb24gPSAnX19zdWJ0cmFjdGlvbicsXG4gIE11bHRpcGx5QnkgPSAnX19tdWx0aXBseV9ieScsXG4gIERpdmlkZUJ5ID0gJ19fZGl2aWRlX2J5JyxcbiAgTW9kdWxvID0gJ19fbW9kdWxvJyxcbiAgRXhwb25lbnQgPSAnX19leHBvbmVudCcsXG4gIE5lc3RlZFF1ZXJ5ID0gJ19fbmVzdGVkX3F1ZXJ5JyxcbiAgRXF1YWxUbyA9ICdfX2VxdWFsX3RvJyxcbiAgTm90RXF1YWxUbyA9ICdfX25vdF9lcXVhbF90bycsXG4gIEdyZWF0ZXJUaGFuID0gJ19fZ3JlYXRlcl90aGFuJyxcbiAgTGVzc1RoYW4gPSAnX19sZXNzX3RoYW4nLFxuICBHcmVhdGVyT3JFcXVhbCA9ICdfX2dyZWF0ZXJfb3JfZXF1YWwnLFxuICBMZXNzT3JFcXVhbCA9ICdfX2xlc3Nfb3JfZXF1YWwnLFxufVxuXG5leHBvcnQgZW51bSBMb2tpT3BlcmF0aW9uT3JkZXIge1xuICBMaW5lRmlsdGVycyA9IDEsXG4gIExpbmVGb3JtYXRzID0gMixcbiAgTGFiZWxGaWx0ZXJzID0gMyxcbiAgVW53cmFwID0gNCxcbiAgTm9FcnJvcnMgPSA1LFxuICBSYW5nZVZlY3RvckZ1bmN0aW9uID0gNSxcbiAgTGFzdCA9IDYsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RW1wdHlRdWVyeSgpOiBMb2tpVmlzdWFsUXVlcnkge1xuICByZXR1cm4ge1xuICAgIGxhYmVsczogW10sXG4gICAgb3BlcmF0aW9uczogW3sgaWQ6ICdfX2xpbmVfY29udGFpbnMnLCBwYXJhbXM6IFsnJ10gfV0sXG4gIH07XG59XG4iLCJpbXBvcnQgeyBjYXBpdGFsaXplLCBncm91cEJ5LCBpc0VtcHR5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHY1IGFzIHV1aWR2NSB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHtcbiAgRmllbGRUeXBlLFxuICBUaW1lU2VyaWVzLFxuICBMYWJlbHMsXG4gIERhdGFGcmFtZSxcbiAgQXJyYXlWZWN0b3IsXG4gIE11dGFibGVEYXRhRnJhbWUsXG4gIGZpbmRVbmlxdWVMYWJlbHMsXG4gIERhdGFGcmFtZVZpZXcsXG4gIERhdGFMaW5rLFxuICBGaWVsZCxcbiAgUXVlcnlSZXN1bHRNZXRhU3RhdCxcbiAgUXVlcnlSZXN1bHRNZXRhLFxuICBUaW1lU2VyaWVzVmFsdWUsXG4gIFNjb3BlZFZhcnMsXG4gIHRvRGF0YUZyYW1lLFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgZ2V0VGVtcGxhdGVTcnYsIGdldERhdGFTb3VyY2VTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCBUYWJsZU1vZGVsIGZyb20gJ2FwcC9jb3JlL3RhYmxlX21vZGVsJztcbmltcG9ydCB7IGZvcm1hdFF1ZXJ5LCBnZXRIaWdobGlnaHRlckV4cHJlc3Npb25zRnJvbVF1ZXJ5IH0gZnJvbSAnLi9xdWVyeV91dGlscyc7XG5pbXBvcnQge1xuICBMb2tpUmFuZ2VRdWVyeVJlcXVlc3QsXG4gIExva2lSZXNwb25zZSxcbiAgTG9raU1hdHJpeFJlc3VsdCxcbiAgTG9raVZlY3RvclJlc3VsdCxcbiAgVHJhbnNmb3JtZXJPcHRpb25zLFxuICBMb2tpUmVzdWx0VHlwZSxcbiAgTG9raVN0cmVhbVJlc3VsdCxcbiAgTG9raVRhaWxSZXNwb25zZSxcbiAgTG9raVF1ZXJ5LFxuICBMb2tpT3B0aW9ucyxcbiAgRGVyaXZlZEZpZWxkQ29uZmlnLFxuICBMb2tpU3RyZWFtUmVzcG9uc2UsXG4gIExva2lTdGF0cyxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyByZW5kZXJMZWdlbmRGb3JtYXQgfSBmcm9tICcuLi9wcm9tZXRoZXVzL2xlZ2VuZCc7XG5cbmNvbnN0IFVVSURfTkFNRVNQQUNFID0gJzZlYzk0NmRhLTBmNDktNDdhOC05ODNhLTFkNzZkMTdlN2M5Mic7XG5cbi8qKlxuICogVHJhbnNmb3JtcyBMb2tpU3RyZWFtUmVzdWx0IHN0cnVjdHVyZSBpbnRvIGEgZGF0YUZyYW1lLiBVc2VkIHdoZW4gZG9pbmcgc3RhbmRhcmQgcXVlcmllcyBhbmQgbmV3ZXIgdmVyc2lvbiBvZiBMb2tpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9raVN0cmVhbVJlc3VsdFRvRGF0YUZyYW1lKHN0cmVhbTogTG9raVN0cmVhbVJlc3VsdCwgcmV2ZXJzZT86IGJvb2xlYW4sIHJlZklkPzogc3RyaW5nKTogRGF0YUZyYW1lIHtcbiAgY29uc3QgbGFiZWxzOiBMYWJlbHMgPSBzdHJlYW0uc3RyZWFtO1xuICBjb25zdCBsYWJlbHNTdHJpbmcgPSBPYmplY3QuZW50cmllcyhsYWJlbHMpXG4gICAgLm1hcCgoW2tleSwgdmFsXSkgPT4gYCR7a2V5fT1cIiR7dmFsfVwiYClcbiAgICAuc29ydCgpXG4gICAgLmpvaW4oJycpO1xuXG4gIGNvbnN0IHRpbWVzID0gbmV3IEFycmF5VmVjdG9yPHN0cmluZz4oW10pO1xuICBjb25zdCB0aW1lc05zID0gbmV3IEFycmF5VmVjdG9yPHN0cmluZz4oW10pO1xuICBjb25zdCBsaW5lcyA9IG5ldyBBcnJheVZlY3RvcjxzdHJpbmc+KFtdKTtcbiAgY29uc3QgdWlkcyA9IG5ldyBBcnJheVZlY3RvcjxzdHJpbmc+KFtdKTtcblxuICAvLyBXZSBuZWVkIHRvIHN0b3JlIGFuZCB0cmFjayBhbGwgdXNlZCB1aWRzIHRvIGVuc3VyZSB0aGF0IHVpZHMgYXJlIHVuaXF1ZVxuICBjb25zdCB1c2VkVWlkczogeyBzdHJpbmc/OiBudW1iZXIgfSA9IHt9O1xuXG4gIGZvciAoY29uc3QgW3RzLCBsaW5lXSBvZiBzdHJlYW0udmFsdWVzKSB7XG4gICAgLy8gbnVtIG5zIGVwb2NoIGluIHN0cmluZywgd2UgY29udmVydCBpdCB0byBpc28gc3RyaW5nIGhlcmUgc28gaXQgbWF0Y2hlcyBvbGQgZm9ybWF0XG4gICAgdGltZXMuYWRkKG5ldyBEYXRlKHBhcnNlSW50KHRzLnNsaWNlKDAsIC02KSwgMTApKS50b0lTT1N0cmluZygpKTtcbiAgICB0aW1lc05zLmFkZCh0cyk7XG4gICAgbGluZXMuYWRkKGxpbmUpO1xuICAgIHVpZHMuYWRkKGNyZWF0ZVVpZCh0cywgbGFiZWxzU3RyaW5nLCBsaW5lLCB1c2VkVWlkcywgcmVmSWQpKTtcbiAgfVxuXG4gIHJldHVybiBjb25zdHJ1Y3REYXRhRnJhbWUodGltZXMsIHRpbWVzTnMsIGxpbmVzLCB1aWRzLCBsYWJlbHMsIHJldmVyc2UsIHJlZklkKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGRhdGFGcmFtZSB3aXRoIHN1cHBsaWVkIGZpZWxkcyBhbmQgb3RoZXIgZGF0YS4gQWxzbyBtYWtlcyBzdXJlIGl0IGlzIHByb3Blcmx5IHJldmVyc2VkIGlmIG5lZWRlZC5cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0RGF0YUZyYW1lKFxuICB0aW1lczogQXJyYXlWZWN0b3I8c3RyaW5nPixcbiAgdGltZXNOczogQXJyYXlWZWN0b3I8c3RyaW5nPixcbiAgbGluZXM6IEFycmF5VmVjdG9yPHN0cmluZz4sXG4gIHVpZHM6IEFycmF5VmVjdG9yPHN0cmluZz4sXG4gIGxhYmVsczogTGFiZWxzLFxuICByZXZlcnNlPzogYm9vbGVhbixcbiAgcmVmSWQ/OiBzdHJpbmdcbikge1xuICBjb25zdCBkYXRhRnJhbWUgPSB7XG4gICAgcmVmSWQsXG4gICAgZmllbGRzOiBbXG4gICAgICB7IG5hbWU6ICd0cycsIHR5cGU6IEZpZWxkVHlwZS50aW1lLCBjb25maWc6IHsgZGlzcGxheU5hbWU6ICdUaW1lJyB9LCB2YWx1ZXM6IHRpbWVzIH0sIC8vIFRpbWVcbiAgICAgIHsgbmFtZTogJ2xpbmUnLCB0eXBlOiBGaWVsZFR5cGUuc3RyaW5nLCBjb25maWc6IHt9LCB2YWx1ZXM6IGxpbmVzLCBsYWJlbHMgfSwgLy8gTGluZSAtIG5lZWRzIHRvIGJlIHRoZSBmaXJzdCBmaWVsZCB3aXRoIHN0cmluZyB0eXBlXG4gICAgICB7IG5hbWU6ICdpZCcsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsIGNvbmZpZzoge30sIHZhbHVlczogdWlkcyB9LFxuICAgICAgeyBuYW1lOiAndHNOcycsIHR5cGU6IEZpZWxkVHlwZS50aW1lLCBjb25maWc6IHsgZGlzcGxheU5hbWU6ICdUaW1lIG5zJyB9LCB2YWx1ZXM6IHRpbWVzTnMgfSwgLy8gVGltZVxuICAgIF0sXG4gICAgbGVuZ3RoOiB0aW1lcy5sZW5ndGgsXG4gIH07XG5cbiAgaWYgKHJldmVyc2UpIHtcbiAgICBjb25zdCBtdXRhYmxlRGF0YUZyYW1lID0gbmV3IE11dGFibGVEYXRhRnJhbWUoZGF0YUZyYW1lKTtcbiAgICBtdXRhYmxlRGF0YUZyYW1lLnJldmVyc2UoKTtcbiAgICByZXR1cm4gbXV0YWJsZURhdGFGcmFtZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhRnJhbWU7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIExva2lSZXNwb25zZSBkYXRhIGFuZCBhcHBlbmRzIGl0IHRvIE11dGFibGVEYXRhRnJhbWUuIFVzZWQgZm9yIHN0cmVhbWluZyB3aGVyZSB0aGUgZGF0YUZyYW1lIGNhbiBiZVxuICogYSBDaXJjdWxhckRhdGFGcmFtZSBjcmVhdGluZyBhIGZpeGVkIHNpemUgcm9sbGluZyBidWZmZXIuXG4gKiBUT0RPOiBQcm9iYWJseSBjb3VsZCBiZSB1bmlmaWVkIHdpdGggdGhlIGxvZ1N0cmVhbVRvRGF0YUZyYW1lIGZ1bmN0aW9uLlxuICogQHBhcmFtIHJlc3BvbnNlXG4gKiBAcGFyYW0gZGF0YSBOZWVkcyB0byBoYXZlIHRzLCBsaW5lLCBsYWJlbHMsIGlkIGFzIGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kUmVzcG9uc2VUb0J1ZmZlcmVkRGF0YShyZXNwb25zZTogTG9raVRhaWxSZXNwb25zZSwgZGF0YTogTXV0YWJsZURhdGFGcmFtZSkge1xuICAvLyBTaG91bGQgd2UgZG8gYW55dGhpbmcgd2l0aDogcmVzcG9uc2UuZHJvcHBlZF9lbnRyaWVzP1xuXG4gIGNvbnN0IHN0cmVhbXM6IExva2lTdHJlYW1SZXN1bHRbXSA9IHJlc3BvbnNlLnN0cmVhbXM7XG4gIGlmICghc3RyZWFtcyB8fCAhc3RyZWFtcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgYmFzZUxhYmVsczogTGFiZWxzID0ge307XG4gIGZvciAoY29uc3QgZiBvZiBkYXRhLmZpZWxkcykge1xuICAgIGlmIChmLnR5cGUgPT09IEZpZWxkVHlwZS5zdHJpbmcpIHtcbiAgICAgIGlmIChmLmxhYmVscykge1xuICAgICAgICBiYXNlTGFiZWxzID0gZi5sYWJlbHM7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25zdCB0c0ZpZWxkID0gZGF0YS5maWVsZHNbMF07XG4gIGNvbnN0IHRzTnNGaWVsZCA9IGRhdGEuZmllbGRzWzFdO1xuICBjb25zdCBsaW5lRmllbGQgPSBkYXRhLmZpZWxkc1syXTtcbiAgY29uc3QgbGFiZWxzRmllbGQgPSBkYXRhLmZpZWxkc1szXTtcbiAgY29uc3QgaWRGaWVsZCA9IGRhdGEuZmllbGRzWzRdO1xuXG4gIC8vIFdlIGFyZSBjb21wYXJpbmcgdXNlZCBpZHMgb25seSB3aXRoaW4gdGhlIHJlY2VpdmVkIHN0cmVhbS4gVGhpcyBjb3VsZCBiZSBhIHByb2JsZW0gaWYgdGhlIHNhbWUgbGluZSArIGxhYmVscyArIG5hbm9zZWNvbmQgdGltZXN0YW1wIGNhbWUgaW4gMiBzZXBhcmF0ZSBiYXRjaGVzLlxuICAvLyBBcyB0aGlzIGlzIHZlcnkgdW5saWtlbHksIGFuZCB0aGUgcmVzdWx0IHdvdWxkIG9ubHkgYWZmZWN0IGxpdmUtdGFpbGluZyBjc3MgYW5pbWF0aW9uIHdlIGhhdmUgZGVjaWRlZCB0byBub3QgY29tcGFyZSBhbGwgcmVjZWl2ZWQgdWlkcyBmcm9tIGRhdGEgcGFyYW0gYXMgdGhpcyB3b3VsZCBzbG93IGRvd24gcHJvY2Vzc2luZy5cbiAgY29uc3QgdXNlZFVpZHM6IHsgc3RyaW5nPzogbnVtYmVyIH0gPSB7fTtcblxuICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgLy8gRmluZCB1bmlxdWUgbGFiZWxzXG4gICAgY29uc3QgdW5pcXVlID0gZmluZFVuaXF1ZUxhYmVscyhzdHJlYW0uc3RyZWFtLCBiYXNlTGFiZWxzKTtcbiAgICBjb25zdCBhbGxMYWJlbHNTdHJpbmcgPSBPYmplY3QuZW50cmllcyhzdHJlYW0uc3RyZWFtKVxuICAgICAgLm1hcCgoW2tleSwgdmFsXSkgPT4gYCR7a2V5fT1cIiR7dmFsfVwiYClcbiAgICAgIC5zb3J0KClcbiAgICAgIC5qb2luKCcnKTtcblxuICAgIC8vIEFkZCBlYWNoIGxpbmVcbiAgICBmb3IgKGNvbnN0IFt0cywgbGluZV0gb2Ygc3RyZWFtLnZhbHVlcykge1xuICAgICAgdHNGaWVsZC52YWx1ZXMuYWRkKG5ldyBEYXRlKHBhcnNlSW50KHRzLnNsaWNlKDAsIC02KSwgMTApKS50b0lTT1N0cmluZygpKTtcbiAgICAgIHRzTnNGaWVsZC52YWx1ZXMuYWRkKHRzKTtcbiAgICAgIGxpbmVGaWVsZC52YWx1ZXMuYWRkKGxpbmUpO1xuICAgICAgbGFiZWxzRmllbGQudmFsdWVzLmFkZCh1bmlxdWUpO1xuICAgICAgaWRGaWVsZC52YWx1ZXMuYWRkKGNyZWF0ZVVpZCh0cywgYWxsTGFiZWxzU3RyaW5nLCBsaW5lLCB1c2VkVWlkcywgZGF0YS5yZWZJZCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVVaWQodHM6IHN0cmluZywgbGFiZWxzU3RyaW5nOiBzdHJpbmcsIGxpbmU6IHN0cmluZywgdXNlZFVpZHM6IGFueSwgcmVmSWQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBHZW5lcmF0ZSBpZCBhcyBoYXNoZWQgbmFub3NlY29uZCB0aW1lc3RhbXAsIGxhYmVscyBhbmQgbGluZSAodGhpcyBkb2VzIG5vdCBoYXZlIHRvIGJlIHVuaXF1ZSlcbiAgbGV0IGlkID0gdXVpZHY1KGAke3RzfV8ke2xhYmVsc1N0cmluZ31fJHtsaW5lfWAsIFVVSURfTkFNRVNQQUNFKTtcblxuICAvLyBDaGVjayBpZiBnZW5lcmF0ZWQgaWQgaXMgdW5pcXVlXG4gIC8vIElmIG5vdCBhbmQgd2UndmUgYWxyZWFkeSB1c2VkIGl0LCBhcHBlbmQgaXQncyBjb3VudCBhZnRlciBpdFxuICBpZiAoaWQgaW4gdXNlZFVpZHMpIHtcbiAgICAvLyBJbmNyZWFzZSB0aGUgY291bnRcbiAgICBjb25zdCBuZXdDb3VudCA9IHVzZWRVaWRzW2lkXSArIDE7XG4gICAgdXNlZFVpZHNbaWRdID0gbmV3Q291bnQ7XG4gICAgLy8gQXBwZW5kIGNvdW50IHRvIGdlbmVyYXRlZCBpZCB0byBtYWtlIGl0IHVuaXF1ZVxuICAgIGlkID0gYCR7aWR9XyR7bmV3Q291bnR9YDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBpZCBpcyB1bmlxdWUgYW5kIHdhc24ndCB1c2VkLCBhZGQgaXQgdG8gdXNlZFVpZHMgYW5kIHN0YXJ0IGNvdW50IGF0IDBcbiAgICB1c2VkVWlkc1tpZF0gPSAwO1xuICB9XG4gIC8vIFJldHVybiB1bmlxdWUgaWRcbiAgaWYgKHJlZklkKSB7XG4gICAgcmV0dXJuIGAke2lkfV8ke3JlZklkfWA7XG4gIH1cbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBsb2tpTWF0cml4VG9UaW1lU2VyaWVzKG1hdHJpeFJlc3VsdDogTG9raU1hdHJpeFJlc3VsdCwgb3B0aW9uczogVHJhbnNmb3JtZXJPcHRpb25zKTogVGltZVNlcmllcyB7XG4gIGNvbnN0IG5hbWUgPSBjcmVhdGVNZXRyaWNMYWJlbChtYXRyaXhSZXN1bHQubWV0cmljLCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB0YXJnZXQ6IG5hbWUsXG4gICAgdGl0bGU6IG5hbWUsXG4gICAgZGF0YXBvaW50czogbG9raVBvaW50c1RvVGltZXNlcmllc1BvaW50cyhtYXRyaXhSZXN1bHQudmFsdWVzKSxcbiAgICB0YWdzOiBtYXRyaXhSZXN1bHQubWV0cmljLFxuICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICByZWZJZDogb3B0aW9ucy5yZWZJZCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQcm9tZXRoZXVzRm9ybWF0U2FtcGxlVmFsdWUodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlICcrSW5mJzpcbiAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY2FzZSAnLUluZic6XG4gICAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxva2lQb2ludHNUb1RpbWVzZXJpZXNQb2ludHMoZGF0YTogQXJyYXk8W251bWJlciwgc3RyaW5nXT4pOiBUaW1lU2VyaWVzVmFsdWVbXVtdIHtcbiAgY29uc3QgZGF0YXBvaW50czogVGltZVNlcmllc1ZhbHVlW11bXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgW3RpbWUsIHZhbHVlXSBvZiBkYXRhKSB7XG4gICAgbGV0IGRhdGFwb2ludFZhbHVlOiBUaW1lU2VyaWVzVmFsdWUgPSBwYXJzZVByb21ldGhldXNGb3JtYXRTYW1wbGVWYWx1ZSh2YWx1ZSk7XG5cbiAgICBpZiAoaXNOYU4oZGF0YXBvaW50VmFsdWUpKSB7XG4gICAgICBkYXRhcG9pbnRWYWx1ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZXN0YW1wID0gdGltZSAqIDEwMDA7XG5cbiAgICBkYXRhcG9pbnRzLnB1c2goW2RhdGFwb2ludFZhbHVlLCB0aW1lc3RhbXBdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhcG9pbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9raVJlc3VsdHNUb1RhYmxlTW9kZWwoXG4gIGxva2lSZXN1bHRzOiBBcnJheTxMb2tpTWF0cml4UmVzdWx0IHwgTG9raVZlY3RvclJlc3VsdD4sXG4gIHJlc3VsdENvdW50OiBudW1iZXIsXG4gIHJlZklkOiBzdHJpbmcsXG4gIG1ldGE6IFF1ZXJ5UmVzdWx0TWV0YSxcbiAgdmFsdWVXaXRoUmVmSWQ/OiBib29sZWFuXG4pOiBUYWJsZU1vZGVsIHtcbiAgaWYgKCFsb2tpUmVzdWx0cyB8fCBsb2tpUmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlTW9kZWwoKTtcbiAgfVxuXG4gIC8vIENvbGxlY3QgYWxsIGxhYmVscyBhY3Jvc3MgYWxsIG1ldHJpY3NcbiAgY29uc3QgbWV0cmljTGFiZWxzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPihcbiAgICBsb2tpUmVzdWx0cy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBhY2MuY29uY2F0KE9iamVjdC5rZXlzKGN1ci5tZXRyaWMpKSwgW10gYXMgc3RyaW5nW10pXG4gICk7XG5cbiAgLy8gU29ydCBtZXRyaWMgbGFiZWxzLCBjcmVhdGUgY29sdW1ucyBmb3IgdGhlbSBhbmQgcmVjb3JkIHRoZWlyIGluZGV4XG4gIGNvbnN0IHNvcnRlZExhYmVscyA9IFsuLi5tZXRyaWNMYWJlbHMudmFsdWVzKCldLnNvcnQoKTtcbiAgY29uc3QgdGFibGUgPSBuZXcgVGFibGVNb2RlbCgpO1xuICB0YWJsZS5yZWZJZCA9IHJlZklkO1xuICB0YWJsZS5tZXRhID0gbWV0YTtcbiAgdGFibGUuY29sdW1ucyA9IFtcbiAgICB7IHRleHQ6ICdUaW1lJywgdHlwZTogRmllbGRUeXBlLnRpbWUgfSxcbiAgICAuLi5zb3J0ZWRMYWJlbHMubWFwKChsYWJlbCkgPT4gKHsgdGV4dDogbGFiZWwsIGZpbHRlcmFibGU6IHRydWUsIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcgfSkpLFxuICAgIHsgdGV4dDogcmVzdWx0Q291bnQgPiAxIHx8IHZhbHVlV2l0aFJlZklkID8gYFZhbHVlICMke3JlZklkfWAgOiAnVmFsdWUnLCB0eXBlOiBGaWVsZFR5cGUubnVtYmVyIH0sXG4gIF07XG5cbiAgLy8gUG9wdWxhdGUgcm93cywgc2V0IHZhbHVlIHRvIGVtcHR5IHN0cmluZyB3aGVuIGxhYmVsIG5vdCBwcmVzZW50LlxuICBsb2tpUmVzdWx0cy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICBjb25zdCBuZXdTZXJpZXM6IExva2lNYXRyaXhSZXN1bHQgPSB7XG4gICAgICBtZXRyaWM6IHNlcmllcy5tZXRyaWMsXG4gICAgICB2YWx1ZXM6IChzZXJpZXMgYXMgTG9raVZlY3RvclJlc3VsdCkudmFsdWVcbiAgICAgICAgPyBbKHNlcmllcyBhcyBMb2tpVmVjdG9yUmVzdWx0KS52YWx1ZV1cbiAgICAgICAgOiAoc2VyaWVzIGFzIExva2lNYXRyaXhSZXN1bHQpLnZhbHVlcyxcbiAgICB9O1xuXG4gICAgaWYgKCFuZXdTZXJpZXMudmFsdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFuZXdTZXJpZXMubWV0cmljKSB7XG4gICAgICB0YWJsZS5yb3dzLmNvbmNhdChuZXdTZXJpZXMudmFsdWVzLm1hcCgoW2EsIGJdKSA9PiBbYSAqIDEwMDAsIHBhcnNlRmxvYXQoYildKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlLnJvd3MucHVzaChcbiAgICAgICAgLi4ubmV3U2VyaWVzLnZhbHVlcy5tYXAoKFthLCBiXSkgPT4gW1xuICAgICAgICAgIGEgKiAxMDAwLFxuICAgICAgICAgIC4uLnNvcnRlZExhYmVscy5tYXAoKGxhYmVsKSA9PiBuZXdTZXJpZXMubWV0cmljW2xhYmVsXSB8fCAnJyksXG4gICAgICAgICAgcGFyc2VGbG9hdChiKSxcbiAgICAgICAgXSlcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZXRyaWNMYWJlbChsYWJlbERhdGE6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sIG9wdGlvbnM/OiBUcmFuc2Zvcm1lck9wdGlvbnMpIHtcbiAgbGV0IGxhYmVsID1cbiAgICBvcHRpb25zID09PSB1bmRlZmluZWQgfHwgaXNFbXB0eShvcHRpb25zLmxlZ2VuZEZvcm1hdClcbiAgICAgID8gZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKGxhYmVsRGF0YSlcbiAgICAgIDogcmVuZGVyTGVnZW5kRm9ybWF0KGdldFRlbXBsYXRlU3J2KCkucmVwbGFjZShvcHRpb25zLmxlZ2VuZEZvcm1hdCA/PyAnJywgb3B0aW9ucy5zY29wZWRWYXJzKSwgbGFiZWxEYXRhKTtcblxuICBpZiAoIWxhYmVsICYmIG9wdGlvbnMpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnMucXVlcnk7XG4gIH1cbiAgcmV0dXJuIGxhYmVsO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbE1ldHJpY05hbWUobGFiZWxEYXRhOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gIGNvbnN0IGxhYmVsUGFydCA9IE9iamVjdC5lbnRyaWVzKGxhYmVsRGF0YSlcbiAgICAubWFwKChsYWJlbCkgPT4gYCR7bGFiZWxbMF19PVwiJHtsYWJlbFsxXX1cImApXG4gICAgLmpvaW4oJywnKTtcbiAgcmV0dXJuIGB7JHtsYWJlbFBhcnR9fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNhbWVsaXplKHM6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1tBLVpdL2csIChtKSA9PiBgICR7bS50b0xvd2VyQ2FzZSgpfWApO1xufVxuXG4vLyBUdXJuIGxva2kgc3RhdHMgeyBtZXRyaWM6IHZhbHVlIH0gaW50byBtZXRhIHN0YXQgeyB0aXRsZTogbWV0cmljLCB2YWx1ZTogdmFsdWUgfVxuZnVuY3Rpb24gbG9raVN0YXRzVG9NZXRhU3RhdChzdGF0czogTG9raVN0YXRzIHwgdW5kZWZpbmVkKTogUXVlcnlSZXN1bHRNZXRhU3RhdFtdIHtcbiAgY29uc3QgcmVzdWx0OiBRdWVyeVJlc3VsdE1ldGFTdGF0W10gPSBbXTtcblxuICBpZiAoIXN0YXRzKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZvciAoY29uc3Qgc2VjdGlvbiBpbiBzdGF0cykge1xuICAgIGNvbnN0IHZhbHVlcyA9IHN0YXRzW3NlY3Rpb25dO1xuICAgIGZvciAoY29uc3QgbGFiZWwgaW4gdmFsdWVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tsYWJlbF07XG4gICAgICBsZXQgdW5pdDtcbiAgICAgIGlmICgvdGltZS9pLnRlc3QobGFiZWwpICYmIHZhbHVlKSB7XG4gICAgICAgIHVuaXQgPSAncyc7XG4gICAgICB9IGVsc2UgaWYgKC9ieXRlcy4qcGVyc2Vjb25kL2kudGVzdChsYWJlbCkpIHtcbiAgICAgICAgdW5pdCA9ICdCcHMnO1xuICAgICAgfSBlbHNlIGlmICgvYnl0ZXMvaS50ZXN0KGxhYmVsKSkge1xuICAgICAgICB1bml0ID0gJ2RlY2J5dGVzJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpdGxlID0gYCR7Y2FwaXRhbGl6ZShzZWN0aW9uKX06ICR7ZGVjYW1lbGl6ZShsYWJlbCl9YDtcbiAgICAgIHJlc3VsdC5wdXNoKHsgZGlzcGxheU5hbWU6IHRpdGxlLCB2YWx1ZSwgdW5pdCB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9raVN0cmVhbXNUb0RhdGFGcmFtZXMoXG4gIHJlc3BvbnNlOiBMb2tpU3RyZWFtUmVzcG9uc2UsXG4gIHRhcmdldDogeyByZWZJZDogc3RyaW5nOyBleHByPzogc3RyaW5nIH0sXG4gIGxpbWl0OiBudW1iZXIsXG4gIGNvbmZpZzogTG9raU9wdGlvbnMsXG4gIHJldmVyc2UgPSBmYWxzZVxuKTogRGF0YUZyYW1lW10ge1xuICBjb25zdCBkYXRhID0gbGltaXQgPiAwID8gcmVzcG9uc2UuZGF0YS5yZXN1bHQgOiBbXTtcbiAgY29uc3Qgc3RhdHM6IFF1ZXJ5UmVzdWx0TWV0YVN0YXRbXSA9IGxva2lTdGF0c1RvTWV0YVN0YXQocmVzcG9uc2UuZGF0YS5zdGF0cyk7XG4gIC8vIFVzZSBjdXN0b20gbWVjaGFuaXNtIHRvIGlkZW50aWZ5IHdoaWNoIHN0YXQgd2Ugd2FudCB0byBwcm9tb3RlIHRvIGxhYmVsXG4gIGNvbnN0IGN1c3RvbSA9IHtcbiAgICBsb2tpUXVlcnlTdGF0S2V5OiAnU3VtbWFyeTogdG90YWwgYnl0ZXMgcHJvY2Vzc2VkJyxcbiAgfTtcblxuICBjb25zdCBtZXRhOiBRdWVyeVJlc3VsdE1ldGEgPSB7XG4gICAgc2VhcmNoV29yZHM6IGdldEhpZ2hsaWdodGVyRXhwcmVzc2lvbnNGcm9tUXVlcnkoZm9ybWF0UXVlcnkodGFyZ2V0LmV4cHIpKSxcbiAgICBsaW1pdCxcbiAgICBzdGF0cyxcbiAgICBjdXN0b20sXG4gICAgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICdsb2dzJyxcbiAgfTtcblxuICBjb25zdCBzZXJpZXM6IERhdGFGcmFtZVtdID0gZGF0YS5tYXAoKHN0cmVhbSkgPT4ge1xuICAgIGNvbnN0IGRhdGFGcmFtZSA9IGxva2lTdHJlYW1SZXN1bHRUb0RhdGFGcmFtZShzdHJlYW0sIHJldmVyc2UsIHRhcmdldC5yZWZJZCk7XG4gICAgZW5oYW5jZURhdGFGcmFtZShkYXRhRnJhbWUsIGNvbmZpZyk7XG5cbiAgICBpZiAobWV0YS5jdXN0b20gJiYgZGF0YUZyYW1lLmZpZWxkcy5zb21lKChmKSA9PiBmLmxhYmVscyAmJiBPYmplY3Qua2V5cyhmLmxhYmVscykuc29tZSgobCkgPT4gbCA9PT0gJ19fZXJyb3JfXycpKSkge1xuICAgICAgbWV0YS5jdXN0b20uZXJyb3IgPSAnRXJyb3Igd2hlbiBwYXJzaW5nIHNvbWUgb2YgdGhlIGxvZ3MnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhRnJhbWUsXG4gICAgICByZWZJZDogdGFyZ2V0LnJlZklkLFxuICAgICAgbWV0YSxcbiAgICB9O1xuICB9KTtcblxuICBpZiAoc3RhdHMubGVuZ3RoICYmICFkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGZpZWxkczogW10sXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgcmVmSWQ6IHRhcmdldC5yZWZJZCxcbiAgICAgICAgbWV0YSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiBzZXJpZXM7XG59XG5cbi8qKlxuICogQWRkcyBuZXcgZmllbGRzIGFuZCBEYXRhTGlua3MgdG8gRGF0YUZyYW1lIGJhc2VkIG9uIERhdGFTb3VyY2UgaW5zdGFuY2UgY29uZmlnLlxuICovXG5leHBvcnQgY29uc3QgZW5oYW5jZURhdGFGcmFtZSA9IChkYXRhRnJhbWU6IERhdGFGcmFtZSwgY29uZmlnOiBMb2tpT3B0aW9ucyB8IG51bGwpOiB2b2lkID0+IHtcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkZXJpdmVkRmllbGRzID0gY29uZmlnLmRlcml2ZWRGaWVsZHMgPz8gW107XG4gIGlmICghZGVyaXZlZEZpZWxkcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVyaXZlZEZpZWxkc0dyb3VwZWQgPSBncm91cEJ5KGRlcml2ZWRGaWVsZHMsICduYW1lJyk7XG5cbiAgY29uc3QgbmV3RmllbGRzID0gT2JqZWN0LnZhbHVlcyhkZXJpdmVkRmllbGRzR3JvdXBlZCkubWFwKGZpZWxkRnJvbURlcml2ZWRGaWVsZENvbmZpZyk7XG5cbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhRnJhbWVWaWV3KGRhdGFGcmFtZSk7XG4gIHZpZXcuZm9yRWFjaCgocm93OiB7IGxpbmU6IHN0cmluZyB9KSA9PiB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBuZXdGaWVsZHMpIHtcbiAgICAgIGNvbnN0IGxvZ01hdGNoID0gcm93LmxpbmUubWF0Y2goZGVyaXZlZEZpZWxkc0dyb3VwZWRbZmllbGQubmFtZV1bMF0ubWF0Y2hlclJlZ2V4KTtcbiAgICAgIGZpZWxkLnZhbHVlcy5hZGQobG9nTWF0Y2ggJiYgbG9nTWF0Y2hbMV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZGF0YUZyYW1lLmZpZWxkcyA9IFsuLi5kYXRhRnJhbWUuZmllbGRzLCAuLi5uZXdGaWVsZHNdO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gZGVyaXZlZEZpZWxkIGNvbmZpZyBpbnRvIGRhdGFmcmFtZSBmaWVsZCB3aXRoIGNvbmZpZyB0aGF0IGNvbnRhaW5zIGxpbmsuXG4gKi9cbmZ1bmN0aW9uIGZpZWxkRnJvbURlcml2ZWRGaWVsZENvbmZpZyhkZXJpdmVkRmllbGRDb25maWdzOiBEZXJpdmVkRmllbGRDb25maWdbXSk6IEZpZWxkPGFueSwgQXJyYXlWZWN0b3I+IHtcbiAgY29uc3QgZGF0YVNvdXJjZVNydiA9IGdldERhdGFTb3VyY2VTcnYoKTtcblxuICBjb25zdCBkYXRhTGlua3MgPSBkZXJpdmVkRmllbGRDb25maWdzLnJlZHVjZSgoYWNjLCBkZXJpdmVkRmllbGRDb25maWcpID0+IHtcbiAgICAvLyBIYXZpbmcgZmllbGQuZGF0YXNvdXJjZVVpZCBtZWFucyBpdCBpcyBhbiBpbnRlcm5hbCBsaW5rLlxuICAgIGlmIChkZXJpdmVkRmllbGRDb25maWcuZGF0YXNvdXJjZVVpZCkge1xuICAgICAgY29uc3QgZHNTZXR0aW5ncyA9IGRhdGFTb3VyY2VTcnYuZ2V0SW5zdGFuY2VTZXR0aW5ncyhkZXJpdmVkRmllbGRDb25maWcuZGF0YXNvdXJjZVVpZCk7XG5cbiAgICAgIGFjYy5wdXNoKHtcbiAgICAgICAgLy8gV2lsbCBiZSBmaWxsZWQgb3V0IGxhdGVyXG4gICAgICAgIHRpdGxlOiBkZXJpdmVkRmllbGRDb25maWcudXJsRGlzcGxheUxhYmVsIHx8ICcnLFxuICAgICAgICB1cmw6ICcnLFxuICAgICAgICAvLyBUaGlzIGlzIGhhcmRjb2RlZCBmb3IgSmFlZ2VyIG9yIFppcGtpbiBub3Qgd2F5IHJpZ2h0IG5vdyB0byBzcGVjaWZ5IGRhdGFzb3VyY2Ugc3BlY2lmaWMgcXVlcnkgb2JqZWN0XG4gICAgICAgIGludGVybmFsOiB7XG4gICAgICAgICAgcXVlcnk6IHsgcXVlcnk6IGRlcml2ZWRGaWVsZENvbmZpZy51cmwgfSxcbiAgICAgICAgICBkYXRhc291cmNlVWlkOiBkZXJpdmVkRmllbGRDb25maWcuZGF0YXNvdXJjZVVpZCxcbiAgICAgICAgICBkYXRhc291cmNlTmFtZTogZHNTZXR0aW5ncz8ubmFtZSA/PyAnRGF0YSBzb3VyY2Ugbm90IGZvdW5kJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGVyaXZlZEZpZWxkQ29uZmlnLnVybCkge1xuICAgICAgYWNjLnB1c2goe1xuICAgICAgICAvLyBXZSBkbyBub3Qga25vdyB3aGF0IHRpdGxlIHRvIGdpdmUgaGVyZSBzbyB3ZSBjb3VudCBvbiBwcmVzZW50YXRpb24gbGF5ZXIgdG8gY3JlYXRlIGEgdGl0bGUgZnJvbSBtZXRhZGF0YS5cbiAgICAgICAgdGl0bGU6IGRlcml2ZWRGaWVsZENvbmZpZy51cmxEaXNwbGF5TGFiZWwgfHwgJycsXG4gICAgICAgIC8vIFRoaXMgaXMgaGFyZGNvZGVkIGZvciBKYWVnZXIgb3IgWmlwa2luIG5vdCB3YXkgcmlnaHQgbm93IHRvIHNwZWNpZnkgZGF0YXNvdXJjZSBzcGVjaWZpYyBxdWVyeSBvYmplY3RcbiAgICAgICAgdXJsOiBkZXJpdmVkRmllbGRDb25maWcudXJsLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdIGFzIERhdGFMaW5rW10pO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogZGVyaXZlZEZpZWxkQ29uZmlnc1swXS5uYW1lLFxuICAgIHR5cGU6IEZpZWxkVHlwZS5zdHJpbmcsXG4gICAgY29uZmlnOiB7XG4gICAgICBsaW5rczogZGF0YUxpbmtzLFxuICAgIH0sXG4gICAgLy8gV2UgYXJlIGFkZGluZyB2YWx1ZXMgbGF0ZXIgb25cbiAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcjxzdHJpbmc+KFtdKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VRdWVyeVJlc3BvbnNlVG9UaW1lU2VyaWVzKFxuICByZXNwb25zZTogTG9raVJlc3BvbnNlLFxuICBxdWVyeTogTG9raVJhbmdlUXVlcnlSZXF1ZXN0LFxuICB0YXJnZXQ6IExva2lRdWVyeSxcbiAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBudW1iZXIsXG4gIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnNcbik6IFRpbWVTZXJpZXNbXSB7XG4gIC8qKiBTaG93IHJlc3VsdHMgb2YgTG9raSBtZXRyaWMgcXVlcmllcyBvbmx5IGluIGdyYXBoICovXG4gIGNvbnN0IG1ldGE6IFF1ZXJ5UmVzdWx0TWV0YSA9IHtcbiAgICBwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZTogJ2dyYXBoJyxcbiAgfTtcbiAgY29uc3QgdHJhbnNmb3JtZXJPcHRpb25zOiBUcmFuc2Zvcm1lck9wdGlvbnMgPSB7XG4gICAgZm9ybWF0OiB0YXJnZXQuZm9ybWF0LFxuICAgIGxlZ2VuZEZvcm1hdDogdGFyZ2V0LmxlZ2VuZEZvcm1hdCA/PyAnJyxcbiAgICBzdGFydDogcXVlcnkuc3RhcnQhLFxuICAgIGVuZDogcXVlcnkuZW5kISxcbiAgICBzdGVwOiBxdWVyeS5zdGVwISxcbiAgICBxdWVyeTogcXVlcnkucXVlcnksXG4gICAgcmVzcG9uc2VMaXN0TGVuZ3RoLFxuICAgIHJlZklkOiB0YXJnZXQucmVmSWQsXG4gICAgbWV0YSxcbiAgICB2YWx1ZVdpdGhSZWZJZDogdGFyZ2V0LnZhbHVlV2l0aFJlZklkLFxuICAgIHNjb3BlZFZhcnMsXG4gIH07XG5cbiAgc3dpdGNoIChyZXNwb25zZS5kYXRhLnJlc3VsdFR5cGUpIHtcbiAgICBjYXNlIExva2lSZXN1bHRUeXBlLlZlY3RvcjpcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnJlc3VsdC5tYXAoKHZlY1Jlc3VsdCkgPT5cbiAgICAgICAgbG9raU1hdHJpeFRvVGltZVNlcmllcyh7IG1ldHJpYzogdmVjUmVzdWx0Lm1ldHJpYywgdmFsdWVzOiBbdmVjUmVzdWx0LnZhbHVlXSB9LCB0cmFuc2Zvcm1lck9wdGlvbnMpXG4gICAgICApO1xuICAgIGNhc2UgTG9raVJlc3VsdFR5cGUuTWF0cml4OlxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEucmVzdWx0Lm1hcCgobWF0cml4UmVzdWx0KSA9PiBsb2tpTWF0cml4VG9UaW1lU2VyaWVzKG1hdHJpeFJlc3VsdCwgdHJhbnNmb3JtZXJPcHRpb25zKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VRdWVyeVJlc3BvbnNlVG9EYXRhRnJhbWVzKFxuICByZXNwb25zZTogTG9raVJlc3BvbnNlLFxuICBxdWVyeTogTG9raVJhbmdlUXVlcnlSZXF1ZXN0LFxuICB0YXJnZXQ6IExva2lRdWVyeSxcbiAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBudW1iZXIsXG4gIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnNcbik6IERhdGFGcmFtZVtdIHtcbiAgY29uc3Qgc2VyaWVzID0gcmFuZ2VRdWVyeVJlc3BvbnNlVG9UaW1lU2VyaWVzKHJlc3BvbnNlLCBxdWVyeSwgdGFyZ2V0LCByZXNwb25zZUxpc3RMZW5ndGgsIHNjb3BlZFZhcnMpO1xuICBjb25zdCBmcmFtZXMgPSBzZXJpZXMubWFwKChzKSA9PiB0b0RhdGFGcmFtZShzKSk7XG5cbiAgY29uc3QgeyBzdGVwIH0gPSBxdWVyeTtcblxuICBpZiAoc3RlcCAhPSBudWxsKSB7XG4gICAgY29uc3QgaW50ZXJ2YWxNcyA9IHN0ZXAgKiAxMDAwO1xuXG4gICAgZnJhbWVzLmZvckVhY2goKGZyYW1lKSA9PiB7XG4gICAgICBmcmFtZS5maWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09IEZpZWxkVHlwZS50aW1lKSB7XG4gICAgICAgICAgZmllbGQuY29uZmlnLmludGVydmFsID0gaW50ZXJ2YWxNcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnJhbWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1JhbmdlUXVlcnlSZXNwb25zZShcbiAgcmVzcG9uc2U6IExva2lSZXNwb25zZSxcbiAgdGFyZ2V0OiBMb2tpUXVlcnksXG4gIHF1ZXJ5OiBMb2tpUmFuZ2VRdWVyeVJlcXVlc3QsXG4gIHJlc3BvbnNlTGlzdExlbmd0aDogbnVtYmVyLFxuICBsaW1pdDogbnVtYmVyLFxuICBjb25maWc6IExva2lPcHRpb25zLFxuICBzY29wZWRWYXJzOiBTY29wZWRWYXJzLFxuICByZXZlcnNlID0gZmFsc2Vcbikge1xuICBzd2l0Y2ggKHJlc3BvbnNlLmRhdGEucmVzdWx0VHlwZSkge1xuICAgIGNhc2UgTG9raVJlc3VsdFR5cGUuU3RyZWFtOlxuICAgICAgcmV0dXJuIG9mKHtcbiAgICAgICAgZGF0YTogbG9raVN0cmVhbXNUb0RhdGFGcmFtZXMocmVzcG9uc2UgYXMgTG9raVN0cmVhbVJlc3BvbnNlLCB0YXJnZXQsIGxpbWl0LCBjb25maWcsIHJldmVyc2UpLFxuICAgICAgICBrZXk6IGAke3RhcmdldC5yZWZJZH1fbG9nYCxcbiAgICAgIH0pO1xuXG4gICAgY2FzZSBMb2tpUmVzdWx0VHlwZS5WZWN0b3I6XG4gICAgY2FzZSBMb2tpUmVzdWx0VHlwZS5NYXRyaXg6XG4gICAgICByZXR1cm4gb2Yoe1xuICAgICAgICBkYXRhOiByYW5nZVF1ZXJ5UmVzcG9uc2VUb0RhdGFGcmFtZXMoXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZm9ybWF0OiAndGltZV9zZXJpZXMnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzcG9uc2VMaXN0TGVuZ3RoLFxuICAgICAgICAgIHNjb3BlZFZhcnNcbiAgICAgICAgKSxcbiAgICAgICAga2V5OiB0YXJnZXQucmVmSWQsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJlc3VsdCB0eXBlIFwiJHsocmVzcG9uc2UuZGF0YSBhcyBhbnkpLnJlc3VsdFR5cGV9XCIuYCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGFGcmFtZUpTT04sIERhdGFRdWVyeVJlcXVlc3QsIERhdGFRdWVyeVJlc3BvbnNlLCBMaXZlQ2hhbm5lbFNjb3BlLCBMb2FkaW5nU3RhdGUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGdldEdyYWZhbmFMaXZlU3J2IH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBtYXAsIE9ic2VydmFibGUsIGRlZmVyLCBtZXJnZU1hcCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTG9raURhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgTG9raVF1ZXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTdHJlYW1pbmdEYXRhRnJhbWUgfSBmcm9tICdhcHAvZmVhdHVyZXMvbGl2ZS9kYXRhL1N0cmVhbWluZ0RhdGFGcmFtZSc7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGEgdW5pcXVlIGtleSBmb3IgdGhlIHF1ZXJ5LiAgVGhlIGtleSBpcyB1c2VkIHRvIHBpY2sgYSBjaGFubmVsIGFuZCBzaG91bGRcbiAqIGJlIHVuaXF1ZSBmb3IgZWFjaCBkaXN0aW5jdCBxdWVyeSBleGVjdXRpb24gcGxhbi4gIFRoaXMga2V5IGlzIG5vdCBzZWN1cmUgYW5kIGlzIG9ubHkgcGlja2VkIHRvIGF2b2lkXG4gKiBwb3NzaWJsZSBjb2xsaXNpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMaXZlU3RyZWFtS2V5KHF1ZXJ5OiBMb2tpUXVlcnkpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeSh7IGV4cHI6IHF1ZXJ5LmV4cHIgfSk7XG5cbiAgY29uc3QgbXNnVWludDggPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTsgLy8gZW5jb2RlIGFzICh1dGYtOCkgVWludDhBcnJheVxuICBjb25zdCBoYXNoQnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0xJywgbXNnVWludDgpOyAvLyBoYXNoIHRoZSBtZXNzYWdlXG4gIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlci5zbGljZSgwLCA4KSkpOyAvLyBmaXJzdCA4IGJ5dGVzXG4gIHJldHVybiBoYXNoQXJyYXkubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbn1cblxuLy8gVGhpcyB3aWxsIGdldCBib3RoIHYxIGFuZCB2MiByZXN1bHQgZm9ybWF0c1xuZXhwb3J0IGZ1bmN0aW9uIGRvTG9raUNoYW5uZWxTdHJlYW0oXG4gIHF1ZXJ5OiBMb2tpUXVlcnksXG4gIGRzOiBMb2tpRGF0YXNvdXJjZSxcbiAgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxMb2tpUXVlcnk+XG4pOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiB7XG4gIC8vIG1heGltdW0gdGltZSB0byBrZWVwIHZhbHVlc1xuICBjb25zdCByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XG4gIGNvbnN0IG1heERlbHRhID0gcmFuZ2UudG8udmFsdWVPZigpIC0gcmFuZ2UuZnJvbS52YWx1ZU9mKCkgKyAxMDAwO1xuICBsZXQgbWF4TGVuZ3RoID0gb3B0aW9ucy5tYXhEYXRhUG9pbnRzID8/IDEwMDA7XG4gIGlmIChtYXhMZW5ndGggPiAxMDApIHtcbiAgICAvLyBmb3Igc21hbGwgYnVmZmVycywga2VlcCB0aGVtIHNtYWxsXG4gICAgbWF4TGVuZ3RoICo9IDI7XG4gIH1cblxuICBsZXQgZnJhbWU6IFN0cmVhbWluZ0RhdGFGcmFtZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgY29uc3QgdXBkYXRlRnJhbWUgPSAobXNnOiBhbnkpID0+IHtcbiAgICBpZiAobXNnPy5tZXNzYWdlKSB7XG4gICAgICBjb25zdCBwID0gbXNnLm1lc3NhZ2UgYXMgRGF0YUZyYW1lSlNPTjtcbiAgICAgIGlmICghZnJhbWUpIHtcbiAgICAgICAgZnJhbWUgPSBTdHJlYW1pbmdEYXRhRnJhbWUuZnJvbURhdGFGcmFtZUpTT04ocCwge1xuICAgICAgICAgIG1heExlbmd0aCxcbiAgICAgICAgICBtYXhEZWx0YSxcbiAgICAgICAgICBkaXNwbGF5TmFtZUZvcm1hdDogcXVlcnkubGVnZW5kRm9ybWF0LFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYW1lLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFtZTtcbiAgfTtcblxuICByZXR1cm4gZGVmZXIoKCkgPT4gZ2V0TGl2ZVN0cmVhbUtleShxdWVyeSkpLnBpcGUoXG4gICAgbWVyZ2VNYXAoKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGdldEdyYWZhbmFMaXZlU3J2KClcbiAgICAgICAgLmdldFN0cmVhbTxhbnk+KHtcbiAgICAgICAgICBzY29wZTogTGl2ZUNoYW5uZWxTY29wZS5EYXRhU291cmNlLFxuICAgICAgICAgIG5hbWVzcGFjZTogZHMudWlkLFxuICAgICAgICAgIHBhdGg6IGB0YWlsLyR7a2V5fWAsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICB0aW1lUmFuZ2U6IHtcbiAgICAgICAgICAgICAgZnJvbTogcmFuZ2UuZnJvbS52YWx1ZU9mKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG86IHJhbmdlLnRvLnZhbHVlT2YoKS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAucGlwZShcbiAgICAgICAgICBtYXAoKGV2dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSB1cGRhdGVGcmFtZShldnQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YTogZnJhbWUgPyBbZnJhbWVdIDogW10sXG4gICAgICAgICAgICAgIHN0YXRlOiBMb2FkaW5nU3RhdGUuU3RyZWFtaW5nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH0pXG4gICk7XG59XG4iLCJpbXBvcnQgeyBHcmFtbWFyIH0gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgeyBDb21wbGV0aW9uSXRlbSB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuY29uc3QgQUdHUkVHQVRJT05fT1BFUkFUT1JTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdzdW0nLFxuICAgIGluc2VydFRleHQ6ICdzdW0nLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgc3VtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21pbicsXG4gICAgaW5zZXJ0VGV4dDogJ21pbicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtaW5pbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21heCcsXG4gICAgaW5zZXJ0VGV4dDogJ21heCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtYXhpbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2F2ZycsXG4gICAgaW5zZXJ0VGV4dDogJ2F2ZycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSB0aGUgYXZlcmFnZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzdGRkZXYnLFxuICAgIGluc2VydFRleHQ6ICdzdGRkZXYnLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgcG9wdWxhdGlvbiBzdGFuZGFyZCBkZXZpYXRpb24gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnc3RkdmFyJyxcbiAgICBpbnNlcnRUZXh0OiAnc3RkdmFyJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIHBvcHVsYXRpb24gc3RhbmRhcmQgdmFyaWFuY2Ugb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY291bnQnLFxuICAgIGluc2VydFRleHQ6ICdjb3VudCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NvdW50IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdmVjdG9yJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYm90dG9taycsXG4gICAgaW5zZXJ0VGV4dDogJ2JvdHRvbWsnLFxuICAgIGRvY3VtZW50YXRpb246ICdTbWFsbGVzdCBrIGVsZW1lbnRzIGJ5IHNhbXBsZSB2YWx1ZScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3RvcGsnLFxuICAgIGluc2VydFRleHQ6ICd0b3BrJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnTGFyZ2VzdCBrIGVsZW1lbnRzIGJ5IHNhbXBsZSB2YWx1ZScsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUElQRV9QQVJTRVJTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdqc29uJyxcbiAgICBpbnNlcnRUZXh0OiAnanNvbicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0V4dHJhY3RpbmcgbGFiZWxzIGZyb20gdGhlIGxvZyBsaW5lIHVzaW5nIGpzb24gcGFyc2VyLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAncmVnZXhwJyxcbiAgICBpbnNlcnRUZXh0OiAncmVnZXhwIFwiXCInLFxuICAgIGRvY3VtZW50YXRpb246ICdFeHRyYWN0aW5nIGxhYmVscyBmcm9tIHRoZSBsb2cgbGluZSB1c2luZyByZWdleHAgcGFyc2VyLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgICBtb3ZlOiAtMSxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnbG9nZm10JyxcbiAgICBpbnNlcnRUZXh0OiAnbG9nZm10JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRXh0cmFjdGluZyBsYWJlbHMgZnJvbSB0aGUgbG9nIGxpbmUgdXNpbmcgbG9nZm10IHBhcnNlci4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3BhdHRlcm4nLFxuICAgIGluc2VydFRleHQ6ICdwYXR0ZXJuJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRXh0cmFjdGluZyBsYWJlbHMgZnJvbSB0aGUgbG9nIGxpbmUgdXNpbmcgcGF0dGVybiBwYXJzZXIuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4zKy4nLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IFBJUEVfT1BFUkFUT1JTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICd1bndyYXAnLFxuICAgIGluc2VydFRleHQ6ICd1bndyYXAnLFxuICAgIGRldGFpbDogJ3Vud3JhcCBpZGVudGlmaWVyJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1Rha2UgbGFiZWxzIGFuZCB1c2UgdGhlIHZhbHVlcyBhcyBzYW1wbGUgZGF0YSBmb3IgbWV0cmljIGFnZ3JlZ2F0aW9ucy4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3VucGFjaycsXG4gICAgaW5zZXJ0VGV4dDogJ3VucGFjaycsXG4gICAgZGV0YWlsOiAndW5wYWNrIGlkZW50aWZpZXInLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUGFyc2VzIGEgSlNPTiBsb2cgbGluZSwgdW5wYWNraW5nIGFsbCBlbWJlZGRlZCBsYWJlbHMgaW4gdGhlIHBhY2sgc3RhZ2UuIEEgc3BlY2lhbCBwcm9wZXJ0eSBcIl9lbnRyeVwiIHdpbGwgYWxzbyBiZSB1c2VkIHRvIHJlcGxhY2UgdGhlIG9yaWdpbmFsIGxvZyBsaW5lLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnbGFiZWxfZm9ybWF0JyxcbiAgICBpbnNlcnRUZXh0OiAnbGFiZWxfZm9ybWF0JyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1VzZSB0byByZW5hbWUsIG1vZGlmeSBvciBhZGQgbGFiZWxzLiBGb3IgZXhhbXBsZSwgfCBsYWJlbF9mb3JtYXQgZm9vPWJhciAuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdsaW5lX2Zvcm1hdCcsXG4gICAgaW5zZXJ0VGV4dDogJ2xpbmVfZm9ybWF0JyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1Jld3JpdGVzIGxvZyBsaW5lIGNvbnRlbnQuIEZvciBleGFtcGxlLCB8IGxpbmVfZm9ybWF0IFwie3sucXVlcnl9fSB7ey5kdXJhdGlvbn19XCIgLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBSQU5HRV9WRUNfRlVOQ1RJT05TID0gW1xuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2F2Z19vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnYXZnX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnYXZnX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGF2ZXJhZ2Ugb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLiBPbmx5IGF2YWlsYWJsZSBpbiBMb2tpIDIuMCsuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdtaW5fb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ21pbl9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ21pbl9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBtaW5pbXVtIG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWF4X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdtYXhfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdtYXhfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbWF4aW11bSBvZiBhbGwgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N1bV9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3VtX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3VtX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHN1bSBvZiBhbGwgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuIE9ubHkgYXZhaWxhYmxlIGluIExva2kgMi4wKy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdjb3VudF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2NvdW50X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGNvdW50IG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZHZhcl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkdmFyX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkdmFyX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1RoZSBwb3B1bGF0aW9uIHN0YW5kYXJkIHZhcmlhbmNlIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc3RkZGV2X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdzdGRkZXZfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdzdGRkZXZfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3F1YW50aWxlX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAncXVhbnRpbGVfb3Zlcl90aW1lKHNjYWxhciwgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSDPhi1xdWFudGlsZSAoMCDiiaQgz4Yg4omkIDEpIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgaW4gTG9raSAyLjArLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYnl0ZXNfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2J5dGVzX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnYnl0ZXNfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDb3VudHMgdGhlIGFtb3VudCBvZiBieXRlcyB1c2VkIGJ5IGVhY2ggbG9nIHN0cmVhbSBmb3IgYSBnaXZlbiByYW5nZScsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYnl0ZXNfcmF0ZScsXG4gICAgbGFiZWw6ICdieXRlc19yYXRlJyxcbiAgICBkZXRhaWw6ICdieXRlc19yYXRlKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgcGVyIHNlY29uZCBmb3IgZWFjaCBzdHJlYW0uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyYXRlJyxcbiAgICBsYWJlbDogJ3JhdGUnLFxuICAgIGRldGFpbDogJ3JhdGUodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGVudHJpZXMgcGVyIHNlY29uZC4nLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEZVTkNUSU9OUyA9IFsuLi5BR0dSRUdBVElPTl9PUEVSQVRPUlMsIC4uLlJBTkdFX1ZFQ19GVU5DVElPTlNdO1xuZXhwb3J0IGNvbnN0IExPS0lfS0VZV09SRFMgPSBbLi4uRlVOQ1RJT05TLCAuLi5QSVBFX09QRVJBVE9SUywgLi4uUElQRV9QQVJTRVJTXS5tYXAoKGtleXdvcmQpID0+IGtleXdvcmQubGFiZWwpO1xuXG5leHBvcnQgY29uc3QgbG9raUdyYW1tYXI6IEdyYW1tYXIgPSB7XG4gIGNvbW1lbnQ6IHtcbiAgICBwYXR0ZXJuOiAvIy4qLyxcbiAgfSxcbiAgJ2NvbnRleHQtYWdncmVnYXRpb24nOiB7XG4gICAgcGF0dGVybjogLygod2l0aG91dHxieSlcXHMqKVxcKFteKV0qXFwpLywgLy8gYnkgKClcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2xhYmVsLWtleSc6IHtcbiAgICAgICAgcGF0dGVybjogL1teKCksXFxzXVteLCldKlteKSxcXHNdKi8sXG4gICAgICAgIGFsaWFzOiAnYXR0ci1uYW1lJyxcbiAgICAgIH0sXG4gICAgICBwdW5jdHVhdGlvbjogL1soKV0vLFxuICAgIH0sXG4gIH0sXG4gICdjb250ZXh0LWxhYmVscyc6IHtcbiAgICBwYXR0ZXJuOiAvXFx7W159XSooPz19PykvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgcGF0dGVybjogLyMuKi8sXG4gICAgICB9LFxuICAgICAgJ2xhYmVsLWtleSc6IHtcbiAgICAgICAgcGF0dGVybjogL1thLXpBLVpfXVxcdyooPz1cXHMqKD18IT18PX58IX4pKS8sXG4gICAgICAgIGFsaWFzOiAnYXR0ci1uYW1lJyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgfSxcbiAgICAgICdsYWJlbC12YWx1ZSc6IHtcbiAgICAgICAgcGF0dGVybjogL1wiKD86XFxcXC58W15cXFxcXCJdKSpcIi8sXG4gICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdhdHRyLXZhbHVlJyxcbiAgICAgIH0sXG4gICAgICBwdW5jdHVhdGlvbjogL1t7XS8sXG4gICAgfSxcbiAgfSxcbiAgJ2NvbnRleHQtcGlwZSc6IHtcbiAgICBwYXR0ZXJuOiAvXFxzXFx8W149fl1cXHM/XFx3Ki9pLFxuICAgIGluc2lkZToge1xuICAgICAgJ3BpcGUtb3BlcmF0b3InOiB7XG4gICAgICAgIHBhdHRlcm46IC9cXHwvaSxcbiAgICAgICAgYWxpYXM6ICdvcGVyYXRvcicsXG4gICAgICB9LFxuICAgICAgJ3BpcGUtb3BlcmF0aW9ucyc6IHtcbiAgICAgICAgcGF0dGVybjogbmV3IFJlZ0V4cChgJHtbLi4uUElQRV9QQVJTRVJTLCAuLi5QSVBFX09QRVJBVE9SU10ubWFwKChmKSA9PiBmLmxhYmVsKS5qb2luKCd8Jyl9YCwgJ2knKSxcbiAgICAgICAgYWxpYXM6ICdrZXl3b3JkJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbiAgZnVuY3Rpb246IG5ldyBSZWdFeHAoYFxcXFxiKD86JHtGVU5DVElPTlMubWFwKChmKSA9PiBmLmxhYmVsKS5qb2luKCd8Jyl9KSg/PVxcXFxzKlxcXFwoKWAsICdpJyksXG4gICdjb250ZXh0LXJhbmdlJzogW1xuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXFtbXlxcXV0qKD89XFxdKS8sIC8vIFsxbV1cbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKG9mZnNldFxccyspXFx3Ky8sIC8vIG9mZnNldCAxbVxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbiAgcXVvdGU6IHtcbiAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcLnxbXlxcXFxcIl0pKlwiLyxcbiAgICBhbGlhczogJ3N0cmluZycsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICB9LFxuICBiYWNrdGlja3M6IHtcbiAgICBwYXR0ZXJuOiAvYCg/OlxcXFwufFteXFxcXGBdKSpgLyxcbiAgICBhbGlhczogJ3N0cmluZycsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICB9LFxuICBudW1iZXI6IC9cXGItP1xcZCsoKFxcLlxcZCopPyhbZUVdWystXT9cXGQrKT8pP1xcYi8sXG4gIG9wZXJhdG9yOiAvXFxzPyhcXHxbPX5dP3whPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT8pXFxzPy9pLFxuICBwdW5jdHVhdGlvbjogL1t7fSgpLC5dLyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxva2lHcmFtbWFyO1xuIiwiaW1wb3J0IHsgRGF0YVF1ZXJ5LCBEYXRhU291cmNlSnNvbkRhdGEsIFF1ZXJ5UmVzdWx0TWV0YSwgU2NvcGVkVmFycyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi4vcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IExva2lWaXN1YWxRdWVyeSB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBMb2tpSW5zdGFudFF1ZXJ5UmVxdWVzdCB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIGxpbWl0PzogbnVtYmVyO1xuICB0aW1lPzogc3RyaW5nO1xuICBkaXJlY3Rpb24/OiAnQkFDS1dBUkQnIHwgJ0ZPUldBUkQnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lSYW5nZVF1ZXJ5UmVxdWVzdCB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIGxpbWl0PzogbnVtYmVyO1xuICBzdGFydD86IG51bWJlcjtcbiAgZW5kPzogbnVtYmVyO1xuICBzdGVwPzogbnVtYmVyO1xuICBkaXJlY3Rpb24/OiAnQkFDS1dBUkQnIHwgJ0ZPUldBUkQnO1xufVxuXG5leHBvcnQgZW51bSBMb2tpUmVzdWx0VHlwZSB7XG4gIFN0cmVhbSA9ICdzdHJlYW1zJyxcbiAgVmVjdG9yID0gJ3ZlY3RvcicsXG4gIE1hdHJpeCA9ICdtYXRyaXgnLFxufVxuXG5leHBvcnQgZW51bSBMb2tpUXVlcnlUeXBlIHtcbiAgUmFuZ2UgPSAncmFuZ2UnLFxuICBJbnN0YW50ID0gJ2luc3RhbnQnLFxuICBTdHJlYW0gPSAnc3RyZWFtJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpUXVlcnkgZXh0ZW5kcyBEYXRhUXVlcnkge1xuICBxdWVyeVR5cGU/OiBMb2tpUXVlcnlUeXBlO1xuICBleHByOiBzdHJpbmc7XG4gIHF1ZXJ5Pzogc3RyaW5nO1xuICBmb3JtYXQ/OiBzdHJpbmc7XG4gIHJldmVyc2U/OiBib29sZWFuO1xuICBsZWdlbmRGb3JtYXQ/OiBzdHJpbmc7XG4gIHZhbHVlV2l0aFJlZklkPzogYm9vbGVhbjtcbiAgbWF4TGluZXM/OiBudW1iZXI7XG4gIHJlc29sdXRpb24/OiBudW1iZXI7XG4gIC8qKiBVc2VkIGluIHJhbmdlIHF1ZXJpZXMgKi9cbiAgdm9sdW1lUXVlcnk/OiBib29sZWFuO1xuICAvKiBAZGVwcmVjYXRlZCBub3cgdXNlIHF1ZXJ5VHlwZSAqL1xuICByYW5nZT86IGJvb2xlYW47XG4gIC8qIEBkZXByZWNhdGVkIG5vdyB1c2UgcXVlcnlUeXBlICovXG4gIGluc3RhbnQ/OiBib29sZWFuO1xuICBlZGl0b3JNb2RlPzogUXVlcnlFZGl0b3JNb2RlO1xuICAvKiogVGVtcG9yYXJ5IHVudGlsIHdlIGhhdmUgYSBwYXJzZXIgKi9cbiAgdmlzdWFsUXVlcnk/OiBMb2tpVmlzdWFsUXVlcnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raU9wdGlvbnMgZXh0ZW5kcyBEYXRhU291cmNlSnNvbkRhdGEge1xuICBtYXhMaW5lcz86IHN0cmluZztcbiAgZGVyaXZlZEZpZWxkcz86IERlcml2ZWRGaWVsZENvbmZpZ1tdO1xuICBhbGVydG1hbmFnZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVN0YXRzIHtcbiAgW2NvbXBvbmVudDogc3RyaW5nXToge1xuICAgIFtsYWJlbDogc3RyaW5nXTogbnVtYmVyO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lWZWN0b3JSZXN1bHQge1xuICBtZXRyaWM6IHsgW2xhYmVsOiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgdmFsdWU6IFtudW1iZXIsIHN0cmluZ107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raVZlY3RvclJlc3BvbnNlIHtcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGRhdGE6IHtcbiAgICByZXN1bHRUeXBlOiBMb2tpUmVzdWx0VHlwZS5WZWN0b3I7XG4gICAgcmVzdWx0OiBMb2tpVmVjdG9yUmVzdWx0W107XG4gICAgc3RhdHM/OiBMb2tpU3RhdHM7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9raU1hdHJpeFJlc3VsdCB7XG4gIG1ldHJpYzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgdmFsdWVzOiBBcnJheTxbbnVtYmVyLCBzdHJpbmddPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpTWF0cml4UmVzcG9uc2Uge1xuICBzdGF0dXM6IHN0cmluZztcbiAgZGF0YToge1xuICAgIHJlc3VsdFR5cGU6IExva2lSZXN1bHRUeXBlLk1hdHJpeDtcbiAgICByZXN1bHQ6IExva2lNYXRyaXhSZXN1bHRbXTtcbiAgICBzdGF0cz86IExva2lTdGF0cztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2tpU3RyZWFtUmVzdWx0IHtcbiAgc3RyZWFtOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICB2YWx1ZXM6IEFycmF5PFtzdHJpbmcsIHN0cmluZ10+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lTdHJlYW1SZXNwb25zZSB7XG4gIHN0YXR1czogc3RyaW5nO1xuICBkYXRhOiB7XG4gICAgcmVzdWx0VHlwZTogTG9raVJlc3VsdFR5cGUuU3RyZWFtO1xuICAgIHJlc3VsdDogTG9raVN0cmVhbVJlc3VsdFtdO1xuICAgIHN0YXRzPzogTG9raVN0YXRzO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lUYWlsUmVzcG9uc2Uge1xuICBzdHJlYW1zOiBMb2tpU3RyZWFtUmVzdWx0W107XG4gIGRyb3BwZWRfZW50cmllcz86IEFycmF5PHtcbiAgICBsYWJlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgdGltZXN0YW1wOiBzdHJpbmc7XG4gIH0+IHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgTG9raVJlc3VsdCA9IExva2lWZWN0b3JSZXN1bHQgfCBMb2tpTWF0cml4UmVzdWx0IHwgTG9raVN0cmVhbVJlc3VsdDtcbmV4cG9ydCB0eXBlIExva2lSZXNwb25zZSA9IExva2lWZWN0b3JSZXNwb25zZSB8IExva2lNYXRyaXhSZXNwb25zZSB8IExva2lTdHJlYW1SZXNwb25zZTtcblxuZXhwb3J0IGludGVyZmFjZSBMb2tpTG9nc1N0cmVhbUVudHJ5IHtcbiAgbGluZTogc3RyaW5nO1xuICB0czogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExva2lFeHByZXNzaW9uIHtcbiAgcmVnZXhwOiBzdHJpbmc7XG4gIHF1ZXJ5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIERlcml2ZWRGaWVsZENvbmZpZyA9IHtcbiAgbWF0Y2hlclJlZ2V4OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xuICB1cmxEaXNwbGF5TGFiZWw/OiBzdHJpbmc7XG4gIGRhdGFzb3VyY2VVaWQ/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZm9ybWVyT3B0aW9ucyB7XG4gIGZvcm1hdD86IHN0cmluZztcbiAgbGVnZW5kRm9ybWF0Pzogc3RyaW5nO1xuICBzdGVwOiBudW1iZXI7XG4gIHN0YXJ0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xuICBxdWVyeTogc3RyaW5nO1xuICByZXNwb25zZUxpc3RMZW5ndGg6IG51bWJlcjtcbiAgcmVmSWQ6IHN0cmluZztcbiAgc2NvcGVkVmFyczogU2NvcGVkVmFycztcbiAgbWV0YT86IFF1ZXJ5UmVzdWx0TWV0YTtcbiAgdmFsdWVXaXRoUmVmSWQ/OiBib29sZWFuO1xufVxuIiwiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnbGV6ZXItcHJvbXFsJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvcGFyc2luZyc7XG5pbXBvcnQgeyBQcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeSB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3R5cGVzJztcblxuLyoqXG4gKiBBZGRzIGxhYmVsIGZpbHRlciB0byBleGlzdGluZyBxdWVyeS4gVXNlZnVsIGZvciBxdWVyeSBtb2RpZmljYXRpb24gZm9yIGV4YW1wbGUgZm9yIGFkIGhvYyBmaWx0ZXJzLlxuICpcbiAqIEl0IHVzZXMgUHJvbVFMIHBhcnNlciB0byBmaW5kIGluc3RhbmNlcyBvZiBtZXRyaWMgYW5kIGxhYmVscywgYWx0ZXJzIHRoZW0gYW5kIHRoZW4gc3BsaWNlcyB0aGVtIGJhY2sgaW50byB0aGUgcXVlcnkuXG4gKiBJZGVhbGx5IHdlIGNvdWxkIHVzZSB0aGUgcGFyc2UgLT4gY2hhbmdlIC0+IHJlbmRlciBpcyBhIHNpbXBsZSAzIHN0ZXBzIGJ1dCByaWdodCBub3cgYnVpbGRpbmcgdGhlIHZpc3VhbCBxdWVyeVxuICogb2JqZWN0IGRvZXMgbm90IHN1cHBvcnQgYWxsIHBvc3NpYmxlIHF1ZXJpZXMuXG4gKlxuICogU28gaW5zdGVhZCB0aGlzIGp1c3Qgb3BlcmF0ZXMgb24gc3Vic3RyaW5ncyBvZiB0aGUgcXVlcnkgd2l0aCBsYWJlbHMgYW5kIG9wZXJhdGVzIGp1c3Qgb24gdGhvc2UuIFRoaXMgbWFrZXMgdGhpc1xuICogbW9yZSByb2J1c3QgYW5kIGNhbiBhbHRlciBldmVuIGludmFsaWQgcXVlcmllcywgYW5kIHByZXNlcnZlcyBpbiBnZW5lcmFsIHRoZSBxdWVyeSBzdHJ1Y3R1cmUgYW5kIHdoaXRlc3BhY2UuXG4gKiBAcGFyYW0gcXVlcnlcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG9wZXJhdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRMYWJlbFRvUXVlcnkocXVlcnk6IHN0cmluZywga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIG9wZXJhdG9yID0gJz0nKTogc3RyaW5nIHtcbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGxhYmVsIHRvIGFkZCB0byBxdWVyeS4nKTtcbiAgfVxuXG4gIGNvbnN0IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zID0gZ2V0VmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMocXVlcnkpO1xuICBpZiAoIXZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlciA9IHRvTGFiZWxGaWx0ZXIoa2V5LCB2YWx1ZSwgb3BlcmF0b3IpO1xuICByZXR1cm4gYWRkRmlsdGVyKHF1ZXJ5LCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucywgZmlsdGVyKTtcbn1cblxudHlwZSBWZWN0b3JTZWxlY3RvclBvc2l0aW9uID0geyBmcm9tOiBudW1iZXI7IHRvOiBudW1iZXI7IHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgc3RyaW5nIGFuZCBnZXQgYWxsIFZlY3RvclNlbGVjdG9yIHBvc2l0aW9ucyBpbiB0aGUgcXVlcnkgdG9nZXRoZXIgd2l0aCBwYXJzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICogc2VsZWN0b3IuXG4gKiBAcGFyYW0gcXVlcnlcbiAqL1xuZnVuY3Rpb24gZ2V0VmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMocXVlcnk6IHN0cmluZyk6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSB7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyc2UocXVlcnkpO1xuICBjb25zdCBwb3NpdGlvbnM6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSA9IFtdO1xuICB0cmVlLml0ZXJhdGUoe1xuICAgIGVudGVyOiAodHlwZSwgZnJvbSwgdG8sIGdldCk6IGZhbHNlIHwgdm9pZCA9PiB7XG4gICAgICBpZiAodHlwZS5uYW1lID09PSAnVmVjdG9yU2VsZWN0b3InKSB7XG4gICAgICAgIGNvbnN0IHZpc1F1ZXJ5ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcocXVlcnkuc3Vic3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHsgcXVlcnk6IHZpc1F1ZXJ5LnF1ZXJ5LCBmcm9tLCB0byB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG5mdW5jdGlvbiB0b0xhYmVsRmlsdGVyKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBvcGVyYXRvcjogc3RyaW5nKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGNvbnZlcnQgdGhlIHZhbHVlIGJhY2sgdG8gc3RyaW5nIGJlY2F1c2UgaXQgbWF5IGJlIGEgbnVtYmVyXG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB2YWx1ZSA9PT0gSW5maW5pdHkgPyAnK0luZicgOiB2YWx1ZS50b1N0cmluZygpO1xuICByZXR1cm4geyBsYWJlbDoga2V5LCBvcDogb3BlcmF0b3IsIHZhbHVlOiB0cmFuc2Zvcm1lZFZhbHVlIH07XG59XG5cbmZ1bmN0aW9uIGFkZEZpbHRlcihcbiAgcXVlcnk6IHN0cmluZyxcbiAgdmVjdG9yU2VsZWN0b3JQb3NpdGlvbnM6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSxcbiAgZmlsdGVyOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlclxuKTogc3RyaW5nIHtcbiAgY29uc3QgbW9kZWxsZXIgPSBuZXcgUHJvbVF1ZXJ5TW9kZWxsZXIoKTtcbiAgbGV0IG5ld1F1ZXJ5ID0gJyc7XG4gIGxldCBwcmV2ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gVGhpcyBpcyBiYXNpY2FsbHkganVzdCBkb2luZyBzcGxpY2Ugb24gYSBzdHJpbmcgZm9yIGVhY2ggbWF0Y2hlZCB2ZWN0b3Igc2VsZWN0b3IuXG5cbiAgICBjb25zdCBtYXRjaCA9IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zW2ldO1xuICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aCAtIDE7XG5cbiAgICBjb25zdCBzdGFydCA9IHF1ZXJ5LnN1YnN0cmluZyhwcmV2LCBtYXRjaC5mcm9tKTtcbiAgICBjb25zdCBlbmQgPSBpc0xhc3QgPyBxdWVyeS5zdWJzdHJpbmcobWF0Y2gudG8pIDogJyc7XG5cbiAgICBpZiAoIWxhYmVsRXhpc3RzKG1hdGNoLnF1ZXJ5LmxhYmVscywgZmlsdGVyKSkge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBhZGQgZHVwbGljYXRlIGxhYmVscy5cbiAgICAgIG1hdGNoLnF1ZXJ5LmxhYmVscy5wdXNoKGZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0xhYmVscyA9IG1vZGVsbGVyLnJlbmRlclF1ZXJ5KG1hdGNoLnF1ZXJ5KTtcbiAgICBuZXdRdWVyeSArPSBzdGFydCArIG5ld0xhYmVscyArIGVuZDtcbiAgICBwcmV2ID0gbWF0Y2gudG87XG4gIH1cbiAgcmV0dXJuIG5ld1F1ZXJ5O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGxhYmVsIGV4aXN0cyBpbiB0aGUgbGlzdCBvZiBsYWJlbHMgYnV0IGlnbm9yZSB0aGUgb3BlcmF0b3IuXG4gKiBAcGFyYW0gbGFiZWxzXG4gKiBAcGFyYW0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIGxhYmVsRXhpc3RzKGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSwgZmlsdGVyOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcikge1xuICByZXR1cm4gbGFiZWxzLmZpbmQoKGxhYmVsKSA9PiBsYWJlbC5sYWJlbCA9PT0gZmlsdGVyLmxhYmVsICYmIGxhYmVsLnZhbHVlID09PSBmaWx0ZXIudmFsdWUpO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNsb25lRGVlcCwgZGVmYXVsdHMgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZm9ya0pvaW4sIGxhc3RWYWx1ZUZyb20sIG1lcmdlLCBPYnNlcnZhYmxlLCBvZiwgT3BlcmF0b3JGdW5jdGlvbiwgcGlwZSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgZmlsdGVyLCBtYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCB7XG4gIEFubm90YXRpb25FdmVudCxcbiAgQ29yZUFwcCxcbiAgRGF0YVF1ZXJ5RXJyb3IsXG4gIERhdGFRdWVyeVJlcXVlc3QsXG4gIERhdGFRdWVyeVJlc3BvbnNlLFxuICBEYXRhU291cmNlSW5zdGFuY2VTZXR0aW5ncyxcbiAgRGF0YVNvdXJjZVdpdGhRdWVyeUV4cG9ydFN1cHBvcnQsXG4gIERhdGFTb3VyY2VXaXRoUXVlcnlJbXBvcnRTdXBwb3J0LFxuICBkYXRlTWF0aCxcbiAgRGF0ZVRpbWUsXG4gIEFic3RyYWN0UXVlcnksXG4gIExvYWRpbmdTdGF0ZSxcbiAgcmFuZ2VVdGlsLFxuICBTY29wZWRWYXJzLFxuICBUaW1lUmFuZ2UsXG4gIERhdGFGcmFtZSxcbiAgZGF0ZVRpbWUsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHtcbiAgQmFja2VuZFNydlJlcXVlc3QsXG4gIEZldGNoRXJyb3IsXG4gIEZldGNoUmVzcG9uc2UsXG4gIGdldEJhY2tlbmRTcnYsXG4gIERhdGFTb3VyY2VXaXRoQmFja2VuZCxcbiAgQmFja2VuZERhdGFTb3VyY2VSZXNwb25zZSxcbiAgdG9EYXRhUXVlcnlSZXNwb25zZSxcbn0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5cbmltcG9ydCB7IHNhZmVTdHJpbmdpZnlWYWx1ZSB9IGZyb20gJ2FwcC9jb3JlL3V0aWxzL2V4cGxvcmUnO1xuaW1wb3J0IHsgZ2V0VGltZVNydiwgVGltZVNydiB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvc2VydmljZXMvVGltZVNydic7XG5pbXBvcnQgeyBnZXRUZW1wbGF0ZVNydiwgVGVtcGxhdGVTcnYgfSBmcm9tICdhcHAvZmVhdHVyZXMvdGVtcGxhdGluZy90ZW1wbGF0ZV9zcnYnO1xuaW1wb3J0IHsgYWRkTGFiZWxUb1F1ZXJ5IH0gZnJvbSAnLi9hZGRfbGFiZWxfdG9fcXVlcnknO1xuaW1wb3J0IFByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4vbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgZXhwYW5kUmVjb3JkaW5nUnVsZXMgfSBmcm9tICcuL2xhbmd1YWdlX3V0aWxzJztcbmltcG9ydCB7IGdldEluaXRIaW50cywgZ2V0UXVlcnlIaW50cyB9IGZyb20gJy4vcXVlcnlfaGludHMnO1xuaW1wb3J0IHsgZ2V0T3JpZ2luYWxNZXRyaWNOYW1lLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybVYyIH0gZnJvbSAnLi9yZXN1bHRfdHJhbnNmb3JtZXInO1xuaW1wb3J0IHtcbiAgRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24sXG4gIFByb21EYXRhRXJyb3JSZXNwb25zZSxcbiAgUHJvbURhdGFTdWNjZXNzUmVzcG9uc2UsXG4gIFByb21FeGVtcGxhckRhdGEsXG4gIFByb21NYXRyaXhEYXRhLFxuICBQcm9tT3B0aW9ucyxcbiAgUHJvbVF1ZXJ5LFxuICBQcm9tUXVlcnlSZXF1ZXN0LFxuICBQcm9tUXVlcnlUeXBlLFxuICBQcm9tU2NhbGFyRGF0YSxcbiAgUHJvbVZlY3RvckRhdGEsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgUHJvbWV0aGV1c1ZhcmlhYmxlU3VwcG9ydCB9IGZyb20gJy4vdmFyaWFibGVzJztcbmltcG9ydCBQcm9tZXRoZXVzTWV0cmljRmluZFF1ZXJ5IGZyb20gJy4vbWV0cmljX2ZpbmRfcXVlcnknO1xuaW1wb3J0IHsgcmVuZGVyTGVnZW5kRm9ybWF0IH0gZnJvbSAnLi9sZWdlbmQnO1xuaW1wb3J0IHsgZmV0Y2hEYXRhU291cmNlQnVpbGRJbmZvIH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2FsZXJ0aW5nL3VuaWZpZWQvYXBpL2J1aWxkSW5mbyc7XG5pbXBvcnQgeyBQcm9tQXBwbGljYXRpb24sIFByb21CdWlsZEluZm8gfSBmcm9tICdhcHAvdHlwZXMvdW5pZmllZC1hbGVydGluZy1kdG8nO1xuaW1wb3J0IHsgQmFkZ2UsIEJhZGdlQ29sb3IsIFRvb2x0aXAgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmV4cG9ydCBjb25zdCBBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVCA9ICc2MHMnO1xuY29uc3QgR0VUX0FORF9QT1NUX01FVEFEQVRBX0VORFBPSU5UUyA9IFsnYXBpL3YxL3F1ZXJ5JywgJ2FwaS92MS9xdWVyeV9yYW5nZScsICdhcGkvdjEvc2VyaWVzJywgJ2FwaS92MS9sYWJlbHMnXTtcblxuZXhwb3J0IGNsYXNzIFByb21ldGhldXNEYXRhc291cmNlXG4gIGV4dGVuZHMgRGF0YVNvdXJjZVdpdGhCYWNrZW5kPFByb21RdWVyeSwgUHJvbU9wdGlvbnM+XG4gIGltcGxlbWVudHMgRGF0YVNvdXJjZVdpdGhRdWVyeUltcG9ydFN1cHBvcnQ8UHJvbVF1ZXJ5PiwgRGF0YVNvdXJjZVdpdGhRdWVyeUV4cG9ydFN1cHBvcnQ8UHJvbVF1ZXJ5Plxue1xuICB0eXBlOiBzdHJpbmc7XG4gIGVkaXRvclNyYzogc3RyaW5nO1xuICBydWxlTWFwcGluZ3M6IHsgW2luZGV4OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgdXJsOiBzdHJpbmc7XG4gIGlkOiBudW1iZXI7XG4gIGRpcmVjdFVybDogc3RyaW5nO1xuICBhY2Nlc3M6ICdkaXJlY3QnIHwgJ3Byb3h5JztcbiAgYmFzaWNBdXRoOiBhbnk7XG4gIHdpdGhDcmVkZW50aWFsczogYW55O1xuICBtZXRyaWNzTmFtZUNhY2hlID0gbmV3IExSVTxzdHJpbmcsIHN0cmluZ1tdPih7IG1heDogMTAgfSk7XG4gIGludGVydmFsOiBzdHJpbmc7XG4gIHF1ZXJ5VGltZW91dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBodHRwTWV0aG9kOiBzdHJpbmc7XG4gIGxhbmd1YWdlUHJvdmlkZXI6IFByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyO1xuICBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW10gfCB1bmRlZmluZWQ7XG4gIGxvb2t1cHNEaXNhYmxlZDogYm9vbGVhbjtcbiAgY3VzdG9tUXVlcnlQYXJhbWV0ZXJzOiBhbnk7XG4gIGV4ZW1wbGFyc0F2YWlsYWJsZTogYm9vbGVhbjtcbiAgc3ViVHlwZTogUHJvbUFwcGxpY2F0aW9uO1xuICBydWxlckVuYWJsZWQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgaW5zdGFuY2VTZXR0aW5nczogRGF0YVNvdXJjZUluc3RhbmNlU2V0dGluZ3M8UHJvbU9wdGlvbnM+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVTcnY6IFRlbXBsYXRlU3J2ID0gZ2V0VGVtcGxhdGVTcnYoKSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRpbWVTcnY6IFRpbWVTcnYgPSBnZXRUaW1lU3J2KCksXG4gICAgbGFuZ3VhZ2VQcm92aWRlcj86IFByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyXG4gICkge1xuICAgIHN1cGVyKGluc3RhbmNlU2V0dGluZ3MpO1xuXG4gICAgdGhpcy50eXBlID0gJ3Byb21ldGhldXMnO1xuICAgIHRoaXMuc3ViVHlwZSA9IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzO1xuICAgIHRoaXMucnVsZXJFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5lZGl0b3JTcmMgPSAnYXBwL2ZlYXR1cmVzL3Byb21ldGhldXMvcGFydGlhbHMvcXVlcnkuZWRpdG9yLmh0bWwnO1xuICAgIHRoaXMuaWQgPSBpbnN0YW5jZVNldHRpbmdzLmlkO1xuICAgIHRoaXMudXJsID0gaW5zdGFuY2VTZXR0aW5ncy51cmwhO1xuICAgIHRoaXMuYWNjZXNzID0gaW5zdGFuY2VTZXR0aW5ncy5hY2Nlc3M7XG4gICAgdGhpcy5iYXNpY0F1dGggPSBpbnN0YW5jZVNldHRpbmdzLmJhc2ljQXV0aDtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGluc3RhbmNlU2V0dGluZ3Mud2l0aENyZWRlbnRpYWxzO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLnRpbWVJbnRlcnZhbCB8fCAnMTVzJztcbiAgICB0aGlzLnF1ZXJ5VGltZW91dCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEucXVlcnlUaW1lb3V0O1xuICAgIHRoaXMuaHR0cE1ldGhvZCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuaHR0cE1ldGhvZCB8fCAnUE9TVCc7XG4gICAgLy8gYGRpcmVjdFVybGAgaXMgbmV2ZXIgdW5kZWZpbmVkLCB3ZSBzZXQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2dyYWZhbmEvZ3JhZmFuYS9ibG9iL21haW4vcGtnL2FwaS9mcm9udGVuZHNldHRpbmdzLmdvI0wxMDhcbiAgICAvLyBoZXJlIHdlIFwiZmFsbCBiYWNrXCIgdG8gdGhpcy51cmwgdG8gbWFrZSB0eXBlc2NyaXB0IGhhcHB5LCBidXQgaXQgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgIHRoaXMuZGlyZWN0VXJsID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5kaXJlY3RVcmwgPz8gdGhpcy51cmw7XG4gICAgdGhpcy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMgPSBpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucztcbiAgICB0aGlzLnJ1bGVNYXBwaW5ncyA9IHt9O1xuICAgIHRoaXMubGFuZ3VhZ2VQcm92aWRlciA9IGxhbmd1YWdlUHJvdmlkZXIgPz8gbmV3IFByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyKHRoaXMpO1xuICAgIHRoaXMubG9va3Vwc0Rpc2FibGVkID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5kaXNhYmxlTWV0cmljc0xvb2t1cCA/PyBmYWxzZTtcbiAgICB0aGlzLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5jdXN0b21RdWVyeVBhcmFtZXRlcnMpO1xuICAgIHRoaXMudmFyaWFibGVzID0gbmV3IFByb21ldGhldXNWYXJpYWJsZVN1cHBvcnQodGhpcywgdGhpcy50ZW1wbGF0ZVNydiwgdGhpcy50aW1lU3J2KTtcbiAgICB0aGlzLmV4ZW1wbGFyc0F2YWlsYWJsZSA9IHRydWU7XG4gIH1cblxuICBpbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRoaXMubG9hZFJ1bGVzKCk7XG4gICAgdGhpcy5leGVtcGxhcnNBdmFpbGFibGUgPSBhd2FpdCB0aGlzLmFyZUV4ZW1wbGFyc0F2YWlsYWJsZSgpO1xuICB9O1xuXG4gIGdldFF1ZXJ5RGlzcGxheVRleHQocXVlcnk6IFByb21RdWVyeSkge1xuICAgIHJldHVybiBxdWVyeS5leHByO1xuICB9XG5cbiAgX2FkZFRyYWNpbmdIZWFkZXJzKGh0dHBPcHRpb25zOiBQcm9tUXVlcnlSZXF1ZXN0LCBvcHRpb25zOiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pIHtcbiAgICBodHRwT3B0aW9ucy5oZWFkZXJzID0ge307XG4gICAgY29uc3QgcHJveHlNb2RlID0gIXRoaXMudXJsLm1hdGNoKC9eaHR0cC8pO1xuICAgIGlmIChwcm94eU1vZGUpIHtcbiAgICAgIGh0dHBPcHRpb25zLmhlYWRlcnNbJ1gtRGFzaGJvYXJkLUlkJ10gPSBvcHRpb25zLmRhc2hib2FyZElkO1xuICAgICAgaHR0cE9wdGlvbnMuaGVhZGVyc1snWC1QYW5lbC1JZCddID0gb3B0aW9ucy5wYW5lbElkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgcmVxdWVzdCBkb25lIGZyb20gdGhpcyBkYXRhIHNvdXJjZSBzaG91bGQgZ28gdGhyb3VnaCBoZXJlIGFzIGl0IGNvbnRhaW5zIHNvbWUgY29tbW9uIHByb2Nlc3NpbmcgZm9yIHRoZVxuICAgKiByZXF1ZXN0LiBBbnkgcHJvY2Vzc2luZyBkb25lIGhlcmUgbmVlZHMgdG8gYmUgYWxzbyBjb3BpZWQgb24gdGhlIGJhY2tlbmQgYXMgdGhpcyBnb2VzIHRocm91Z2ggZGF0YSBzb3VyY2UgcHJveHlcbiAgICogYnV0IG5vdCB0aHJvdWdoIHRoZSBzYW1lIGNvZGUgYXMgYWxlcnRpbmcuXG4gICAqL1xuICBfcmVxdWVzdDxUID0gYW55PihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCxcbiAgICBvdmVycmlkZXM6IFBhcnRpYWw8QmFja2VuZFNydlJlcXVlc3Q+ID0ge31cbiAgKTogT2JzZXJ2YWJsZTxGZXRjaFJlc3BvbnNlPFQ+PiB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5jdXN0b21RdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgIGlmIChkYXRhW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zOiBCYWNrZW5kU3J2UmVxdWVzdCA9IGRlZmF1bHRzKG92ZXJyaWRlcywge1xuICAgICAgdXJsOiB0aGlzLnVybCArIHVybCxcbiAgICAgIG1ldGhvZDogdGhpcy5odHRwTWV0aG9kLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGgpIHtcbiAgICAgICAgb3B0aW9ucy51cmwgPVxuICAgICAgICAgIG9wdGlvbnMudXJsICtcbiAgICAgICAgICAob3B0aW9ucy51cmwuc2VhcmNoKC9cXD8vKSA+PSAwID8gJyYnIDogJz8nKSArXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSlcbiAgICAgICAgICAgIC5tYXAoKFtrLCB2XSkgPT4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGspfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2KX1gKVxuICAgICAgICAgICAgLmpvaW4oJyYnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzIVsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgIG9wdGlvbnMuZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmFzaWNBdXRoIHx8IHRoaXMud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICBvcHRpb25zLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmFzaWNBdXRoKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMhLkF1dGhvcml6YXRpb24gPSB0aGlzLmJhc2ljQXV0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0QmFja2VuZFNydigpLmZldGNoPFQ+KG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgaW1wb3J0RnJvbUFic3RyYWN0UXVlcmllcyhhYnN0cmFjdFF1ZXJpZXM6IEFic3RyYWN0UXVlcnlbXSk6IFByb21pc2U8UHJvbVF1ZXJ5W10+IHtcbiAgICByZXR1cm4gYWJzdHJhY3RRdWVyaWVzLm1hcCgoYWJzdHJhY3RRdWVyeSkgPT4gdGhpcy5sYW5ndWFnZVByb3ZpZGVyLmltcG9ydEZyb21BYnN0cmFjdFF1ZXJ5KGFic3RyYWN0UXVlcnkpKTtcbiAgfVxuXG4gIGFzeW5jIGV4cG9ydFRvQWJzdHJhY3RRdWVyaWVzKHF1ZXJpZXM6IFByb21RdWVyeVtdKTogUHJvbWlzZTxBYnN0cmFjdFF1ZXJ5W10+IHtcbiAgICByZXR1cm4gcXVlcmllcy5tYXAoKHF1ZXJ5KSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuZXhwb3J0VG9BYnN0cmFjdFF1ZXJ5KHF1ZXJ5KSk7XG4gIH1cblxuICAvLyBVc2UgdGhpcyBmb3IgdGFiIGNvbXBsZXRpb24gZmVhdHVyZXMsIHdvbnQgcHVibGlzaCByZXNwb25zZSB0byBvdGhlciBjb21wb25lbnRzXG4gIGFzeW5jIG1ldGFkYXRhUmVxdWVzdDxUID0gYW55Pih1cmw6IHN0cmluZywgcGFyYW1zID0ge30pIHtcbiAgICAvLyBJZiBVUkwgaW5jbHVkZXMgZW5kcG9pbnQgdGhhdCBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgbWV0aG9kLCB0cnkgdG8gdXNlIGNvbmZpZ3VyZWQgbWV0aG9kLiBUaGlzIG1pZ2h0IGZhaWwgYXMgUE9TVCBpcyBzdXBwb3J0ZWQgb25seSBpbiB2Mi4xMCsuXG4gICAgaWYgKEdFVF9BTkRfUE9TVF9NRVRBREFUQV9FTkRQT0lOVFMuc29tZSgoZW5kcG9pbnQpID0+IHVybC5pbmNsdWRlcyhlbmRwb2ludCkpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgbGFzdFZhbHVlRnJvbSh0aGlzLl9yZXF1ZXN0PFQ+KHVybCwgcGFyYW1zLCB7IG1ldGhvZDogdGhpcy5odHRwTWV0aG9kLCBoaWRlRnJvbUluc3BlY3RvcjogdHJ1ZSB9KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWYgc3RhdHVzIGNvZGUgb2YgZXJyb3IgaXMgTWV0aG9kIE5vdCBBbGxvd2VkICg0MDUpIGFuZCBIVFRQIG1ldGhvZCBpcyBQT1NULCByZXRyeSB3aXRoIEdFVFxuICAgICAgICBpZiAodGhpcy5odHRwTWV0aG9kID09PSAnUE9TVCcgJiYgZXJyLnN0YXR1cyA9PT0gNDA1KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZG4ndCB1c2UgY29uZmlndXJlZCBQT1NUIEhUVFAgbWV0aG9kIGZvciB0aGlzIHJlcXVlc3QuIFRyeWluZyB0byB1c2UgR0VUIG1ldGhvZCBpbnN0ZWFkLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBsYXN0VmFsdWVGcm9tKHRoaXMuX3JlcXVlc3Q8VD4odXJsLCBwYXJhbXMsIHsgbWV0aG9kOiAnR0VUJywgaGlkZUZyb21JbnNwZWN0b3I6IHRydWUgfSkpOyAvLyB0b1Byb21pc2UgdW50aWwgd2UgY2hhbmdlIGdldFRhZ1ZhbHVlcywgZ2V0VGFnS2V5cyB0byBPYnNlcnZhYmxlXG4gIH1cblxuICBpbnRlcnBvbGF0ZVF1ZXJ5RXhwcih2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10gPSBbXSwgdmFyaWFibGU6IGFueSkge1xuICAgIC8vIGlmIG5vIG11bHRpIG9yIGluY2x1ZGUgYWxsIGRvIG5vdCByZWdleEVzY2FwZVxuICAgIGlmICghdmFyaWFibGUubXVsdGkgJiYgIXZhcmlhYmxlLmluY2x1ZGVBbGwpIHtcbiAgICAgIHJldHVybiBwcm9tZXRoZXVzUmVndWxhckVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwcm9tZXRoZXVzU3BlY2lhbFJlZ2V4RXNjYXBlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBlc2NhcGVkVmFsdWVzID0gdmFsdWUubWFwKCh2YWwpID0+IHByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUodmFsKSk7XG5cbiAgICBpZiAoZXNjYXBlZFZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBlc2NhcGVkVmFsdWVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiAnKCcgKyBlc2NhcGVkVmFsdWVzLmpvaW4oJ3wnKSArICcpJztcbiAgfVxuXG4gIHRhcmdldENvbnRhaW5zVGVtcGxhdGUodGFyZ2V0OiBQcm9tUXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5jb250YWluc1RlbXBsYXRlKHRhcmdldC5leHByKTtcbiAgfVxuXG4gIHByZXBhcmVUYXJnZXRzID0gKG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Piwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBxdWVyaWVzOiBQcm9tUXVlcnlSZXF1ZXN0W10gPSBbXTtcbiAgICBjb25zdCBhY3RpdmVUYXJnZXRzOiBQcm9tUXVlcnlbXSA9IFtdO1xuICAgIGNvbnN0IGNsb25lZFRhcmdldHMgPSBjbG9uZURlZXAob3B0aW9ucy50YXJnZXRzKTtcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIGNsb25lZFRhcmdldHMpIHtcbiAgICAgIGlmICghdGFyZ2V0LmV4cHIgfHwgdGFyZ2V0LmhpZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5yZXF1ZXN0SWQgPSBvcHRpb25zLnBhbmVsSWQgKyB0YXJnZXQucmVmSWQ7XG4gICAgICBjb25zdCBtZXRyaWNOYW1lID0gdGhpcy5sYW5ndWFnZVByb3ZpZGVyLmhpc3RvZ3JhbU1ldHJpY3MuZmluZCgobSkgPT4gdGFyZ2V0LmV4cHIuaW5jbHVkZXMobSkpO1xuXG4gICAgICAvLyBJbiBFeHBsb3JlLCB3ZSBydW4gYm90aCAoaW5zdGFudCBhbmQgcmFuZ2UpIHF1ZXJpZXMgaWYgYm90aCBhcmUgdHJ1ZSAoc2VsZWN0ZWQpIG9yIGJvdGggYXJlIHVuZGVmaW5lZCAobGVnYWN5IEV4cGxvcmUgcXVlcmllcylcbiAgICAgIGlmIChvcHRpb25zLmFwcCA9PT0gQ29yZUFwcC5FeHBsb3JlICYmIHRhcmdldC5yYW5nZSA9PT0gdGFyZ2V0Lmluc3RhbnQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGluc3RhbnQgdGFyZ2V0XG4gICAgICAgIGNvbnN0IGluc3RhbnRUYXJnZXQ6IGFueSA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LmZvcm1hdCA9ICd0YWJsZSc7XG4gICAgICAgIGluc3RhbnRUYXJnZXQuaW5zdGFudCA9IHRydWU7XG4gICAgICAgIGluc3RhbnRUYXJnZXQucmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFudFRhcmdldC52YWx1ZVdpdGhSZWZJZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSBpbnN0YW50VGFyZ2V0Lm1heERhdGFQb2ludHM7XG4gICAgICAgIGluc3RhbnRUYXJnZXQucmVxdWVzdElkICs9ICdfaW5zdGFudCc7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJhbmdlIHRhcmdldFxuICAgICAgICBjb25zdCByYW5nZVRhcmdldDogYW55ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgIHJhbmdlVGFyZ2V0LmZvcm1hdCA9ICd0aW1lX3Nlcmllcyc7XG4gICAgICAgIHJhbmdlVGFyZ2V0Lmluc3RhbnQgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFudFRhcmdldC5yYW5nZSA9IHRydWU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGV4ZW1wbGFyIHF1ZXJ5XG4gICAgICAgIGlmICh0YXJnZXQuZXhlbXBsYXIpIHtcbiAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBleGVtcGxhciB0YXJnZXQgZm9yIGRpZmZlcmVudCBtZXRyaWMgbmFtZXNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWV0cmljTmFtZSB8fFxuICAgICAgICAgICAgKG1ldHJpY05hbWUgJiYgIWFjdGl2ZVRhcmdldHMuc29tZSgoYWN0aXZlVGFyZ2V0KSA9PiBhY3RpdmVUYXJnZXQuZXhwci5pbmNsdWRlcyhtZXRyaWNOYW1lKSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBleGVtcGxhclRhcmdldCA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQuaW5zdGFudCA9IGZhbHNlO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQucmVxdWVzdElkICs9ICdfZXhlbXBsYXInO1xuICAgICAgICAgICAgcXVlcmllcy5wdXNoKHRoaXMuY3JlYXRlUXVlcnkoZXhlbXBsYXJUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChleGVtcGxhclRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbnRUYXJnZXQuZXhlbXBsYXIgPSBmYWxzZTtcbiAgICAgICAgICByYW5nZVRhcmdldC5leGVtcGxhciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGJvdGggdGFyZ2V0cyB0byBhY3RpdmVUYXJnZXRzIGFuZCBxdWVyaWVzIGFycmF5c1xuICAgICAgICBhY3RpdmVUYXJnZXRzLnB1c2goaW5zdGFudFRhcmdldCwgcmFuZ2VUYXJnZXQpO1xuICAgICAgICBxdWVyaWVzLnB1c2goXG4gICAgICAgICAgdGhpcy5jcmVhdGVRdWVyeShpbnN0YW50VGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKSxcbiAgICAgICAgICB0aGlzLmNyZWF0ZVF1ZXJ5KHJhbmdlVGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKVxuICAgICAgICApO1xuICAgICAgICAvLyBJZiBydW5uaW5nIG9ubHkgaW5zdGFudCBxdWVyeSBpbiBFeHBsb3JlLCBmb3JtYXQgYXMgdGFibGVcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmluc3RhbnQgJiYgb3B0aW9ucy5hcHAgPT09IENvcmVBcHAuRXhwbG9yZSkge1xuICAgICAgICBjb25zdCBpbnN0YW50VGFyZ2V0OiBhbnkgPSBjbG9uZURlZXAodGFyZ2V0KTtcbiAgICAgICAgaW5zdGFudFRhcmdldC5mb3JtYXQgPSAndGFibGUnO1xuICAgICAgICBxdWVyaWVzLnB1c2godGhpcy5jcmVhdGVRdWVyeShpbnN0YW50VGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKSk7XG4gICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChpbnN0YW50VGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBxdWVyeSBmb3IgZXhlbXBsYXJzIGluIGRhc2hib2FyZCBpZiBvbmx5IGluc3RhbnQgaXMgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRhcmdldC5leGVtcGxhciAmJiAhdGFyZ2V0Lmluc3RhbnQpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWV0cmljTmFtZSB8fFxuICAgICAgICAgICAgKG1ldHJpY05hbWUgJiYgIWFjdGl2ZVRhcmdldHMuc29tZSgoYWN0aXZlVGFyZ2V0KSA9PiBhY3RpdmVUYXJnZXQuZXhwci5pbmNsdWRlcyhtZXRyaWNOYW1lKSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBleGVtcGxhclRhcmdldCA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICAgICAgZXhlbXBsYXJUYXJnZXQucmVxdWVzdElkICs9ICdfZXhlbXBsYXInO1xuICAgICAgICAgICAgcXVlcmllcy5wdXNoKHRoaXMuY3JlYXRlUXVlcnkoZXhlbXBsYXJUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChleGVtcGxhclRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5leGVtcGxhciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJpZXMucHVzaCh0aGlzLmNyZWF0ZVF1ZXJ5KHRhcmdldCwgb3B0aW9ucywgc3RhcnQsIGVuZCkpO1xuICAgICAgICBhY3RpdmVUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcmllcyxcbiAgICAgIGFjdGl2ZVRhcmdldHMsXG4gICAgfTtcbiAgfTtcblxuICBzaG91bGRSdW5FeGVtcGxhclF1ZXJ5KHRhcmdldDogUHJvbVF1ZXJ5LCByZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pOiBib29sZWFuIHtcbiAgICBpZiAodGFyZ2V0LmV4ZW1wbGFyKSB7XG4gICAgICAvLyBXZSBjaGVjayBhbGwgYWxyZWFkeSBwcm9jZXNzZWQgdGFyZ2V0cyBhbmQgb25seSBjcmVhdGUgZXhlbXBsYXIgdGFyZ2V0IGZvciBub3QgdXNlZCBtZXRyaWMgbmFtZXNcbiAgICAgIGNvbnN0IG1ldHJpY05hbWUgPSB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaGlzdG9ncmFtTWV0cmljcy5maW5kKChtKSA9PiB0YXJnZXQuZXhwci5pbmNsdWRlcyhtKSk7XG4gICAgICAvLyBSZW1vdmUgdGFyZ2V0cyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkIHlldCAoaW4gdGFyZ2V0cyBhcnJheSB0aGV5IGFyZSBhZnRlciBjdXJyZW50IHRhcmdldClcbiAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXRJZHggPSByZXF1ZXN0LnRhcmdldHMuZmluZEluZGV4KCh0KSA9PiB0LnJlZklkID09PSB0YXJnZXQucmVmSWQpO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IHJlcXVlc3QudGFyZ2V0cy5zbGljZSgwLCBjdXJyZW50VGFyZ2V0SWR4KTtcblxuICAgICAgaWYgKCFtZXRyaWNOYW1lIHx8IChtZXRyaWNOYW1lICYmICF0YXJnZXRzLnNvbWUoKHQpID0+IHQuZXhwci5pbmNsdWRlcyhtZXRyaWNOYW1lKSkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcm9jZXNzVGFyZ2V0VjIodGFyZ2V0OiBQcm9tUXVlcnksIHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pikge1xuICAgIGNvbnN0IHByb2Nlc3NlZFRhcmdldCA9IHtcbiAgICAgIC4uLnRhcmdldCxcbiAgICAgIHF1ZXJ5VHlwZTogUHJvbVF1ZXJ5VHlwZS50aW1lU2VyaWVzUXVlcnksXG4gICAgICBleGVtcGxhcjogdGhpcy5zaG91bGRSdW5FeGVtcGxhclF1ZXJ5KHRhcmdldCwgcmVxdWVzdCksXG4gICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QucGFuZWxJZCArIHRhcmdldC5yZWZJZCxcbiAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB1dGNPZmZzZXRTZWMgdG8gYmFja2VuZCB0byBjYWxjdWxhdGUgYWxpZ25lZCByYW5nZVxuICAgICAgdXRjT2Zmc2V0U2VjOiB0aGlzLnRpbWVTcnYudGltZVJhbmdlKCkudG8udXRjT2Zmc2V0KCkgKiA2MCxcbiAgICB9O1xuICAgIHJldHVybiBwcm9jZXNzZWRUYXJnZXQ7XG4gIH1cblxuICBxdWVyeShyZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4pOiBPYnNlcnZhYmxlPERhdGFRdWVyeVJlc3BvbnNlPiB7XG4gICAgaWYgKHRoaXMuYWNjZXNzID09PSAncHJveHknKSB7XG4gICAgICBjb25zdCB0YXJnZXRzID0gcmVxdWVzdC50YXJnZXRzLm1hcCgodGFyZ2V0KSA9PiB0aGlzLnByb2Nlc3NUYXJnZXRWMih0YXJnZXQsIHJlcXVlc3QpKTtcbiAgICAgIHJldHVybiBzdXBlclxuICAgICAgICAucXVlcnkoeyAuLi5yZXF1ZXN0LCB0YXJnZXRzIH0pXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIG1hcCgocmVzcG9uc2UpID0+XG4gICAgICAgICAgICB0cmFuc2Zvcm1WMihyZXNwb25zZSwgcmVxdWVzdCwgeyBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IHRoaXMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgLy8gUnVuIHF1ZXJpZXMgdHJvdWdoIGJyb3dzZXIvcHJveHlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmdldFByb21ldGhldXNUaW1lKHJlcXVlc3QucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgICAgY29uc3QgZW5kID0gdGhpcy5nZXRQcm9tZXRoZXVzVGltZShyZXF1ZXN0LnJhbmdlLnRvLCB0cnVlKTtcbiAgICAgIGNvbnN0IHsgcXVlcmllcywgYWN0aXZlVGFyZ2V0cyB9ID0gdGhpcy5wcmVwYXJlVGFyZ2V0cyhyZXF1ZXN0LCBzdGFydCwgZW5kKTtcblxuICAgICAgLy8gTm8gdmFsaWQgdGFyZ2V0cywgcmV0dXJuIHRoZSBlbXB0eSByZXN1bHQgdG8gc2F2ZSBhIHJvdW5kIHRyaXAuXG4gICAgICBpZiAoIXF1ZXJpZXMgfHwgIXF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvZih7XG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgc3RhdGU6IExvYWRpbmdTdGF0ZS5Eb25lLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3QuYXBwID09PSBDb3JlQXBwLkV4cGxvcmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwbG9yZVF1ZXJ5KHF1ZXJpZXMsIGFjdGl2ZVRhcmdldHMsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhbmVsc1F1ZXJ5KHF1ZXJpZXMsIGFjdGl2ZVRhcmdldHMsIGVuZCwgcmVxdWVzdC5yZXF1ZXN0SWQsIHJlcXVlc3Quc2NvcGVkVmFycyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBleHBsb3JlUXVlcnkocXVlcmllczogUHJvbVF1ZXJ5UmVxdWVzdFtdLCBhY3RpdmVUYXJnZXRzOiBQcm9tUXVlcnlbXSwgZW5kOiBudW1iZXIpIHtcbiAgICBsZXQgcnVubmluZ1F1ZXJpZXNDb3VudCA9IHF1ZXJpZXMubGVuZ3RoO1xuXG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHF1ZXJpZXMubWFwKChxdWVyeSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGFjdGl2ZVRhcmdldHNbaW5kZXhdO1xuXG4gICAgICBjb25zdCBmaWx0ZXJBbmRNYXBSZXNwb25zZSA9IHBpcGUoXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBjb3VudGVyIGhlcmUuIFdlIGFzc3VtZSB0aGF0IGVhY2ggcmVxdWVzdCByZXR1cm5zIG9ubHkgc2luZ2xlIHZhbHVlIGFuZCB0aGVuIGNvbXBsZXRlc1xuICAgICAgICAvLyAoc2hvdWxkIGhvbGQgdW50aWwgdGhlcmUgaXMgc29tZSBzdHJlYW1pbmcgcmVxdWVzdHMgaW52b2x2ZWQpLlxuICAgICAgICB0YXAoKCkgPT4gcnVubmluZ1F1ZXJpZXNDb3VudC0tKSxcbiAgICAgICAgZmlsdGVyKChyZXNwb25zZTogYW55KSA9PiAocmVzcG9uc2UuY2FuY2VsbGVkID8gZmFsc2UgOiB0cnVlKSksXG4gICAgICAgIG1hcCgocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0cmFuc2Zvcm0ocmVzcG9uc2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBxdWVyaWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogdGhpcy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBrZXk6IHF1ZXJ5LnJlcXVlc3RJZCxcbiAgICAgICAgICAgIHN0YXRlOiBydW5uaW5nUXVlcmllc0NvdW50ID09PSAwID8gTG9hZGluZ1N0YXRlLkRvbmUgOiBMb2FkaW5nU3RhdGUuTG9hZGluZyxcbiAgICAgICAgICB9IGFzIERhdGFRdWVyeVJlc3BvbnNlO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMucnVuUXVlcnkocXVlcnksIGVuZCwgZmlsdGVyQW5kTWFwUmVzcG9uc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1lcmdlKC4uLnN1YlF1ZXJpZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBwYW5lbHNRdWVyeShcbiAgICBxdWVyaWVzOiBQcm9tUXVlcnlSZXF1ZXN0W10sXG4gICAgYWN0aXZlVGFyZ2V0czogUHJvbVF1ZXJ5W10sXG4gICAgZW5kOiBudW1iZXIsXG4gICAgcmVxdWVzdElkOiBzdHJpbmcsXG4gICAgc2NvcGVkVmFyczogU2NvcGVkVmFyc1xuICApIHtcbiAgICBjb25zdCBvYnNlcnZhYmxlcyA9IHF1ZXJpZXMubWFwKChxdWVyeSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGFjdGl2ZVRhcmdldHNbaW5kZXhdO1xuXG4gICAgICBjb25zdCBmaWx0ZXJBbmRNYXBSZXNwb25zZSA9IHBpcGUoXG4gICAgICAgIGZpbHRlcigocmVzcG9uc2U6IGFueSkgPT4gKHJlc3BvbnNlLmNhbmNlbGxlZCA/IGZhbHNlIDogdHJ1ZSkpLFxuICAgICAgICBtYXAoKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdHJhbnNmb3JtKHJlc3BvbnNlLCB7XG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHJlc3BvbnNlTGlzdExlbmd0aDogcXVlcmllcy5sZW5ndGgsXG4gICAgICAgICAgICBzY29wZWRWYXJzLFxuICAgICAgICAgICAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zOiB0aGlzLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1blF1ZXJ5KHF1ZXJ5LCBlbmQsIGZpbHRlckFuZE1hcFJlc3BvbnNlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmb3JrSm9pbihvYnNlcnZhYmxlcykucGlwZShcbiAgICAgIG1hcCgocmVzdWx0cykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gcmVzdWx0cy5yZWR1Y2UoKHJlc3VsdCwgY3VycmVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBbLi4ucmVzdWx0LCAuLi5jdXJyZW50XTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAga2V5OiByZXF1ZXN0SWQsXG4gICAgICAgICAgc3RhdGU6IExvYWRpbmdTdGF0ZS5Eb25lLFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBydW5RdWVyeTxUPihxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCwgZW5kOiBudW1iZXIsIGZpbHRlcjogT3BlcmF0b3JGdW5jdGlvbjxhbnksIFQ+KTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgaWYgKHF1ZXJ5Lmluc3RhbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1JbnN0YW50UXVlcnkocXVlcnksIGVuZCkucGlwZShmaWx0ZXIpO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5leGVtcGxhcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhlbXBsYXJzKHF1ZXJ5KS5waXBlKFxuICAgICAgICBjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gb2Yoe1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLkRvbmUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBmaWx0ZXJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGVyZm9ybVRpbWVTZXJpZXNRdWVyeShxdWVyeSwgcXVlcnkuc3RhcnQsIHF1ZXJ5LmVuZCkucGlwZShmaWx0ZXIpO1xuICB9XG5cbiAgY3JlYXRlUXVlcnkodGFyZ2V0OiBQcm9tUXVlcnksIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Piwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICBjb25zdCBxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCA9IHtcbiAgICAgIGhpbnRpbmc6IHRhcmdldC5oaW50aW5nLFxuICAgICAgaW5zdGFudDogdGFyZ2V0Lmluc3RhbnQsXG4gICAgICBleGVtcGxhcjogdGFyZ2V0LmV4ZW1wbGFyLFxuICAgICAgc3RlcDogMCxcbiAgICAgIGV4cHI6ICcnLFxuICAgICAgcmVxdWVzdElkOiB0YXJnZXQucmVxdWVzdElkLFxuICAgICAgcmVmSWQ6IHRhcmdldC5yZWZJZCxcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwLFxuICAgIH07XG4gICAgY29uc3QgcmFuZ2UgPSBNYXRoLmNlaWwoZW5kIC0gc3RhcnQpO1xuXG4gICAgLy8gb3B0aW9ucy5pbnRlcnZhbCBpcyB0aGUgZHluYW1pY2FsbHkgY2FsY3VsYXRlZCBpbnRlcnZhbFxuICAgIGxldCBpbnRlcnZhbDogbnVtYmVyID0gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKG9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgIC8vIE1pbmltdW0gaW50ZXJ2YWwgKFwiTWluIHN0ZXBcIiksIGlmIHNwZWNpZmllZCBmb3IgdGhlIHF1ZXJ5LCBvciBzYW1lIGFzIGludGVydmFsIG90aGVyd2lzZS5cbiAgICBjb25zdCBtaW5JbnRlcnZhbCA9IHJhbmdlVXRpbC5pbnRlcnZhbFRvU2Vjb25kcyhcbiAgICAgIHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQuaW50ZXJ2YWwgfHwgb3B0aW9ucy5pbnRlcnZhbCwgb3B0aW9ucy5zY29wZWRWYXJzKVxuICAgICk7XG4gICAgLy8gU2NyYXBlIGludGVydmFsIGFzIHNwZWNpZmllZCBmb3IgdGhlIHF1ZXJ5IChcIk1pbiBzdGVwXCIpIG9yIG90aGVyd2lzZSB0YWtlbiBmcm9tIHRoZSBkYXRhc291cmNlLlxuICAgIC8vIE1pbiBzdGVwIGZpZWxkIGNhbiBoYXZlIHRlbXBsYXRlIHZhcmlhYmxlcyBpbiBpdCwgbWFrZSBzdXJlIHRvIHJlcGxhY2UgaXQuXG4gICAgY29uc3Qgc2NyYXBlSW50ZXJ2YWwgPSB0YXJnZXQuaW50ZXJ2YWxcbiAgICAgID8gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQuaW50ZXJ2YWwsIG9wdGlvbnMuc2NvcGVkVmFycykpXG4gICAgICA6IHJhbmdlVXRpbC5pbnRlcnZhbFRvU2Vjb25kcyh0aGlzLmludGVydmFsKTtcblxuICAgIGNvbnN0IGludGVydmFsRmFjdG9yID0gdGFyZ2V0LmludGVydmFsRmFjdG9yIHx8IDE7XG4gICAgLy8gQWRqdXN0IHRoZSBpbnRlcnZhbCB0byB0YWtlIGludG8gYWNjb3VudCBhbnkgc3BlY2lmaWVkIG1pbmltdW0gYW5kIGludGVydmFsIGZhY3RvciBwbHVzIFByb21ldGhldXMgbGltaXRzXG4gICAgY29uc3QgYWRqdXN0ZWRJbnRlcnZhbCA9IHRoaXMuYWRqdXN0SW50ZXJ2YWwoaW50ZXJ2YWwsIG1pbkludGVydmFsLCByYW5nZSwgaW50ZXJ2YWxGYWN0b3IpO1xuICAgIGxldCBzY29wZWRWYXJzID0ge1xuICAgICAgLi4ub3B0aW9ucy5zY29wZWRWYXJzLFxuICAgICAgLi4udGhpcy5nZXRSYW5nZVNjb3BlZFZhcnMob3B0aW9ucy5yYW5nZSksXG4gICAgICAuLi50aGlzLmdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKGFkanVzdGVkSW50ZXJ2YWwsIHNjcmFwZUludGVydmFsKSxcbiAgICB9O1xuICAgIC8vIElmIHRoZSBpbnRlcnZhbCB3YXMgYWRqdXN0ZWQsIG1ha2UgYSBzaGFsbG93IGNvcHkgb2Ygc2NvcGVkVmFycyB3aXRoIHVwZGF0ZWQgaW50ZXJ2YWwgdmFyc1xuICAgIGlmIChpbnRlcnZhbCAhPT0gYWRqdXN0ZWRJbnRlcnZhbCkge1xuICAgICAgaW50ZXJ2YWwgPSBhZGp1c3RlZEludGVydmFsO1xuICAgICAgc2NvcGVkVmFycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuc2NvcGVkVmFycywge1xuICAgICAgICBfX2ludGVydmFsOiB7IHRleHQ6IGludGVydmFsICsgJ3MnLCB2YWx1ZTogaW50ZXJ2YWwgKyAncycgfSxcbiAgICAgICAgX19pbnRlcnZhbF9tczogeyB0ZXh0OiBpbnRlcnZhbCAqIDEwMDAsIHZhbHVlOiBpbnRlcnZhbCAqIDEwMDAgfSxcbiAgICAgICAgLi4udGhpcy5nZXRSYXRlSW50ZXJ2YWxTY29wZWRWYXJpYWJsZShpbnRlcnZhbCwgc2NyYXBlSW50ZXJ2YWwpLFxuICAgICAgICAuLi50aGlzLmdldFJhbmdlU2NvcGVkVmFycyhvcHRpb25zLnJhbmdlKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBxdWVyeS5zdGVwID0gaW50ZXJ2YWw7XG5cbiAgICBsZXQgZXhwciA9IHRhcmdldC5leHByO1xuXG4gICAgLy8gQXBwbHkgYWRob2MgZmlsdGVyc1xuICAgIGV4cHIgPSB0aGlzLmVuaGFuY2VFeHByV2l0aEFkSG9jRmlsdGVycyhleHByKTtcblxuICAgIC8vIE9ubHkgcmVwbGFjZSB2YXJzIGluIGV4cHJlc3Npb24gYWZ0ZXIgaGF2aW5nIChwb3NzaWJseSkgdXBkYXRlZCBpbnRlcnZhbCB2YXJzXG4gICAgcXVlcnkuZXhwciA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShleHByLCBzY29wZWRWYXJzLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKTtcblxuICAgIC8vIEFsaWduIHF1ZXJ5IGludGVydmFsIHdpdGggc3RlcCB0byBhbGxvdyBxdWVyeSBjYWNoaW5nIGFuZCB0byBlbnN1cmVcbiAgICAvLyB0aGF0IGFib3V0LXNhbWUtdGltZSBxdWVyeSByZXN1bHRzIGxvb2sgdGhlIHNhbWUuXG4gICAgY29uc3QgYWRqdXN0ZWQgPSBhbGlnblJhbmdlKHN0YXJ0LCBlbmQsIHF1ZXJ5LnN0ZXAsIHRoaXMudGltZVNydi50aW1lUmFuZ2UoKS50by51dGNPZmZzZXQoKSAqIDYwKTtcbiAgICBxdWVyeS5zdGFydCA9IGFkanVzdGVkLnN0YXJ0O1xuICAgIHF1ZXJ5LmVuZCA9IGFkanVzdGVkLmVuZDtcbiAgICB0aGlzLl9hZGRUcmFjaW5nSGVhZGVycyhxdWVyeSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICBnZXRSYXRlSW50ZXJ2YWxTY29wZWRWYXJpYWJsZShpbnRlcnZhbDogbnVtYmVyLCBzY3JhcGVJbnRlcnZhbDogbnVtYmVyKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IHNjcmFwZSBpbnRlcnZhbCBvZiAxNXMgaWYgc2NyYXBlSW50ZXJ2YWwgaXMgMCBmb3Igc29tZSByZWFzb24uXG4gICAgaWYgKHNjcmFwZUludGVydmFsID09PSAwKSB7XG4gICAgICBzY3JhcGVJbnRlcnZhbCA9IDE1O1xuICAgIH1cbiAgICBjb25zdCByYXRlSW50ZXJ2YWwgPSBNYXRoLm1heChpbnRlcnZhbCArIHNjcmFwZUludGVydmFsLCA0ICogc2NyYXBlSW50ZXJ2YWwpO1xuICAgIHJldHVybiB7IF9fcmF0ZV9pbnRlcnZhbDogeyB0ZXh0OiByYXRlSW50ZXJ2YWwgKyAncycsIHZhbHVlOiByYXRlSW50ZXJ2YWwgKyAncycgfSB9O1xuICB9XG5cbiAgYWRqdXN0SW50ZXJ2YWwoaW50ZXJ2YWw6IG51bWJlciwgbWluSW50ZXJ2YWw6IG51bWJlciwgcmFuZ2U6IG51bWJlciwgaW50ZXJ2YWxGYWN0b3I6IG51bWJlcikge1xuICAgIC8vIFByb21ldGhldXMgd2lsbCBkcm9wIHF1ZXJpZXMgdGhhdCBtaWdodCByZXR1cm4gbW9yZSB0aGFuIDExMDAwIGRhdGEgcG9pbnRzLlxuICAgIC8vIENhbGN1bGF0ZSBhIHNhZmUgaW50ZXJ2YWwgYXMgYW4gYWRkaXRpb25hbCBtaW5pbXVtIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgIC8vIEZyYWN0aW9uYWwgc2FmZUludGVydmFscyBhcmUgYWxsb3dlZCwgaG93ZXZlciBzZXJ2ZSBsaXR0bGUgcHVycG9zZSBpZiB0aGUgaW50ZXJ2YWwgaXMgZ3JlYXRlciB0aGFuIDFcbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBjYXNlIHRha2UgdGhlIGNlaWwgb2YgdGhlIHZhbHVlLlxuICAgIGxldCBzYWZlSW50ZXJ2YWwgPSByYW5nZSAvIDExMDAwO1xuICAgIGlmIChzYWZlSW50ZXJ2YWwgPiAxKSB7XG4gICAgICBzYWZlSW50ZXJ2YWwgPSBNYXRoLmNlaWwoc2FmZUludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KGludGVydmFsICogaW50ZXJ2YWxGYWN0b3IsIG1pbkludGVydmFsLCBzYWZlSW50ZXJ2YWwpO1xuICB9XG5cbiAgcGVyZm9ybVRpbWVTZXJpZXNRdWVyeShxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHRocm93IHsgbWVzc2FnZTogJ0ludmFsaWQgdGltZSByYW5nZScgfTtcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSAnL2FwaS92MS9xdWVyeV9yYW5nZSc7XG4gICAgY29uc3QgZGF0YTogYW55ID0ge1xuICAgICAgcXVlcnk6IHF1ZXJ5LmV4cHIsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIHN0ZXA6IHF1ZXJ5LnN0ZXAsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VGltZW91dCkge1xuICAgICAgZGF0YVsndGltZW91dCddID0gdGhpcy5xdWVyeVRpbWVvdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8UHJvbU1hdHJpeERhdGE+Pih1cmwsIGRhdGEsIHtcbiAgICAgIHJlcXVlc3RJZDogcXVlcnkucmVxdWVzdElkLFxuICAgICAgaGVhZGVyczogcXVlcnkuaGVhZGVycyxcbiAgICB9KS5waXBlKFxuICAgICAgY2F0Y2hFcnJvcigoZXJyOiBGZXRjaEVycm9yPFByb21EYXRhRXJyb3JSZXNwb25zZTxQcm9tTWF0cml4RGF0YT4+KSA9PiB7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih0aGlzLmhhbmRsZUVycm9ycyhlcnIsIHF1ZXJ5KSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwZXJmb3JtSW5zdGFudFF1ZXJ5KFxuICAgIHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0LFxuICAgIHRpbWU6IG51bWJlclxuICApOiBPYnNlcnZhYmxlPEZldGNoUmVzcG9uc2U8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8UHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YT4+IHwgRmV0Y2hFcnJvcj4ge1xuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL3F1ZXJ5JztcbiAgICBjb25zdCBkYXRhOiBhbnkgPSB7XG4gICAgICBxdWVyeTogcXVlcnkuZXhwcixcbiAgICAgIHRpbWUsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VGltZW91dCkge1xuICAgICAgZGF0YVsndGltZW91dCddID0gdGhpcy5xdWVyeVRpbWVvdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8UHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YT4+KHVybCwgZGF0YSwge1xuICAgICAgcmVxdWVzdElkOiBxdWVyeS5yZXF1ZXN0SWQsXG4gICAgICBoZWFkZXJzOiBxdWVyeS5oZWFkZXJzLFxuICAgIH0pLnBpcGUoXG4gICAgICBjYXRjaEVycm9yKChlcnI6IEZldGNoRXJyb3I8UHJvbURhdGFFcnJvclJlc3BvbnNlPFByb21WZWN0b3JEYXRhIHwgUHJvbVNjYWxhckRhdGE+PikgPT4ge1xuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybiBvZihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IodGhpcy5oYW5kbGVFcnJvcnMoZXJyLCBxdWVyeSkpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgaGFuZGxlRXJyb3JzID0gKGVycjogYW55LCB0YXJnZXQ6IFByb21RdWVyeSkgPT4ge1xuICAgIGNvbnN0IGVycm9yOiBEYXRhUXVlcnlFcnJvciA9IHtcbiAgICAgIG1lc3NhZ2U6IChlcnIgJiYgZXJyLnN0YXR1c1RleHQpIHx8ICdVbmtub3duIGVycm9yIGR1cmluZyBxdWVyeSB0cmFuc2FjdGlvbi4gUGxlYXNlIGNoZWNrIEpTIGNvbnNvbGUgbG9ncy4nLFxuICAgICAgcmVmSWQ6IHRhcmdldC5yZWZJZCxcbiAgICB9O1xuXG4gICAgaWYgKGVyci5kYXRhKSB7XG4gICAgICBpZiAodHlwZW9mIGVyci5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gZXJyLmRhdGE7XG4gICAgICB9IGVsc2UgaWYgKGVyci5kYXRhLmVycm9yKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSBzYWZlU3RyaW5naWZ5VmFsdWUoZXJyLmRhdGEuZXJyb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvci5tZXNzYWdlID0gZXJyO1xuICAgIH1cblxuICAgIGVycm9yLnN0YXR1cyA9IGVyci5zdGF0dXM7XG4gICAgZXJyb3Iuc3RhdHVzVGV4dCA9IGVyci5zdGF0dXNUZXh0O1xuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9O1xuXG4gIG1ldHJpY0ZpbmRRdWVyeShxdWVyeTogc3RyaW5nKSB7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVkVmFycyA9IHtcbiAgICAgIF9faW50ZXJ2YWw6IHsgdGV4dDogdGhpcy5pbnRlcnZhbCwgdmFsdWU6IHRoaXMuaW50ZXJ2YWwgfSxcbiAgICAgIF9faW50ZXJ2YWxfbXM6IHsgdGV4dDogcmFuZ2VVdGlsLmludGVydmFsVG9Ncyh0aGlzLmludGVydmFsKSwgdmFsdWU6IHJhbmdlVXRpbC5pbnRlcnZhbFRvTXModGhpcy5pbnRlcnZhbCkgfSxcbiAgICAgIC4uLnRoaXMuZ2V0UmFuZ2VTY29wZWRWYXJzKHRoaXMudGltZVNydi50aW1lUmFuZ2UoKSksXG4gICAgfTtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UocXVlcnksIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuICAgIGNvbnN0IG1ldHJpY0ZpbmRRdWVyeSA9IG5ldyBQcm9tZXRoZXVzTWV0cmljRmluZFF1ZXJ5KHRoaXMsIGludGVycG9sYXRlZCk7XG4gICAgcmV0dXJuIG1ldHJpY0ZpbmRRdWVyeS5wcm9jZXNzKCk7XG4gIH1cblxuICBnZXRSYW5nZVNjb3BlZFZhcnMocmFuZ2U6IFRpbWVSYW5nZSA9IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKSkge1xuICAgIGNvbnN0IG1zUmFuZ2UgPSByYW5nZS50by5kaWZmKHJhbmdlLmZyb20pO1xuICAgIGNvbnN0IHNSYW5nZSA9IE1hdGgucm91bmQobXNSYW5nZSAvIDEwMDApO1xuICAgIHJldHVybiB7XG4gICAgICBfX3JhbmdlX21zOiB7IHRleHQ6IG1zUmFuZ2UsIHZhbHVlOiBtc1JhbmdlIH0sXG4gICAgICBfX3JhbmdlX3M6IHsgdGV4dDogc1JhbmdlLCB2YWx1ZTogc1JhbmdlIH0sXG4gICAgICBfX3JhbmdlOiB7IHRleHQ6IHNSYW5nZSArICdzJywgdmFsdWU6IHNSYW5nZSArICdzJyB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBhbm5vdGF0aW9uUXVlcnkob3B0aW9uczogYW55KTogUHJvbWlzZTxBbm5vdGF0aW9uRXZlbnRbXT4ge1xuICAgIGNvbnN0IGFubm90YXRpb24gPSBvcHRpb25zLmFubm90YXRpb247XG4gICAgY29uc3QgeyBleHByID0gJycgfSA9IGFubm90YXRpb247XG5cbiAgICBpZiAoIWV4cHIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ZXAgPSBvcHRpb25zLmFubm90YXRpb24uc3RlcCB8fCBBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVDtcbiAgICBjb25zdCBxdWVyeU1vZGVsID0ge1xuICAgICAgZXhwcixcbiAgICAgIHJhbmdlOiB0cnVlLFxuICAgICAgaW5zdGFudDogZmFsc2UsXG4gICAgICBleGVtcGxhcjogZmFsc2UsXG4gICAgICBpbnRlcnZhbDogc3RlcCxcbiAgICAgIHF1ZXJ5VHlwZTogUHJvbVF1ZXJ5VHlwZS50aW1lU2VyaWVzUXVlcnksXG4gICAgICByZWZJZDogJ1gnLFxuICAgICAgZGF0YXNvdXJjZTogdGhpcy5nZXRSZWYoKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGF3YWl0IGxhc3RWYWx1ZUZyb20oXG4gICAgICBnZXRCYWNrZW5kU3J2KClcbiAgICAgICAgLmZldGNoPEJhY2tlbmREYXRhU291cmNlUmVzcG9uc2U+KHtcbiAgICAgICAgICB1cmw6ICcvYXBpL2RzL3F1ZXJ5JyxcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmcm9tOiAodGhpcy5nZXRQcm9tZXRoZXVzVGltZShvcHRpb25zLnJhbmdlLmZyb20sIGZhbHNlKSAqIDEwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0bzogKHRoaXMuZ2V0UHJvbWV0aGV1c1RpbWUob3B0aW9ucy5yYW5nZS50bywgdHJ1ZSkgKiAxMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgcXVlcmllczogW3RoaXMuYXBwbHlUZW1wbGF0ZVZhcmlhYmxlcyhxdWVyeU1vZGVsLCB7fSldLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWVzdElkOiBgcHJvbS1xdWVyeS0ke2Fubm90YXRpb24ubmFtZX1gLFxuICAgICAgICB9KVxuICAgICAgICAucGlwZShcbiAgICAgICAgICBtYXAoKHJzcDogRmV0Y2hSZXNwb25zZTxCYWNrZW5kRGF0YVNvdXJjZVJlc3BvbnNlPikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0Fubm90YXRpb25SZXNwb25zZShvcHRpb25zLCByc3AuZGF0YSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICk7XG4gIH1cblxuICBwcm9jZXNzQW5ub3RhdGlvblJlc3BvbnNlID0gKG9wdGlvbnM6IGFueSwgZGF0YTogQmFja2VuZERhdGFTb3VyY2VSZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IGZyYW1lczogRGF0YUZyYW1lW10gPSB0b0RhdGFRdWVyeVJlc3BvbnNlKHsgZGF0YTogZGF0YSB9KS5kYXRhO1xuICAgIGlmICghZnJhbWVzIHx8ICFmcmFtZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IG9wdGlvbnMuYW5ub3RhdGlvbjtcbiAgICBjb25zdCB7IHRhZ0tleXMgPSAnJywgdGl0bGVGb3JtYXQgPSAnJywgdGV4dEZvcm1hdCA9ICcnIH0gPSBhbm5vdGF0aW9uO1xuXG4gICAgY29uc3Qgc3RlcCA9IHJhbmdlVXRpbC5pbnRlcnZhbFRvU2Vjb25kcyhhbm5vdGF0aW9uLnN0ZXAgfHwgQU5OT1RBVElPTl9RVUVSWV9TVEVQX0RFRkFVTFQpICogMTAwMDtcbiAgICBjb25zdCB0YWdLZXlzQXJyYXkgPSB0YWdLZXlzLnNwbGl0KCcsJyk7XG5cbiAgICBjb25zdCBldmVudExpc3Q6IEFubm90YXRpb25FdmVudFtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGZyYW1lcykge1xuICAgICAgY29uc3QgdGltZUZpZWxkID0gZnJhbWUuZmllbGRzWzBdO1xuICAgICAgY29uc3QgdmFsdWVGaWVsZCA9IGZyYW1lLmZpZWxkc1sxXTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHZhbHVlRmllbGQ/LmxhYmVscyB8fCB7fTtcblxuICAgICAgY29uc3QgdGFncyA9IE9iamVjdC5rZXlzKGxhYmVscylcbiAgICAgICAgLmZpbHRlcigobGFiZWwpID0+IHRhZ0tleXNBcnJheS5pbmNsdWRlcyhsYWJlbCkpXG4gICAgICAgIC5tYXAoKGxhYmVsKSA9PiBsYWJlbHNbbGFiZWxdKTtcblxuICAgICAgY29uc3QgdGltZVZhbHVlVHVwbGU6IEFycmF5PFtudW1iZXIsIG51bWJlcl0+ID0gW107XG5cbiAgICAgIGxldCBpZHggPSAwO1xuICAgICAgdmFsdWVGaWVsZC52YWx1ZXMudG9BcnJheSgpLmZvckVhY2goKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IHRpbWVTdGFtcFZhbHVlOiBudW1iZXI7XG4gICAgICAgIGxldCB2YWx1ZVZhbHVlOiBudW1iZXI7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aW1lRmllbGQudmFsdWVzLmdldChpZHgpO1xuXG4gICAgICAgIC8vIElmIHdlIHdhbnQgdG8gdXNlIHZhbHVlIGFzIGEgdGltZSwgd2UgdXNlIHZhbHVlIGFzIHRpbWVTdGFtcFZhbHVlIGFuZCB2YWx1ZVZhbHVlIHdpbGwgYmUgMVxuICAgICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9uLnVzZVZhbHVlRm9yVGltZSkge1xuICAgICAgICAgIHRpbWVTdGFtcFZhbHVlID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgICAgdmFsdWVWYWx1ZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZVN0YW1wVmFsdWUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQodGltZSkpO1xuICAgICAgICAgIHZhbHVlVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkeCsrO1xuICAgICAgICB0aW1lVmFsdWVUdXBsZS5wdXNoKFt0aW1lU3RhbXBWYWx1ZSwgdmFsdWVWYWx1ZV0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFjdGl2ZVZhbHVlcyA9IHRpbWVWYWx1ZVR1cGxlLmZpbHRlcigodmFsdWUpID0+IHZhbHVlWzFdID49IDEpO1xuICAgICAgY29uc3QgYWN0aXZlVmFsdWVzVGltZXN0YW1wcyA9IGFjdGl2ZVZhbHVlcy5tYXAoKHZhbHVlKSA9PiB2YWx1ZVswXSk7XG5cbiAgICAgIC8vIEluc3RlYWQgb2YgY3JlYXRpbmcgc2luZ3VsYXIgYW5ub3RhdGlvbiBmb3IgZWFjaCBhY3RpdmUgZXZlbnQgd2UgZ3JvdXAgZXZlbnRzIGludG8gcmVnaW9uIGlmIHRoZXkgYXJlIGxlc3NcbiAgICAgIC8vIG9yIGVxdWFsIHRvIGBzdGVwYCBhcGFydC5cbiAgICAgIGxldCBsYXRlc3RFdmVudDogQW5ub3RhdGlvbkV2ZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgIGZvciAoY29uc3QgdGltZXN0YW1wIG9mIGFjdGl2ZVZhbHVlc1RpbWVzdGFtcHMpIHtcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGV2ZW50IGBvcGVuYCBhbmQgd2UgaGF2ZSBuZXcgZXZlbnQgdGhhdCBpcyBpbnNpZGUgdGhlIGBzdGVwYCBzbyB3ZSBqdXN0IHVwZGF0ZSB0aGUgZW5kLlxuICAgICAgICBpZiAobGF0ZXN0RXZlbnQgJiYgKGxhdGVzdEV2ZW50LnRpbWVFbmQgPz8gMCkgKyBzdGVwID49IHRpbWVzdGFtcCkge1xuICAgICAgICAgIGxhdGVzdEV2ZW50LnRpbWVFbmQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdmVudCBleGlzdHMgYnV0IG5ldyBvbmUgaXMgb3V0c2lkZSBvZiB0aGUgYHN0ZXBgIHNvIHdlIGFkZCBpdCB0byBldmVudExpc3QuXG4gICAgICAgIGlmIChsYXRlc3RFdmVudCkge1xuICAgICAgICAgIGV2ZW50TGlzdC5wdXNoKGxhdGVzdEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHN0YXJ0IGEgbmV3IHJlZ2lvbi5cbiAgICAgICAgbGF0ZXN0RXZlbnQgPSB7XG4gICAgICAgICAgdGltZTogdGltZXN0YW1wLFxuICAgICAgICAgIHRpbWVFbmQ6IHRpbWVzdGFtcCxcbiAgICAgICAgICBhbm5vdGF0aW9uLFxuICAgICAgICAgIHRpdGxlOiByZW5kZXJMZWdlbmRGb3JtYXQodGl0bGVGb3JtYXQsIGxhYmVscyksXG4gICAgICAgICAgdGFncyxcbiAgICAgICAgICB0ZXh0OiByZW5kZXJMZWdlbmRGb3JtYXQodGV4dEZvcm1hdCwgbGFiZWxzKSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhdGVzdEV2ZW50KSB7XG4gICAgICAgIC8vIEZpbmlzaCB1cCBsYXN0IHBvaW50IGlmIHdlIGhhdmUgb25lXG4gICAgICAgIGxhdGVzdEV2ZW50LnRpbWVFbmQgPSBhY3RpdmVWYWx1ZXNUaW1lc3RhbXBzW2FjdGl2ZVZhbHVlc1RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGV2ZW50TGlzdC5wdXNoKGxhdGVzdEV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRMaXN0O1xuICB9O1xuXG4gIGdldEV4ZW1wbGFycyhxdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCkge1xuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL3F1ZXJ5X2V4ZW1wbGFycyc7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8UHJvbUV4ZW1wbGFyRGF0YT4+KFxuICAgICAgdXJsLFxuICAgICAgeyBxdWVyeTogcXVlcnkuZXhwciwgc3RhcnQ6IHF1ZXJ5LnN0YXJ0LnRvU3RyaW5nKCksIGVuZDogcXVlcnkuZW5kLnRvU3RyaW5nKCkgfSxcbiAgICAgIHsgcmVxdWVzdElkOiBxdWVyeS5yZXF1ZXN0SWQsIGhlYWRlcnM6IHF1ZXJ5LmhlYWRlcnMgfVxuICAgICk7XG4gIH1cblxuICBhc3luYyBnZXRTdWJ0aXRsZSgpOiBQcm9taXNlPEpTWC5FbGVtZW50IHwgbnVsbD4ge1xuICAgIGNvbnN0IGJ1aWxkSW5mbyA9IGF3YWl0IHRoaXMuZ2V0QnVpbGRJbmZvKCk7XG4gICAgcmV0dXJuIGJ1aWxkSW5mbyA/IHRoaXMuZ2V0QnVpbGRJbmZvTWVzc2FnZShidWlsZEluZm8pIDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldFRhZ0tleXMob3B0aW9ucz86IGFueSkge1xuICAgIGlmIChvcHRpb25zPy5zZXJpZXMpIHtcbiAgICAgIC8vIEdldCB0YWdzIGZvciB0aGUgcHJvdmlkZWQgc2VyaWVzIG9ubHlcbiAgICAgIGNvbnN0IHNlcmllc0xhYmVsczogQXJyYXk8UmVjb3JkPHN0cmluZywgc3RyaW5nW10+PiA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBvcHRpb25zLnNlcmllcy5tYXAoKHNlcmllczogc3RyaW5nKSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoc2VyaWVzKSlcbiAgICAgICk7XG4gICAgICBjb25zdCB1bmlxdWVMYWJlbHMgPSBbLi4ubmV3IFNldCguLi5zZXJpZXNMYWJlbHMubWFwKCh2YWx1ZSkgPT4gT2JqZWN0LmtleXModmFsdWUpKSldO1xuICAgICAgcmV0dXJuIHVuaXF1ZUxhYmVscy5tYXAoKHZhbHVlOiBhbnkpID0+ICh7IHRleHQ6IHZhbHVlIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IGFsbCB0YWdzXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdCgnL2FwaS92MS9sYWJlbHMnKTtcbiAgICAgIHJldHVybiByZXN1bHQ/LmRhdGE/LmRhdGE/Lm1hcCgodmFsdWU6IGFueSkgPT4gKHsgdGV4dDogdmFsdWUgfSkpID8/IFtdO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFRhZ1ZhbHVlcyhvcHRpb25zOiB7IGtleT86IHN0cmluZyB9ID0ge30pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdChgL2FwaS92MS9sYWJlbC8ke29wdGlvbnMua2V5fS92YWx1ZXNgKTtcbiAgICByZXR1cm4gcmVzdWx0Py5kYXRhPy5kYXRhPy5tYXAoKHZhbHVlOiBhbnkpID0+ICh7IHRleHQ6IHZhbHVlIH0pKSA/PyBbXTtcbiAgfVxuXG4gIGFzeW5jIGdldEJ1aWxkSW5mbygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnVpbGRJbmZvID0gYXdhaXQgZmV0Y2hEYXRhU291cmNlQnVpbGRJbmZvKHRoaXMpO1xuICAgICAgcmV0dXJuIGJ1aWxkSW5mbztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBicmVhayB0aGUgcmVzdCBvZiBmdW5jdGlvbmFsaXR5IGlmIGJ1aWxkIGluZm8gZG9lcyBub3Qgd29yayBjb3JyZWN0bHlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0QnVpbGRJbmZvTWVzc2FnZShidWlsZEluZm86IFByb21CdWlsZEluZm8pIHtcbiAgICBjb25zdCBlbmFibGVkID0gPEJhZGdlIGNvbG9yPVwiZ3JlZW5cIiBpY29uPVwiY2hlY2tcIiB0ZXh0PVwiUnVsZXIgQVBJIGVuYWJsZWRcIiAvPjtcbiAgICBjb25zdCBkaXNhYmxlZCA9IDxCYWRnZSBjb2xvcj1cIm9yYW5nZVwiIGljb249XCJleGNsYW1hdGlvbi10cmlhbmdsZVwiIHRleHQ9XCJSdWxlciBBUEkgbm90IGVuYWJsZWRcIiAvPjtcbiAgICBjb25zdCB1bnN1cHBvcnRlZCA9IChcbiAgICAgIDxUb29sdGlwXG4gICAgICAgIHBsYWNlbWVudD1cInRvcFwiXG4gICAgICAgIGNvbnRlbnQ9XCJQcm9tZXRoZXVzIGRvZXMgbm90IGFsbG93IGVkaXRpbmcgcnVsZXMsIGNvbm5lY3QgdG8gZWl0aGVyIGEgTWltaXIgb3IgQ29ydGV4IGRhdGFzb3VyY2UgdG8gbWFuYWdlIGFsZXJ0cyB2aWEgR3JhZmFuYS5cIlxuICAgICAgPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxCYWRnZSBjb2xvcj1cInJlZFwiIGljb249XCJleGNsYW1hdGlvbi10cmlhbmdsZVwiIHRleHQ9XCJSdWxlciBBUEkgbm90IHN1cHBvcnRlZFwiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9Ub29sdGlwPlxuICAgICk7XG5cbiAgICBjb25zdCBMT0dPUyA9IHtcbiAgICAgIFtQcm9tQXBwbGljYXRpb24uQ29ydGV4XTogJy9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2ltZy9jb3J0ZXhfbG9nby5zdmcnLFxuICAgICAgW1Byb21BcHBsaWNhdGlvbi5NaW1pcl06ICcvcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9pbWcvbWltaXJfbG9nby5zdmcnLFxuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXTogJy9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2ltZy9wcm9tZXRoZXVzX2xvZ28uc3ZnJyxcbiAgICB9O1xuXG4gICAgY29uc3QgQ09MT1JTOiBSZWNvcmQ8UHJvbUFwcGxpY2F0aW9uLCBCYWRnZUNvbG9yPiA9IHtcbiAgICAgIFtQcm9tQXBwbGljYXRpb24uQ29ydGV4XTogJ2JsdWUnLFxuICAgICAgW1Byb21BcHBsaWNhdGlvbi5NaW1pcl06ICdvcmFuZ2UnLFxuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXTogJ3JlZCcsXG4gICAgfTtcblxuICAgIC8vIHRoaXMgd2lsbCBpbmZvcm0gdGhlIHVzZXIgYWJvdXQgd2hhdCBcInN1YnR5cGVcIiB0aGUgZGF0YXNvdXJjZSBpczsgTWltaXIsIENvcnRleCBvciB2YW5pbGxhIFByb21ldGhldXNcbiAgICBjb25zdCBhcHBsaWNhdGlvblN1YlR5cGUgPSAoXG4gICAgICA8QmFkZ2VcbiAgICAgICAgdGV4dD17XG4gICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAxNCwgaGVpZ2h0OiAxNCwgdmVydGljYWxBbGlnbjogJ3RleHQtYm90dG9tJyB9fVxuICAgICAgICAgICAgICBzcmM9e0xPR09TW2J1aWxkSW5mby5hcHBsaWNhdGlvbiA/PyBQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1c119XG4gICAgICAgICAgICAvPnsnICd9XG4gICAgICAgICAgICB7YnVpbGRJbmZvLmFwcGxpY2F0aW9ufVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgfVxuICAgICAgICBjb2xvcj17Q09MT1JTW2J1aWxkSW5mby5hcHBsaWNhdGlvbiA/PyBQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1c119XG4gICAgICAvPlxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiAnbWF4LWNvbnRlbnQgbWF4LWNvbnRlbnQnLFxuICAgICAgICAgIHJvd0dhcDogJzAuNXJlbScsXG4gICAgICAgICAgY29sdW1uR2FwOiAnMnJlbScsXG4gICAgICAgICAgbWFyZ2luVG9wOiAnMXJlbScsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxkaXY+VHlwZTwvZGl2PlxuICAgICAgICA8ZGl2PnthcHBsaWNhdGlvblN1YlR5cGV9PC9kaXY+XG4gICAgICAgIDw+XG4gICAgICAgICAgPGRpdj5SdWxlciBBUEk8L2Rpdj5cbiAgICAgICAgICB7LyogUHJvbWV0aGV1cyBkb2VzIG5vdCBoYXZlIGEgUnVsZXIgQVBJIOKAkyBzbyBzaG93IHRoYXQgaXQgaXMgbm90IHN1cHBvcnRlZCAqL31cbiAgICAgICAgICB7YnVpbGRJbmZvLmFwcGxpY2F0aW9uID09PSBQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1cyAmJiA8ZGl2Pnt1bnN1cHBvcnRlZH08L2Rpdj59XG4gICAgICAgICAge2J1aWxkSW5mby5hcHBsaWNhdGlvbiAhPT0gUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXMgJiYgKFxuICAgICAgICAgICAgPGRpdj57YnVpbGRJbmZvLmZlYXR1cmVzLnJ1bGVyQXBpRW5hYmxlZCA/IGVuYWJsZWQgOiBkaXNhYmxlZH08L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8Lz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBhc3luYyB0ZXN0RGF0YXNvdXJjZSgpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCByZXF1ZXN0OiBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT4gPSB7XG4gICAgICB0YXJnZXRzOiBbeyByZWZJZDogJ3Rlc3QnLCBleHByOiAnMSsxJywgaW5zdGFudDogdHJ1ZSB9XSxcbiAgICAgIHJlcXVlc3RJZDogYCR7dGhpcy5pZH0taGVhbHRoYCxcbiAgICAgIHNjb3BlZFZhcnM6IHt9LFxuICAgICAgZGFzaGJvYXJkSWQ6IDAsXG4gICAgICBwYW5lbElkOiAwLFxuICAgICAgaW50ZXJ2YWw6ICcxbScsXG4gICAgICBpbnRlcnZhbE1zOiA2MDAwMCxcbiAgICAgIG1heERhdGFQb2ludHM6IDEsXG4gICAgICByYW5nZToge1xuICAgICAgICBmcm9tOiBkYXRlVGltZShub3cgLSAxMDAwKSxcbiAgICAgICAgdG86IGRhdGVUaW1lKG5vdyksXG4gICAgICB9LFxuICAgIH0gYXMgRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+O1xuXG4gICAgY29uc3QgYnVpbGRJbmZvID0gYXdhaXQgdGhpcy5nZXRCdWlsZEluZm8oKTtcblxuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKHRoaXMucXVlcnkocmVxdWVzdCkpXG4gICAgICAudGhlbigocmVzOiBEYXRhUXVlcnlSZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoIXJlcyB8fCAhcmVzLmRhdGEgfHwgcmVzLnN0YXRlICE9PSBMb2FkaW5nU3RhdGUuRG9uZSkge1xuICAgICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogYEVycm9yIHJlYWRpbmcgUHJvbWV0aGV1czogJHtyZXM/LmVycm9yPy5tZXNzYWdlfWAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiAnc3VjY2VzcycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRGF0YSBzb3VyY2UgaXMgd29ya2luZycsXG4gICAgICAgICAgICBkZXRhaWxzOiBidWlsZEluZm8gJiYge1xuICAgICAgICAgICAgICB2ZXJib3NlTWVzc2FnZTogdGhpcy5nZXRCdWlsZEluZm9NZXNzYWdlKGJ1aWxkSW5mbyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycjogYW55KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb21ldGhldXMgRXJyb3InLCBlcnIpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVyci5tZXNzYWdlIH07XG4gICAgICB9KTtcbiAgfVxuXG4gIGludGVycG9sYXRlVmFyaWFibGVzSW5RdWVyaWVzKHF1ZXJpZXM6IFByb21RdWVyeVtdLCBzY29wZWRWYXJzOiBTY29wZWRWYXJzKTogUHJvbVF1ZXJ5W10ge1xuICAgIGxldCBleHBhbmRlZFF1ZXJpZXMgPSBxdWVyaWVzO1xuICAgIGlmIChxdWVyaWVzICYmIHF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICBleHBhbmRlZFF1ZXJpZXMgPSBxdWVyaWVzLm1hcCgocXVlcnkpID0+IHtcbiAgICAgICAgY29uc3QgZXhwYW5kZWRRdWVyeSA9IHtcbiAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICBkYXRhc291cmNlOiB0aGlzLmdldFJlZigpLFxuICAgICAgICAgIGV4cHI6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeS5leHByLCBzY29wZWRWYXJzLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKSxcbiAgICAgICAgICBpbnRlcnZhbDogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LmludGVydmFsLCBzY29wZWRWYXJzKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkUXVlcnk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuZGVkUXVlcmllcztcbiAgfVxuXG4gIGdldFF1ZXJ5SGludHMocXVlcnk6IFByb21RdWVyeSwgcmVzdWx0OiBhbnlbXSkge1xuICAgIHJldHVybiBnZXRRdWVyeUhpbnRzKHF1ZXJ5LmV4cHIgPz8gJycsIHJlc3VsdCwgdGhpcyk7XG4gIH1cblxuICBnZXRJbml0SGludHMoKSB7XG4gICAgcmV0dXJuIGdldEluaXRIaW50cyh0aGlzKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRSdWxlcygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5tZXRhZGF0YVJlcXVlc3QoJy9hcGkvdjEvcnVsZXMnKTtcbiAgICAgIGNvbnN0IGdyb3VwcyA9IHJlcy5kYXRhPy5kYXRhPy5ncm91cHM7XG5cbiAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgdGhpcy5ydWxlTWFwcGluZ3MgPSBleHRyYWN0UnVsZU1hcHBpbmdGcm9tR3JvdXBzKGdyb3Vwcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ1J1bGVzIEFQSSBpcyBleHBlcmltZW50YWwuIElnbm9yZSBuZXh0IGVycm9yLicpO1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBhcmVFeGVtcGxhcnNBdmFpbGFibGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KCcvYXBpL3YxL3F1ZXJ5X2V4ZW1wbGFycycsIHsgcXVlcnk6ICd0ZXN0JyB9KTtcbiAgICAgIGlmIChyZXMuZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBtb2RpZnlRdWVyeShxdWVyeTogUHJvbVF1ZXJ5LCBhY3Rpb246IGFueSk6IFByb21RdWVyeSB7XG4gICAgbGV0IGV4cHJlc3Npb24gPSBxdWVyeS5leHByID8/ICcnO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0FERF9GSUxURVInOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBhZGRMYWJlbFRvUXVlcnkoZXhwcmVzc2lvbiwgYWN0aW9uLmtleSwgYWN0aW9uLnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBRERfRklMVEVSX09VVCc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGFkZExhYmVsVG9RdWVyeShleHByZXNzaW9uLCBhY3Rpb24ua2V5LCBhY3Rpb24udmFsdWUsICchPScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0FERF9ISVNUT0dSQU1fUVVBTlRJTEUnOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBgaGlzdG9ncmFtX3F1YW50aWxlKDAuOTUsIHN1bShyYXRlKCR7ZXhwcmVzc2lvbn1bJF9fcmF0ZV9pbnRlcnZhbF0pKSBieSAobGUpKWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQUREX1JBVEUnOiB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBgcmF0ZSgke2V4cHJlc3Npb259WyRfX3JhdGVfaW50ZXJ2YWxdKWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQUREX1NVTSc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGBzdW0oJHtleHByZXNzaW9uLnRyaW0oKX0pIGJ5ICgkMSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0VYUEFORF9SVUxFUyc6IHtcbiAgICAgICAgaWYgKGFjdGlvbi5tYXBwaW5nKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cGFuZFJlY29yZGluZ1J1bGVzKGV4cHJlc3Npb24sIGFjdGlvbi5tYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5xdWVyeSwgZXhwcjogZXhwcmVzc2lvbiB9O1xuICB9XG5cbiAgZ2V0UHJvbWV0aGV1c1RpbWUoZGF0ZTogc3RyaW5nIHwgRGF0ZVRpbWUsIHJvdW5kVXA6IGJvb2xlYW4pIHtcbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRlID0gZGF0ZU1hdGgucGFyc2UoZGF0ZSwgcm91bmRVcCkhO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmNlaWwoZGF0ZS52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgfVxuXG4gIGdldFRpbWVSYW5nZVBhcmFtcygpOiB7IHN0YXJ0OiBzdHJpbmc7IGVuZDogc3RyaW5nIH0ge1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogdGhpcy5nZXRQcm9tZXRoZXVzVGltZShyYW5nZS5mcm9tLCBmYWxzZSkudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogdGhpcy5nZXRQcm9tZXRoZXVzVGltZShyYW5nZS50bywgdHJ1ZSkudG9TdHJpbmcoKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKGxhYmVsRGF0YTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkge1xuICAgIHJldHVybiBnZXRPcmlnaW5hbE1ldHJpY05hbWUobGFiZWxEYXRhKTtcbiAgfVxuXG4gIGVuaGFuY2VFeHByV2l0aEFkSG9jRmlsdGVycyhleHByOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhZGhvY0ZpbHRlcnMgPSB0aGlzLnRlbXBsYXRlU3J2LmdldEFkaG9jRmlsdGVycyh0aGlzLm5hbWUpO1xuXG4gICAgY29uc3QgZmluYWxRdWVyeSA9IGFkaG9jRmlsdGVycy5yZWR1Y2UoKGFjYzogc3RyaW5nLCBmaWx0ZXI6IHsga2V5PzogYW55OyBvcGVyYXRvcj86IGFueTsgdmFsdWU/OiBhbnkgfSkgPT4ge1xuICAgICAgY29uc3QgeyBrZXksIG9wZXJhdG9yIH0gPSBmaWx0ZXI7XG4gICAgICBsZXQgeyB2YWx1ZSB9ID0gZmlsdGVyO1xuICAgICAgaWYgKG9wZXJhdG9yID09PSAnPX4nIHx8IG9wZXJhdG9yID09PSAnIX4nKSB7XG4gICAgICAgIHZhbHVlID0gcHJvbWV0aGV1c1JlZ3VsYXJFc2NhcGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZExhYmVsVG9RdWVyeShhY2MsIGtleSwgdmFsdWUsIG9wZXJhdG9yKTtcbiAgICB9LCBleHByKTtcbiAgICByZXR1cm4gZmluYWxRdWVyeTtcbiAgfVxuXG4gIC8vIFVzZWQgd2hlbiBydW5uaW5nIHF1ZXJpZXMgdHJvdWdoIGJhY2tlbmRcbiAgZmlsdGVyUXVlcnkocXVlcnk6IFByb21RdWVyeSk6IGJvb2xlYW4ge1xuICAgIGlmIChxdWVyeS5oaWRlIHx8ICFxdWVyeS5leHByKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVXNlZCB3aGVuIHJ1bm5pbmcgcXVlcmllcyB0cm91Z2ggYmFja2VuZFxuICBhcHBseVRlbXBsYXRlVmFyaWFibGVzKHRhcmdldDogUHJvbVF1ZXJ5LCBzY29wZWRWYXJzOiBTY29wZWRWYXJzKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgY29uc3QgdmFyaWFibGVzID0gY2xvbmVEZWVwKHNjb3BlZFZhcnMpO1xuXG4gICAgLy8gV2Ugd2FudCB0byBpbnRlcnBvbGF0ZSB0aGVzZSB2YXJpYWJsZXMgb24gYmFja2VuZFxuICAgIGRlbGV0ZSB2YXJpYWJsZXMuX19pbnRlcnZhbDtcbiAgICBkZWxldGUgdmFyaWFibGVzLl9faW50ZXJ2YWxfbXM7XG5cbiAgICAvL0FkZCBhZCBob2MgZmlsdGVyc1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLmVuaGFuY2VFeHByV2l0aEFkSG9jRmlsdGVycyh0YXJnZXQuZXhwcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgbGVnZW5kRm9ybWF0OiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UodGFyZ2V0LmxlZ2VuZEZvcm1hdCwgdmFyaWFibGVzKSxcbiAgICAgIGV4cHI6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShleHByLCB2YXJpYWJsZXMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpLFxuICAgICAgaW50ZXJ2YWw6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQuaW50ZXJ2YWwsIHZhcmlhYmxlcyksXG4gICAgfTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVTcnYuZ2V0VmFyaWFibGVzKCkubWFwKCh2KSA9PiBgJCR7di5uYW1lfWApO1xuICB9XG5cbiAgaW50ZXJwb2xhdGVTdHJpbmcoc3RyaW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHN0cmluZywgdW5kZWZpbmVkLCB0aGlzLmludGVycG9sYXRlUXVlcnlFeHByKTtcbiAgfVxufVxuXG4vKipcbiAqIEFsaWduIHF1ZXJ5IHJhbmdlIHRvIHN0ZXAuXG4gKiBSb3VuZHMgc3RhcnQgYW5kIGVuZCBkb3duIHRvIGEgbXVsdGlwbGUgb2Ygc3RlcC5cbiAqIEBwYXJhbSBzdGFydCBUaW1lc3RhbXAgbWFya2luZyB0aGUgYmVnaW5uaW5nIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSBlbmQgVGltZXN0YW1wIG1hcmtpbmcgdGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0gc3RlcCBJbnRlcnZhbCB0byBhbGlnbiBzdGFydCBhbmQgZW5kIHdpdGguXG4gKiBAcGFyYW0gdXRjT2Zmc2V0U2VjIE51bWJlciBvZiBzZWNvbmRzIGN1cnJlbnQgdGltZXpvbmUgaXMgb2Zmc2V0IGZyb20gVVRDXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnblJhbmdlKFxuICBzdGFydDogbnVtYmVyLFxuICBlbmQ6IG51bWJlcixcbiAgc3RlcDogbnVtYmVyLFxuICB1dGNPZmZzZXRTZWM6IG51bWJlclxuKTogeyBlbmQ6IG51bWJlcjsgc3RhcnQ6IG51bWJlciB9IHtcbiAgY29uc3QgYWxpZ25lZEVuZCA9IE1hdGguZmxvb3IoKGVuZCArIHV0Y09mZnNldFNlYykgLyBzdGVwKSAqIHN0ZXAgLSB1dGNPZmZzZXRTZWM7XG4gIGNvbnN0IGFsaWduZWRTdGFydCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgdXRjT2Zmc2V0U2VjKSAvIHN0ZXApICogc3RlcCAtIHV0Y09mZnNldFNlYztcbiAgcmV0dXJuIHtcbiAgICBlbmQ6IGFsaWduZWRFbmQsXG4gICAgc3RhcnQ6IGFsaWduZWRTdGFydCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RSdWxlTWFwcGluZ0Zyb21Hcm91cHMoZ3JvdXBzOiBhbnlbXSkge1xuICByZXR1cm4gZ3JvdXBzLnJlZHVjZShcbiAgICAobWFwcGluZywgZ3JvdXApID0+XG4gICAgICBncm91cC5ydWxlc1xuICAgICAgICAuZmlsdGVyKChydWxlOiBhbnkpID0+IHJ1bGUudHlwZSA9PT0gJ3JlY29yZGluZycpXG4gICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgKGFjYzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSwgcnVsZTogYW55KSA9PiAoe1xuICAgICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgICAgW3J1bGUubmFtZV06IHJ1bGUucXVlcnksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWFwcGluZ1xuICAgICAgICApLFxuICAgIHt9XG4gICk7XG59XG5cbi8vIE5PVEU6IHRoZXNlIHR3byBmdW5jdGlvbnMgYXJlIHZlcnkgc2ltaWxhciB0byB0aGUgZXNjYXBlTGFiZWxWYWx1ZUluKiBmdW5jdGlvbnNcbi8vIGluIGxhbmd1YWdlX3V0aWxzLnRzLCBidXQgdGhleSBhcmUgbm90IGV4YWN0bHkgdGhlIHNhbWUgYWxnb3JpdGhtLCBhbmQgd2UgZm91bmRcbi8vIG5vIHdheSB0byByZXVzZSBvbmUgaW4gdGhlIGFub3RoZXIgb3IgdmljZSB2ZXJzYS5cbmV4cG9ydCBmdW5jdGlvbiBwcm9tZXRoZXVzUmVndWxhckVzY2FwZSh2YWx1ZTogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC8nL2csIFwiXFxcXFxcXFwnXCIpIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9tZXRoZXVzU3BlY2lhbFJlZ2V4RXNjYXBlKHZhbHVlOiBhbnkpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXFxcXFxcXFxcJykucmVwbGFjZSgvWyReKnt9XFxbXFxdXFwnKz8uKCl8XS9nLCAnXFxcXFxcXFwkJicpIDogdmFsdWU7XG59XG4iLCJpbXBvcnQgeyBvbmNlLCBjaGFpbiwgZGlmZmVyZW5jZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgTFJVIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCBQcmlzbSBmcm9tICdwcmlzbWpzJztcblxuaW1wb3J0IHtcbiAgQWJzdHJhY3RMYWJlbE1hdGNoZXIsXG4gIEFic3RyYWN0TGFiZWxPcGVyYXRvcixcbiAgQWJzdHJhY3RRdWVyeSxcbiAgZGF0ZVRpbWUsXG4gIEhpc3RvcnlJdGVtLFxuICBMYW5ndWFnZVByb3ZpZGVyLFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IENvbXBsZXRpb25JdGVtLCBDb21wbGV0aW9uSXRlbUdyb3VwLCBTZWFyY2hGdW5jdGlvblR5cGUsIFR5cGVhaGVhZElucHV0LCBUeXBlYWhlYWRPdXRwdXQgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7XG4gIGFkZExpbWl0SW5mbyxcbiAgZXh0cmFjdExhYmVsTWF0Y2hlcnMsXG4gIGZpeFN1bW1hcmllc01ldGFkYXRhLFxuICBwYXJzZVNlbGVjdG9yLFxuICBwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyxcbiAgcHJvY2Vzc0xhYmVscyxcbiAgcm91bmRTZWNUb01pbixcbiAgdG9Qcm9tTGlrZVF1ZXJ5LFxufSBmcm9tICcuL2xhbmd1YWdlX3V0aWxzJztcbmltcG9ydCBQcm9tcWxTeW50YXgsIHsgRlVOQ1RJT05TLCBSQVRFX1JBTkdFUyB9IGZyb20gJy4vcHJvbXFsJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbU1ldHJpY3NNZXRhZGF0YSwgUHJvbVF1ZXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfS0VZUyA9IFsnam9iJywgJ2luc3RhbmNlJ107XG5jb25zdCBFTVBUWV9TRUxFQ1RPUiA9ICd7fSc7XG5jb25zdCBISVNUT1JZX0lURU1fQ09VTlQgPSA1O1xuY29uc3QgSElTVE9SWV9DT1VOVF9DVVRPRkYgPSAxMDAwICogNjAgKiA2MCAqIDI0OyAvLyAyNGhcbi8vIE1heCBudW1iZXIgb2YgaXRlbXMgKG1ldHJpY3MsIGxhYmVscywgdmFsdWVzKSB0aGF0IHdlIGRpc3BsYXkgYXMgc3VnZ2VzdGlvbnMuIFByZXZlbnRzIGZyb20gcnVubmluZyBvdXQgb2YgbWVtb3J5LlxuZXhwb3J0IGNvbnN0IFNVR0dFU1RJT05TX0xJTUlUID0gMTAwMDA7XG5cbmNvbnN0IHdyYXBMYWJlbCA9IChsYWJlbDogc3RyaW5nKTogQ29tcGxldGlvbkl0ZW0gPT4gKHsgbGFiZWwgfSk7XG5cbmNvbnN0IHNldEZ1bmN0aW9uS2luZCA9IChzdWdnZXN0aW9uOiBDb21wbGV0aW9uSXRlbSk6IENvbXBsZXRpb25JdGVtID0+IHtcbiAgc3VnZ2VzdGlvbi5raW5kID0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHN1Z2dlc3Rpb247XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSGlzdG9yeU1ldGFkYXRhKGl0ZW06IENvbXBsZXRpb25JdGVtLCBoaXN0b3J5OiBhbnlbXSk6IENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3QgY3V0b2ZmVHMgPSBEYXRlLm5vdygpIC0gSElTVE9SWV9DT1VOVF9DVVRPRkY7XG4gIGNvbnN0IGhpc3RvcnlGb3JJdGVtID0gaGlzdG9yeS5maWx0ZXIoKGgpID0+IGgudHMgPiBjdXRvZmZUcyAmJiBoLnF1ZXJ5ID09PSBpdGVtLmxhYmVsKTtcbiAgY29uc3QgY291bnQgPSBoaXN0b3J5Rm9ySXRlbS5sZW5ndGg7XG4gIGNvbnN0IHJlY2VudCA9IGhpc3RvcnlGb3JJdGVtWzBdO1xuICBsZXQgaGludCA9IGBRdWVyaWVkICR7Y291bnR9IHRpbWVzIGluIHRoZSBsYXN0IDI0aC5gO1xuXG4gIGlmIChyZWNlbnQpIHtcbiAgICBjb25zdCBsYXN0UXVlcmllZCA9IGRhdGVUaW1lKHJlY2VudC50cykuZnJvbU5vdygpO1xuICAgIGhpbnQgPSBgJHtoaW50fSBMYXN0IHF1ZXJpZWQgJHtsYXN0UXVlcmllZH0uYDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uaXRlbSxcbiAgICBkb2N1bWVudGF0aW9uOiBoaW50LFxuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRNZXRyaWNzTWV0YWRhdGEobWV0cmljOiBzdHJpbmcsIG1ldGFkYXRhPzogUHJvbU1ldHJpY3NNZXRhZGF0YSk6IENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3QgaXRlbTogQ29tcGxldGlvbkl0ZW0gPSB7IGxhYmVsOiBtZXRyaWMgfTtcbiAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhW21ldHJpY10pIHtcbiAgICBpdGVtLmRvY3VtZW50YXRpb24gPSBnZXRNZXRhZGF0YVN0cmluZyhtZXRyaWMsIG1ldGFkYXRhKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGFkYXRhU3RyaW5nKG1ldHJpYzogc3RyaW5nLCBtZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghbWV0YWRhdGFbbWV0cmljXSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgeyB0eXBlLCBoZWxwIH0gPSBtZXRhZGF0YVttZXRyaWNdO1xuICByZXR1cm4gYCR7dHlwZS50b1VwcGVyQ2FzZSgpfTogJHtoZWxwfWA7XG59XG5cbmNvbnN0IFBSRUZJWF9ERUxJTUlURVJfUkVHRVggPVxuICAvKD1cInwhPVwifD1+XCJ8IX5cInxcXHt8XFxbfFxcKHxcXCt8LXxcXC98XFwqfCV8XFxefFxcYmFuZFxcYnxcXGJvclxcYnxcXGJ1bmxlc3NcXGJ8PT18Pj18IT18PD18Pnw8fD18fnwsKS87XG5cbmludGVyZmFjZSBBdXRvY29tcGxldGVDb250ZXh0IHtcbiAgaGlzdG9yeT86IEFycmF5PEhpc3RvcnlJdGVtPFByb21RdWVyeT4+O1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvbVFsTGFuZ3VhZ2VQcm92aWRlciBleHRlbmRzIExhbmd1YWdlUHJvdmlkZXIge1xuICBoaXN0b2dyYW1NZXRyaWNzOiBzdHJpbmdbXTtcbiAgdGltZVJhbmdlPzogeyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlciB9O1xuICBtZXRyaWNzOiBzdHJpbmdbXTtcbiAgbWV0cmljc01ldGFkYXRhPzogUHJvbU1ldHJpY3NNZXRhZGF0YTtcbiAgZGVjbGFyZSBzdGFydFRhc2s6IFByb21pc2U8YW55PjtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIGxhYmVsS2V5czogc3RyaW5nW10gPSBbXTtcbiAgZGVjbGFyZSBsYWJlbEZldGNoVHM6IG51bWJlcjtcblxuICAvKipcbiAgICogIENhY2hlIGZvciBsYWJlbHMgb2Ygc2VyaWVzLiBUaGlzIGlzIGJpdCBzaW1wbGlzdGljIGluIHRoZSBzZW5zZSB0aGF0IGl0IGp1c3QgY291bnRzIHJlc3BvbnNlcyBlYWNoIGFzIGEgMSBhbmQgZG9lc1xuICAgKiAgbm90IGFjY291bnQgZm9yIGRpZmZlcmVudCBzaXplIG9mIGEgcmVzcG9uc2UuIElmIHRoYXQgaXMgbmVlZGVkIGEgYGxlbmd0aGAgZnVuY3Rpb24gY2FuIGJlIGFkZGVkIGluIHRoZSBvcHRpb25zLlxuICAgKiAgMTAgYXMgYSBtYXggc2l6ZSBpcyB0b3RhbGx5IGFyYml0cmFyeSByaWdodCBub3cuXG4gICAqL1xuICBwcml2YXRlIGxhYmVsc0NhY2hlID0gbmV3IExSVTxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4oeyBtYXg6IDEwIH0pO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlLCBpbml0aWFsVmFsdWVzPzogUGFydGlhbDxQcm9tUWxMYW5ndWFnZVByb3ZpZGVyPikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRhdGFzb3VyY2UgPSBkYXRhc291cmNlO1xuICAgIHRoaXMuaGlzdG9ncmFtTWV0cmljcyA9IFtdO1xuICAgIHRoaXMudGltZVJhbmdlID0geyBzdGFydDogMCwgZW5kOiAwIH07XG4gICAgdGhpcy5tZXRyaWNzID0gW107XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXRpYWxWYWx1ZXMpO1xuICB9XG5cbiAgLy8gU3RyaXAgc3ludGF4IGNoYXJzIHNvIHRoYXQgdHlwZWFoZWFkIHN1Z2dlc3Rpb25zIGNhbiB3b3JrIG9uIGNsZWFuIGlucHV0c1xuICBjbGVhblRleHQoczogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFydHMgPSBzLnNwbGl0KFBSRUZJWF9ERUxJTUlURVJfUkVHRVgpO1xuICAgIGNvbnN0IGxhc3QgPSBwYXJ0cy5wb3AoKSE7XG4gICAgcmV0dXJuIGxhc3QudHJpbUxlZnQoKS5yZXBsYWNlKC9cIiQvLCAnJykucmVwbGFjZSgvXlwiLywgJycpO1xuICB9XG5cbiAgZ2V0IHN5bnRheCgpIHtcbiAgICByZXR1cm4gUHJvbXFsU3ludGF4O1xuICB9XG5cbiAgcmVxdWVzdCA9IGFzeW5jICh1cmw6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBhbnksIHBhcmFtcyA9IHt9KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gcmVzLmRhdGEuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfTtcblxuICBzdGFydCA9IGFzeW5jICgpOiBQcm9taXNlPGFueVtdPiA9PiB7XG4gICAgaWYgKHRoaXMuZGF0YXNvdXJjZS5sb29rdXBzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPICMzMzk3NjogbWFrZSB0aG9zZSByZXF1ZXN0cyBwYXJhbGxlbFxuICAgIGF3YWl0IHRoaXMuZmV0Y2hMYWJlbHMoKTtcbiAgICB0aGlzLm1ldHJpY3MgPSAoYXdhaXQgdGhpcy5mZXRjaExhYmVsVmFsdWVzKCdfX25hbWVfXycpKSB8fCBbXTtcbiAgICBhd2FpdCB0aGlzLmxvYWRNZXRyaWNzTWV0YWRhdGEoKTtcbiAgICB0aGlzLmhpc3RvZ3JhbU1ldHJpY3MgPSBwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyh0aGlzLm1ldHJpY3MpLnNvcnQoKTtcbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgYXN5bmMgbG9hZE1ldHJpY3NNZXRhZGF0YSgpIHtcbiAgICB0aGlzLm1ldHJpY3NNZXRhZGF0YSA9IGZpeFN1bW1hcmllc01ldGFkYXRhKGF3YWl0IHRoaXMucmVxdWVzdCgnL2FwaS92MS9tZXRhZGF0YScsIHt9KSk7XG4gIH1cblxuICBnZXRMYWJlbEtleXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmxhYmVsS2V5cztcbiAgfVxuXG4gIHByb3ZpZGVDb21wbGV0aW9uSXRlbXMgPSBhc3luYyAoXG4gICAgeyBwcmVmaXgsIHRleHQsIHZhbHVlLCBsYWJlbEtleSwgd3JhcHBlckNsYXNzZXMgfTogVHlwZWFoZWFkSW5wdXQsXG4gICAgY29udGV4dDogQXV0b2NvbXBsZXRlQ29udGV4dCA9IHt9XG4gICk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgY29uc3QgZW1wdHlSZXN1bHQ6IFR5cGVhaGVhZE91dHB1dCA9IHsgc3VnZ2VzdGlvbnM6IFtdIH07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZW1wdHlSZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gTG9jYWwgdGV4dCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZW1wdHkgPSB2YWx1ZS5kb2N1bWVudC50ZXh0Lmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBzZWxlY3RlZExpbmVzID0gdmFsdWUuZG9jdW1lbnQuZ2V0VGV4dHNBdFJhbmdlKHZhbHVlLnNlbGVjdGlvbik7XG4gICAgY29uc3QgY3VycmVudExpbmUgPSBzZWxlY3RlZExpbmVzLnNpemUgPT09IDEgPyBzZWxlY3RlZExpbmVzLmZpcnN0KCkuZ2V0VGV4dCgpIDogbnVsbDtcblxuICAgIGNvbnN0IG5leHRDaGFyYWN0ZXIgPSBjdXJyZW50TGluZSA/IGN1cnJlbnRMaW5lW3ZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0XSA6IG51bGw7XG5cbiAgICAvLyBTeW50YXggc3BhbnMgaGF2ZSAzIGNsYXNzZXMgYnkgZGVmYXVsdC4gTW9yZSBpbmRpY2F0ZSBhIHJlY29nbml6ZWQgdG9rZW5cbiAgICBjb25zdCB0b2tlblJlY29nbml6ZWQgPSB3cmFwcGVyQ2xhc3Nlcy5sZW5ndGggPiAzO1xuICAgIC8vIE5vbi1lbXB0eSBwcmVmaXgsIGJ1dCBub3QgaW5zaWRlIGtub3duIHRva2VuXG4gICAgY29uc3QgcHJlZml4VW5yZWNvZ25pemVkID0gcHJlZml4ICYmICF0b2tlblJlY29nbml6ZWQ7XG5cbiAgICAvLyBQcmV2ZW50IHN1Z2dlc3Rpb25zIGluIGBmdW5jdGlvbih8c3VmZml4KWBcbiAgICBjb25zdCBub1N1ZmZpeCA9ICFuZXh0Q2hhcmFjdGVyIHx8IG5leHRDaGFyYWN0ZXIgPT09ICcpJztcblxuICAgIC8vIFByZWZpeCBpcyBzYWZlIGlmIGl0IGRvZXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvdyBhIGNvbXBsZXRlIGV4cHJlc3Npb24gYW5kIGhhcyBubyB0ZXh0IGFmdGVyIGl0XG4gICAgY29uc3Qgc2FmZVByZWZpeCA9IHByZWZpeCAmJiAhdGV4dC5tYXRjaCgvXltcXF19KVxcc10rJC8pICYmIG5vU3VmZml4O1xuXG4gICAgLy8gQWJvdXQgdG8gdHlwZSBuZXh0IG9wZXJhbmQgaWYgcHJlY2VkZWQgYnkgYmluYXJ5IG9wZXJhdG9yXG4gICAgY29uc3Qgb3BlcmF0b3JzUGF0dGVybiA9IC9bK1xcLSovXiVdLztcbiAgICBjb25zdCBpc05leHRPcGVyYW5kID0gdGV4dC5tYXRjaChvcGVyYXRvcnNQYXR0ZXJuKTtcblxuICAgIC8vIERldGVybWluZSBjYW5kaWRhdGVzIGJ5IENTUyBjb250ZXh0XG4gICAgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LXJhbmdlJykpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBtZXRyaWNbfF1cbiAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlQ29tcGxldGlvbkl0ZW1zKCk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1sYWJlbHMnKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIG1ldHJpY3t8fSBhbmQgbWV0cmlje2Zvbz18fSwgYXMgd2VsbCBhcyBtZXRyaWMtaW5kZXBlbmRlbnQgbGFiZWwgcXVlcmllcyBsaWtlIHt8fVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFiZWxDb21wbGV0aW9uSXRlbXMoeyBwcmVmaXgsIHRleHQsIHZhbHVlLCBsYWJlbEtleSwgd3JhcHBlckNsYXNzZXMgfSk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnY29udGV4dC1hZ2dyZWdhdGlvbicpKSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3Igc3VtKG1ldHJpYykgYnkgKHwpXG4gICAgICByZXR1cm4gdGhpcy5nZXRBZ2dyZWdhdGlvbkNvbXBsZXRpb25JdGVtcyh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChlbXB0eSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIGVtcHR5IHF1ZXJ5IGZpZWxkXG4gICAgICByZXR1cm4gdGhpcy5nZXRFbXB0eUNvbXBsZXRpb25JdGVtcyhjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeFVucmVjb2duaXplZCAmJiBub1N1ZmZpeCAmJiAhaXNOZXh0T3BlcmFuZCkge1xuICAgICAgLy8gU2hvdyB0ZXJtIHN1Z2dlc3Rpb25zIGluIGEgY291cGxlIG9mIHNjZW5hcmlvc1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocHJlZml4VW5yZWNvZ25pemVkICYmIHNhZmVQcmVmaXgpIHtcbiAgICAgIC8vIFNob3cgdGVybSBzdWdnZXN0aW9ucyBpbiBhIGNvdXBsZSBvZiBzY2VuYXJpb3NcbiAgICAgIHJldHVybiB0aGlzLmdldFRlcm1Db21wbGV0aW9uSXRlbXMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHlSZXN1bHQ7XG4gIH07XG5cbiAgZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zID0gKGNvbnRleHQ6IEF1dG9jb21wbGV0ZUNvbnRleHQpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdWdnZXN0aW9uczogWy4uLnRoaXMuZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMoY29udGV4dCkuc3VnZ2VzdGlvbnMsIC4uLnRoaXMuZ2V0VGVybUNvbXBsZXRpb25JdGVtcygpLnN1Z2dlc3Rpb25zXSxcbiAgICB9O1xuICB9O1xuXG4gIGdldEVtcHR5Q29tcGxldGlvbkl0ZW1zID0gKGNvbnRleHQ6IEF1dG9jb21wbGV0ZUNvbnRleHQpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHsgaGlzdG9yeSB9ID0gY29udGV4dDtcbiAgICBjb25zdCBzdWdnZXN0aW9uczogQ29tcGxldGlvbkl0ZW1Hcm91cFtdID0gW107XG5cbiAgICBpZiAoaGlzdG9yeSAmJiBoaXN0b3J5Lmxlbmd0aCkge1xuICAgICAgY29uc3QgaGlzdG9yeUl0ZW1zID0gY2hhaW4oaGlzdG9yeSlcbiAgICAgICAgLm1hcCgoaCkgPT4gaC5xdWVyeS5leHByKVxuICAgICAgICAuZmlsdGVyKClcbiAgICAgICAgLnVuaXEoKVxuICAgICAgICAudGFrZShISVNUT1JZX0lURU1fQ09VTlQpXG4gICAgICAgIC5tYXAod3JhcExhYmVsKVxuICAgICAgICAubWFwKChpdGVtKSA9PiBhZGRIaXN0b3J5TWV0YWRhdGEoaXRlbSwgaGlzdG9yeSkpXG4gICAgICAgIC52YWx1ZSgpO1xuXG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuUHJlZml4LFxuICAgICAgICBza2lwU29ydDogdHJ1ZSxcbiAgICAgICAgbGFiZWw6ICdIaXN0b3J5JyxcbiAgICAgICAgaXRlbXM6IGhpc3RvcnlJdGVtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zIH07XG4gIH07XG5cbiAgZ2V0VGVybUNvbXBsZXRpb25JdGVtcyA9ICgpOiBUeXBlYWhlYWRPdXRwdXQgPT4ge1xuICAgIGNvbnN0IHsgbWV0cmljcywgbWV0cmljc01ldGFkYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcblxuICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuUHJlZml4LFxuICAgICAgbGFiZWw6ICdGdW5jdGlvbnMnLFxuICAgICAgaXRlbXM6IEZVTkNUSU9OUy5tYXAoc2V0RnVuY3Rpb25LaW5kKSxcbiAgICB9KTtcblxuICAgIGlmIChtZXRyaWNzICYmIG1ldHJpY3MubGVuZ3RoKSB7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgbGFiZWw6ICdNZXRyaWNzJyxcbiAgICAgICAgaXRlbXM6IG1ldHJpY3MubWFwKChtKSA9PiBhZGRNZXRyaWNzTWV0YWRhdGEobSwgbWV0cmljc01ldGFkYXRhKSksXG4gICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBnZXRSYW5nZUNvbXBsZXRpb25JdGVtcygpOiBUeXBlYWhlYWRPdXRwdXQge1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiAnY29udGV4dC1yYW5nZScsXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdSYW5nZSB2ZWN0b3InLFxuICAgICAgICAgIGl0ZW1zOiBbLi4uUkFURV9SQU5HRVNdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0QWdncmVnYXRpb25Db21wbGV0aW9uSXRlbXMgPSBhc3luYyAodmFsdWU6IFZhbHVlKTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+ID0+IHtcbiAgICBjb25zdCBzdWdnZXN0aW9uczogQ29tcGxldGlvbkl0ZW1Hcm91cFtdID0gW107XG5cbiAgICAvLyBTdGl0Y2ggYWxsIHF1ZXJ5IGxpbmVzIHRvZ2V0aGVyIHRvIHN1cHBvcnQgbXVsdGktbGluZSBxdWVyaWVzXG4gICAgbGV0IHF1ZXJ5T2Zmc2V0O1xuICAgIGNvbnN0IHF1ZXJ5VGV4dCA9IHZhbHVlLmRvY3VtZW50LmdldEJsb2NrcygpLnJlZHVjZSgodGV4dCwgYmxvY2spID0+IHtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gYmxvY2s/LmdldFRleHQoKTtcblxuICAgICAgaWYgKHZhbHVlLmFuY2hvckJsb2NrLmtleSA9PT0gYmxvY2sua2V5KSB7XG4gICAgICAgIC8vIE5ld2xpbmUgY2hhcmFjdGVycyBhcmUgbm90IGFjY291bnRlZCBmb3IgYnV0IHRoaXMgaXMgaXJyZWxldmFudFxuICAgICAgICAvLyBmb3IgdGhlIHB1cnBvc2Ugb2YgZXh0cmFjdGluZyB0aGUgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgIHF1ZXJ5T2Zmc2V0ID0gdmFsdWUuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHQgKyBibG9ja1RleHQ7XG4gICAgfSwgJycpO1xuXG4gICAgLy8gVHJ5IHNlYXJjaCBmb3Igc2VsZWN0b3IgcGFydCBvbiB0aGUgbGVmdC1oYW5kIHNpZGUsIHN1Y2ggYXMgYHN1bSAobSkgYnkgKGwpYFxuICAgIGNvbnN0IG9wZW5QYXJlbnNBZ2dyZWdhdGlvbkluZGV4ID0gcXVlcnlUZXh0Lmxhc3RJbmRleE9mKCcoJywgcXVlcnlPZmZzZXQpO1xuICAgIGxldCBvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5sYXN0SW5kZXhPZignKCcsIG9wZW5QYXJlbnNBZ2dyZWdhdGlvbkluZGV4IC0gMSk7XG4gICAgbGV0IGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5pbmRleE9mKCcpJywgb3BlblBhcmVuc1NlbGVjdG9ySW5kZXgpO1xuXG4gICAgLy8gVHJ5IHNlYXJjaCBmb3Igc2VsZWN0b3IgcGFydCBvZiBhbiBhbHRlcm5hdGUgYWdncmVnYXRpb24gY2xhdXNlLCBzdWNoIGFzIGBzdW0gYnkgKGwpIChtKWBcbiAgICBpZiAob3BlblBhcmVuc1NlbGVjdG9ySW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggPSBxdWVyeVRleHQuaW5kZXhPZignKScsIHF1ZXJ5T2Zmc2V0KTtcbiAgICAgIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5pbmRleE9mKCcpJywgY2xvc2VQYXJlbnNBZ2dyZWdhdGlvbkluZGV4ICsgMSk7XG4gICAgICBvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9IHF1ZXJ5VGV4dC5sYXN0SW5kZXhPZignKCcsIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgc3VnZ2VzdGlvbnMsXG4gICAgICBjb250ZXh0OiAnY29udGV4dC1hZ2dyZWdhdGlvbicsXG4gICAgfTtcblxuICAgIC8vIFN1Z2dlc3Rpb25zIGFyZSB1c2VsZXNzIGZvciBhbHRlcm5hdGl2ZSBhZ2dyZWdhdGlvbiBjbGF1c2VzIHdpdGhvdXQgYSBzZWxlY3RvciBpbiBjb250ZXh0XG4gICAgaWYgKG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBSYW5nZSB2ZWN0b3Igc3ludGF4IG5vdCBhY2NvdW50ZWQgZm9yIGJ5IHN1YnNlcXVlbnQgcGFyc2Ugc28gZGlzY2FyZCBpdCBpZiBwcmVzZW50XG4gICAgY29uc3Qgc2VsZWN0b3JTdHJpbmcgPSBxdWVyeVRleHRcbiAgICAgIC5zbGljZShvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCArIDEsIGNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleClcbiAgICAgIC5yZXBsYWNlKC9cXFtbXlxcXV0rXFxdJC8sICcnKTtcblxuICAgIGNvbnN0IHNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihzZWxlY3RvclN0cmluZywgc2VsZWN0b3JTdHJpbmcubGVuZ3RoIC0gMikuc2VsZWN0b3I7XG5cbiAgICBjb25zdCBzZXJpZXMgPSBhd2FpdCB0aGlzLmdldFNlcmllcyhzZWxlY3Rvcik7XG4gICAgY29uc3QgbGFiZWxLZXlzID0gT2JqZWN0LmtleXMoc2VyaWVzKTtcbiAgICBpZiAobGFiZWxLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxpbWl0SW5mbyA9IGFkZExpbWl0SW5mbyhsYWJlbEtleXMpO1xuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIGxhYmVsOiBgTGFiZWxzJHtsaW1pdEluZm99YCxcbiAgICAgICAgaXRlbXM6IGxhYmVsS2V5cy5tYXAod3JhcExhYmVsKSxcbiAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuRnV6enksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBnZXRMYWJlbENvbXBsZXRpb25JdGVtcyA9IGFzeW5jICh7XG4gICAgdGV4dCxcbiAgICB3cmFwcGVyQ2xhc3NlcyxcbiAgICBsYWJlbEtleSxcbiAgICB2YWx1ZSxcbiAgfTogVHlwZWFoZWFkSW5wdXQpOiBQcm9taXNlPFR5cGVhaGVhZE91dHB1dD4gPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB7IHN1Z2dlc3Rpb25zOiBbXSB9O1xuICAgIH1cblxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcbiAgICBjb25zdCBsaW5lID0gdmFsdWUuYW5jaG9yQmxvY2suZ2V0VGV4dCgpO1xuICAgIGNvbnN0IGN1cnNvck9mZnNldCA9IHZhbHVlLnNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IHN1ZmZpeCA9IGxpbmUuc3Vic3RyKGN1cnNvck9mZnNldCk7XG4gICAgY29uc3QgcHJlZml4ID0gbGluZS5zdWJzdHIoMCwgY3Vyc29yT2Zmc2V0KTtcbiAgICBjb25zdCBpc1ZhbHVlU3RhcnQgPSB0ZXh0Lm1hdGNoKC9eKD18PX58IT18IX4pLyk7XG4gICAgY29uc3QgaXNWYWx1ZUVuZCA9IHN1ZmZpeC5tYXRjaCgvXlwiP1ssfV18JC8pO1xuICAgIC8vIERldGVjdCBjdXJzb3IgaW4gZnJvbnQgb2YgdmFsdWUsIGUuZy4sIHtrZXk9fFwifVxuICAgIGNvbnN0IGlzUHJlVmFsdWUgPSBwcmVmaXgubWF0Y2goLyg9fD1+fCE9fCF+KSQvKSAmJiBzdWZmaXgubWF0Y2goL15cIi8pO1xuXG4gICAgLy8gRG9uJ3Qgc3VnZ2VzdCBhbnl0aGluZyBhdCB0aGUgYmVnaW5uaW5nIG9yIGluc2lkZSBhIHZhbHVlXG4gICAgY29uc3QgaXNWYWx1ZUVtcHR5ID0gaXNWYWx1ZVN0YXJ0ICYmIGlzVmFsdWVFbmQ7XG4gICAgY29uc3QgaGFzVmFsdWVQcmVmaXggPSBpc1ZhbHVlRW5kICYmICFpc1ZhbHVlU3RhcnQ7XG4gICAgaWYgKCghaXNWYWx1ZUVtcHR5ICYmICFoYXNWYWx1ZVByZWZpeCkgfHwgaXNQcmVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbm9ybWFsaXplZCBzZWxlY3RvclxuICAgIGxldCBzZWxlY3RvcjtcbiAgICBsZXQgcGFyc2VkU2VsZWN0b3I7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihsaW5lLCBjdXJzb3JPZmZzZXQpO1xuICAgICAgc2VsZWN0b3IgPSBwYXJzZWRTZWxlY3Rvci5zZWxlY3RvcjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHNlbGVjdG9yID0gRU1QVFlfU0VMRUNUT1I7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbnNNZXRyaWMgPSBzZWxlY3Rvci5pbmNsdWRlcygnX19uYW1lX189Jyk7XG4gICAgY29uc3QgZXhpc3RpbmdLZXlzID0gcGFyc2VkU2VsZWN0b3IgPyBwYXJzZWRTZWxlY3Rvci5sYWJlbEtleXMgOiBbXTtcblxuICAgIGxldCBzZXJpZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIC8vIFF1ZXJ5IGxhYmVscyBmb3Igc2VsZWN0b3JcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHNlcmllcyA9IGF3YWl0IHRoaXMuZ2V0U2VyaWVzKHNlbGVjdG9yLCAhY29udGFpbnNNZXRyaWMpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhzZXJpZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKGBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW55IHZhbHVlcyBmb3Igc2VsZWN0b3IgPSAke3NlbGVjdG9yfWApO1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgICB9XG5cbiAgICBsZXQgY29udGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCh0ZXh0ICYmIGlzVmFsdWVTdGFydCkgfHwgd3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2F0dHItdmFsdWUnKSkge1xuICAgICAgLy8gTGFiZWwgdmFsdWVzXG4gICAgICBpZiAobGFiZWxLZXkgJiYgc2VyaWVzW2xhYmVsS2V5XSkge1xuICAgICAgICBjb250ZXh0ID0gJ2NvbnRleHQtbGFiZWwtdmFsdWVzJztcbiAgICAgICAgY29uc3QgbGltaXRJbmZvID0gYWRkTGltaXRJbmZvKHNlcmllc1tsYWJlbEtleV0pO1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBsYWJlbDogYExhYmVsIHZhbHVlcyBmb3IgXCIke2xhYmVsS2V5fVwiJHtsaW1pdEluZm99YCxcbiAgICAgICAgICBpdGVtczogc2VyaWVzW2xhYmVsS2V5XS5tYXAod3JhcExhYmVsKSxcbiAgICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5GdXp6eSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExhYmVsIGtleXNcbiAgICAgIGNvbnN0IGxhYmVsS2V5cyA9IHNlcmllcyA/IE9iamVjdC5rZXlzKHNlcmllcykgOiBjb250YWluc01ldHJpYyA/IG51bGwgOiBERUZBVUxUX0tFWVM7XG5cbiAgICAgIGlmIChsYWJlbEtleXMpIHtcbiAgICAgICAgY29uc3QgcG9zc2libGVLZXlzID0gZGlmZmVyZW5jZShsYWJlbEtleXMsIGV4aXN0aW5nS2V5cyk7XG4gICAgICAgIGlmIChwb3NzaWJsZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGV4dCA9ICdjb250ZXh0LWxhYmVscyc7XG4gICAgICAgICAgY29uc3QgbmV3SXRlbXMgPSBwb3NzaWJsZUtleXMubWFwKChrZXkpID0+ICh7IGxhYmVsOiBrZXkgfSkpO1xuICAgICAgICAgIGNvbnN0IGxpbWl0SW5mbyA9IGFkZExpbWl0SW5mbyhuZXdJdGVtcyk7XG4gICAgICAgICAgY29uc3QgbmV3U3VnZ2VzdGlvbjogQ29tcGxldGlvbkl0ZW1Hcm91cCA9IHtcbiAgICAgICAgICAgIGxhYmVsOiBgTGFiZWxzJHtsaW1pdEluZm99YCxcbiAgICAgICAgICAgIGl0ZW1zOiBuZXdJdGVtcyxcbiAgICAgICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgICAgIH07XG4gICAgICAgICAgc3VnZ2VzdGlvbnMucHVzaChuZXdTdWdnZXN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnRleHQsIHN1Z2dlc3Rpb25zIH07XG4gIH07XG5cbiAgaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogUHJvbVF1ZXJ5IHtcbiAgICByZXR1cm4gdG9Qcm9tTGlrZVF1ZXJ5KGxhYmVsQmFzZWRRdWVyeSk7XG4gIH1cblxuICBleHBvcnRUb0Fic3RyYWN0UXVlcnkocXVlcnk6IFByb21RdWVyeSk6IEFic3RyYWN0UXVlcnkge1xuICAgIGNvbnN0IHByb21RdWVyeSA9IHF1ZXJ5LmV4cHI7XG4gICAgaWYgKCFwcm9tUXVlcnkgfHwgcHJvbVF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgcmVmSWQ6IHF1ZXJ5LnJlZklkLCBsYWJlbE1hdGNoZXJzOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShwcm9tUXVlcnksIFByb21xbFN5bnRheCk7XG4gICAgY29uc3QgbGFiZWxNYXRjaGVyczogQWJzdHJhY3RMYWJlbE1hdGNoZXJbXSA9IGV4dHJhY3RMYWJlbE1hdGNoZXJzKHRva2Vucyk7XG4gICAgY29uc3QgbmFtZUxhYmVsVmFsdWUgPSBnZXROYW1lTGFiZWxWYWx1ZShwcm9tUXVlcnksIHRva2Vucyk7XG4gICAgaWYgKG5hbWVMYWJlbFZhbHVlICYmIG5hbWVMYWJlbFZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGxhYmVsTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdfX25hbWVfXycsXG4gICAgICAgIG9wZXJhdG9yOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuRXF1YWwsXG4gICAgICAgIHZhbHVlOiBuYW1lTGFiZWxWYWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZWZJZDogcXVlcnkucmVmSWQsXG4gICAgICBsYWJlbE1hdGNoZXJzLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBnZXRTZXJpZXMoc2VsZWN0b3I6IHN0cmluZywgd2l0aE5hbWU/OiBib29sZWFuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+IHtcbiAgICBpZiAodGhpcy5kYXRhc291cmNlLmxvb2t1cHNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaERlZmF1bHRTZXJpZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoU2VyaWVzTGFiZWxzKHNlbGVjdG9yLCB3aXRoTmFtZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFRPRE86IGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgZmV0Y2hMYWJlbFZhbHVlcyA9IGFzeW5jIChrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvbGFiZWwvJHt0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcoa2V5KX0vdmFsdWVzYDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgW10sIHBhcmFtcyk7XG4gIH07XG5cbiAgYXN5bmMgZ2V0TGFiZWxWYWx1ZXMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hMYWJlbFZhbHVlcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYWxsIGxhYmVsIGtleXNcbiAgICovXG4gIGFzeW5jIGZldGNoTGFiZWxzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS92MS9sYWJlbHMnO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICB0aGlzLmxhYmVsRmV0Y2hUcyA9IERhdGUubm93KCkudmFsdWVPZigpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgW10sIHBhcmFtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkge1xuICAgICAgdGhpcy5sYWJlbEtleXMgPSByZXMuc2xpY2UoKS5zb3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxhYmVscyBmb3IgYSBzZXJpZXMuIFRoaXMgaXMgY2FjaGVkIGJ5IGl0J3MgYXJncyBidXQgYWxzbyBieSB0aGUgZ2xvYmFsIHRpbWVSYW5nZSBjdXJyZW50bHkgc2VsZWN0ZWQgYXNcbiAgICogdGhleSBjYW4gY2hhbmdlIG92ZXIgcmVxdWVzdGVkIHRpbWUuXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSB3aXRoTmFtZVxuICAgKi9cbiAgZmV0Y2hTZXJpZXNMYWJlbHMgPSBhc3luYyAobmFtZTogc3RyaW5nLCB3aXRoTmFtZT86IGJvb2xlYW4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4gPT4ge1xuICAgIGNvbnN0IGludGVycG9sYXRlZE5hbWUgPSB0aGlzLmRhdGFzb3VyY2UuaW50ZXJwb2xhdGVTdHJpbmcobmFtZSk7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0VGltZVJhbmdlUGFyYW1zKCk7XG4gICAgY29uc3QgdXJsUGFyYW1zID0ge1xuICAgICAgLi4ucmFuZ2UsXG4gICAgICAnbWF0Y2hbXSc6IGludGVycG9sYXRlZE5hbWUsXG4gICAgfTtcbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9zZXJpZXNgO1xuICAgIC8vIENhY2hlIGtleSBpcyBhIGJpdCBkaWZmZXJlbnQgaGVyZS4gV2UgYWRkIHRoZSBgd2l0aE5hbWVgIHBhcmFtIGFuZCBhbHNvIHJvdW5kIHVwIHRvIGEgbWludXRlIHRoZSBpbnRlcnZhbHMuXG4gICAgLy8gVGhlIHJvdW5kaW5nIG1heSBzZWVtIHN0cmFuZ2UgYnV0IG1ha2VzIHJlbGF0aXZlIGludGVydmFscyBsaWtlIG5vdy0xaCBsZXNzIHByb25lIHRvIG5lZWQgc2VwYXJhdGUgcmVxdWVzdCBldmVyeVxuICAgIC8vIG1pbGxpc2Vjb25kIHdoaWxlIHN0aWxsIGFjdHVhbGx5IGdldHRpbmcgYWxsIHRoZSBrZXlzIGZvciB0aGUgY29ycmVjdCBpbnRlcnZhbC4gVGhpcyBzdGlsbCBjYW4gY3JlYXRlIHByb2JsZW1zXG4gICAgLy8gd2hlbiB1c2VyIGRvZXMgbm90IHRoZSBuZXdlc3QgdmFsdWVzIGZvciBhIG1pbnV0ZSBpZiBhbHJlYWR5IGNhY2hlZC5cbiAgICBjb25zdCBjYWNoZVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgJ21hdGNoW10nOiBpbnRlcnBvbGF0ZWROYW1lLFxuICAgICAgc3RhcnQ6IHJvdW5kU2VjVG9NaW4ocGFyc2VJbnQocmFuZ2Uuc3RhcnQsIDEwKSkudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogcm91bmRTZWNUb01pbihwYXJzZUludChyYW5nZS5lbmQsIDEwKSkudG9TdHJpbmcoKSxcbiAgICAgIHdpdGhOYW1lOiB3aXRoTmFtZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGAvYXBpL3YxL3Nlcmllcz8ke2NhY2hlUGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmxhYmVsc0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIFtdLCB1cmxQYXJhbXMpO1xuICAgICAgY29uc3QgeyB2YWx1ZXMgfSA9IHByb2Nlc3NMYWJlbHMoZGF0YSwgd2l0aE5hbWUpO1xuICAgICAgdmFsdWUgPSB2YWx1ZXM7XG4gICAgICB0aGlzLmxhYmVsc0NhY2hlLnNldChjYWNoZUtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoIHNlcmllcyBmb3IgYSBzZWxlY3Rvci4gVXNlIHRoaXMgZm9yIHJhdyByZXN1bHRzLiBVc2UgZmV0Y2hTZXJpZXNMYWJlbHMoKSB0byBnZXQgbGFiZWxzLlxuICAgKiBAcGFyYW0gbWF0Y2hcbiAgICovXG4gIGZldGNoU2VyaWVzID0gYXN5bmMgKG1hdGNoOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PFJlY29yZDxzdHJpbmcsIHN0cmluZz4+PiA9PiB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvc2VyaWVzJztcbiAgICBjb25zdCByYW5nZSA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7IC4uLnJhbmdlLCAnbWF0Y2hbXSc6IG1hdGNoIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdCh1cmwsIHt9LCBwYXJhbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGlzIG9ubHkgb25lIGFzIHdlIGFzc3VtZSB0aGlzIHdvbid0IGNoYW5nZSBvdmVyIHRpbWUuIFRoaXMgaXMgY2FjaGVkIGRpZmZlcmVudGx5IGZyb20gZmV0Y2hTZXJpZXNMYWJlbHNcbiAgICogYmVjYXVzZSB3ZSBjYW4gY2FjaGUgbW9yZSBhZ2dyZXNzaXZlbHkgaGVyZSBhbmQgYWxzbyB3ZSBkbyBub3Qgd2FudCB0byBpbnZhbGlkYXRlIHRoaXMgY2FjaGUgdGhlIHNhbWUgd2F5IGFzIGluXG4gICAqIGZldGNoU2VyaWVzTGFiZWxzLlxuICAgKi9cbiAgZmV0Y2hEZWZhdWx0U2VyaWVzID0gb25jZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoREVGQVVMVF9LRVlTLm1hcCgoa2V5KSA9PiB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoa2V5KSkpO1xuICAgIHJldHVybiBERUZBVUxUX0tFWVMucmVkdWNlKChhY2MsIGtleSwgaSkgPT4gKHsgLi4uYWNjLCBba2V5XTogdmFsdWVzW2ldIH0pLCB7fSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROYW1lTGFiZWxWYWx1ZShwcm9tUXVlcnk6IHN0cmluZywgdG9rZW5zOiBhbnkpOiBzdHJpbmcge1xuICBsZXQgbmFtZUxhYmVsVmFsdWUgPSAnJztcbiAgZm9yIChsZXQgcHJvcCBpbiB0b2tlbnMpIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1twcm9wXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVMYWJlbFZhbHVlID0gdG9rZW5zW3Byb3BdIGFzIHN0cmluZztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmFtZUxhYmVsVmFsdWU7XG59XG4iLCJpbXBvcnQgeyBQcm9tTWV0cmljc01ldGFkYXRhLCBQcm9tTWV0cmljc01ldGFkYXRhSXRlbSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgYWRkTGFiZWxUb1F1ZXJ5IH0gZnJvbSAnLi9hZGRfbGFiZWxfdG9fcXVlcnknO1xuaW1wb3J0IHsgU1VHR0VTVElPTlNfTElNSVQgfSBmcm9tICcuL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCB7IERhdGFRdWVyeSwgQWJzdHJhY3RRdWVyeSwgQWJzdHJhY3RMYWJlbE9wZXJhdG9yLCBBYnN0cmFjdExhYmVsTWF0Y2hlciB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgVG9rZW4gfSBmcm9tICdwcmlzbWpzJztcbmltcG9ydCB7IGludmVydCB9IGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBjb25zdCBwcm9jZXNzSGlzdG9ncmFtTWV0cmljcyA9IChtZXRyaWNzOiBzdHJpbmdbXSkgPT4ge1xuICBjb25zdCByZXN1bHRTZXQ6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKCdfYnVja2V0KCR8OiknKTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1ldHJpY3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgbWV0cmljID0gbWV0cmljc1tpbmRleF07XG4gICAgY29uc3QgaXNIaXN0b2dyYW1WYWx1ZSA9IHJlZ2V4cC50ZXN0KG1ldHJpYyk7XG4gICAgaWYgKGlzSGlzdG9ncmFtVmFsdWUpIHtcbiAgICAgIHJlc3VsdFNldC5hZGQobWV0cmljKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5yZXN1bHRTZXRdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NMYWJlbHMobGFiZWxzOiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9Piwgd2l0aE5hbWUgPSBmYWxzZSkge1xuICAvLyBGb3IgcHJvY2Vzc2luZyB3ZSBhcmUgZ29pbmcgdG8gdXNlIHNldHMgYXMgdGhleSBoYXZlIHNpZ25pZmljYW50bHkgYmV0dGVyIHBlcmZvcm1hbmNlIHRoYW4gYXJyYXlzXG4gIC8vIEFmdGVyIHdlIHByb2Nlc3MgbGFiZWxzLCB3ZSB3aWxsIGNvbnZlcnQgc2V0cyB0byBhcnJheXMgYW5kIHJldHVybiBvYmplY3Qgd2l0aCBsYWJlbCB2YWx1ZXMgaW4gYXJyYXlzXG4gIGNvbnN0IHZhbHVlU2V0OiB7IFtrZXk6IHN0cmluZ106IFNldDxzdHJpbmc+IH0gPSB7fTtcbiAgbGFiZWxzLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgY29uc3QgeyBfX25hbWVfXywgLi4ucmVzdCB9ID0gbGFiZWw7XG4gICAgaWYgKHdpdGhOYW1lKSB7XG4gICAgICB2YWx1ZVNldFsnX19uYW1lX18nXSA9IHZhbHVlU2V0WydfX25hbWVfXyddIHx8IG5ldyBTZXQoKTtcbiAgICAgIGlmICghdmFsdWVTZXRbJ19fbmFtZV9fJ10uaGFzKF9fbmFtZV9fKSkge1xuICAgICAgICB2YWx1ZVNldFsnX19uYW1lX18nXS5hZGQoX19uYW1lX18pO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHJlc3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKCF2YWx1ZVNldFtrZXldKSB7XG4gICAgICAgIHZhbHVlU2V0W2tleV0gPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbHVlU2V0W2tleV0uaGFzKHJlc3Rba2V5XSkpIHtcbiAgICAgICAgdmFsdWVTZXRba2V5XS5hZGQocmVzdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdmFsdWVBcnJheSB0aGF0IHdlIGFyZSBnb2luZyB0byByZXR1cm4gaW4gdGhlIG9iamVjdFxuICBjb25zdCB2YWx1ZUFycmF5OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIH0gPSB7fTtcbiAgbGltaXRTdWdnZXN0aW9ucyhPYmplY3Qua2V5cyh2YWx1ZVNldCkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHZhbHVlQXJyYXlba2V5XSA9IGxpbWl0U3VnZ2VzdGlvbnMoQXJyYXkuZnJvbSh2YWx1ZVNldFtrZXldKSk7XG4gIH0pO1xuXG4gIHJldHVybiB7IHZhbHVlczogdmFsdWVBcnJheSwga2V5czogT2JqZWN0LmtleXModmFsdWVBcnJheSkgfTtcbn1cblxuLy8gY29uc3QgY2xlYW5TZWxlY3RvclJlZ2V4cCA9IC9cXHsoXFx3Kz1cIlteXCJcXG5dKj9cIikoLFxcdys9XCJbXlwiXFxuXSo/XCIpKlxcfS87XG5leHBvcnQgY29uc3Qgc2VsZWN0b3JSZWdleHAgPSAvXFx7W159XSo/KFxcfXwkKS87XG5leHBvcnQgY29uc3QgbGFiZWxSZWdleHAgPSAvXFxiKFxcdyspKCE/PX4/KShcIlteXCJcXG5dKj9cIikvZztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNlbGVjdG9yKHF1ZXJ5OiBzdHJpbmcsIGN1cnNvck9mZnNldCA9IDEpOiB7IGxhYmVsS2V5czogYW55W107IHNlbGVjdG9yOiBzdHJpbmcgfSB7XG4gIGlmICghcXVlcnkubWF0Y2goc2VsZWN0b3JSZWdleHApKSB7XG4gICAgLy8gU3BlY2lhbCBtYXRjaGVyIGZvciBtZXRyaWNzXG4gICAgaWYgKHF1ZXJ5Lm1hdGNoKC9eW0EtWmEtejpdW1xcdzpdKiQvKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3I6IGB7X19uYW1lX189XCIke3F1ZXJ5fVwifWAsXG4gICAgICAgIGxhYmVsS2V5czogWydfX25hbWVfXyddLFxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBtdXN0IGNvbnRhaW4gYSBzZWxlY3RvcjogJyArIHF1ZXJ5KTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGluc2lkZSBhIHNlbGVjdG9yXG4gIGNvbnN0IHByZWZpeCA9IHF1ZXJ5LnNsaWNlKDAsIGN1cnNvck9mZnNldCk7XG4gIGNvbnN0IHByZWZpeE9wZW4gPSBwcmVmaXgubGFzdEluZGV4T2YoJ3snKTtcbiAgY29uc3QgcHJlZml4Q2xvc2UgPSBwcmVmaXgubGFzdEluZGV4T2YoJ30nKTtcbiAgaWYgKHByZWZpeE9wZW4gPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW5zaWRlIHNlbGVjdG9yLCBtaXNzaW5nIG9wZW4gYnJhY2U6ICcgKyBwcmVmaXgpO1xuICB9XG4gIGlmIChwcmVmaXhDbG9zZSA+IC0xICYmIHByZWZpeENsb3NlID4gcHJlZml4T3Blbikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGluc2lkZSBzZWxlY3RvciwgcHJldmlvdXMgc2VsZWN0b3IgYWxyZWFkeSBjbG9zZWQ6ICcgKyBwcmVmaXgpO1xuICB9XG4gIGNvbnN0IHN1ZmZpeCA9IHF1ZXJ5LnNsaWNlKGN1cnNvck9mZnNldCk7XG4gIGNvbnN0IHN1ZmZpeENsb3NlSW5kZXggPSBzdWZmaXguaW5kZXhPZignfScpO1xuICBjb25zdCBzdWZmaXhDbG9zZSA9IHN1ZmZpeENsb3NlSW5kZXggKyBjdXJzb3JPZmZzZXQ7XG4gIGNvbnN0IHN1ZmZpeE9wZW5JbmRleCA9IHN1ZmZpeC5pbmRleE9mKCd7Jyk7XG4gIGNvbnN0IHN1ZmZpeE9wZW4gPSBzdWZmaXhPcGVuSW5kZXggKyBjdXJzb3JPZmZzZXQ7XG4gIGlmIChzdWZmaXhDbG9zZSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbnNpZGUgc2VsZWN0b3IsIG1pc3NpbmcgY2xvc2luZyBicmFjZSBpbiBzdWZmaXg6ICcgKyBzdWZmaXgpO1xuICB9XG4gIGlmIChzdWZmaXhPcGVuSW5kZXggPiAtMSAmJiBzdWZmaXhPcGVuIDwgc3VmZml4Q2xvc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbnNpZGUgc2VsZWN0b3IsIG5leHQgc2VsZWN0b3Igb3BlbnMgYmVmb3JlIHRoaXMgb25lIGNsb3NlZDogJyArIHN1ZmZpeCk7XG4gIH1cblxuICAvLyBFeHRyYWN0IGNsZWFuIGxhYmVscyB0byBmb3JtIGNsZWFuIHNlbGVjdG9yLCBpbmNvbXBsZXRlIGxhYmVscyBhcmUgZHJvcHBlZFxuICBjb25zdCBzZWxlY3RvciA9IHF1ZXJ5LnNsaWNlKHByZWZpeE9wZW4sIHN1ZmZpeENsb3NlKTtcbiAgY29uc3QgbGFiZWxzOiB7IFtrZXk6IHN0cmluZ106IHsgdmFsdWU6IHN0cmluZzsgb3BlcmF0b3I6IHN0cmluZyB9IH0gPSB7fTtcbiAgc2VsZWN0b3IucmVwbGFjZShsYWJlbFJlZ2V4cCwgKGxhYmVsLCBrZXksIG9wZXJhdG9yLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGxhYmVsT2Zmc2V0ID0gcXVlcnkuaW5kZXhPZihsYWJlbCk7XG4gICAgY29uc3QgdmFsdWVTdGFydCA9IGxhYmVsT2Zmc2V0ICsga2V5Lmxlbmd0aCArIG9wZXJhdG9yLmxlbmd0aCArIDE7XG4gICAgY29uc3QgdmFsdWVFbmQgPSBsYWJlbE9mZnNldCArIGtleS5sZW5ndGggKyBvcGVyYXRvci5sZW5ndGggKyB2YWx1ZS5sZW5ndGggLSAxO1xuICAgIC8vIFNraXAgbGFiZWwgaWYgY3Vyc29yIGlzIGluIHZhbHVlXG4gICAgaWYgKGN1cnNvck9mZnNldCA8IHZhbHVlU3RhcnQgfHwgY3Vyc29yT2Zmc2V0ID4gdmFsdWVFbmQpIHtcbiAgICAgIGxhYmVsc1trZXldID0geyB2YWx1ZSwgb3BlcmF0b3IgfTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcblxuICAvLyBBZGQgbWV0cmljIGlmIHRoZXJlIGlzIG9uZSBiZWZvcmUgdGhlIHNlbGVjdG9yXG4gIGNvbnN0IG1ldHJpY1ByZWZpeCA9IHF1ZXJ5LnNsaWNlKDAsIHByZWZpeE9wZW4pO1xuICBjb25zdCBtZXRyaWNNYXRjaCA9IG1ldHJpY1ByZWZpeC5tYXRjaCgvW0EtWmEtejpdW1xcdzpdKiQvKTtcbiAgaWYgKG1ldHJpY01hdGNoKSB7XG4gICAgbGFiZWxzWydfX25hbWVfXyddID0geyB2YWx1ZTogYFwiJHttZXRyaWNNYXRjaFswXX1cImAsIG9wZXJhdG9yOiAnPScgfTtcbiAgfVxuXG4gIC8vIEJ1aWxkIHNvcnRlZCBzZWxlY3RvclxuICBjb25zdCBsYWJlbEtleXMgPSBPYmplY3Qua2V5cyhsYWJlbHMpLnNvcnQoKTtcbiAgY29uc3QgY2xlYW5TZWxlY3RvciA9IGxhYmVsS2V5cy5tYXAoKGtleSkgPT4gYCR7a2V5fSR7bGFiZWxzW2tleV0ub3BlcmF0b3J9JHtsYWJlbHNba2V5XS52YWx1ZX1gKS5qb2luKCcsJyk7XG5cbiAgY29uc3Qgc2VsZWN0b3JTdHJpbmcgPSBbJ3snLCBjbGVhblNlbGVjdG9yLCAnfSddLmpvaW4oJycpO1xuXG4gIHJldHVybiB7IGxhYmVsS2V5cywgc2VsZWN0b3I6IHNlbGVjdG9yU3RyaW5nIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRSZWNvcmRpbmdSdWxlcyhxdWVyeTogc3RyaW5nLCBtYXBwaW5nOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSk6IHN0cmluZyB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IE9iamVjdC5rZXlzKG1hcHBpbmcpO1xuICBjb25zdCBydWxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFxzfF4pKCR7cnVsZU5hbWVzLmpvaW4oJ3wnKX0pKFxcXFxzfCR8XFxcXCh8XFxcXFt8XFxcXHspYCwgJ2lnJyk7XG4gIGNvbnN0IGV4cGFuZGVkUXVlcnkgPSBxdWVyeS5yZXBsYWNlKHJ1bGVzUmVnZXgsIChtYXRjaCwgcHJlLCBuYW1lLCBwb3N0KSA9PiBgJHtwcmV9JHttYXBwaW5nW25hbWVdfSR7cG9zdH1gKTtcblxuICAvLyBTcGxpdCBxdWVyeSBpbnRvIGFycmF5LCBzbyBpZiBxdWVyeSB1c2VzIG9wZXJhdG9ycywgd2UgY2FuIGNvcnJlY3RseSBhZGQgbGFiZWxzIHRvIGVhY2ggaW5kaXZpZHVhbCBwYXJ0LlxuICBjb25zdCBxdWVyeUFycmF5ID0gZXhwYW5kZWRRdWVyeS5zcGxpdCgvKFxcK3xcXC18XFwqfFxcL3xcXCV8XFxeKS8pO1xuXG4gIC8vIFJlZ2V4IHRoYXQgbWF0Y2hlcyBvY2N1cnJlbmNlcyBvZiApeyBvciB9eyBvciBdeyB3aGljaCBpcyBhIHNpZ24gb2YgaW5jb3JyZWNseSBhZGRlZCBsYWJlbHMuXG4gIGNvbnN0IGludmFsaWRMYWJlbHNSZWdleCA9IC8oXFwpXFx7fFxcfVxce3xcXF1cXHspLztcbiAgY29uc3QgY29ycmVjdGx5RXhwYW5kZWRRdWVyeUFycmF5ID0gcXVlcnlBcnJheS5tYXAoKHF1ZXJ5KSA9PiB7XG4gICAgcmV0dXJuIGFkZExhYmVsc1RvRXhwcmVzc2lvbihxdWVyeSwgaW52YWxpZExhYmVsc1JlZ2V4KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvcnJlY3RseUV4cGFuZGVkUXVlcnlBcnJheS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gYWRkTGFiZWxzVG9FeHByZXNzaW9uKGV4cHI6IHN0cmluZywgaW52YWxpZExhYmVsc1JlZ2V4cDogUmVnRXhwKSB7XG4gIGNvbnN0IG1hdGNoID0gZXhwci5tYXRjaChpbnZhbGlkTGFiZWxzUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gU3BsaXQgcXVlcnkgaW50byAyIHBhcnRzIC0gYmVmb3JlIHRoZSBpbnZhbGlkTGFiZWxzUmVnZXggbWF0Y2ggYW5kIGFmdGVyLlxuICBjb25zdCBpbmRleE9mUmVnZXhNYXRjaCA9IG1hdGNoLmluZGV4ID8/IDA7XG4gIGNvbnN0IGV4cHJCZWZvcmVSZWdleE1hdGNoID0gZXhwci5zbGljZSgwLCBpbmRleE9mUmVnZXhNYXRjaCArIDEpO1xuICBjb25zdCBleHByQWZ0ZXJSZWdleE1hdGNoID0gZXhwci5zbGljZShpbmRleE9mUmVnZXhNYXRjaCArIDEpO1xuXG4gIC8vIENyZWF0ZSBhcnJheU9mTGFiZWxPYmplY3RzIHdpdGggbGFiZWwgb2JqZWN0cyB0aGF0IGhhdmUga2V5LCBvcGVyYXRvciBhbmQgdmFsdWUuXG4gIGNvbnN0IGFycmF5T2ZMYWJlbE9iamVjdHM6IEFycmF5PHsga2V5OiBzdHJpbmc7IG9wZXJhdG9yOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfT4gPSBbXTtcbiAgZXhwckFmdGVyUmVnZXhNYXRjaC5yZXBsYWNlKGxhYmVsUmVnZXhwLCAobGFiZWwsIGtleSwgb3BlcmF0b3IsIHZhbHVlKSA9PiB7XG4gICAgYXJyYXlPZkxhYmVsT2JqZWN0cy5wdXNoKHsga2V5LCBvcGVyYXRvciwgdmFsdWUgfSk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcblxuICAvLyBMb29wIHRocm91Z2ggYWxsIGxhYmVsIG9iamVjdHMgYW5kIGFkZCB0aGVtIHRvIHF1ZXJ5LlxuICAvLyBBcyBhIHN0YXJ0aW5nIHBvaW50IHdlIGhhdmUgdmFsaWQgcXVlcnkgd2l0aG91dCB0aGUgbGFiZWxzLlxuICBsZXQgcmVzdWx0ID0gZXhwckJlZm9yZVJlZ2V4TWF0Y2g7XG4gIGFycmF5T2ZMYWJlbE9iamVjdHMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKG9iaikgPT4ge1xuICAgIC8vIFJlbW92ZSBleHRyYSBzZXQgb2YgcXVvdGVzIGZyb20gb2JqLnZhbHVlXG4gICAgY29uc3QgdmFsdWUgPSBvYmoudmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIHJlc3VsdCA9IGFkZExhYmVsVG9RdWVyeShyZXN1bHQsIG9iai5rZXksIHZhbHVlLCBvYmoub3BlcmF0b3IpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFkZHMgbWV0YWRhdGEgZm9yIHN5bnRoZXRpYyBtZXRyaWNzIGZvciB3aGljaCB0aGUgQVBJIGRvZXMgbm90IHByb3ZpZGUgbWV0YWRhdGEuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyYWZhbmEvZ3JhZmFuYS9pc3N1ZXMvMjIzMzcgZm9yIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIG1ldGFkYXRhIEhFTFAgYW5kIFRZUEUgbWV0YWRhdGEgZnJvbSAvYXBpL3YxL21ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhTdW1tYXJpZXNNZXRhZGF0YShtZXRhZGF0YTogeyBbbWV0cmljOiBzdHJpbmddOiBQcm9tTWV0cmljc01ldGFkYXRhSXRlbVtdIH0pOiBQcm9tTWV0cmljc01ldGFkYXRhIHtcbiAgaWYgKCFtZXRhZGF0YSkge1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfVxuICBjb25zdCBiYXNlTWV0YWRhdGE6IFByb21NZXRyaWNzTWV0YWRhdGEgPSB7fTtcbiAgY29uc3Qgc3VtbWFyeU1ldGFkYXRhOiBQcm9tTWV0cmljc01ldGFkYXRhID0ge307XG4gIGZvciAoY29uc3QgbWV0cmljIGluIG1ldGFkYXRhKSB7XG4gICAgLy8gTk9URTogYmFzZWQgb24gcHJvbWV0aGV1cy1kb2N1bWVudGF0aW9uLCB3ZSBjYW4gcmVjZWl2ZVxuICAgIC8vIG11bHRpcGxlIG1ldGFkYXRhLWVudHJpZXMgZm9yIHRoZSBnaXZlbiBtZXRyaWMsIGl0IHNlZW1zXG4gICAgLy8gaXQgaGFwcGVucyB3aGVuIHRoZSBzYW1lIG1ldHJpYyBpcyBvbiBtdWx0aXBsZSB0YXJnZXRzXG4gICAgLy8gYW5kIHRoZWlyIGhlbHAtdGV4dCBkaWZmZXJzXG4gICAgLy8gKGh0dHBzOi8vcHJvbWV0aGV1cy5pby9kb2NzL3Byb21ldGhldXMvbGF0ZXN0L3F1ZXJ5aW5nL2FwaS8jcXVlcnlpbmctbWV0cmljLW1ldGFkYXRhKVxuICAgIC8vIGZvciBub3cgd2UganVzdCB1c2UgdGhlIGZpcnN0IGVudHJ5LlxuICAgIGNvbnN0IGl0ZW0gPSBtZXRhZGF0YVttZXRyaWNdWzBdO1xuICAgIGJhc2VNZXRhZGF0YVttZXRyaWNdID0gaXRlbTtcblxuICAgIGlmIChpdGVtLnR5cGUgPT09ICdoaXN0b2dyYW0nKSB7XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9idWNrZXRgXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgQ3VtdWxhdGl2ZSBjb3VudGVycyBmb3IgdGhlIG9ic2VydmF0aW9uIGJ1Y2tldHMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X2NvdW50YF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYENvdW50IG9mIGV2ZW50cyB0aGF0IGhhdmUgYmVlbiBvYnNlcnZlZCBmb3IgdGhlIGhpc3RvZ3JhbSBtZXRyaWMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X3N1bWBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBUb3RhbCBzdW0gb2YgYWxsIG9ic2VydmVkIHZhbHVlcyBmb3IgdGhlIGhpc3RvZ3JhbSBtZXRyaWMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3N1bW1hcnknKSB7XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9jb3VudGBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBDb3VudCBvZiBldmVudHMgdGhhdCBoYXZlIGJlZW4gb2JzZXJ2ZWQgZm9yIHRoZSBiYXNlIG1ldHJpYyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fc3VtYF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYFRvdGFsIHN1bSBvZiBhbGwgb2JzZXJ2ZWQgdmFsdWVzIGZvciB0aGUgYmFzZSBtZXRyaWMgKCR7aXRlbS5oZWxwfSlgLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLy8gU3ludGhldGljIHNlcmllc1xuICBjb25zdCBzeW50aGV0aWNNZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSA9IHt9O1xuICBzeW50aGV0aWNNZXRhZGF0YVsnQUxFUlRTJ10gPSB7XG4gICAgdHlwZTogJ2NvdW50ZXInLFxuICAgIGhlbHA6ICdUaW1lIHNlcmllcyBzaG93aW5nIHBlbmRpbmcgYW5kIGZpcmluZyBhbGVydHMuIFRoZSBzYW1wbGUgdmFsdWUgaXMgc2V0IHRvIDEgYXMgbG9uZyBhcyB0aGUgYWxlcnQgaXMgaW4gdGhlIGluZGljYXRlZCBhY3RpdmUgKHBlbmRpbmcgb3IgZmlyaW5nKSBzdGF0ZS4nLFxuICB9O1xuXG4gIHJldHVybiB7IC4uLmJhc2VNZXRhZGF0YSwgLi4uc3VtbWFyeU1ldGFkYXRhLCAuLi5zeW50aGV0aWNNZXRhZGF0YSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRNc1RvTWluKG1pbGxpc2Vjb25kczogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHJvdW5kU2VjVG9NaW4obWlsbGlzZWNvbmRzIC8gMTAwMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFNlY1RvTWluKHNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW1pdFN1Z2dlc3Rpb25zKGl0ZW1zOiBzdHJpbmdbXSkge1xuICByZXR1cm4gaXRlbXMuc2xpY2UoMCwgU1VHR0VTVElPTlNfTElNSVQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTGltaXRJbmZvKGl0ZW1zOiBhbnlbXSB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gIHJldHVybiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPj0gU1VHR0VTVElPTlNfTElNSVQgPyBgLCBsaW1pdGVkIHRvIHRoZSBmaXJzdCAke1NVR0dFU1RJT05TX0xJTUlUfSByZWNlaXZlZCBpdGVtc2AgOiAnJztcbn1cblxuLy8gTk9URTogdGhlIGZvbGxvd2luZyAyIGV4cG9ydGVkIGZ1bmN0aW9ucyBhcmUgdmVyeSBzaW1pbGFyIHRvIHRoZSBwcm9tZXRoZXVzKkVzY2FwZVxuLy8gZnVuY3Rpb25zIGluIGRhdGFzb3VyY2UudHMsIGJ1dCB0aGV5IGFyZSBub3QgZXhhY3RseSB0aGUgc2FtZSBhbGdvcml0aG0sIGFuZCB3ZSBmb3VuZFxuLy8gbm8gd2F5IHRvIHJldXNlIG9uZSBpbiB0aGUgYW5vdGhlciBvciB2aWNlIHZlcnNhLlxuXG4vLyBQcm9tZXRoZXVzIHJlZ3VsYXItZXhwcmVzc2lvbnMgdXNlIHRoZSBSRTIgc3ludGF4IChodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3JlMi93aWtpL1N5bnRheCksXG4vLyBzbyBldmVyeSBjaGFyYWN0ZXIgdGhhdCBtYXRjaGVzIHNvbWV0aGluZyBpbiB0aGF0IGxpc3QgaGFzIHRvIGJlIGVzY2FwZWQuXG4vLyB0aGUgbGlzdCBvZiBtZXRhY2hhcmFjdGVycyBpczogKis/KCl8XFwuW117fV4kXG4vLyB3ZSBtYWtlIGEgamF2YXNjcmlwdCByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIHRob3NlIGNoYXJhY3RlcnM6XG5jb25zdCBSRTJfTUVUQUNIQVJBQ1RFUlMgPSAvWyorPygpfFxcXFwuXFxbXFxde31eJF0vZztcbmZ1bmN0aW9uIGVzY2FwZVByb21ldGhldXNSZWdleHAodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKFJFMl9NRVRBQ0hBUkFDVEVSUywgJ1xcXFwkJicpO1xufVxuXG4vLyBiYXNlZCBvbiB0aGUgb3Blbm1ldHJpY3MtZG9jdW1lbnRhdGlvbiwgdGhlIDMgc3ltYm9scyB3ZSBoYXZlIHRvIGhhbmRsZSBhcmU6XG4vLyAtIFxcbiAuLi4gdGhlIG5ld2xpbmUgY2hhcmFjdGVyXG4vLyAtIFxcICAuLi4gdGhlIGJhY2tzbGFzaCBjaGFyYWN0ZXJcbi8vIC0gXCIgIC4uLiB0aGUgZG91YmxlLXF1b3RlIGNoYXJhY3RlclxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IobGFiZWxWYWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGxhYmVsVmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlTGFiZWxWYWx1ZUluUmVnZXhTZWxlY3RvcihsYWJlbFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3Rvcihlc2NhcGVQcm9tZXRoZXVzUmVnZXhwKGxhYmVsVmFsdWUpKTtcbn1cblxuY29uc3QgRnJvbVByb21MaWtlTWFwOiBSZWNvcmQ8c3RyaW5nLCBBYnN0cmFjdExhYmVsT3BlcmF0b3I+ID0ge1xuICAnPSc6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5FcXVhbCxcbiAgJyE9JzogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLk5vdEVxdWFsLFxuICAnPX4nOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuRXF1YWxSZWdFeCxcbiAgJyF+JzogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLk5vdEVxdWFsUmVnRXgsXG59O1xuY29uc3QgVG9Qcm9tTGlrZU1hcDogUmVjb3JkPEFic3RyYWN0TGFiZWxPcGVyYXRvciwgc3RyaW5nPiA9IGludmVydChGcm9tUHJvbUxpa2VNYXApIGFzIFJlY29yZDxcbiAgQWJzdHJhY3RMYWJlbE9wZXJhdG9yLFxuICBzdHJpbmdcbj47XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1Byb21MaWtlRXhwcihsYWJlbEJhc2VkUXVlcnk6IEFic3RyYWN0UXVlcnkpOiBzdHJpbmcge1xuICBjb25zdCBleHByID0gbGFiZWxCYXNlZFF1ZXJ5LmxhYmVsTWF0Y2hlcnNcbiAgICAubWFwKChzZWxlY3RvcjogQWJzdHJhY3RMYWJlbE1hdGNoZXIpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gVG9Qcm9tTGlrZU1hcFtzZWxlY3Rvci5vcGVyYXRvcl07XG4gICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGAke3NlbGVjdG9yLm5hbWV9JHtvcGVyYXRvcn1cIiR7c2VsZWN0b3IudmFsdWV9XCJgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcigoZTogc3RyaW5nKSA9PiBlICE9PSAnJylcbiAgICAuam9pbignLCAnKTtcblxuICByZXR1cm4gZXhwciA/IGB7JHtleHByfX1gIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1Byb21MaWtlUXVlcnkobGFiZWxCYXNlZFF1ZXJ5OiBBYnN0cmFjdFF1ZXJ5KTogUHJvbUxpa2VRdWVyeSB7XG4gIHJldHVybiB7XG4gICAgcmVmSWQ6IGxhYmVsQmFzZWRRdWVyeS5yZWZJZCxcbiAgICBleHByOiB0b1Byb21MaWtlRXhwcihsYWJlbEJhc2VkUXVlcnkpLFxuICAgIHJhbmdlOiB0cnVlLFxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21MaWtlUXVlcnkgZXh0ZW5kcyBEYXRhUXVlcnkge1xuICBleHByOiBzdHJpbmc7XG4gIHJhbmdlOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdExhYmVsTWF0Y2hlcnModG9rZW5zOiBBcnJheTxzdHJpbmcgfCBUb2tlbj4pOiBBYnN0cmFjdExhYmVsTWF0Y2hlcltdIHtcbiAgY29uc3QgbGFiZWxNYXRjaGVyczogQWJzdHJhY3RMYWJlbE1hdGNoZXJbXSA9IFtdO1xuXG4gIGZvciAobGV0IHByb3AgaW4gdG9rZW5zKSB7XG4gICAgaWYgKHRva2Vuc1twcm9wXSBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICBsZXQgdG9rZW46IFRva2VuID0gdG9rZW5zW3Byb3BdIGFzIFRva2VuO1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdjb250ZXh0LWxhYmVscycpIHtcbiAgICAgICAgbGV0IGxhYmVsS2V5ID0gJyc7XG4gICAgICAgIGxldCBsYWJlbFZhbHVlID0gJyc7XG4gICAgICAgIGxldCBsYWJlbE9wZXJhdG9yID0gJyc7XG4gICAgICAgIGxldCBjb250ZW50VG9rZW5zOiBhbnlbXSA9IHRva2VuLmNvbnRlbnQgYXMgYW55W107XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnRUb2tlbiBpbiBjb250ZW50VG9rZW5zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0cjogc3RyaW5nO1xuICAgICAgICAgICAgY3VycmVudFN0ciA9IGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXSBhcyBzdHJpbmc7XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0ciA9PT0gJz0nIHx8IGN1cnJlbnRTdHIgPT09ICchPScgfHwgY3VycmVudFN0ciA9PT0gJz1+JyB8fCBjdXJyZW50U3RyID09PSAnIX4nKSB7XG4gICAgICAgICAgICAgIGxhYmVsT3BlcmF0b3IgPSBjdXJyZW50U3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnbGFiZWwta2V5JzpcbiAgICAgICAgICAgICAgICBsYWJlbEtleSA9IGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXS5jb250ZW50IGFzIHN0cmluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnbGFiZWwtdmFsdWUnOlxuICAgICAgICAgICAgICAgIGxhYmVsVmFsdWUgPSBjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0uY29udGVudCBhcyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgbGFiZWxWYWx1ZSA9IGxhYmVsVmFsdWUuc3Vic3RyaW5nKDEsIGxhYmVsVmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxDb21wYXJhdG9yID0gRnJvbVByb21MaWtlTWFwW2xhYmVsT3BlcmF0b3JdO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbENvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGxhYmVsTWF0Y2hlcnMucHVzaCh7IG5hbWU6IGxhYmVsS2V5LCBvcGVyYXRvcjogbGFiZWxDb21wYXJhdG9yLCB2YWx1ZTogbGFiZWxWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVsTWF0Y2hlcnM7XG59XG4iLCJpbXBvcnQgeyBjaGFpbiwgbWFwIGFzIF9tYXAsIHVuaXEgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgbGFzdFZhbHVlRnJvbSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTWV0cmljRmluZFZhbHVlLCBUaW1lUmFuZ2UgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5UmVxdWVzdCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0VGltZVNydiB9IGZyb20gJ2FwcC9mZWF0dXJlcy9kYXNoYm9hcmQvc2VydmljZXMvVGltZVNydic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkge1xuICByYW5nZTogVGltZVJhbmdlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2UsIHByaXZhdGUgcXVlcnk6IHN0cmluZykge1xuICAgIHRoaXMuZGF0YXNvdXJjZSA9IGRhdGFzb3VyY2U7XG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMucmFuZ2UgPSBnZXRUaW1lU3J2KCkudGltZVJhbmdlKCk7XG4gIH1cblxuICBwcm9jZXNzKCk6IFByb21pc2U8TWV0cmljRmluZFZhbHVlW10+IHtcbiAgICBjb25zdCBsYWJlbE5hbWVzUmVnZXggPSAvXmxhYmVsX25hbWVzXFwoXFwpXFxzKiQvO1xuICAgIGNvbnN0IGxhYmVsVmFsdWVzUmVnZXggPSAvXmxhYmVsX3ZhbHVlc1xcKCg/OiguKyksXFxzKik/KFthLXpBLVpfXVthLXpBLVowLTlfXSopXFwpXFxzKiQvO1xuICAgIGNvbnN0IG1ldHJpY05hbWVzUmVnZXggPSAvXm1ldHJpY3NcXCgoLispXFwpXFxzKiQvO1xuICAgIGNvbnN0IHF1ZXJ5UmVzdWx0UmVnZXggPSAvXnF1ZXJ5X3Jlc3VsdFxcKCguKylcXClcXHMqJC87XG4gICAgY29uc3QgbGFiZWxOYW1lc1F1ZXJ5ID0gdGhpcy5xdWVyeS5tYXRjaChsYWJlbE5hbWVzUmVnZXgpO1xuICAgIGlmIChsYWJlbE5hbWVzUXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsTmFtZXNRdWVyeSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsVmFsdWVzUXVlcnkgPSB0aGlzLnF1ZXJ5Lm1hdGNoKGxhYmVsVmFsdWVzUmVnZXgpO1xuICAgIGlmIChsYWJlbFZhbHVlc1F1ZXJ5KSB7XG4gICAgICBpZiAobGFiZWxWYWx1ZXNRdWVyeVsxXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFZhbHVlc1F1ZXJ5KGxhYmVsVmFsdWVzUXVlcnlbMl0sIGxhYmVsVmFsdWVzUXVlcnlbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxWYWx1ZXNRdWVyeShsYWJlbFZhbHVlc1F1ZXJ5WzJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZXRyaWNOYW1lc1F1ZXJ5ID0gdGhpcy5xdWVyeS5tYXRjaChtZXRyaWNOYW1lc1JlZ2V4KTtcbiAgICBpZiAobWV0cmljTmFtZXNRdWVyeSkge1xuICAgICAgcmV0dXJuIHRoaXMubWV0cmljTmFtZVF1ZXJ5KG1ldHJpY05hbWVzUXVlcnlbMV0pO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5UmVzdWx0UXVlcnkgPSB0aGlzLnF1ZXJ5Lm1hdGNoKHF1ZXJ5UmVzdWx0UmVnZXgpO1xuICAgIGlmIChxdWVyeVJlc3VsdFF1ZXJ5KSB7XG4gICAgICByZXR1cm4gbGFzdFZhbHVlRnJvbSh0aGlzLnF1ZXJ5UmVzdWx0UXVlcnkocXVlcnlSZXN1bHRRdWVyeVsxXSkpO1xuICAgIH1cblxuICAgIC8vIGlmIHF1ZXJ5IGNvbnRhaW5zIGZ1bGwgbWV0cmljIG5hbWUsIHJldHVybiBtZXRyaWMgbmFtZSBhbmQgbGFiZWwgbGlzdFxuICAgIHJldHVybiB0aGlzLm1ldHJpY05hbWVBbmRMYWJlbHNRdWVyeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIGxhYmVsTmFtZXNRdWVyeSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LnRvU3RyaW5nKCksXG4gICAgICBlbmQ6IGVuZC50b1N0cmluZygpLFxuICAgIH07XG5cbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9sYWJlbHNgO1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpLnRoZW4oKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICByZXR1cm4gX21hcChyZXN1bHQuZGF0YS5kYXRhLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogdmFsdWUgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgbGFiZWxWYWx1ZXNRdWVyeShsYWJlbDogc3RyaW5nLCBtZXRyaWM/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG5cbiAgICBsZXQgdXJsOiBzdHJpbmc7XG5cbiAgICBpZiAoIW1ldHJpYykge1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICAvLyByZXR1cm4gbGFiZWwgdmFsdWVzIGdsb2JhbGx5XG4gICAgICB1cmwgPSBgL2FwaS92MS9sYWJlbC8ke2xhYmVsfS92YWx1ZXNgO1xuXG4gICAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgICAgcmV0dXJuIF9tYXAocmVzdWx0LmRhdGEuZGF0YSwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHsgdGV4dDogdmFsdWUgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAnbWF0Y2hbXSc6IG1ldHJpYyxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LnRvU3RyaW5nKCksXG4gICAgICAgIGVuZDogZW5kLnRvU3RyaW5nKCksXG4gICAgICB9O1xuICAgICAgdXJsID0gYC9hcGkvdjEvc2VyaWVzYDtcblxuICAgICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5tZXRhZGF0YVJlcXVlc3QodXJsLCBwYXJhbXMpLnRoZW4oKHJlc3VsdDogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IF9sYWJlbHMgPSBfbWFwKHJlc3VsdC5kYXRhLmRhdGEsIChtZXRyaWMpID0+IHtcbiAgICAgICAgICByZXR1cm4gbWV0cmljW2xhYmVsXSB8fCAnJztcbiAgICAgICAgfSkuZmlsdGVyKChsYWJlbCkgPT4ge1xuICAgICAgICAgIHJldHVybiBsYWJlbCAhPT0gJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB1bmlxKF9sYWJlbHMpLm1hcCgobWV0cmljKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IG1ldHJpYyxcbiAgICAgICAgICAgIGV4cGFuZGFibGU6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBtZXRyaWNOYW1lUXVlcnkobWV0cmljRmlsdGVyUGF0dGVybjogc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UudG8sIHRydWUpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHN0YXJ0OiBzdGFydC50b1N0cmluZygpLFxuICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICB9O1xuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL2xhYmVsL19fbmFtZV9fL3ZhbHVlc2A7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBjaGFpbihyZXN1bHQuZGF0YS5kYXRhKVxuICAgICAgICAuZmlsdGVyKChtZXRyaWNOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IG5ldyBSZWdFeHAobWV0cmljRmlsdGVyUGF0dGVybik7XG4gICAgICAgICAgcmV0dXJuIHIudGVzdChtZXRyaWNOYW1lKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcCgobWF0Y2hlZE1ldHJpY05hbWUpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hlZE1ldHJpY05hbWUsXG4gICAgICAgICAgICBleHBhbmRhYmxlOiB0cnVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIC52YWx1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcXVlcnlSZXN1bHRRdWVyeShxdWVyeTogc3RyaW5nKSB7XG4gICAgY29uc3QgZW5kID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UudG8sIHRydWUpO1xuICAgIGNvbnN0IGluc3RhbnRRdWVyeTogUHJvbVF1ZXJ5UmVxdWVzdCA9IHsgZXhwcjogcXVlcnkgfSBhcyBQcm9tUXVlcnlSZXF1ZXN0O1xuICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UucGVyZm9ybUluc3RhbnRRdWVyeShpbnN0YW50UXVlcnksIGVuZCkucGlwZShcbiAgICAgIG1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgIHJldHVybiBfbWFwKHJlc3VsdC5kYXRhLmRhdGEucmVzdWx0LCAobWV0cmljRGF0YSkgPT4ge1xuICAgICAgICAgIGxldCB0ZXh0ID0gbWV0cmljRGF0YS5tZXRyaWMuX19uYW1lX18gfHwgJyc7XG4gICAgICAgICAgZGVsZXRlIG1ldHJpY0RhdGEubWV0cmljLl9fbmFtZV9fO1xuICAgICAgICAgIHRleHQgKz1cbiAgICAgICAgICAgICd7JyArXG4gICAgICAgICAgICBfbWFwKG1ldHJpY0RhdGEubWV0cmljLCAodiwgaykgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gayArICc9XCInICsgdiArICdcIic7XG4gICAgICAgICAgICB9KS5qb2luKCcsJykgK1xuICAgICAgICAgICAgJ30nO1xuICAgICAgICAgIHRleHQgKz0gJyAnICsgbWV0cmljRGF0YS52YWx1ZVsxXSArICcgJyArIG1ldHJpY0RhdGEudmFsdWVbMF0gKiAxMDAwO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBleHBhbmRhYmxlOiB0cnVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbWV0cmljTmFtZUFuZExhYmVsc1F1ZXJ5KHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPE1ldHJpY0ZpbmRWYWx1ZVtdPiB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UudG8sIHRydWUpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICdtYXRjaFtdJzogcXVlcnksXG4gICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogZW5kLnRvU3RyaW5nKCksXG4gICAgfTtcblxuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL3Nlcmllc2A7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBfbWFwKHJlc3VsdC5kYXRhLmRhdGEsIChtZXRyaWM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0ZXh0OiBzZWxmLmRhdGFzb3VyY2UuZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKG1ldHJpYyksXG4gICAgICAgICAgZXhwYW5kYWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBHcmFtbWFyIH0gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgeyBDb21wbGV0aW9uSXRlbSB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuLy8gV2hlbiBjaGFuZ2luZyBSQVRFX1JBTkdFUywgY2hlY2sgaWYgTG9raS9Mb2dRTCByYW5nZXMgc2hvdWxkIGJlIGNoYW5nZWQgdG9vXG4vLyBAc2VlIHB1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL2xva2kvbGFuZ3VhZ2VfcHJvdmlkZXIudHNcbmV4cG9ydCBjb25zdCBSQVRFX1JBTkdFUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAgeyBsYWJlbDogJyRfX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9faW50ZXJ2YWwnIH0sXG4gIHsgbGFiZWw6ICckX19yYXRlX2ludGVydmFsJywgc29ydFZhbHVlOiAnJF9fcmF0ZV9pbnRlcnZhbCcgfSxcbiAgeyBsYWJlbDogJyRfX3JhbmdlJywgc29ydFZhbHVlOiAnJF9fcmFuZ2UnIH0sXG4gIHsgbGFiZWw6ICcxbScsIHNvcnRWYWx1ZTogJzAwOjAxOjAwJyB9LFxuICB7IGxhYmVsOiAnNW0nLCBzb3J0VmFsdWU6ICcwMDowNTowMCcgfSxcbiAgeyBsYWJlbDogJzEwbScsIHNvcnRWYWx1ZTogJzAwOjEwOjAwJyB9LFxuICB7IGxhYmVsOiAnMzBtJywgc29ydFZhbHVlOiAnMDA6MzA6MDAnIH0sXG4gIHsgbGFiZWw6ICcxaCcsIHNvcnRWYWx1ZTogJzAxOjAwOjAwJyB9LFxuICB7IGxhYmVsOiAnMWQnLCBzb3J0VmFsdWU6ICcyNDowMDowMCcgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBPUEVSQVRPUlMgPSBbJ2J5JywgJ2dyb3VwX2xlZnQnLCAnZ3JvdXBfcmlnaHQnLCAnaWdub3JpbmcnLCAnb24nLCAnb2Zmc2V0JywgJ3dpdGhvdXQnXTtcbmV4cG9ydCBjb25zdCBMT0dJQ0FMX09QRVJBVE9SUyA9IFsnb3InLCAnYW5kJywgJ3VubGVzcyddO1xuXG5jb25zdCBUUklHT05PTUVUUklDX0ZVTkNUSU9OUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAge1xuICAgIGxhYmVsOiAnYWNvcycsXG4gICAgaW5zZXJ0VGV4dDogJ2Fjb3MnLFxuICAgIGRldGFpbDogJ2Fjb3ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmNjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhY29zaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2Fjb3NoJyxcbiAgICBkZXRhaWw6ICdhY29zaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyBjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhc2luJyxcbiAgICBpbnNlcnRUZXh0OiAnYXNpbicsXG4gICAgZGV0YWlsOiAnYXNpbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGFyY3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhc2luaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2FzaW5oJyxcbiAgICBkZXRhaWw6ICdhc2luaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGludmVyc2UgaHlwZXJib2xpYyBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXRhbicsXG4gICAgaW5zZXJ0VGV4dDogJ2F0YW4nLFxuICAgIGRldGFpbDogJ2F0YW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmN0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXRhbmgnLFxuICAgIGluc2VydFRleHQ6ICdhdGFuaCcsXG4gICAgZGV0YWlsOiAnYXRhbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBpbnZlcnNlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2NvcycsXG4gICAgaW5zZXJ0VGV4dDogJ2NvcycsXG4gICAgZGV0YWlsOiAnY29zKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgY29zaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY29zaCcsXG4gICAgaW5zZXJ0VGV4dDogJ2Nvc2gnLFxuICAgIGRldGFpbDogJ2Nvc2godiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3NpbicsXG4gICAgaW5zZXJ0VGV4dDogJ3NpbicsXG4gICAgZGV0YWlsOiAnc2luKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3NpbmgnLFxuICAgIGluc2VydFRleHQ6ICdzaW5oJyxcbiAgICBkZXRhaWw6ICdzaW5oKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndGFuJyxcbiAgICBpbnNlcnRUZXh0OiAndGFuJyxcbiAgICBkZXRhaWw6ICd0YW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSB0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndGFuaCcsXG4gICAgaW5zZXJ0VGV4dDogJ3RhbmgnLFxuICAgIGRldGFpbDogJ3RhbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuXTtcblxuY29uc3QgQUdHUkVHQVRJT05fT1BFUkFUT1JTOiBDb21wbGV0aW9uSXRlbVtdID0gW1xuICB7XG4gICAgbGFiZWw6ICdzdW0nLFxuICAgIGluc2VydFRleHQ6ICdzdW0nLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgc3VtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21pbicsXG4gICAgaW5zZXJ0VGV4dDogJ21pbicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtaW5pbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ21heCcsXG4gICAgaW5zZXJ0VGV4dDogJ21heCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NlbGVjdCBtYXhpbXVtIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2F2ZycsXG4gICAgaW5zZXJ0VGV4dDogJ2F2ZycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSB0aGUgYXZlcmFnZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdncm91cCcsXG4gICAgaW5zZXJ0VGV4dDogJ2dyb3VwJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQWxsIHZhbHVlcyBpbiB0aGUgcmVzdWx0aW5nIHZlY3RvciBhcmUgMScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3N0ZGRldicsXG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldicsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSBwb3B1bGF0aW9uIHN0YW5kYXJkIGRldmlhdGlvbiBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzdGR2YXInLFxuICAgIGluc2VydFRleHQ6ICdzdGR2YXInLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgcG9wdWxhdGlvbiBzdGFuZGFyZCB2YXJpYW5jZSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudCcsXG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50JyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ291bnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB2ZWN0b3InLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3VudF92YWx1ZXMnLFxuICAgIGluc2VydFRleHQ6ICdjb3VudF92YWx1ZXMnLFxuICAgIGRvY3VtZW50YXRpb246ICdDb3VudCBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB2YWx1ZScsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2JvdHRvbWsnLFxuICAgIGluc2VydFRleHQ6ICdib3R0b21rJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnU21hbGxlc3QgayBlbGVtZW50cyBieSBzYW1wbGUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICd0b3BrJyxcbiAgICBpbnNlcnRUZXh0OiAndG9waycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0xhcmdlc3QgayBlbGVtZW50cyBieSBzYW1wbGUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdxdWFudGlsZScsXG4gICAgaW5zZXJ0VGV4dDogJ3F1YW50aWxlJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIM+GLXF1YW50aWxlICgwIOKJpCDPhiDiiaQgMSkgb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBGVU5DVElPTlMgPSBbXG4gIC4uLkFHR1JFR0FUSU9OX09QRVJBVE9SUyxcbiAgLi4uVFJJR09OT01FVFJJQ19GVU5DVElPTlMsXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzJyxcbiAgICBsYWJlbDogJ2FicycsXG4gICAgZGV0YWlsOiAnYWJzKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgaW5wdXQgdmVjdG9yIHdpdGggYWxsIHNhbXBsZSB2YWx1ZXMgY29udmVydGVkIHRvIHRoZWlyIGFic29sdXRlIHZhbHVlLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzZW50JyxcbiAgICBsYWJlbDogJ2Fic2VudCcsXG4gICAgZGV0YWlsOiAnYWJzZW50KHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYW4gZW1wdHkgdmVjdG9yIGlmIHRoZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBhbnkgZWxlbWVudHMgYW5kIGEgMS1lbGVtZW50IHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAxIGlmIHRoZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBubyBlbGVtZW50cy4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsZXJ0aW5nIG9uIHdoZW4gbm8gdGltZSBzZXJpZXMgZXhpc3QgZm9yIGEgZ2l2ZW4gbWV0cmljIG5hbWUgYW5kIGxhYmVsIGNvbWJpbmF0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYWJzZW50X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdhYnNlbnRfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdhYnNlbnQodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgYW4gZW1wdHkgdmVjdG9yIGlmIHRoZSByYW5nZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBhbnkgZWxlbWVudHMgYW5kIGEgMS1lbGVtZW50IHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAxIGlmIHRoZSByYW5nZSB2ZWN0b3IgcGFzc2VkIHRvIGl0IGhhcyBubyBlbGVtZW50cy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NlaWwnLFxuICAgIGxhYmVsOiAnY2VpbCcsXG4gICAgZGV0YWlsOiAnY2VpbCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHVwIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjaGFuZ2VzJyxcbiAgICBsYWJlbDogJ2NoYW5nZXMnLFxuICAgIGRldGFpbDogJ2NoYW5nZXModiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIGlucHV0IHRpbWUgc2VyaWVzLCBgY2hhbmdlcyh2IHJhbmdlLXZlY3RvcilgIHJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBpdHMgdmFsdWUgaGFzIGNoYW5nZWQgd2l0aGluIHRoZSBwcm92aWRlZCB0aW1lIHJhbmdlIGFzIGFuIGluc3RhbnQgdmVjdG9yLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXAnLFxuICAgIGxhYmVsOiAnY2xhbXAnLFxuICAgIGRldGFpbDogJ2NsYW1wKHYgaW5zdGFudC12ZWN0b3IsIG1pbiBzY2FsYXIsIG1heCBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NsYW1wcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHRvIGhhdmUgYSBsb3dlciBsaW1pdCBvZiBgbWluYCBhbmQgYW4gdXBwZXIgbGltaXQgb2YgYG1heGAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjbGFtcF9tYXgnLFxuICAgIGxhYmVsOiAnY2xhbXBfbWF4JyxcbiAgICBkZXRhaWw6ICdjbGFtcF9tYXgodiBpbnN0YW50LXZlY3RvciwgbWF4IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDbGFtcHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCB0byBoYXZlIGFuIHVwcGVyIGxpbWl0IG9mIGBtYXhgLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXBfbWluJyxcbiAgICBsYWJlbDogJ2NsYW1wX21pbicsXG4gICAgZGV0YWlsOiAnY2xhbXBfbWluKHYgaW5zdGFudC12ZWN0b3IsIG1pbiBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2xhbXBzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gaGF2ZSBhIGxvd2VyIGxpbWl0IG9mIGBtaW5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfc2NhbGFyJyxcbiAgICBsYWJlbDogJ2NvdW50X3NjYWxhcicsXG4gICAgZGV0YWlsOiAnY291bnRfc2NhbGFyKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIHRpbWUgc2VyaWVzIHZlY3RvciBhcyBhIHNjYWxhci4gVGhpcyBpcyBpbiBjb250cmFzdCB0byB0aGUgYGNvdW50KClgIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLCB3aGljaCBhbHdheXMgcmV0dXJucyBhIHZlY3RvciAoYW4gZW1wdHkgb25lIGlmIHRoZSBpbnB1dCB2ZWN0b3IgaXMgZW1wdHkpIGFuZCBhbGxvd3MgZ3JvdXBpbmcgYnkgbGFiZWxzIHZpYSBhIGBieWAgY2xhdXNlLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGVnJyxcbiAgICBsYWJlbDogJ2RlZycsXG4gICAgZGV0YWlsOiAnZGVnKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzIGZvciBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5X29mX21vbnRoJyxcbiAgICBsYWJlbDogJ2RheV9vZl9tb250aCcsXG4gICAgZGV0YWlsOiAnZGF5X29mX21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgZGF5IG9mIHRoZSBtb250aCBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMSB0byAzMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RheV9vZl93ZWVrJyxcbiAgICBsYWJlbDogJ2RheV9vZl93ZWVrJyxcbiAgICBkZXRhaWw6ICdkYXlfb2Zfd2Vlayh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gNiwgd2hlcmUgMCBtZWFucyBTdW5kYXkgZXRjLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGF5c19pbl9tb250aCcsXG4gICAgbGFiZWw6ICdkYXlzX2luX21vbnRoJyxcbiAgICBkZXRhaWw6ICdkYXlzX2luX21vbnRoKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgbnVtYmVyIG9mIGRheXMgaW4gdGhlIG1vbnRoIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAyOCB0byAzMS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RlbHRhJyxcbiAgICBsYWJlbDogJ2RlbHRhJyxcbiAgICBkZXRhaWw6ICdkZWx0YSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCB2YWx1ZSBvZiBlYWNoIHRpbWUgc2VyaWVzIGVsZW1lbnQgaW4gYSByYW5nZSB2ZWN0b3IgYHZgLCByZXR1cm5pbmcgYW4gaW5zdGFudCB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gZGVsdGFzIGFuZCBlcXVpdmFsZW50IGxhYmVscy4gVGhlIGRlbHRhIGlzIGV4dHJhcG9sYXRlZCB0byBjb3ZlciB0aGUgZnVsbCB0aW1lIHJhbmdlIGFzIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UgdmVjdG9yIHNlbGVjdG9yLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBhIG5vbi1pbnRlZ2VyIHJlc3VsdCBldmVuIGlmIHRoZSBzYW1wbGUgdmFsdWVzIGFyZSBhbGwgaW50ZWdlcnMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkZXJpdicsXG4gICAgbGFiZWw6ICdkZXJpdicsXG4gICAgZGV0YWlsOiAnZGVyaXYodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgZGVyaXZhdGl2ZSBvZiB0aGUgdGltZSBzZXJpZXMgaW4gYSByYW5nZSB2ZWN0b3IgYHZgLCB1c2luZyBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkcm9wX2NvbW1vbl9sYWJlbHMnLFxuICAgIGxhYmVsOiAnZHJvcF9jb21tb25fbGFiZWxzJyxcbiAgICBkZXRhaWw6ICdkcm9wX2NvbW1vbl9sYWJlbHMoaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnRHJvcHMgYWxsIGxhYmVscyB0aGF0IGhhdmUgdGhlIHNhbWUgbmFtZSBhbmQgdmFsdWUgYWNyb3NzIGFsbCBzZXJpZXMgaW4gdGhlIGlucHV0IHZlY3Rvci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2V4cCcsXG4gICAgbGFiZWw6ICdleHAnLFxuICAgIGRldGFpbDogJ2V4cCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBleHBvbmVudGlhbCBmdW5jdGlvbiBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC5cXG5TcGVjaWFsIGNhc2VzIGFyZTpcXG4qIGBFeHAoK0luZikgPSArSW5mYCBcXG4qIGBFeHAoTmFOKSA9IE5hTmAnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2Zsb29yJyxcbiAgICBsYWJlbDogJ2Zsb29yJyxcbiAgICBkZXRhaWw6ICdmbG9vcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIGRvd24gdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsXG4gICAgbGFiZWw6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLFxuICAgIGRldGFpbDogJ2hpc3RvZ3JhbV9xdWFudGlsZSjPhiBmbG9hdCwgYiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgz4YtcXVhbnRpbGUgKDAg4omkIM+GIOKJpCAxKSBmcm9tIHRoZSBidWNrZXRzIGBiYCBvZiBhIGhpc3RvZ3JhbS4gVGhlIHNhbXBsZXMgaW4gYGJgIGFyZSB0aGUgY291bnRzIG9mIG9ic2VydmF0aW9ucyBpbiBlYWNoIGJ1Y2tldC4gRWFjaCBzYW1wbGUgbXVzdCBoYXZlIGEgbGFiZWwgYGxlYCB3aGVyZSB0aGUgbGFiZWwgdmFsdWUgZGVub3RlcyB0aGUgaW5jbHVzaXZlIHVwcGVyIGJvdW5kIG9mIHRoZSBidWNrZXQuIChTYW1wbGVzIHdpdGhvdXQgc3VjaCBhIGxhYmVsIGFyZSBzaWxlbnRseSBpZ25vcmVkLikgVGhlIGhpc3RvZ3JhbSBtZXRyaWMgdHlwZSBhdXRvbWF0aWNhbGx5IHByb3ZpZGVzIHRpbWUgc2VyaWVzIHdpdGggdGhlIGBfYnVja2V0YCBzdWZmaXggYW5kIHRoZSBhcHByb3ByaWF0ZSBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdob2x0X3dpbnRlcnMnLFxuICAgIGxhYmVsOiAnaG9sdF93aW50ZXJzJyxcbiAgICBkZXRhaWw6ICdob2x0X3dpbnRlcnModiByYW5nZS12ZWN0b3IsIHNmIHNjYWxhciwgdGYgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdQcm9kdWNlcyBhIHNtb290aGVkIHZhbHVlIGZvciB0aW1lIHNlcmllcyBiYXNlZCBvbiB0aGUgcmFuZ2UgaW4gYHZgLiBUaGUgbG93ZXIgdGhlIHNtb290aGluZyBmYWN0b3IgYHNmYCwgdGhlIG1vcmUgaW1wb3J0YW5jZSBpcyBnaXZlbiB0byBvbGQgZGF0YS4gVGhlIGhpZ2hlciB0aGUgdHJlbmQgZmFjdG9yIGB0ZmAsIHRoZSBtb3JlIHRyZW5kcyBpbiB0aGUgZGF0YSBpcyBjb25zaWRlcmVkLiBCb3RoIGBzZmAgYW5kIGB0ZmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdob3VyJyxcbiAgICBsYWJlbDogJ2hvdXInLFxuICAgIGRldGFpbDogJ2hvdXIodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSBob3VyIG9mIHRoZSBkYXkgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gMjMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpZGVsdGEnLFxuICAgIGxhYmVsOiAnaWRlbHRhJyxcbiAgICBkZXRhaWw6ICdpZGVsdGEodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFzdCB0d28gc2FtcGxlcyBpbiB0aGUgcmFuZ2UgdmVjdG9yIGB2YCwgcmV0dXJuaW5nIGFuIGluc3RhbnQgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGRlbHRhcyBhbmQgZXF1aXZhbGVudCBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpbmNyZWFzZScsXG4gICAgbGFiZWw6ICdpbmNyZWFzZScsXG4gICAgZGV0YWlsOiAnaW5jcmVhc2UodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGluY3JlYXNlIGluIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBCcmVha3MgaW4gbW9ub3RvbmljaXR5IChzdWNoIGFzIGNvdW50ZXIgcmVzZXRzIGR1ZSB0byB0YXJnZXQgcmVzdGFydHMpIGFyZSBhdXRvbWF0aWNhbGx5IGFkanVzdGVkIGZvci4gVGhlIGluY3JlYXNlIGlzIGV4dHJhcG9sYXRlZCB0byBjb3ZlciB0aGUgZnVsbCB0aW1lIHJhbmdlIGFzIHNwZWNpZmllZCBpbiB0aGUgcmFuZ2UgdmVjdG9yIHNlbGVjdG9yLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBhIG5vbi1pbnRlZ2VyIHJlc3VsdCBldmVuIGlmIGEgY291bnRlciBpbmNyZWFzZXMgb25seSBieSBpbnRlZ2VyIGluY3JlbWVudHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdpcmF0ZScsXG4gICAgbGFiZWw6ICdpcmF0ZScsXG4gICAgZGV0YWlsOiAnaXJhdGUodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgaW5zdGFudCByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBsYXN0IHR3byBkYXRhIHBvaW50cy4gQnJlYWtzIGluIG1vbm90b25pY2l0eSAoc3VjaCBhcyBjb3VudGVyIHJlc2V0cyBkdWUgdG8gdGFyZ2V0IHJlc3RhcnRzKSBhcmUgYXV0b21hdGljYWxseSBhZGp1c3RlZCBmb3IuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsYWJlbF9qb2luJyxcbiAgICBsYWJlbDogJ2xhYmVsX2pvaW4nLFxuICAgIGRldGFpbDpcbiAgICAgICdsYWJlbF9qb2luKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHNlcGFyYXRvciBzdHJpbmcsIHNyY19sYWJlbF8xIHN0cmluZywgc3JjX2xhYmVsXzIgc3RyaW5nLCAuLi4pJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0ZvciBlYWNoIHRpbWVzZXJpZXMgaW4gYHZgLCBqb2lucyBhbGwgdGhlIHZhbHVlcyBvZiBhbGwgdGhlIGBzcmNfbGFiZWxzYCB1c2luZyBgc2VwYXJhdG9yYCBhbmQgcmV0dXJucyB0aGUgdGltZXNlcmllcyB3aXRoIHRoZSBsYWJlbCBgZHN0X2xhYmVsYCBjb250YWluaW5nIHRoZSBqb2luZWQgdmFsdWUuIFRoZXJlIGNhbiBiZSBhbnkgbnVtYmVyIG9mIGBzcmNfbGFiZWxzYCBpbiB0aGlzIGZ1bmN0aW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFiZWxfcmVwbGFjZScsXG4gICAgbGFiZWw6ICdsYWJlbF9yZXBsYWNlJyxcbiAgICBkZXRhaWw6ICdsYWJlbF9yZXBsYWNlKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHJlcGxhY2VtZW50IHN0cmluZywgc3JjX2xhYmVsIHN0cmluZywgcmVnZXggc3RyaW5nKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIFwiRm9yIGVhY2ggdGltZXNlcmllcyBpbiBgdmAsIGBsYWJlbF9yZXBsYWNlKHYgaW5zdGFudC12ZWN0b3IsIGRzdF9sYWJlbCBzdHJpbmcsIHJlcGxhY2VtZW50IHN0cmluZywgc3JjX2xhYmVsIHN0cmluZywgcmVnZXggc3RyaW5nKWAgIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhgIGFnYWluc3QgdGhlIGxhYmVsIGBzcmNfbGFiZWxgLiAgSWYgaXQgbWF0Y2hlcywgdGhlbiB0aGUgdGltZXNlcmllcyBpcyByZXR1cm5lZCB3aXRoIHRoZSBsYWJlbCBgZHN0X2xhYmVsYCByZXBsYWNlZCBieSB0aGUgZXhwYW5zaW9uIG9mIGByZXBsYWNlbWVudGAuIGAkMWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgbWF0Y2hpbmcgc3ViZ3JvdXAsIGAkMmAgd2l0aCB0aGUgc2Vjb25kIGV0Yy4gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2Vzbid0IG1hdGNoIHRoZW4gdGhlIHRpbWVzZXJpZXMgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlwiLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xuJyxcbiAgICBsYWJlbDogJ2xuJyxcbiAgICBkZXRhaWw6ICdsbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC5cXG5TcGVjaWFsIGNhc2VzIGFyZTpcXG4gKiBgbG4oK0luZikgPSArSW5mYFxcbiAqIGBsbigwKSA9IC1JbmZgXFxuICogYGxuKHggPCAwKSA9IE5hTmBcXG4gKiBgbG4oTmFOKSA9IE5hTmAnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xvZzInLFxuICAgIGxhYmVsOiAnbG9nMicsXG4gICAgZGV0YWlsOiAnbG9nMih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBiaW5hcnkgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLiBUaGUgc3BlY2lhbCBjYXNlcyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbiBgbG5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbG9nMTAnLFxuICAgIGxhYmVsOiAnbG9nMTAnLFxuICAgIGRldGFpbDogJ2xvZzEwKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRlY2ltYWwgbG9nYXJpdGhtIGZvciBhbGwgZWxlbWVudHMgaW4gYHZgLiBUaGUgc3BlY2lhbCBjYXNlcyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbiBgbG5gLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWludXRlJyxcbiAgICBsYWJlbDogJ21pbnV0ZScsXG4gICAgZGV0YWlsOiAnbWludXRlKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JldHVybnMgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMCB0byA1OS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21vbnRoJyxcbiAgICBsYWJlbDogJ21vbnRoJyxcbiAgICBkZXRhaWw6ICdtb250aCh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBtb250aCBvZiB0aGUgeWVhciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMSB0byAxMiwgd2hlcmUgMSBtZWFucyBKYW51YXJ5IGV0Yy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3BpJyxcbiAgICBsYWJlbDogJ3BpJyxcbiAgICBkZXRhaWw6ICdwaSgpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyBwaScsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncHJlZGljdF9saW5lYXInLFxuICAgIGxhYmVsOiAncHJlZGljdF9saW5lYXInLFxuICAgIGRldGFpbDogJ3ByZWRpY3RfbGluZWFyKHYgcmFuZ2UtdmVjdG9yLCB0IHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUHJlZGljdHMgdGhlIHZhbHVlIG9mIHRpbWUgc2VyaWVzIGB0YCBzZWNvbmRzIGZyb20gbm93LCBiYXNlZCBvbiB0aGUgcmFuZ2UgdmVjdG9yIGB2YCwgdXNpbmcgc2ltcGxlIGxpbmVhciByZWdyZXNzaW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmFkJyxcbiAgICBsYWJlbDogJ3JhZCcsXG4gICAgZGV0YWlsOiAncmFkKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zIGZvciBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmF0ZScsXG4gICAgbGFiZWw6ICdyYXRlJyxcbiAgICBkZXRhaWw6ICdyYXRlKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIFwiQ2FsY3VsYXRlcyB0aGUgcGVyLXNlY29uZCBhdmVyYWdlIHJhdGUgb2YgaW5jcmVhc2Ugb2YgdGhlIHRpbWUgc2VyaWVzIGluIHRoZSByYW5nZSB2ZWN0b3IuIEJyZWFrcyBpbiBtb25vdG9uaWNpdHkgKHN1Y2ggYXMgY291bnRlciByZXNldHMgZHVlIHRvIHRhcmdldCByZXN0YXJ0cykgYXJlIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgZm9yLiBBbHNvLCB0aGUgY2FsY3VsYXRpb24gZXh0cmFwb2xhdGVzIHRvIHRoZSBlbmRzIG9mIHRoZSB0aW1lIHJhbmdlLCBhbGxvd2luZyBmb3IgbWlzc2VkIHNjcmFwZXMgb3IgaW1wZXJmZWN0IGFsaWdubWVudCBvZiBzY3JhcGUgY3ljbGVzIHdpdGggdGhlIHJhbmdlJ3MgdGltZSBwZXJpb2QuXCIsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncmVzZXRzJyxcbiAgICBsYWJlbDogJ3Jlc2V0cycsXG4gICAgZGV0YWlsOiAncmVzZXRzKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdGb3IgZWFjaCBpbnB1dCB0aW1lIHNlcmllcywgYHJlc2V0cyh2IHJhbmdlLXZlY3RvcilgIHJldHVybnMgdGhlIG51bWJlciBvZiBjb3VudGVyIHJlc2V0cyB3aXRoaW4gdGhlIHByb3ZpZGVkIHRpbWUgcmFuZ2UgYXMgYW4gaW5zdGFudCB2ZWN0b3IuIEFueSBkZWNyZWFzZSBpbiB0aGUgdmFsdWUgYmV0d2VlbiB0d28gY29uc2VjdXRpdmUgc2FtcGxlcyBpcyBpbnRlcnByZXRlZCBhcyBhIGNvdW50ZXIgcmVzZXQuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdyb3VuZCcsXG4gICAgbGFiZWw6ICdyb3VuZCcsXG4gICAgZGV0YWlsOiAncm91bmQodiBpbnN0YW50LXZlY3RvciwgdG9fbmVhcmVzdD0xIHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUm91bmRzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4gVGllcyBhcmUgcmVzb2x2ZWQgYnkgcm91bmRpbmcgdXAuIFRoZSBvcHRpb25hbCBgdG9fbmVhcmVzdGAgYXJndW1lbnQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIG5lYXJlc3QgbXVsdGlwbGUgdG8gd2hpY2ggdGhlIHNhbXBsZSB2YWx1ZXMgc2hvdWxkIGJlIHJvdW5kZWQuIFRoaXMgbXVsdGlwbGUgbWF5IGFsc28gYmUgYSBmcmFjdGlvbi4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NjYWxhcicsXG4gICAgbGFiZWw6ICdzY2FsYXInLFxuICAgIGRldGFpbDogJ3NjYWxhcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdHaXZlbiBhIHNpbmdsZS1lbGVtZW50IGlucHV0IHZlY3RvciwgYHNjYWxhcih2IGluc3RhbnQtdmVjdG9yKWAgcmV0dXJucyB0aGUgc2FtcGxlIHZhbHVlIG9mIHRoYXQgc2luZ2xlIGVsZW1lbnQgYXMgYSBzY2FsYXIuIElmIHRoZSBpbnB1dCB2ZWN0b3IgZG9lcyBub3QgaGF2ZSBleGFjdGx5IG9uZSBlbGVtZW50LCBgc2NhbGFyYCB3aWxsIHJldHVybiBgTmFOYC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NnbicsXG4gICAgbGFiZWw6ICdzZ24nLFxuICAgIGRldGFpbDogJ3Nnbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIGEgdmVjdG9yIHdpdGggYWxsIHNhbXBsZSB2YWx1ZXMgY29udmVydGVkIHRvIHRoZWlyIHNpZ24sIGRlZmluZWQgYXMgdGhpczogMSBpZiB2IGlzIHBvc2l0aXZlLCAtMSBpZiB2IGlzIG5lZ2F0aXZlIGFuZCAwIGlmIHYgaXMgZXF1YWwgdG8gemVyby4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NvcnQnLFxuICAgIGxhYmVsOiAnc29ydCcsXG4gICAgZGV0YWlsOiAnc29ydCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdmVjdG9yIGVsZW1lbnRzIHNvcnRlZCBieSB0aGVpciBzYW1wbGUgdmFsdWVzLCBpbiBhc2NlbmRpbmcgb3JkZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzb3J0X2Rlc2MnLFxuICAgIGxhYmVsOiAnc29ydF9kZXNjJyxcbiAgICBkZXRhaWw6ICdzb3J0X2Rlc2ModiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHZlY3RvciBlbGVtZW50cyBzb3J0ZWQgYnkgdGhlaXIgc2FtcGxlIHZhbHVlcywgaW4gZGVzY2VuZGluZyBvcmRlci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3NxcnQnLFxuICAgIGxhYmVsOiAnc3FydCcsXG4gICAgZGV0YWlsOiAnc3FydCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZXMgdGhlIHNxdWFyZSByb290IG9mIGFsbCBlbGVtZW50cyBpbiBgdmAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd0aW1lJyxcbiAgICBsYWJlbDogJ3RpbWUnLFxuICAgIGRldGFpbDogJ3RpbWUoKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgVVRDLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhY3R1YWxseSByZXR1cm4gdGhlIGN1cnJlbnQgdGltZSwgYnV0IHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBleHByZXNzaW9uIGlzIHRvIGJlIGV2YWx1YXRlZC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3RpbWVzdGFtcCcsXG4gICAgbGFiZWw6ICd0aW1lc3RhbXAnLFxuICAgIGRldGFpbDogJ3RpbWVzdGFtcCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSB0aW1lc3RhbXAgb2YgZWFjaCBvZiB0aGUgc2FtcGxlcyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGFzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgVVRDLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAndmVjdG9yJyxcbiAgICBsYWJlbDogJ3ZlY3RvcicsXG4gICAgZGV0YWlsOiAndmVjdG9yKHMgc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdGhlIHNjYWxhciBgc2AgYXMgYSB2ZWN0b3Igd2l0aCBubyBsYWJlbHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd5ZWFyJyxcbiAgICBsYWJlbDogJ3llYXInLFxuICAgIGRldGFpbDogJ3llYXIodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSB5ZWFyIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdhdmdfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2F2Z19vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2F2Z19vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBhdmVyYWdlIHZhbHVlIG9mIGFsbCBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21pbl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbWluX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnbWluX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIG1pbmltdW0gdmFsdWUgb2YgYWxsIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbWF4X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdtYXhfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdtYXhfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbWF4aW11bSB2YWx1ZSBvZiBhbGwgcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzdW1fb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3N1bV9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ3N1bV9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBzdW0gb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2NvdW50X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnY291bnRfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgY291bnQgb2YgYWxsIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncXVhbnRpbGVfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3F1YW50aWxlX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAncXVhbnRpbGVfb3Zlcl90aW1lKHNjYWxhciwgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSDPhi1xdWFudGlsZSAoMCDiiaQgz4Yg4omkIDEpIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkZGV2X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkZGV2X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3N0ZHZhcl9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnc3RkdmFyX292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnc3RkdmFyX292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIHBvcHVsYXRpb24gc3RhbmRhcmQgdmFyaWFuY2Ugb2YgdGhlIHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbGFzdF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2xhc3Rfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgbW9zdCByZWNlbnQgcG9pbnQgdmFsdWUgaW4gc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgUFJPTV9LRVlXT1JEUyA9IEZVTkNUSU9OUy5tYXAoKGtleXdvcmQpID0+IGtleXdvcmQubGFiZWwpO1xuXG5leHBvcnQgY29uc3QgcHJvbXFsR3JhbW1hcjogR3JhbW1hciA9IHtcbiAgY29tbWVudDoge1xuICAgIHBhdHRlcm46IC8jLiovLFxuICB9LFxuICAnY29udGV4dC1hZ2dyZWdhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKChieXx3aXRob3V0KVxccyopXFwoW14pXSpcXCkvLCAvLyBieSAoKVxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW14oKSxcXHNdW14sKV0qW14pLFxcc10qLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvWygpXS8sXG4gICAgfSxcbiAgfSxcbiAgJ2NvbnRleHQtbGFiZWxzJzoge1xuICAgIHBhdHRlcm46IC9cXHtbXn1dKig/PX0/KS8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgY29tbWVudDoge1xuICAgICAgICBwYXR0ZXJuOiAvIy4qLyxcbiAgICAgIH0sXG4gICAgICAnbGFiZWwta2V5Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvW2Etel9dXFx3Kig/PVxccyooPXwhPXw9fnwhfikpLyxcbiAgICAgICAgYWxpYXM6ICdhdHRyLW5hbWUnLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICB9LFxuICAgICAgJ2xhYmVsLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcLnxbXlxcXFxcIl0pKlwiLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBhbGlhczogJ2F0dHItdmFsdWUnLFxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvW3tdLyxcbiAgICB9LFxuICB9LFxuICBmdW5jdGlvbjogbmV3IFJlZ0V4cChgXFxcXGIoPzoke0ZVTkNUSU9OUy5tYXAoKGYpID0+IGYubGFiZWwpLmpvaW4oJ3wnKX0pKD89XFxcXHMqXFxcXCgpYCwgJ2knKSxcbiAgJ2NvbnRleHQtcmFuZ2UnOiBbXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcW1teXFxdXSooPz1dKS8sIC8vIFsxbV1cbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKG9mZnNldFxccyspXFx3Ky8sIC8vIG9mZnNldCAxbVxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncmFuZ2UtZHVyYXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcYlxcZCtbc21oZHd5XVxcYi9pLFxuICAgICAgICAgIGFsaWFzOiAnbnVtYmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbiAgaWRMaXN0OiB7XG4gICAgcGF0dGVybjogL1xcZCsoXFx8XFxkKykrLyxcbiAgICBhbGlhczogJ251bWJlcicsXG4gIH0sXG4gIG51bWJlcjogL1xcYi0/XFxkKygoXFwuXFxkKik/KFtlRV1bKy1dP1xcZCspPyk/XFxiLyxcbiAgb3BlcmF0b3I6IG5ldyBSZWdFeHAoYC9bLSsqLz0lXn5dfCYmP3xcXFxcfD9cXFxcfHwhPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT98XFxcXGIoPzoke09QRVJBVE9SUy5qb2luKCd8Jyl9KVxcXFxiYCwgJ2knKSxcbiAgcHVuY3R1YXRpb246IC9be307KClgLC5dLyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByb21xbEdyYW1tYXI7XG4iLCJpbXBvcnQgeyBzaXplIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFF1ZXJ5SGludCwgUXVlcnlGaXggfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi9kYXRhc291cmNlJztcblxuLyoqXG4gKiBOdW1iZXIgb2YgdGltZSBzZXJpZXMgcmVzdWx0cyBuZWVkZWQgYmVmb3JlIHN0YXJ0aW5nIHRvIHN1Z2dlc3Qgc3VtIGFnZ3JlZ2F0aW9uIGhpbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBTVU1fSElOVF9USFJFU0hPTERfQ09VTlQgPSAyMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFF1ZXJ5SGludHMocXVlcnk6IHN0cmluZywgc2VyaWVzPzogYW55W10sIGRhdGFzb3VyY2U/OiBQcm9tZXRoZXVzRGF0YXNvdXJjZSk6IFF1ZXJ5SGludFtdIHtcbiAgY29uc3QgaGludHMgPSBbXTtcblxuICAvLyAuLi5fYnVja2V0IG1ldHJpYyBuZWVkcyBhIGhpc3RvZ3JhbV9xdWFudGlsZSgpXG4gIGNvbnN0IGhpc3RvZ3JhbU1ldHJpYyA9IHF1ZXJ5LnRyaW0oKS5tYXRjaCgvXlxcdytfYnVja2V0JHxeXFx3K19idWNrZXR7Lip9JC8pO1xuICBpZiAoaGlzdG9ncmFtTWV0cmljKSB7XG4gICAgY29uc3QgbGFiZWwgPSAnU2VsZWN0ZWQgbWV0cmljIGhhcyBidWNrZXRzLic7XG4gICAgaGludHMucHVzaCh7XG4gICAgICB0eXBlOiAnSElTVE9HUkFNX1FVQU5USUxFJyxcbiAgICAgIGxhYmVsLFxuICAgICAgZml4OiB7XG4gICAgICAgIGxhYmVsOiAnQ29uc2lkZXIgY2FsY3VsYXRpbmcgYWdncmVnYXRlZCBxdWFudGlsZSBieSBhZGRpbmcgaGlzdG9ncmFtX3F1YW50aWxlKCkuJyxcbiAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogJ0FERF9ISVNUT0dSQU1fUVVBTlRJTEUnLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICB9LFxuICAgICAgfSBhcyBRdWVyeUZpeCxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBuZWVkIG9mIHJhdGUoKVxuICBpZiAocXVlcnkuaW5kZXhPZigncmF0ZSgnKSA9PT0gLTEgJiYgcXVlcnkuaW5kZXhPZignaW5jcmVhc2UoJykgPT09IC0xKSB7XG4gICAgLy8gVXNlIG1ldHJpYyBtZXRhZGF0YSBmb3IgZXhhY3QgdHlwZXNcbiAgICBjb25zdCBuYW1lTWF0Y2ggPSBxdWVyeS5tYXRjaCgvXFxiKFxcdytfKHRvdGFsfHN1bXxjb3VudCkpXFxiLyk7XG4gICAgbGV0IGNvdW50ZXJOYW1lTWV0cmljID0gbmFtZU1hdGNoID8gbmFtZU1hdGNoWzFdIDogJyc7XG4gICAgY29uc3QgbWV0cmljc01ldGFkYXRhID0gZGF0YXNvdXJjZT8ubGFuZ3VhZ2VQcm92aWRlcj8ubWV0cmljc01ldGFkYXRhID8/IHt9O1xuICAgIGNvbnN0IG1ldHJpY01ldGFkYXRhS2V5cyA9IE9iamVjdC5rZXlzKG1ldHJpY3NNZXRhZGF0YSk7XG4gICAgbGV0IGNlcnRhaW4gPSBmYWxzZTtcblxuICAgIGlmIChtZXRyaWNNZXRhZGF0YUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgY291bnRlck5hbWVNZXRyaWMgPVxuICAgICAgICBtZXRyaWNNZXRhZGF0YUtleXMuZmluZCgobWV0cmljTmFtZSkgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXJpbmcgZmlyc3QgdHlwZSBpbmZvcm1hdGlvbiwgY291bGQgYmUgbm9uLWRldGVybWluaXN0aWNcbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldHJpY3NNZXRhZGF0YVttZXRyaWNOYW1lXTtcbiAgICAgICAgICBpZiAobWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnY291bnRlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY1JlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke21ldHJpY05hbWV9XFxcXGJgKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5tYXRjaChtZXRyaWNSZWdleCkpIHtcbiAgICAgICAgICAgICAgY2VydGFpbiA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pID8/ICcnO1xuICAgIH1cblxuICAgIGlmIChjb3VudGVyTmFtZU1ldHJpYykge1xuICAgICAgLy8gRml4YWJsZVF1ZXJ5IGNvbnNpc3RzIG9mIG1ldHJpYyBuYW1lIGFuZCBvcHRpb25hbGx5IGxhYmVsLXZhbHVlIHBhaXJzLiBXZSBhcmUgbm90IG9mZmVyaW5nIGZpeCBmb3IgY29tcGxleCBxdWVyaWVzIHlldC5cbiAgICAgIGNvbnN0IGZpeGFibGVRdWVyeSA9IHF1ZXJ5LnRyaW0oKS5tYXRjaCgvXlxcdyskfF5cXHcrey4qfSQvKTtcbiAgICAgIGNvbnN0IHZlcmIgPSBjZXJ0YWluID8gJ2lzJyA6ICdsb29rcyBsaWtlJztcbiAgICAgIGxldCBsYWJlbCA9IGBTZWxlY3RlZCBtZXRyaWMgJHt2ZXJifSBhIGNvdW50ZXIuYDtcbiAgICAgIGxldCBmaXg6IFF1ZXJ5Rml4IHwgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZml4YWJsZVF1ZXJ5KSB7XG4gICAgICAgIGZpeCA9IHtcbiAgICAgICAgICBsYWJlbDogJ0NvbnNpZGVyIGNhbGN1bGF0aW5nIHJhdGUgb2YgY291bnRlciBieSBhZGRpbmcgcmF0ZSgpLicsXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiAnQUREX1JBVEUnLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsID0gYCR7bGFiZWx9IENvbnNpZGVyIGNhbGN1bGF0aW5nIHJhdGUgb2YgY291bnRlciBieSBhZGRpbmcgcmF0ZSgpLmA7XG4gICAgICB9XG5cbiAgICAgIGhpbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQVBQTFlfUkFURScsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmaXgsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmb3IgcmVjb3JkaW5nIHJ1bGVzIGV4cGFuc2lvblxuICBpZiAoZGF0YXNvdXJjZSAmJiBkYXRhc291cmNlLnJ1bGVNYXBwaW5ncykge1xuICAgIGNvbnN0IG1hcHBpbmcgPSBkYXRhc291cmNlLnJ1bGVNYXBwaW5ncztcbiAgICBjb25zdCBtYXBwaW5nRm9yUXVlcnkgPSBPYmplY3Qua2V5cyhtYXBwaW5nKS5yZWR1Y2UoKGFjYywgcnVsZU5hbWUpID0+IHtcbiAgICAgIGlmIChxdWVyeS5zZWFyY2gocnVsZU5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgW3J1bGVOYW1lXTogbWFwcGluZ1tydWxlTmFtZV0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBpZiAoc2l6ZShtYXBwaW5nRm9yUXVlcnkpID4gMCkge1xuICAgICAgY29uc3QgbGFiZWwgPSAnUXVlcnkgY29udGFpbnMgcmVjb3JkaW5nIHJ1bGVzLic7XG4gICAgICBoaW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0VYUEFORF9SVUxFUycsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmaXg6IHtcbiAgICAgICAgICBsYWJlbDogJ0V4cGFuZCBydWxlcycsXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiAnRVhQQU5EX1JVTEVTJyxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgbWFwcGluZzogbWFwcGluZ0ZvclF1ZXJ5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgYW55IGFzIFF1ZXJ5Rml4LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlcmllcyAmJiBzZXJpZXMubGVuZ3RoID49IFNVTV9ISU5UX1RIUkVTSE9MRF9DT1VOVCkge1xuICAgIGNvbnN0IHNpbXBsZU1ldHJpYyA9IHF1ZXJ5LnRyaW0oKS5tYXRjaCgvXlxcdyskLyk7XG4gICAgaWYgKHNpbXBsZU1ldHJpYykge1xuICAgICAgaGludHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdBRERfU1VNJyxcbiAgICAgICAgbGFiZWw6ICdNYW55IHRpbWUgc2VyaWVzIHJlc3VsdHMgcmV0dXJuZWQuJyxcbiAgICAgICAgZml4OiB7XG4gICAgICAgICAgbGFiZWw6ICdDb25zaWRlciBhZ2dyZWdhdGluZyB3aXRoIHN1bSgpLicsXG4gICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiAnQUREX1NVTScsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICBwcmV2ZW50U3VibWl0OiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgUXVlcnlGaXgsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0SGludHMoZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2UpOiBRdWVyeUhpbnRbXSB7XG4gIGNvbnN0IGhpbnRzID0gW107XG4gIC8vIEhpbnQgaWYgdXNpbmcgTG9raSBhcyBQcm9tZXRoZXVzIGRhdGEgc291cmNlXG4gIGlmIChkYXRhc291cmNlLmRpcmVjdFVybC5pbmNsdWRlcygnL2xva2knKSAmJiAhZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLm1ldHJpY3MubGVuZ3RoKSB7XG4gICAgaGludHMucHVzaCh7XG4gICAgICBsYWJlbDogYFVzaW5nIExva2kgYXMgYSBQcm9tZXRoZXVzIGRhdGEgc291cmNlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFlvdSBtdXN0IHVzZSB0aGUgTG9raSBkYXRhIHNvdXJjZSBmb3IgeW91ciBMb2tpIGluc3RhbmNlLmAsXG4gICAgICB0eXBlOiAnSU5GTycsXG4gICAgfSk7XG4gIH1cblxuICAvLyBIaW50IGZvciBiaWcgZGlzYWJsZWQgbG9va3Vwc1xuICBpZiAoZGF0YXNvdXJjZS5sb29rdXBzRGlzYWJsZWQpIHtcbiAgICBoaW50cy5wdXNoKHtcbiAgICAgIGxhYmVsOiBgTGFiZWxzIGFuZCBtZXRyaWNzIGxvb2t1cCB3YXMgZGlzYWJsZWQgaW4gZGF0YSBzb3VyY2Ugc2V0dGluZ3MuYCxcbiAgICAgIHR5cGU6ICdJTkZPJyxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBoaW50cztcbn1cbiIsImltcG9ydCB7IEZVTkNUSU9OUyB9IGZyb20gJy4uL3Byb21xbCc7XG5pbXBvcnQgeyBnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMgfSBmcm9tICcuL2FnZ3JlZ2F0aW9ucyc7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25EZWZpbml0aW9ucyB9IGZyb20gJy4vb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIH0gZnJvbSAnLi9zaGFyZWQvTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnlQYXR0ZXJuLCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgUHJvbVF1ZXJ5TW9kZWxsZXIgZXh0ZW5kcyBMb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKCkgPT4ge1xuICAgICAgY29uc3QgYWxsT3BlcmF0aW9ucyA9IFsuLi5nZXRPcGVyYXRpb25EZWZpbml0aW9ucygpLCAuLi5nZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMoKV07XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIGFsbE9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IEZVTkNUSU9OUy5maW5kKCh4KSA9PiB4Lmluc2VydFRleHQgPT09IG9wLmlkKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICBvcC5kb2N1bWVudGF0aW9uID0gZnVuYy5kb2N1bWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsT3BlcmF0aW9ucztcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhbXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICAgIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0UXVlcnlQYXR0ZXJucygpOiBQcm9tUXVlcnlQYXR0ZXJuW10ge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdSYXRlIHRoZW4gc3VtJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6ICdyYXRlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdzdW0nLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnUmF0ZSB0aGVuIHN1bSBieShsYWJlbCkgdGhlbiBhdmcnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ3JhdGUnLCBwYXJhbXM6IFsnJF9fcmF0ZV9pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogJ19fc3VtX2J5JywgcGFyYW1zOiBbJyddIH0sXG4gICAgICAgICAgeyBpZDogJ2F2ZycsIHBhcmFtczogW10gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdIaXN0b2dyYW0gcXVhbnRpbGUgb24gcmF0ZScsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiAncmF0ZScsIHBhcmFtczogWyckX19yYXRlX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiAnX19zdW1fYnknLCBwYXJhbXM6IFsnbGUnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLCBwYXJhbXM6IFswLjk1XSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0hpc3RvZ3JhbSBxdWFudGlsZSBvbiBpbmNyZWFzZSAnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ2luY3JlYXNlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdfX21heF9ieScsIHBhcmFtczogWydsZSddIH0sXG4gICAgICAgICAgeyBpZDogJ2hpc3RvZ3JhbV9xdWFudGlsZScsIHBhcmFtczogWzAuOTVdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIF07XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb21RdWVyeU1vZGVsbGVyID0gbmV3IFByb21RdWVyeU1vZGVsbGVyKCk7XG4iLCJpbXBvcnQgeyBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IgfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24sXG4gIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtLFxuICBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lLFxuICBnZXRSYW5nZVZlY3RvclBhcmFtRGVmLFxufSBmcm9tICcuL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LCBQcm9tT3BlcmF0aW9uSWQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uT3BlcmF0aW9ucygpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIHJldHVybiBbXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLlN1bSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLkF2ZyksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLk1pbiksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLk1heCksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb24oUHJvbU9wZXJhdGlvbklkLkNvdW50KSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShQcm9tT3BlcmF0aW9uSWQuVG9wSywge1xuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnSy12YWx1ZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzVdLFxuICAgIH0pLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFByb21PcGVyYXRpb25JZC5Cb3R0b21LLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdLLXZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbNV0sXG4gICAgfSksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0oUHJvbU9wZXJhdGlvbklkLkNvdW50VmFsdWVzLCB7XG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdJZGVudGlmaWVyJywgdHlwZTogJ3N0cmluZycgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJ2NvdW50J10sXG4gICAgfSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuU3VtT3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkF2Z092ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5NaW5PdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuTWF4T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkNvdW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLkxhc3RPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuUHJlc2VudE92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5BYnNlbnRPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuU3RkZGV2T3ZlclRpbWUpLFxuICBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKG5hbWU6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IG5hbWUsXG4gICAgbmFtZTogZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKSxcbiAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCldLFxuICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnXSxcbiAgICBhbHRlcm5hdGl2ZXNLZXk6ICdvdmVydGltZSBmdW5jdGlvbicsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgIHJlbmRlcmVyOiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcixcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmdcbikge1xuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnJF9faW50ZXJ2YWwnO1xuICByZXR1cm4gYCR7ZGVmLmlkfSgke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dKWA7XG59XG4iLCJpbXBvcnQgeyBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYgfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tT3BlcmF0aW9uSWQsIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciB9IGZyb20gJy4vc2hhcmVkL29wZXJhdGlvblV0aWxzJztcblxuZXhwb3J0IGNvbnN0IGJpbmFyeVNjYWxhckRlZnMgPSBbXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFkZGl0aW9uLFxuICAgIG5hbWU6ICdBZGQgc2NhbGFyJyxcbiAgICBzaWduOiAnKycsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLlN1YnRyYWN0aW9uLFxuICAgIG5hbWU6ICdTdWJ0cmFjdCBzY2FsYXInLFxuICAgIHNpZ246ICctJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTXVsdGlwbHlCeSxcbiAgICBuYW1lOiAnTXVsdGlwbHkgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnKicsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRpdmlkZUJ5LFxuICAgIG5hbWU6ICdEaXZpZGUgYnkgc2NhbGFyJyxcbiAgICBzaWduOiAnLycsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLk1vZHVsbyxcbiAgICBuYW1lOiAnTW9kdWxvIGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJyUnLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5FeHBvbmVudCxcbiAgICBuYW1lOiAnRXhwb25lbnQnLFxuICAgIHNpZ246ICdeJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRXF1YWxUbyxcbiAgICBuYW1lOiAnRXF1YWwgdG8nLFxuICAgIHNpZ246ICc9PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTm90RXF1YWxUbyxcbiAgICBuYW1lOiAnTm90IGVxdWFsIHRvJyxcbiAgICBzaWduOiAnIT0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkdyZWF0ZXJUaGFuLFxuICAgIG5hbWU6ICdHcmVhdGVyIHRoYW4nLFxuICAgIHNpZ246ICc+JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5MZXNzVGhhbixcbiAgICBuYW1lOiAnTGVzcyB0aGFuJyxcbiAgICBzaWduOiAnPCcsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuR3JlYXRlck9yRXF1YWwsXG4gICAgbmFtZTogJ0dyZWF0ZXIgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc+PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGVzc09yRXF1YWwsXG4gICAgbmFtZTogJ0xlc3Mgb3IgZXF1YWwgdG8nLFxuICAgIHNpZ246ICc8PScsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbl07XG5cbi8vIE5vdCBzdXJlIGFib3V0IHRoaXMgb25lLiBJdCBjb3VsZCBhbHNvIGJlIGEgbW9yZSBnZW5lcmljICdTaW1wbGUgbWF0aCBvcGVyYXRpb24nIHdoZXJlIHVzZXIgc3BlY2lmaWVzXG4vLyBib3RoIHRoZSBvcGVyYXRvciBhbmQgdGhlIG9wZXJhbmQgaW4gYSBzaW5nbGUgaW5wdXRcbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJPcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSA9IGJpbmFyeVNjYWxhckRlZnMubWFwKChvcERlZikgPT4ge1xuICBjb25zdCBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW10gPSBbeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XTtcbiAgY29uc3QgZGVmYXVsdFBhcmFtczogYW55W10gPSBbMl07XG4gIGlmIChvcERlZi5jb21wYXJpc29uKSB7XG4gICAgcGFyYW1zLnB1c2goe1xuICAgICAgbmFtZTogJ0Jvb2wnLFxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVzY3JpcHRpb246ICdJZiBjaGVja2VkIGNvbXBhcmlzb24gd2lsbCByZXR1cm4gMCBvciAxIGZvciB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gZmlsdGVyaW5nLicsXG4gICAgfSk7XG4gICAgZGVmYXVsdFBhcmFtcy5wdXNoKGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaWQ6IG9wRGVmLmlkLFxuICAgIG5hbWU6IG9wRGVmLm5hbWUsXG4gICAgcGFyYW1zLFxuICAgIGRlZmF1bHRQYXJhbXMsXG4gICAgYWx0ZXJuYXRpdmVzS2V5OiAnYmluYXJ5IHNjYWxhciBvcGVyYXRpb25zJyxcbiAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgIHJlbmRlcmVyOiBnZXRTaW1wbGVCaW5hcnlSZW5kZXJlcihvcERlZi5zaWduKSxcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRTaW1wbGVCaW5hcnlSZW5kZXJlcihvcGVyYXRvcjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaW5hcnlSZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICBsZXQgcGFyYW0gPSBtb2RlbC5wYXJhbXNbMF07XG4gICAgbGV0IGJvb2wgPSAnJztcbiAgICBpZiAobW9kZWwucGFyYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgYm9vbCA9IG1vZGVsLnBhcmFtc1sxXSA/ICcgYm9vbCcgOiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7aW5uZXJFeHByfSAke29wZXJhdG9yfSR7Ym9vbH0gJHtwYXJhbX1gO1xuICB9O1xufVxuIiwiaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgU2VsZWN0YWJsZVZhbHVlLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi8uLi9kYXRhc291cmNlJztcbmltcG9ydCB7IHByb21RdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vUHJvbVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4uL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcyB9IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWJlbFBhcmFtRWRpdG9yKHtcbiAgb25DaGFuZ2UsXG4gIGluZGV4LFxuICBvcGVyYXRpb25JbmRleCxcbiAgdmFsdWUsXG4gIHF1ZXJ5LFxuICBkYXRhc291cmNlLFxufTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPHtcbiAgICBvcHRpb25zPzogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPGFueT4+O1xuICAgIGlzTG9hZGluZz86IGJvb2xlYW47XG4gIH0+KHt9KTtcblxuICByZXR1cm4gKFxuICAgIDxTZWxlY3RcbiAgICAgIGlucHV0SWQ9e2dldE9wZXJhdGlvblBhcmFtSWQob3BlcmF0aW9uSW5kZXgsIGluZGV4KX1cbiAgICAgIG1lbnVTaG91bGRQb3J0YWxcbiAgICAgIGF1dG9Gb2N1cz17dmFsdWUgPT09ICcnID8gdHJ1ZSA6IHVuZGVmaW5lZH1cbiAgICAgIG9wZW5NZW51T25Gb2N1c1xuICAgICAgb25PcGVuTWVudT17YXN5bmMgKCkgPT4ge1xuICAgICAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGxvYWRHcm91cEJ5TGFiZWxzKHF1ZXJ5LCBkYXRhc291cmNlKTtcbiAgICAgICAgc2V0U3RhdGUoeyBvcHRpb25zLCBpc0xvYWRpbmc6IHVuZGVmaW5lZCB9KTtcbiAgICAgIH19XG4gICAgICBpc0xvYWRpbmc9e3N0YXRlLmlzTG9hZGluZ31cbiAgICAgIGFsbG93Q3VzdG9tVmFsdWVcbiAgICAgIG5vT3B0aW9uc01lc3NhZ2U9XCJObyBsYWJlbHMgZm91bmRcIlxuICAgICAgbG9hZGluZ01lc3NhZ2U9XCJMb2FkaW5nIGxhYmVsc1wiXG4gICAgICBvcHRpb25zPXtzdGF0ZS5vcHRpb25zfVxuICAgICAgdmFsdWU9e3RvT3B0aW9uKHZhbHVlIGFzIHN0cmluZyl9XG4gICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiBvbkNoYW5nZShpbmRleCwgdmFsdWUudmFsdWUhKX1cbiAgICAvPlxuICApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkR3JvdXBCeUxhYmVscyhcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeSxcbiAgZGF0YXNvdXJjZTogRGF0YVNvdXJjZUFwaVxuKTogUHJvbWlzZTxBcnJheTxTZWxlY3RhYmxlVmFsdWU8YW55Pj4+IHtcbiAgbGV0IGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSA9IHF1ZXJ5LmxhYmVscztcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgYm90aCBQcm9tZXRoZXVzIGFuZCBMb2tpIGFuZCB0aGlzIHRoZSBvbmx5IGRpZmZlcmVuY2VcbiAgaWYgKGRhdGFzb3VyY2UgaW5zdGFuY2VvZiBQcm9tZXRoZXVzRGF0YXNvdXJjZSkge1xuICAgIGxhYmVscyA9IFt7IGxhYmVsOiAnX19uYW1lX18nLCBvcDogJz0nLCB2YWx1ZTogcXVlcnkubWV0cmljIH0sIC4uLnF1ZXJ5LmxhYmVsc107XG4gIH1cblxuICBjb25zdCBleHByID0gcHJvbVF1ZXJ5TW9kZWxsZXIucmVuZGVyTGFiZWxzKGxhYmVscyk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhleHByKTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0KS5tYXAoKHgpID0+ICh7XG4gICAgbGFiZWw6IHgsXG4gICAgdmFsdWU6IHgsXG4gIH0pKTtcbn1cbiIsImltcG9ydCB7IExhYmVsUGFyYW1FZGl0b3IgfSBmcm9tICcuL2NvbXBvbmVudHMvTGFiZWxQYXJhbUVkaXRvcic7XG5pbXBvcnQge1xuICBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gIGZ1bmN0aW9uUmVuZGVyZXJSaWdodCxcbiAgZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZSxcbiAgZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZixcbiAgcmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zLFxuICByYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zLFxufSBmcm9tICcuL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5pbXBvcnQge1xuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgUXVlcnlXaXRoT3BlcmF0aW9ucyxcbiAgVmlzdWFsUXVlcnlNb2RlbGxlcixcbn0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbU9wZXJhdGlvbklkLCBQcm9tVmlzdWFsUXVlcnksIFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBiaW5hcnlTY2FsYXJPcGVyYXRpb25zIH0gZnJvbSAnLi9iaW5hcnlTY2FsYXJPcGVyYXRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wZXJhdGlvbkRlZmluaXRpb25zKCk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3QgbGlzdDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBbXG4gICAge1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5IaXN0b2dyYW1RdWFudGlsZSxcbiAgICAgIG5hbWU6ICdIaXN0b2dyYW0gcXVhbnRpbGUnLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnUXVhbnRpbGUnLCB0eXBlOiAnbnVtYmVyJywgb3B0aW9uczogWzAuOTksIDAuOTUsIDAuOSwgMC43NSwgMC41LCAwLjI1XSB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFswLjldLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiBmdW5jdGlvblJlbmRlcmVyTGVmdCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyLFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5MYWJlbFJlcGxhY2UsXG4gICAgICBuYW1lOiAnTGFiZWwgcmVwbGFjZScsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgeyBuYW1lOiAnRGVzdGluYXRpb24gbGFiZWwnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdSZXBsYWNlbWVudCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsgbmFtZTogJ1NvdXJjZSBsYWJlbCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIHsgbmFtZTogJ1JlZ2V4JywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgIF0sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnLCAnJDEnLCAnJywgJyguKiknXSxcbiAgICAgIHJlbmRlcmVyOiBmdW5jdGlvblJlbmRlcmVyUmlnaHQsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTG4sXG4gICAgICBuYW1lOiAnTG4nLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFtdLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiBmdW5jdGlvblJlbmRlcmVyTGVmdCxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyLFxuICAgIH0sXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuQ2hhbmdlcyksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuUmF0ZSwgdHJ1ZSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuSXJhdGUpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLkluY3JlYXNlLCB0cnVlKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5JZGVsdGEpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLkRlbHRhKSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkhvbHRXaW50ZXJzLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIGdldFJhbmdlVmVjdG9yUGFyYW1EZWYoKSxcbiAgICAgICAgeyBuYW1lOiAnU21vb3RoaW5nIEZhY3RvcicsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsgbmFtZTogJ1RyZW5kIEZhY3RvcicsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWyckX19pbnRlcnZhbCcsIDAuNSwgMC41XSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3JhbmdlIGZ1bmN0aW9uJyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiByYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICAgICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5QcmVkaWN0TGluZWFyLFxuICAgICAgcGFyYW1zOiBbZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpLCB7IG5hbWU6ICdTZWNvbmRzIGZyb20gbm93JywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyRfX2ludGVydmFsJywgNjBdLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAncmFuZ2UgZnVuY3Rpb24nLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlJhbmdlRnVuY3Rpb25zLFxuICAgICAgcmVuZGVyZXI6IHJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gICAgICBjaGFuZ2VUeXBlSGFuZGxlcjogb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbixcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlF1YW50aWxlT3ZlclRpbWUsXG4gICAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCksIHsgbmFtZTogJ1F1YW50aWxlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyRfX2ludGVydmFsJywgMC41XSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ292ZXJ0aW1lIGZ1bmN0aW9uJyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiByYW5nZVJlbmRlcmVyTGVmdFdpdGhQYXJhbXMsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IsXG4gICAgICBjaGFuZ2VUeXBlSGFuZGxlcjogb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbixcbiAgICB9KSxcbiAgICAuLi5iaW5hcnlTY2FsYXJPcGVyYXRpb25zLFxuICAgIHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTmVzdGVkUXVlcnksXG4gICAgICBuYW1lOiAnQmluYXJ5IG9wZXJhdGlvbiB3aXRoIHF1ZXJ5JyxcbiAgICAgIHBhcmFtczogW10sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5CaW5hcnlPcHMsXG4gICAgICByZW5kZXJlcjogKG1vZGVsLCBkZWYsIGlubmVyRXhwcikgPT4gaW5uZXJFeHByLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkTmVzdGVkUXVlcnlIYW5kbGVyLFxuICAgIH0sXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkFic2VudCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFjb3MsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkFjb3NoLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Bc2luLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Bc2luaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQXRhbixcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQXRhbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuQ2VpbCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkNsYW1wLFxuICAgICAgbmFtZTogJ0NsYW1wJyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7IG5hbWU6ICdNaW5pbXVtIFNjYWxhcicsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICAgIHsgbmFtZTogJ01heGltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMSwgMV0sXG4gICAgfSksXG5cbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkNsYW1wTWF4LFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnTWF4aW11bSBTY2FsYXInLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxXSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkNsYW1wTWluLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnTWluaW11bSBTY2FsYXInLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxXSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkNvcyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQ29zaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRGF5T2ZNb250aCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRGF5T2ZXZWVrLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRpbWUsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5EYXlzSW5Nb250aCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5EZWcgfSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuRGVyaXYpLFxuICAgIC8vXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkV4cCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuRmxvb3IgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkdyb3VwIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Ib3VyIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGFiZWxKb2luLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnRGVzdGluYXRpb24gTGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTZXBhcmF0b3InLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ1NvdXJjZSBMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJycsICcsJywgJyddLFxuICAgICAgcmVuZGVyZXI6IGxhYmVsSm9pblJlbmRlcmVyLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogbGFiZWxKb2luQWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuTG9nMTAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkxvZzIgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLk1pbnV0ZSB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuTW9udGggfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5QaSxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwpID0+IGAke21vZGVsLmlkfSgpYCxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlF1YW50aWxlLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxXSxcbiAgICAgIHJlbmRlcmVyOiBmdW5jdGlvblJlbmRlcmVyTGVmdCxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuUmFkIH0pLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLlJlc2V0cyksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Sb3VuZCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdUbyBOZWFyZXN0JywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNjYWxhciB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU2duIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TaW4sIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuU2luaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Tb3J0IH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Tb3J0RGVzYyB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU3FydCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU3RkZGV2IH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVGFuLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5UYW5oLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5UaW1lLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCkgPT4gYCR7bW9kZWwuaWR9KClgLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5UaW1lc3RhbXAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5WZWN0b3IsXG4gICAgICBwYXJhbXM6IFt7IG5hbWU6ICdWYWx1ZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCkgPT4gYCR7bW9kZWwuaWR9KCR7bW9kZWwucGFyYW1zWzBdfSlgLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5ZZWFyIH0pLFxuICBdO1xuXG4gIHJldHVybiBsaXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24oZGVmaW5pdGlvbjogUGFydGlhbDxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+KTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZpbml0aW9uLFxuICAgIGlkOiBkZWZpbml0aW9uLmlkISxcbiAgICBuYW1lOiBkZWZpbml0aW9uLm5hbWUgPz8gZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShkZWZpbml0aW9uLmlkISksXG4gICAgcGFyYW1zOiBkZWZpbml0aW9uLnBhcmFtcyA/PyBbXSxcbiAgICBkZWZhdWx0UGFyYW1zOiBkZWZpbml0aW9uLmRlZmF1bHRQYXJhbXMgPz8gW10sXG4gICAgY2F0ZWdvcnk6IGRlZmluaXRpb24uY2F0ZWdvcnkgPz8gUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgIHJlbmRlcmVyOiBkZWZpbml0aW9uLnJlbmRlcmVyID8/IChkZWZpbml0aW9uLnBhcmFtcyA/IGZ1bmN0aW9uUmVuZGVyZXJSaWdodCA6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0KSxcbiAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZpbml0aW9uLmFkZE9wZXJhdGlvbkhhbmRsZXIgPz8gZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYW5nZUZ1bmN0aW9uKG5hbWU6IHN0cmluZywgd2l0aFJhdGVJbnRlcnZhbCA9IGZhbHNlKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogbmFtZSxcbiAgICBuYW1lOiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpLFxuICAgIHBhcmFtczogW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYod2l0aFJhdGVJbnRlcnZhbCldLFxuICAgIGRlZmF1bHRQYXJhbXM6IFt3aXRoUmF0ZUludGVydmFsID8gJyRfX3JhdGVfaW50ZXJ2YWwnIDogJyRfX2ludGVydmFsJ10sXG4gICAgYWx0ZXJuYXRpdmVzS2V5OiAncmFuZ2UgZnVuY3Rpb24nLFxuICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICByZW5kZXJlcjogb3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIsXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICAgIGNoYW5nZVR5cGVIYW5kbGVyOiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uLFxuICB9O1xufVxuXG5mdW5jdGlvbiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uKFxuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgbmV3RGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZcbikge1xuICAvLyB2YWxpZGF0ZSBjdXJyZW50IHBhcmFtZXRlclxuICBpZiAob3BlcmF0aW9uLnBhcmFtc1swXSA9PT0gJyRfX3JhdGVfaW50ZXJ2YWwnICYmIG5ld0RlZi5kZWZhdWx0UGFyYW1zWzBdICE9PSAnJF9fcmF0ZV9pbnRlcnZhbCcpIHtcbiAgICBvcGVyYXRpb24ucGFyYW1zID0gbmV3RGVmLmRlZmF1bHRQYXJhbXM7XG4gIH0gZWxzZSBpZiAob3BlcmF0aW9uLnBhcmFtc1swXSA9PT0gJyRfX2ludGVydmFsJyAmJiBuZXdEZWYuZGVmYXVsdFBhcmFtc1swXSAhPT0gJyRfX2ludGVydmFsJykge1xuICAgIG9wZXJhdGlvbi5wYXJhbXMgPSBuZXdEZWYuZGVmYXVsdFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiBvcGVyYXRpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcihcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pIHtcbiAgbGV0IHJhbmdlVmVjdG9yID0gKG1vZGVsLnBhcmFtcyA/PyBbXSlbMF0gPz8gJzVtJztcbiAgcmV0dXJuIGAke2RlZi5pZH0oJHtpbm5lckV4cHJ9WyR7cmFuZ2VWZWN0b3J9XSlgO1xufVxuXG4vKipcbiAqIFNpbmNlIHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBvcGVyYXRpb24gd2l0aCByYW5nZSB2ZWN0b3IgdGhpcyB3aWxsIHJlcGxhY2UgdGhlIGN1cnJlbnQgb25lIChpZiBvbmUgd2FzIGFkZGVkIClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcihcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnksXG4gIG1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyXG4pIHtcbiAgY29uc3QgbmV3T3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBwYXJhbXM6IGRlZi5kZWZhdWx0UGFyYW1zLFxuICB9O1xuXG4gIGlmIChxdWVyeS5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAvLyBJZiBvcGVyYXRpb24gZXhpc3RzIGl0IGhhcyB0byBiZSBpbiB0aGUgcmVnaXN0cnkgc28gbm8gcG9pbnQgdG8gY2hlY2sgaWYgaXQgd2FzIGZvdW5kXG4gICAgY29uc3QgZmlyc3RPcCA9IG1vZGVsbGVyLmdldE9wZXJhdGlvbkRlZihxdWVyeS5vcGVyYXRpb25zWzBdLmlkKSE7XG5cbiAgICBpZiAoZmlyc3RPcC5hZGRPcGVyYXRpb25IYW5kbGVyID09PSBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICBvcGVyYXRpb25zOiBbbmV3T3BlcmF0aW9uLCAuLi5xdWVyeS5vcGVyYXRpb25zLnNsaWNlKDEpXSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5xdWVyeSxcbiAgICBvcGVyYXRpb25zOiBbbmV3T3BlcmF0aW9uLCAuLi5xdWVyeS5vcGVyYXRpb25zXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTmVzdGVkUXVlcnlIYW5kbGVyKGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5KTogUHJvbVZpc3VhbFF1ZXJ5IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5xdWVyeSxcbiAgICBiaW5hcnlRdWVyaWVzOiBbXG4gICAgICAuLi4ocXVlcnkuYmluYXJ5UXVlcmllcyA/PyBbXSksXG4gICAgICB7XG4gICAgICAgIG9wZXJhdG9yOiAnLycsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xufVxuXG5mdW5jdGlvbiBsYWJlbEpvaW5SZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBtb2RlbC5wYXJhbXNbMV0gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgJ1RoZSBzZXBhcmF0b3IgbXVzdCBiZSBhIHN0cmluZyc7XG4gIH1cbiAgY29uc3Qgc2VwYXJhdG9yID0gYFwiJHttb2RlbC5wYXJhbXNbMV19XCJgO1xuICByZXR1cm4gYCR7bW9kZWwuaWR9KCR7aW5uZXJFeHByfSwgXCIke21vZGVsLnBhcmFtc1swXX1cIiwgJHtzZXBhcmF0b3J9LCBcIiR7bW9kZWwucGFyYW1zLnNsaWNlKDIpLmpvaW4oc2VwYXJhdG9yKX1cIilgO1xufVxuXG5mdW5jdGlvbiBsYWJlbEpvaW5BZGRPcGVyYXRpb25IYW5kbGVyPFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPihkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgcXVlcnk6IFQpIHtcbiAgY29uc3QgbmV3T3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBwYXJhbXM6IGRlZi5kZWZhdWx0UGFyYW1zLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgb3BlcmF0aW9uczogWy4uLnF1ZXJ5Lm9wZXJhdGlvbnMsIG5ld09wZXJhdGlvbl0sXG4gIH07XG59XG4iLCJpbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdsZXplci1wcm9tcWwnO1xuaW1wb3J0IHsgU3ludGF4Tm9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeSwgUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBiaW5hcnlTY2FsYXJEZWZzIH0gZnJvbSAnLi9iaW5hcnlTY2FsYXJPcGVyYXRpb25zJztcbmltcG9ydCB7XG4gIEVycm9yTmFtZSxcbiAgZ2V0QWxsQnlUeXBlLFxuICBnZXRMZWZ0TW9zdENoaWxkLFxuICBnZXRTdHJpbmcsXG4gIG1ha2VCaW5PcCxcbiAgbWFrZUVycm9yLFxuICByZXBsYWNlVmFyaWFibGVzLFxufSBmcm9tICcuL3NoYXJlZC9wYXJzaW5nVXRpbHMnO1xuXG4vKipcbiAqIFBhcnNlcyBhIFByb21RTCBxdWVyeSBpbnRvIGEgdmlzdWFsIHF1ZXJ5IG1vZGVsLlxuICpcbiAqIEl0IHRyYXZlcnNlcyB0aGUgdHJlZSBhbmQgdXNlcyBzb3J0IG9mIHN0YXRlIG1hY2hpbmUgdG8gdXBkYXRlIHRoZSBxdWVyeSBtb2RlbC4gVGhlIHF1ZXJ5IG1vZGVsIGlzIG1vZGlmaWVkXG4gKiBkdXJpbmcgdGhlIHRyYXZlcnNhbCBhbmQgc2VudCB0byBlYWNoIGhhbmRsZXIgYXMgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gZXhwclxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcoZXhwcjogc3RyaW5nKTogQ29udGV4dCB7XG4gIGNvbnN0IHJlcGxhY2VkRXhwciA9IHJlcGxhY2VWYXJpYWJsZXMoZXhwcik7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyc2UocmVwbGFjZWRFeHByKTtcbiAgY29uc3Qgbm9kZSA9IHRyZWUudG9wTm9kZTtcblxuICAvLyBUaGlzIHdpbGwgYmUgbW9kaWZpZWQgaW4gdGhlIGhhbmRsZXJzLlxuICBjb25zdCB2aXNRdWVyeTogUHJvbVZpc3VhbFF1ZXJ5ID0ge1xuICAgIG1ldHJpYzogJycsXG4gICAgbGFiZWxzOiBbXSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgfTtcbiAgY29uc3QgY29udGV4dDogQ29udGV4dCA9IHtcbiAgICBxdWVyeTogdmlzUXVlcnksXG4gICAgZXJyb3JzOiBbXSxcbiAgfTtcblxuICB0cnkge1xuICAgIGhhbmRsZUV4cHJlc3Npb24ocmVwbGFjZWRFeHByLCBub2RlLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gTm90IGlkZWFsIHRvIGxvZyBpdCBoZXJlLCBidXQgb3RoZXJ3aXNlIHdlIHdvdWxkIGxvc2UgdGhlIHN0YWNrIHRyYWNlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBjb250ZXh0LmVycm9ycy5wdXNoKHtcbiAgICAgIHRleHQ6IGVyci5tZXNzYWdlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBlbXB0eSBxdWVyeSwgd2Ugd2FudCB0byByZXNldCBlcnJvcnNcbiAgaWYgKGlzRW1wdHlRdWVyeShjb250ZXh0LnF1ZXJ5KSkge1xuICAgIGNvbnRleHQuZXJyb3JzID0gW107XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmludGVyZmFjZSBQYXJzaW5nRXJyb3Ige1xuICB0ZXh0OiBzdHJpbmc7XG4gIGZyb20/OiBudW1iZXI7XG4gIHRvPzogbnVtYmVyO1xuICBwYXJlbnRUeXBlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQ29udGV4dCB7XG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnk7XG4gIGVycm9yczogUGFyc2luZ0Vycm9yW107XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgZGVmYXVsdCBzdGF0ZS4gSXQgd2lsbCB0cmF2ZXJzZSB0aGUgdHJlZSBhbmQgY2FsbCB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlciBmb3IgZWFjaCBub2RlLiBUaGUgbm9kZVxuICogaGFuZGxlZCBoZXJlIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG5lZWQgdG8gYmUgb2YgdHlwZSA9PSBFeHByLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXhwcmVzc2lvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgIGNhc2UgJ01ldHJpY0lkZW50aWZpZXInOiB7XG4gICAgICAvLyBFeHBlY3RhdGlvbiBpcyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIG9mIHRob3NlIHBlciBxdWVyeS5cbiAgICAgIHZpc1F1ZXJ5Lm1ldHJpYyA9IGdldFN0cmluZyhleHByLCBub2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0xhYmVsTWF0Y2hlcic6IHtcbiAgICAgIC8vIFNhbWUgYXMgTWV0cmljSWRlbnRpZmllciBzaG91bGQgYmUganVzdCBvbmUgcGVyIHF1ZXJ5LlxuICAgICAgdmlzUXVlcnkubGFiZWxzLnB1c2goZ2V0TGFiZWwoZXhwciwgbm9kZSkpO1xuICAgICAgY29uc3QgZXJyID0gbm9kZS5nZXRDaGlsZChFcnJvck5hbWUpO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG1ha2VFcnJvcihleHByLCBlcnIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0Z1bmN0aW9uQ2FsbCc6IHtcbiAgICAgIGhhbmRsZUZ1bmN0aW9uKGV4cHIsIG5vZGUsIGNvbnRleHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnQWdncmVnYXRlRXhwcic6IHtcbiAgICAgIGhhbmRsZUFnZ3JlZ2F0aW9uKGV4cHIsIG5vZGUsIGNvbnRleHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnQmluYXJ5RXhwcic6IHtcbiAgICAgIGhhbmRsZUJpbmFyeShleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgRXJyb3JOYW1lOiB7XG4gICAgICBpZiAoaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3Iobm9kZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG1ha2VFcnJvcihleHByLCBub2RlKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAobm9kZS5uYW1lID09PSAnUGFyZW5FeHByJykge1xuICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHBhcmVudGhlc2lzIGluIHRoZSBxdWVyeSB0byBncm91cCBleHByZXNzaW9ucy4gV2UganVzdCByZXBvcnQgZXJyb3IgYnV0IGdvIG9uIHdpdGggdGhlXG4gICAgICAgIC8vIHBhcnNpbmcuXG4gICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2gobWFrZUVycm9yKGV4cHIsIG5vZGUpKTtcbiAgICAgIH1cbiAgICAgIC8vIEFueSBvdGhlciBub2RlcyB3ZSBqdXN0IGlnbm9yZSBhbmQgZ28gdG8gaXQncyBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgZmluZSBhcyB0aGVyZSBhcmUgbG90J3Mgb2Ygd3JhcHBlclxuICAgICAgLy8gbm9kZXMgdGhhdCBjYW4gYmUgc2tpcHBlZC5cbiAgICAgIC8vIFRPRE86IHRoZXJlIGFyZSBwcm9iYWJseSBjYXNlcyB3aGVyZSB3ZSB3aWxsIGp1c3Qgc2tpcCBub2RlcyB3ZSBkb24ndCBzdXBwb3J0IGFuZCB3ZSBzaG91bGQgYmUgYWJsZSB0b1xuICAgICAgLy8gIGRldGVjdCB0aG9zZSBhbmQgcmVwb3J0IGJhY2suXG4gICAgICBsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCBjaGlsZCwgY29udGV4dCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yKG5vZGU6IFN5bnRheE5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucHJldlNpYmxpbmc/Lm5hbWUgPT09ICdFeHByJyAmJiBub2RlLnByZXZTaWJsaW5nPy5maXJzdENoaWxkPy5uYW1lID09PSAnVmVjdG9yU2VsZWN0b3InO1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbChleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB7XG4gIGNvbnN0IGxhYmVsID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ0xhYmVsTmFtZScpKTtcbiAgY29uc3Qgb3AgPSBnZXRTdHJpbmcoZXhwciwgbm9kZS5nZXRDaGlsZCgnTWF0Y2hPcCcpKTtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHJpbmcoZXhwciwgbm9kZS5nZXRDaGlsZCgnU3RyaW5nTGl0ZXJhbCcpKS5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gIHJldHVybiB7XG4gICAgbGFiZWwsXG4gICAgb3AsXG4gICAgdmFsdWUsXG4gIH07XG59XG5cbmNvbnN0IHJhbmdlRnVuY3Rpb25zID0gWydjaGFuZ2VzJywgJ3JhdGUnLCAnaXJhdGUnLCAnaW5jcmVhc2UnLCAnZGVsdGEnXTtcbi8qKlxuICogSGFuZGxlIGZ1bmN0aW9uIGNhbGwgd2hpY2ggaXMgdXN1YWxseSBhbmQgaWRlbnRpZmllciBhbmQgaXRzIGJvZHkgPiBhcmd1bWVudHMuXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUZ1bmN0aW9uKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSwgY29udGV4dDogQ29udGV4dCkge1xuICBjb25zdCB2aXNRdWVyeSA9IGNvbnRleHQucXVlcnk7XG4gIGNvbnN0IG5hbWVOb2RlID0gbm9kZS5nZXRDaGlsZCgnRnVuY3Rpb25JZGVudGlmaWVyJyk7XG4gIGNvbnN0IGZ1bmNOYW1lID0gZ2V0U3RyaW5nKGV4cHIsIG5hbWVOb2RlKTtcblxuICBjb25zdCBib2R5ID0gbm9kZS5nZXRDaGlsZCgnRnVuY3Rpb25DYWxsQm9keScpO1xuICBjb25zdCBjYWxsQXJncyA9IGJvZHkhLmdldENoaWxkKCdGdW5jdGlvbkNhbGxBcmdzJyk7XG4gIGNvbnN0IHBhcmFtcyA9IFtdO1xuICBsZXQgaW50ZXJ2YWwgPSAnJztcblxuICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgc2hvcnRjdXQgdG8gZ2V0IHRoZSBpbnRlcnZhbCBhcmd1bWVudC4gUmVhc29ucyBhcmVcbiAgLy8gLSBpbnRlcnZhbCBpcyBub3QgcGFydCBvZiB0aGUgZnVuY3Rpb24gYXJncyBwZXIgcHJvbVFMIGdyYW1tYXIgYnV0IHdlIG1vZGVsIGl0IGFzIGFyZ3VtZW50IGZvciB0aGUgZnVuY3Rpb24gaW5cbiAgLy8gICB0aGUgcXVlcnkgbW9kZWwuXG4gIC8vIC0gaXQgaXMgZWFzaWVyIHRvIGhhbmRsZSB0ZW1wbGF0ZSB2YXJpYWJsZXMgdGhpcyB3YXkgYXMgdGVtcGxhdGUgdmFyaWFibGUgaXMgYW4gZXJyb3IgZm9yIHRoZSBwYXJzZXJcbiAgaWYgKHJhbmdlRnVuY3Rpb25zLmluY2x1ZGVzKGZ1bmNOYW1lKSB8fCBmdW5jTmFtZS5lbmRzV2l0aCgnX292ZXJfdGltZScpKSB7XG4gICAgbGV0IG1hdGNoID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUpLm1hdGNoKC9cXFsoLispXFxdLyk7XG4gICAgaWYgKG1hdGNoPy5bMV0pIHtcbiAgICAgIGludGVydmFsID0gbWF0Y2hbMV07XG4gICAgICBwYXJhbXMucHVzaChtYXRjaFsxXSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb3AgPSB7IGlkOiBmdW5jTmFtZSwgcGFyYW1zIH07XG4gIC8vIFdlIHVuc2hpZnQgb3BlcmF0aW9ucyB0byBrZWVwIHRoZSBtb3JlIG5hdHVyYWwgb3JkZXIgdGhhdCB3ZSB3YW50IHRvIGhhdmUgaW4gdGhlIHZpc3VhbCBxdWVyeSBlZGl0b3IuXG4gIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMudW5zaGlmdChvcCk7XG5cbiAgaWYgKGNhbGxBcmdzKSB7XG4gICAgaWYgKGdldFN0cmluZyhleHByLCBjYWxsQXJncykgPT09IGludGVydmFsICsgJ10nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGhhdmUgYSBmdW5jdGlvbiB3aXRoIGEgc2luZ2xlIGFyZ3VtZW50IGFuZCBpdCBpcyB0aGUgaW50ZXJ2YWwuXG4gICAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiB5b3Ugc3RhcnQgYWRkaW5nIG9wZXJhdGlvbnMgaW4gcXVlcnkgYnVpbGRlciBhbmQgZGlkIG5vdCBzZXQgYSBtZXRyaWMgeWV0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVGdW5jdGlvbkFyZ3MoZXhwciwgY2FsbEFyZ3MsIGNvbnRleHQsIG9wKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBhZ2dyZWdhdGlvbiBhcyB0aGV5IGFyZSBkaXN0aW5jdCB0eXBlIGZyb20gb3RoZXIgZnVuY3Rpb25zLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVBZ2dyZWdhdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBuYW1lTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ0FnZ3JlZ2F0ZU9wJyk7XG4gIGxldCBmdW5jTmFtZSA9IGdldFN0cmluZyhleHByLCBuYW1lTm9kZSk7XG5cbiAgY29uc3QgbW9kaWZpZXIgPSBub2RlLmdldENoaWxkKCdBZ2dyZWdhdGVNb2RpZmllcicpO1xuICBjb25zdCBsYWJlbHMgPSBbXTtcblxuICBpZiAobW9kaWZpZXIpIHtcbiAgICBjb25zdCBieU1vZGlmaWVyID0gbW9kaWZpZXIuZ2V0Q2hpbGQoYEJ5YCk7XG4gICAgaWYgKGJ5TW9kaWZpZXIgJiYgZnVuY05hbWUpIHtcbiAgICAgIGZ1bmNOYW1lID0gYF9fJHtmdW5jTmFtZX1fYnlgO1xuICAgIH1cblxuICAgIGNvbnN0IHdpdGhvdXRNb2RpZmllciA9IG1vZGlmaWVyLmdldENoaWxkKGBXaXRob3V0YCk7XG4gICAgaWYgKHdpdGhvdXRNb2RpZmllcikge1xuICAgICAgZnVuY05hbWUgPSBgX18ke2Z1bmNOYW1lfV93aXRob3V0YDtcbiAgICB9XG5cbiAgICBsYWJlbHMucHVzaCguLi5nZXRBbGxCeVR5cGUoZXhwciwgbW9kaWZpZXIsICdHcm91cGluZ0xhYmVsJykpO1xuICB9XG5cbiAgY29uc3QgYm9keSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEJvZHknKTtcbiAgY29uc3QgY2FsbEFyZ3MgPSBib2R5IS5nZXRDaGlsZCgnRnVuY3Rpb25DYWxsQXJncycpO1xuXG4gIGNvbnN0IG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7IGlkOiBmdW5jTmFtZSwgcGFyYW1zOiBbXSB9O1xuICB2aXNRdWVyeS5vcGVyYXRpb25zLnVuc2hpZnQob3ApO1xuICB1cGRhdGVGdW5jdGlvbkFyZ3MoZXhwciwgY2FsbEFyZ3MsIGNvbnRleHQsIG9wKTtcbiAgLy8gV2UgYWRkIGxhYmVscyBhZnRlciBwYXJhbXMgaW4gdGhlIHZpc3VhbCBxdWVyeSBlZGl0b3IuXG4gIG9wLnBhcmFtcy5wdXNoKC4uLmxhYmVscyk7XG59XG5cbi8qKlxuICogSGFuZGxlIChwcm9iYWJseSkgYWxsIHR5cGVzIG9mIGFyZ3VtZW50cyB0aGF0IGZ1bmN0aW9uIG9yIGFnZ3JlZ2F0aW9uIGNhbiBoYXZlLlxuICpcbiAqICBGdW5jdGlvbkNhbGxBcmdzIGFyZSBuZXN0ZWQgYml0IHdlaXJkbHkgYmFzaWNhbGx5IGl0cyBbZmlyc3RBcmcsIC4uLnJlc3RdIHdoZXJlIHJlc3QgaXMgYWdhaW4gRnVuY3Rpb25DYWxsQXJncyBzb1xuICogIHdlIGNhbm5vdCBqdXN0IGdldCBhbGwgdGhlIGNoaWxkcmVuIGFuZCBpdGVyYXRlIHRoZW0gYXMgYXJndW1lbnRzIHdlIGhhdmUgdG8gYWdhaW4gcmVjdXJzaXZlbHkgdHJhdmVyc2UgdGhyb3VnaFxuICogIHRoZW0uXG4gKlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICogQHBhcmFtIG9wIC0gV2UgbmVlZCB0aGUgb3BlcmF0aW9uIHRvIGFkZCB0aGUgcGFyYW1zIHRvIGFzIGFuIGFkZGl0aW9uYWwgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSB8IG51bGwsIGNvbnRleHQ6IENvbnRleHQsIG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXRjaCAobm9kZS5uYW1lKSB7XG4gICAgLy8gSW4gY2FzZSB3ZSBoYXZlIGFuIGV4cHJlc3Npb24gd2UgZG9uJ3Qga25vdyB3aGF0IGtpbmQgc28gd2UgaGF2ZSB0byBsb29rIGF0IHRoZSBjaGlsZCBhcyBpdCBjYW4gYmUgYW55dGhpbmcuXG4gICAgY2FzZSAnRXhwcic6XG4gICAgLy8gRnVuY3Rpb25DYWxsQXJncyBhcmUgbmVzdGVkIGJpdCB3ZWlyZGx5IGFzIG1lbnRpb25lZCBzbyB3ZSBoYXZlIHRvIGdvIG9uZSBkZWVwZXIgaW4gdGhpcyBjYXNlLlxuICAgIGNhc2UgJ0Z1bmN0aW9uQ2FsbEFyZ3MnOiB7XG4gICAgICBsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNoaWxkLCBjb250ZXh0LCBvcCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdOdW1iZXJMaXRlcmFsJzoge1xuICAgICAgb3AucGFyYW1zLnB1c2gocGFyc2VGbG9hdChnZXRTdHJpbmcoZXhwciwgbm9kZSkpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOiB7XG4gICAgICBvcC5wYXJhbXMucHVzaChnZXRTdHJpbmcoZXhwciwgbm9kZSkucmVwbGFjZSgvXCIvZywgJycpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIC8vIE1lYW5zIHdlIGdldCB0byBzb21ldGhpbmcgdGhhdCBkb2VzIG5vdCBzZWVtIGxpa2Ugc2ltcGxlIGZ1bmN0aW9uIGFyZyBhbmQgaXMgcHJvYmFibHkgbmVzdGVkIHF1ZXJ5IHNvIGp1bXBcbiAgICAgIC8vIGJhY2sgdG8gbWFpbiBjb250ZXh0XG4gICAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIG5vZGUsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBvcGVyYXRvclRvT3BOYW1lID0gYmluYXJ5U2NhbGFyRGVmcy5yZWR1Y2UoKGFjYywgZGVmKSA9PiB7XG4gIGFjY1tkZWYuc2lnbl0gPSB7XG4gICAgaWQ6IGRlZi5pZCxcbiAgICBjb21wYXJpc29uOiBkZWYuY29tcGFyaXNvbixcbiAgfTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHsgaWQ6IHN0cmluZzsgY29tcGFyaXNvbj86IGJvb2xlYW4gfT4pO1xuXG4vKipcbiAqIFJpZ2h0IG5vdyBiaW5hcnkgZXhwcmVzc2lvbnMgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5IGluIHZpc3VhbCBxdWVyeS4gQXMgYWRkaXRpb25hbCBvcGVyYXRpb24gaW4gY2FzZSBpdCBpc1xuICoganVzdCBvcGVyYXRpb24gd2l0aCBzY2FsYXIgb3IgaXQgY3JlYXRlcyBhIGJpbmFyeVF1ZXJ5IHdoZW4gaXQncyAyIHF1ZXJpZXMuXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUJpbmFyeShleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBsZWZ0ID0gbm9kZS5maXJzdENoaWxkITtcbiAgY29uc3Qgb3AgPSBnZXRTdHJpbmcoZXhwciwgbGVmdC5uZXh0U2libGluZyk7XG4gIGNvbnN0IGJpbk1vZGlmaWVyID0gZ2V0QmluYXJ5TW9kaWZpZXIoZXhwciwgbm9kZS5nZXRDaGlsZCgnQmluTW9kaWZpZXJzJykpO1xuXG4gIGNvbnN0IHJpZ2h0ID0gbm9kZS5sYXN0Q2hpbGQhO1xuXG4gIGNvbnN0IG9wRGVmID0gb3BlcmF0b3JUb09wTmFtZVtvcF07XG5cbiAgY29uc3QgbGVmdE51bWJlciA9IGxlZnQuZ2V0Q2hpbGQoJ051bWJlckxpdGVyYWwnKTtcbiAgY29uc3QgcmlnaHROdW1iZXIgPSByaWdodC5nZXRDaGlsZCgnTnVtYmVyTGl0ZXJhbCcpO1xuXG4gIGNvbnN0IHJpZ2h0QmluYXJ5ID0gcmlnaHQuZ2V0Q2hpbGQoJ0JpbmFyeUV4cHInKTtcblxuICBpZiAobGVmdE51bWJlcikge1xuICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGFscmVhZHkgaGFuZGxlZCBpbiBjYXNlIHBhcmVudCBpcyBiaW5hcnkgZXhwcmVzc2lvbiBhcyBpdCBoYXMgdG8gYmUgYWRkZWQgdG8gcGFyZW50XG4gICAgLy8gIGlmIHF1ZXJ5IHN0YXJ0cyB3aXRoIGEgbnVtYmVyIHRoYXQgaXNuJ3QgaGFuZGxlZCBub3cuXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhpcyBpcyBiaW5hcnkgd2UgZG9uJ3QgcmVhbGx5IGtub3cgaWYgdGhlcmUgaXMgYSBxdWVyeSBvciBqdXN0IGNoYWluZWQgc2NhbGFycy4gU29cbiAgICAvLyB3ZSBoYXZlIHRvIHRyYXZlcnNlIGEgYml0IGRlZXBlciB0byBrbm93XG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCBsZWZ0LCBjb250ZXh0KTtcbiAgfVxuXG4gIGlmIChyaWdodE51bWJlcikge1xuICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChtYWtlQmluT3Aob3BEZWYsIGV4cHIsIHJpZ2h0LCAhIWJpbk1vZGlmaWVyPy5pc0Jvb2wpKTtcbiAgfSBlbHNlIGlmIChyaWdodEJpbmFyeSkge1xuICAgIC8vIER1ZSB0byB0aGUgd2F5IGJpbmFyeSBvcHMgYXJlIHBhcnNlZCB3ZSBjYW4gZ2V0IGEgYmluYXJ5IG9wZXJhdGlvbiBvbiB0aGUgcmlnaHQgdGhhdCBzdGFydHMgd2l0aCBhIG51bWJlciB3aGljaFxuICAgIC8vIGlzIGEgZmFjdG9yIGZvciBhIGN1cnJlbnQgYmluYXJ5IG9wZXJhdGlvbi4gU28gd2UgaGF2ZSB0byBhZGQgaXQgYXMgYW4gb3BlcmF0aW9uIG5vdy5cbiAgICBjb25zdCBsZWZ0TW9zdENoaWxkID0gZ2V0TGVmdE1vc3RDaGlsZChyaWdodCk7XG4gICAgaWYgKGxlZnRNb3N0Q2hpbGQ/Lm5hbWUgPT09ICdOdW1iZXJMaXRlcmFsJykge1xuICAgICAgdmlzUXVlcnkub3BlcmF0aW9ucy5wdXNoKG1ha2VCaW5PcChvcERlZiwgZXhwciwgbGVmdE1vc3RDaGlsZCwgISFiaW5Nb2RpZmllcj8uaXNCb29sKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYWRkZWQgdGhlIGZpcnN0IG51bWJlciBsaXRlcmFsIGFzIG9wZXJhdGlvbiBoZXJlIHdlIHN0aWxsIGNhbiBjb250aW51ZSBhbmQgaGFuZGxlIHRoZSByZXN0IGFzIHRoZSBmaXJzdFxuICAgIC8vIG51bWJlciB3aWxsIGJlIGp1c3Qgc2tpcHBlZC5cbiAgICBoYW5kbGVFeHByZXNzaW9uKGV4cHIsIHJpZ2h0LCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzID0gdmlzUXVlcnkuYmluYXJ5UXVlcmllcyB8fCBbXTtcbiAgICBjb25zdCBiaW5RdWVyeTogUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5ID0ge1xuICAgICAgb3BlcmF0b3I6IG9wLFxuICAgICAgcXVlcnk6IHtcbiAgICAgICAgbWV0cmljOiAnJyxcbiAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgb3BlcmF0aW9uczogW10sXG4gICAgICB9LFxuICAgIH07XG4gICAgaWYgKGJpbk1vZGlmaWVyPy5pc01hdGNoZXIpIHtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXNUeXBlID0gYmluTW9kaWZpZXIubWF0Y2hUeXBlO1xuICAgICAgYmluUXVlcnkudmVjdG9yTWF0Y2hlcyA9IGJpbk1vZGlmaWVyLm1hdGNoZXM7XG4gICAgfVxuICAgIHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMucHVzaChiaW5RdWVyeSk7XG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwge1xuICAgICAgcXVlcnk6IGJpblF1ZXJ5LnF1ZXJ5LFxuICAgICAgZXJyb3JzOiBjb250ZXh0LmVycm9ycyxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnlNb2RpZmllcihcbiAgZXhwcjogc3RyaW5nLFxuICBub2RlOiBTeW50YXhOb2RlIHwgbnVsbFxuKTpcbiAgfCB7IGlzQm9vbDogdHJ1ZTsgaXNNYXRjaGVyOiBmYWxzZSB9XG4gIHwgeyBpc0Jvb2w6IGZhbHNlOyBpc01hdGNoZXI6IHRydWU7IG1hdGNoZXM6IHN0cmluZzsgbWF0Y2hUeXBlOiAnaWdub3JpbmcnIHwgJ29uJyB9XG4gIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAobm9kZS5nZXRDaGlsZCgnQm9vbCcpKSB7XG4gICAgcmV0dXJuIHsgaXNCb29sOiB0cnVlLCBpc01hdGNoZXI6IGZhbHNlIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2hlciA9IG5vZGUuZ2V0Q2hpbGQoJ09uT3JJZ25vcmluZycpO1xuICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgLy8gTm90IHN1cmUgd2hhdCB0aGlzIGNvdWxkIGJlLCBtYXliZSBzaG91bGQgYmUgYW4gZXJyb3IuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSBnZXRTdHJpbmcoZXhwciwgbWF0Y2hlci5nZXRDaGlsZCgnR3JvdXBpbmdMYWJlbHMnKT8uZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxMaXN0JykpO1xuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoZXI6IHRydWUsXG4gICAgICBpc0Jvb2w6IGZhbHNlLFxuICAgICAgbWF0Y2hlczogbGFiZWxzLFxuICAgICAgbWF0Y2hUeXBlOiBtYXRjaGVyLmdldENoaWxkKCdPbicpID8gJ29uJyA6ICdpZ25vcmluZycsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0VtcHR5UXVlcnkocXVlcnk6IFByb21WaXN1YWxRdWVyeSkge1xuICBpZiAocXVlcnkubGFiZWxzLmxlbmd0aCA9PT0gMCAmJiBxdWVyeS5vcGVyYXRpb25zLmxlbmd0aCA9PT0gMCAmJiAhcXVlcnkubWV0cmljKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgSW5wdXQsIG1lYXN1cmVUZXh0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgUHJvcHMgYXMgSW5wdXRQcm9wcyB9IGZyb20gJ0BncmFmYW5hL3VpL3NyYy9jb21wb25lbnRzL0lucHV0L0lucHV0JztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIGV4dGVuZHMgSW5wdXRQcm9wcyB7XG4gIC8qKiBTZXRzIHRoZSBtaW4td2lkdGggdG8gYSBtdWx0aXBsZSBvZiA4cHguIERlZmF1bHQgdmFsdWUgaXMgMTAqL1xuICBtaW5XaWR0aD86IG51bWJlcjtcbiAgLyoqIFNldHMgdGhlIG1heC13aWR0aCB0byBhIG11bHRpcGxlIG9mIDhweC4qL1xuICBtYXhXaWR0aD86IG51bWJlcjtcbiAgLyoqIG9uQ2hhbmdlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW4gb24gb25CbHVyIGFuZCBvbktleVByZXNzIHdpdGggZW50ZXIqL1xuICBvbkNvbW1pdENoYW5nZT86IChldmVudDogUmVhY3QuRm9ybUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgQXV0b1NpemVJbnB1dCA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTElucHV0RWxlbWVudCwgUHJvcHM+KChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgZGVmYXVsdFZhbHVlID0gJycsIG1pbldpZHRoID0gMTAsIG1heFdpZHRoLCBvbkNvbW1pdENoYW5nZSwgb25LZXlEb3duLCBvbkJsdXIsIC4uLnJlc3RQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFZhbHVlKTtcbiAgY29uc3QgW2lucHV0V2lkdGgsIHNldElucHV0V2lkdGhdID0gUmVhY3QudXNlU3RhdGUobWluV2lkdGgpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SW5wdXRXaWR0aChnZXRXaWR0aEZvcih2YWx1ZS50b1N0cmluZygpLCBtaW5XaWR0aCwgbWF4V2lkdGgpKTtcbiAgfSwgW3ZhbHVlLCBtYXhXaWR0aCwgbWluV2lkdGhdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbnB1dFxuICAgICAgey4uLnJlc3RQcm9wc31cbiAgICAgIHJlZj17cmVmfVxuICAgICAgdmFsdWU9e3ZhbHVlLnRvU3RyaW5nKCl9XG4gICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiB7XG4gICAgICAgIHNldFZhbHVlKGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgICAgfX1cbiAgICAgIHdpZHRoPXtpbnB1dFdpZHRofVxuICAgICAgb25CbHVyPXsoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKG9uQ29tbWl0Q2hhbmdlKSB7XG4gICAgICAgICAgb25Db21taXRDaGFuZ2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgICBvbkJsdXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9fVxuICAgICAgb25LZXlEb3duPXsoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJyAmJiBvbkNvbW1pdENoYW5nZSkge1xuICAgICAgICAgIG9uQ29tbWl0Q2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25LZXlEb3duKSB7XG4gICAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIGRhdGEtdGVzdGlkPXsnYXV0b3NpemUtaW5wdXQnfVxuICAgIC8+XG4gICk7XG59KTtcblxuZnVuY3Rpb24gZ2V0V2lkdGhGb3IodmFsdWU6IHN0cmluZywgbWluV2lkdGg6IG51bWJlciwgbWF4V2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gbWluV2lkdGg7XG4gIH1cblxuICBjb25zdCBleHRyYVNwYWNlID0gMztcbiAgY29uc3QgcmVhbFdpZHRoID0gbWVhc3VyZVRleHQodmFsdWUudG9TdHJpbmcoKSwgMTQpLndpZHRoIC8gOCArIGV4dHJhU3BhY2U7XG5cbiAgaWYgKG1pbldpZHRoICYmIHJlYWxXaWR0aCA8IG1pbldpZHRoKSB7XG4gICAgcmV0dXJuIG1pbldpZHRoO1xuICB9XG5cbiAgaWYgKG1heFdpZHRoICYmIHJlYWxXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgcmV0dXJuIHJlYWxXaWR0aDtcbiAgfVxuXG4gIHJldHVybiByZWFsV2lkdGg7XG59XG5cbkF1dG9TaXplSW5wdXQuZGlzcGxheU5hbWUgPSAnQXV0b1NpemVJbnB1dCc7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUsIHRvT3B0aW9uIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQWNjZXNzb3J5QnV0dG9uLCBJbnB1dEdyb3VwIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIGRlZmF1bHRPcDogc3RyaW5nO1xuICBpdGVtOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPjtcbiAgb25DaGFuZ2U6ICh2YWx1ZTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpID0+IHZvaWQ7XG4gIG9uR2V0TGFiZWxOYW1lczogKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG4gIG9uR2V0TGFiZWxWYWx1ZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBvbkRlbGV0ZTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYmVsRmlsdGVySXRlbSh7IGl0ZW0sIGRlZmF1bHRPcCwgb25DaGFuZ2UsIG9uRGVsZXRlLCBvbkdldExhYmVsTmFtZXMsIG9uR2V0TGFiZWxWYWx1ZXMgfTogUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTx7XG4gICAgbGFiZWxOYW1lcz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBsYWJlbFZhbHVlcz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBpc0xvYWRpbmdMYWJlbE5hbWVzPzogYm9vbGVhbjtcbiAgICBpc0xvYWRpbmdMYWJlbFZhbHVlcz86IGJvb2xlYW47XG4gIH0+KHt9KTtcblxuICBjb25zdCBpc011bHRpU2VsZWN0ID0gKCkgPT4ge1xuICAgIHJldHVybiBpdGVtLm9wID09PSBvcGVyYXRvcnNbMF0ubGFiZWw7XG4gIH07XG5cbiAgY29uc3QgZ2V0VmFsdWUgPSAoaXRlbTogYW55KSA9PiB7XG4gICAgaWYgKGl0ZW0gJiYgaXRlbS52YWx1ZSkge1xuICAgICAgaWYgKGl0ZW0udmFsdWUuaW5kZXhPZignfCcpID4gMCkge1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZS5zcGxpdCgnfCcpLm1hcCgoeDogYW55KSA9PiAoeyBsYWJlbDogeCwgdmFsdWU6IHggfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvT3B0aW9uKGl0ZW0udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBjb25zdCBnZXRPcHRpb25zID0gKCkgPT4ge1xuICAgIGlmICghc3RhdGUubGFiZWxWYWx1ZXMgJiYgaXRlbSAmJiBpdGVtLnZhbHVlICYmIGl0ZW0udmFsdWUuaW5kZXhPZignfCcpID4gMCkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlKGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5sYWJlbFZhbHVlcztcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJwcm9tZXRoZXVzLWRpbWVuc2lvbnMtZmlsdGVyLWl0ZW1cIj5cbiAgICAgIDxJbnB1dEdyb3VwPlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbS1rZXlcIlxuICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgdmFsdWU9e2l0ZW0ubGFiZWwgPyB0b09wdGlvbihpdGVtLmxhYmVsKSA6IG51bGx9XG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgaXNMb2FkaW5nTGFiZWxOYW1lczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsTmFtZXMgPSBhd2FpdCBvbkdldExhYmVsTmFtZXMoaXRlbSk7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGxhYmVsTmFtZXMsIGlzTG9hZGluZ0xhYmVsTmFtZXM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGlzTG9hZGluZz17c3RhdGUuaXNMb2FkaW5nTGFiZWxOYW1lc31cbiAgICAgICAgICBvcHRpb25zPXtzdGF0ZS5sYWJlbE5hbWVzfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmxhYmVsKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCxcbiAgICAgICAgICAgICAgICBsYWJlbDogY2hhbmdlLmxhYmVsLFxuICAgICAgICAgICAgICB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgdmFsdWU9e3RvT3B0aW9uKGl0ZW0ub3AgPz8gZGVmYXVsdE9wKX1cbiAgICAgICAgICBvcHRpb25zPXtvcGVyYXRvcnN9XG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICBvbkNoYW5nZT17KGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgb3A6IGNoYW5nZS52YWx1ZSB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbS12YWx1ZVwiXG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICB2YWx1ZT17Z2V0VmFsdWUoaXRlbSl9XG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgaXNMb2FkaW5nTGFiZWxWYWx1ZXM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbFZhbHVlcyA9IGF3YWl0IG9uR2V0TGFiZWxWYWx1ZXMoaXRlbSk7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBsYWJlbFZhbHVlcyxcbiAgICAgICAgICAgICAgaXNMb2FkaW5nTGFiZWxWYWx1ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH19XG4gICAgICAgICAgaXNNdWx0aT17aXNNdWx0aVNlbGVjdCgpfVxuICAgICAgICAgIGlzTG9hZGluZz17c3RhdGUuaXNMb2FkaW5nTGFiZWxWYWx1ZXN9XG4gICAgICAgICAgb3B0aW9ucz17Z2V0T3B0aW9ucygpfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgdmFsdWU6IGNoYW5nZS52YWx1ZSwgb3A6IGl0ZW0ub3AgPz8gZGVmYXVsdE9wIH0gYXMgYW55IGFzIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAubWFwKChjaGFuZ2U6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZS5sYWJlbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgdmFsdWU6IGNoYW5nZXMsIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICAgPEFjY2Vzc29yeUJ1dHRvbiBhcmlhLWxhYmVsPVwicmVtb3ZlXCIgaWNvbj1cInRpbWVzXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e29uRGVsZXRlfSAvPlxuICAgICAgPC9JbnB1dEdyb3VwPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5jb25zdCBvcGVyYXRvcnMgPSBbXG4gIHsgbGFiZWw6ICc9ficsIHZhbHVlOiAnPX4nIH0sXG4gIHsgbGFiZWw6ICc9JywgdmFsdWU6ICc9JyB9LFxuICB7IGxhYmVsOiAnIT0nLCB2YWx1ZTogJyE9JyB9LFxuICB7IGxhYmVsOiAnIX4nLCB2YWx1ZTogJyF+JyB9LFxuXTtcbiIsImltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yRmllbGQsIEVkaXRvckZpZWxkR3JvdXAsIEVkaXRvckxpc3QgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgaXNFcXVhbCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IExhYmVsRmlsdGVySXRlbSB9IGZyb20gJy4vTGFiZWxGaWx0ZXJJdGVtJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIGxhYmVsc0ZpbHRlcnM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW107XG4gIG9uQ2hhbmdlOiAobGFiZWxGaWx0ZXJzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKSA9PiB2b2lkO1xuICBvbkdldExhYmVsTmFtZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBvbkdldExhYmVsVmFsdWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYmVsRmlsdGVycyh7IGxhYmVsc0ZpbHRlcnMsIG9uQ2hhbmdlLCBvbkdldExhYmVsTmFtZXMsIG9uR2V0TGFiZWxWYWx1ZXMgfTogUHJvcHMpIHtcbiAgY29uc3QgZGVmYXVsdE9wID0gJz0nO1xuICBjb25zdCBbaXRlbXMsIHNldEl0ZW1zXSA9IHVzZVN0YXRlPEFycmF5PFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+Pj4oW3sgb3A6IGRlZmF1bHRPcCB9XSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobGFiZWxzRmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRJdGVtcyhsYWJlbHNGaWx0ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXRlbXMoW3sgb3A6IGRlZmF1bHRPcCB9XSk7XG4gICAgfVxuICB9LCBbbGFiZWxzRmlsdGVyc10pO1xuXG4gIGNvbnN0IG9uTGFiZWxzQ2hhbmdlID0gKG5ld0l0ZW1zOiBBcnJheTxQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPj4pID0+IHtcbiAgICBzZXRJdGVtcyhuZXdJdGVtcyk7XG5cbiAgICAvLyBFeHRyYWN0IGZ1bGwgbGFiZWwgZmlsdGVycyB3aXRoIGJvdGggbGFiZWwgJiB2YWx1ZVxuICAgIGNvbnN0IG5ld0xhYmVscyA9IG5ld0l0ZW1zLmZpbHRlcigoeCkgPT4geC5sYWJlbCAhPSBudWxsICYmIHgudmFsdWUgIT0gbnVsbCk7XG4gICAgaWYgKCFpc0VxdWFsKG5ld0xhYmVscywgbGFiZWxzRmlsdGVycykpIHtcbiAgICAgIG9uQ2hhbmdlKG5ld0xhYmVscyBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIkxhYmVsc1wiPlxuICAgICAgICA8RWRpdG9yTGlzdFxuICAgICAgICAgIGl0ZW1zPXtpdGVtc31cbiAgICAgICAgICBvbkNoYW5nZT17b25MYWJlbHNDaGFuZ2V9XG4gICAgICAgICAgcmVuZGVySXRlbT17KGl0ZW0sIG9uQ2hhbmdlSXRlbSwgb25EZWxldGUpID0+IChcbiAgICAgICAgICAgIDxMYWJlbEZpbHRlckl0ZW1cbiAgICAgICAgICAgICAgaXRlbT17aXRlbX1cbiAgICAgICAgICAgICAgZGVmYXVsdE9wPXtkZWZhdWx0T3B9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZUl0ZW19XG4gICAgICAgICAgICAgIG9uRGVsZXRlPXtvbkRlbGV0ZX1cbiAgICAgICAgICAgICAgb25HZXRMYWJlbE5hbWVzPXtvbkdldExhYmVsTmFtZXN9XG4gICAgICAgICAgICAgIG9uR2V0TGFiZWxWYWx1ZXM9e29uR2V0TGFiZWxWYWx1ZXN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIC8+XG4gICAgICA8L0VkaXRvckZpZWxkPlxuICAgIDwvRWRpdG9yRmllbGRHcm91cD5cbiAgKTtcbn1cbiIsImltcG9ydCB7IFJlZ2lzdHJ5IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZpc3VhbFF1ZXJ5QmluYXJ5PFQ+IHtcbiAgb3BlcmF0b3I6IHN0cmluZztcbiAgdmVjdG9yTWF0Y2hlc1R5cGU/OiAnb24nIHwgJ2lnbm9yaW5nJztcbiAgdmVjdG9yTWF0Y2hlcz86IHN0cmluZztcbiAgcXVlcnk6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUxva2lWaXN1YWxRdWVyeSB7XG4gIG1ldHJpYz86IHN0cmluZztcbiAgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbiAgYmluYXJ5UXVlcmllcz86IEFycmF5PFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+Pjtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UgaW1wbGVtZW50cyBWaXN1YWxRdWVyeU1vZGVsbGVyIHtcbiAgcHJvdGVjdGVkIG9wZXJhdGlvbnNSZWdpc3R5OiBSZWdpc3RyeTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+O1xuICBwcml2YXRlIGNhdGVnb3JpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZ2V0T3BlcmF0aW9uczogKCkgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5ID0gbmV3IFJlZ2lzdHJ5PFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4oZ2V0T3BlcmF0aW9ucyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhjYXRlZ29yaWVzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XG4gIH1cblxuICBnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5Lmxpc3QoKS5maWx0ZXIoKG9wKSA9PiBvcC5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkgJiYgIW9wLmhpZGVGcm9tTGlzdCk7XG4gIH1cblxuICBnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoa2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zUmVnaXN0eS5saXN0KCkuZmlsdGVyKChvcCkgPT4gb3AuYWx0ZXJuYXRpdmVzS2V5ID09PSBrZXkpO1xuICB9XG5cbiAgZ2V0Q2F0ZWdvcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5jYXRlZ29yaWVzO1xuICB9XG5cbiAgZ2V0T3BlcmF0aW9uRGVmKGlkOiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5LmdldElmRXhpc3RzKGlkKTtcbiAgfVxuXG4gIHJlbmRlck9wZXJhdGlvbnMocXVlcnlTdHJpbmc6IHN0cmluZywgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW10pIHtcbiAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7XG4gICAgICBjb25zdCBkZWYgPSB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5LmdldElmRXhpc3RzKG9wZXJhdGlvbi5pZCk7XG4gICAgICBpZiAoIWRlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG9wZXJhdGlvbiAke29wZXJhdGlvbi5pZH0gaW4gdGhlIHJlZ2lzdHJ5YCk7XG4gICAgICB9XG4gICAgICBxdWVyeVN0cmluZyA9IGRlZi5yZW5kZXJlcihvcGVyYXRpb24sIGRlZiwgcXVlcnlTdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgfVxuXG4gIHJlbmRlckJpbmFyeVF1ZXJpZXMocXVlcnlTdHJpbmc6IHN0cmluZywgYmluYXJ5UXVlcmllcz86IEFycmF5PFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+Pikge1xuICAgIGlmIChiaW5hcnlRdWVyaWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGJpblF1ZXJ5IG9mIGJpbmFyeVF1ZXJpZXMpIHtcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBgJHt0aGlzLnJlbmRlckJpbmFyeVF1ZXJ5KHF1ZXJ5U3RyaW5nLCBiaW5RdWVyeSl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJCaW5hcnlRdWVyeShsZWZ0T3BlcmFuZDogc3RyaW5nLCBiaW5hcnlRdWVyeTogVmlzdWFsUXVlcnlCaW5hcnk8UHJvbUxva2lWaXN1YWxRdWVyeT4pIHtcbiAgICBsZXQgcmVzdWx0ID0gbGVmdE9wZXJhbmQgKyBgICR7YmluYXJ5UXVlcnkub3BlcmF0b3J9IGA7XG5cbiAgICBpZiAoYmluYXJ5UXVlcnkudmVjdG9yTWF0Y2hlcykge1xuICAgICAgcmVzdWx0ICs9IGAke2JpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXNUeXBlfSgke2JpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXN9KSBgO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgKyB0aGlzLnJlbmRlclF1ZXJ5KGJpbmFyeVF1ZXJ5LnF1ZXJ5LCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlckxhYmVscyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pIHtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGxldCBleHByID0gJ3snO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGxhYmVscykge1xuICAgICAgaWYgKGV4cHIgIT09ICd7Jykge1xuICAgICAgICBleHByICs9ICcsICc7XG4gICAgICB9XG5cbiAgICAgIGV4cHIgKz0gYCR7ZmlsdGVyLmxhYmVsfSR7ZmlsdGVyLm9wfVwiJHtmaWx0ZXIudmFsdWV9XCJgO1xuICAgIH1cblxuICAgIHJldHVybiBleHByICsgYH1gO1xuICB9XG5cbiAgcmVuZGVyUXVlcnkocXVlcnk6IFByb21Mb2tpVmlzdWFsUXVlcnksIG5lc3RlZD86IGJvb2xlYW4pIHtcbiAgICBsZXQgcXVlcnlTdHJpbmcgPSBgJHtxdWVyeS5tZXRyaWMgPz8gJyd9JHt0aGlzLnJlbmRlckxhYmVscyhxdWVyeS5sYWJlbHMpfWA7XG4gICAgcXVlcnlTdHJpbmcgPSB0aGlzLnJlbmRlck9wZXJhdGlvbnMocXVlcnlTdHJpbmcsIHF1ZXJ5Lm9wZXJhdGlvbnMpO1xuXG4gICAgaWYgKCFuZXN0ZWQgJiYgdGhpcy5oYXNCaW5hcnlPcChxdWVyeSkgJiYgQm9vbGVhbihxdWVyeS5iaW5hcnlRdWVyaWVzPy5sZW5ndGgpKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGAoJHtxdWVyeVN0cmluZ30pYDtcbiAgICB9XG5cbiAgICBxdWVyeVN0cmluZyA9IHRoaXMucmVuZGVyQmluYXJ5UXVlcmllcyhxdWVyeVN0cmluZywgcXVlcnkuYmluYXJ5UXVlcmllcyk7XG5cbiAgICBpZiAobmVzdGVkICYmICh0aGlzLmhhc0JpbmFyeU9wKHF1ZXJ5KSB8fCBCb29sZWFuKHF1ZXJ5LmJpbmFyeVF1ZXJpZXM/Lmxlbmd0aCkpKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGAoJHtxdWVyeVN0cmluZ30pYDtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnlTdHJpbmc7XG4gIH1cblxuICBoYXNCaW5hcnlPcChxdWVyeTogUHJvbUxva2lWaXN1YWxRdWVyeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBxdWVyeS5vcGVyYXRpb25zLmZpbmQoKG9wKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuZ2V0T3BlcmF0aW9uRGVmKG9wLmlkKTtcbiAgICAgICAgcmV0dXJuIGRlZj8uY2F0ZWdvcnkgPT09IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcztcbiAgICAgIH0pICE9PSB1bmRlZmluZWRcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IERhdGFTb3VyY2VBcGksIEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgSWNvbiwgVG9vbHRpcCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlIH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5pbXBvcnQge1xuICBWaXN1YWxRdWVyeU1vZGVsbGVyLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWUsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBPcGVyYXRpb25IZWFkZXIgfSBmcm9tICcuL09wZXJhdGlvbkhlYWRlcic7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25QYXJhbUVkaXRvciB9IGZyb20gJy4vT3BlcmF0aW9uUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4vb3BlcmF0aW9uVXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG4gIGluZGV4OiBudW1iZXI7XG4gIHF1ZXJ5OiBhbnk7XG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGk7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgaGlnaGxpZ2h0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkVkaXRvcih7XG4gIG9wZXJhdGlvbixcbiAgaW5kZXgsXG4gIG9uUmVtb3ZlLFxuICBvbkNoYW5nZSxcbiAgb25SdW5RdWVyeSxcbiAgcXVlcnlNb2RlbGxlcixcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIGhpZ2hsaWdodCxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgZGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYob3BlcmF0aW9uLmlkKTtcbiAgY29uc3Qgc2hvdWxkSGlnaGxpZ2h0ID0gdXNlSGlnaGxpZ2h0KGhpZ2hsaWdodCk7XG5cbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm4gPHNwYW4+T3BlcmF0aW9uIHtvcGVyYXRpb24uaWR9IG5vdCBmb3VuZDwvc3Bhbj47XG4gIH1cblxuICBjb25zdCBvblBhcmFtVmFsdWVDaGFuZ2VkID0gKHBhcmFtSWR4OiBudW1iZXIsIHZhbHVlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7IC4uLm9wZXJhdGlvbiwgcGFyYW1zOiBbLi4ub3BlcmF0aW9uLnBhcmFtc10gfTtcbiAgICB1cGRhdGUucGFyYW1zW3BhcmFtSWR4XSA9IHZhbHVlO1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBwYXJhbUlkeCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uQWRkUmVzdFBhcmFtID0gKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyAuLi5vcGVyYXRpb24sIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXMsICcnXSB9O1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlUmVzdFBhcmFtID0gKHBhcmFtSWR4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHtcbiAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXMuc2xpY2UoMCwgcGFyYW1JZHgpLCAuLi5vcGVyYXRpb24ucGFyYW1zLnNsaWNlKHBhcmFtSWR4ICsgMSldLFxuICAgIH07XG4gICAgY2FsbFBhcmFtQ2hhbmdlZFRoZW5PbkNoYW5nZShkZWYsIHVwZGF0ZSwgaW5kZXgsIHBhcmFtSWR4LCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgY29uc3Qgb3BlcmF0aW9uRWxlbWVudHM6IFJlYWN0LlJlYWN0Tm9kZVtdID0gW107XG5cbiAgZm9yIChsZXQgcGFyYW1JbmRleCA9IDA7IHBhcmFtSW5kZXggPCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aDsgcGFyYW1JbmRleCsrKSB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW01hdGgubWluKGRlZi5wYXJhbXMubGVuZ3RoIC0gMSwgcGFyYW1JbmRleCldO1xuICAgIGNvbnN0IEVkaXRvciA9IGdldE9wZXJhdGlvblBhcmFtRWRpdG9yKHBhcmFtRGVmKTtcblxuICAgIG9wZXJhdGlvbkVsZW1lbnRzLnB1c2goXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtUm93fSBrZXk9e2Ake3BhcmFtSW5kZXh9LTFgfT5cbiAgICAgICAgeyFwYXJhbURlZi5oaWRlTmFtZSAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5wYXJhbU5hbWV9PlxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2dldE9wZXJhdGlvblBhcmFtSWQoaW5kZXgsIHBhcmFtSW5kZXgpfT57cGFyYW1EZWYubmFtZX08L2xhYmVsPlxuICAgICAgICAgICAge3BhcmFtRGVmLmRlc2NyaXB0aW9uICYmIChcbiAgICAgICAgICAgICAgPFRvb2x0aXAgcGxhY2VtZW50PVwidG9wXCIgY29udGVudD17cGFyYW1EZWYuZGVzY3JpcHRpb259IHRoZW1lPVwiaW5mb1wiPlxuICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJpbmZvLWNpcmNsZVwiIHNpemU9XCJzbVwiIGNsYXNzTmFtZT17c3R5bGVzLmluZm9JY29ufSAvPlxuICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtVmFsdWV9PlxuICAgICAgICAgIDxTdGFjayBnYXA9ezAuNX0gZGlyZWN0aW9uPVwicm93XCIgYWxpZ25JdGVtcz1cImNlbnRlclwiIHdyYXA9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxFZGl0b3JcbiAgICAgICAgICAgICAgaW5kZXg9e3BhcmFtSW5kZXh9XG4gICAgICAgICAgICAgIHBhcmFtRGVmPXtwYXJhbURlZn1cbiAgICAgICAgICAgICAgdmFsdWU9e29wZXJhdGlvbi5wYXJhbXNbcGFyYW1JbmRleF19XG4gICAgICAgICAgICAgIG9wZXJhdGlvbj17b3BlcmF0aW9ufVxuICAgICAgICAgICAgICBvcGVyYXRpb25JbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvblBhcmFtVmFsdWVDaGFuZ2VkfVxuICAgICAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge3BhcmFtRGVmLnJlc3RQYXJhbSAmJiAob3BlcmF0aW9uLnBhcmFtcy5sZW5ndGggPiBkZWYucGFyYW1zLmxlbmd0aCB8fCBwYXJhbURlZi5vcHRpb25hbCkgJiYgKFxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9e2BvcGVyYXRpb25zLiR7aW5kZXh9LnJlbW92ZS1yZXN0LXBhcmFtYH1cbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIGZpbGw9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBpY29uPVwidGltZXNcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPXtgUmVtb3ZlICR7cGFyYW1EZWYubmFtZX1gfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlUmVzdFBhcmFtKHBhcmFtSW5kZXgpfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L1N0YWNrPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICAvLyBIYW5kbGUgYWRkaW5nIGJ1dHRvbiBmb3IgcmVzdCBwYXJhbXNcbiAgbGV0IHJlc3RQYXJhbTogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkO1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGFzdFBhcmFtRGVmID0gZGVmLnBhcmFtc1tkZWYucGFyYW1zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0UGFyYW1EZWYucmVzdFBhcmFtKSB7XG4gICAgICByZXN0UGFyYW0gPSByZW5kZXJBZGRSZXN0UGFyYW1CdXR0b24obGFzdFBhcmFtRGVmLCBvbkFkZFJlc3RQYXJhbSwgaW5kZXgsIG9wZXJhdGlvbi5wYXJhbXMubGVuZ3RoLCBzdHlsZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPERyYWdnYWJsZSBkcmFnZ2FibGVJZD17YG9wZXJhdGlvbi0ke2luZGV4fWB9IGluZGV4PXtpbmRleH0+XG4gICAgICB7KHByb3ZpZGVkKSA9PiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2N4KHN0eWxlcy5jYXJkLCBzaG91bGRIaWdobGlnaHQgJiYgc3R5bGVzLmNhcmRIaWdobGlnaHQpfVxuICAgICAgICAgIHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9XG4gICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdnYWJsZVByb3BzfVxuICAgICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke2luZGV4fS53cmFwcGVyYH1cbiAgICAgICAgPlxuICAgICAgICAgIDxPcGVyYXRpb25IZWFkZXJcbiAgICAgICAgICAgIG9wZXJhdGlvbj17b3BlcmF0aW9ufVxuICAgICAgICAgICAgZHJhZ0hhbmRsZVByb3BzPXtwcm92aWRlZC5kcmFnSGFuZGxlUHJvcHN9XG4gICAgICAgICAgICBkZWY9e2RlZn1cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIG9uUmVtb3ZlPXtvblJlbW92ZX1cbiAgICAgICAgICAgIHF1ZXJ5TW9kZWxsZXI9e3F1ZXJ5TW9kZWxsZXJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PntvcGVyYXRpb25FbGVtZW50c308L2Rpdj5cbiAgICAgICAgICB7cmVzdFBhcmFtfVxuICAgICAgICAgIHtpbmRleCA8IHF1ZXJ5Lm9wZXJhdGlvbnMubGVuZ3RoIC0gMSAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFycm93fT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hcnJvd0xpbmV9IC8+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYXJyb3dBcnJvd30gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L0RyYWdnYWJsZT5cbiAgKTtcbn1cblxuLyoqXG4gKiBXaGVuIGhpZ2hsaWdodCBpcyBzd2l0Y2hlZCBvbiBtYWtlcyBzdXJlIGl0IGlzIHN3aXRjaGVkIG9mIHJpZ2h0IGF3YXksIHNvIHdlIGp1c3QgZmxhc2ggdGhlIGhpZ2hsaWdodCBhbmQgdGhlbiBmYWRlXG4gKiBvdXQuXG4gKiBAcGFyYW0gaGlnaGxpZ2h0XG4gKi9cbmZ1bmN0aW9uIHVzZUhpZ2hsaWdodChoaWdobGlnaHQ/OiBib29sZWFuKSB7XG4gIGNvbnN0IFtrZWVwSGlnaGxpZ2h0LCBzZXRLZWVwSGlnaGxpZ2h0XSA9IHVzZVN0YXRlKHRydWUpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0OiBhbnk7XG4gICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRLZWVwSGlnaGxpZ2h0KGZhbHNlKTtcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRLZWVwSGlnaGxpZ2h0KHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodCk7XG4gIH0sIFtoaWdobGlnaHRdKTtcblxuICByZXR1cm4ga2VlcEhpZ2hsaWdodCAmJiBoaWdobGlnaHQ7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFkZFJlc3RQYXJhbUJ1dHRvbihcbiAgcGFyYW1EZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxuICBvbkFkZFJlc3RQYXJhbTogKCkgPT4gdm9pZCxcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcixcbiAgcGFyYW1JbmRleDogbnVtYmVyLFxuICBzdHlsZXM6IE9wZXJhdGlvbkVkaXRvclN0eWxlc1xuKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5yZXN0UGFyYW19IGtleT17YCR7cGFyYW1JbmRleH0tMmB9PlxuICAgICAgPEJ1dHRvblxuICAgICAgICBzaXplPVwic21cIlxuICAgICAgICBpY29uPVwicGx1c1wiXG4gICAgICAgIHRpdGxlPXtgQWRkICR7cGFyYW1EZWYubmFtZX1gfVxuICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgb25DbGljaz17b25BZGRSZXN0UGFyYW19XG4gICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke29wZXJhdGlvbkluZGV4fS5hZGQtcmVzdC1wYXJhbWB9XG4gICAgICA+XG4gICAgICAgIHtwYXJhbURlZi5uYW1lfVxuICAgICAgPC9CdXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcixcbiAgcGFyYW1JbmRleDogbnVtYmVyLFxuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkXG4pIHtcbiAgaWYgKGRlZi5wYXJhbUNoYW5nZWRIYW5kbGVyKSB7XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uSW5kZXgsIGRlZi5wYXJhbUNoYW5nZWRIYW5kbGVyKHBhcmFtSW5kZXgsIG9wZXJhdGlvbiwgZGVmKSk7XG4gIH0gZWxzZSB7XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uSW5kZXgsIG9wZXJhdGlvbik7XG4gIH1cbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY2FyZDogY3NzKHtcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnksXG4gICAgICBib3JkZXI6IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLm1lZGl1bX1gLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICBjdXJzb3I6ICdncmFiJyxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgICAgbWFyZ2luQm90dG9tOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDFzIGVhc2UtaW4gMHMnLFxuICAgIH0pLFxuICAgIGNhcmRIaWdobGlnaHQ6IGNzcyh7XG4gICAgICBib3hTaGFkb3c6IGAwcHggMHB4IDRweCAwcHggJHt0aGVtZS5jb2xvcnMucHJpbWFyeS5ib3JkZXJ9YCxcbiAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5wcmltYXJ5LmJvcmRlcn1gLFxuICAgIH0pLFxuICAgIGluZm9JY29uOiBjc3Moe1xuICAgICAgbWFyZ2luTGVmdDogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgICc6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgbWFyZ2luOiB0aGVtZS5zcGFjaW5nKDEsIDEsIDAuNSwgMSksXG4gICAgICBkaXNwbGF5OiAndGFibGUnLFxuICAgIH0pLFxuICAgIHBhcmFtUm93OiBjc3Moe1xuICAgICAgbGFiZWw6ICdwYXJhbVJvdycsXG4gICAgICBkaXNwbGF5OiAndGFibGUtcm93JyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgIH0pLFxuICAgIHBhcmFtTmFtZTogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMCwgMSwgMCwgMCksXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgIGhlaWdodDogJzMycHgnLFxuICAgIH0pLFxuICAgIHBhcmFtVmFsdWU6IGNzcyh7XG4gICAgICBsYWJlbDogJ3BhcmFtVmFsdWUnLFxuICAgICAgZGlzcGxheTogJ3RhYmxlLWNlbGwnLFxuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgfSksXG4gICAgcmVzdFBhcmFtOiBjc3Moe1xuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygwLCAxLCAxLCAxKSxcbiAgICB9KSxcbiAgICBhcnJvdzogY3NzKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICByaWdodDogJy0xOHB4JyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9KSxcbiAgICBhcnJvd0xpbmU6IGNzcyh7XG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgd2lkdGg6ICc4cHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5jb2xvcnMuYm9yZGVyLnN0cm9uZyxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAnMTRweCcsXG4gICAgfSksXG4gICAgYXJyb3dBcnJvdzogY3NzKHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgYm9yZGVyVG9wOiBgNXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgIGJvcmRlckJvdHRvbTogYDVweCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICBib3JkZXJMZWZ0OiBgN3B4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5zdHJvbmd9YCxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAnMTBweCcsXG4gICAgfSksXG4gIH07XG59O1xuXG50eXBlIE9wZXJhdGlvbkVkaXRvclN0eWxlcyA9IFJldHVyblR5cGU8dHlwZW9mIGdldFN0eWxlcz47XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgcmVuZGVyTWFya2Rvd24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1hcmtkb3duPzogc3RyaW5nO1xuICBzdGVwTnVtYmVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPcGVyYXRpb25FeHBsYWluZWRCb3goeyB0aXRsZSwgc3RlcE51bWJlciwgbWFya2Rvd24sIGNoaWxkcmVuIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm94fT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3RlcE51bWJlcn0+e3N0ZXBOdW1iZXJ9PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJveElubmVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICAgIDxzcGFuPnt0aXRsZX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PlxuICAgICAgICAgIHttYXJrZG93biAmJiA8ZGl2IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogcmVuZGVyTWFya2Rvd24obWFya2Rvd24pIH19PjwvZGl2Pn1cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGJveDogY3NzKHtcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeSxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cygpLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBtYXJnaW5Cb3R0b206IHRoZW1lLnNwYWNpbmcoMC41KSxcbiAgICB9KSxcbiAgICBib3hJbm5lcjogY3NzKHtcbiAgICAgIG1hcmdpbkxlZnQ6IHRoZW1lLnNwYWNpbmcoNCksXG4gICAgfSksXG4gICAgc3RlcE51bWJlcjogY3NzKHtcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5zZWNvbmRhcnkubWFpbixcbiAgICAgIHdpZHRoOiAnMjBweCcsXG4gICAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnMTBweCcsXG4gICAgICBsZWZ0OiAnMTFweCcsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgfSksXG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBmb250RmFtaWx5OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHlNb25vc3BhY2UsXG4gICAgfSksXG4gICAgYm9keTogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICAncDpsYXN0LWNoaWxkJzoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICB9LFxuICAgICAgYToge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQubGluayxcbiAgICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnLFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBGbGV4SXRlbSB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIFNlbGVjdCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE9wZXJhdGlvbkluZm9CdXR0b24gfSBmcm9tICcuL09wZXJhdGlvbkluZm9CdXR0b24nO1xuaW1wb3J0IHsgVmlzdWFsUXVlcnlNb2RlbGxlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgZHJhZ0hhbmRsZVByb3BzOiBhbnk7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFN0YXRlIHtcbiAgaXNPcGVuPzogYm9vbGVhbjtcbiAgYWx0ZXJuYXRpdmVzPzogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4+O1xufVxuXG5leHBvcnQgY29uc3QgT3BlcmF0aW9uSGVhZGVyID0gUmVhY3QubWVtbzxQcm9wcz4oXG4gICh7IG9wZXJhdGlvbiwgZGVmLCBpbmRleCwgb25DaGFuZ2UsIG9uUmVtb3ZlLCBxdWVyeU1vZGVsbGVyLCBkcmFnSGFuZGxlUHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFN0YXRlPih7fSk7XG5cbiAgICBjb25zdCBvblRvZ2dsZVN3aXRjaGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlLmlzT3Blbikge1xuICAgICAgICBzZXRTdGF0ZSh7IC4uLnN0YXRlLCBpc09wZW46IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWx0ZXJuYXRpdmVzID0gcXVlcnlNb2RlbGxlclxuICAgICAgICAgIC5nZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoZGVmLmFsdGVybmF0aXZlc0tleSEpXG4gICAgICAgICAgLm1hcCgoYWx0KSA9PiAoeyBsYWJlbDogYWx0Lm5hbWUsIHZhbHVlOiBhbHQgfSkpO1xuICAgICAgICBzZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSwgYWx0ZXJuYXRpdmVzIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICB7IXN0YXRlLmlzT3BlbiAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxkaXYgey4uLmRyYWdIYW5kbGVQcm9wc30+e2RlZi5uYW1lID8/IGRlZi5pZH08L2Rpdj5cbiAgICAgICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3N0eWxlcy5vcGVyYXRpb25IZWFkZXJCdXR0b25zfSBvcGVyYXRpb24taGVhZGVyLXNob3ctb24taG92ZXJgfT5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGljb249XCJhbmdsZS1kb3duXCJcbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uVG9nZ2xlU3dpdGNoZXJ9XG4gICAgICAgICAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiQ2xpY2sgdG8gdmlldyBhbHRlcm5hdGl2ZSBvcGVyYXRpb25zXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPE9wZXJhdGlvbkluZm9CdXR0b24gZGVmPXtkZWZ9IG9wZXJhdGlvbj17b3BlcmF0aW9ufSAvPlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlKGluZGV4KX1cbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJSZW1vdmUgb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICB7c3RhdGUuaXNPcGVuICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlbGVjdFdyYXBwZXJ9PlxuICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgICAgICAgb3Blbk1lbnVPbkZvY3VzXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUmVwbGFjZSB3aXRoXCJcbiAgICAgICAgICAgICAgb3B0aW9ucz17c3RhdGUuYWx0ZXJuYXRpdmVzfVxuICAgICAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgICAgIG9uQ2xvc2VNZW51PXtvblRvZ2dsZVN3aXRjaGVyfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBPcGVyYXRpb24gc2hvdWxkIGV4aXN0IGlmIGl0IGlzIHNlbGVjdGFibGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RlZiA9IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKHZhbHVlLnZhbHVlLmlkKSE7XG4gICAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZE9wID0geyAuLi5vcGVyYXRpb24sIGlkOiB2YWx1ZS52YWx1ZS5pZCB9O1xuICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIGRlZi5jaGFuZ2VUeXBlSGFuZGxlciA/IGRlZi5jaGFuZ2VUeXBlSGFuZGxlcihjaGFuZ2VkT3AsIG5ld0RlZikgOiBjaGFuZ2VkT3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4pO1xuXG5PcGVyYXRpb25IZWFkZXIuZGlzcGxheU5hbWUgPSAnT3BlcmF0aW9uSGVhZGVyJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgYm9yZGVyQm90dG9tOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5tZWRpdW19YCxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMC41LCAwLjUsIDAuNSwgMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICcmOmhvdmVyIC5vcGVyYXRpb24taGVhZGVyLXNob3ctb24taG92ZXInOiBjc3Moe1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgfSksXG4gICAgfSksXG4gICAgb3BlcmF0aW9uSGVhZGVyQnV0dG9uczogY3NzKHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoWydvcGFjaXR5J10sIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0LFxuICAgICAgfSksXG4gICAgfSksXG4gICAgc2VsZWN0V3JhcHBlcjogY3NzKHtcbiAgICAgIHBhZGRpbmdSaWdodDogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgcmVuZGVyTWFya2Rvd24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEZsZXhJdGVtIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgUG9ydGFsLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUG9wcGVyVG9vbHRpcCB9IGZyb20gJ3JlYWN0LXBvcHBlci10b29sdGlwJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY7XG59XG5cbmV4cG9ydCBjb25zdCBPcGVyYXRpb25JbmZvQnV0dG9uID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgZGVmLCBvcGVyYXRpb24gfSkgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IFtzaG93LCBzZXRTaG93XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBnZXRUb29sdGlwUHJvcHMsIHNldFRvb2x0aXBSZWYsIHNldFRyaWdnZXJSZWYsIHZpc2libGUgfSA9IHVzZVBvcHBlclRvb2x0aXAoe1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgdmlzaWJsZTogc2hvdyxcbiAgICBvZmZzZXQ6IFswLCAxNl0sXG4gICAgb25WaXNpYmxlQ2hhbmdlOiBzZXRTaG93LFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHRyaWdnZXI6IFsnY2xpY2snXSxcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEJ1dHRvblxuICAgICAgICB0aXRsZT1cIkNsaWNrIHRvIHNob3cgZGVzY3JpcHRpb25cIlxuICAgICAgICByZWY9e3NldFRyaWdnZXJSZWZ9XG4gICAgICAgIGljb249XCJpbmZvLWNpcmNsZVwiXG4gICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAvPlxuICAgICAge3Zpc2libGUgJiYgKFxuICAgICAgICA8UG9ydGFsPlxuICAgICAgICAgIDxkaXYgcmVmPXtzZXRUb29sdGlwUmVmfSB7Li4uZ2V0VG9vbHRpcFByb3BzKCl9IGNsYXNzTmFtZT17c3R5bGVzLmRvY0JveH0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvY0JveEhlYWRlcn0+XG4gICAgICAgICAgICAgIDxzcGFuPntkZWYucmVuZGVyZXIob3BlcmF0aW9uLCBkZWYsICc8ZXhwcj4nKX08L3NwYW4+XG4gICAgICAgICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaG93KGZhbHNlKX1cbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJSZW1vdmUgb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5kb2NCb3hCb2R5fVxuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGdldE9wZXJhdGlvbkRvY3MoZGVmLCBvcGVyYXRpb24pIH19XG4gICAgICAgICAgICA+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvUG9ydGFsPlxuICAgICAgKX1cbiAgICA8Lz5cbiAgKTtcbn0pO1xuXG5PcGVyYXRpb25JbmZvQnV0dG9uLmRpc3BsYXlOYW1lID0gJ09wZXJhdGlvbkRvY3MnO1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBkb2NCb3g6IGNzcyh7XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5LFxuICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5zdHJvbmd9YCxcbiAgICAgIGJveFNoYWRvdzogdGhlbWUuc2hhZG93cy56MyxcbiAgICAgIG1heFdpZHRoOiAnNjAwcHgnLFxuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKCksXG4gICAgICB6SW5kZXg6IHRoZW1lLnpJbmRleC50b29sdGlwLFxuICAgIH0pLFxuICAgIGRvY0JveEhlYWRlcjogY3NzKHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5Lmg1LmZvbnRTaXplLFxuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlLFxuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIH0pLFxuICAgIGRvY0JveEJvZHk6IGNzcyh7XG4gICAgICAvLyBUaGUgbWFya2Rvd24gcGFyYWdyYXBoIGhhcyBhIG1hcmdpbkJvdHRvbSB0aGlzIHJlbW92ZXMgaXRcbiAgICAgIG1hcmdpbkJvdHRvbTogdGhlbWUuc3BhY2luZygtMSksXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgIH0pLFxuICAgIHNpZ25hdHVyZTogY3NzKHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZSxcbiAgICB9KSxcbiAgICBkcm9wZG93bjogY3NzKHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgIH0pLFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE9wZXJhdGlvbkRvY3MoZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pOiBzdHJpbmcge1xuICByZXR1cm4gcmVuZGVyTWFya2Rvd24oZGVmLmV4cGxhaW5IYW5kbGVyID8gZGVmLmV4cGxhaW5IYW5kbGVyKG9wLCBkZWYpIDogZGVmLmRvY3VtZW50YXRpb24gPz8gJ25vIGRvY3MnKTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIENhc2NhZGVyLCBDYXNjYWRlck9wdGlvbiwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERyYWdEcm9wQ29udGV4dCwgRHJvcHBhYmxlLCBEcm9wUmVzdWx0IH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5pbXBvcnQgeyB1c2VNb3VudGVkU3RhdGUsIHVzZVByZXZpb3VzIH0gZnJvbSAncmVhY3QtdXNlJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlXaXRoT3BlcmF0aW9ucywgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBPcGVyYXRpb25FZGl0b3IgfSBmcm9tICcuL09wZXJhdGlvbkVkaXRvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHM8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+IHtcbiAgcXVlcnk6IFQ7XG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGk7XG4gIG9uQ2hhbmdlOiAocXVlcnk6IFQpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIGV4cGxhaW5Nb2RlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkxpc3Q8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KHtcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIHF1ZXJ5TW9kZWxsZXIsXG4gIG9uQ2hhbmdlLFxuICBvblJ1blF1ZXJ5LFxufTogUHJvcHM8VD4pIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuICBjb25zdCB7IG9wZXJhdGlvbnMgfSA9IHF1ZXJ5O1xuXG4gIGNvbnN0IG9wc1RvSGlnaGxpZ2h0ID0gdXNlT3BlcmF0aW9uc0hpZ2hsaWdodChvcGVyYXRpb25zKTtcblxuICBjb25zdCBbY2FzY2FkZXJPcGVuLCBzZXRDYXNjYWRlck9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IG9uT3BlcmF0aW9uQ2hhbmdlID0gKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ub3BlcmF0aW9uc107XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKGluZGV4LCAxLCB1cGRhdGUpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIG9wZXJhdGlvbnM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5vcGVyYXRpb25zLnNsaWNlKDAsIGluZGV4KSwgLi4ub3BlcmF0aW9ucy5zbGljZShpbmRleCArIDEpXTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBvcGVyYXRpb25zOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICBjb25zdCBhZGRPcHRpb25zOiBDYXNjYWRlck9wdGlvbltdID0gcXVlcnlNb2RlbGxlci5nZXRDYXRlZ29yaWVzKCkubWFwKChjYXRlZ29yeSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogY2F0ZWdvcnksXG4gICAgICBsYWJlbDogY2F0ZWdvcnksXG4gICAgICBpdGVtczogcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnkpLm1hcCgob3BlcmF0aW9uKSA9PiAoe1xuICAgICAgICB2YWx1ZTogb3BlcmF0aW9uLmlkLFxuICAgICAgICBsYWJlbDogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgIGlzTGVhZjogdHJ1ZSxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBvbkFkZE9wZXJhdGlvbiA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgb3BlcmF0aW9uRGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYodmFsdWUpO1xuICAgIGlmICghb3BlcmF0aW9uRGVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uQ2hhbmdlKG9wZXJhdGlvbkRlZi5hZGRPcGVyYXRpb25IYW5kbGVyKG9wZXJhdGlvbkRlZiwgcXVlcnksIHF1ZXJ5TW9kZWxsZXIpKTtcbiAgICBzZXRDYXNjYWRlck9wZW4oZmFsc2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uRHJhZ0VuZCA9IChyZXN1bHQ6IERyb3BSZXN1bHQpID0+IHtcbiAgICBpZiAoIXJlc3VsdC5kZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm9wZXJhdGlvbnNdO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1cGRhdGVkTGlzdFtyZXN1bHQuc291cmNlLmluZGV4XTtcbiAgICB1cGRhdGVkTGlzdC5zcGxpY2UocmVzdWx0LnNvdXJjZS5pbmRleCwgMSk7XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKHJlc3VsdC5kZXN0aW5hdGlvbi5pbmRleCwgMCwgZWxlbWVudCk7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgb3BlcmF0aW9uczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25DYXNjYWRlckJsdXIgPSAoKSA9PiB7XG4gICAgc2V0Q2FzY2FkZXJPcGVuKGZhbHNlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBnYXA9ezF9IGRpcmVjdGlvbj1cImNvbHVtblwiPlxuICAgICAgPFN0YWNrIGdhcD17MX0+XG4gICAgICAgIHtvcGVyYXRpb25zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgIDxEcmFnRHJvcENvbnRleHQgb25EcmFnRW5kPXtvbkRyYWdFbmR9PlxuICAgICAgICAgICAgPERyb3BwYWJsZSBkcm9wcGFibGVJZD1cInNvcnRhYmxlLWZpZWxkLW1hcHBpbmdzXCIgZGlyZWN0aW9uPVwiaG9yaXpvbnRhbFwiPlxuICAgICAgICAgICAgICB7KHByb3ZpZGVkKSA9PiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5vcGVyYXRpb25MaXN0fSByZWY9e3Byb3ZpZGVkLmlubmVyUmVmfSB7Li4ucHJvdmlkZWQuZHJvcHBhYmxlUHJvcHN9PlxuICAgICAgICAgICAgICAgICAge29wZXJhdGlvbnMubWFwKChvcCwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPE9wZXJhdGlvbkVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgIGtleT17b3AuaWQgKyBpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICBxdWVyeU1vZGVsbGVyPXtxdWVyeU1vZGVsbGVyfVxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb249e29wfVxuICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbk9wZXJhdGlvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICBvblJlbW92ZT17b25SZW1vdmV9XG4gICAgICAgICAgICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQ9e29wc1RvSGlnaGxpZ2h0W2luZGV4XX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgICAge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9Ecm9wcGFibGU+XG4gICAgICAgICAgPC9EcmFnRHJvcENvbnRleHQ+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYWRkQnV0dG9ufT5cbiAgICAgICAgICB7Y2FzY2FkZXJPcGVuID8gKFxuICAgICAgICAgICAgPENhc2NhZGVyXG4gICAgICAgICAgICAgIG9wdGlvbnM9e2FkZE9wdGlvbnN9XG4gICAgICAgICAgICAgIG9uU2VsZWN0PXtvbkFkZE9wZXJhdGlvbn1cbiAgICAgICAgICAgICAgb25CbHVyPXtvbkNhc2NhZGVyQmx1cn1cbiAgICAgICAgICAgICAgYXV0b0ZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgICBhbHdheXNPcGVuPXt0cnVlfVxuICAgICAgICAgICAgICBoaWRlQWN0aXZlTGV2ZWxMYWJlbD17dHJ1ZX1cbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9eydTZWFyY2gnfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgPEJ1dHRvbiBpY29uPXsncGx1cyd9IHZhcmlhbnQ9eydzZWNvbmRhcnknfSBvbkNsaWNrPXsoKSA9PiBzZXRDYXNjYWRlck9wZW4odHJ1ZSl9IHRpdGxlPXsnQWRkIG9wZXJhdGlvbid9PlxuICAgICAgICAgICAgICBPcGVyYXRpb25zXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvU3RhY2s+XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGluZGV4ZXMgb2Ygb3BlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSBoaWdobGlnaHRlZC4gV2UgY2hlY2sgdGhlIGRpZmYgb2Ygb3BlcmF0aW9ucyBhZGRlZCBidXQgYXQgdGhlIHNhbWUgdGltZVxuICogd2Ugd2FudCB0byBoaWdobGlnaHQgb3BlcmF0aW9ucyBvbmx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlciwgc28gd2UgY2hlY2sgZm9yIG1vdW50ZWQgc3RhdGUgYW5kIGNhbGN1bGF0ZSB0aGUgZGlmZlxuICogb25seSBhZnRlci5cbiAqIEBwYXJhbSBvcGVyYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZU9wZXJhdGlvbnNIaWdobGlnaHQob3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW10pIHtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlTW91bnRlZFN0YXRlKCk7XG4gIGNvbnN0IHByZXZPcGVyYXRpb25zID0gdXNlUHJldmlvdXMob3BlcmF0aW9ucyk7XG5cbiAgaWYgKCFpc01vdW50ZWQoKSkge1xuICAgIHJldHVybiBvcGVyYXRpb25zLm1hcCgoKSA9PiBmYWxzZSk7XG4gIH1cblxuICBpZiAoIXByZXZPcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG9wZXJhdGlvbnMubWFwKCgpID0+IHRydWUpO1xuICB9XG5cbiAgbGV0IG5ld09wczogYm9vbGVhbltdID0gW107XG5cbiAgaWYgKHByZXZPcGVyYXRpb25zLmxlbmd0aCAtIDEgPT09IG9wZXJhdGlvbnMubGVuZ3RoICYmIG9wZXJhdGlvbnMuZXZlcnkoKG9wKSA9PiBwcmV2T3BlcmF0aW9ucy5pbmNsdWRlcyhvcCkpKSB7XG4gICAgLy8gSW4gY2FzZSB3ZSByZW1vdmUgb25lIG9wIGFuZCBkb2VzIG5vdCBjaGFuZ2UgYW55IG9wcyB0aGVuIGRvbid0IGhpZ2hsaWdodCBhbnl0aGluZy5cbiAgICByZXR1cm4gb3BlcmF0aW9ucy5tYXAoKCkgPT4gZmFsc2UpO1xuICB9XG4gIGlmIChwcmV2T3BlcmF0aW9ucy5sZW5ndGggKyAxID09PSBvcGVyYXRpb25zLmxlbmd0aCAmJiBwcmV2T3BlcmF0aW9ucy5ldmVyeSgob3ApID0+IG9wZXJhdGlvbnMuaW5jbHVkZXMob3ApKSkge1xuICAgIC8vIElmIHdlIGFkZCBhIHNpbmdsZSBvcCBqdXN0IGZpbmQgaXQgYW5kIGhpZ2hsaWdodCBqdXN0IHRoYXQuXG4gICAgY29uc3QgbmV3T3AgPSBvcGVyYXRpb25zLmZpbmQoKG9wKSA9PiAhcHJldk9wZXJhdGlvbnMuaW5jbHVkZXMob3ApKTtcbiAgICBuZXdPcHMgPSBvcGVyYXRpb25zLm1hcCgob3ApID0+IHtcbiAgICAgIHJldHVybiBvcCA9PT0gbmV3T3A7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBkaWZmIG9mIGFsbCBvcHMuXG4gICAgbmV3T3BzID0gb3BlcmF0aW9ucy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuICFpc1NhbWVPcChvcC5pZCwgcHJldk9wZXJhdGlvbnNbaW5kZXhdPy5pZCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld09wcztcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3Aob3AxPzogc3RyaW5nLCBvcDI/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIG9wMSA9PT0gb3AyIHx8IGBfXyR7b3AxfV9ieWAgPT09IG9wMiB8fCBvcDEgPT09IGBfXyR7b3AyfV9ieWA7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGhlYWRpbmc6IGNzcyh7XG4gICAgICBsYWJlbDogJ2hlYWRpbmcnLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgZm9udFdlaWdodDogdGhlbWUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFxuICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgIH0pLFxuICAgIG9wZXJhdGlvbkxpc3Q6IGNzcyh7XG4gICAgICBsYWJlbDogJ29wZXJhdGlvbkxpc3QnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleFdyYXA6ICd3cmFwJyxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9KSxcbiAgICBhZGRCdXR0b246IGNzcyh7XG4gICAgICBsYWJlbDogJ2FkZEJ1dHRvbicsXG4gICAgICB3aWR0aDogMTI2LFxuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygxKSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgT3BlcmF0aW9uRXhwbGFpbmVkQm94IH0gZnJvbSAnLi9PcGVyYXRpb25FeHBsYWluZWRCb3gnO1xuaW1wb3J0IHsgUXVlcnlXaXRoT3BlcmF0aW9ucywgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzPFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPiB7XG4gIHF1ZXJ5OiBUO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBleHBsYWluTW9kZT86IGJvb2xlYW47XG4gIHN0ZXBOdW1iZXI6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkxpc3RFeHBsYWluZWQ8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KHsgcXVlcnksIHF1ZXJ5TW9kZWxsZXIsIHN0ZXBOdW1iZXIgfTogUHJvcHM8VD4pIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3F1ZXJ5Lm9wZXJhdGlvbnMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYob3AuaWQpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgIHJldHVybiBgT3BlcmF0aW9uICR7b3AuaWR9IG5vdCBmb3VuZGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGl0bGUgPSBkZWYucmVuZGVyZXIob3AsIGRlZiwgJzxleHByPicpO1xuICAgICAgICBjb25zdCBib2R5ID0gZGVmLmV4cGxhaW5IYW5kbGVyID8gZGVmLmV4cGxhaW5IYW5kbGVyKG9wLCBkZWYpIDogZGVmLmRvY3VtZW50YXRpb24gPz8gJ25vIGRvY3MnO1xuXG4gICAgICAgIHJldHVybiA8T3BlcmF0aW9uRXhwbGFpbmVkQm94IHN0ZXBOdW1iZXI9e2luZGV4ICsgc3RlcE51bWJlcn0ga2V5PXtpbmRleH0gdGl0bGU9e3RpdGxlfSBtYXJrZG93bj17Ym9keX0gLz47XG4gICAgICB9KX1cbiAgICA8Lz5cbiAgKTtcbn1cbiIsImltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IENoZWNrYm94LCBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IEF1dG9TaXplSW5wdXQgfSBmcm9tICcuL0F1dG9TaXplSW5wdXQnO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4vb3BlcmF0aW9uVXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IoXG4gIHBhcmFtRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZlxuKTogQ29tcG9uZW50VHlwZTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzPiB7XG4gIGlmIChwYXJhbURlZi5lZGl0b3IpIHtcbiAgICByZXR1cm4gcGFyYW1EZWYuZWRpdG9yO1xuICB9XG5cbiAgaWYgKHBhcmFtRGVmLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gU2VsZWN0SW5wdXRQYXJhbUVkaXRvcjtcbiAgfVxuXG4gIHN3aXRjaCAocGFyYW1EZWYudHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xJbnB1dFBhcmFtRWRpdG9yO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFNpbXBsZUlucHV0UGFyYW1FZGl0b3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gU2ltcGxlSW5wdXRQYXJhbUVkaXRvcihwcm9wczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICBpZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChwcm9wcy5vcGVyYXRpb25JbmRleCwgcHJvcHMuaW5kZXgpfVxuICAgICAgZGVmYXVsdFZhbHVlPXtwcm9wcy52YWx1ZT8udG9TdHJpbmcoKX1cbiAgICAgIG1pbldpZHRoPXtwcm9wcy5wYXJhbURlZi5taW5XaWR0aH1cbiAgICAgIHBsYWNlaG9sZGVyPXtwcm9wcy5wYXJhbURlZi5wbGFjZWhvbGRlcn1cbiAgICAgIHRpdGxlPXtwcm9wcy5wYXJhbURlZi5kZXNjcmlwdGlvbn1cbiAgICAgIG9uQ29tbWl0Q2hhbmdlPXsoZXZ0KSA9PiB7XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKHByb3BzLmluZGV4LCBldnQuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG5cbmZ1bmN0aW9uIEJvb2xJbnB1dFBhcmFtRWRpdG9yKHByb3BzOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPENoZWNrYm94XG4gICAgICBpZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChwcm9wcy5vcGVyYXRpb25JbmRleCwgcHJvcHMuaW5kZXgpfVxuICAgICAgdmFsdWU9e3Byb3BzLnZhbHVlIGFzIGJvb2xlYW59XG4gICAgICBvbkNoYW5nZT17KGV2dCkgPT4gcHJvcHMub25DaGFuZ2UocHJvcHMuaW5kZXgsIGV2dC5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfVxuICAgIC8+XG4gICk7XG59XG5cbmZ1bmN0aW9uIFNlbGVjdElucHV0UGFyYW1FZGl0b3Ioe1xuICBwYXJhbURlZixcbiAgdmFsdWUsXG4gIGluZGV4LFxuICBvcGVyYXRpb25JbmRleCxcbiAgb25DaGFuZ2UsXG59OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzKSB7XG4gIGxldCBzZWxlY3RPcHRpb25zID0gcGFyYW1EZWYub3B0aW9ucyBhcyBBcnJheTxTZWxlY3RhYmxlVmFsdWU8YW55Pj47XG5cbiAgaWYgKCFzZWxlY3RPcHRpb25zWzBdPy5sYWJlbCkge1xuICAgIHNlbGVjdE9wdGlvbnMgPSBwYXJhbURlZi5vcHRpb25zIS5tYXAoKG9wdGlvbikgPT4gKHtcbiAgICAgIGxhYmVsOiBvcHRpb24udG9TdHJpbmcoKSxcbiAgICAgIHZhbHVlOiBvcHRpb24gYXMgc3RyaW5nLFxuICAgIH0pKTtcbiAgfVxuXG4gIGxldCB2YWx1ZU9wdGlvbiA9IHNlbGVjdE9wdGlvbnMuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gdmFsdWUpID8/IHRvT3B0aW9uKHZhbHVlIGFzIHN0cmluZyk7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VsZWN0XG4gICAgICBpZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChvcGVyYXRpb25JbmRleCwgaW5kZXgpfVxuICAgICAgbWVudVNob3VsZFBvcnRhbFxuICAgICAgdmFsdWU9e3ZhbHVlT3B0aW9ufVxuICAgICAgb3B0aW9ucz17c2VsZWN0T3B0aW9uc31cbiAgICAgIHBsYWNlaG9sZGVyPXtwYXJhbURlZi5wbGFjZWhvbGRlcn1cbiAgICAgIGFsbG93Q3VzdG9tVmFsdWU9e3RydWV9XG4gICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiBvbkNoYW5nZShpbmRleCwgdmFsdWUudmFsdWUhKX1cbiAgICAvPlxuICApO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uc0VkaXRvclJvdyh7IGNoaWxkcmVuIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm9vdH0+XG4gICAgICA8U3RhY2sgZ2FwPXsxfT57Y2hpbGRyZW59PC9TdGFjaz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcm9vdDogY3NzKHtcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSwgMSwgMCwgMSksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IFJhZGlvQnV0dG9uR3JvdXAsIFRhZyB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBtb2RlOiBRdWVyeUVkaXRvck1vZGU7XG4gIG9uQ2hhbmdlOiAobW9kZTogUXVlcnlFZGl0b3JNb2RlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBlZGl0b3JNb2RlcyA9IFtcbiAgeyBsYWJlbDogJ0V4cGxhaW4nLCB2YWx1ZTogUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gfSxcbiAge1xuICAgIGxhYmVsOiAnQnVpbGRlcicsXG4gICAgdmFsdWU6IFF1ZXJ5RWRpdG9yTW9kZS5CdWlsZGVyLFxuICAgIGNvbXBvbmVudDogKCkgPT4gKFxuICAgICAgPFRhZ1xuICAgICAgICBjbGFzc05hbWU9e2Nzcyh7XG4gICAgICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgICAgIHBhZGRpbmc6ICcxcHggNXB4JyxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndGV4dC1ib3R0b20nLFxuICAgICAgICB9KX1cbiAgICAgICAgbmFtZT17J0JldGEnfVxuICAgICAgICBjb2xvckluZGV4PXsxfVxuICAgICAgLz5cbiAgICApLFxuICB9LFxuICB7IGxhYmVsOiAnQ29kZScsIHZhbHVlOiBRdWVyeUVkaXRvck1vZGUuQ29kZSB9LFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIFF1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSh7IG1vZGUsIG9uQ2hhbmdlIH06IFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBkYXRhLXRlc3RpZD17J1F1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSd9PlxuICAgICAgPFJhZGlvQnV0dG9uR3JvdXAgb3B0aW9ucz17ZWRpdG9yTW9kZXN9IHNpemU9XCJzbVwiIHZhbHVlPXttb2RlfSBvbkNoYW5nZT17b25DaGFuZ2V9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEljb24sIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyB1c2VUb2dnbGUgfSBmcm9tICdyZWFjdC11c2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgY29sbGFwc2VkSW5mbzogc3RyaW5nW107XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeU9wdGlvbkdyb3VwKHsgdGl0bGUsIGNoaWxkcmVuLCBjb2xsYXBzZWRJbmZvIH06IFByb3BzKSB7XG4gIGNvbnN0IFtpc09wZW4sIHRvZ2dsZU9wZW5dID0gdXNlVG9nZ2xlKGZhbHNlKTtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGdhcD17MH0gZGlyZWN0aW9uPVwiY29sdW1uXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0gb25DbGljaz17dG9nZ2xlT3Blbn0gdGl0bGU9XCJDbGljayB0byBlZGl0IG9wdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50b2dnbGV9PlxuICAgICAgICAgIDxJY29uIG5hbWU9e2lzT3BlbiA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCd9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aDYgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9Pnt0aXRsZX08L2g2PlxuICAgICAgICB7IWlzT3BlbiAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kZXNjcmlwdGlvbn0+XG4gICAgICAgICAgICB7Y29sbGFwc2VkSW5mby5tYXAoKHgsIGkpID0+IChcbiAgICAgICAgICAgICAgPHNwYW4ga2V5PXtpfT57eH08L3NwYW4+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICAge2lzT3BlbiAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PntjaGlsZHJlbn08L2Rpdj59XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgc3dpdGNoTGFiZWw6IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnksXG4gICAgICB9LFxuICAgIH0pLFxuICAgIGhlYWRlcjogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgYWxpZ25JdGVtczogJ2Jhc2VsaW5lJyxcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5lbXBoYXNpemUodGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeSwgMC4wMyksXG4gICAgICB9LFxuICAgIH0pLFxuICAgIHRpdGxlOiBjc3Moe1xuICAgICAgZmxleEdyb3c6IDEsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICBtYXJnaW46IDAsXG4gICAgfSksXG4gICAgZGVzY3JpcHRpb246IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgfSksXG4gICAgYm9keTogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIHBhZGRpbmdUb3A6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBmbGV4V3JhcDogJ3dyYXAnLFxuICAgIH0pLFxuICAgIHRvZ2dsZTogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBtYXJnaW5SaWdodDogYCR7dGhlbWUuc3BhY2luZygxKX1gLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNhcGl0YWxpemUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlLFxuICBRdWVyeVdpdGhPcGVyYXRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjJztcbmltcG9ydCB7IExhYmVsUGFyYW1FZGl0b3IgfSBmcm9tICcuLi9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgcGx1cmFsaXplIGZyb20gJ3BsdXJhbGl6ZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvblJlbmRlcmVyTGVmdChtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFyYW1zID0gcmVuZGVyUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwcik7XG4gIGNvbnN0IHN0ciA9IG1vZGVsLmlkICsgJygnO1xuXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICBwYXJhbXMucHVzaChpbm5lckV4cHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIHBhcmFtcy5qb2luKCcsICcpICsgJyknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25SZW5kZXJlclJpZ2h0KG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSByZW5kZXJQYXJhbXMobW9kZWwsIGRlZiwgaW5uZXJFeHByKTtcbiAgY29uc3Qgc3RyID0gbW9kZWwuaWQgKyAnKCc7XG5cbiAgaWYgKGlubmVyRXhwcikge1xuICAgIHBhcmFtcy51bnNoaWZ0KGlubmVyRXhwcik7XG4gIH1cblxuICByZXR1cm4gc3RyICsgcGFyYW1zLmpvaW4oJywgJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmcsXG4gIHJlbmRlckxlZnQ6IGJvb2xlYW5cbikge1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgYENhbm5vdCByZW5kZXIgYSBmdW5jdGlvbiB3aXRoIHBhcmFtcyBvZiBsZW5ndGggWyR7ZGVmLnBhcmFtcy5sZW5ndGh9XWA7XG4gIH1cblxuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnNW0nO1xuXG4gIC8vIE5leHQgZnJhbWUgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLCBidXQgZ2V0IHJpZCBvZiB0aGUgZmlyc3Qgb25lIGJlY2F1c2UgaXQncyB1c2VkIHRvIG1vdmUgdGhlXG4gIC8vIGluc3RhbnQgdmVjdG9yIGludG8gYSByYW5nZSB2ZWN0b3IuXG4gIGNvbnN0IHBhcmFtcyA9IHJlbmRlclBhcmFtcyhcbiAgICB7XG4gICAgICAuLi5tb2RlbCxcbiAgICAgIHBhcmFtczogbW9kZWwucGFyYW1zLnNsaWNlKDEpLFxuICAgIH0sXG4gICAge1xuICAgICAgLi4uZGVmLFxuICAgICAgcGFyYW1zOiBkZWYucGFyYW1zLnNsaWNlKDEpLFxuICAgICAgZGVmYXVsdFBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMuc2xpY2UoMSksXG4gICAgfSxcbiAgICBpbm5lckV4cHJcbiAgKTtcblxuICBjb25zdCBzdHIgPSBtb2RlbC5pZCArICcoJztcblxuICAvLyBEZXBlbmRpbmcgb24gdGhlIHJlbmRlckxlZnQgdmFyaWFibGUsIHJlbmRlciBwYXJhbWV0ZXJzIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gIC8vIHJlbmRlckxlZnQgPT09IHRydWUgKHJlbmRlckxlZnQpID0+IChwYXJhbTEsIHBhcmFtMiwgcmFuZ2VWZWN0b3JbLi4uXSlcbiAgLy8gcmVuZGVyTGVmdCA9PT0gZmFsc2UgKHJlbmRlclJpZ2h0KSA9PiAocmFuZ2VWZWN0b3JbLi4uXSwgcGFyYW0xLCBwYXJhbTIpXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICByZW5kZXJMZWZ0ID8gcGFyYW1zLnB1c2goYCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV1gKSA6IHBhcmFtcy51bnNoaWZ0KGAke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dYCk7XG4gIH1cblxuICAvLyBzdGljayBldmVyeXRoaW5nIHRvZ2V0aGVyXG4gIHJldHVybiBzdHIgKyBwYXJhbXMuam9pbignLCAnKSArICcpJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIHJldHVybiByYW5nZVJlbmRlcmVyV2l0aFBhcmFtcyhtb2RlbCwgZGVmLCBpbm5lckV4cHIsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyhcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pIHtcbiAgcmV0dXJuIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwciwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBhcmFtcyhtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChtb2RlbC5wYXJhbXMgPz8gW10pLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW2luZGV4XTtcbiAgICBpZiAocGFyYW1EZWYudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBUKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFsuLi5xdWVyeS5vcGVyYXRpb25zLCBuZXdPcGVyYXRpb25dLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShmdW5jTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBjYXBpdGFsaXplKGZ1bmNOYW1lLnJlcGxhY2UoL18vZywgJyAnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4OiBudW1iZXIsIHBhcmFtSW5kZXg6IG51bWJlcikge1xuICByZXR1cm4gYG9wZXJhdGlvbnMuJHtvcGVyYXRpb25JbmRleH0ucGFyYW0uJHtwYXJhbUluZGV4fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZVZlY3RvclBhcmFtRGVmKHdpdGhSYXRlSW50ZXJ2YWwgPSBmYWxzZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIHtcbiAgY29uc3QgcGFyYW06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmID0ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uczogW1xuICAgICAge1xuICAgICAgICBsYWJlbDogJyRfX2ludGVydmFsJyxcbiAgICAgICAgdmFsdWU6ICckX19pbnRlcnZhbCcsXG4gICAgICAgIC8vIHRvb2x0aXA6ICdEeW5hbWljIGludGVydmFsIGJhc2VkIG9uIG1heCBkYXRhIHBvaW50cywgc2NyYXBlIGFuZCBtaW4gaW50ZXJ2YWwnLFxuICAgICAgfSxcbiAgICAgIHsgbGFiZWw6ICcxbScsIHZhbHVlOiAnMW0nIH0sXG4gICAgICB7IGxhYmVsOiAnNW0nLCB2YWx1ZTogJzVtJyB9LFxuICAgICAgeyBsYWJlbDogJzEwbScsIHZhbHVlOiAnMTBtJyB9LFxuICAgICAgeyBsYWJlbDogJzFoJywgdmFsdWU6ICcxaCcgfSxcbiAgICAgIHsgbGFiZWw6ICcyNGgnLCB2YWx1ZTogJzI0aCcgfSxcbiAgICBdLFxuICB9O1xuXG4gIGlmICh3aXRoUmF0ZUludGVydmFsKSB7XG4gICAgKHBhcmFtLm9wdGlvbnMgYXMgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+KS51bnNoaWZ0KHtcbiAgICAgIGxhYmVsOiAnJF9fcmF0ZV9pbnRlcnZhbCcsXG4gICAgICB2YWx1ZTogJyRfX3JhdGVfaW50ZXJ2YWwnLFxuICAgICAgLy8gdG9vbHRpcDogJ0Fsd2F5cyBhYm92ZSA0eCBzY3JhcGUgaW50ZXJ2YWwnLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2hhcmVkIGJldHdlZW4gUHJvbWV0aGV1cyBhbmQgTG9raSB2YXJpYW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb248VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KFxuICBuYW1lOiBzdHJpbmcsXG4gIG92ZXJyaWRlczogUGFydGlhbDxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+ID0ge31cbik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3Qgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBbXG4gICAge1xuICAgICAgaWQ6IG5hbWUsXG4gICAgICBuYW1lOiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnQnkgbGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlc3RQYXJhbTogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3BsYWluIGFnZ3JlZ2F0aW9ucycsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQWdncmVnYXRpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0T25MYWJlbEFkZGVkSGFuZGxlcihgX18ke25hbWV9X2J5YCksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJycpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogYF9fJHtuYW1lfV9ieWAsXG4gICAgICBuYW1lOiBgJHtnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpfSBieWAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyKG5hbWUpLFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIobmFtZSksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJ2J5JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICAgIGhpZGVGcm9tTGlzdDogdHJ1ZSxcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBgX18ke25hbWV9X3dpdGhvdXRgLFxuICAgICAgbmFtZTogYCR7Z2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKX0gd2l0aG91dGAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25XaXRob3V0UmVuZGVyZXIobmFtZSksXG4gICAgICBwYXJhbUNoYW5nZWRIYW5kbGVyOiBnZXRMYXN0TGFiZWxSZW1vdmVkSGFuZGxlcihuYW1lKSxcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiBnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lcihuYW1lLCAnd2l0aG91dCcpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICBoaWRlRnJvbUxpc3Q6IHRydWUsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgXTtcblxuICByZXR1cm4gb3BlcmF0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFxuICBuYW1lOiBzdHJpbmcsXG4gIHBhcmFtc0RlZjogeyBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW107IGRlZmF1bHRQYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXSB9LFxuICBvdmVycmlkZXM6IFBhcnRpYWw8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPiA9IHt9XG4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihuYW1lLCBvdmVycmlkZXMpO1xuICBvcGVyYXRpb25zWzBdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzFdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzJdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzBdLmRlZmF1bHRQYXJhbXMgPSBwYXJhbXNEZWYuZGVmYXVsdFBhcmFtcztcbiAgb3BlcmF0aW9uc1sxXS5kZWZhdWx0UGFyYW1zID0gWy4uLnBhcmFtc0RlZi5kZWZhdWx0UGFyYW1zLCAnJ107XG4gIG9wZXJhdGlvbnNbMl0uZGVmYXVsdFBhcmFtcyA9IFsuLi5wYXJhbXNEZWYuZGVmYXVsdFBhcmFtcywgJyddO1xuICBvcGVyYXRpb25zWzFdLnJlbmRlcmVyID0gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihuYW1lKTtcbiAgb3BlcmF0aW9uc1syXS5yZW5kZXJlciA9IGdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIobmFtZSk7XG4gIHJldHVybiBvcGVyYXRpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXIoYWdncmVnYXRpb246IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25SZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7YWdncmVnYXRpb259IGJ5KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uV2l0aG91dFJlbmRlcmVyKGFnZ3JlZ2F0aW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFnZ3JlZ2F0aW9uUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke2FnZ3JlZ2F0aW9ufSB3aXRob3V0KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbi8qKlxuICogVmVyeSBzaW1wbGUgcG9jIGltcGxlbWVudGF0aW9uLCBuZWVkcyB0byBiZSBtb2RpZmllZCB0byBzdXBwb3J0IGFsbCBhZ2dyZWdhdGlvbiBvcGVyYXRvcnNcbiAqL1xuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25FeHBsYWluZXIoYWdncmVnYXRpb25OYW1lOiBzdHJpbmcsIG1vZGU6ICdieScgfCAnd2l0aG91dCcgfCAnJykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25FeHBsYWluZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikge1xuICAgIGNvbnN0IGxhYmVscyA9IG1vZGVsLnBhcmFtcy5tYXAoKGxhYmVsKSA9PiBgXFxgJHtsYWJlbH1cXGBgKS5qb2luKCcgYW5kICcpO1xuICAgIGNvbnN0IGxhYmVsV29yZCA9IHBsdXJhbGl6ZSgnbGFiZWwnLCBtb2RlbC5wYXJhbXMubGVuZ3RoKTtcblxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnYnknOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgZGltZW5zaW9ucyB3aGlsZSBwcmVzZXJ2aW5nICR7bGFiZWxXb3JkfSAke2xhYmVsc30uYDtcbiAgICAgIGNhc2UgJ3dpdGhvdXQnOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgdGhlIGRpbWVuc2lvbnMgJHtsYWJlbHN9LiBBbGwgb3RoZXIgbGFiZWxzIGFyZSBwcmVzZXJ2ZWQuYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgQ2FsY3VsYXRlcyAke2FnZ3JlZ2F0aW9uTmFtZX0gb3ZlciB0aGUgZGltZW5zaW9ucy5gO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihhZ2dyZWdhdGlvbjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZ2dyZWdhdGlvblJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICAgIGZ1bmN0aW9uIG1hcFR5cGUocDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFxcXCIke3B9XFxcImA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDAsIC0xKTtcbiAgICBjb25zdCByZXN0UGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDEpO1xuICAgIHJldHVybiBgJHthZ2dyZWdhdGlvbn0gYnkoJHtyZXN0UGFyYW1zLmpvaW4oJywgJyl9KSAoJHtwYXJhbXMubWFwKG1hcFR5cGUpLmpvaW4oJywgJyl9LCAke2lubmVyRXhwcn0pYDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdHJhbnNmb3JtIG9wZXJhdGlvbnMgd2l0aG91dCBsYWJlbHMgdG8gdGhlaXIgcGxhbiBhZ2dyZWdhdGlvbiBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIoY2hhbmdlVG9PcGVyYXRpb25JZDogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvblBhcmFtQ2hhbmdlZChpbmRleDogbnVtYmVyLCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZikge1xuICAgIC8vIElmIGRlZmluaXRpb24gaGFzIG1vcmUgcGFyYW1zIHRoZW4gaXMgZGVmaW5lZCB0aGVyZSBhcmUgbm8gb3B0aW9uYWwgcmVzdCBwYXJhbXMgYW55bW9yZS5cbiAgICAvLyBXZSB0aGVuIHRyYW5zZm9ybSB0aGlzIG9wZXJhdGlvbiBpbnRvIGEgZGlmZmVyZW50IG9uZVxuICAgIGlmIChvcC5wYXJhbXMubGVuZ3RoIDwgZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPbkxhYmVsQWRkZWRIYW5kbGVyKGNoYW5nZVRvT3BlcmF0aW9uSWQ6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gb25QYXJhbUNoYW5nZWQoaW5kZXg6IG51bWJlciwgb3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIHRoZSBsYWJlbCBwYXJhbS4gQXMgaXQncyBvcHRpb25hbCB0aGUgYWdncmVnYXRpb24gY2FuIGhhdmUgb25lIGxlc3MsIHdoaWNoIGlzIHRoZVxuICAgIC8vIGNhc2Ugb2YganVzdCBzaW1wbGUgYWdncmVnYXRpb24gd2l0aG91dCBsYWJlbC4gV2hlbiB1c2VyIGFkZHMgdGhlIGxhYmVsIGl0IG5vdyBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIHBhcmFtc1xuICAgIC8vIGFzIGl0J3MgZGVmaW5pdGlvbiwgYW5kIG5vdyB3ZSBjYW4gY2hhbmdlIGl0IHRvIGl0J3MgYF9ieWAgdmFyaWFudC5cbiAgICBpZiAob3AucGFyYW1zLmxlbmd0aCA9PT0gZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcDtcbiAgfTtcbn1cbiIsImltcG9ydCB7IFN5bnRheE5vZGUsIFRyZWVDdXJzb3IgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBUaGlzIGlzIHVzZWQgZm9yIGVycm9yIHR5cGUgZm9yIHNvbWUgcmVhc29uXG5leHBvcnQgY29uc3QgRXJyb3JOYW1lID0gJ+KaoCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWZ0TW9zdENoaWxkKGN1cjogU3ludGF4Tm9kZSk6IFN5bnRheE5vZGUge1xuICByZXR1cm4gY3VyLmZpcnN0Q2hpbGQgPyBnZXRMZWZ0TW9zdENoaWxkKGN1ci5maXJzdENoaWxkKSA6IGN1cjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiBnZXRTdHJpbmcoZXhwciwgbm9kZSksXG4gICAgLy8gVE9ETzogdGhpcyBhcmUgcG9zaXRpb25zIGluIHRoZSBzdHJpbmcgd2l0aCB0aGUgcmVwbGFjZWQgdmFyaWFibGVzLiBNZWFucyBpdCBjYW5ub3QgYmUgdXNlZCB0byBzaG93IGV4YWN0XG4gICAgLy8gIHBsYWNlbWVudCBvZiB0aGUgZXJyb3IgZm9yIHRoZSB1c2VyLiBXZSBuZWVkIHNvbWUgdHJhbnNsYXRpb24gdGFibGUgdG8gcG9zaXRpb25zIGJlZm9yZSB0aGUgdmFyaWFibGVcbiAgICAvLyAgcmVwbGFjZS5cbiAgICBmcm9tOiBub2RlLmZyb20sXG4gICAgdG86IG5vZGUudG8sXG4gICAgcGFyZW50VHlwZTogbm9kZS5wYXJlbnQ/Lm5hbWUsXG4gIH07XG59XG5cbi8vIFRha2VuIGZyb20gdGVtcGxhdGVfc3J2LCBidXQgY29waWVkIHNvIHRvIG5vdCBtZXNzIHdpdGggdGhlIHJlZ2V4LmluZGV4IHdoaWNoIGlzIG1hbmlwdWxhdGVkIGluIHRoZSBzZXJ2aWNlXG4vKlxuICogVGhpcyByZWdleCBtYXRjaGVzIDMgdHlwZXMgb2YgdmFyaWFibGUgcmVmZXJlbmNlIHdpdGggYW4gb3B0aW9uYWwgZm9ybWF0IHNwZWNpZmllclxuICogXFwkKFxcdyspICAgICAgICAgICAgICAgICAgICAgICAgICAkdmFyMVxuICogXFxbXFxbKFtcXHNcXFNdKz8pKD86OihcXHcrKSk/XFxdXFxdICAgIFtbdmFyMl1dIG9yIFtbdmFyMjpmbXQyXV1cbiAqIFxcJHsoXFx3KykoPzo6KFxcdyspKT99ICAgICAgICAgICAgICR7dmFyM30gb3IgJHt2YXIzOmZtdDN9XG4gKi9cbmNvbnN0IHZhcmlhYmxlUmVnZXggPSAvXFwkKFxcdyspfFxcW1xcWyhbXFxzXFxTXSs/KSg/OjooXFx3KykpP1xcXVxcXXxcXCR7KFxcdyspKD86XFwuKFteOl5cXH1dKykpPyg/OjooW15cXH1dKykpP30vZztcblxuLyoqXG4gKiBBcyB2YXJpYWJsZXMgd2l0aCAkIGFyZSBjcmVhdGluZyBwYXJzaW5nIGVycm9ycywgd2UgZmlyc3QgcmVwbGFjZSB0aGVtIHdpdGggbWFnaWMgc3RyaW5nIHRoYXQgaXMgcGFyc2FibGUgYW5kIGF0XG4gKiB0aGUgc2FtZSB0aW1lIHdlIGNhbiBnZXQgdGhlIHZhcmlhYmxlIGFuZCBpdCdzIGZvcm1hdCBiYWNrIGZyb20gaXQuXG4gKiBAcGFyYW0gZXhwclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVZhcmlhYmxlcyhleHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGV4cHIucmVwbGFjZSh2YXJpYWJsZVJlZ2V4LCAobWF0Y2gsIHZhcjEsIHZhcjIsIGZtdDIsIHZhcjMsIGZpZWxkUGF0aCwgZm10MykgPT4ge1xuICAgIGNvbnN0IGZtdCA9IGZtdDIgfHwgZm10MztcbiAgICBsZXQgdmFyaWFibGUgPSB2YXIxO1xuICAgIGxldCB2YXJUeXBlID0gJzAnO1xuXG4gICAgaWYgKHZhcjIpIHtcbiAgICAgIHZhcmlhYmxlID0gdmFyMjtcbiAgICAgIHZhclR5cGUgPSAnMSc7XG4gICAgfVxuXG4gICAgaWYgKHZhcjMpIHtcbiAgICAgIHZhcmlhYmxlID0gdmFyMztcbiAgICAgIHZhclR5cGUgPSAnMic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBfX1ZfJHt2YXJUeXBlfV9fYCArIHZhcmlhYmxlICsgJ19fVl9fJyArIChmbXQgPyAnX19GX18nICsgZm10ICsgJ19fRl9fJyA6ICcnKTtcbiAgfSk7XG59XG5cbmNvbnN0IHZhclR5cGVGdW5jID0gW1xuICAodjogc3RyaW5nLCBmPzogc3RyaW5nKSA9PiBgXFwkJHt2fWAsXG4gICh2OiBzdHJpbmcsIGY/OiBzdHJpbmcpID0+IGBbWyR7dn0ke2YgPyBgOiR7Zn1gIDogJyd9XV1gLFxuICAodjogc3RyaW5nLCBmPzogc3RyaW5nKSA9PiBgXFwkXFx7JHt2fSR7ZiA/IGA6JHtmfWAgOiAnJ31cXH1gLFxuXTtcblxuLyoqXG4gKiBHZXQgYmFjayB0aGUgdGV4dCB3aXRoIHZhcmlhYmxlcyBpbiB0aGVpciBvcmlnaW5hbCBmb3JtYXQuXG4gKiBAcGFyYW0gZXhwclxuICovXG5mdW5jdGlvbiByZXR1cm5WYXJpYWJsZXMoZXhwcjogc3RyaW5nKSB7XG4gIHJldHVybiBleHByLnJlcGxhY2UoL19fVl8oXFxkKV9fKC4rPylfX1ZfXyg/Ol9fRl9fKFxcdyspX19GX18pPy9nLCAobWF0Y2gsIHR5cGUsIHYsIGYpID0+IHtcbiAgICByZXR1cm4gdmFyVHlwZUZ1bmNbcGFyc2VJbnQodHlwZSwgMTApXSh2LCBmKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhY3R1YWwgc3RyaW5nIG9mIHRoZSBleHByZXNzaW9uLiBUaGF0IGlzIG5vdCBzdG9yZWQgaW4gdGhlIHRyZWUgc28gd2UgaGF2ZSB0byBnZXQgdGhlIGluZGV4ZXMgZnJvbSB0aGUgbm9kZVxuICogYW5kIHRoZW4gYmFzZWQgb24gdGhhdCBnZXQgaXQgZnJvbSB0aGUgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaW5nKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSB8IFRyZWVDdXJzb3IgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcmV0dXJuVmFyaWFibGVzKGV4cHIuc3Vic3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50bykpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBzaW1wbGUgc2NhbGFyIGJpbmFyeSBvcCBvYmplY3QuXG4gKiBAcGFyYW0gb3BEZWYgLSBkZWZpbml0aW9uIG9mIHRoZSBvcCB0byBiZSBjcmVhdGVkXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIG51bWJlck5vZGUgLSB0aGUgbm9kZSBmb3IgdGhlIHNjYWxhclxuICogQHBhcmFtIGhhc0Jvb2wgLSB3aGV0aGVyIG9wZXJhdGlvbiBoYXMgYSBib29sIG1vZGlmaWVyLiBJcyB1c2VkIG9ubHkgZm9yIG9wcyBmb3Igd2hpY2ggaXQgbWFrZXMgc2Vuc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQmluT3AoXG4gIG9wRGVmOiB7IGlkOiBzdHJpbmc7IGNvbXBhcmlzb24/OiBib29sZWFuIH0sXG4gIGV4cHI6IHN0cmluZyxcbiAgbnVtYmVyTm9kZTogU3ludGF4Tm9kZSxcbiAgaGFzQm9vbDogYm9vbGVhblxuKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uIHtcbiAgY29uc3QgcGFyYW1zOiBhbnlbXSA9IFtwYXJzZUZsb2F0KGdldFN0cmluZyhleHByLCBudW1iZXJOb2RlKSldO1xuICBpZiAob3BEZWYuY29tcGFyaXNvbikge1xuICAgIHBhcmFtcy5wdXNoKGhhc0Jvb2wpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IG9wRGVmLmlkLFxuICAgIHBhcmFtcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgYWxsIG5vZGVzIHdpdGggdHlwZSBpbiB0aGUgdHJlZS4gVGhpcyB0cmF2ZXJzZXMgdGhlIHRyZWUgc28gaXQgaXMgc2FmZSBvbmx5IHdoZW4geW91IGtub3cgdGhlcmUgc2hvdWxkbid0IGJlXG4gKiB0b28gbXVjaCBuZXN0aW5nIGJ1dCB5b3UganVzdCB3YW50IHRvIHNraXAgc29tZSBvZiB0aGUgd3JhcHBlcnMuIEZvciBleGFtcGxlIGdldHRpbmcgZnVuY3Rpb24gYXJncyB0aGlzIHdheSB3b3VsZFxuICogbm90IGJlIHNhZmUgaXMgaXQgd291bGQgYWxzbyBmaW5kIGFyZ3VtZW50cyBvZiBuZXN0ZWQgZnVuY3Rpb25zLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBjdXJcbiAqIEBwYXJhbSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxCeVR5cGUoZXhwcjogc3RyaW5nLCBjdXI6IFN5bnRheE5vZGUsIHR5cGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgaWYgKGN1ci5uYW1lID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIFtnZXRTdHJpbmcoZXhwciwgY3VyKV07XG4gIH1cbiAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgcG9zID0gMDtcbiAgbGV0IGNoaWxkID0gY3VyLmNoaWxkQWZ0ZXIocG9zKTtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgdmFsdWVzLnB1c2goLi4uZ2V0QWxsQnlUeXBlKGV4cHIsIGNoaWxkLCB0eXBlKSk7XG4gICAgcG9zID0gY2hpbGQudG87XG4gICAgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8vIERlYnVnZ2luZyBmdW5jdGlvbiBmb3IgY29udmVuaWVuY2UuIEdpdmVzIHlvdSBuaWNlIG91dHB1dCBzaW1pbGFyIHRvIGxpbnV4IHRyZWUgdXRpbC5cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBmdW5jdGlvbiBsb2coZXhwcjogc3RyaW5nLCBjdXI/OiBTeW50YXhOb2RlKSB7XG4gIGlmICghY3VyKSB7XG4gICAgY29uc29sZS5sb2coJzxlbXB0eT4nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QganNvbiA9IHRvSnNvbihleHByLCBjdXIpO1xuICBjb25zdCB0ZXh0ID0ganNvblRvVGV4dChqc29uKTtcblxuICBpZiAoIXRleHQpIHtcbiAgICBjb25zb2xlLmxvZygnPGVtcHR5PicpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmxvZyh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gdG9Kc29uKGV4cHI6IHN0cmluZywgY3VyOiBTeW50YXhOb2RlKSB7XG4gIGNvbnN0IHRyZWVKc29uOiBhbnkgPSB7fTtcbiAgY29uc3QgbmFtZSA9IG5vZGVUb1N0cmluZyhleHByLCBjdXIpO1xuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuXG4gIGxldCBwb3MgPSAwO1xuICBsZXQgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBjaGlsZHJlbi5wdXNoKHRvSnNvbihleHByLCBjaGlsZCkpO1xuICAgIHBvcyA9IGNoaWxkLnRvO1xuICAgIGNoaWxkID0gY3VyLmNoaWxkQWZ0ZXIocG9zKTtcbiAgfVxuXG4gIHRyZWVKc29uLm5hbWUgPSBuYW1lO1xuICB0cmVlSnNvbi5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICByZXR1cm4gdHJlZUpzb247XG59XG5cbnR5cGUgSnNvbk5vZGUgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgY2hpbGRyZW46IEpzb25Ob2RlW107XG59O1xuXG5mdW5jdGlvbiBqc29uVG9UZXh0KFxuICBub2RlOiBKc29uTm9kZSxcbiAgY29udGV4dDogeyBsYXN0Q2hpbGQ6IGJvb2xlYW47IGluZGVudDogc3RyaW5nIH0gPSB7XG4gICAgbGFzdENoaWxkOiB0cnVlLFxuICAgIGluZGVudDogJycsXG4gIH1cbikge1xuICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICBjb25zdCB7IGxhc3RDaGlsZCwgaW5kZW50IH0gPSBjb250ZXh0O1xuICBjb25zdCBuZXdJbmRlbnQgPSBpbmRlbnQgIT09ICcnID8gaW5kZW50ICsgKGxhc3RDaGlsZCA/ICfilJTilIAnIDogJ+KUnOKUgCcpIDogJyc7XG4gIGxldCB0ZXh0ID0gbmV3SW5kZW50ICsgbmFtZTtcblxuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBpc0xhc3RDaGlsZCA9IGluZGV4ID09PSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIHRleHQgKz1cbiAgICAgICdcXG4nICtcbiAgICAgIGpzb25Ub1RleHQoY2hpbGQsIHtcbiAgICAgICAgbGFzdENoaWxkOiBpc0xhc3RDaGlsZCxcbiAgICAgICAgaW5kZW50OiBpbmRlbnQgKyAobGFzdENoaWxkID8gJyAgJyA6ICfilIIgJyksXG4gICAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRleHQ7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb1N0cmluZyhleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmFtZSArICc6ICcgKyBnZXRTdHJpbmcoZXhwciwgbm9kZSk7XG59XG4iLCIvKipcbiAqIFNoYXJlZCB0eXBlcyB0aGF0IGNhbiBiZSByZXVzZWQgYnkgTG9raSBhbmQgb3RoZXIgZGF0YSBzb3VyY2VzXG4gKi9cblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgUmVnaXN0cnlJdGVtLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBsYWJlbDogc3RyaW5nO1xuICBvcDogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHBhcmFtczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5V2l0aE9wZXJhdGlvbnMge1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY8VCA9IGFueT4gZXh0ZW5kcyBSZWdpc3RyeUl0ZW0ge1xuICBkb2N1bWVudGF0aW9uPzogc3RyaW5nO1xuICBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW107XG4gIGRlZmF1bHRQYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXTtcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgaGlkZUZyb21MaXN0PzogYm9vbGVhbjtcbiAgYWx0ZXJuYXRpdmVzS2V5Pzogc3RyaW5nO1xuICAvKiogQ2FuIGJlIHVzZWQgdG8gY29udHJvbCBvcGVyYXRpb24gcGxhY2VtZW50IHdoZW4gYWRkaW5nIGEgbmV3IG9wZXJhdGlvbnMsIGxvd2VyIGFyZSBwbGFjZWQgZmlyc3QgKi9cbiAgb3JkZXJSYW5rPzogbnVtYmVyO1xuICByZW5kZXJlcjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUmVuZGVyZXI7XG4gIGFkZE9wZXJhdGlvbkhhbmRsZXI6IFF1ZXJ5QnVpbGRlckFkZE9wZXJhdGlvbkhhbmRsZXI8VD47XG4gIHBhcmFtQ2hhbmdlZEhhbmRsZXI/OiBRdWVyeUJ1aWxkZXJPblBhcmFtQ2hhbmdlZEhhbmRsZXI7XG4gIGV4cGxhaW5IYW5kbGVyPzogUXVlcnlCdWlsZGVyRXhwbGFpbk9wZXJhdGlvbkhhbmRsZXI7XG4gIGNoYW5nZVR5cGVIYW5kbGVyPzogKG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIG5ld0RlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPFQ+KSA9PiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG59XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlckFkZE9wZXJhdGlvbkhhbmRsZXI8VD4gPSAoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogVCxcbiAgbW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXJcbikgPT4gVDtcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyRXhwbGFpbk9wZXJhdGlvbkhhbmRsZXIgPSAob3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpID0+IHN0cmluZztcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT25QYXJhbUNoYW5nZWRIYW5kbGVyID0gKFxuICBpbmRleDogbnVtYmVyLFxuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgb3BlcmF0aW9uRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZcbikgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuXG5leHBvcnQgdHlwZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25SZW5kZXJlciA9IChcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pID0+IHN0cmluZztcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW47XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6ICdzdHJpbmcnIHwgJ251bWJlcicgfCAnYm9vbGVhbic7XG4gIG9wdGlvbnM/OiBzdHJpbmdbXSB8IG51bWJlcltdIHwgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+O1xuICBoaWRlTmFtZT86IGJvb2xlYW47XG4gIHJlc3RQYXJhbT86IGJvb2xlYW47XG4gIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBtaW5XaWR0aD86IG51bWJlcjtcbiAgZWRpdG9yPzogQ29tcG9uZW50VHlwZTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25FZGl0b3JQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBpbmRleDogbnVtYmVyO1xuICBxdWVyeTogYW55O1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkO1xuICBvblJlbW92ZTogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcyB7XG4gIHZhbHVlPzogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZTtcbiAgcGFyYW1EZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmO1xuICAvKiogUGFyYW1ldGVyIGluZGV4ICovXG4gIGluZGV4OiBudW1iZXI7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBvcGVyYXRpb25JbmRleDogbnVtYmVyO1xuICBxdWVyeTogYW55O1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHZhbHVlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZW51bSBRdWVyeUVkaXRvck1vZGUge1xuICBDb2RlID0gJ2NvZGUnLFxuICBCdWlsZGVyID0gJ2J1aWxkZXInLFxuICBFeHBsYWluID0gJ2V4cGxhaW4nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpc3VhbFF1ZXJ5TW9kZWxsZXIge1xuICBnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdO1xuICBnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoa2V5OiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXTtcbiAgZ2V0Q2F0ZWdvcmllcygpOiBzdHJpbmdbXTtcbiAgZ2V0T3BlcmF0aW9uRGVmKGlkOiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfCB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBWaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4vc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB9IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcblxuLyoqXG4gKiBWaXN1YWwgcXVlcnkgbW9kZWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9tVmlzdWFsUXVlcnkge1xuICBtZXRyaWM6IHN0cmluZztcbiAgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbiAgYmluYXJ5UXVlcmllcz86IFByb21WaXN1YWxRdWVyeUJpbmFyeVtdO1xufVxuXG5leHBvcnQgdHlwZSBQcm9tVmlzdWFsUXVlcnlCaW5hcnkgPSBWaXN1YWxRdWVyeUJpbmFyeTxQcm9tVmlzdWFsUXVlcnk+O1xuXG5leHBvcnQgZW51bSBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB7XG4gIEFnZ3JlZ2F0aW9ucyA9ICdBZ2dyZWdhdGlvbnMnLFxuICBSYW5nZUZ1bmN0aW9ucyA9ICdSYW5nZSBmdW5jdGlvbnMnLFxuICBGdW5jdGlvbnMgPSAnRnVuY3Rpb25zJyxcbiAgQmluYXJ5T3BzID0gJ0JpbmFyeSBvcGVyYXRpb25zJyxcbiAgVHJpZ29ub21ldHJpYyA9ICdUcmlnb25vbWV0cmljJyxcbiAgVGltZSA9ICdUaW1lIEZ1bmN0aW9ucycsXG59XG5cbmV4cG9ydCBlbnVtIFByb21PcGVyYXRpb25JZCB7XG4gIEFicyA9ICdhYnMnLFxuICBBYnNlbnQgPSAnYWJzZW50JyxcbiAgQWJzZW50T3ZlclRpbWUgPSAnYWJzZW50X292ZXJfdGltZScsXG4gIEFjb3MgPSAnYWNvcycsXG4gIEFjb3NoID0gJ2Fjb3NoJyxcbiAgQXNpbiA9ICdhc2luJyxcbiAgQXNpbmggPSAnYXNpbmgnLFxuICBBdGFuID0gJ2F0YW4nLFxuICBBdGFuaCA9ICdhdGFuaCcsXG4gIEF2ZyA9ICdhdmcnLFxuICBBdmdPdmVyVGltZSA9ICdhdmdfb3Zlcl90aW1lJyxcbiAgQm90dG9tSyA9ICdib3R0b21rJyxcbiAgQ2VpbCA9ICdjZWlsJyxcbiAgQ2hhbmdlcyA9ICdjaGFuZ2VzJyxcbiAgQ2xhbXAgPSAnY2xhbXAnLFxuICBDbGFtcE1heCA9ICdjbGFtcF9tYXgnLFxuICBDbGFtcE1pbiA9ICdjbGFtcF9taW4nLFxuICBDb3MgPSAnY29zJyxcbiAgQ29zaCA9ICdjb3NoJyxcbiAgQ291bnQgPSAnY291bnQnLFxuICBDb3VudE92ZXJUaW1lID0gJ2NvdW50X292ZXJfdGltZScsXG4gIENvdW50U2NhbGFyID0gJ2NvdW50X3NjYWxhcicsXG4gIENvdW50VmFsdWVzID0gJ2NvdW50X3ZhbHVlcycsXG4gIERheU9mTW9udGggPSAnZGF5X29mX21vbnRoJyxcbiAgRGF5T2ZXZWVrID0gJ2RheV9vZl93ZWVrJyxcbiAgRGF5c0luTW9udGggPSAnZGF5c19pbl9tb250aCcsXG4gIERlZyA9ICdkZWcnLFxuICBEZWx0YSA9ICdkZWx0YScsXG4gIERlcml2ID0gJ2Rlcml2JyxcbiAgRHJvcENvbW1vbkxhYmVscyA9ICdkcm9wX2NvbW1vbl9sYWJlbHMnLFxuICBFeHAgPSAnZXhwJyxcbiAgRmxvb3IgPSAnZmxvb3InLFxuICBHcm91cCA9ICdncm91cCcsXG4gIEhpc3RvZ3JhbVF1YW50aWxlID0gJ2hpc3RvZ3JhbV9xdWFudGlsZScsXG4gIEhvbHRXaW50ZXJzID0gJ2hvbHRfd2ludGVycycsXG4gIEhvdXIgPSAnaG91cicsXG4gIElkZWx0YSA9ICdpZGVsdGEnLFxuICBJbmNyZWFzZSA9ICdpbmNyZWFzZScsXG4gIElyYXRlID0gJ2lyYXRlJyxcbiAgTGFiZWxKb2luID0gJ2xhYmVsX2pvaW4nLFxuICBMYWJlbFJlcGxhY2UgPSAnbGFiZWxfcmVwbGFjZScsXG4gIExhc3QgPSAnbGFzdCcsXG4gIExhc3RPdmVyVGltZSA9ICdsYXN0X292ZXJfdGltZScsXG4gIExuID0gJ2xuJyxcbiAgTG9nMTAgPSAnbG9nMTAnLFxuICBMb2cyID0gJ2xvZzInLFxuICBNYXggPSAnbWF4JyxcbiAgTWF4T3ZlclRpbWUgPSAnbWF4X292ZXJfdGltZScsXG4gIE1pbiA9ICdtaW4nLFxuICBNaW5PdmVyVGltZSA9ICdtaW5fb3Zlcl90aW1lJyxcbiAgTWludXRlID0gJ21pbnV0ZScsXG4gIE1vbnRoID0gJ21vbnRoJyxcbiAgUGkgPSAncGknLFxuICBQcmVkaWN0TGluZWFyID0gJ3ByZWRpY3RfbGluZWFyJyxcbiAgUHJlc2VudCA9ICdwcmVzZW50JyxcbiAgUHJlc2VudE92ZXJUaW1lID0gJ3ByZXNlbnRfb3Zlcl90aW1lJyxcbiAgUXVhbnRpbGUgPSAncXVhbnRpbGUnLFxuICBRdWFudGlsZU92ZXJUaW1lID0gJ3F1YW50aWxlX292ZXJfdGltZScsXG4gIFJhZCA9ICdyYWQnLFxuICBSYXRlID0gJ3JhdGUnLFxuICBSZXNldHMgPSAncmVzZXRzJyxcbiAgUm91bmQgPSAncm91bmQnLFxuICBTY2FsYXIgPSAnc2NhbGFyJyxcbiAgU2duID0gJ3NnbicsXG4gIFNpbiA9ICdzaW4nLFxuICBTaW5oID0gJ3NpbmgnLFxuICBTb3J0ID0gJ3NvcnQnLFxuICBTb3J0RGVzYyA9ICdzb3J0X2Rlc2MnLFxuICBTcXJ0ID0gJ3NxcnQnLFxuICBTdGRkZXYgPSAnc3RkZGV2JyxcbiAgU3RkZGV2T3ZlclRpbWUgPSAnc3RkZGV2X292ZXJfdGltZScsXG4gIFN1bSA9ICdzdW0nLFxuICBTdW1PdmVyVGltZSA9ICdzdW1fb3Zlcl90aW1lJyxcbiAgVGFuID0gJ3RhbicsXG4gIFRhbmggPSAndGFuaCcsXG4gIFRpbWUgPSAndGltZScsXG4gIFRpbWVzdGFtcCA9ICd0aW1lc3RhbXAnLFxuICBUb3BLID0gJ3RvcGsnLFxuICBWZWN0b3IgPSAndmVjdG9yJyxcbiAgWWVhciA9ICd5ZWFyJyxcbiAgLy8gQmluYXJ5IG9wc1xuICBBZGRpdGlvbiA9ICdfX2FkZGl0aW9uJyxcbiAgU3VidHJhY3Rpb24gPSAnX19zdWJ0cmFjdGlvbicsXG4gIE11bHRpcGx5QnkgPSAnX19tdWx0aXBseV9ieScsXG4gIERpdmlkZUJ5ID0gJ19fZGl2aWRlX2J5JyxcbiAgTW9kdWxvID0gJ19fbW9kdWxvJyxcbiAgRXhwb25lbnQgPSAnX19leHBvbmVudCcsXG4gIE5lc3RlZFF1ZXJ5ID0gJ19fbmVzdGVkX3F1ZXJ5JyxcbiAgRXF1YWxUbyA9ICdfX2VxdWFsX3RvJyxcbiAgTm90RXF1YWxUbyA9ICdfX25vdF9lcXVhbF90bycsXG4gIEdyZWF0ZXJUaGFuID0gJ19fZ3JlYXRlcl90aGFuJyxcbiAgTGVzc1RoYW4gPSAnX19sZXNzX3RoYW4nLFxuICBHcmVhdGVyT3JFcXVhbCA9ICdfX2dyZWF0ZXJfb3JfZXF1YWwnLFxuICBMZXNzT3JFcXVhbCA9ICdfX2xlc3Nfb3JfZXF1YWwnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21RdWVyeVBhdHRlcm4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIG9wZXJhdGlvbnM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbltdO1xufVxuIiwiaW1wb3J0IHtcbiAgQXJyYXlEYXRhRnJhbWUsXG4gIEFycmF5VmVjdG9yLFxuICBEYXRhRnJhbWUsXG4gIERhdGFMaW5rLFxuICBEYXRhVG9waWMsXG4gIEZpZWxkLFxuICBGaWVsZFR5cGUsXG4gIGZvcm1hdExhYmVscyxcbiAgZ2V0RGlzcGxheVByb2Nlc3NvcixcbiAgTGFiZWxzLFxuICBNdXRhYmxlRmllbGQsXG4gIFNjb3BlZFZhcnMsXG4gIFRJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRSxcbiAgVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIERhdGFRdWVyeVJlcXVlc3QsXG4gIFByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlLFxuICBDb3JlQXBwLFxuICBEYXRhRnJhbWVUeXBlLFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEZldGNoUmVzcG9uc2UsIGdldERhdGFTb3VyY2VTcnYsIGdldFRlbXBsYXRlU3J2IH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBwYXJ0aXRpb24sIGdyb3VwQnkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZGVzY2VuZGluZywgZGV2aWF0aW9uIH0gZnJvbSAnZDMnO1xuaW1wb3J0IHtcbiAgRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24sXG4gIGlzRXhlbXBsYXJEYXRhLFxuICBpc01hdHJpeERhdGEsXG4gIE1hdHJpeE9yVmVjdG9yUmVzdWx0LFxuICBQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZSxcbiAgUHJvbU1ldHJpYyxcbiAgUHJvbVF1ZXJ5LFxuICBQcm9tUXVlcnlSZXF1ZXN0LFxuICBQcm9tVmFsdWUsXG4gIFRyYW5zZm9ybU9wdGlvbnMsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgcmVuZGVyTGVnZW5kRm9ybWF0IH0gZnJvbSAnLi9sZWdlbmQnO1xuXG5jb25zdCBQT1NJVElWRV9JTkZJTklUWV9TQU1QTEVfVkFMVUUgPSAnK0luZic7XG5jb25zdCBORUdBVElWRV9JTkZJTklUWV9TQU1QTEVfVkFMVUUgPSAnLUluZic7XG5cbmludGVyZmFjZSBUaW1lQW5kVmFsdWUge1xuICBbVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FXTogbnVtYmVyO1xuICBbVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRV06IG51bWJlcjtcbn1cblxuY29uc3QgaXNUYWJsZVJlc3VsdCA9IChkYXRhRnJhbWU6IERhdGFGcmFtZSwgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KTogYm9vbGVhbiA9PiB7XG4gIC8vIFdlIHdhbnQgdG8gcHJvY2VzcyB2ZWN0b3IgYW5kIHNjYWxhciByZXN1bHRzIGluIEV4cGxvcmUgYXMgdGFibGVcbiAgaWYgKFxuICAgIG9wdGlvbnMuYXBwID09PSBDb3JlQXBwLkV4cGxvcmUgJiZcbiAgICAoZGF0YUZyYW1lLm1ldGE/LmN1c3RvbT8ucmVzdWx0VHlwZSA9PT0gJ3ZlY3RvcicgfHwgZGF0YUZyYW1lLm1ldGE/LmN1c3RvbT8ucmVzdWx0VHlwZSA9PT0gJ3NjYWxhcicpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byBwcm9jZXNzIGFsbCBkYXRhRnJhbWVzIHdpdGggdGFyZ2V0LmZvcm1hdCA9PT0gJ3RhYmxlJyBhcyB0YWJsZVxuICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldHMuZmluZCgodGFyZ2V0KSA9PiB0YXJnZXQucmVmSWQgPT09IGRhdGFGcmFtZS5yZWZJZCk7XG4gIHJldHVybiB0YXJnZXQ/LmZvcm1hdCA9PT0gJ3RhYmxlJztcbn07XG5cbmNvbnN0IGlzSGVhdG1hcFJlc3VsdCA9IChkYXRhRnJhbWU6IERhdGFGcmFtZSwgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0cy5maW5kKCh0YXJnZXQpID0+IHRhcmdldC5yZWZJZCA9PT0gZGF0YUZyYW1lLnJlZklkKTtcbiAgcmV0dXJuIHRhcmdldD8uZm9ybWF0ID09PSAnaGVhdG1hcCc7XG59O1xuXG4vLyBWMiByZXN1bHQgdHJhc25mb3JtZXIgdXNlZCB0byB0cmFuc2Zvcm0gcXVlcnkgcmVzdWx0cyBmcm9tIHF1ZXJpZXMgdGhhdCB3ZXJlIHJ1biB0cm91Z2ggcHJvbWV0aGV1cyBiYWNrZW5kXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtVjIoXG4gIHJlc3BvbnNlOiBEYXRhUXVlcnlSZXNwb25zZSxcbiAgcmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+LFxuICBvcHRpb25zOiB7IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucz86IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW10gfVxuKSB7XG4gIGNvbnN0IFt0YWJsZUZyYW1lcywgZnJhbWVzV2l0aG91dFRhYmxlXSA9IHBhcnRpdGlvbjxEYXRhRnJhbWU+KHJlc3BvbnNlLmRhdGEsIChkZikgPT4gaXNUYWJsZVJlc3VsdChkZiwgcmVxdWVzdCkpO1xuICBjb25zdCBwcm9jZXNzZWRUYWJsZUZyYW1lcyA9IHRyYW5zZm9ybURGVG9UYWJsZSh0YWJsZUZyYW1lcyk7XG5cbiAgY29uc3QgW2V4ZW1wbGFyRnJhbWVzLCBmcmFtZXNXaXRob3V0VGFibGVBbmRFeGVtcGxhcnNdID0gcGFydGl0aW9uPERhdGFGcmFtZT4oXG4gICAgZnJhbWVzV2l0aG91dFRhYmxlLFxuICAgIChkZikgPT4gZGYubWV0YT8uY3VzdG9tPy5yZXN1bHRUeXBlID09PSAnZXhlbXBsYXInXG4gICk7XG5cbiAgLy8gRVhFTVBMQVIgRlJBTUVTOiBXZSBlbnJpY2ggZXhlbXBsYXIgZnJhbWVzIHdpdGggZGF0YSBsaW5rcyBhbmQgYWRkIGRhdGFUb3BpYyBtZXRhIGluZm9cbiAgY29uc3QgeyBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IGRlc3RpbmF0aW9ucyB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJvY2Vzc2VkRXhlbXBsYXJGcmFtZXMgPSBleGVtcGxhckZyYW1lcy5tYXAoKGRhdGFGcmFtZSkgPT4ge1xuICAgIGlmIChkZXN0aW5hdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiBvZiBkZXN0aW5hdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHJhY2VJREZpZWxkID0gZGF0YUZyYW1lLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24ubmFtZSk7XG4gICAgICAgIGlmICh0cmFjZUlERmllbGQpIHtcbiAgICAgICAgICBjb25zdCBsaW5rcyA9IGdldERhdGFMaW5rcyhleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbik7XG4gICAgICAgICAgdHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcyA9IHRyYWNlSURGaWVsZC5jb25maWcubGlua3M/Lmxlbmd0aFxuICAgICAgICAgICAgPyBbLi4udHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcywgLi4ubGlua3NdXG4gICAgICAgICAgICA6IGxpbmtzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgLi4uZGF0YUZyYW1lLCBtZXRhOiB7IC4uLmRhdGFGcmFtZS5tZXRhLCBkYXRhVG9waWM6IERhdGFUb3BpYy5Bbm5vdGF0aW9ucyB9IH07XG4gIH0pO1xuXG4gIGNvbnN0IFtoZWF0bWFwUmVzdWx0cywgZnJhbWVzV2l0aG91dFRhYmxlSGVhdG1hcHNBbmRFeGVtcGxhcnNdID0gcGFydGl0aW9uPERhdGFGcmFtZT4oXG4gICAgZnJhbWVzV2l0aG91dFRhYmxlQW5kRXhlbXBsYXJzLFxuICAgIChkZikgPT4gaXNIZWF0bWFwUmVzdWx0KGRmLCByZXF1ZXN0KVxuICApO1xuXG4gIGNvbnN0IHByb2Nlc3NlZEhlYXRtYXBGcmFtZXMgPSBtZXJnZUhlYXRtYXBGcmFtZXMoXG4gICAgdHJhbnNmb3JtVG9IaXN0b2dyYW1PdmVyVGltZShoZWF0bWFwUmVzdWx0cy5zb3J0KHNvcnRTZXJpZXNCeUxhYmVsKSlcbiAgKTtcblxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgcHJvY2Vzc2VkIGFzIHRpbWVfc2VyaWVzIHJlc3VsdCBhbmQgZ3JhcGggcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGVcbiAgY29uc3Qgb3RoZXJGcmFtZXMgPSBmcmFtZXNXaXRob3V0VGFibGVIZWF0bWFwc0FuZEV4ZW1wbGFycy5tYXAoKGRhdGFGcmFtZSkgPT4ge1xuICAgIGNvbnN0IGRmID0ge1xuICAgICAgLi4uZGF0YUZyYW1lLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5kYXRhRnJhbWUubWV0YSxcbiAgICAgICAgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICdncmFwaCcsXG4gICAgICB9LFxuICAgIH0gYXMgRGF0YUZyYW1lO1xuICAgIHJldHVybiBkZjtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXNwb25zZSxcbiAgICBkYXRhOiBbLi4ub3RoZXJGcmFtZXMsIC4uLnByb2Nlc3NlZFRhYmxlRnJhbWVzLCAuLi5wcm9jZXNzZWRIZWF0bWFwRnJhbWVzLCAuLi5wcm9jZXNzZWRFeGVtcGxhckZyYW1lc10sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1ERlRvVGFibGUoZGZzOiBEYXRhRnJhbWVbXSk6IERhdGFGcmFtZVtdIHtcbiAgLy8gSWYgbm8gZGF0YUZyYW1lcyBvciBpZiAxIGRhdGFGcmFtZXMgd2l0aCBubyB2YWx1ZXMsIHJldHVybiBvcmlnaW5hbCBkYXRhRnJhbWVcbiAgaWYgKGRmcy5sZW5ndGggPT09IDAgfHwgKGRmcy5sZW5ndGggPT09IDEgJiYgZGZzWzBdLmxlbmd0aCA9PT0gMCkpIHtcbiAgICByZXR1cm4gZGZzO1xuICB9XG5cbiAgLy8gR3JvdXAgcmVzdWx0cyBieSByZWZJZCBhbmQgcHJvY2VzcyBkYXRhRnJhbWVzIHdpdGggdGhlIHNhbWUgcmVmSWQgYXMgMSBkYXRhRnJhbWVcbiAgY29uc3QgZGF0YUZyYW1lc0J5UmVmSWQgPSBncm91cEJ5KGRmcywgJ3JlZklkJyk7XG4gIGNvbnN0IHJlZklkcyA9IE9iamVjdC5rZXlzKGRhdGFGcmFtZXNCeVJlZklkKTtcblxuICBjb25zdCBmcmFtZXMgPSByZWZJZHMubWFwKChyZWZJZCkgPT4ge1xuICAgIC8vIENyZWF0ZSB0aW1lRmllbGQsIHZhbHVlRmllbGQgYW5kIGxhYmVsRmllbGRzXG4gICAgY29uc3QgdmFsdWVUZXh0ID0gZ2V0VmFsdWVUZXh0KHJlZklkcy5sZW5ndGgsIHJlZklkKTtcbiAgICBjb25zdCB2YWx1ZUZpZWxkID0gZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IFtdLCB2YWx1ZU5hbWU6IHZhbHVlVGV4dCB9KTtcbiAgICBjb25zdCB0aW1lRmllbGQgPSBnZXRUaW1lRmllbGQoW10pO1xuICAgIGNvbnN0IGxhYmVsRmllbGRzOiBNdXRhYmxlRmllbGRbXSA9IFtdO1xuXG4gICAgLy8gRmlsbCBsYWJlbHNGaWVsZHMgd2l0aCBsYWJlbHMgZnJvbSBkYXRhRnJhbWVzXG4gICAgZGF0YUZyYW1lc0J5UmVmSWRbcmVmSWRdLmZvckVhY2goKGRmKSA9PiB7XG4gICAgICBjb25zdCBmcmFtZVZhbHVlRmllbGQgPSBkZi5maWVsZHNbMV07XG4gICAgICBjb25zdCBwcm9tTGFiZWxzID0gZnJhbWVWYWx1ZUZpZWxkLmxhYmVscyA/PyB7fTtcblxuICAgICAgT2JqZWN0LmtleXMocHJvbUxhYmVscylcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGxhYmVsIGluIGxhYmVsRmllbGRzLCBhZGQgaXRcbiAgICAgICAgICBpZiAoIWxhYmVsRmllbGRzLnNvbWUoKGwpID0+IGwubmFtZSA9PT0gbGFiZWwpKSB7XG4gICAgICAgICAgICBjb25zdCBudW1iZXJGaWVsZCA9IGxhYmVsID09PSAnbGUnO1xuICAgICAgICAgICAgbGFiZWxGaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICAgICAgICBjb25maWc6IHsgZmlsdGVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICB0eXBlOiBudW1iZXJGaWVsZCA/IEZpZWxkVHlwZS5udW1iZXIgOiBGaWVsZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEZpbGwgdmFsdWVGaWVsZCwgdGltZUZpZWxkIGFuZCBsYWJlbEZpZWxkcyB3aXRoIHZhbHVlc1xuICAgIGRhdGFGcmFtZXNCeVJlZklkW3JlZklkXS5mb3JFYWNoKChkZikgPT4ge1xuICAgICAgZGYuZmllbGRzWzBdLnZhbHVlcy50b0FycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHRpbWVGaWVsZC52YWx1ZXMuYWRkKHZhbHVlKSk7XG4gICAgICBkZi5maWVsZHNbMV0udmFsdWVzLnRvQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICB2YWx1ZUZpZWxkLnZhbHVlcy5hZGQocGFyc2VTYW1wbGVWYWx1ZSh2YWx1ZSkpO1xuICAgICAgICBjb25zdCBsYWJlbHNGb3JGaWVsZCA9IGRmLmZpZWxkc1sxXS5sYWJlbHMgPz8ge307XG4gICAgICAgIGxhYmVsRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiBmaWVsZC52YWx1ZXMuYWRkKGdldExhYmVsVmFsdWUobGFiZWxzRm9yRmllbGQsIGZpZWxkLm5hbWUpKSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZpZWxkcyA9IFt0aW1lRmllbGQsIC4uLmxhYmVsRmllbGRzLCB2YWx1ZUZpZWxkXTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmSWQsXG4gICAgICBmaWVsZHMsXG4gICAgICBtZXRhOiB7IC4uLmRmc1swXS5tZXRhLCBwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZTogJ3RhYmxlJyBhcyBQcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZSB9LFxuICAgICAgbGVuZ3RoOiB0aW1lRmllbGQudmFsdWVzLmxlbmd0aCxcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGZyYW1lcztcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVUZXh0KHJlc3BvbnNlTGVuZ3RoOiBudW1iZXIsIHJlZklkID0gJycpIHtcbiAgcmV0dXJuIHJlc3BvbnNlTGVuZ3RoID4gMSA/IGBWYWx1ZSAjJHtyZWZJZH1gIDogJ1ZhbHVlJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShcbiAgcmVzcG9uc2U6IEZldGNoUmVzcG9uc2U8UHJvbURhdGFTdWNjZXNzUmVzcG9uc2U+LFxuICB0cmFuc2Zvcm1PcHRpb25zOiB7XG4gICAgcXVlcnk6IFByb21RdWVyeVJlcXVlc3Q7XG4gICAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zPzogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25bXTtcbiAgICB0YXJnZXQ6IFByb21RdWVyeTtcbiAgICByZXNwb25zZUxpc3RMZW5ndGg6IG51bWJlcjtcbiAgICBzY29wZWRWYXJzPzogU2NvcGVkVmFycztcbiAgfVxuKSB7XG4gIC8vIENyZWF0ZSBvcHRpb25zIG9iamVjdCBmcm9tIHRyYW5zZm9ybU9wdGlvbnNcbiAgY29uc3Qgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucyA9IHtcbiAgICBmb3JtYXQ6IHRyYW5zZm9ybU9wdGlvbnMudGFyZ2V0LmZvcm1hdCxcbiAgICBzdGVwOiB0cmFuc2Zvcm1PcHRpb25zLnF1ZXJ5LnN0ZXAsXG4gICAgbGVnZW5kRm9ybWF0OiB0cmFuc2Zvcm1PcHRpb25zLnRhcmdldC5sZWdlbmRGb3JtYXQsXG4gICAgc3RhcnQ6IHRyYW5zZm9ybU9wdGlvbnMucXVlcnkuc3RhcnQsXG4gICAgZW5kOiB0cmFuc2Zvcm1PcHRpb25zLnF1ZXJ5LmVuZCxcbiAgICBxdWVyeTogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5leHByLFxuICAgIHJlc3BvbnNlTGlzdExlbmd0aDogdHJhbnNmb3JtT3B0aW9ucy5yZXNwb25zZUxpc3RMZW5ndGgsXG4gICAgc2NvcGVkVmFyczogdHJhbnNmb3JtT3B0aW9ucy5zY29wZWRWYXJzLFxuICAgIHJlZklkOiB0cmFuc2Zvcm1PcHRpb25zLnRhcmdldC5yZWZJZCxcbiAgICB2YWx1ZVdpdGhSZWZJZDogdHJhbnNmb3JtT3B0aW9ucy50YXJnZXQudmFsdWVXaXRoUmVmSWQsXG4gICAgbWV0YToge1xuICAgICAgLy8gRml4IGZvciBzaG93aW5nIG9mIFByb21ldGhldXMgcmVzdWx0cyBpbiBFeHBsb3JlIHRhYmxlXG4gICAgICBwcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZTogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5pbnN0YW50ID8gJ3RhYmxlJyA6ICdncmFwaCcsXG4gICAgfSxcbiAgfTtcbiAgY29uc3QgcHJvbWV0aGV1c1Jlc3VsdCA9IHJlc3BvbnNlLmRhdGEuZGF0YTtcblxuICBpZiAoaXNFeGVtcGxhckRhdGEocHJvbWV0aGV1c1Jlc3VsdCkpIHtcbiAgICBjb25zdCBldmVudHM6IFRpbWVBbmRWYWx1ZVtdID0gW107XG4gICAgcHJvbWV0aGV1c1Jlc3VsdC5mb3JFYWNoKChleGVtcGxhckRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBleGVtcGxhckRhdGEuZXhlbXBsYXJzLm1hcCgoZXhlbXBsYXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FXTogZXhlbXBsYXIudGltZXN0YW1wICogMTAwMCxcbiAgICAgICAgICBbVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRV06IGV4ZW1wbGFyLnZhbHVlLFxuICAgICAgICAgIC4uLmV4ZW1wbGFyLmxhYmVscyxcbiAgICAgICAgICAuLi5leGVtcGxhckRhdGEuc2VyaWVzTGFiZWxzLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBldmVudHMucHVzaCguLi5kYXRhKTtcbiAgICB9KTtcblxuICAgIC8vIEdyb3VwaW5nIGV4ZW1wbGFycyBieSBzdGVwXG4gICAgY29uc3Qgc2FtcGxlZEV4ZW1wbGFycyA9IHNhbXBsZUV4ZW1wbGFycyhldmVudHMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgZGF0YUZyYW1lID0gbmV3IEFycmF5RGF0YUZyYW1lKHNhbXBsZWRFeGVtcGxhcnMpO1xuICAgIGRhdGFGcmFtZS5tZXRhID0geyBkYXRhVG9waWM6IERhdGFUb3BpYy5Bbm5vdGF0aW9ucyB9O1xuXG4gICAgLy8gQWRkIGRhdGEgbGlua3MgaWYgY29uZmlndXJlZFxuICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uIG9mIHRyYW5zZm9ybU9wdGlvbnMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRyYWNlSURGaWVsZCA9IGRhdGFGcmFtZS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uLm5hbWUpO1xuICAgICAgICBpZiAodHJhY2VJREZpZWxkKSB7XG4gICAgICAgICAgY29uc3QgbGlua3MgPSBnZXREYXRhTGlua3MoZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24pO1xuICAgICAgICAgIHRyYWNlSURGaWVsZC5jb25maWcubGlua3MgPSB0cmFjZUlERmllbGQuY29uZmlnLmxpbmtzPy5sZW5ndGhcbiAgICAgICAgICAgID8gWy4uLnRyYWNlSURGaWVsZC5jb25maWcubGlua3MsIC4uLmxpbmtzXVxuICAgICAgICAgICAgOiBsaW5rcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2RhdGFGcmFtZV07XG4gIH1cblxuICBpZiAoIXByb21ldGhldXNSZXN1bHQ/LnJlc3VsdCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIFJldHVybiBlYXJseSBpZiByZXN1bHQgdHlwZSBpcyBzY2FsYXJcbiAgaWYgKHByb21ldGhldXNSZXN1bHQucmVzdWx0VHlwZSA9PT0gJ3NjYWxhcicpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBtZXRhOiBvcHRpb25zLm1ldGEsXG4gICAgICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgICAgICBsZW5ndGg6IDEsXG4gICAgICAgIGZpZWxkczogW2dldFRpbWVGaWVsZChbcHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHRdKSwgZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IFtwcm9tZXRoZXVzUmVzdWx0LnJlc3VsdF0gfSldLFxuICAgICAgfSxcbiAgICBdO1xuICB9XG5cbiAgLy8gUmV0dXJuIGVhcmx5IGFnYWluIGlmIHRoZSBmb3JtYXQgaXMgdGFibGUsIHRoaXMgbmVlZHMgc3BlY2lhbCB0cmFuc2Zvcm1hdGlvbi5cbiAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAndGFibGUnKSB7XG4gICAgY29uc3QgdGFibGVEYXRhID0gdHJhbnNmb3JtTWV0cmljRGF0YVRvVGFibGUocHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBbdGFibGVEYXRhXTtcbiAgfVxuXG4gIC8vIFByb2Nlc3MgbWF0cml4IGFuZCB2ZWN0b3IgcmVzdWx0cyB0byBEYXRhRnJhbWVcbiAgY29uc3QgZGF0YUZyYW1lOiBEYXRhRnJhbWVbXSA9IFtdO1xuICBwcm9tZXRoZXVzUmVzdWx0LnJlc3VsdC5mb3JFYWNoKChkYXRhOiBNYXRyaXhPclZlY3RvclJlc3VsdCkgPT4gZGF0YUZyYW1lLnB1c2godHJhbnNmb3JtVG9EYXRhRnJhbWUoZGF0YSwgb3B0aW9ucykpKTtcblxuICAvLyBXaGVuIGZvcm1hdCBpcyBoZWF0bWFwIHVzZSB0aGUgYWxyZWFkeSBjcmVhdGVkIGRhdGEgZnJhbWVzIGFuZCB0cmFuc2Zvcm0gaXQgbW9yZVxuICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdoZWF0bWFwJykge1xuICAgIHJldHVybiBtZXJnZUhlYXRtYXBGcmFtZXModHJhbnNmb3JtVG9IaXN0b2dyYW1PdmVyVGltZShkYXRhRnJhbWUuc29ydChzb3J0U2VyaWVzQnlMYWJlbCkpKTtcbiAgfVxuXG4gIC8vIFJldHVybiBtYXRyaXggb3IgdmVjdG9yIHJlc3VsdCBhcyBEYXRhRnJhbWVbXVxuICByZXR1cm4gZGF0YUZyYW1lO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhTGlua3Mob3B0aW9uczogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24pOiBEYXRhTGlua1tdIHtcbiAgY29uc3QgZGF0YUxpbmtzOiBEYXRhTGlua1tdID0gW107XG5cbiAgaWYgKG9wdGlvbnMuZGF0YXNvdXJjZVVpZCkge1xuICAgIGNvbnN0IGRhdGFTb3VyY2VTcnYgPSBnZXREYXRhU291cmNlU3J2KCk7XG4gICAgY29uc3QgZHNTZXR0aW5ncyA9IGRhdGFTb3VyY2VTcnYuZ2V0SW5zdGFuY2VTZXR0aW5ncyhvcHRpb25zLmRhdGFzb3VyY2VVaWQpO1xuXG4gICAgZGF0YUxpbmtzLnB1c2goe1xuICAgICAgdGl0bGU6IG9wdGlvbnMudXJsRGlzcGxheUxhYmVsIHx8IGBRdWVyeSB3aXRoICR7ZHNTZXR0aW5ncz8ubmFtZX1gLFxuICAgICAgdXJsOiAnJyxcbiAgICAgIGludGVybmFsOiB7XG4gICAgICAgIHF1ZXJ5OiB7IHF1ZXJ5OiAnJHtfX3ZhbHVlLnJhd30nLCBxdWVyeVR5cGU6ICd0cmFjZUlkJyB9LFxuICAgICAgICBkYXRhc291cmNlVWlkOiBvcHRpb25zLmRhdGFzb3VyY2VVaWQsXG4gICAgICAgIGRhdGFzb3VyY2VOYW1lOiBkc1NldHRpbmdzPy5uYW1lID8/ICdEYXRhIHNvdXJjZSBub3QgZm91bmQnLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnVybCkge1xuICAgIGRhdGFMaW5rcy5wdXNoKHtcbiAgICAgIHRpdGxlOiBvcHRpb25zLnVybERpc3BsYXlMYWJlbCB8fCBgR28gdG8gJHtvcHRpb25zLnVybH1gLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHRhcmdldEJsYW5rOiB0cnVlLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhTGlua3M7XG59XG5cbi8qKlxuICogUmVkdWNlIHRoZSBkZW5zaXR5IG9mIHRoZSBleGVtcGxhcnMgYnkgbWFraW5nIHN1cmUgdGhhdCB0aGUgaGlnaGVzdCB2YWx1ZSBleGVtcGxhciBpcyBpbmNsdWRlZFxuICogYW5kIHRoZW4gb25seSB0aGUgb25lcyB0aGF0IGFyZSAyIHRpbWVzIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIGFsbCB0aGUgdmFsdWVzLlxuICogVGhpcyBtYWtlcyBzdXJlIG5vdCB0byBzaG93IHRvbyBtYW55IGRvdHMgbmVhciBlYWNoIG90aGVyLlxuICovXG5mdW5jdGlvbiBzYW1wbGVFeGVtcGxhcnMoZXZlbnRzOiBUaW1lQW5kVmFsdWVbXSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucykge1xuICBjb25zdCBzdGVwID0gb3B0aW9ucy5zdGVwIHx8IDE1O1xuICBjb25zdCBidWNrZXRlZEV4ZW1wbGFyczogeyBbdHM6IHN0cmluZ106IFRpbWVBbmRWYWx1ZVtdIH0gPSB7fTtcbiAgY29uc3QgdmFsdWVzOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGV4ZW1wbGFyIG9mIGV2ZW50cykge1xuICAgIC8vIEFsaWduIGV4ZW1wbGFyIHRpbWVzdGFtcCB0byBuZWFyZXN0IHN0ZXAgc2Vjb25kXG4gICAgY29uc3QgYWxpZ25lZFRzID0gU3RyaW5nKE1hdGguZmxvb3IoZXhlbXBsYXJbVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FXSAvIDEwMDAgLyBzdGVwKSAqIHN0ZXAgKiAxMDAwKTtcbiAgICBpZiAoIWJ1Y2tldGVkRXhlbXBsYXJzW2FsaWduZWRUc10pIHtcbiAgICAgIC8vIE5ldyBidWNrZXQgZm91bmRcbiAgICAgIGJ1Y2tldGVkRXhlbXBsYXJzW2FsaWduZWRUc10gPSBbXTtcbiAgICB9XG4gICAgYnVja2V0ZWRFeGVtcGxhcnNbYWxpZ25lZFRzXS5wdXNoKGV4ZW1wbGFyKTtcbiAgICB2YWx1ZXMucHVzaChleGVtcGxhcltUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FXSk7XG4gIH1cblxuICAvLyBHZXR0aW5nIGV4ZW1wbGFycyBmcm9tIGVhY2ggYnVja2V0XG4gIGNvbnN0IHN0YW5kYXJkRGV2aWF0aW9uID0gZGV2aWF0aW9uKHZhbHVlcyk7XG4gIGNvbnN0IHNhbXBsZWRCdWNrZXRzID0gT2JqZWN0LmtleXMoYnVja2V0ZWRFeGVtcGxhcnMpLnNvcnQoKTtcbiAgY29uc3Qgc2FtcGxlZEV4ZW1wbGFycyA9IFtdO1xuICBmb3IgKGNvbnN0IHRzIG9mIHNhbXBsZWRCdWNrZXRzKSB7XG4gICAgY29uc3QgZXhlbXBsYXJzSW5CdWNrZXQgPSBidWNrZXRlZEV4ZW1wbGFyc1t0c107XG4gICAgaWYgKGV4ZW1wbGFyc0luQnVja2V0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgc2FtcGxlZEV4ZW1wbGFycy5wdXNoKGV4ZW1wbGFyc0luQnVja2V0WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hvb3NlIHdoaWNoIHZhbHVlcyB0byBzYW1wbGVcbiAgICAgIGNvbnN0IGJ1Y2tldFZhbHVlcyA9IGV4ZW1wbGFyc0luQnVja2V0Lm1hcCgoZXgpID0+IGV4W1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdKS5zb3J0KGRlc2NlbmRpbmcpO1xuICAgICAgY29uc3Qgc2FtcGxlZEJ1Y2tldFZhbHVlcyA9IGJ1Y2tldFZhbHVlcy5yZWR1Y2UoKGFjYzogbnVtYmVyW10sIGN1cnIpID0+IHtcbiAgICAgICAgaWYgKGFjYy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBGaXJzdCB2YWx1ZSBpcyBtYXggYW5kIGlzIGFsd2F5cyBhZGRlZFxuICAgICAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZW4gdGFrZSB2YWx1ZXMgb25seSB3aGVuIGF0IGxlYXN0IDIgc3RhbmRhcmQgZGV2aWF0aW9uIGRpc3RhbmNlIHRvIHByZXZpb3VzbHkgdGFrZW4gdmFsdWVcbiAgICAgICAgICBjb25zdCBwcmV2ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoc3RhbmRhcmREZXZpYXRpb24gJiYgcHJldiAtIGN1cnIgPj0gMiAqIHN0YW5kYXJkRGV2aWF0aW9uKSB7XG4gICAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIFtdKTtcbiAgICAgIC8vIEZpbmQgdGhlIGV4ZW1wbGFycyBmb3IgdGhlIHNhbXBsZWQgdmFsdWVzXG4gICAgICBzYW1wbGVkRXhlbXBsYXJzLnB1c2goXG4gICAgICAgIC4uLnNhbXBsZWRCdWNrZXRWYWx1ZXMubWFwKFxuICAgICAgICAgICh2YWx1ZSkgPT4gZXhlbXBsYXJzSW5CdWNrZXQuZmluZCgoZXgpID0+IGV4W1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdID09PSB2YWx1ZSkhXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzYW1wbGVkRXhlbXBsYXJzO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgbWF0cml4IGFuZCB2ZWN0b3IgcmVzdWx0IGZyb20gUHJvbWV0aGV1cyByZXN1bHQgdG8gRGF0YUZyYW1lXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVRvRGF0YUZyYW1lKGRhdGE6IE1hdHJpeE9yVmVjdG9yUmVzdWx0LCBvcHRpb25zOiBUcmFuc2Zvcm1PcHRpb25zKTogRGF0YUZyYW1lIHtcbiAgY29uc3QgeyBuYW1lLCBsYWJlbHMgfSA9IGNyZWF0ZUxhYmVsSW5mbyhkYXRhLm1ldHJpYywgb3B0aW9ucyk7XG5cbiAgY29uc3QgZmllbGRzOiBGaWVsZFtdID0gW107XG5cbiAgaWYgKGlzTWF0cml4RGF0YShkYXRhKSkge1xuICAgIGNvbnN0IHN0ZXBNcyA9IG9wdGlvbnMuc3RlcCA/IG9wdGlvbnMuc3RlcCAqIDEwMDAgOiBOYU47XG4gICAgbGV0IGJhc2VUaW1lc3RhbXAgPSBvcHRpb25zLnN0YXJ0ICogMTAwMDtcbiAgICBjb25zdCBkcHM6IFByb21WYWx1ZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRhdGEudmFsdWVzKSB7XG4gICAgICBsZXQgZHBWYWx1ZTogbnVtYmVyIHwgbnVsbCA9IHBhcnNlU2FtcGxlVmFsdWUodmFsdWVbMV0pO1xuXG4gICAgICBpZiAoaXNOYU4oZHBWYWx1ZSkpIHtcbiAgICAgICAgZHBWYWx1ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHZhbHVlWzBdICogMTAwMDtcbiAgICAgIGZvciAobGV0IHQgPSBiYXNlVGltZXN0YW1wOyB0IDwgdGltZXN0YW1wOyB0ICs9IHN0ZXBNcykge1xuICAgICAgICBkcHMucHVzaChbdCwgbnVsbF0pO1xuICAgICAgfVxuICAgICAgYmFzZVRpbWVzdGFtcCA9IHRpbWVzdGFtcCArIHN0ZXBNcztcbiAgICAgIGRwcy5wdXNoKFt0aW1lc3RhbXAsIGRwVmFsdWVdKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRUaW1lc3RhbXAgPSBvcHRpb25zLmVuZCAqIDEwMDA7XG4gICAgZm9yIChsZXQgdCA9IGJhc2VUaW1lc3RhbXA7IHQgPD0gZW5kVGltZXN0YW1wOyB0ICs9IHN0ZXBNcykge1xuICAgICAgZHBzLnB1c2goW3QsIG51bGxdKTtcbiAgICB9XG4gICAgZmllbGRzLnB1c2goZ2V0VGltZUZpZWxkKGRwcywgdHJ1ZSkpO1xuICAgIGZpZWxkcy5wdXNoKGdldFZhbHVlRmllbGQoeyBkYXRhOiBkcHMsIHBhcnNlVmFsdWU6IGZhbHNlLCBsYWJlbHMsIGRpc3BsYXlOYW1lRnJvbURTOiBuYW1lIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBmaWVsZHMucHVzaChnZXRUaW1lRmllbGQoW2RhdGEudmFsdWVdKSk7XG4gICAgZmllbGRzLnB1c2goZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IFtkYXRhLnZhbHVlXSwgbGFiZWxzLCBkaXNwbGF5TmFtZUZyb21EUzogbmFtZSB9KSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICByZWZJZDogb3B0aW9ucy5yZWZJZCxcbiAgICBsZW5ndGg6IGZpZWxkc1swXS52YWx1ZXMubGVuZ3RoLFxuICAgIGZpZWxkcyxcbiAgICBuYW1lLFxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NZXRyaWNEYXRhVG9UYWJsZShtZDogTWF0cml4T3JWZWN0b3JSZXN1bHRbXSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucyk6IERhdGFGcmFtZSB7XG4gIGlmICghbWQgfHwgbWQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgICAgbGVuZ3RoOiAwLFxuICAgICAgZmllbGRzOiBbXSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgdmFsdWVUZXh0ID0gb3B0aW9ucy5yZXNwb25zZUxpc3RMZW5ndGggPiAxIHx8IG9wdGlvbnMudmFsdWVXaXRoUmVmSWQgPyBgVmFsdWUgIyR7b3B0aW9ucy5yZWZJZH1gIDogJ1ZhbHVlJztcblxuICBjb25zdCB0aW1lRmllbGQgPSBnZXRUaW1lRmllbGQoW10pO1xuICBjb25zdCBtZXRyaWNGaWVsZHMgPSBPYmplY3Qua2V5cyhtZC5yZWR1Y2UoKGFjYywgc2VyaWVzKSA9PiAoeyAuLi5hY2MsIC4uLnNlcmllcy5tZXRyaWMgfSksIHt9KSlcbiAgICAuc29ydCgpXG4gICAgLm1hcCgobGFiZWwpID0+IHtcbiAgICAgIC8vIExhYmVscyBoYXZlIHN0cmluZyBmaWVsZCB0eXBlLCBvdGhlcndpc2UgdGFibGUgdHJpZXMgdG8gZmlndXJlIG91dCB0aGUgdHlwZSB3aGljaCBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgcmVzdWx0c1xuICAgICAgLy8gT25seSBcImxlXCIgbGFiZWwgaGFzIGEgbnVtYmVyIGZpZWxkIHR5cGVcbiAgICAgIGNvbnN0IG51bWJlckZpZWxkID0gbGFiZWwgPT09ICdsZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgY29uZmlnOiB7IGZpbHRlcmFibGU6IHRydWUgfSxcbiAgICAgICAgdHlwZTogbnVtYmVyRmllbGQgPyBGaWVsZFR5cGUubnVtYmVyIDogRmllbGRUeXBlLnN0cmluZyxcbiAgICAgICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIGNvbnN0IHZhbHVlRmllbGQgPSBnZXRWYWx1ZUZpZWxkKHsgZGF0YTogW10sIHZhbHVlTmFtZTogdmFsdWVUZXh0IH0pO1xuXG4gIG1kLmZvckVhY2goKGQpID0+IHtcbiAgICBpZiAoaXNNYXRyaXhEYXRhKGQpKSB7XG4gICAgICBkLnZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgdGltZUZpZWxkLnZhbHVlcy5hZGQodmFsWzBdICogMTAwMCk7XG4gICAgICAgIG1ldHJpY0ZpZWxkcy5mb3JFYWNoKChtZXRyaWNGaWVsZCkgPT4gbWV0cmljRmllbGQudmFsdWVzLmFkZChnZXRMYWJlbFZhbHVlKGQubWV0cmljLCBtZXRyaWNGaWVsZC5uYW1lKSkpO1xuICAgICAgICB2YWx1ZUZpZWxkLnZhbHVlcy5hZGQocGFyc2VTYW1wbGVWYWx1ZSh2YWxbMV0pKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lRmllbGQudmFsdWVzLmFkZChkLnZhbHVlWzBdICogMTAwMCk7XG4gICAgICBtZXRyaWNGaWVsZHMuZm9yRWFjaCgobWV0cmljRmllbGQpID0+IG1ldHJpY0ZpZWxkLnZhbHVlcy5hZGQoZ2V0TGFiZWxWYWx1ZShkLm1ldHJpYywgbWV0cmljRmllbGQubmFtZSkpKTtcbiAgICAgIHZhbHVlRmllbGQudmFsdWVzLmFkZChwYXJzZVNhbXBsZVZhbHVlKGQudmFsdWVbMV0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWV0YTogb3B0aW9ucy5tZXRhLFxuICAgIHJlZklkOiBvcHRpb25zLnJlZklkLFxuICAgIGxlbmd0aDogdGltZUZpZWxkLnZhbHVlcy5sZW5ndGgsXG4gICAgZmllbGRzOiBbdGltZUZpZWxkLCAuLi5tZXRyaWNGaWVsZHMsIHZhbHVlRmllbGRdLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRMYWJlbFZhbHVlKG1ldHJpYzogUHJvbU1ldHJpYywgbGFiZWw6IHN0cmluZyk6IHN0cmluZyB8IG51bWJlciB7XG4gIGlmIChtZXRyaWMuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgaWYgKGxhYmVsID09PSAnbGUnKSB7XG4gICAgICByZXR1cm4gcGFyc2VTYW1wbGVWYWx1ZShtZXRyaWNbbGFiZWxdKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY1tsYWJlbF07XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lRmllbGQoZGF0YTogUHJvbVZhbHVlW10sIGlzTXMgPSBmYWxzZSk6IE11dGFibGVGaWVsZCB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FLFxuICAgIHR5cGU6IEZpZWxkVHlwZS50aW1lLFxuICAgIGNvbmZpZzoge30sXG4gICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3I8bnVtYmVyPihkYXRhLm1hcCgodmFsKSA9PiAoaXNNcyA/IHZhbFswXSA6IHZhbFswXSAqIDEwMDApKSksXG4gIH07XG59XG50eXBlIFZhbHVlRmllbGRPcHRpb25zID0ge1xuICBkYXRhOiBQcm9tVmFsdWVbXTtcbiAgdmFsdWVOYW1lPzogc3RyaW5nO1xuICBwYXJzZVZhbHVlPzogYm9vbGVhbjtcbiAgbGFiZWxzPzogTGFiZWxzO1xuICBkaXNwbGF5TmFtZUZyb21EUz86IHN0cmluZztcbn07XG5cbmZ1bmN0aW9uIGdldFZhbHVlRmllbGQoe1xuICBkYXRhLFxuICB2YWx1ZU5hbWUgPSBUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FLFxuICBwYXJzZVZhbHVlID0gdHJ1ZSxcbiAgbGFiZWxzLFxuICBkaXNwbGF5TmFtZUZyb21EUyxcbn06IFZhbHVlRmllbGRPcHRpb25zKTogTXV0YWJsZUZpZWxkIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiB2YWx1ZU5hbWUsXG4gICAgdHlwZTogRmllbGRUeXBlLm51bWJlcixcbiAgICBkaXNwbGF5OiBnZXREaXNwbGF5UHJvY2Vzc29yKCksXG4gICAgY29uZmlnOiB7XG4gICAgICBkaXNwbGF5TmFtZUZyb21EUyxcbiAgICB9LFxuICAgIGxhYmVscyxcbiAgICB2YWx1ZXM6IG5ldyBBcnJheVZlY3RvcjxudW1iZXIgfCBudWxsPihkYXRhLm1hcCgodmFsKSA9PiAocGFyc2VWYWx1ZSA/IHBhcnNlU2FtcGxlVmFsdWUodmFsWzFdKSA6IHZhbFsxXSkpKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGFiZWxJbmZvKGxhYmVsczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucykge1xuICBpZiAob3B0aW9ucz8ubGVnZW5kRm9ybWF0KSB7XG4gICAgY29uc3QgdGl0bGUgPSByZW5kZXJMZWdlbmRGb3JtYXQoZ2V0VGVtcGxhdGVTcnYoKS5yZXBsYWNlKG9wdGlvbnMubGVnZW5kRm9ybWF0LCBvcHRpb25zPy5zY29wZWRWYXJzKSwgbGFiZWxzKTtcbiAgICByZXR1cm4geyBuYW1lOiB0aXRsZSwgbGFiZWxzIH07XG4gIH1cblxuICBjb25zdCB7IF9fbmFtZV9fLCAuLi5sYWJlbHNXaXRob3V0TmFtZSB9ID0gbGFiZWxzO1xuICBjb25zdCBsYWJlbFBhcnQgPSBmb3JtYXRMYWJlbHMobGFiZWxzV2l0aG91dE5hbWUpO1xuICBsZXQgdGl0bGUgPSBgJHtfX25hbWVfXyA/PyAnJ30ke2xhYmVsUGFydH1gO1xuXG4gIGlmICghdGl0bGUpIHtcbiAgICB0aXRsZSA9IG9wdGlvbnMucXVlcnk7XG4gIH1cblxuICByZXR1cm4geyBuYW1lOiB0aXRsZSwgbGFiZWxzOiBsYWJlbHNXaXRob3V0TmFtZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JpZ2luYWxNZXRyaWNOYW1lKGxhYmVsRGF0YTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkge1xuICBjb25zdCBtZXRyaWNOYW1lID0gbGFiZWxEYXRhLl9fbmFtZV9fIHx8ICcnO1xuICBkZWxldGUgbGFiZWxEYXRhLl9fbmFtZV9fO1xuICBjb25zdCBsYWJlbFBhcnQgPSBPYmplY3QuZW50cmllcyhsYWJlbERhdGEpXG4gICAgLm1hcCgobGFiZWwpID0+IGAke2xhYmVsWzBdfT1cIiR7bGFiZWxbMV19XCJgKVxuICAgIC5qb2luKCcsJyk7XG4gIHJldHVybiBgJHttZXRyaWNOYW1lfXske2xhYmVsUGFydH19YDtcbn1cblxuZnVuY3Rpb24gbWVyZ2VIZWF0bWFwRnJhbWVzKGZyYW1lczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIGlmIChmcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgdGltZUZpZWxkID0gZnJhbWVzWzBdLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLnRpbWUpITtcbiAgY29uc3QgY291bnRGaWVsZHMgPSBmcmFtZXMubWFwKChmcmFtZSkgPT4ge1xuICAgIGxldCBmaWVsZCA9IGZyYW1lLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gRmllbGRUeXBlLm51bWJlcikhO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpZWxkLFxuICAgICAgbmFtZTogZmllbGQuY29uZmlnLmRpc3BsYXlOYW1lRnJvbURTISxcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIC4uLmZyYW1lc1swXSxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4uZnJhbWVzWzBdLm1ldGEsXG4gICAgICAgIHR5cGU6IERhdGFGcmFtZVR5cGUuSGVhdG1hcEJ1Y2tldHMsXG4gICAgICB9LFxuICAgICAgZmllbGRzOiBbdGltZUZpZWxkISwgLi4uY291bnRGaWVsZHNdLFxuICAgIH0sXG4gIF07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVRvSGlzdG9ncmFtT3ZlclRpbWUoc2VyaWVzTGlzdDogRGF0YUZyYW1lW10pIHtcbiAgLyogICAgICB0MSA9IHRpbWVzdGFtcDEsIHQyID0gdGltZXN0YW1wMiBldGMuXG4gICAgICAgICAgICB0MSAgdDIgIHQzICAgICAgICAgIHQxICB0MiAgdDNcbiAgICBsZTEwICAgIDEwICAxMCAgMCAgICAgPT4gICAgMTAgIDEwICAwXG4gICAgbGUyMCAgICAyMCAgMTAgIDMwICAgID0+ICAgIDEwICAwICAgMzBcbiAgICBsZTMwICAgIDMwICAxMCAgMzUgICAgPT4gICAgMTAgIDAgICA1XG4gICAgKi9cbiAgZm9yIChsZXQgaSA9IHNlcmllc0xpc3QubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIGNvbnN0IHRvcFNlcmllcyA9IHNlcmllc0xpc3RbaV0uZmllbGRzLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSk7XG4gICAgY29uc3QgYm90dG9tU2VyaWVzID0gc2VyaWVzTGlzdFtpIC0gMV0uZmllbGRzLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSk7XG4gICAgaWYgKCF0b3BTZXJpZXMgfHwgIWJvdHRvbVNlcmllcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9tZXRoZXVzIGhlYXRtYXAgdHJhbnNmb3JtIGVycm9yOiBkYXRhIHNob3VsZCBiZSBhIHRpbWUgc2VyaWVzJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b3BTZXJpZXMudmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBib3R0b21Qb2ludCA9IGJvdHRvbVNlcmllcy52YWx1ZXMuZ2V0KGopIHx8IFswXTtcbiAgICAgIHRvcFNlcmllcy52YWx1ZXMudG9BcnJheSgpW2pdIC09IGJvdHRvbVBvaW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXJpZXNMaXN0O1xufVxuXG5mdW5jdGlvbiBzb3J0U2VyaWVzQnlMYWJlbChzMTogRGF0YUZyYW1lLCBzMjogRGF0YUZyYW1lKTogbnVtYmVyIHtcbiAgbGV0IGxlMSwgbGUyO1xuXG4gIHRyeSB7XG4gICAgLy8gZmFpbCBpZiBub3QgaW50ZWdlci4gbWlnaHQgaGFwcGVuIHdpdGggYmFkIHF1ZXJpZXNcbiAgICBsZTEgPSBwYXJzZVNhbXBsZVZhbHVlKHMxLm5hbWUgPz8gJycpO1xuICAgIGxlMiA9IHBhcnNlU2FtcGxlVmFsdWUoczIubmFtZSA/PyAnJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChsZTEgPiBsZTIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChsZTEgPCBsZTIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gcGFyc2VTYW1wbGVWYWx1ZSh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgUE9TSVRJVkVfSU5GSU5JVFlfU0FNUExFX1ZBTFVFOlxuICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjYXNlIE5FR0FUSVZFX0lORklOSVRZX1NBTVBMRV9WQUxVRTpcbiAgICAgIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0YVF1ZXJ5LCBEYXRhU291cmNlSnNvbkRhdGEsIFF1ZXJ5UmVzdWx0TWV0YSwgU2NvcGVkVmFycyB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tUXVlcnkgZXh0ZW5kcyBEYXRhUXVlcnkge1xuICBleHByOiBzdHJpbmc7XG4gIGZvcm1hdD86IHN0cmluZztcbiAgaW5zdGFudD86IGJvb2xlYW47XG4gIHJhbmdlPzogYm9vbGVhbjtcbiAgZXhlbXBsYXI/OiBib29sZWFuO1xuICBoaW50aW5nPzogYm9vbGVhbjtcbiAgaW50ZXJ2YWw/OiBzdHJpbmc7XG4gIGludGVydmFsRmFjdG9yPzogbnVtYmVyO1xuICAvLyBUaW1lem9uZSBvZmZzZXQgdG8gYWxpZ24gc3RhcnQgJiBlbmQgdGltZSBvbiBiYWNrZW5kXG4gIHV0Y09mZnNldFNlYz86IG51bWJlcjtcbiAgbGVnZW5kRm9ybWF0Pzogc3RyaW5nO1xuICB2YWx1ZVdpdGhSZWZJZD86IGJvb2xlYW47XG4gIHJlcXVlc3RJZD86IHN0cmluZztcbiAgc2hvd2luZ0dyYXBoPzogYm9vbGVhbjtcbiAgc2hvd2luZ1RhYmxlPzogYm9vbGVhbjtcbiAgLyoqIENvZGUsIEJ1aWxkZXIgb3IgRXhwbGFpbiAqL1xuICBlZGl0b3JNb2RlPzogUXVlcnlFZGl0b3JNb2RlO1xuICAvKiogQ29udHJvbHMgaWYgdGhlIHJhdyBxdWVyeSB0ZXh0IGlzIHNob3duICovXG4gIHJhd1F1ZXJ5PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tT3B0aW9ucyBleHRlbmRzIERhdGFTb3VyY2VKc29uRGF0YSB7XG4gIHRpbWVJbnRlcnZhbD86IHN0cmluZztcbiAgcXVlcnlUaW1lb3V0Pzogc3RyaW5nO1xuICBodHRwTWV0aG9kPzogc3RyaW5nO1xuICBkaXJlY3RVcmw/OiBzdHJpbmc7XG4gIGN1c3RvbVF1ZXJ5UGFyYW1ldGVycz86IHN0cmluZztcbiAgZGlzYWJsZU1ldHJpY3NMb29rdXA/OiBib29sZWFuO1xuICBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM/OiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdO1xufVxuXG5leHBvcnQgZW51bSBQcm9tUXVlcnlUeXBlIHtcbiAgdGltZVNlcmllc1F1ZXJ5ID0gJ3RpbWVTZXJpZXNRdWVyeScsXG59XG5cbmV4cG9ydCB0eXBlIEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHVybD86IHN0cmluZztcbiAgdXJsRGlzcGxheUxhYmVsPzogc3RyaW5nO1xuICBkYXRhc291cmNlVWlkPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tUXVlcnlSZXF1ZXN0IGV4dGVuZHMgUHJvbVF1ZXJ5IHtcbiAgc3RlcD86IG51bWJlcjtcbiAgcmVxdWVzdElkPzogc3RyaW5nO1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgaGVhZGVycz86IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTWV0cmljc01ldGFkYXRhSXRlbSB7XG4gIHR5cGU6IHN0cmluZztcbiAgaGVscDogc3RyaW5nO1xuICB1bml0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21NZXRyaWNzTWV0YWRhdGEge1xuICBbbWV0cmljOiBzdHJpbmddOiBQcm9tTWV0cmljc01ldGFkYXRhSXRlbTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxUID0gUHJvbURhdGE+IHtcbiAgc3RhdHVzOiAnc3VjY2Vzcyc7XG4gIGRhdGE6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbURhdGFFcnJvclJlc3BvbnNlPFQgPSBQcm9tRGF0YT4ge1xuICBzdGF0dXM6ICdlcnJvcic7XG4gIGVycm9yVHlwZTogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nO1xuICBkYXRhOiBUO1xufVxuXG5leHBvcnQgdHlwZSBQcm9tRGF0YSA9IFByb21NYXRyaXhEYXRhIHwgUHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YSB8IFByb21FeGVtcGxhckRhdGFbXTtcblxuZXhwb3J0IGludGVyZmFjZSBMYWJlbHMge1xuICBbaW5kZXg6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeGVtcGxhciB7XG4gIGxhYmVsczogTGFiZWxzO1xuICB2YWx1ZTogbnVtYmVyO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tRXhlbXBsYXJEYXRhIHtcbiAgc2VyaWVzTGFiZWxzOiBQcm9tTWV0cmljO1xuICBleGVtcGxhcnM6IEV4ZW1wbGFyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVZlY3RvckRhdGEge1xuICByZXN1bHRUeXBlOiAndmVjdG9yJztcbiAgcmVzdWx0OiBBcnJheTx7XG4gICAgbWV0cmljOiBQcm9tTWV0cmljO1xuICAgIHZhbHVlOiBQcm9tVmFsdWU7XG4gIH0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21NYXRyaXhEYXRhIHtcbiAgcmVzdWx0VHlwZTogJ21hdHJpeCc7XG4gIHJlc3VsdDogQXJyYXk8e1xuICAgIG1ldHJpYzogUHJvbU1ldHJpYztcbiAgICB2YWx1ZXM6IFByb21WYWx1ZVtdO1xuICB9Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tU2NhbGFyRGF0YSB7XG4gIHJlc3VsdFR5cGU6ICdzY2FsYXInO1xuICByZXN1bHQ6IFByb21WYWx1ZTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvbVZhbHVlID0gW251bWJlciwgYW55XTtcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTWV0cmljIHtcbiAgX19uYW1lX18/OiBzdHJpbmc7XG4gIFtpbmRleDogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXRyaXhEYXRhKHJlc3VsdDogTWF0cml4T3JWZWN0b3JSZXN1bHQpOiByZXN1bHQgaXMgUHJvbU1hdHJpeERhdGFbJ3Jlc3VsdCddWzBdIHtcbiAgcmV0dXJuICd2YWx1ZXMnIGluIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXhlbXBsYXJEYXRhKHJlc3VsdDogUHJvbURhdGEpOiByZXN1bHQgaXMgUHJvbUV4ZW1wbGFyRGF0YVtdIHtcbiAgaWYgKHJlc3VsdCA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyAnZXhlbXBsYXJzJyBpbiByZXN1bHRbMF0gOiBmYWxzZTtcbn1cblxuZXhwb3J0IHR5cGUgTWF0cml4T3JWZWN0b3JSZXN1bHQgPSBQcm9tTWF0cml4RGF0YVsncmVzdWx0J11bMF0gfCBQcm9tVmVjdG9yRGF0YVsncmVzdWx0J11bMF07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtT3B0aW9ucyB7XG4gIGZvcm1hdD86IHN0cmluZztcbiAgc3RlcD86IG51bWJlcjtcbiAgbGVnZW5kRm9ybWF0Pzogc3RyaW5nO1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgcXVlcnk6IHN0cmluZztcbiAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBudW1iZXI7XG4gIHNjb3BlZFZhcnM/OiBTY29wZWRWYXJzO1xuICByZWZJZDogc3RyaW5nO1xuICB2YWx1ZVdpdGhSZWZJZD86IGJvb2xlYW47XG4gIG1ldGE6IFF1ZXJ5UmVzdWx0TWV0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTGFiZWxRdWVyeVJlc3BvbnNlIHtcbiAgZGF0YToge1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIGRhdGE6IHN0cmluZ1tdO1xuICB9O1xuICBjYW5jZWxsZWQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEF1dG8gPSBxdWVyeS5sZWdlbmRGb3JtYXQgPT0gJ19fYXV0bydcbiAqIFZlcmJvc2UgPSBxdWVyeS5sZWdlbmRGb3JtYXQgPT0gbnVsbC91bmRlZmluZWQvJydcbiAqIEN1c3RvbSBxdWVyeS5sZWdlbmRGb3JtYXQubGVuZ3RoID4gMCAmJiBxdWVyeS5sZWdlbmRGb3JtYXQgIT09ICdfX2F1dG8nXG4gKi9cbmV4cG9ydCBlbnVtIExlZ2VuZEZvcm1hdE1vZGUge1xuICBBdXRvID0gJ19fYXV0bycsXG4gIFZlcmJvc2UgPSAnX192ZXJib3NlJyxcbiAgQ3VzdG9tID0gJ19fY3VzdG9tJyxcbn1cbiIsImltcG9ydCB7IGZyb20sIE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBEYXRhUXVlcnlSZXF1ZXN0LFxuICBEYXRhUXVlcnlSZXNwb25zZSxcbiAgcmFuZ2VVdGlsLFxuICBTdGFuZGFyZFZhcmlhYmxlUXVlcnksXG4gIFN0YW5kYXJkVmFyaWFibGVTdXBwb3J0LFxufSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGdldFRlbXBsYXRlU3J2LCBUZW1wbGF0ZVNydiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBQcm9tZXRoZXVzTWV0cmljRmluZFF1ZXJ5IGZyb20gJy4vbWV0cmljX2ZpbmRfcXVlcnknO1xuaW1wb3J0IHsgZ2V0VGltZVNydiwgVGltZVNydiB9IGZyb20gJy4uLy4uLy4uL2ZlYXR1cmVzL2Rhc2hib2FyZC9zZXJ2aWNlcy9UaW1lU3J2JztcblxuZXhwb3J0IGNsYXNzIFByb21ldGhldXNWYXJpYWJsZVN1cHBvcnQgZXh0ZW5kcyBTdGFuZGFyZFZhcmlhYmxlU3VwcG9ydDxQcm9tZXRoZXVzRGF0YXNvdXJjZT4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGVtcGxhdGVTcnY6IFRlbXBsYXRlU3J2ID0gZ2V0VGVtcGxhdGVTcnYoKSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRpbWVTcnY6IFRpbWVTcnYgPSBnZXRUaW1lU3J2KClcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcXVlcnkocmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KTogT2JzZXJ2YWJsZTxEYXRhUXVlcnlSZXNwb25zZT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gcmVxdWVzdC50YXJnZXRzWzBdLmV4cHI7XG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIG9mKHsgZGF0YTogW10gfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVkVmFycyA9IHtcbiAgICAgIC4uLnJlcXVlc3Quc2NvcGVkVmFycyxcbiAgICAgIF9faW50ZXJ2YWw6IHsgdGV4dDogdGhpcy5kYXRhc291cmNlLmludGVydmFsLCB2YWx1ZTogdGhpcy5kYXRhc291cmNlLmludGVydmFsIH0sXG4gICAgICBfX2ludGVydmFsX21zOiB7XG4gICAgICAgIHRleHQ6IHJhbmdlVXRpbC5pbnRlcnZhbFRvTXModGhpcy5kYXRhc291cmNlLmludGVydmFsKSxcbiAgICAgICAgdmFsdWU6IHJhbmdlVXRpbC5pbnRlcnZhbFRvTXModGhpcy5kYXRhc291cmNlLmludGVydmFsKSxcbiAgICAgIH0sXG4gICAgICAuLi50aGlzLmRhdGFzb3VyY2UuZ2V0UmFuZ2VTY29wZWRWYXJzKHRoaXMudGltZVNydi50aW1lUmFuZ2UoKSksXG4gICAgfTtcblxuICAgIGNvbnN0IGludGVycG9sYXRlZCA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeSwgc2NvcGVkVmFycywgdGhpcy5kYXRhc291cmNlLmludGVycG9sYXRlUXVlcnlFeHByKTtcbiAgICBjb25zdCBtZXRyaWNGaW5kUXVlcnkgPSBuZXcgUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSh0aGlzLmRhdGFzb3VyY2UsIGludGVycG9sYXRlZCk7XG4gICAgY29uc3QgbWV0cmljRmluZFN0cmVhbSA9IGZyb20obWV0cmljRmluZFF1ZXJ5LnByb2Nlc3MoKSk7XG5cbiAgICByZXR1cm4gbWV0cmljRmluZFN0cmVhbS5waXBlKG1hcCgocmVzdWx0cykgPT4gKHsgZGF0YTogcmVzdWx0cyB9KSkpO1xuICB9XG5cbiAgdG9EYXRhUXVlcnkocXVlcnk6IFN0YW5kYXJkVmFyaWFibGVRdWVyeSk6IFByb21RdWVyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkOiAnUHJvbWV0aGV1c0RhdGFzb3VyY2UtVmFyaWFibGVRdWVyeScsXG4gICAgICBleHByOiBxdWVyeS5xdWVyeSxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVByZXZpb3VzKHN0YXRlKSB7XG4gICAgdmFyIHJlZiA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gc3RhdGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuIiwiaW1wb3J0IHsgdXNlUmVkdWNlciB9IGZyb20gJ3JlYWN0JztcbnZhciB0b2dnbGVSZWR1Y2VyID0gZnVuY3Rpb24gKHN0YXRlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5leHRWYWx1ZSA9PT0gJ2Jvb2xlYW4nID8gbmV4dFZhbHVlIDogIXN0YXRlO1xufTtcbnZhciB1c2VUb2dnbGUgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgcmV0dXJuIHVzZVJlZHVjZXIodG9nZ2xlUmVkdWNlciwgaW5pdGlhbFZhbHVlKTtcbn07XG5leHBvcnQgZGVmYXVsdCB1c2VUb2dnbGU7XG4iLCJjb25zdCBwZXJmID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiBwZXJmb3JtYW5jZSAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nID8gcGVyZm9ybWFuY2UgOiBEYXRlXG5cbmNvbnN0IGhhc0Fib3J0Q29udHJvbGxlciA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT09ICd1bmRlZmluZWQnXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbWluaW1hbCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwb2x5ZmlsbCAqL1xuY29uc3QgQUMgPSBoYXNBYm9ydENvbnRyb2xsZXIgPyBBYm9ydENvbnRyb2xsZXIgOiBPYmplY3QuYXNzaWduKFxuICBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yICgpIHsgdGhpcy5zaWduYWwgPSBuZXcgQUMuQWJvcnRTaWduYWwgfVxuICAgIGFib3J0ICgpIHsgdGhpcy5zaWduYWwuYWJvcnRlZCA9IHRydWUgfVxuICB9LFxuICB7IEFib3J0U2lnbmFsOiBjbGFzcyBBYm9ydFNpZ25hbCB7IGNvbnN0cnVjdG9yICgpIHsgdGhpcy5hYm9ydGVkID0gZmFsc2UgfX19XG4pXG5cbmNvbnN0IHdhcm5lZCA9IG5ldyBTZXQoKVxuY29uc3QgZGVwcmVjYXRlZE9wdGlvbiA9IChvcHQsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfT1BUSU9OXyR7b3B0fWBcbiAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICB3YXJuKGNvZGUsIGAke29wdH0gb3B0aW9uYCwgYG9wdGlvbnMuJHtpbnN0ZWFkfWAsIExSVUNhY2hlKVxuICB9XG59XG5jb25zdCBkZXByZWNhdGVkTWV0aG9kID0gKG1ldGhvZCwgaW5zdGVhZCkgPT4ge1xuICBjb25zdCBjb2RlID0gYExSVV9DQUNIRV9NRVRIT0RfJHttZXRob2R9YFxuICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgIGNvbnN0IHsgcHJvdG90eXBlIH0gPSBMUlVDYWNoZVxuICAgIGNvbnN0IHsgZ2V0IH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgbWV0aG9kKVxuICAgIHdhcm4oY29kZSwgYCR7bWV0aG9kfSBtZXRob2RgLCBgY2FjaGUuJHtpbnN0ZWFkfSgpYCwgZ2V0KVxuICB9XG59XG5jb25zdCBkZXByZWNhdGVkUHJvcGVydHkgPSAoZmllbGQsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfUFJPUEVSVFlfJHtmaWVsZH1gXG4gIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgY29uc3QgeyBwcm90b3R5cGUgfSA9IExSVUNhY2hlXG4gICAgY29uc3QgeyBnZXQgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBmaWVsZClcbiAgICB3YXJuKGNvZGUsIGAke2ZpZWxkfSBwcm9wZXJ0eWAsIGBjYWNoZS4ke2luc3RlYWR9YCwgZ2V0KVxuICB9XG59XG5cbmNvbnN0IHNob3VsZFdhcm4gPSBjb2RlID0+IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzICYmXG4gICF3YXJuZWQuaGFzKGNvZGUpXG5cbmNvbnN0IHdhcm4gPSAoY29kZSwgd2hhdCwgaW5zdGVhZCwgZm4pID0+IHtcbiAgd2FybmVkLmFkZChjb2RlKVxuICBjb25zdCBtc2cgPSBgVGhlICR7d2hhdH0gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAke2luc3RlYWR9IGluc3RlYWQuYFxuICBwcm9jZXNzLmVtaXRXYXJuaW5nKG1zZywgJ0RlcHJlY2F0aW9uV2FybmluZycsIGNvZGUsIGZuKVxufVxuXG5jb25zdCBpc1Bvc0ludCA9IG4gPT4gbiAmJiBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPiAwICYmIGlzRmluaXRlKG4pXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gVGhpcyBpcyBhIGxpdHRsZSBiaXQgcmlkaWN1bG91cywgdGJoLlxuICogVGhlIG1heGltdW0gYXJyYXkgbGVuZ3RoIGlzIDJeMzItMSBvciB0aGVyZWFib3V0cyBvbiBtb3N0IEpTIGltcGxzLlxuICogQW5kIHdlbGwgYmVmb3JlIHRoYXQgcG9pbnQsIHlvdSdyZSBjYWNoaW5nIHRoZSBlbnRpcmUgd29ybGQsIEkgbWVhbixcbiAqIHRoYXQncyB+MzJHQiBvZiBqdXN0IGludGVnZXJzIGZvciB0aGUgbmV4dC9wcmV2IGxpbmtzLCBwbHVzIHdoYXRldmVyXG4gKiBlbHNlIHRvIGhvbGQgdGhhdCBtYW55IGtleXMgYW5kIHZhbHVlcy4gIEp1c3QgZmlsbGluZyB0aGUgbWVtb3J5IHdpdGhcbiAqIHplcm9lcyBhdCBpbml0IHRpbWUgaXMgYnJ1dGFsIHdoZW4geW91IGdldCB0aGF0IGJpZy5cbiAqIEJ1dCB3aHkgbm90IGJlIGNvbXBsZXRlP1xuICogTWF5YmUgaW4gdGhlIGZ1dHVyZSwgdGhlc2UgbGltaXRzIHdpbGwgaGF2ZSBleHBhbmRlZC4gKi9cbmNvbnN0IGdldFVpbnRBcnJheSA9IG1heCA9PiAhaXNQb3NJbnQobWF4KSA/IG51bGxcbjogbWF4IDw9IE1hdGgucG93KDIsIDgpID8gVWludDhBcnJheVxuOiBtYXggPD0gTWF0aC5wb3coMiwgMTYpID8gVWludDE2QXJyYXlcbjogbWF4IDw9IE1hdGgucG93KDIsIDMyKSA/IFVpbnQzMkFycmF5XG46IG1heCA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA/IFplcm9BcnJheVxuOiBudWxsXG5cbmNsYXNzIFplcm9BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IgKHNpemUpIHtcbiAgICBzdXBlcihzaXplKVxuICAgIHRoaXMuZmlsbCgwKVxuICB9XG59XG5cbmNsYXNzIFN0YWNrIHtcbiAgY29uc3RydWN0b3IgKG1heCkge1xuICAgIGNvbnN0IFVpbnRBcnJheSA9IG1heCA/IGdldFVpbnRBcnJheShtYXgpIDogQXJyYXlcbiAgICB0aGlzLmhlYXAgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgfVxuICBwdXNoIChuKSB7XG4gICAgdGhpcy5oZWFwW3RoaXMubGVuZ3RoKytdID0gblxuICB9XG4gIHBvcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFstLXRoaXMubGVuZ3RoXVxuICB9XG59XG5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1heCA9IDAsXG4gICAgICB0dGwsXG4gICAgICB0dGxSZXNvbHV0aW9uID0gMSxcbiAgICAgIHR0bEF1dG9wdXJnZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0LFxuICAgICAgYWxsb3dTdGFsZSxcbiAgICAgIGRpc3Bvc2UsXG4gICAgICBkaXNwb3NlQWZ0ZXIsXG4gICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgIG5vVXBkYXRlVFRMLFxuICAgICAgbWF4U2l6ZSA9IDAsXG4gICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICBmZXRjaE1ldGhvZCxcbiAgICB9ID0gb3B0aW9uc1xuXG4gICAgLy8gZGVwcmVjYXRlZCBvcHRpb25zLCBkb24ndCB0cmlnZ2VyIGEgd2FybmluZyBmb3IgZ2V0dGluZyB0aGVtIGlmXG4gICAgLy8gdGhlIHRoaW5nIGJlaW5nIHBhc3NlZCBpbiBpcyBhbm90aGVyIExSVUNhY2hlIHdlJ3JlIGNvcHlpbmcuXG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoLFxuICAgICAgbWF4QWdlLFxuICAgICAgc3RhbGUsXG4gICAgfSA9IG9wdGlvbnMgaW5zdGFuY2VvZiBMUlVDYWNoZSA/IHt9IDogb3B0aW9uc1xuXG4gICAgaWYgKG1heCAhPT0gMCAmJiAhaXNQb3NJbnQobWF4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpXG4gICAgfVxuXG4gICAgY29uc3QgVWludEFycmF5ID0gbWF4ID8gZ2V0VWludEFycmF5KG1heCkgOiBBcnJheVxuICAgIGlmICghVWludEFycmF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IHZhbHVlOiAnICsgbWF4KVxuICAgIH1cblxuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZVxuICAgIHRoaXMuc2l6ZUNhbGN1bGF0aW9uID0gc2l6ZUNhbGN1bGF0aW9uIHx8IGxlbmd0aFxuICAgIGlmICh0aGlzLnNpemVDYWxjdWxhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLm1heFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUnKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpbmcgc2V0IHRvIG5vbi1mdW5jdGlvbicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaE1ldGhvZCA9IGZldGNoTWV0aG9kIHx8IG51bGxcbiAgICBpZiAodGhpcy5mZXRjaE1ldGhvZCAmJiB0eXBlb2YgdGhpcy5mZXRjaE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmV0Y2hNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHNwZWNpZmllZCcpXG4gICAgfVxuXG5cbiAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKVxuICAgIHRoaXMua2V5TGlzdCA9IG5ldyBBcnJheShtYXgpLmZpbGwobnVsbClcbiAgICB0aGlzLnZhbExpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKG51bGwpXG4gICAgdGhpcy5uZXh0ID0gbmV3IFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5wcmV2ID0gbmV3IFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5oZWFkID0gMFxuICAgIHRoaXMudGFpbCA9IDBcbiAgICB0aGlzLmZyZWUgPSBuZXcgU3RhY2sobWF4KVxuICAgIHRoaXMuaW5pdGlhbEZpbGwgPSAxXG4gICAgdGhpcy5zaXplID0gMFxuXG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UgPSBkaXNwb3NlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZUFmdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VBZnRlciA9IGRpc3Bvc2VBZnRlclxuICAgICAgdGhpcy5kaXNwb3NlZCA9IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcG9zZUFmdGVyID0gbnVsbFxuICAgICAgdGhpcy5kaXNwb3NlZCA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5ub0Rpc3Bvc2VPblNldCA9ICEhbm9EaXNwb3NlT25TZXRcbiAgICB0aGlzLm5vVXBkYXRlVFRMID0gISFub1VwZGF0ZVRUTFxuXG4gICAgaWYgKHRoaXMubWF4U2l6ZSAhPT0gMCkge1xuICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLm1heFNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJylcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVNpemVUcmFja2luZygpXG4gICAgfVxuXG4gICAgdGhpcy5hbGxvd1N0YWxlID0gISFhbGxvd1N0YWxlIHx8ICEhc3RhbGVcbiAgICB0aGlzLnVwZGF0ZUFnZU9uR2V0ID0gISF1cGRhdGVBZ2VPbkdldFxuICAgIHRoaXMudHRsUmVzb2x1dGlvbiA9IGlzUG9zSW50KHR0bFJlc29sdXRpb24pIHx8IHR0bFJlc29sdXRpb24gPT09IDBcbiAgICAgID8gdHRsUmVzb2x1dGlvbiA6IDFcbiAgICB0aGlzLnR0bEF1dG9wdXJnZSA9ICEhdHRsQXV0b3B1cmdlXG4gICAgdGhpcy50dGwgPSB0dGwgfHwgbWF4QWdlIHx8IDBcbiAgICBpZiAodGhpcy50dGwpIHtcbiAgICAgIGlmICghaXNQb3NJbnQodGhpcy50dGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R0bCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy5pbml0aWFsaXplVFRMVHJhY2tpbmcoKVxuICAgIH1cblxuICAgIC8vIGRvIG5vdCBhbGxvdyBjb21wbGV0ZWx5IHVuYm91bmRlZCBjYWNoZXNcbiAgICBpZiAodGhpcy5tYXggPT09IDAgJiYgdGhpcy50dGwgPT09IDAgJiYgdGhpcy5tYXhTaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdCBsZWFzdCBvbmUgb2YgbWF4LCBtYXhTaXplLCBvciB0dGwgaXMgcmVxdWlyZWQnKVxuICAgIH1cbiAgICBpZiAoIXRoaXMudHRsQXV0b3B1cmdlICYmICF0aGlzLm1heCAmJiAhdGhpcy5tYXhTaXplKSB7XG4gICAgICBjb25zdCBjb2RlID0gJ0xSVV9DQUNIRV9VTkJPVU5ERUQnXG4gICAgICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgICAgICB3YXJuZWQuYWRkKGNvZGUpXG4gICAgICAgIGNvbnN0IG1zZyA9ICdUVEwgY2FjaGluZyB3aXRob3V0IHR0bEF1dG9wdXJnZSwgbWF4LCBvciBtYXhTaXplIGNhbiAnICtcbiAgICAgICAgICAncmVzdWx0IGluIHVuYm91bmRlZCBtZW1vcnkgY29uc3VtcHRpb24uJ1xuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG1zZywgJ1VuYm91bmRlZENhY2hlV2FybmluZycsIGNvZGUsIExSVUNhY2hlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFsZSkge1xuICAgICAgZGVwcmVjYXRlZE9wdGlvbignc3RhbGUnLCAnYWxsb3dTdGFsZScpXG4gICAgfVxuICAgIGlmIChtYXhBZ2UpIHtcbiAgICAgIGRlcHJlY2F0ZWRPcHRpb24oJ21heEFnZScsICd0dGwnKVxuICAgIH1cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBkZXByZWNhdGVkT3B0aW9uKCdsZW5ndGgnLCAnc2l6ZUNhbGN1bGF0aW9uJylcbiAgICB9XG4gIH1cblxuICBnZXRSZW1haW5pbmdUVEwgKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhrZXkpID8gSW5maW5pdHkgOiAwXG4gIH1cblxuICBpbml0aWFsaXplVFRMVHJhY2tpbmcgKCkge1xuICAgIHRoaXMudHRscyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG4gICAgdGhpcy5zdGFydHMgPSBuZXcgWmVyb0FycmF5KHRoaXMubWF4KVxuXG4gICAgdGhpcy5zZXRJdGVtVFRMID0gKGluZGV4LCB0dGwpID0+IHtcbiAgICAgIHRoaXMuc3RhcnRzW2luZGV4XSA9IHR0bCAhPT0gMCA/IHBlcmYubm93KCkgOiAwXG4gICAgICB0aGlzLnR0bHNbaW5kZXhdID0gdHRsXG4gICAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsQXV0b3B1cmdlKSB7XG4gICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUodGhpcy5rZXlMaXN0W2luZGV4XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHR0bCArIDEpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gdW5yZWYoKSBub3Qgc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMgKi9cbiAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICB0LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlSXRlbUFnZSA9IChpbmRleCkgPT4ge1xuICAgICAgdGhpcy5zdGFydHNbaW5kZXhdID0gdGhpcy50dGxzW2luZGV4XSAhPT0gMCA/IHBlcmYubm93KCkgOiAwXG4gICAgfVxuXG4gICAgLy8gZGVib3VuY2UgY2FsbHMgdG8gcGVyZi5ub3coKSB0byAxcyBzbyB3ZSdyZSBub3QgaGl0dGluZ1xuICAgIC8vIHRoYXQgY29zdGx5IGNhbGwgcmVwZWF0ZWRseS5cbiAgICBsZXQgY2FjaGVkTm93ID0gMFxuICAgIGNvbnN0IGdldE5vdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBwZXJmLm5vdygpXG4gICAgICBpZiAodGhpcy50dGxSZXNvbHV0aW9uID4gMCkge1xuICAgICAgICBjYWNoZWROb3cgPSBuXG4gICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IGNhY2hlZE5vdyA9IDAsIHRoaXMudHRsUmVzb2x1dGlvbilcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBub3QgYXZhaWxhYmxlIG9uIGFsbCBwbGF0Zm9ybXMgKi9cbiAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICB0LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5cbiAgICB9XG5cbiAgICB0aGlzLmdldFJlbWFpbmluZ1RUTCA9IChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGtleSlcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50dGxzW2luZGV4XSA9PT0gMCB8fCB0aGlzLnN0YXJ0c1tpbmRleF0gPT09IDAgPyBJbmZpbml0eVxuICAgICAgICA6ICgodGhpcy5zdGFydHNbaW5kZXhdICsgdGhpcy50dGxzW2luZGV4XSkgLSAoY2FjaGVkTm93IHx8IGdldE5vdygpKSlcbiAgICB9XG5cbiAgICB0aGlzLmlzU3RhbGUgPSAoaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnR0bHNbaW5kZXhdICE9PSAwICYmIHRoaXMuc3RhcnRzW2luZGV4XSAhPT0gMCAmJlxuICAgICAgICAoKGNhY2hlZE5vdyB8fCBnZXROb3coKSkgLSB0aGlzLnN0YXJ0c1tpbmRleF0gPiB0aGlzLnR0bHNbaW5kZXhdKVxuICAgIH1cbiAgfVxuICB1cGRhdGVJdGVtQWdlIChpbmRleCkge31cbiAgc2V0SXRlbVRUTCAoaW5kZXgsIHR0bCkge31cbiAgaXNTdGFsZSAoaW5kZXgpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpbml0aWFsaXplU2l6ZVRyYWNraW5nICgpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZWRTaXplID0gMFxuICAgIHRoaXMuc2l6ZXMgPSBuZXcgWmVyb0FycmF5KHRoaXMubWF4KVxuICAgIHRoaXMucmVtb3ZlSXRlbVNpemUgPSBpbmRleCA9PiB0aGlzLmNhbGN1bGF0ZWRTaXplIC09IHRoaXMuc2l6ZXNbaW5kZXhdXG4gICAgdGhpcy5yZXF1aXJlU2l6ZSA9IChrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pID0+IHtcbiAgICAgIGlmIChzaXplQ2FsY3VsYXRpb24gJiYgIXNpemUpIHtcbiAgICAgICAgc2l6ZSA9IHNpemVDYWxjdWxhdGlvbih2LCBrKVxuICAgICAgfVxuICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcicpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2l6ZVxuICAgIH1cbiAgICB0aGlzLmFkZEl0ZW1TaXplID0gKGluZGV4LCB2LCBrLCBzaXplKSA9PiB7XG4gICAgICB0aGlzLnNpemVzW2luZGV4XSA9IHNpemVcbiAgICAgIGNvbnN0IG1heFNpemUgPSB0aGlzLm1heFNpemUgLSB0aGlzLnNpemVzW2luZGV4XVxuICAgICAgd2hpbGUgKHRoaXMuY2FsY3VsYXRlZFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHRoaXMuZXZpY3QoKVxuICAgICAgfVxuICAgICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSArPSB0aGlzLnNpemVzW2luZGV4XVxuICAgIH1cbiAgICB0aGlzLmRlbGV0ZSA9IGsgPT4ge1xuICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gMCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgLT0gdGhpcy5zaXplc1tpbmRleF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIExSVUNhY2hlLnByb3RvdHlwZS5kZWxldGUuY2FsbCh0aGlzLCBrKVxuICAgIH1cbiAgfVxuICByZW1vdmVJdGVtU2l6ZSAoaW5kZXgpIHt9XG4gIGFkZEl0ZW1TaXplIChpbmRleCwgdiwgaywgc2l6ZSkge31cbiAgcmVxdWlyZVNpemUgKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikge1xuICAgIGlmIChzaXplIHx8IHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9uIGNhY2hlJylcbiAgICB9XG4gIH1cblxuICAqaW5kZXhlcyAoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnRhaWw7IHRydWU7ICkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgICAgeWllbGQgaVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSB0aGlzLnByZXZbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICpyaW5kZXhlcyAoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYWQ7IHRydWU7ICkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgICAgeWllbGQgaVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSB0aGlzLm5leHRbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWRJbmRleCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlNYXAuZ2V0KHRoaXMua2V5TGlzdFtpbmRleF0pID09PSBpbmRleFxuICB9XG5cbiAgKmVudHJpZXMgKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgW3RoaXMua2V5TGlzdFtpXSwgdGhpcy52YWxMaXN0W2ldXVxuICAgIH1cbiAgfVxuICAqcmVudHJpZXMgKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIFt0aGlzLmtleUxpc3RbaV0sIHRoaXMudmFsTGlzdFtpXV1cbiAgICB9XG4gIH1cblxuICAqa2V5cyAoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLmtleUxpc3RbaV1cbiAgICB9XG4gIH1cbiAgKnJrZXlzICgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLmtleUxpc3RbaV1cbiAgICB9XG4gIH1cblxuICAqdmFsdWVzICgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIHRoaXMudmFsTGlzdFtpXVxuICAgIH1cbiAgfVxuICAqcnZhbHVlcyAoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy52YWxMaXN0W2ldXG4gICAgfVxuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgZmluZCAoZm4sIGdldE9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgaWYgKGZuKHRoaXMudmFsTGlzdFtpXSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5rZXlMaXN0W2ldLCBnZXRPcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGZuLmNhbGwodGhpc3AsIHRoaXMudmFsTGlzdFtpXSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgZm4uY2FsbCh0aGlzcCwgdGhpcy52YWxMaXN0W2ldLCB0aGlzLmtleUxpc3RbaV0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgZ2V0IHBydW5lICgpIHtcbiAgICBkZXByZWNhdGVkTWV0aG9kKCdwcnVuZScsICdwdXJnZVN0YWxlJylcbiAgICByZXR1cm4gdGhpcy5wdXJnZVN0YWxlXG4gIH1cblxuICBwdXJnZVN0YWxlICgpIHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICBpZiAodGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKHRoaXMua2V5TGlzdFtpXSlcbiAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWRcbiAgfVxuXG4gIGR1bXAgKCkge1xuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmtleUxpc3RbaV1cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWxMaXN0W2ldXG4gICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfVxuICAgICAgaWYgKHRoaXMudHRscykge1xuICAgICAgICBlbnRyeS50dGwgPSB0aGlzLnR0bHNbaV1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemVzKSB7XG4gICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLnNpemVzW2ldXG4gICAgICB9XG4gICAgICBhcnIudW5zaGlmdChba2V5LCBlbnRyeV0pXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIHRoaXMuY2xlYXIoKVxuICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIGFycikge1xuICAgICAgdGhpcy5zZXQoa2V5LCBlbnRyeS52YWx1ZSwgZW50cnkpXG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSAodiwgaywgcmVhc29uKSB7fVxuXG4gIHNldCAoaywgdiwge1xuICAgIHR0bCA9IHRoaXMudHRsLFxuICAgIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCxcbiAgICBzaXplID0gMCxcbiAgICBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbixcbiAgICBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsXG4gIH0gPSB7fSkge1xuICAgIHNpemUgPSB0aGlzLnJlcXVpcmVTaXplKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbilcbiAgICBsZXQgaW5kZXggPSB0aGlzLnNpemUgPT09IDAgPyB1bmRlZmluZWQgOiB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWRkaXRpb25cbiAgICAgIGluZGV4ID0gdGhpcy5uZXdJbmRleCgpXG4gICAgICB0aGlzLmtleUxpc3RbaW5kZXhdID0ga1xuICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHZcbiAgICAgIHRoaXMua2V5TWFwLnNldChrLCBpbmRleClcbiAgICAgIHRoaXMubmV4dFt0aGlzLnRhaWxdID0gaW5kZXhcbiAgICAgIHRoaXMucHJldltpbmRleF0gPSB0aGlzLnRhaWxcbiAgICAgIHRoaXMudGFpbCA9IGluZGV4XG4gICAgICB0aGlzLnNpemUgKytcbiAgICAgIHRoaXMuYWRkSXRlbVNpemUoaW5kZXgsIHYsIGssIHNpemUpXG4gICAgICBub1VwZGF0ZVRUTCA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgY29uc3Qgb2xkVmFsID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgaWYgKHYgIT09IG9sZFZhbCkge1xuICAgICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaChvbGRWYWwpKSB7XG4gICAgICAgICAgb2xkVmFsLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2Uob2xkVmFsLCBrLCAnc2V0JylcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW29sZFZhbCwgaywgJ3NldCddKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUl0ZW1TaXplKGluZGV4KVxuICAgICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gdlxuICAgICAgICB0aGlzLmFkZEl0ZW1TaXplKGluZGV4LCB2LCBrLCBzaXplKVxuICAgICAgfVxuICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgIH1cbiAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsID09PSAwICYmICF0aGlzLnR0bHMpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVRUTFRyYWNraW5nKClcbiAgICB9XG4gICAgaWYgKCFub1VwZGF0ZVRUTCkge1xuICAgICAgdGhpcy5zZXRJdGVtVFRMKGluZGV4LCB0dGwpXG4gICAgfVxuICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG5ld0luZGV4ICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWlsXG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IHRoaXMubWF4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmljdCgpXG4gICAgfVxuICAgIGlmICh0aGlzLmZyZWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmVlLnBvcCgpXG4gICAgfVxuICAgIC8vIGluaXRpYWwgZmlsbCwganVzdCBrZWVwIHdyaXRpbmcgZG93biB0aGUgbGlzdFxuICAgIHJldHVybiB0aGlzLmluaXRpYWxGaWxsKytcbiAgfVxuXG4gIHBvcCAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy52YWxMaXN0W3RoaXMuaGVhZF1cbiAgICAgIHRoaXMuZXZpY3QoKVxuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgfVxuXG4gIGV2aWN0ICgpIHtcbiAgICBjb25zdCBoZWFkID0gdGhpcy5oZWFkXG4gICAgY29uc3QgayA9IHRoaXMua2V5TGlzdFtoZWFkXVxuICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaGVhZF1cbiAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcG9zZSh2LCBrLCAnZXZpY3QnKVxuICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2V2aWN0J10pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlSXRlbVNpemUoaGVhZClcbiAgICB0aGlzLmhlYWQgPSB0aGlzLm5leHRbaGVhZF1cbiAgICB0aGlzLmtleU1hcC5kZWxldGUoaylcbiAgICB0aGlzLnNpemUgLS1cbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgaGFzIChrKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5TWFwLmhhcyhrKSAmJiAhdGhpcy5pc1N0YWxlKHRoaXMua2V5TWFwLmdldChrKSlcbiAgfVxuXG4gIC8vIGxpa2UgZ2V0KCksIGJ1dCB3aXRob3V0IGFueSBMUlUgdXBkYXRpbmcgb3IgVFRMIGV4cGlyYXRpb25cbiAgcGVlayAoaywgeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpbmRleCkpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgIH1cbiAgfVxuXG4gIGJhY2tncm91bmRGZXRjaCAoaywgaW5kZXgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB2ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgcmV0dXJuIHZcbiAgICB9XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgIG9wdGlvbnMsXG4gICAgfVxuICAgIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUodGhpcy5mZXRjaE1ldGhvZChrLCB2LCBmZXRjaE9wdHMpKS50aGVuKHYgPT4ge1xuICAgICAgaWYgKCFhYy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aGlzLnNldChrLCB2LCBmZXRjaE9wdHMub3B0aW9ucylcbiAgICAgIH1cbiAgICAgIHJldHVybiB2XG4gICAgfSlcbiAgICBwLl9fYWJvcnRDb250cm9sbGVyID0gYWNcbiAgICBwLl9fc3RhbGVXaGlsZUZldGNoaW5nID0gdlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldChrLCBwLCBmZXRjaE9wdHMub3B0aW9ucylcbiAgICAgIGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSBwXG4gICAgfVxuICAgIHJldHVybiBwXG4gIH1cblxuICBpc0JhY2tncm91bmRGZXRjaCAocCkge1xuICAgIHJldHVybiBwICYmIHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCwgJ19fc3RhbGVXaGlsZUZldGNoaW5nJylcbiAgfVxuXG4gIC8vIHRoaXMgdGFrZXMgdGhlIHVuaW9uIG9mIGdldCgpIGFuZCBzZXQoKSBvcHRzLCBiZWNhdXNlIGl0IGRvZXMgYm90aFxuICBhc3luYyBmZXRjaCAoaywge1xuICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsXG4gICAgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LFxuICAgIHR0bCA9IHRoaXMudHRsLFxuICAgIG5vRGlzcG9zZU9uU2V0ID0gdGhpcy5ub0Rpc3Bvc2VPblNldCxcbiAgICBzaXplID0gMCxcbiAgICBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbixcbiAgICBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5mZXRjaE1ldGhvZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGssIHthbGxvd1N0YWxlLCB1cGRhdGVBZ2VPbkdldH0pXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGFsbG93U3RhbGUsXG4gICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgIHR0bCxcbiAgICAgIG5vRGlzcG9zZU9uU2V0LFxuICAgICAgc2l6ZSxcbiAgICAgIHNpemVDYWxjdWxhdGlvbixcbiAgICAgIG5vVXBkYXRlVFRMLFxuICAgIH1cblxuICAgIGxldCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIGNhY2hlLCBtYXliZSBhbHJlYWR5IGZldGNoaW5nXG4gICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgJiYgdi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogdlxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cblxuICAgICAgLy8gb2ssIGl0IGlzIHN0YWxlLCBhbmQgbm90IGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgIC8vIHJlZnJlc2ggdGhlIGNhY2hlLlxuICAgICAgY29uc3QgcCA9IHRoaXMuYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zKVxuICAgICAgcmV0dXJuIGFsbG93U3RhbGUgJiYgcC5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHBcbiAgICB9XG4gIH1cblxuICBnZXQgKGssIHtcbiAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLFxuICAgIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCxcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBjb25zdCBmZXRjaGluZyA9IHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godmFsdWUpXG4gICAgICBpZiAodGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAvLyBkZWxldGUgb25seSBpZiBub3QgYW4gaW4tZmxpZ2h0IGJhY2tncm91bmQgZmV0Y2hcbiAgICAgICAgaWYgKCFmZXRjaGluZykge1xuICAgICAgICAgIHRoaXMuZGVsZXRlKGspXG4gICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZSA6IHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UncmUgY3VycmVudGx5IGZldGNoaW5nIGl0LCB3ZSBkb24ndCBhY3R1YWxseSBoYXZlIGl0IHlldFxuICAgICAgICAvLyBpdCdzIG5vdCBzdGFsZSwgd2hpY2ggbWVhbnMgdGhpcyBpc24ndCBhIHN0YWxlV2hpbGVSZWZldGNoaW5nLFxuICAgICAgICAvLyBzbyB3ZSBqdXN0IHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYgKGZldGNoaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICAgICAgaWYgKHVwZGF0ZUFnZU9uR2V0KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVJdGVtQWdlKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QgKHAsIG4pIHtcbiAgICB0aGlzLnByZXZbbl0gPSBwXG4gICAgdGhpcy5uZXh0W3BdID0gblxuICB9XG5cbiAgbW92ZVRvVGFpbCAoaW5kZXgpIHtcbiAgICAvLyBpZiB0YWlsIGFscmVhZHksIG5vdGhpbmcgdG8gZG9cbiAgICAvLyBpZiBoZWFkLCBtb3ZlIGhlYWQgdG8gbmV4dFtpbmRleF1cbiAgICAvLyBlbHNlXG4gICAgLy8gICBtb3ZlIG5leHRbcHJldltpbmRleF1dIHRvIG5leHRbaW5kZXhdIChoZWFkIGhhcyBubyBwcmV2KVxuICAgIC8vICAgbW92ZSBwcmV2W25leHRbaW5kZXhdXSB0byBwcmV2W2luZGV4XVxuICAgIC8vIHByZXZbaW5kZXhdID0gdGFpbFxuICAgIC8vIG5leHRbdGFpbF0gPSBpbmRleFxuICAgIC8vIHRhaWwgPSBpbmRleFxuICAgIGlmIChpbmRleCAhPT0gdGhpcy50YWlsKSB7XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuaGVhZCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLm5leHRbaW5kZXhdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5wcmV2W2luZGV4XSwgdGhpcy5uZXh0W2luZGV4XSlcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnRhaWwsIGluZGV4KVxuICAgICAgdGhpcy50YWlsID0gaW5kZXhcbiAgICB9XG4gIH1cblxuICBnZXQgZGVsICgpIHtcbiAgICBkZXByZWNhdGVkTWV0aG9kKCdkZWwnLCAnZGVsZXRlJylcbiAgICByZXR1cm4gdGhpcy5kZWxldGVcbiAgfVxuICBkZWxldGUgKGspIHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG4gICAgaWYgKHRoaXMuc2l6ZSAhPT0gMCkge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlXG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW1TaXplKGluZGV4KVxuICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UodiwgaywgJ2RlbGV0ZScpXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFt2LCBrLCAnZGVsZXRlJ10pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMua2V5TWFwLmRlbGV0ZShrKVxuICAgICAgICAgIHRoaXMua2V5TGlzdFtpbmRleF0gPSBudWxsXG4gICAgICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IG51bGxcbiAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy5wcmV2W2luZGV4XVxuICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5uZXh0W2luZGV4XVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRbdGhpcy5wcmV2W2luZGV4XV0gPSB0aGlzLm5leHRbaW5kZXhdXG4gICAgICAgICAgICB0aGlzLnByZXZbdGhpcy5uZXh0W2luZGV4XV0gPSB0aGlzLnByZXZbaW5kZXhdXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2l6ZSAtLVxuICAgICAgICAgIHRoaXMuZnJlZS5wdXNoKGluZGV4KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICB3aGlsZSAodGhpcy5kaXNwb3NlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIoLi4udGhpcy5kaXNwb3NlZC5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVsZXRlZFxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGhpcy5yaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLmtleUxpc3RbaW5kZXhdXG4gICAgICAgIHRoaXMuZGlzcG9zZSh2LCBrLCAnZGVsZXRlJylcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFt2LCBrLCAnZGVsZXRlJ10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmtleU1hcC5jbGVhcigpXG4gICAgdGhpcy52YWxMaXN0LmZpbGwobnVsbClcbiAgICB0aGlzLmtleUxpc3QuZmlsbChudWxsKVxuICAgIGlmICh0aGlzLnR0bHMpIHtcbiAgICAgIHRoaXMudHRscy5maWxsKDApXG4gICAgICB0aGlzLnN0YXJ0cy5maWxsKDApXG4gICAgfVxuICAgIGlmICh0aGlzLnNpemVzKSB7XG4gICAgICB0aGlzLnNpemVzLmZpbGwoMClcbiAgICB9XG4gICAgdGhpcy5oZWFkID0gMFxuICAgIHRoaXMudGFpbCA9IDBcbiAgICB0aGlzLmluaXRpYWxGaWxsID0gMVxuICAgIHRoaXMuZnJlZS5sZW5ndGggPSAwXG4gICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSA9IDBcbiAgICB0aGlzLnNpemUgPSAwXG4gICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgIHdoaWxlICh0aGlzLmRpc3Bvc2VkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VBZnRlciguLi50aGlzLmRpc3Bvc2VkLnNoaWZ0KCkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCByZXNldCAoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgncmVzZXQnLCAnY2xlYXInKVxuICAgIHJldHVybiB0aGlzLmNsZWFyXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICBkZXByZWNhdGVkUHJvcGVydHkoJ2xlbmd0aCcsICdzaXplJylcbiAgICByZXR1cm4gdGhpcy5zaXplXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3ViamVjdCwgQW5vbnltb3VzU3ViamVjdCB9IGZyb20gJy4uLy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uLy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFJlcGxheVN1YmplY3QgfSBmcm9tICcuLi8uLi9SZXBsYXlTdWJqZWN0JztcbnZhciBERUZBVUxUX1dFQlNPQ0tFVF9DT05GSUcgPSB7XG4gICAgdXJsOiAnJyxcbiAgICBkZXNlcmlhbGl6ZXI6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBKU09OLnBhcnNlKGUuZGF0YSk7IH0sXG4gICAgc2VyaWFsaXplcjogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7IH0sXG59O1xudmFyIFdFQlNPQ0tFVFNVQkpFQ1RfSU5WQUxJRF9FUlJPUl9PQkpFQ1QgPSAnV2ViU29ja2V0U3ViamVjdC5lcnJvciBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdCB3aXRoIGFuIGVycm9yIGNvZGUsIGFuZCBhbiBvcHRpb25hbCByZWFzb246IHsgY29kZTogbnVtYmVyLCByZWFzb246IHN0cmluZyB9JztcbnZhciBXZWJTb2NrZXRTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2ViU29ja2V0U3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRTdWJqZWN0KHVybENvbmZpZ09yU291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fc29ja2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHVybENvbmZpZ09yU291cmNlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZSA9IHVybENvbmZpZ09yU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IChfdGhpcy5fY29uZmlnID0gX19hc3NpZ24oe30sIERFRkFVTFRfV0VCU09DS0VUX0NPTkZJRykpO1xuICAgICAgICAgICAgX3RoaXMuX291dHB1dCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybENvbmZpZ09yU291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy51cmwgPSB1cmxDb25maWdPclNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB1cmxDb25maWdPclNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsQ29uZmlnT3JTb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnW2tleV0gPSB1cmxDb25maWdPclNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25maWcuV2ViU29ja2V0Q3RvciAmJiBXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuV2ViU29ja2V0Q3RvciA9IFdlYlNvY2tldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjb25maWcuV2ViU29ja2V0Q3Rvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gV2ViU29ja2V0IGNvbnN0cnVjdG9yIGNhbiBiZSBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc29jayA9IG5ldyBXZWJTb2NrZXRTdWJqZWN0KHRoaXMuX2NvbmZpZywgdGhpcy5kZXN0aW5hdGlvbik7XG4gICAgICAgIHNvY2sub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgc29jay5zb3VyY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc29jaztcbiAgICB9O1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLl9yZXNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFJlcGxheVN1YmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdXRwdXQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH07XG4gICAgV2ViU29ja2V0U3ViamVjdC5wcm90b3R5cGUubXVsdGlwbGV4ID0gZnVuY3Rpb24gKHN1Yk1zZywgdW5zdWJNc2csIG1lc3NhZ2VGaWx0ZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNlbGYubmV4dChzdWJNc2coKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzZWxmLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlRmlsdGVyKHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZXJyKTsgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIuY29tcGxldGUoKTsgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm5leHQodW5zdWJNc2coKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLl9jb25uZWN0U29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9jb25maWcsIFdlYlNvY2tldEN0b3IgPSBfYS5XZWJTb2NrZXRDdG9yLCBwcm90b2NvbCA9IF9hLnByb3RvY29sLCB1cmwgPSBfYS51cmwsIGJpbmFyeVR5cGUgPSBfYS5iaW5hcnlUeXBlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0aGlzLl9vdXRwdXQ7XG4gICAgICAgIHZhciBzb2NrZXQgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc29ja2V0ID0gcHJvdG9jb2wgPyBuZXcgV2ViU29ja2V0Q3Rvcih1cmwsIHByb3RvY29sKSA6IG5ldyBXZWJTb2NrZXRDdG9yKHVybCk7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgICBpZiAoYmluYXJ5VHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvY2tldC5iaW5hcnlUeXBlID0gYmluYXJ5VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3NvY2tldCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgdmFyIF9zb2NrZXQgPSBfdGhpcy5fc29ja2V0O1xuICAgICAgICAgICAgaWYgKCFfc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3Blbk9ic2VydmVyID0gX3RoaXMuX2NvbmZpZy5vcGVuT2JzZXJ2ZXI7XG4gICAgICAgICAgICBpZiAob3Blbk9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgb3Blbk9ic2VydmVyLm5leHQoZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IF90aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBTdWJzY3JpYmVyLmNyZWF0ZShmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBfdGhpcy5fY29uZmlnLnNlcmlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChzZXJpYWxpemVyKHgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24uZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NpbmdPYnNlcnZlciA9IF90aGlzLl9jb25maWcuY2xvc2luZ09ic2VydmVyO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zaW5nT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2luZ09ic2VydmVyLm5leHQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoZXJyLmNvZGUsIGVyci5yZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmV3IFR5cGVFcnJvcihXRUJTT0NLRVRTVUJKRUNUX0lOVkFMSURfRVJST1JfT0JKRUNUKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NpbmdPYnNlcnZlciA9IF90aGlzLl9jb25maWcuY2xvc2luZ09ic2VydmVyO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zaW5nT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2luZ09ic2VydmVyLm5leHQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHF1ZXVlICYmIHF1ZXVlIGluc3RhbmNlb2YgUmVwbGF5U3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQocXVldWUuc3Vic2NyaWJlKF90aGlzLmRlc3RpbmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHNvY2tldCA9PT0gX3RoaXMuX3NvY2tldCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xvc2VPYnNlcnZlciA9IF90aGlzLl9jb25maWcuY2xvc2VPYnNlcnZlcjtcbiAgICAgICAgICAgIGlmIChjbG9zZU9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VPYnNlcnZlci5uZXh0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUud2FzQ2xlYW4pIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzZXJpYWxpemVyID0gX3RoaXMuX2NvbmZpZy5kZXNlcmlhbGl6ZXI7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChkZXNlcmlhbGl6ZXIoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdFNvY2tldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX291dHB1dC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfc29ja2V0ID0gX3RoaXMuX3NvY2tldDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fb3V0cHV0Lm9ic2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoX3NvY2tldCAmJiAoX3NvY2tldC5yZWFkeVN0YXRlID09PSAxIHx8IF9zb2NrZXQucmVhZHlTdGF0ZSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9zb2NrZXQgPSB0aGlzLl9zb2NrZXQ7XG4gICAgICAgIGlmIChfc29ja2V0ICYmIChfc29ja2V0LnJlYWR5U3RhdGUgPT09IDEgfHwgX3NvY2tldC5yZWFkeVN0YXRlID09PSAwKSkge1xuICAgICAgICAgICAgX3NvY2tldC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFdlYlNvY2tldFN1YmplY3Q7XG59KEFub255bW91c1N1YmplY3QpKTtcbmV4cG9ydCB7IFdlYlNvY2tldFN1YmplY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYlNvY2tldFN1YmplY3QuanMubWFwIiwiaW1wb3J0IHsgV2ViU29ja2V0U3ViamVjdCB9IGZyb20gJy4vV2ViU29ja2V0U3ViamVjdCc7XG5leHBvcnQgZnVuY3Rpb24gd2ViU29ja2V0KHVybENvbmZpZ09yU291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBXZWJTb2NrZXRTdWJqZWN0KHVybENvbmZpZ09yU291cmNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYlNvY2tldC5qcy5tYXAiLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICB2YXIgdjtcbiAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcblxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTsiLCIvLyBBZGFwdGVkIGZyb20gQ2hyaXMgVmVuZXNzJyBTSEExIGNvZGUgYXRcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvc2hhMS5odG1sXG5mdW5jdGlvbiBmKHMsIHgsIHksIHopIHtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHggJiB5IF4gfnggJiB6O1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB4ICYgeSBeIHggJiB6IF4geSAmIHo7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuICB9XG59XG5cbmZ1bmN0aW9uIFJPVEwoeCwgbikge1xuICByZXR1cm4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xufVxuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIHZhciBLID0gWzB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4Y2E2MmMxZDZdO1xuICB2YXIgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMucHVzaChtc2cuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIC8vIENvbnZlcnQgQXJyYXktbGlrZSB0byBBcnJheVxuICAgIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMpO1xuICB9XG5cbiAgYnl0ZXMucHVzaCgweDgwKTtcbiAgdmFyIGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcbiAgdmFyIE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgdmFyIE0gPSBuZXcgQXJyYXkoTik7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE47ICsrX2kpIHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgYXJyW2pdID0gYnl0ZXNbX2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDFdIDw8IDE2IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMl0gPDwgOCB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cblxuICAgIE1bX2ldID0gYXJyO1xuICB9XG5cbiAgTVtOIC0gMV1bMTRdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAvIE1hdGgucG93KDIsIDMyKTtcbiAgTVtOIC0gMV1bMTRdID0gTWF0aC5mbG9vcihNW04gLSAxXVsxNF0pO1xuICBNW04gLSAxXVsxNV0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4ICYgMHhmZmZmZmZmZjtcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBOOyArK19pMikge1xuICAgIHZhciBXID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcblxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMTY7ICsrdCkge1xuICAgICAgV1t0XSA9IE1bX2kyXVt0XTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfdCA9IDE2OyBfdCA8IDgwOyArK190KSB7XG4gICAgICBXW190XSA9IFJPVEwoV1tfdCAtIDNdIF4gV1tfdCAtIDhdIF4gV1tfdCAtIDE0XSBeIFdbX3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIHZhciBhID0gSFswXTtcbiAgICB2YXIgYiA9IEhbMV07XG4gICAgdmFyIGMgPSBIWzJdO1xuICAgIHZhciBkID0gSFszXTtcbiAgICB2YXIgZSA9IEhbNF07XG5cbiAgICBmb3IgKHZhciBfdDIgPSAwOyBfdDIgPCA4MDsgKytfdDIpIHtcbiAgICAgIHZhciBzID0gTWF0aC5mbG9vcihfdDIgLyAyMCk7XG4gICAgICB2YXIgVCA9IFJPVEwoYSwgNSkgKyBmKHMsIGIsIGMsIGQpICsgZSArIEtbc10gKyBXW190Ml0gPj4+IDA7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gVDtcbiAgICB9XG5cbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiID4+PiAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyA+Pj4gMDtcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XG4gICAgSFs0XSA9IEhbNF0gKyBlID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIFtIWzBdID4+IDI0ICYgMHhmZiwgSFswXSA+PiAxNiAmIDB4ZmYsIEhbMF0gPj4gOCAmIDB4ZmYsIEhbMF0gJiAweGZmLCBIWzFdID4+IDI0ICYgMHhmZiwgSFsxXSA+PiAxNiAmIDB4ZmYsIEhbMV0gPj4gOCAmIDB4ZmYsIEhbMV0gJiAweGZmLCBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLCBIWzNdID4+IDI0ICYgMHhmZiwgSFszXSA+PiAxNiAmIDB4ZmYsIEhbM10gPj4gOCAmIDB4ZmYsIEhbM10gJiAweGZmLCBIWzRdID4+IDI0ICYgMHhmZiwgSFs0XSA+PiAxNiAmIDB4ZmYsIEhbNF0gPj4gOCAmIDB4ZmYsIEhbNF0gJiAweGZmXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiLCJpbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCB2YXIgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgdmFyIFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59IiwiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgc2hhMSBmcm9tICcuL3NoYTEuanMnO1xudmFyIHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7IiwiaW1wb3J0IHsgTFJQYXJzZXIgfSBmcm9tICdAbGV6ZXIvbHInO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IEpzb24kMSA9IDEsXG4gIExvZ2ZtdCQxID0gMixcbiAgVW5wYWNrJDEgPSAzLFxuICBQYXR0ZXJuJDEgPSA0LFxuICBSZWdleHAkMSA9IDUsXG4gIFVud3JhcCQxID0gNixcbiAgSXAkMSA9IDcsXG4gIExhYmVsRm9ybWF0JDEgPSA4LFxuICBMaW5lRm9ybWF0JDEgPSA5LFxuICBMYWJlbFJlcGxhY2UkMSA9IDEwLFxuICBPZmZzZXQkMSA9IDExLFxuICBCb29sJDEgPSAxMixcbiAgT24kMSA9IDEzLFxuICBJZ25vcmluZyQxID0gMTQsXG4gIEdyb3VwTGVmdCQxID0gMTUsXG4gIEdyb3VwUmlnaHQkMSA9IDE2LFxuICBCeXRlc0NvbnYkMSA9IDE3LFxuICBEdXJhdGlvbkNvbnYkMSA9IDE4LFxuICBEdXJhdGlvblNlY29uZHNDb252JDEgPSAxOSxcbiAgQnkkMSA9IDIwLFxuICBXaXRob3V0JDEgPSAyMSxcbiAgQW5kJDEgPSAyMixcbiAgT3IkMSA9IDIzLFxuICBVbmxlc3MkMSA9IDI0LFxuICBTdW0kMSA9IDI1LFxuICBBdmckMSA9IDI2LFxuICBDb3VudCQxID0gMjcsXG4gIE1heCQxID0gMjgsXG4gIE1pbiQxID0gMjksXG4gIFN0ZGRldiQxID0gMzAsXG4gIFN0ZHZhciQxID0gMzEsXG4gIEJvdHRvbWskMSA9IDMyLFxuICBUb3BrJDEgPSAzMztcblxuY29uc3Qga2V5d29yZFRva2VucyA9IHtcbiAgICBqc29uOiBKc29uJDEsXG4gICAgbG9nZm10IDogTG9nZm10JDEsXG4gICAgdW5wYWNrOiBVbnBhY2skMSxcbiAgICBwYXR0ZXJuIDogUGF0dGVybiQxLFxuICAgIHJlZ2V4cCA6IFJlZ2V4cCQxLFxuICAgIGlwIDogSXAkMSxcbiAgICBsYWJlbF9mb3JtYXQgOiBMYWJlbEZvcm1hdCQxLFxuICAgIGxpbmVfZm9ybWF0IDogTGluZUZvcm1hdCQxLFxuICAgIGxhYmVsX3JlcGxhY2U6IExhYmVsUmVwbGFjZSQxLFxuICAgIG9mZnNldDogT2Zmc2V0JDEsXG4gICAgYm9vbDogQm9vbCQxLFxuICAgIG9uOiBPbiQxLFxuICAgIGlnbm9yaW5nOiBJZ25vcmluZyQxLFxuICAgIGdyb3VwX2xlZnQ6IEdyb3VwTGVmdCQxLFxuICAgIGdyb3VwX3JpZ2h0OiBHcm91cFJpZ2h0JDEsXG4gICAgdW53cmFwOiBVbndyYXAkMSxcbiAgICBieXRlczogQnl0ZXNDb252JDEsXG4gICAgZHVyYXRpb246IER1cmF0aW9uQ29udiQxLFxuICAgIGR1cmF0aW9uX3NlY29uZHM6IER1cmF0aW9uU2Vjb25kc0NvbnYkMVxufTtcblxuY29uc3Qgc3BlY2lhbGl6ZUlkZW50aWZpZXIgPSAodmFsdWUsIHN0YWNrKSA9PiB7XG4gICAgcmV0dXJuIGtleXdvcmRUb2tlbnNbdmFsdWUudG9Mb3dlckNhc2UoKV0gfHwgLTE7XG59O1xuXG5cbmNvbnN0IGNvbnRleHR1YWxLZXl3b3JkVG9rZW5zID0ge1xuICAgIGJ5OiBCeSQxLFxuICAgIHdpdGhvdXQ6IFdpdGhvdXQkMSxcbiAgICBhbmQ6IEFuZCQxLFxuICAgIG9yOiBPciQxLFxuICAgIHVubGVzczogVW5sZXNzJDEsXG4gICAgc3VtOiBTdW0kMSxcbiAgICBhdmc6IEF2ZyQxLFxuICAgIGNvdW50OiBDb3VudCQxLFxuICAgIG1heDogTWF4JDEsXG4gICAgbWluOiBNaW4kMSxcbiAgICBzdGRkZXY6IFN0ZGRldiQxLFxuICAgIHN0ZHZhcjogU3RkdmFyJDEsXG4gICAgYm90dG9tazogQm90dG9tayQxLFxuICAgIHRvcGs6IFRvcGskMVxufTtcblxuY29uc3QgZXh0ZW5kSWRlbnRpZmllciA9ICh2YWx1ZSwgc3RhY2spID0+IHtcbiAgICByZXR1cm4gY29udGV4dHVhbEtleXdvcmRUb2tlbnNbdmFsdWUudG9Mb3dlckNhc2UoKV0gfHwgLTE7XG59O1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHNwZWNfSWRlbnRpZmllciA9IHtfX3Byb3RvX186bnVsbCxjb3VudF9vdmVyX3RpbWU6MjU1LCByYXRlOjI1NywgYnl0ZXNfb3Zlcl90aW1lOjI1OSwgYnl0ZXNfcmF0ZToyNjEsIGF2Z19vdmVyX3RpbWU6MjYzLCBzdW1fb3Zlcl90aW1lOjI2NSwgbWluX292ZXJfdGltZToyNjcsIG1heF9vdmVyX3RpbWU6MjY5LCBzdGRkZXZfb3Zlcl90aW1lOjI3MSwgc3RkdmFyX292ZXJfdGltZToyNzMsIHF1YW50aWxlX292ZXJfdGltZToyNzUsIGZpcnN0X292ZXJfdGltZToyNzcsIGxhc3Rfb3Zlcl90aW1lOjI3OSwgYWJzZW50X292ZXJfdGltZToyODF9O1xuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxMyxcbiAgc3RhdGVzOiBcIkBqT1lRUE9PTyNWUVBPJyNEU08kZlFQTycjRFJPWVFQTycjRFJPT1FPJyNFTycjRU9PJHNRUE8nI0R9T09RTycjRWcnI0VnTyR4UVBPJyNFZlElVFFQT09PT1FPJyNFdScjRXVPJlVRUE8nI0V1TyZaUVBPJyNFdk9PUU8nI0R8JyNEfE9PUU8nI0RRJyNEUU9PUU8nI0VQJyNFUE9PUU8nI0VRJyNFUU9PUU8nI0VSJyNFUk9PUU8nI0VTJyNFU09PUU8nI0VUJyNFVE9PUU8nI0VVJyNFVU9PUU8nI0VWJyNFVk9PUU8nI0VXJyNFV09PUU8nI0VYJyNFWE9PUU8nI0VZJyNFWU9PUU8nI0VaJyNFWk9PUU8nI0VbJyNFW09PUU8nI0VdJyNFXU9PUU8nI0VeJyNFXk8mYFFQTycjRFVPT1FPJyNEVCcjRFRPJm5RUE8sNTluT09RTycjRGEnI0RhTyZ2UVBPJyNEYE8nT1FQTycjRF9PT1FPJyNEXicjRF5PKGxRUE8nI0ReT09RTycjRF0nI0RdTypoUVBPLDU5bU8rdlFQTyw1OW1PK31RUE8sNTpoTyxVUVBPLDU6aU8sYVFQTycjRWRPLmBRUE8sNTtRTy5nUVBPLDU7UU8ubFFQTyw1O1NPLmxRUE8sNTtTTy5sUVBPLDU7U08ubFFQTyw1O1NPLmxRUE8sNTtTTy5sUVBPLDU7U09PUU8sNTthLDU7YU9ZUVBPLDU7Yk8wclFQTyw1OXBPMHdRUE8xRy9ZT09RTzFHL1kxRy9ZT09RTycjRGQnI0RkT09RTyw1OXosNTl6TzFQUVBPLDU5ek9PUU8sNTl5LDU5eU8xVVFQTycjRFVPMXNRUE8nI0RmT09RTycjRGYnI0RmTzNkUVBPJyNEZk8zaVFQTycjRG1PT1FPJyNEbCcjRGxPT1FPJyNEaicjRGpPKVJRUE8nI0RqTzRRUVBPLDU5eE81blFQTycjRHhPNXNRUE8nI0R5T09RTyw1OXgsNTl4T09RTyw1OXcsNTl3T09RTzFHL1gxRy9YT09RTzFHMFMxRzBTTzV4UVBPJyNFX08sWFFQTycjRV9PNmFRUE8xRzBUTzZmUVBPMUcwVE82a1FQTyw1O09PNnNRUE8xRzBsTzhPUVBPMUcwbE84VlFQTzFHMGxPOF5RUE8nI0VqTzpgUVBPJyNFaU86alFQTycjRWlPWVFQTzFHMG5PWVFQTzFHMG5PWVFQTzFHMG5PWVFQTzFHMG5PWVFQTzFHMG5PWVFQTzFHMG5POnRRUE8xRzB8T09RTzFHL1sxRy9bT09RTzFHL1oxRy9aT09RTzcrJHQ3KyR0Tzp7UVBPMUcvZk87UVFQTyw1OXBPO1dRUE8sNTpgTztgUVBPJyNEaU87ZVFQTycjRGhPT1FPLDU6Uiw1OlJPT1FPLDU6USw1OlFPPVJRUE8sNTpYTz1XUVBPLDU6VU8pUlFQTyw1OlVPKVJRUE8sNTpVT09RTyw1OmQsNTpkTz1mUVBPJyNEe09PUU8nI0R6JyNEek89a1FQTyw1OmVPP1hRUE8nI0ReTzV4UVBPLDU6eU8/YFFQTycjRWBPP2VRUE8nI0ViT0BPUVBPLDU6eU82W1FQTyw1OnlPQFlRUE8sNTp5T0BhUVBPLDU6eU9AZlFQTzcrJW9PLFhRUE83KyVvT09RTycjRWUnI0VlT0F2UVBPMUcwak9PUU8xRzBqMUcwak9CT1FQTzcrJldPWVFQTzcrJldPQ2BRUE83KyZXT0NnUVBPNysmV09DblFRTycjRWtPT1FPLDU7VSw1O1VPRXBRUE8sNTtUT0V3UVBPLDU7VE9HWVFQTzcrJllPR2FRUE83KyZZT09RTzcrJlk3KyZZT0duUVBPNysmWU9HdVFQTzcrJllPSHpRUE83KyZZT0lbUVBPNysmaE9JYVFQTzcrJVFPSWZRUE8xRy9xT09RTzFHL3oxRy96T09RTzFHL3wxRy98T0lrUVBPLDU6VE9JcFFQTyw1OlNPT1FPMUcvczFHL3NPT1FPMUcvcDFHL3BPSXVRUE8xRy9wT0tjUVBPLDU6Z081c1FQTyw1OmZPS2tRUE8sNTp8T0t5UVBPMUcwZU82W1FQTzFHMGVPTFJRUE8sNTp6TylSUVBPLDU6fE9MV1FQTzFHMGVPTF9RUE8nI0VhT0xXUVBPMUcwZU9PUU8xRzBlMUcwZU9MZFFQTzFHMGVPNltRUE8xRzBlT0xrUVBPMUcwZU9PUU88PElaPDxJWk9Mc1FQTzw8SVpPTHhRUE8sNTtQT09RTzcrJlU3KyZVT09RTzw8SXI8PElyT0x9UVBPPDxJck9ZUVBPPDxJck9PUU8nI0VtJyNFbU9NVVFQTyw1O1ZPT1FPJyNFbCcjRWxPT1FPLDU7Viw1O1ZPT1FPMUcwbzFHMG9PTV5RUE8xRzBvTyEgWlFQTzw8SlNPT1FPPDxIbDw8SGxPISBgUVBPNyslXU9PUU8xRy9vMUcvb09PUU8xRy9uMUcvbk9PUU8xRzBSMUcwUk9PUU8xRzBRMUcwUU9PUU8nI0VjJyNFY09PUU8xRzBoMUcwaE8hIGVRUE8xRzBoT09RTzcrJlA3KyZQT09RTzFHMGYxRzBmTyEgalFQTzFHMGhPT1FPLDU6eyw1OntPISB7UVBPNysmUE82W1FQTzcrJlBPISFTUVBPNysmUE8hIWJRUE9BTj51T09RTzFHMGsxRzBrTyEjclFQT0FOP15PISVTUVBPQU4/Xk8hJVpRUU8xRzBxT09RTzFHMHExRzBxT09RTzcrJlo3KyZaTyElY1FQT0FOP25PISVoUVBPPDxId08hJW1RUE83KyZTT09RTzw8SWs8PElrTyElclFQTzw8SWtPISV6UVBPPDxJa08hJlZRUE8nI0ViT09RT0cyNGFHMjRhT09RT0cyNHhHMjR4T09RTzFHMHIxRzByT09RTzcrJl03KyZdTyEmW1FQT0cyNVlPT1FPQU4+Y0FOPmNPISZhUVBPPDxJbk9PUU9BTj9WQU4/Vk8hJmZRUE9MRCp0T09RT0FOP1lBTj9ZT09RTyw1OmUsNTplTyEma1FQTyEkJ05gTyEmcFFQTyEpOUN6TyEmdVFQTyEuSzlmT09RTyE0Ly9RITQvL1FPNXNRUE8nI0R5TyEmelFQTycjRF5PISdsUVBPLDU5bU8hJ3ZRUE8nI0RST1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuT1lRUE8xRzBuTy5sUVBPLDU7U08ubFFQTyw1O1NPLmxRUE8sNTtTTy5sUVBPLDU7U08ubFFQTyw1O1NPLmxRUE8sNTtTTyEpUlFQTzcrJllPISlZUVBPNysmWU8hKWdRUE83KyZZTyEqb1FQTzcrJllPISp2UVBPNysmWU8hKW5RUE8nI0VoXCIsXG4gIHN0YXRlRGF0YTogXCIhK1R+TyNtT1NyT1N+T1laT2lVT2pVT2tVT2xVT21VT25VT29VT3BVT3FVTyFrWE8jY1lPI2RZTyNuUE8jcVJPI3NeTyN0X08jdWBPI3ZhTyN3Yk8jeGNPI3lkTyN6ZU8je2ZPI3xnTyN9aE8kT2lPJFBqTyRRa09+T3lsT35PfG9PIU9vTyFVb08hVm9PZnVYZ3VYaHVYIWJ1WCFkdVghZXVYIWZ1WCFndVgjY3VYI2R1WCNldVgjZnVYI2d1WCNodVh+TyFYc08ja3VYI3J1WH5QI1tPI3F4T35PZHlPZXlPI3F6T35PZn1PZ3xPaH1PfCFSTyFiIVJPIWQhUk8hZSFSTyFmIVJPIWchUk8jYyFPTyNkIU9PI2UhUE8jZiFQTyNnIVBPI2ghUU9+TyFrIVNPfk8jcSFUT35PeiFVT3whVU99IVVPIU8hVU9+TyNvIVZPI3AhV09+T1YhWE97IVlPfk98b08hT29PIVVvTyFWb09mIVJYZyFSWGghUlghWCFSWCFiIVJYIWQhUlghZSFSWCFmIVJYIWchUlgjYyFSWCNkIVJYI2UhUlgjZiFSWCNnIVJYI2ghUlgjayFSWCNyIVJYVSFSWCRSIVJYI28hUlh+T1AhXk9RIV9PUiFfT1MhYE9UIWBPVyFnT1ghZk9iIWFPeSFdTyNxIWRPfk98b08hT29PIVVvTyFWb09mdWFndWFodWEhYnVhIWR1YSFldWEhZnVhIWd1YSNjdWEjZHVhI2V1YSNmdWEjZ3VhI2h1YX5PIVhzTyNrdWEjcnVhflApXk9mdFhndFhodFh8dFghYnRYIWR0WCFldFghZnRYIWd0WCNjdFgjZHRYI2V0WCNmdFgjZ3RYI2h0WH5PI3Ihak9+UCp1TyNyIWtPflAqdU8hayFvTyNuUE8jcSFtT35PI3EhcE9+T1laT2lVT2pVT2tVT2xVT21VT25VT29VT3BVT3FVTyNjWU8jZFlPI25QTyNxUk8jc15PI3RfTyN1YE8jdmFPI3diTyN4Y08jeWRPI3plTyN7Zk8jfGdPI31oTyRPaU8kUGpPJFFrT35PIWshck9+UCxmTyNxIXNPfk9bIXZPXSF0T14hdE9ZI11QaSNdUGojXVBrI11QbCNdUG0jXVBuI11QbyNdUHAjXVBxI11QIWsjXVAjYyNdUCNkI11QI24jXVAjcSNdUCNzI11QI3QjXVAjdSNdUCN2I11QI3cjXVAjeCNdUCN5I11QI3ojXVAjeyNdUCN8I11QI30jXVAkTyNdUCRQI11QJFEjXVB+T3sjT09+T3lsTyNwI1FPfk8jcSNST35PeiNTT3wjU099IVVPIU8hVU8hYiNUTyFkI1RPIWUjVE8hZiNUTyFnI1RPfk95I1VPZiFZWGchWVhoIVlYfCFZWCFPIVlYIVUhWVghViFZWCFYIVlYIWIhWVghZCFZWCFlIVlYIWYhWVghZyFZWCNjIVlYI2QhWVgjZSFZWCNmIVlYI2chWVgjaCFZWCNrIVlYI3IhWVhVIVlYJFIhWVgjbyFZWH5PeyNYT35PeiNZT3wjWU8hYiNZTyFkI1lPIWUjWU8hZiNZTyFnI1lPfk9mI1tPZyNdTyNvI1tPaCFRYXwhUWEhTyFRYSFVIVFhIVYhUWEhWCFRYSFiIVFhIWQhUWEhZSFRYSFmIVFhIWchUWEjYyFRYSNkIVFhI2UhUWEjZiFRYSNnIVFhI2ghUWEjayFRYSNyIVFhVSFRYSRSIVFhfk97I15Pfk95I19Pfk9VI2VPfG9PIU9vTyFVb08hVm9PIVgjYk8kUiNkT35PI3Ijak9+TyNvI2tPfk95I2xPI3Ijbk9+TyNyI29PflAqdU9mI2lYZyNpWGgjaVh8I2lYIWIjaVghZCNpWCFlI2lYIWYjaVghZyNpWCNjI2lYI2QjaVgjZSNpWCNmI2lYI2cjaVgjaCNpWCNyI2lYfk8jbyNwT35QNnpPIWsjck9+UCxmTyNxI3NPfk9ZI11YaSNdWGojXVhrI11YbCNdWG0jXVhuI11YbyNdWHAjXVhxI11YIWsjXVgjYyNdWCNkI11YI24jXVgjcSNdWCNzI11YI3QjXVgjdSNdWCN2I11YI3cjXVgjeCNdWCN5I11YI3ojXVgjeyNdWCN8I11YI30jXVgkTyNdWCRQI11YJFEjXVh+T18jdU9gI3VPflA4Y09dIXRPXiF0T35QOGNPI28jfU9+UCp1T3skT09+T1YkUE97I09PIWkkUU8hayRST35PeiRTT35PI28kVE9mIVtYZyFbWGghW1h8IVtYIU8hW1ghVSFbWCFWIVtYIVghW1ghYiFbWCFkIVtYIWUhW1ghZiFbWCFnIVtYI2MhW1gjZCFbWCNlIVtYI2YhW1gjZyFbWCNoIVtYI2shW1gjciFbWFUhW1gkUiFbWH5PIWMkVU9+T2YjW09nI11PI28jW08jciRWT35PeiRYT35PI28kWU9mIW1hZyFtYWghbWF8IW1hIU8hbWEhVSFtYSFWIW1hIVghbWEhYiFtYSFkIW1hIWUhbWEhZiFtYSFnIW1hI2MhbWEjZCFtYSNlIW1hI2YhbWEjZyFtYSNoIW1hI2shbWEjciFtYVUhbWEkUiFtYX5PVSRaT35QKGxPIWMkXk9+TyFYJF9Pfk9VI2VPfG9PIU9vTyFVb08hVm9PIVgjYk9+T1okYU8jciNSYX5QP2pPI3IkZU9+UDV4TyNyJGNPfk9keU9leU9mIXFxZyFxcWghcXF8IXFxIWIhcXEhZCFxcSFlIXFxIWYhcXEhZyFxcSNjIXFxI2QhcXEjZSFxcSNmIXFxI2chcXEjaCFxcSNrIXFxI3IhcXEjbyFxcX5PI28kaU8jciRqT35PZHlPZXlPZiNZcWcjWXFoI1lxfCNZcSFiI1lxIWQjWXEhZSNZcSFmI1lxIWcjWXEjYyNZcSNkI1lxI2UjWXEjZiNZcSNnI1lxI2gjWXEjayNZcSNyI1lxI28jWXF+TyNyJGtPflAqdU8jbyRtT35QNnpPI2Ikbk8jciRxT35PWSNdYWkjXWFqI11hayNdYWwjXWFtI11hbiNdYW8jXWFwI11hcSNdYSFrI11hI2MjXWEjZCNdYSNuI11hI3MjXWEjdCNdYSN1I11hI3YjXWEjdyNdYSN4I11hI3kjXWEjeiNdYSN7I11hI3wjXWEjfSNdYSRPI11hJFAjXWEkUSNdYX5PI3Ejc09+UEN2T18kc09gJHNPI3EjXWF+UEN2T2Z9T2h9T3whUk8hYiFSTyFkIVJPIWUhUk8hZiFSTyFnIVJPI2MhT08jZCFPTyNlI1txI2YjW3EjZyNbcSNoI1txI2sjW3EjciNbcX5PZyNbcX5QRlVPZiNbcWcjW3FoI1txflBGW09nfE9+UEZVTyNrI1txI3IjW3F+UCVUT2YjW3FnI1txaCNbcXwjW3EhYiNbcSFkI1txIWUjW3EhZiNbcSFnI1txI2UjW3EjZiNbcSNnI1txI2gjW3F+TyNjIU9PI2QhT08jayNbcSNyI1txflBIUE97JHRPfk8jciR1T35PI3Ekdk9+T3skd09+T3kjVU9+T2YjW08jbyNbT2chXmloIV5pfCFeaSFPIV5pIVUhXmkhViFeaSFYIV5pIWIhXmkhZCFeaSFlIV5pIWYhXmkhZyFeaSNjIV5pI2QhXmkjZSFeaSNmIV5pI2chXmkjaCFeaSNrIV5pI3IhXmlVIV5pJFIhXml+T3kkeU97JHlPfk9hJHtPYiR7T2Mke095JHxPfk9aJGFPI3IjUml+TyRTJVBPfk8jciNSaX5QP2pPIWMlUk9+TyNyJVRPflA1eE8jciVUTyRSI2RPfk8jciVWT35PeSVXT35PI3IlWE9+UCp1TyNvJVpPI3IlW09+TyNxI3NPWSNdaWkjXWlqI11payNdaWwjXWltI11pbiNdaW8jXWlwI11pcSNdaSFrI11pI2MjXWkjZCNdaSNuI11pI3MjXWkjdCNdaSN1I11pI3YjXWkjdyNdaSN4I11pI3kjXWkjeiNdaSN7I11pI3wjXWkjfSNdaSRPI11pJFAjXWkkUSNdaX5PI28lXk9+T3slX09+TyNxJWBPfk9mI1tPZyNdTyNvI1tPJFIjVWkjciNVaX5PI3IjUnF+UD9qT1UjZU9aJWNPIVglZE8jciNScX5PZHlPZXlPZiFxIVJnIXEhUmghcSFSfCFxIVIhYiFxIVIhZCFxIVIhZSFxIVIhZiFxIVIhZyFxIVIjYyFxIVIjZCFxIVIjZSFxIVIjZiFxIVIjZyFxIVIjaCFxIVIjayFxIVIjciFxIVIjbyFxIVJ+T2R5T2V5T2YjWSFSZyNZIVJoI1khUnwjWSFSIWIjWSFSIWQjWSFSIWUjWSFSIWYjWSFSIWcjWSFSI2MjWSFSI2QjWSFSI2UjWSFSI2YjWSFSI2cjWSFSI2gjWSFSI2sjWSFSI3IjWSFSI28jWSFSfk8jciVmT35QKnVPI2Ikbk8jciVoT35PeyVpT35PI3Ilak9+T3kla09+T1okYU8jciNSeX5PVSNlTyFYJWRPIWMlUk9+T1UkWk9+TyNvJW1Pfk8jciVuT35PeyVwT35PI28lcU9+T3slck9+TyNyJXNPfk9QIV5PUSFfT1IhX09TIWBPVCFgT1cldE9YIWZPYiFhT3khXU8jcSFkT35PIVgldU8jb3VhflApXk8hWCV1TyNvdVh+UCNbT2YmUE9oJlBPfCZUTyFiJlRPIWQmVE8hZSZUTyFmJlRPIWcmVE8jYyZRTyNkJlFPI2UjW3EjZiNbcSNnI1txI2gjW3EjbyNbcX5PZyNbcX5QIShRT2YjW3FnI1txaCNbcX5QIShXT2cmT09+UCEoUU9mJlBPZyZPT2gmUE98JlRPIWImVE8hZCZUTyFlJlRPIWYmVE8hZyZUTyNjJlFPI2QmUU8jZSZSTyNmJlJPI2cmUk8jaCZTT35PI28jW3F+UCEpbk8jYyZRTyNkJlFPI28jW3F+UEhQT1wiLFxuICBnb3RvOiBcIi9ZI2tQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAjbCRrJVMlciV1UFBQUFBQJlUmaCZ4J1cnaVBQJ3hQJ3sneyhRKFQoWihsKGwodVBQUFBQUCh1UChsUCd7J3spTylVKV0qTyplKnoqeip6Knoqeip6Knoqeip6Knoqeip6KnoqeithK2orfSxaLHMsdi1WKk8tWSpPLW8uZS52L1AvU1BQUFBQUFAqTypPW1dPUnohcyNwJG1RI3chd1EjeCF4UyN5IXklelEjeiF6USN7IXtRI3whfFEmVSV4USZWJXlRJlcle1EmWCV8USZZJX1SJlohVHRdT3ohVCFzIXcheCF5IXoheyF8I3AkbSV4JXkleiV7JXwlfVJ2UmpRT1J6IVQhcyF3IXgheSF6IXshfCNwJG1TIWx4I2tRI2ghbV0ldyV4JXkleiV7JXwlfVJuUFFtUF4hY3MhZCNbI10jYiRfJXVSI1AhVlF1UVEjYyFsUSRgI2ZRJGQjaFElUyRiUiV2JXdbdFEhbCNmI2gkYiV3XSFpdSNjJGAkZCVTJXZpclF1IWwjYyNmI2gkYCRiJGQlUyV2JXdocVF1IWwjYyNmI2gkYCRiJGQlUyV2JXdSIVtxa3BRcXUhbCNjI2YjaCRgJGIkZCVTJXYld1IhWnBWIWhzI2IldVIjVyFeUSNWIV5SJHgkVFUhZXMjYiV1USNaIWRRJFYjW1EkVyNdUiVRJF9fIWNzIWQjWyNdI2IkXyV1XyFicyFkI1sjXSNiJF8ldVEjYSFnUiVvJXRTI2AhZyV0UiR6JFlqXU8hdyF4IXkheiF7IXwleCV5JXoleyV8JX1Rd1JRIXF6USF9IVRRI3Ehc1EkbCNwUiVZJG13W09SeiFUIXMhdyF4IXkheiF7IXwjcCRtJXgleSV6JXslfCV9d1RPUnohVCFzIXcheCF5IXoheyF8I3AkbSV4JXkleiV7JXwlfXdTT1J6IVQhcyF3IXgheSF6IXshfCNwJG0leCV5JXoleyV8JX1RIW54USNpIW1SJGgja1MjZiFsI2hXJFsjYyNnJGQkZlElTyRdUSVVJGVSJWIlVFEkYiNmUSVPJFtRJWElVVIlbCViUSNnIWxTJF0jYyRkUSRjI2ZRJGYjaFMlTyRgJGJTJWElUyVVUiVsJWNSJH0kWlF7VlEkZyNqUSRrI29RJWUlVlIlZiVYUiNtIXB3Vk9SeiFUIXMhdyF4IXkheiF7IXwjcCRtJXgleSV6JXslfCV9USF3fFEheH1RIXkhT1EheiFQUSF7IVFRIXwhUlEleCZPUSV5JlBRJXomUVEleyZSUSV8JlNSJX0mVGghdXx9IU8hUCFRIVImTyZQJlEmUiZTJlRSI3YhdlEjdCF0USRyI3VSJV0kc1IkbyNzUSRwI3NSJWclWlwiLFxuICBub2RlTmFtZXM6IFwi4pqgIEpzb24gTG9nZm10IFVucGFjayBQYXR0ZXJuIFJlZ2V4cCBVbndyYXAgSXAgTGFiZWxGb3JtYXQgTGluZUZvcm1hdCBMYWJlbFJlcGxhY2UgT2Zmc2V0IEJvb2wgT24gSWdub3JpbmcgR3JvdXBMZWZ0IEdyb3VwUmlnaHQgQnl0ZXNDb252IER1cmF0aW9uQ29udiBEdXJhdGlvblNlY29uZHNDb252IEJ5IFdpdGhvdXQgQW5kIE9yIFVubGVzcyBTdW0gQXZnIENvdW50IE1heCBNaW4gU3RkZGV2IFN0ZHZhciBCb3R0b21rIFRvcGsgTGluZUNvbW1lbnQgTG9nUUwgRXhwciBMb2dFeHByIFNlbGVjdG9yIE1hdGNoZXJzIE1hdGNoZXIgSWRlbnRpZmllciBFcSBTdHJpbmcgTmVxIFJlIE5yZSBQaXBlbGluZUV4cHIgUGlwZWxpbmVTdGFnZSBMaW5lRmlsdGVycyBMaW5lRmlsdGVyIEZpbHRlciBQaXBlRXhhY3QgUGlwZU1hdGNoIEZpbHRlck9wIFBpcGUgTGFiZWxQYXJzZXIgSnNvbkV4cHJlc3Npb25QYXJzZXIgSnNvbkV4cHJlc3Npb25MaXN0IEpzb25FeHByZXNzaW9uIExhYmVsRmlsdGVyIElwTGFiZWxGaWx0ZXIgVW5pdEZpbHRlciBEdXJhdGlvbkZpbHRlciBHdHIgRHVyYXRpb24gR3RlIExzcyBMdGUgRXFsIEJ5dGVzRmlsdGVyIEJ5dGVzIE51bWJlckZpbHRlciBOdW1iZXIgTGluZUZvcm1hdEV4cHIgTGFiZWxGb3JtYXRFeHByIExhYmVsc0Zvcm1hdCBMYWJlbEZvcm1hdE1hdGNoZXIgTWV0cmljRXhwciBSYW5nZUFnZ3JlZ2F0aW9uRXhwciBSYW5nZU9wIENvdW50T3ZlclRpbWUgUmF0ZSBCeXRlc092ZXJUaW1lIEJ5dGVzUmF0ZSBBdmdPdmVyVGltZSBTdW1PdmVyVGltZSBNaW5PdmVyVGltZSBNYXhPdmVyVGltZSBTdGRkZXZPdmVyVGltZSBTdGR2YXJPdmVyVGltZSBRdWFudGlsZU92ZXJUaW1lIEZpcnN0T3ZlclRpbWUgTGFzdE92ZXJUaW1lIEFic2VudE92ZXJUaW1lIExvZ1JhbmdlRXhwciBSYW5nZSBPZmZzZXRFeHByIFVud3JhcEV4cHIgQ29udk9wIEdyb3VwaW5nIExhYmVscyBWZWN0b3JBZ2dyZWdhdGlvbkV4cHIgVmVjdG9yT3AgQmluT3BFeHByIEJpbk9wTW9kaWZpZXIgT25Pcklnbm9yaW5nTW9kaWZpZXIgR3JvdXBpbmdMYWJlbHMgR3JvdXBpbmdMYWJlbExpc3QgR3JvdXBpbmdMYWJlbCBMYWJlbE5hbWUgQWRkIFN1YiBNdWwgRGl2IE1vZCBQb3cgTGl0ZXJhbEV4cHIgTGFiZWxSZXBsYWNlRXhwclwiLFxuICBtYXhUZXJtOiAxNDIsXG4gIHNraXBwZWROb2RlczogWzAsMzRdLFxuICByZXBlYXROb2RlQ291bnQ6IDAsXG4gIHRva2VuRGF0YTogXCIze35Sd1heI2xwcSNscXIkYXJzJHRzdCVodXYlc3d4JXh4eSZneXombHp7JnF7fCZ2fH0me30hTydRIU8hUCdWIVAhUShWIVEhUihbIVIhWylyIVshXTByIV4hXzFXIV8hYDFlIWAhYTF6IWMhfTJYIX0jTzJvI1AjUTJ0I1EjUjJ5I1IjUzJYI1MjVDNPI1QjbzJYI28jcDNbI3AjcTNhI3EjcjN2I3kjeiNsJGYkZyNsI0JZI0JaI2wkSVMkSV8jbCRJfCRKTyNsJEpUJEpVI2wkS1YkS1cjbCZGVSZGViNsfiNxWSNtflheI2xwcSNsI3kjeiNsJGYkZyNsI0JZI0JaI2wkSVMkSV8jbCRJfCRKTyNsJEpUJEpVI2wkS1YkS1cjbCZGVSZGViNsfiRkUSFfIWAkaiNyI3Mkb34kb098fn4kdE8hT35+JHlVe35PWSR0WnIkdHJzJV1zI08kdCNPI1AlYiNQfiR0fiViT3t+fiVlUE9+JHR+JW1Rcn5PWSVoWn4laH4leE8jZ35+JX1Ve35PWSV4WncleHd4JV14I08leCNPI1AmYSNQfiV4fiZkUE9+JXh+JmxPI3F+fiZxTyNyfn4mdk8jZX5+JntPI2N+fidRTyNvfn4nVk8jZH5+J1lQIVEhWyddfidiUiFrfiFRIVsnXSFnIWgnayNYI1kna34nblJ7fCd3fSFPJ3chUSFbJ31+J3pQIVEhWyd9fihTUCFrfiFRIVsnfX4oW08jZn5+KGFlIWt+IU8hUCddIVEhWylyIWchaCtWIWkhait0IW0hbit0IW8hcCt0IXIhcyt0IXYhdyt0I1UjVitpI1cjWCt9I1gjWS5QI1ojWy5jI1sjXSxmI18jYC5jI2EjYi5sI2QjZS5jI2cjaC1uI2gjaS5jI2sjbC59I2wjbTBXI20jbi9pfil3ZCFrfiFPIVAnXSFRIVspciFnIWgrViFpIWordCFtIW4rdCFvIXArdCFyIXMrdCF2IXcrdCNVI1YraSNXI1grfSNYI1kuUCNaI1suYyNbI10sZiNfI2AuYyNhI2IubCNkI2UuYyNnI2gtbiNoI2kuYyNrI2wufSNtI24vaX4rWVR7fCd3fSFPJ3chUSFbJ30hZCFlK2kjXSNeK25+K25PIWl+fitxUCNVI1YraX4rd1EhZCFlK2kjXSNeK25+LFNQIWN+IVEhWyxWfixZUyFRIVssViNbI10sZiNhI2IseiNnI2gtbn4sa1AhY34hUSFbLG5+LHFSIVEhWyxuI2EjYix6I2cjaC1ufi1QUSFjfiFRIVstViNnI2gtaX4tWVIhUSFbLVYjYSNiLWMjZyNoLW5+LWZQI2cjaC1pfi1uTyFjfn4tc1AhY34hUSFbLXZ+LXlRIVEhWy12I2EjYi1jfi5TVHt8J3d9IU8ndyFRIVsnfSNVI1YraSNdI14rbn4uZlEjVSNWK2kjXSNeK25+LnFTIWN+IVEhWy1WI1UjVitpI10jXituI2cjaC1pfi9TUCFjfiFRIVsvVn4vWVQhUSFbL1YjVyNYK30jWyNdLGYjYSNiLHojZyNoLW5+L25QIWN+IVEhWy9xfi90VSFRIVsvcSNXI1grfSNbI10sZiNhI2IseiNnI2gtbiNrI2wufX4wWlIhUSFbMGQhYyFpMGQjVCNaMGR+MGlSIWt+IVEhWzBkIWMhaTBkI1QjWjBkUDB3VHlQIVEhWzByIVshXTByIWMhfTByI1IjUzByI1QjbzByfjFdUCFlfiFfIWAxYH4xZU8hZn5+MWpRen4hXyFgMXAjciNzMXV+MXVPIWd+fjF6T31+fjJQUCFifiFfIWAyU34yWE8hZH5SMmBUeVAjYlEhUSFbMlghWyFdMHIhYyF9MlgjUiNTMlgjVCNvMlh+MnRPJFJ+fjJ5TyRTfn4zT08jaH5+M1JSTyNTM08jUyNUJV0jVH4zT34zYU8jbn5+M2ZRIVh+IV8hYDNsI3IjczNxfjNxTyFVfn4zdk8hVn5+M3tPI3B+XCIsXG4gIHRva2VuaXplcnM6IFswLCAxXSxcbiAgdG9wUnVsZXM6IHtcIkxvZ1FMXCI6WzAsMzVdfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7dGVybTogNDEsIGdldDogKHZhbHVlLCBzdGFjaykgPT4gKHNwZWNpYWxpemVJZGVudGlmaWVyKHZhbHVlKSA8PCAxKX0se3Rlcm06IDQxLCBnZXQ6ICh2YWx1ZSwgc3RhY2spID0+IChleHRlbmRJZGVudGlmaWVyKHZhbHVlKSA8PCAxKSB8IDF9LHt0ZXJtOiA0MSwgZ2V0OiB2YWx1ZSA9PiBzcGVjX0lkZW50aWZpZXJbdmFsdWVdIHx8IC0xfV0sXG4gIHRva2VuUHJlYzogMFxufSk7XG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IEpzb24gPSAxLFxuICBMb2dmbXQgPSAyLFxuICBVbnBhY2sgPSAzLFxuICBQYXR0ZXJuID0gNCxcbiAgUmVnZXhwID0gNSxcbiAgVW53cmFwID0gNixcbiAgSXAgPSA3LFxuICBMYWJlbEZvcm1hdCA9IDgsXG4gIExpbmVGb3JtYXQgPSA5LFxuICBMYWJlbFJlcGxhY2UgPSAxMCxcbiAgT2Zmc2V0ID0gMTEsXG4gIEJvb2wgPSAxMixcbiAgT24gPSAxMyxcbiAgSWdub3JpbmcgPSAxNCxcbiAgR3JvdXBMZWZ0ID0gMTUsXG4gIEdyb3VwUmlnaHQgPSAxNixcbiAgQnl0ZXNDb252ID0gMTcsXG4gIER1cmF0aW9uQ29udiA9IDE4LFxuICBEdXJhdGlvblNlY29uZHNDb252ID0gMTksXG4gIEJ5ID0gMjAsXG4gIFdpdGhvdXQgPSAyMSxcbiAgQW5kID0gMjIsXG4gIE9yID0gMjMsXG4gIFVubGVzcyA9IDI0LFxuICBTdW0gPSAyNSxcbiAgQXZnID0gMjYsXG4gIENvdW50ID0gMjcsXG4gIE1heCA9IDI4LFxuICBNaW4gPSAyOSxcbiAgU3RkZGV2ID0gMzAsXG4gIFN0ZHZhciA9IDMxLFxuICBCb3R0b21rID0gMzIsXG4gIFRvcGsgPSAzMyxcbiAgTGluZUNvbW1lbnQgPSAzNCxcbiAgTG9nUUwgPSAzNSxcbiAgRXhwciA9IDM2LFxuICBMb2dFeHByID0gMzcsXG4gIFNlbGVjdG9yID0gMzgsXG4gIE1hdGNoZXJzID0gMzksXG4gIE1hdGNoZXIgPSA0MCxcbiAgSWRlbnRpZmllciA9IDQxLFxuICBFcSA9IDQyLFxuICBTdHJpbmcgPSA0MyxcbiAgTmVxID0gNDQsXG4gIFJlID0gNDUsXG4gIE5yZSA9IDQ2LFxuICBQaXBlbGluZUV4cHIgPSA0NyxcbiAgUGlwZWxpbmVTdGFnZSA9IDQ4LFxuICBMaW5lRmlsdGVycyA9IDQ5LFxuICBMaW5lRmlsdGVyID0gNTAsXG4gIEZpbHRlciA9IDUxLFxuICBQaXBlRXhhY3QgPSA1MixcbiAgUGlwZU1hdGNoID0gNTMsXG4gIEZpbHRlck9wID0gNTQsXG4gIFBpcGUgPSA1NSxcbiAgTGFiZWxQYXJzZXIgPSA1NixcbiAgSnNvbkV4cHJlc3Npb25QYXJzZXIgPSA1NyxcbiAgSnNvbkV4cHJlc3Npb25MaXN0ID0gNTgsXG4gIEpzb25FeHByZXNzaW9uID0gNTksXG4gIExhYmVsRmlsdGVyID0gNjAsXG4gIElwTGFiZWxGaWx0ZXIgPSA2MSxcbiAgVW5pdEZpbHRlciA9IDYyLFxuICBEdXJhdGlvbkZpbHRlciA9IDYzLFxuICBHdHIgPSA2NCxcbiAgRHVyYXRpb24gPSA2NSxcbiAgR3RlID0gNjYsXG4gIExzcyA9IDY3LFxuICBMdGUgPSA2OCxcbiAgRXFsID0gNjksXG4gIEJ5dGVzRmlsdGVyID0gNzAsXG4gIEJ5dGVzID0gNzEsXG4gIE51bWJlckZpbHRlciA9IDcyLFxuICBOdW1iZXIgPSA3MyxcbiAgTGluZUZvcm1hdEV4cHIgPSA3NCxcbiAgTGFiZWxGb3JtYXRFeHByID0gNzUsXG4gIExhYmVsc0Zvcm1hdCA9IDc2LFxuICBMYWJlbEZvcm1hdE1hdGNoZXIgPSA3NyxcbiAgTWV0cmljRXhwciA9IDc4LFxuICBSYW5nZUFnZ3JlZ2F0aW9uRXhwciA9IDc5LFxuICBSYW5nZU9wID0gODAsXG4gIENvdW50T3ZlclRpbWUgPSA4MSxcbiAgUmF0ZSA9IDgyLFxuICBCeXRlc092ZXJUaW1lID0gODMsXG4gIEJ5dGVzUmF0ZSA9IDg0LFxuICBBdmdPdmVyVGltZSA9IDg1LFxuICBTdW1PdmVyVGltZSA9IDg2LFxuICBNaW5PdmVyVGltZSA9IDg3LFxuICBNYXhPdmVyVGltZSA9IDg4LFxuICBTdGRkZXZPdmVyVGltZSA9IDg5LFxuICBTdGR2YXJPdmVyVGltZSA9IDkwLFxuICBRdWFudGlsZU92ZXJUaW1lID0gOTEsXG4gIEZpcnN0T3ZlclRpbWUgPSA5MixcbiAgTGFzdE92ZXJUaW1lID0gOTMsXG4gIEFic2VudE92ZXJUaW1lID0gOTQsXG4gIExvZ1JhbmdlRXhwciA9IDk1LFxuICBSYW5nZSA9IDk2LFxuICBPZmZzZXRFeHByID0gOTcsXG4gIFVud3JhcEV4cHIgPSA5OCxcbiAgQ29udk9wID0gOTksXG4gIEdyb3VwaW5nID0gMTAwLFxuICBMYWJlbHMgPSAxMDEsXG4gIFZlY3RvckFnZ3JlZ2F0aW9uRXhwciA9IDEwMixcbiAgVmVjdG9yT3AgPSAxMDMsXG4gIEJpbk9wRXhwciA9IDEwNCxcbiAgQmluT3BNb2RpZmllciA9IDEwNSxcbiAgT25Pcklnbm9yaW5nTW9kaWZpZXIgPSAxMDYsXG4gIEdyb3VwaW5nTGFiZWxzID0gMTA3LFxuICBHcm91cGluZ0xhYmVsTGlzdCA9IDEwOCxcbiAgR3JvdXBpbmdMYWJlbCA9IDEwOSxcbiAgTGFiZWxOYW1lID0gMTEwLFxuICBBZGQgPSAxMTEsXG4gIFN1YiA9IDExMixcbiAgTXVsID0gMTEzLFxuICBEaXYgPSAxMTQsXG4gIE1vZCA9IDExNSxcbiAgUG93ID0gMTE2LFxuICBMaXRlcmFsRXhwciA9IDExNyxcbiAgTGFiZWxSZXBsYWNlRXhwciA9IDExODtcblxuZXhwb3J0IHsgQWJzZW50T3ZlclRpbWUsIEFkZCwgQW5kLCBBdmcsIEF2Z092ZXJUaW1lLCBCaW5PcEV4cHIsIEJpbk9wTW9kaWZpZXIsIEJvb2wsIEJvdHRvbWssIEJ5LCBCeXRlcywgQnl0ZXNDb252LCBCeXRlc0ZpbHRlciwgQnl0ZXNPdmVyVGltZSwgQnl0ZXNSYXRlLCBDb252T3AsIENvdW50LCBDb3VudE92ZXJUaW1lLCBEaXYsIER1cmF0aW9uLCBEdXJhdGlvbkNvbnYsIER1cmF0aW9uRmlsdGVyLCBEdXJhdGlvblNlY29uZHNDb252LCBFcSwgRXFsLCBFeHByLCBGaWx0ZXIsIEZpbHRlck9wLCBGaXJzdE92ZXJUaW1lLCBHcm91cExlZnQsIEdyb3VwUmlnaHQsIEdyb3VwaW5nLCBHcm91cGluZ0xhYmVsLCBHcm91cGluZ0xhYmVsTGlzdCwgR3JvdXBpbmdMYWJlbHMsIEd0ZSwgR3RyLCBJZGVudGlmaWVyLCBJZ25vcmluZywgSXAsIElwTGFiZWxGaWx0ZXIsIEpzb24sIEpzb25FeHByZXNzaW9uLCBKc29uRXhwcmVzc2lvbkxpc3QsIEpzb25FeHByZXNzaW9uUGFyc2VyLCBMYWJlbEZpbHRlciwgTGFiZWxGb3JtYXQsIExhYmVsRm9ybWF0RXhwciwgTGFiZWxGb3JtYXRNYXRjaGVyLCBMYWJlbE5hbWUsIExhYmVsUGFyc2VyLCBMYWJlbFJlcGxhY2UsIExhYmVsUmVwbGFjZUV4cHIsIExhYmVscywgTGFiZWxzRm9ybWF0LCBMYXN0T3ZlclRpbWUsIExpbmVDb21tZW50LCBMaW5lRmlsdGVyLCBMaW5lRmlsdGVycywgTGluZUZvcm1hdCwgTGluZUZvcm1hdEV4cHIsIExpdGVyYWxFeHByLCBMb2dFeHByLCBMb2dRTCwgTG9nUmFuZ2VFeHByLCBMb2dmbXQsIExzcywgTHRlLCBNYXRjaGVyLCBNYXRjaGVycywgTWF4LCBNYXhPdmVyVGltZSwgTWV0cmljRXhwciwgTWluLCBNaW5PdmVyVGltZSwgTW9kLCBNdWwsIE5lcSwgTnJlLCBOdW1iZXIsIE51bWJlckZpbHRlciwgT2Zmc2V0LCBPZmZzZXRFeHByLCBPbiwgT25Pcklnbm9yaW5nTW9kaWZpZXIsIE9yLCBQYXR0ZXJuLCBQaXBlLCBQaXBlRXhhY3QsIFBpcGVNYXRjaCwgUGlwZWxpbmVFeHByLCBQaXBlbGluZVN0YWdlLCBQb3csIFF1YW50aWxlT3ZlclRpbWUsIFJhbmdlLCBSYW5nZUFnZ3JlZ2F0aW9uRXhwciwgUmFuZ2VPcCwgUmF0ZSwgUmUsIFJlZ2V4cCwgU2VsZWN0b3IsIFN0ZGRldiwgU3RkZGV2T3ZlclRpbWUsIFN0ZHZhciwgU3RkdmFyT3ZlclRpbWUsIFN0cmluZywgU3ViLCBTdW0sIFN1bU92ZXJUaW1lLCBUb3BrLCBVbml0RmlsdGVyLCBVbmxlc3MsIFVucGFjaywgVW53cmFwLCBVbndyYXBFeHByLCBWZWN0b3JBZ2dyZWdhdGlvbkV4cHIsIFZlY3Rvck9wLCBXaXRob3V0LCBwYXJzZXIgfTtcbiIsImltcG9ydCB7IExSUGFyc2VyIH0gZnJvbSAnQGxlemVyL2xyJztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBcbiAgaW5mID0gMTQ2LFxuICBuYW4gPSAxNDcsXG4gIEJvb2wgPSAxLFxuICBJZ25vcmluZyA9IDIsXG4gIE9uID0gMyxcbiAgR3JvdXBMZWZ0ID0gNCxcbiAgR3JvdXBSaWdodCA9IDUsXG4gIE9mZnNldCA9IDYsXG4gIEF0YW4yID0gNyxcbiAgQXZnID0gOCxcbiAgQm90dG9tayA9IDksXG4gIENvdW50ID0gMTAsXG4gIENvdW50VmFsdWVzID0gMTEsXG4gIEdyb3VwID0gMTIsXG4gIE1heCA9IDEzLFxuICBNaW4gPSAxNCxcbiAgUXVhbnRpbGUgPSAxNSxcbiAgU3RkZGV2ID0gMTYsXG4gIFN0ZHZhciA9IDE3LFxuICBTdW0gPSAxOCxcbiAgVG9wayA9IDE5LFxuICBCeSA9IDIwLFxuICBXaXRob3V0ID0gMjEsXG4gIEFuZCA9IDIyLFxuICBPciA9IDIzLFxuICBVbmxlc3MgPSAyNCxcbiAgU3RhcnQgPSAyNSxcbiAgRW5kID0gMjY7XG5cbi8vIENvcHlyaWdodCAyMDIxIFRoZSBQcm9tZXRoZXVzIEF1dGhvcnNcblxuY29uc3Qga2V5d29yZFRva2VucyA9IHtcbiAgICBpbmY6IGluZixcbiAgICBuYW46IG5hbixcbiAgICBib29sOiBCb29sLFxuICAgIGlnbm9yaW5nOiBJZ25vcmluZyxcbiAgICBvbjogT24sXG4gICAgZ3JvdXBfbGVmdDogR3JvdXBMZWZ0LFxuICAgIGdyb3VwX3JpZ2h0OiBHcm91cFJpZ2h0LFxuICAgIG9mZnNldDogT2Zmc2V0LFxufTtcblxuY29uc3Qgc3BlY2lhbGl6ZUlkZW50aWZpZXIgPSAodmFsdWUsIHN0YWNrKSA9PiB7XG4gICAgcmV0dXJuIGtleXdvcmRUb2tlbnNbdmFsdWUudG9Mb3dlckNhc2UoKV0gfHwgLTE7XG59O1xuXG5jb25zdCBjb250ZXh0dWFsS2V5d29yZFRva2VucyA9IHtcbiAgICBhdmc6IEF2ZyxcbiAgICBhdGFuMjogQXRhbjIsXG4gICAgYm90dG9tazogQm90dG9tayxcbiAgICBjb3VudDogQ291bnQsXG4gICAgY291bnRfdmFsdWVzOiBDb3VudFZhbHVlcyxcbiAgICBncm91cDogR3JvdXAsXG4gICAgbWF4OiBNYXgsXG4gICAgbWluOiBNaW4sXG4gICAgcXVhbnRpbGU6IFF1YW50aWxlLFxuICAgIHN0ZGRldjogU3RkZGV2LFxuICAgIHN0ZHZhcjogU3RkdmFyLFxuICAgIHN1bTogU3VtLFxuICAgIHRvcGs6IFRvcGssXG4gICAgYnk6IEJ5LFxuICAgIHdpdGhvdXQ6IFdpdGhvdXQsXG4gICAgYW5kOiBBbmQsXG4gICAgb3I6IE9yLFxuICAgIHVubGVzczogVW5sZXNzLFxuICAgIHN0YXJ0OiBTdGFydCxcbiAgICBlbmQ6IEVuZCxcbn07XG5cbmNvbnN0IGV4dGVuZElkZW50aWZpZXIgPSAodmFsdWUsIHN0YWNrKSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHR1YWxLZXl3b3JkVG9rZW5zW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IC0xO1xufTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX0lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsYWJzZW50X292ZXJfdGltZTozMDcsIGFic2VudDozMDksIGFiczozMTEsIGFjb3M6MzEzLCBhY29zaDozMTUsIGFzaW46MzE3LCBhc2luaDozMTksIGF0YW46MzIxLCBhdGFuaDozMjMsIGF2Z19vdmVyX3RpbWU6MzI1LCBjZWlsOjMyNywgY2hhbmdlczozMjksIGNsYW1wOjMzMSwgY2xhbXBfbWF4OjMzMywgY2xhbXBfbWluOjMzNSwgY29zOjMzNywgY29zaDozMzksIGNvdW50X292ZXJfdGltZTozNDEsIGRheXNfaW5fbW9udGg6MzQzLCBkYXlfb2ZfbW9udGg6MzQ1LCBkYXlfb2Zfd2VlazozNDcsIGRlZzozNDksIGRlbHRhOjM1MSwgZGVyaXY6MzUzLCBleHA6MzU1LCBmbG9vcjozNTcsIGhpc3RvZ3JhbV9xdWFudGlsZTozNTksIGhvbHRfd2ludGVyczozNjEsIGhvdXI6MzYzLCBpZGVsdGE6MzY1LCBpbmNyZWFzZTozNjcsIGlyYXRlOjM2OSwgbGFiZWxfcmVwbGFjZTozNzEsIGxhYmVsX2pvaW46MzczLCBsYXN0X292ZXJfdGltZTozNzUsIGxuOjM3NywgbG9nMTA6Mzc5LCBsb2cyOjM4MSwgbWF4X292ZXJfdGltZTozODMsIG1pbl9vdmVyX3RpbWU6Mzg1LCBtaW51dGU6Mzg3LCBtb250aDozODksIHBpOjM5MSwgcHJlZGljdF9saW5lYXI6MzkzLCBwcmVzZW50X292ZXJfdGltZTozOTUsIHF1YW50aWxlX292ZXJfdGltZTozOTcsIHJhZDozOTksIHJhdGU6NDAxLCByZXNldHM6NDAzLCByb3VuZDo0MDUsIHNjYWxhcjo0MDcsIHNnbjo0MDksIHNpbjo0MTEsIHNpbmg6NDEzLCBzb3J0OjQxNSwgc29ydF9kZXNjOjQxNywgc3FydDo0MTksIHN0ZGRldl9vdmVyX3RpbWU6NDIxLCBzdGR2YXJfb3Zlcl90aW1lOjQyMywgc3VtX292ZXJfdGltZTo0MjUsIHRhbjo0MjcsIHRhbmg6NDI5LCB0aW1lc3RhbXA6NDMxLCB0aW1lOjQzMywgdmVjdG9yOjQzNSwgeWVhcjo0Mzd9O1xuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxMyxcbiAgc3RhdGVzOiBcIjZbT1lRUE9PTyZ7UVBPT09PUU8nI0N7JyNDe08nUVFQTycjQ3pRJ11RUU9PT09RTycjRGUnI0RlTydXUVBPJyNEZE9PUU8nI0V9JyNFfU8oalFQTycjRlRPWVFQTycjRlBPWVFQTycjRlNPT1FPJyNGVicjRlZPLmZRU08nI0ZXTy5uUVFPJyNGVU9PUU8nI0ZVJyNGVU9PUU8nI0N5JyNDeU9PUU8nI0RmJyNEZk9PUU8nI0RoJyNEaE9PUU8nI0RpJyNEaU9PUU8nI0RqJyNEak9PUU8nI0RrJyNEa09PUU8nI0RsJyNEbE9PUU8nI0RtJyNEbU9PUU8nI0RuJyNEbk9PUU8nI0RvJyNEb09PUU8nI0RwJyNEcE9PUU8nI0RxJyNEcU9PUU8nI0RyJyNEck9PUU8nI0RzJyNEc09PUU8nI0R0JyNEdE9PUU8nI0R1JyNEdU9PUU8nI0R2JyNEdk9PUU8nI0R3JyNEd09PUU8nI0R4JyNEeE9PUU8nI0R5JyNEeU9PUU8nI0R6JyNEek9PUU8nI0R7JyNEe09PUU8nI0R8JyNEfE9PUU8nI0R9JyNEfU9PUU8nI0VPJyNFT09PUU8nI0VQJyNFUE9PUU8nI0VRJyNFUU9PUU8nI0VSJyNFUk9PUU8nI0VTJyNFU09PUU8nI0VUJyNFVE9PUU8nI0VVJyNFVU9PUU8nI0VWJyNFVk9PUU8nI0VXJyNFV09PUU8nI0VYJyNFWE9PUU8nI0VZJyNFWU9PUU8nI0VaJyNFWk9PUU8nI0VbJyNFW09PUU8nI0VdJyNFXU9PUU8nI0VeJyNFXk9PUU8nI0VfJyNFX09PUU8nI0VgJyNFYE9PUU8nI0VhJyNFYU9PUU8nI0ViJyNFYk9PUU8nI0VjJyNFY09PUU8nI0VkJyNFZE9PUU8nI0VlJyNFZU9PUU8nI0VmJyNFZk9PUU8nI0VnJyNFZ09PUU8nI0VoJyNFaE9PUU8nI0VpJyNFaU9PUU8nI0VqJyNFak9PUU8nI0VrJyNFa09PUU8nI0VsJyNFbE9PUU8nI0VtJyNFbU9PUU8nI0VuJyNFbk9PUU8nI0VvJyNFb09PUU8nI0VwJyNFcE9PUU8nI0VxJyNFcU9PUU8nI0VyJyNFck9PUU8nI0VzJyNFc09PUU8nI0V0JyNFdE9PUU8nI0V1JyNFdU9PUU8nI0V2JyNFdk9PUU8nI0V3JyNFd09PUU8nI0V4JyNFeE9PUU8nI0V5JyNFeU9PUU8nI0V6JyNFelFPUVBPT08wWFFQTycjQ3xPMF5RUE8nI0RSTydXUVBPLDU5Zk8wZVFRTyw1OWZPMlJRUE8sNTlvTzJSUVBPLDU5b08yUlFQTyw1OW9PMlJRUE8sNTlvTzJSUVBPLDU5b083fVFRTyw1O2dPOFNRUU8sNTtqTzhbUVBPLDU7eU9PUU8sNTpPLDU6T09PUU8sNTtpLDU7aU84c1FRTyw1O2tPOHpRUU8sNTtuTzpiUVBPJyNGWU86cFFQTyw1O3JPT1FPJyNGWCcjRlhPT1FPLDU7ciw1O3JPT1FPLDU7cCw1O3BPOnhRU08nI0N9T09RTyw1OWgsNTloTztRUVBPLDU5bU87WVFRTycjRFNPT1FPLDU5bSw1OW1PT1FPMUcvUTFHL1FPMFhRUE8nI0RXT0FWUVBPJyNEVk9BYVFQTycjRFZPWVFQTzFHL1pPWVFQTzFHL1pPWVFQTzFHL1pPWVFQTzFHL1pPWVFQTzFHL1pPQWtRU08xRzFST09RTzFHMVUxRzFVT0FzUVFPMUcxVU9BeFFQTycjRX1PT1FPJyNGYScjRmFPT1FPMUcxZTFHMWVPQlRRUE8xRzFlT09RTzFHMVYxRzFWT09RTycjRlonI0ZaT0JZUVBPLDU7dE9CX1FTTzFHMV5PT1FPMUcxXjFHMV5PT1FPJyNEUCcjRFBPQmdRUE8sNTlpT09RTycjRE8nI0RPT09RTyw1OWksNTlpT1lRUE8sNTluT09RTzFHL1gxRy9YT09RTyw1OXIsNTlyT0hfUVBPLDU5cU9IZlFQTyw1OXFPSX1RUU83KyR1T0pfUVFPNyskdU9Lc1FRTzcrJHVPTFpRUU83KyR1T01yUVFPNyskdU9PUU83KyZtNysmbU9OXVFRTzcrJnNPT1FPNysmcDcrJnBPTmVRUE83KydQT09RTzFHMWAxRzFgT09RTzFHMV8xRzFfT09RTzcrJng3KyZ4T05qUVNPMUcvVE9PUU8xRy9UMUcvVE9OclFRTzFHL1lPT1FPMUcvXTFHL11PTnxRUE8xRy9dT09RTzw8Sl88PEpfTyEmb1FQTzw8Sl9PT1FPPDxKazw8SmtPT1FPMUcvVTFHL1VPT1FPNyskbzcrJG9PT1FPNyskdzcrJHdPT1FPQU4/eUFOP3lcIixcbiAgc3RhdGVEYXRhOiBcIiEmdH5PJFpPU2tPU35PV1FPWFFPWVFPWlFPW1FPXVFPXlFPX1FPYFFPYVFPYlFPY1FPIVpaTyN0X08kV1ZPJFhWTyRbWE8kX2BPJGBhTyRhYk8kYmNPJGNkTyRkZU8kZWZPJGZnTyRnaE8kaGlPJGlqTyRqa08ka2xPJGxtTyRtbk8kbm9PJG9wTyRwcU8kcXJPJHJzTyRzdE8kdHVPJHV2TyR2d08kd3hPJHh5TyR5ek8kentPJHt8TyR8fU8kfSFPTyVPIVBPJVAhUU8lUSFSTyVSIVNPJVMhVE8lVCFVTyVVIVZPJVYhV08lVyFYTyVYIVlPJVkhWk8lWiFbTyVbIV1PJV0hXk8lXiFfTyVfIWBPJWAhYU8lYSFiTyViIWNPJWMhZE8lZCFlTyVlIWZPJWYhZ08lZyFoTyVoIWlPJWkhak8laiFrTyVrIWxPJWwhbU8lbSFuTyVuIW9PJW8hcE8lcCFxTyVxIXJPJXIhc08ldVdPJXZXTyV3Vk8leVtPfk8hWlpPfk9kIXVPZSF1TyRbIXZPfk9VI1BPViF5T2YhfE9nIX1PaCF8T3gheU97IXlPfCF5T30heU8hTyF6TyFQIXpPIVEhe08hUiF7TyFTIXtPIVQhe08hVSF7TyFWIXtPJFMjUU8lcyNPT35PJFcjU08kWCNTTyV3I1NPVyN3WFgjd1hZI3dYWiN3WFsjd1hdI3dYXiN3WF8jd1hgI3dYYSN3WGIjd1hjI3dYIVojd1gjdCN3WCRXI3dYJFgjd1gkWyN3WCRfI3dYJGAjd1gkYSN3WCRiI3dYJGMjd1gkZCN3WCRlI3dYJGYjd1gkZyN3WCRoI3dYJGkjd1gkaiN3WCRrI3dYJGwjd1gkbSN3WCRuI3dYJG8jd1gkcCN3WCRxI3dYJHIjd1gkcyN3WCR0I3dYJHUjd1gkdiN3WCR3I3dYJHgjd1gkeSN3WCR6I3dYJHsjd1gkfCN3WCR9I3dYJU8jd1glUCN3WCVRI3dYJVIjd1glUyN3WCVUI3dYJVUjd1glViN3WCVXI3dYJVgjd1glWSN3WCVaI3dYJVsjd1glXSN3WCVeI3dYJV8jd1glYCN3WCVhI3dYJWIjd1glYyN3WCVkI3dYJWUjd1glZiN3WCVnI3dYJWgjd1glaSN3WCVqI3dYJWsjd1glbCN3WCVtI3dYJW4jd1glbyN3WCVwI3dYJXEjd1glciN3WCV1I3dYJXYjd1gldyN3WCV5I3dYfk90I1ZPJXojWU9+TyV5W09VI3hYViN4WGYjeFhnI3hYaCN4WHgjeFh7I3hYfCN4WH0jeFghTyN4WCFQI3hYIVEjeFghUiN4WCFTI3hYIVQjeFghVSN4WCFWI3hYJFMjeFgkViN4WCVzI3hYJF4jeFgkXSN4WH5PJFsjW09+TyReI2BPflBZT2QhdU9lIXVPVW5hVm5hZm5hZ25haG5heG5he25hfG5hfW5hIU9uYSFQbmEhUW5hIVJuYSFTbmEhVG5hIVVuYSFWbmEkU25hJFZuYSVzbmEkXm5hJF1uYX5PUCNkT1EjYk9SI2JPV3lQWHlQWXlQWnlQW3lQXXlQXnlQX3lQYHlQYXlQYnlQY3lQIVp5UCN0eVAkV3lQJFh5UCRbeVAkX3lQJGB5UCRheVAkYnlQJGN5UCRkeVAkZXlQJGZ5UCRneVAkaHlQJGl5UCRqeVAka3lQJGx5UCRteVAkbnlQJG95UCRweVAkcXlQJHJ5UCRzeVAkdHlQJHV5UCR2eVAkd3lQJHh5UCR5eVAkenlQJHt5UCR8eVAkfXlQJU95UCVQeVAlUXlQJVJ5UCVTeVAlVHlQJVV5UCVWeVAlV3lQJVh5UCVZeVAlWnlQJVt5UCVdeVAlXnlQJV95UCVgeVAlYXlQJWJ5UCVjeVAlZHlQJWV5UCVmeVAlZ3lQJWh5UCVpeVAlanlQJWt5UCVseVAlbXlQJW55UCVveVAlcHlQJXF5UCVyeVAldXlQJXZ5UCV3eVAleXlQfk8jcCNqT35PIVAjbE8jcCNrT35PaSNuT2ojbk8kV1ZPJFhWTyV1I21PJXYjbU8ld1ZPfk8kXiNxT35QJ11PeCF5T1UjdmFWI3ZhZiN2YWcjdmFoI3ZheyN2YXwjdmF9I3ZhIU8jdmEhUCN2YSFRI3ZhIVIjdmEhUyN2YSFUI3ZhIVUjdmEhViN2YSRTI3ZhJFYjdmElcyN2YSReI3ZhJF0jdmF+TyFWI3JPJE8jck8kUCNyTyRRI3JPfk8kXSN0TyV6I3VPfk90I3ZPJF4jeU9+TyRdI3pPJF4je09+TyRddlgkXnZYflAnXU9XeVhYeVhZeVhaeVhbeVhdeVheeVhfeVhgeVhheVhieVhjeVghWnlYI3R5WCRXeVgkWHlYJFt5WCRfeVgkYHlYJGF5WCRieVgkY3lYJGR5WCRleVgkZnlYJGd5WCRoeVgkaXlYJGp5WCRreVgkbHlYJG15WCRueVgkb3lYJHB5WCRxeVgkcnlYJHN5WCR0eVgkdXlYJHZ5WCR3eVgkeHlYJHl5WCR6eVgke3lYJHx5WCR9eVglT3lYJVB5WCVReVglUnlYJVN5WCVUeVglVXlYJVZ5WCVXeVglWHlYJVl5WCVaeVglW3lYJV15WCVeeVglX3lYJWB5WCVheVglYnlYJWN5WCVkeVglZXlYJWZ5WCVneVglaHlYJWl5WCVqeVgla3lYJWx5WCVteVglbnlYJW95WCVweVglcXlYJXJ5WCV1eVgldnlYJXd5WCV5eVh+T1MjfU9UI31PflA7ZE9RI2JPUiNiT35QO2RPJXQkVU8leCRWT35PI3AkV09+TyRXI1NPJFgjU08ldyNTT35PJFskWE9+TyN0JFlPfk90I1ZPJXokW09+TyRdJF1PJF4kXk9+T1d5YVh5YVl5YVp5YVt5YV15YV55YV95YWB5YWF5YWJ5YWN5YSFaeWEjdHlhJFd5YSRYeWEkX3lhJGB5YSRheWEkYnlhJGN5YSRkeWEkZXlhJGZ5YSRneWEkaHlhJGl5YSRqeWEka3lhJGx5YSRteWEkbnlhJG95YSRweWEkcXlhJHJ5YSRzeWEkdHlhJHV5YSR2eWEkd3lhJHh5YSR5eWEkenlhJHt5YSR8eWEkfXlhJU95YSVQeWElUXlhJVJ5YSVTeWElVHlhJVV5YSVWeWElV3lhJVh5YSVZeWElWnlhJVt5YSVdeWElXnlhJV95YSVgeWElYXlhJWJ5YSVjeWElZHlhJWV5YSVmeWElZ3lhJWh5YSVpeWElanlhJWt5YSVseWElbXlhJW55YSVveWElcHlhJXF5YSVyeWEldXlhJXZ5YSV3eWEleXlhfk8kWyNbT35QQm9PUyRhT1QkYU8kW3lhflBCb094IXlPVXdxZndxZ3dxaHdxIU93cSFQd3EhUXdxIVJ3cSFTd3EhVHdxIVV3cSFWd3EkU3dxJFZ3cSVzd3EkXndxJF13cX5PVndxe3dxfHdxfXdxflBIc09WIXlPeyF5T3wheU99IXlPflBIc09WIXlPeCF5T3sheU98IXlPfSF5TyFPIXpPIVAhek9Vd3Fmd3Fnd3Fod3EkU3dxJFZ3cSVzd3EkXndxJF13cX5PIVF3cSFSd3EhU3dxIVR3cSFVd3EhVndxflBKb08hUSF7TyFSIXtPIVMhe08hVCF7TyFVIXtPIVYhe09+UEpvT1YheU9mIXxPaCF8T3gheU97IXlPfCF5T30heU8hTyF6TyFQIXpPIVEhe08hUiF7TyFTIXtPIVQhe08hVSF7TyFWIXtPfk9Vd3Fnd3EkU3dxJFZ3cSVzd3EkXndxJF13cX5QTHFPI3AkY08ldCRiT35PJF4kZE9+T3Qjdk8kXiRmT35PJF12aSRedml+UCddTyRbI1tPV3lpWHlpWXlpWnlpW3lpXXlpXnlpX3lpYHlpYXlpYnlpY3lpIVp5aSN0eWkkV3lpJFh5aSRfeWkkYHlpJGF5aSRieWkkY3lpJGR5aSRleWkkZnlpJGd5aSRoeWkkaXlpJGp5aSRreWkkbHlpJG15aSRueWkkb3lpJHB5aSRxeWkkcnlpJHN5aSR0eWkkdXlpJHZ5aSR3eWkkeHlpJHl5aSR6eWkke3lpJHx5aSR9eWklT3lpJVB5aSVReWklUnlpJVN5aSVUeWklVXlpJVZ5aSVXeWklWHlpJVl5aSVaeWklW3lpJV15aSVeeWklX3lpJWB5aSVheWklYnlpJWN5aSVkeWklZXlpJWZ5aSVneWklaHlpJWl5aSVqeWkla3lpJWx5aSVteWklbnlpJW95aSVweWklcXlpJXJ5aSV1eWkldnlpJXd5aSV5eWl+TyV0JGhPfk9cIixcbiAgZ290bzogXCIodSRVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAkViR1JVIlXyVlJXEldFAleiZUJHVQJlcmZ1BQUFBQUFBQUFBQJHUmcSZ9UCZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0kdVAnWiR1JHVQJHUkdSdqJHUndihWKGYoaShvUFBQJHVQKHJRU09RI1RYUSNVWVEjXyF2USRQI2VRJFEjZlEkUiNnUSRTI2hRJFQjaVIkXyN6ZV9PWFkhdiNlI2YjZyNoI2kjemVST1hZIXYjZSNmI2cjaCNpI3pRIXdSUiNhIXhRI10hdVEjfCNiUSRgI31SJGckYVIjdyNbUSN4I1tSJGUkXVEheFJRI1JVUiNhIXdSI14hdlEjZSF5USNmIXpRI2che1EjaCF8UiNpIX1ZI2MheSF6IXshfCF9UiRPI2RlVU9YWSF2I2UjZiNnI2gjaSN6ZVRPWFkhdiNlI2YjZyNoI2kjemRfT1hZIXYjZSNmI2cjaCNpI3pSI28jUWVZT1hZIXYjZSNmI2cjaCNpI3pkXU9YWSF2I2UjZiNnI2gjaSN6UiF0UGReT1hZIXYjZSNmI2cjaCNpI3pSI1pdUiNXW1EjWFtSJFojdFIjcyNWUiNwI1FcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBCb29sIElnbm9yaW5nIE9uIEdyb3VwTGVmdCBHcm91cFJpZ2h0IE9mZnNldCBBdGFuMiBBdmcgQm90dG9tayBDb3VudCBDb3VudFZhbHVlcyBHcm91cCBNYXggTWluIFF1YW50aWxlIFN0ZGRldiBTdGR2YXIgU3VtIFRvcGsgQnkgV2l0aG91dCBBbmQgT3IgVW5sZXNzIFN0YXJ0IEVuZCBMaW5lQ29tbWVudCBQcm9tUUwgRXhwciBBZ2dyZWdhdGVFeHByIEFnZ3JlZ2F0ZU9wIEFnZ3JlZ2F0ZU1vZGlmaWVyIEdyb3VwaW5nTGFiZWxzIEdyb3VwaW5nTGFiZWxMaXN0IEdyb3VwaW5nTGFiZWwgTGFiZWxOYW1lIEZ1bmN0aW9uQ2FsbEJvZHkgRnVuY3Rpb25DYWxsQXJncyBCaW5hcnlFeHByIFBvdyBCaW5Nb2RpZmllcnMgT25Pcklnbm9yaW5nIE11bCBEaXYgTW9kIEFkZCBTdWIgRXFsIEd0ZSBHdHIgTHRlIExzcyBOZXEgRnVuY3Rpb25DYWxsIEZ1bmN0aW9uSWRlbnRpZmllciBBYnNlbnRPdmVyVGltZSBJZGVudGlmaWVyIEFic2VudCBBYnMgQWNvcyBBY29zaCBBc2luIEFzaW5oIEF0YW4gQXRhbmggQXZnT3ZlclRpbWUgQ2VpbCBDaGFuZ2VzIENsYW1wIENsYW1wTWF4IENsYW1wTWluIENvcyBDb3NoIENvdW50T3ZlclRpbWUgRGF5c0luTW9udGggRGF5T2ZNb250aCBEYXlPZldlZWsgRGVnIERlbHRhIERlcml2IEV4cCBGbG9vciBIaXN0b2dyYW1RdWFudGlsZSBIb2x0V2ludGVycyBIb3VyIElkZWx0YSBJbmNyZWFzZSBJcmF0ZSBMYWJlbFJlcGxhY2UgTGFiZWxKb2luIExhc3RPdmVyVGltZSBMbiBMb2cxMCBMb2cyIE1heE92ZXJUaW1lIE1pbk92ZXJUaW1lIE1pbnV0ZSBNb250aCBQaSBQcmVkaWN0TGluZWFyIFByZXNlbnRPdmVyVGltZSBRdWFudGlsZU92ZXJUaW1lIFJhZCBSYXRlIFJlc2V0cyBSb3VuZCBTY2FsYXIgU2duIFNpbiBTaW5oIFNvcnQgU29ydERlc2MgU3FydCBTdGRkZXZPdmVyVGltZSBTdGR2YXJPdmVyVGltZSBTdW1PdmVyVGltZSBUYW4gVGFuaCBUaW1lc3RhbXAgVGltZSBWZWN0b3IgWWVhciBNYXRyaXhTZWxlY3RvciBEdXJhdGlvbiBOdW1iZXJMaXRlcmFsIE9mZnNldEV4cHIgUGFyZW5FeHByIFN0cmluZ0xpdGVyYWwgU3VicXVlcnlFeHByIFVuYXJ5RXhwciBVbmFyeU9wIFZlY3RvclNlbGVjdG9yIE1ldHJpY0lkZW50aWZpZXIgTGFiZWxNYXRjaGVycyBMYWJlbE1hdGNoTGlzdCBMYWJlbE1hdGNoZXIgTWF0Y2hPcCBFcWxTaW5nbGUgRXFsUmVnZXggTmVxUmVnZXggU3RlcEludmFyaWFudEV4cHIgQXQgQXRNb2RpZmllclByZXByb2Nlc3NvcnMgTWV0cmljTmFtZVwiLFxuICBtYXhUZXJtOiAyMjYsXG4gIHNraXBwZWROb2RlczogWzAsMjddLFxuICByZXBlYXROb2RlQ291bnQ6IDAsXG4gIHRva2VuRGF0YTogXCIxUn5Sd1heI2xwcSNscXIkYXJzJHRzdCVodXYlc3d4JXh4eSZneXombHp7JnF7fCZ2fH0mfX0hTydTIU8hUCdaIVAhUShaIVEhUihgIVIhWylXIVshXS1yIV4hXy5uIV8hYC57IWAhYS9iIWIhYy9vIWMhfS90IX0jTzBbI1AjUTBhI1EjUjBmI1IjUy90I1MjVDBrI1Qjby90I28jcDB3I3EjcjB8I3kjeiNsJGYkZyNsI0JZI0JaI2wkSVMkSV8jbCRJfCRKTyNsJEpUJEpVI2wkS1YkS1cjbCZGVSZGViNsfiNxWSRaflheI2xwcSNsI3kjeiNsJGYkZyNsI0JZI0JaI2wkSVMkSV8jbCRJfCRKTyNsJEpUJEpVI2wkS1YkS1cjbCZGVSZGViNsfiRkUSFfIWAkaiNyI3Mkb34kb08hVn5+JHRPJFF+fiR5VSN0fk9ZJHRaciR0cnMlXXMjTyR0I08jUCViI1B+JHR+JWJPI3R+fiVlUE9+JHR+JW1Ra35PWSVoWn4laH4leE99fn4lfVUjdH5PWSV4WncleHd4JV14I08leCNPI1AmYSNQfiV4fiZkUE9+JXh+JmxPJFt+fiZxTyRefn4mdk97flImfU8ldlAhT1F+J1NPJF1+UidaTyV1UCFQUVAnXlAhUSFbJ2FQJ2ZSJXdQIVEhWydhIWchaCdvI1gjWSdvUCdyUnt8J3t9IU8neyFRIVsoUlAoT1AhUSFbKFJQKFdQJXdQIVEhWyhSfihgT3x+UihlWiV3UCFPIVAnYSFRIVspVyFnIWgnbyNXI1gpeyNYI1knbyNbI10qZCNhI2IqeCNnI2grbCNrI2wrfSNsI20tVyNtI24saVIpXVkld1AhTyFQJ2EhUSFbKVchZyFoJ28jVyNYKXsjWCNZJ28jWyNdKmQjYSNiKngjZyNoK2wjayNsK30jbSNuLGlRKlFQI3BRIVEhWypUUSpXUyFRIVsqVCNbI10qZCNhI2IqeCNnI2grbFEqaVAjcFEhUSFbKmxRKm9SIVEhWypsI2EjYip4I2cjaCtsUSp9USNwUSFRIVsrVCNnI2grZ1ErV1IhUSFbK1QjYSNiK2EjZyNoK2xRK2RQI2cjaCtnUStsTyNwUVErcVAjcFEhUSFbK3RRK3dRIVEhWyt0I2EjYithUSxTUCNwUSFRIVssVlEsWVQhUSFbLFYjVyNYKXsjWyNdKmQjYSNiKngjZyNoK2xRLG5QI3BRIVEhWyxxUSx0VSFRIVsscSNXI1gpeyNbI10qZCNhI2IqeCNnI2grbCNrI2wrfVAtWlIhUSFbLWQhYyFpLWQjVCNaLWRQLWlSJXdQIVEhWy1kIWMhaS1kI1QjWi1kVi15VCV4UyFaUiFRIVsuWSFbIV0uWSFjIX0uWSNSI1MuWSNUI28uWVIuX1QhWlIhUSFbLlkhWyFdLlkhYyF9LlkjUiNTLlkjVCNvLll+LnNQIVV+IV8hYC52fi57TyFUfn4vUVEkT1AhXyFgL1cjciNzL11RL11PIVFRfi9iTyRQfn4vZ1AhU34hXyFgL2p+L29PIVJ+fi90TyRTflYve1QhWlJ0UyFRIVsvdCFbIV0uWSFjIX0vdCNSI1MvdCNUI28vdH4wYU8lc35+MGZPJXR+fjBrT3h+fjBuUk8jUzBrI1MjVCVdI1R+MGt+MHxPJXl+fjFSTyV6flwiLFxuICB0b2tlbml6ZXJzOiBbMCwgMSwgMl0sXG4gIHRvcFJ1bGVzOiB7XCJQcm9tUUxcIjpbMCwyOF0sXCJNZXRyaWNOYW1lXCI6WzEsMTQ0XX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDU3LCBnZXQ6ICh2YWx1ZSwgc3RhY2spID0+IChzcGVjaWFsaXplSWRlbnRpZmllcih2YWx1ZSkgPDwgMSl9LHt0ZXJtOiA1NywgZ2V0OiAodmFsdWUsIHN0YWNrKSA9PiAoZXh0ZW5kSWRlbnRpZmllcih2YWx1ZSkgPDwgMSkgfCAxfSx7dGVybTogNTcsIGdldDogdmFsdWUgPT4gc3BlY19JZGVudGlmaWVyW3ZhbHVlXSB8fCAtMX1dLFxuICB0b2tlblByZWM6IDBcbn0pO1xuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBcbiAgaW5mJDEgPSAxNDYsXG4gIG5hbiQxID0gMTQ3LFxuICBCb29sJDEgPSAxLFxuICBJZ25vcmluZyQxID0gMixcbiAgT24kMSA9IDMsXG4gIEdyb3VwTGVmdCQxID0gNCxcbiAgR3JvdXBSaWdodCQxID0gNSxcbiAgT2Zmc2V0JDEgPSA2LFxuICBBdGFuMiQxID0gNyxcbiAgQXZnJDEgPSA4LFxuICBCb3R0b21rJDEgPSA5LFxuICBDb3VudCQxID0gMTAsXG4gIENvdW50VmFsdWVzJDEgPSAxMSxcbiAgR3JvdXAkMSA9IDEyLFxuICBNYXgkMSA9IDEzLFxuICBNaW4kMSA9IDE0LFxuICBRdWFudGlsZSQxID0gMTUsXG4gIFN0ZGRldiQxID0gMTYsXG4gIFN0ZHZhciQxID0gMTcsXG4gIFN1bSQxID0gMTgsXG4gIFRvcGskMSA9IDE5LFxuICBCeSQxID0gMjAsXG4gIFdpdGhvdXQkMSA9IDIxLFxuICBBbmQkMSA9IDIyLFxuICBPciQxID0gMjMsXG4gIFVubGVzcyQxID0gMjQsXG4gIFN0YXJ0JDEgPSAyNSxcbiAgRW5kJDEgPSAyNixcbiAgTGluZUNvbW1lbnQgPSAyNyxcbiAgUHJvbVFMID0gMjgsXG4gIEV4cHIgPSAyOSxcbiAgQWdncmVnYXRlRXhwciA9IDMwLFxuICBBZ2dyZWdhdGVPcCA9IDMxLFxuICBBZ2dyZWdhdGVNb2RpZmllciA9IDMyLFxuICBHcm91cGluZ0xhYmVscyA9IDMzLFxuICBHcm91cGluZ0xhYmVsTGlzdCA9IDM0LFxuICBHcm91cGluZ0xhYmVsID0gMzUsXG4gIExhYmVsTmFtZSA9IDM2LFxuICBGdW5jdGlvbkNhbGxCb2R5ID0gMzcsXG4gIEZ1bmN0aW9uQ2FsbEFyZ3MgPSAzOCxcbiAgQmluYXJ5RXhwciA9IDM5LFxuICBQb3cgPSA0MCxcbiAgQmluTW9kaWZpZXJzID0gNDEsXG4gIE9uT3JJZ25vcmluZyA9IDQyLFxuICBNdWwgPSA0MyxcbiAgRGl2ID0gNDQsXG4gIE1vZCA9IDQ1LFxuICBBZGQgPSA0NixcbiAgU3ViID0gNDcsXG4gIEVxbCA9IDQ4LFxuICBHdGUgPSA0OSxcbiAgR3RyID0gNTAsXG4gIEx0ZSA9IDUxLFxuICBMc3MgPSA1MixcbiAgTmVxID0gNTMsXG4gIEZ1bmN0aW9uQ2FsbCA9IDU0LFxuICBGdW5jdGlvbklkZW50aWZpZXIgPSA1NSxcbiAgQWJzZW50T3ZlclRpbWUgPSA1NixcbiAgSWRlbnRpZmllciA9IDU3LFxuICBBYnNlbnQgPSA1OCxcbiAgQWJzID0gNTksXG4gIEFjb3MgPSA2MCxcbiAgQWNvc2ggPSA2MSxcbiAgQXNpbiA9IDYyLFxuICBBc2luaCA9IDYzLFxuICBBdGFuID0gNjQsXG4gIEF0YW5oID0gNjUsXG4gIEF2Z092ZXJUaW1lID0gNjYsXG4gIENlaWwgPSA2NyxcbiAgQ2hhbmdlcyA9IDY4LFxuICBDbGFtcCA9IDY5LFxuICBDbGFtcE1heCA9IDcwLFxuICBDbGFtcE1pbiA9IDcxLFxuICBDb3MgPSA3MixcbiAgQ29zaCA9IDczLFxuICBDb3VudE92ZXJUaW1lID0gNzQsXG4gIERheXNJbk1vbnRoID0gNzUsXG4gIERheU9mTW9udGggPSA3NixcbiAgRGF5T2ZXZWVrID0gNzcsXG4gIERlZyA9IDc4LFxuICBEZWx0YSA9IDc5LFxuICBEZXJpdiA9IDgwLFxuICBFeHAgPSA4MSxcbiAgRmxvb3IgPSA4MixcbiAgSGlzdG9ncmFtUXVhbnRpbGUgPSA4MyxcbiAgSG9sdFdpbnRlcnMgPSA4NCxcbiAgSG91ciA9IDg1LFxuICBJZGVsdGEgPSA4NixcbiAgSW5jcmVhc2UgPSA4NyxcbiAgSXJhdGUgPSA4OCxcbiAgTGFiZWxSZXBsYWNlID0gODksXG4gIExhYmVsSm9pbiA9IDkwLFxuICBMYXN0T3ZlclRpbWUgPSA5MSxcbiAgTG4gPSA5MixcbiAgTG9nMTAgPSA5MyxcbiAgTG9nMiA9IDk0LFxuICBNYXhPdmVyVGltZSA9IDk1LFxuICBNaW5PdmVyVGltZSA9IDk2LFxuICBNaW51dGUgPSA5NyxcbiAgTW9udGggPSA5OCxcbiAgUGkgPSA5OSxcbiAgUHJlZGljdExpbmVhciA9IDEwMCxcbiAgUHJlc2VudE92ZXJUaW1lID0gMTAxLFxuICBRdWFudGlsZU92ZXJUaW1lID0gMTAyLFxuICBSYWQgPSAxMDMsXG4gIFJhdGUgPSAxMDQsXG4gIFJlc2V0cyA9IDEwNSxcbiAgUm91bmQgPSAxMDYsXG4gIFNjYWxhciA9IDEwNyxcbiAgU2duID0gMTA4LFxuICBTaW4gPSAxMDksXG4gIFNpbmggPSAxMTAsXG4gIFNvcnQgPSAxMTEsXG4gIFNvcnREZXNjID0gMTEyLFxuICBTcXJ0ID0gMTEzLFxuICBTdGRkZXZPdmVyVGltZSA9IDExNCxcbiAgU3RkdmFyT3ZlclRpbWUgPSAxMTUsXG4gIFN1bU92ZXJUaW1lID0gMTE2LFxuICBUYW4gPSAxMTcsXG4gIFRhbmggPSAxMTgsXG4gIFRpbWVzdGFtcCA9IDExOSxcbiAgVGltZSA9IDEyMCxcbiAgVmVjdG9yID0gMTIxLFxuICBZZWFyID0gMTIyLFxuICBNYXRyaXhTZWxlY3RvciA9IDEyMyxcbiAgRHVyYXRpb24gPSAxMjQsXG4gIE51bWJlckxpdGVyYWwgPSAxMjUsXG4gIE9mZnNldEV4cHIgPSAxMjYsXG4gIFBhcmVuRXhwciA9IDEyNyxcbiAgU3RyaW5nTGl0ZXJhbCA9IDEyOCxcbiAgU3VicXVlcnlFeHByID0gMTI5LFxuICBVbmFyeUV4cHIgPSAxMzAsXG4gIFVuYXJ5T3AgPSAxMzEsXG4gIFZlY3RvclNlbGVjdG9yID0gMTMyLFxuICBNZXRyaWNJZGVudGlmaWVyID0gMTMzLFxuICBMYWJlbE1hdGNoZXJzID0gMTM0LFxuICBMYWJlbE1hdGNoTGlzdCA9IDEzNSxcbiAgTGFiZWxNYXRjaGVyID0gMTM2LFxuICBNYXRjaE9wID0gMTM3LFxuICBFcWxTaW5nbGUgPSAxMzgsXG4gIEVxbFJlZ2V4ID0gMTM5LFxuICBOZXFSZWdleCA9IDE0MCxcbiAgU3RlcEludmFyaWFudEV4cHIgPSAxNDEsXG4gIEF0ID0gMTQyLFxuICBBdE1vZGlmaWVyUHJlcHJvY2Vzc29ycyA9IDE0MyxcbiAgTWV0cmljTmFtZSA9IDE0NDtcblxuZXhwb3J0IHsgQWJzLCBBYnNlbnQsIEFic2VudE92ZXJUaW1lLCBBY29zLCBBY29zaCwgQWRkLCBBZ2dyZWdhdGVFeHByLCBBZ2dyZWdhdGVNb2RpZmllciwgQWdncmVnYXRlT3AsIEFuZCQxIGFzIEFuZCwgQXNpbiwgQXNpbmgsIEF0LCBBdE1vZGlmaWVyUHJlcHJvY2Vzc29ycywgQXRhbiwgQXRhbjIkMSBhcyBBdGFuMiwgQXRhbmgsIEF2ZyQxIGFzIEF2ZywgQXZnT3ZlclRpbWUsIEJpbk1vZGlmaWVycywgQmluYXJ5RXhwciwgQm9vbCQxIGFzIEJvb2wsIEJvdHRvbWskMSBhcyBCb3R0b21rLCBCeSQxIGFzIEJ5LCBDZWlsLCBDaGFuZ2VzLCBDbGFtcCwgQ2xhbXBNYXgsIENsYW1wTWluLCBDb3MsIENvc2gsIENvdW50JDEgYXMgQ291bnQsIENvdW50T3ZlclRpbWUsIENvdW50VmFsdWVzJDEgYXMgQ291bnRWYWx1ZXMsIERheU9mTW9udGgsIERheU9mV2VlaywgRGF5c0luTW9udGgsIERlZywgRGVsdGEsIERlcml2LCBEaXYsIER1cmF0aW9uLCBFbmQkMSBhcyBFbmQsIEVxbCwgRXFsUmVnZXgsIEVxbFNpbmdsZSwgRXhwLCBFeHByLCBGbG9vciwgRnVuY3Rpb25DYWxsLCBGdW5jdGlvbkNhbGxBcmdzLCBGdW5jdGlvbkNhbGxCb2R5LCBGdW5jdGlvbklkZW50aWZpZXIsIEdyb3VwJDEgYXMgR3JvdXAsIEdyb3VwTGVmdCQxIGFzIEdyb3VwTGVmdCwgR3JvdXBSaWdodCQxIGFzIEdyb3VwUmlnaHQsIEdyb3VwaW5nTGFiZWwsIEdyb3VwaW5nTGFiZWxMaXN0LCBHcm91cGluZ0xhYmVscywgR3RlLCBHdHIsIEhpc3RvZ3JhbVF1YW50aWxlLCBIb2x0V2ludGVycywgSG91ciwgSWRlbHRhLCBJZGVudGlmaWVyLCBJZ25vcmluZyQxIGFzIElnbm9yaW5nLCBJbmNyZWFzZSwgSXJhdGUsIExhYmVsSm9pbiwgTGFiZWxNYXRjaExpc3QsIExhYmVsTWF0Y2hlciwgTGFiZWxNYXRjaGVycywgTGFiZWxOYW1lLCBMYWJlbFJlcGxhY2UsIExhc3RPdmVyVGltZSwgTGluZUNvbW1lbnQsIExuLCBMb2cxMCwgTG9nMiwgTHNzLCBMdGUsIE1hdGNoT3AsIE1hdHJpeFNlbGVjdG9yLCBNYXgkMSBhcyBNYXgsIE1heE92ZXJUaW1lLCBNZXRyaWNJZGVudGlmaWVyLCBNZXRyaWNOYW1lLCBNaW4kMSBhcyBNaW4sIE1pbk92ZXJUaW1lLCBNaW51dGUsIE1vZCwgTW9udGgsIE11bCwgTmVxLCBOZXFSZWdleCwgTnVtYmVyTGl0ZXJhbCwgT2Zmc2V0JDEgYXMgT2Zmc2V0LCBPZmZzZXRFeHByLCBPbiQxIGFzIE9uLCBPbk9ySWdub3JpbmcsIE9yJDEgYXMgT3IsIFBhcmVuRXhwciwgUGksIFBvdywgUHJlZGljdExpbmVhciwgUHJlc2VudE92ZXJUaW1lLCBQcm9tUUwsIFF1YW50aWxlJDEgYXMgUXVhbnRpbGUsIFF1YW50aWxlT3ZlclRpbWUsIFJhZCwgUmF0ZSwgUmVzZXRzLCBSb3VuZCwgU2NhbGFyLCBTZ24sIFNpbiwgU2luaCwgU29ydCwgU29ydERlc2MsIFNxcnQsIFN0YXJ0JDEgYXMgU3RhcnQsIFN0ZGRldiQxIGFzIFN0ZGRldiwgU3RkZGV2T3ZlclRpbWUsIFN0ZHZhciQxIGFzIFN0ZHZhciwgU3RkdmFyT3ZlclRpbWUsIFN0ZXBJbnZhcmlhbnRFeHByLCBTdHJpbmdMaXRlcmFsLCBTdWIsIFN1YnF1ZXJ5RXhwciwgU3VtJDEgYXMgU3VtLCBTdW1PdmVyVGltZSwgVGFuLCBUYW5oLCBUaW1lLCBUaW1lc3RhbXAsIFRvcGskMSBhcyBUb3BrLCBVbmFyeUV4cHIsIFVuYXJ5T3AsIFVubGVzcyQxIGFzIFVubGVzcywgVmVjdG9yLCBWZWN0b3JTZWxlY3RvciwgV2l0aG91dCQxIGFzIFdpdGhvdXQsIFllYXIsIGluZiQxIGFzIGluZiwgbmFuJDEgYXMgbmFuLCBwYXJzZXIgfTtcbiIsIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZSAoMTAyNCkuXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuLy8vIEVhY2ggW25vZGUgdHlwZV0oI2NvbW1vbi5Ob2RlVHlwZSkgb3IgW2luZGl2aWR1YWwgdHJlZV0oI2NvbW1vbi5UcmVlKVxuLy8vIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBpdCBpbiBwcm9wcy4gSW5zdGFuY2VzIG9mIHRoaXNcbi8vLyBjbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0UHJvcElEKys7XG4gICAgICAgIHRoaXMucGVyTm9kZSA9ICEhY29uZmlnLnBlck5vZGU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBjb25maWcuZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8gVGhpcyBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGhcbiAgICAvLy8gW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgLy8vIFtgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLlBhcnNlckNvbmZpZy5wcm9wcykgdG8gY29tcHV0ZVxuICAgIC8vLyBwcm9wIHZhbHVlcyBmb3IgZWFjaCBub2RlIHR5cGUgaW4gdGhlIHNldC4gVGFrZXMgYSBbbWF0Y2hcbiAgICAvLy8gb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8vIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIC8vLyBpdCBkb2VzLlxuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIFByb3AgdGhhdCBpcyB1c2VkIHRvIGRlc2NyaWJlIG1hdGNoaW5nIGRlbGltaXRlcnMuIEZvciBvcGVuaW5nXG4vLy8gZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbi8vLyBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHdoZW4gZGVjbGFyaW5nIHRoaXMgcHJvcCBpbiBhIGdyYW1tYXIpXG4vLy8gZm9yIHRoZSBub2RlIHR5cGVzIG9mIGNsb3NpbmcgZGVsaW1pdGVycyB0aGF0IG1hdGNoIGl0LlxuTm9kZVByb3AuY2xvc2VkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG4vLy8gYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBVc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuLy8vIGBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG4vLy8gdGhhdCB0aGUgbm9kZSB3YXMgcGFyc2VkIGluLCBpZiBhbnkuIFVzZWQgdG8gbGltaXQgcmV1c2Ugb2Zcbi8vLyBjb250ZXh0dWFsIG5vZGVzLlxuTm9kZVByb3AuY29udGV4dEhhc2ggPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIFRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbi8vLyBsb29rZWQgYWhlYWQgZm9yIGFueSBvZiB0aGUgdG9rZW5zIGluc2lkZSB0aGUgbm9kZS4gKFRoZSBMUlxuLy8vIHBhcnNlciBvbmx5IHN0b3JlcyB0aGlzIHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gMjUsIGZvclxuLy8vIGVmZmljaWVuY3kgcmVhc29ucy4pXG5Ob2RlUHJvcC5sb29rQWhlYWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIFRoaXMgcGVyLW5vZGUgcHJvcCBpcyB1c2VkIHRvIHJlcGxhY2UgYSBnaXZlbiBub2RlLCBvciBwYXJ0IG9mIGFcbi8vLyBub2RlLCB3aXRoIGFub3RoZXIgdHJlZS4gVGhpcyBpcyB1c2VmdWwgdG8gaW5jbHVkZSB0cmVlcyBmcm9tXG4vLy8gZGlmZmVyZW50IGxhbmd1YWdlcy5cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIEEgbW91bnRlZCB0cmVlLCB3aGljaCBjYW4gYmUgW3N0b3JlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBvblxuLy8vIGEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG4vLy8gcmVwcmVzZW50ZWQgYnkgYW5vdGhlciB0cmVlLlxuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgaW5uZXIgdHJlZS5cbiAgICB0cmVlLCBcbiAgICAvLy8gSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgLy8vIGJlIGluY2x1ZGVkIGluIHRoZSByZWd1bGFyIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGl0cyBob3N0XG4gICAgLy8vIG5vZGUpLiBJZiBub3QsIG9ubHkgdGhlIGdpdmVuIHJhbmdlcyBhcmUgY29uc2lkZXJlZCB0byBiZVxuICAgIC8vLyBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIC8vLyBhIHdheSB0aGF0IGlzbid0IHN0cmljdGx5IGhpZXJhcmNoaWNhbC4gU3VjaCBtb3VudGVkIHRyZWVzIGFyZVxuICAgIC8vLyBvbmx5IGVudGVyZWQgYnkgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKVxuICAgIC8vLyBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgb3ZlcmxheSwgXG4gICAgLy8vIFRoZSBwYXJzZXIgdXNlZCB0byBjcmVhdGUgdGhpcyBzdWJ0cmVlLlxuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFRvcCAqLykgPiAwOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBTa2lwcGVkICovKSA+IDA7IH1cbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIEVycm9yICovKSA+IDA7IH1cbiAgICAvLy8gV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBBbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIC8vLyBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogQW5vbnltb3VzICovKTtcbi8vLyBBIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG4vLy8gZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbi8vLyB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8vLyBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICAvLy8gdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjcmVhdGVkIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuLy8vIFtgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbi8vLyBtb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWUge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcm9vdGVkIGF0IHRoaXMgdHJlZS4gV2hlblxuICAgIC8vLyBgcG9zYCBpcyBnaXZlbiwgdGhlIGN1cnNvciBpcyBbbW92ZWRdKCNjb21tb24uVHJlZUN1cnNvci5tb3ZlVG8pXG4gICAgLy8vIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS5cbiAgICBjdXJzb3IocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSAocG9zICE9IG51bGwgJiYgQ2FjaGVkTm9kZS5nZXQodGhpcykpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgdGhhdCwgdW5saWtlIHJlZ3VsYXJcbiAgICAvLy8gY3Vyc29ycywgZG9lc24ndCBza2lwIHRocm91Z2hcbiAgICAvLy8gW2Fub255bW91c10oI2NvbW1vbi5Ob2RlVHlwZS5pc0Fub255bW91cykgbm9kZXMgYW5kIGRvZXNuJ3RcbiAgICAvLy8gYXV0b21hdGljYWxseSBlbnRlciBtb3VudGVkIG5vZGVzLlxuICAgIGZ1bGxDdXJzb3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIDEgLyogRnVsbCAqLyk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vLyBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBJZiAxLCBpdCdsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBzdGFydCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIC8vLyBmcm9tIGJvdGggc2lkZXMuXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgLy8vIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgICAvLy8gcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgLy8vICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICAvLy8gdGhlIGhvc3QgdHJlZXMpLlxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIC8vLyBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKSwgZ2V0ID0gKCkgPT4gYy5ub2RlOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXG4gICAgLy8vIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5vZGUncyBbcGVyLW5vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3AucGVyTm9kZSkgaW4gYVxuICAgIC8vLyBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIGNvbnN0cnVjdG9yLlxuICAgIGdldCBwcm9wVmFsdWVzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbK2lkLCB0aGlzLnByb3BzW2lkXV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIC8vLyB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgLy8vIFtgTm9kZVR5cGUubm9uZWBdKCNjb21tb24uTm9kZVR5cGVebm9uZSkuXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vLyBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8vLyBUaGUgZW1wdHkgdHJlZVxuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG5jbGFzcyBGbGF0QnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIGdldCBwb3MoKSB7IHJldHVybiB0aGlzLmluZGV4OyB9XG4gICAgbmV4dCgpIHsgdGhpcy5pbmRleCAtPSA0OyB9XG4gICAgZm9yaygpIHsgcmV0dXJuIG5ldyBGbGF0QnVmZmVyQ3Vyc29yKHRoaXMuYnVmZmVyLCB0aGlzLmluZGV4KTsgfVxufVxuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbi8vLyBub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuLy8vIGJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KVxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgYnVmZmVyJ3MgY29udGVudC5cbiAgICBidWZmZXIsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCB0byAtIGZyb20sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIEJlZm9yZSAqLzogcmV0dXJuIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgLTEgLyogQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIEF0T3JBZnRlciAqLzogcmV0dXJuIGZyb20gPD0gcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDIgLyogQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIERvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgdHJ1ZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIF9mcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5fZnJvbSA9IF9mcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuX2Zyb207IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLl9mcm9tICsgdGhpcy5ub2RlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5ub2RlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuX2Zyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIDIgLyogTm9FbnRlckJ1ZmZlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgMSAvKiBGdWxsICovKSAmJiBuZXh0LnByb3BzICYmIChtb3VudGVkID0gbmV4dC5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBBZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyA9IHRydWUsIGJ1ZmZlcnMgPSB0cnVlKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAob3ZlcmxheXMgJiYgKG1vdW50ZWQgPSB0aGlzLm5vZGUucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBidWZmZXJzID8gMCA6IDIgLyogTm9FbnRlckJ1ZmZlciAqLyk7XG4gICAgfVxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh2YWwudHlwZS5pc0Fub255bW91cyAmJiB2YWwuX3BhcmVudClcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIDAsIDQgLyogRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykgeyByZXR1cm4gZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUodGhpcywgcG9zKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5ub2RlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IsIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cywgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFidWZmZXJzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgc2lkZSA+IDAgPyAxIDogLTEsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXSwgdG8gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG59XG4vLy8gQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG4vLy8gYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSwgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuYnVmZmVyLnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihpbmRleCk7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgLy8vIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IGVuZHMgYWZ0ZXIgYHBvc2AuXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBzdGFydHMgYmVmb3JlIGBwb3NgLlxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgLy8vIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgLy8vIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgLy8vIHNldCB0byBmYWxzZS5cbiAgICBlbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzID0gdHJ1ZSwgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyAmJiAhKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLyksIGJ1ZmZlcnMpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnMgPyB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmluZGV4IDwgMCA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQubm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUubm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDAsIGxvb2tBaGVhZCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgbGV0IGxvb2tBaGVhZEF0U3RhcnQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHdoaWxlIChzaXplIDwgMCkge1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzaXplID09IC0xIC8qIFJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIExvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgcmVjb3JkIHNpemU6ICR7c2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0KTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICBsZXQgbGFzdEdyb3VwID0gMCwgbGFzdEVuZCA9IGVuZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBjdXJzb3IuaWQgPT0gbG9jYWxJblJlcGVhdCAmJiBjdXJzb3Iuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZW5kIDw9IGxhc3RFbmQgLSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBjdXJzb3IuZW5kLCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSAwLCBsYXN0SSA9IGNoaWxkcmVuLmxlbmd0aCAtIDEsIGxhc3QsIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICBpZiAobGFzdEkgPj0gMCAmJiAobGFzdCA9IGNoaWxkcmVuW2xhc3RJXSkgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0SSAmJiBsYXN0LnR5cGUgPT0gdHlwZSAmJiBsYXN0Lmxlbmd0aCA9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsb29rQWhlYWRQcm9wID0gbGFzdC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHBvc2l0aW9uc1tsYXN0SV0gKyBsYXN0Lmxlbmd0aCArIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmVwZWF0TGVhZihjaGlsZHJlbiwgcG9zaXRpb25zLCBiYXNlLCBpLCBmcm9tLCB0bywgdHlwZSwgbG9va0FoZWFkKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkID0gMCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHRIYXNoKSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5jb250ZXh0SGFzaCwgY29udGV4dEhhc2hdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiAyNSkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AubG9va0FoZWFkLCBsb29rQWhlYWRdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1ZmZlclNpemUobWF4U2l6ZSwgaW5SZXBlYXQpIHtcbiAgICAgICAgLy8gU2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgdG8gZmluZCBwcmV2aW91cyBzaWJsaW5ncyB0aGF0IGZpdFxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGNhbid0IGJlIHN0b3JlZCBpbiBhIGJ1ZmZlcikuXG4gICAgICAgIC8vIElmIGBpblJlcGVhdGAgaXMgPiAtMSwgaWdub3JlIG5vZGUgYm91bmRhcmllcyBvZiB0aGF0IHR5cGUgZm9yXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIChgbWF4U2l6ZWApIG9yIGJlZm9yZSBzdWNoIGEgbm9kZS5cbiAgICAgICAgbGV0IGZvcmsgPSBjdXJzb3IuZm9yaygpO1xuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHNpemU6IDAsIHN0YXJ0OiAwLCBza2lwOiAwIH07XG4gICAgICAgIHNjYW46IGZvciAobGV0IG1pblBvcyA9IGZvcmsucG9zIC0gbWF4U2l6ZTsgZm9yay5wb3MgPiBtaW5Qb3M7KSB7XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemU7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIG5lc3RlZCByZXBlYXQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBkb24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKGZvcmsuaWQgPT0gaW5SZXBlYXQgJiYgbm9kZVNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgZGF0YS5idWZmZXJTdGFydCB8fCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5jb25zdCBub2RlU2l6ZUNhY2hlID0gbmV3IFdlYWtNYXA7XG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xuICAgIGlmICghYmFsYW5jZVR5cGUuaXNBbm9ueW1vdXMgfHwgbm9kZSBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgbm9kZS50eXBlICE9IGJhbGFuY2VUeXBlKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9IGJhbGFuY2VUeXBlIHx8ICEoY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVTaXplQ2FjaGUuc2V0KG5vZGUsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShcbi8vIFRoZSB0eXBlIHRoZSBiYWxhbmNlZCB0cmVlJ3MgaW5uZXIgbm9kZXMuXG5iYWxhbmNlVHlwZSwgXG4vLyBUaGUgZGlyZWN0IGNoaWxkcmVuIGFuZCB0aGVpciBwb3NpdGlvbnNcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxuLy8gVGhlIGluZGV4IHJhbmdlIGluIGNoaWxkcmVuL3Bvc2l0aW9ucyB0byB1c2VcbmZyb20sIHRvLCBcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cbnN0YXJ0LCBcbi8vIExlbmd0aCBvZiB0aGUgb3V0ZXIgbm9kZVxubGVuZ3RoLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSB0b3Agbm9kZSBvZiB0aGUgYmFsYW5jZWQgdHJlZVxubWtUb3AsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RyZWUpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgdG90YWwgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICBsZXQgbWF4Q2hpbGQgPSBNYXRoLmNlaWwoKHRvdGFsICogMS41KSAvIDggLyogQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuXG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxuLy8vIHBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xuLy8vIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbi8vLyB0byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbi8vLyBwYXJzZXMuIFVzZSB0aGUgc3RhdGljXG4vLy8gW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xuLy8vIHVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIC8vLyBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIC8vLyBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8vIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogU3RhcnQgKi8pID4gMDsgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgLy8vIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIEVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbi8vL1xuLy8vIFRoZSBuZXN0aW5nIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGN1cnNvciB0byBwcm92aWRlIGNvbnRleHQgZm9yIGFcbi8vLyBub2RlLCBidXQgX3Nob3VsZCBub3RfIG1vdmUgdGhhdCBjdXJzb3IsIG9ubHkgaW5zcGVjdCBpdHNcbi8vLyBwcm9wZXJ0aWVzIGFuZCBvcHRpb25hbGx5IGFjY2VzcyBpdHNcbi8vLyBbbm9kZSBvYmplY3RdKCNjb21tb24uVHJlZUN1cnNvci5ub2RlKS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCAxIC8qIEZ1bGwgKi8pO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgfHwgY3Vyc29yLmZyb20gPCB0aGlzLnN0b3BwZWRBdDspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50Q3Vyc29yLmhhc05vZGUoY3Vyc29yKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG92ZXJsYXkubW91bnRzLmZpbmQobSA9PiBtLmZyYWcuZnJvbSA8PSBjdXJzb3IuZnJvbSAmJiBtLmZyYWcudG8gPj0gY3Vyc29yLnRvICYmIG0ubW91bnQub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbWF0Y2gubW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gci5mcm9tICsgbWF0Y2gucG9zLCB0byA9IHIudG8gKyBtYXRjaC5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gY3Vyc29yLmZyb20gJiYgdG8gPD0gY3Vyc29yLnRvICYmICFvdmVybGF5LnJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDwgdG8gJiYgci50byA+IGZyb20pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3ZlcmVkICYmIChpc0NvdmVyZWQgPSBjaGVja0NvdmVyKGNvdmVyZWQucmFuZ2VzLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKSkpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGlzQ292ZXJlZCAhPSAyIC8qIEZ1bGwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLnR5cGUuaXNBbm9ueW1vdXMgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gJiYgKG5lc3QgPSB0aGlzLm5lc3QoY3Vyc29yLCB0aGlzLmlucHV0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRNb3VudHMgPSBmcmFnbWVudEN1cnNvci5maW5kTW91bnRzKGN1cnNvci5mcm9tLCBuZXN0LnBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0Lm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHwgW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIucHVzaChuZXcgSW5uZXJQYXJzZShuZXN0LnBhcnNlciwgbmVzdC5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvbGRNb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG5lc3Qub3ZlcmxheSA/IG5lc3Qub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gY3Vyc29yLmZyb20sIHIudG8gLSBjdXJzb3IuZnJvbSkpIDogbnVsbCwgY3Vyc29yLnRyZWUsIHJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkudGFyZ2V0LCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIEZ1bGwgKi8gOiAxIC8qIFBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV0sIHRvID0gYnVmLmJ1ZmZlcltlbmRJIC0gMl07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgd2hpbGUgKGJbaSArIDJdICsgb2ZmIDw9IG5vZGUuZnJvbSlcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgaSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xuICAgICAgICBsZXQgaXNUYXJnZXQgPSBmcm9tICsgb2ZmID09IG5vZGUuZnJvbSAmJiB0byArIG9mZiA9PSBub2RlLnRvICYmIGJbaV0gPT0gbm9kZS50eXBlLmlkO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGlzVGFyZ2V0ID8gbm9kZS50b1RyZWUoKSA6IHNwbGl0KGkgKyA0LCBiW2kgKyAzXSwgYnVmLnNldC50eXBlc1tiW2ldXSwgZnJvbSwgdG8gLSBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYltpICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcbiAgICAgICAgY3Vyc29yLmNoaWxkQWZ0ZXIobm9kZS5mcm9tKTtcbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmZ1bGxDdXJzb3IoKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBmYWxzZSwgZmFsc2UpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MsIGZyYWcudG8gPD0gZW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcywgZnJhZy50byA8PSBlbmRQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIiwiaW1wb3J0IHsgUGFyc2VyLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTm9kZVByb3AsIFRyZWUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLy8vIEEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xuLy8vIHBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xuLy8vIHRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG4vLy8gYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuY2xhc3MgU3RhY2sge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHBhcnNlIHRoYXQgdGhpcyBzdGFjayBpcyBwYXJ0IG9mIEBpbnRlcm5hbFxuICAgIHAsIFxuICAgIC8vLyBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGN1ckNvbnRleHQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBjdXJDb250ZXh0O1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICAvLy8gYW55LiBJdHMgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgY29udGV4dCB0cmFja2VyJ3MgdHlwZVxuICAgIC8vLyBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICAvLy8gdHJhY2tlci5cbiAgICBnZXQgY29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCA/IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0IDogbnVsbDsgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFja1tiYXNlIC0gMl07XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gdGhpcy5zdGFja1tiYXNlIC0gMV0sIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIFJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgaXNSZWR1Y2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIEVyciAqLykgeyAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBFcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICBpZiAobmV4dEVuZCA+IHRoaXMucG9zIHx8IG5leHQgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTa2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wLnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMucC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnAucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA9PSAtMSBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZXVzZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdmFsdWUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSB2YWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIERlbGV0ZSAqLztcbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIC8vLyBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICAvLy8gZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICAvLy8gZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24oc2ltLnN0YXRlLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIE1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIE1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBJbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgcmVkdWNlID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IHJlZHVjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICAvLy8gc29tZWhvdykuIEBpbnRlcm5hbFxuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIEVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLy8vIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICAvLy8gd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgLy8vIHN0YXRlKS4gQGludGVybmFsXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gZGlhbGVjdCAoYnkgbnVtZXJpYyBJRCwgYXMgZXhwb3J0ZWQgZnJvbVxuICAgIC8vLyB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIC0zKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVtaXRMb29rQWhlYWQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC00KVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmxvb2tBaGVhZCwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCAtNCk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCAhPSB0aGlzLmN1ckNvbnRleHQuY29udGV4dCkge1xuICAgICAgICAgICAgbGV0IG5ld0N4ID0gbmV3IFN0YWNrQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlciwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAobmV3Q3guaGFzaCAhPSB0aGlzLmN1ckNvbnRleHQuaGFzaClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBuZXdDeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkID4gdGhpcy5sb29rQWhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxudmFyIFJlY292ZXI7XG4oZnVuY3Rpb24gKFJlY292ZXIpIHtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJJbnNlcnRcIl0gPSAyMDBdID0gXCJJbnNlcnRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEZWxldGVcIl0gPSAxOTBdID0gXCJEZWxldGVcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJSZWR1Y2VcIl0gPSAxMDBdID0gXCJSZWR1Y2VcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhOZXh0XCJdID0gNF0gPSBcIk1heE5leHRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhJbnNlcnRTdGFja0RlcHRoXCJdID0gMzAwXSA9IFwiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIl0gPSAxMjBdID0gXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCI7XG59KShSZWNvdmVyIHx8IChSZWNvdmVyID0ge30pKTtcbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFydC5zdGFjaztcbiAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrLCBwb3MgPSBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBwb3MsIHBvcyAtIHN0YWNrLmJ1ZmZlckJhc2UpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG5jbGFzcyBDYWNoZWRUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICB0aGlzLmVuZCA9IC0xO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gMDtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gMDtcbiAgICB9XG59XG5jb25zdCBudWxsVG9rZW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4vLy8gW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbi8vLyB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlLiBJdCBwcmVzZW50cyB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2Zcbi8vLyBjaGFyYWN0ZXJzLCB0cmFja2luZyBsb29rYWhlYWQgYW5kIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZlxuLy8vIFtyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbmNsYXNzIElucHV0U3RyZWFtIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGlucHV0LCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIC8vLyBCYWNrdXAgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVuazIgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rMlBvcyA9IDA7XG4gICAgICAgIC8vLyBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5leHQgY29kZSB1bml0IGluIHRoZSBpbnB1dCwgb3IgLTFcbiAgICAgICAgLy8vIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8vLyBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgICAvLy8gYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIC8vLyBvbi5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IGxvb2tpbmcgYXJvdW5kIGR1cmluZyB0b2tlbml6aW5nIGNyZWF0ZXMgZGVwZW5kZW5jaWVzXG4gICAgLy8vIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgLy8vIGVmZmVjdGl2ZW5lc3MgaW5jcmVtZW50YWwgcGFyc2luZ+KAlHdoZW4gbG9va2luZyBmb3J3YXJk4oCUb3IgZXZlblxuICAgIC8vLyBjYXVzZSBpbnZhbGlkIHJlcGFyc2VzIHdoZW4gbG9va2luZyBiYWNrd2FyZCBtb3JlIHRoYW4gMjUgY29kZVxuICAgIC8vLyB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICBwZWVrKG9mZnNldCkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5jaHVua09mZiArIG9mZnNldCwgcG9zLCByZXN1bHQ7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZU9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcG9zID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdChwb3MgLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHRoaXMucmFuZ2VJbmRleCwgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS50byA8PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZXNbKytpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5jaHVuazJQb3MgPSBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0aGlzLmNodW5rMi5sZW5ndGggPiByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rMi5zbGljZSgwLCByYW5nZS50byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgICAvLy8gY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIC8vLyB0aGUgc3RyZWFtIHBvc2l0aW9uKSB0byBjaGFuZ2UgdGhhdC5cbiAgICBhY2NlcHRUb2tlbih0b2tlbiwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZW5kID0gZW5kT2Zmc2V0ID8gdGhpcy5yZXNvbHZlT2Zmc2V0KGVuZE9mZnNldCwgLTEpIDogdGhpcy5wb3M7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPCB0aGlzLnRva2VuLnN0YXJ0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUb2tlbiBlbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgZ2V0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiB0aGlzLnBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBjaHVuaywgY2h1bmtQb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gdGhpcy5jaHVuazI7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5jaHVuazJQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSBjaHVua1BvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSB0aGlzLnBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICBsZXQgbmV4dENodW5rID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLnBvcyk7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgKyBuZXh0Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IGVuZCA+IHRoaXMucmFuZ2UudG8gPyBuZXh0Q2h1bmsuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IG5leHRDaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua09mZiA+PSB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgLy8vIHRoZSBuZXcgdmFsdWUgb2YgW2BuZXh0YF0oI2xyLklucHV0U3RyZWFtLm5leHQpLlxuICAgIGFkdmFuY2UobiA9IDEpIHtcbiAgICAgICAgdGhpcy5jaHVua09mZiArPSBuO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgKyBuID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlSW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICBuIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmFuZ2UuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgc2V0RG9uZSgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlc2V0KHBvcywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0b2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIHRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMucmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbLS10aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA+PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmtQb3MgJiYgcG9zIDwgdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEBpbnRlcm5hbFxuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHsgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCB0aGlzLmlkKTsgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vLy8gYEBleHRlcm5hbCB0b2tlbnNgIGRlY2xhcmF0aW9ucyBpbiB0aGUgZ3JhbW1hciBzaG91bGQgcmVzb2x2ZSB0b1xuLy8vIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBFeHRlcm5hbFRva2VuaXplciB7XG4gICAgLy8vIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIC8vLyBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgLy8vIHJlY29nbml6ZXMgYXQgdGhlIHN0cmVhbSdzIHBvc2l0aW9uLCBhbmQgY2FsbHNcbiAgICAvLy8gW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICAgIC8vLyBvbmUuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGB0b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRpYWxlY3QgfSA9IHBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fCBwYXJzZXIub3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAobGV0IG5leHQgPSBpbnB1dC5uZXh0LCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRklYTUUgZmluZCBzb21lIHdheSB0byByZWR1Y2UgcmVjb3Zlcnkgd29yayBkb25lIHdoZW4gdGhlIGlucHV0XG4vLyBkb2Vzbid0IG1hdGNoIHRoZSBncmFtbWFyIGF0IGFsbC5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xudmFyIFNhZmV0eTtcbihmdW5jdGlvbiAoU2FmZXR5KSB7XG4gICAgU2FmZXR5W1NhZmV0eVtcIk1hcmdpblwiXSA9IDI1XSA9IFwiTWFyZ2luXCI7XG59KShTYWZldHkgfHwgKFNhZmV0eSA9IHt9KSk7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5mdWxsQ3Vyc29yKCk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIE1hcmdpbiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRyZWUubGVuZ3RoLCBNYXRoLm1heChjdXJzb3IuZnJvbSArIDEsIHBvcyArIDI1IC8qIE1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cywgbm9kZVNldCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCB0aGlzLnNhZmVGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kIDw9IHRoaXMuc2FmZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gbmV4dC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb2tBaGVhZCB8fCBlbmQgKyBsb29rQWhlYWQgPCB0aGlzLmZyYWdtZW50LnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBuZXh0Lmxlbmd0aCA+PSBNYXRoLm1heCh0aGlzLnNhZmVGcm9tLCBwb3MpKSB7IC8vIEVudGVyIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVG9rZW5DYWNoZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zID0gcGFyc2VyLnRva2VuaXplcnMubWFwKF8gPT4gbmV3IENhY2hlZFRva2VuKTtcbiAgICB9XG4gICAgZ2V0QWN0aW9ucyhzdGFjaykge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBUb2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFjay5jdXJDb250ZXh0ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzayB8fCB0b2tlbi5jb250ZXh0ICE9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5sb29rQWhlYWQgPiB0b2tlbi5lbmQgKyAyNSAvKiBNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gTWF0aC5tYXgodG9rZW4ubG9va0FoZWFkLCBsb29rQWhlYWQpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlICE9IDAgLyogRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKGxvb2tBaGVhZClcbiAgICAgICAgICAgIHN0YWNrLnNldExvb2tBaGVhZChsb29rQWhlYWQpO1xuICAgICAgICBpZiAoIW1haW4gJiYgc3RhY2sucG9zID09IHRoaXMuc3RyZWFtLmVuZCkge1xuICAgICAgICAgICAgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbjtcbiAgICAgICAgICAgIG1haW4udmFsdWUgPSBzdGFjay5wLnBhcnNlci5lb2ZUZXJtO1xuICAgICAgICAgICAgbWFpbi5zdGFydCA9IG1haW4uZW5kID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIG1haW4udmFsdWUsIG1haW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICBnZXRNYWluVG9rZW4oc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWFpblRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpblRva2VuO1xuICAgICAgICBsZXQgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbiwgeyBwb3MsIHAgfSA9IHN0YWNrO1xuICAgICAgICBtYWluLnN0YXJ0ID0gcG9zO1xuICAgICAgICBtYWluLmVuZCA9IE1hdGgubWluKHBvcyArIDEsIHAuc3RyZWFtLmVuZCk7XG4gICAgICAgIG1haW4udmFsdWUgPSBwb3MgPT0gcC5zdHJlYW0uZW5kID8gcC5wYXJzZXIuZW9mVGVybSA6IDAgLyogRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKHRoaXMuc3RyZWFtLnJlc2V0KHN0YWNrLnBvcywgdG9rZW4pLCBzdGFjayk7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKHRoaXMuc3RyZWFtLnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgdG9rZW4uZW5kID0gTWF0aC5taW4oc3RhY2sucC5zdHJlYW0uZW5kLCBzdGFjay5wb3MgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkYXRhIH0gPSBwYXJzZXI7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMCAmJiBkYXRhW2kgKyAxXSA9PSAyIC8qIE90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMiksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbnZhciBSZWM7XG4oZnVuY3Rpb24gKFJlYykge1xuICAgIFJlY1tSZWNbXCJEaXN0YW5jZVwiXSA9IDVdID0gXCJEaXN0YW5jZVwiO1xuICAgIFJlY1tSZWNbXCJNYXhSZW1haW5pbmdQZXJTdGVwXCJdID0gM10gPSBcIk1heFJlbWFpbmluZ1BlclN0ZXBcIjtcbiAgICAvLyBXaGVuIHR3byBzdGFja3MgaGF2ZSBiZWVuIHJ1bm5pbmcgaW5kZXBlbmRlbnRseSBsb25nIGVub3VnaCB0b1xuICAgIC8vIGFkZCB0aGlzIG1hbnkgZWxlbWVudHMgdG8gdGhlaXIgYnVmZmVycywgcHJ1bmUgb25lLlxuICAgIFJlY1tSZWNbXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiXSA9IDUwMF0gPSBcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCI7XG4gICAgUmVjW1JlY1tcIkZvcmNlUmVkdWNlTGltaXRcIl0gPSAxMF0gPSBcIkZvcmNlUmVkdWNlTGltaXRcIjtcbiAgICAvLyBPbmNlIGEgc3RhY2sgcmVhY2hlcyB0aGlzIGRlcHRoIChpbiAuc3RhY2subGVuZ3RoKSBmb3JjZS1yZWR1Y2VcbiAgICAvLyBpdCBiYWNrIHRvIEN1dFRvIHRvIGF2b2lkIGNyZWF0aW5nIHRyZWVzIHRoYXQgb3ZlcmZsb3cgdGhlIHN0YWNrXG4gICAgLy8gb24gcmVjdXJzaXZlIHRyYXZlcnNhbC5cbiAgICBSZWNbUmVjW1wiQ3V0RGVwdGhcIl0gPSAxNTAwMF0gPSBcIkN1dERlcHRoXCI7XG4gICAgUmVjW1JlY1tcIkN1dFRvXCJdID0gOTAwMF0gPSBcIkN1dFRvXCI7XG59KShSZWMgfHwgKFJlYyA9IHt9KSk7XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFN0YWNrSUQgPSAweDI2NTQ7IC8vIOKZlCwg4pmVLCDimZYsIOKZlywg4pmYLCDimZksIOKZoCwg4pmhLCDimaIsIOKZoywg4pmkLCDimaUsIOKZpiwg4pmnXG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSAwO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBuZXdTdGFja3MsIHN0YWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbnMuZ2V0TWFpblRva2VuKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlICYmIHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3R1Y2sgd2l0aCB0b2tlbiBcIiArICh0aGlzLnRva2Vucy5tYWluVG9rZW4gPyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkgOiBcIm5vbmVcIikpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gNTAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLm1pblN0YWNrUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0YXJ0ID4gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suZm9yY2VSZWR1Y2UoKSA/IHN0YWNrIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RyaWN0Q3ggPSBzdGFjay5jdXJDb250ZXh0ICYmIHN0YWNrLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QsIGN4SGFzaCA9IHN0cmljdEN4ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNhY2hlZCA9IHRoaXMuZnJhZ21lbnRzLm5vZGVBdChzdGFydCk7IGNhY2hlZDspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2NhY2hlZC50eXBlLmlkXSA9PSBjYWNoZWQudHlwZSA/IHBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBjYWNoZWQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjYWNoZWQubGVuZ3RoICYmICghc3RyaWN0Q3ggfHwgKGNhY2hlZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgVHJlZSAmJiBjYWNoZWQucG9zaXRpb25zWzBdID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suc3RhY2subGVuZ3RoID49IDE1MDAwIC8qIEN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gOTAwMCAvKiBDdXRUbyAqLyAmJiBzdGFjay5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2spO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogRm9yY2VSZWR1Y2VMaW1pdCAqLzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5lbmQgPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBFcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2spIHtcbiAgICAgICAgc3RhY2suY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8vLyBDb250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbi8vLyBpbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG4vLy8gZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuLy8vIGdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuLy8vXG4vLy8gQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbi8vLyBvbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cbi8vL1xuLy8vIFRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbi8vLyB0eXBlLlxuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8vLyBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vLy8gQSBwYXJzZXIgaG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWRcbi8vLyBieSBgbGV6ZXItZ2VuZXJhdG9yYC5cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxMyAvKiBWZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezEzIC8qIFZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgbm9kZU5hbWVzID0gc3BlYy5ub2RlTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLm1pblJlcGVhdFRlcm0gPSBub2RlTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMucmVwZWF0Tm9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICBub2RlTmFtZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkoc3BlYy5zcGVjaWFsaXplZCA/IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnNwZWNpYWxpemVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0udGVybTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVyc1tpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0uZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gcGFpcih0aGlzLmRhdGEsIGkgKyAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIC8vLyBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBSZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG92ZXJyaWRlcyh0b2tlbiwgcHJldikge1xuICAgICAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgcHJldik7XG4gICAgICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHRva2VuKSA8IGlQcmV2O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICAvLy8gd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgLy8vIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICAvLy8gc3RvcmVkLlxuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLy8vIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgLy8vIHR5cGVzLiBAaW50ZXJuYWxcbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvLy8gVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICBnZXQgdG9wTm9kZSgpIHsgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8vLyAodXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yKSBAaW50ZXJuYWxcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExSUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gc3RhY2sucC5zdG9wcGVkQXQ7XG4gICAgICAgIGlmICgoc3RhY2sucG9zID09IHN0YWNrLnAuc3RyZWFtLmVuZCB8fCBzdG9wcGVkICE9IG51bGwgJiYgc3RhY2sucG9zID4gc3RvcHBlZCkgJiZcbiAgICAgICAgICAgIHN0YWNrLnAucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBTdGFjayB9O1xuIl0sIm5hbWVzIjpbIkxva2lBbm5vdGF0aW9uc1F1ZXJ5Q3RybCIsImNvbnN0cnVjdG9yIiwiJHNjb3BlIiwiYW5ub3RhdGlvbiIsImN0cmwiLCJ0YXJnZXQiLCJvblF1ZXJ5Q2hhbmdlIiwiYmluZCIsInF1ZXJ5IiwiZXhwciIsIm1heExpbmVzIiwiaW5zdGFudCIsImNoYWluIiwiaXNFcXVhbCIsIkxPS0lfS0VZV09SRFMiLCJQUk9NX0tFWVdPUkRTIiwiT1BFUkFUT1JTIiwiTE9HSUNBTF9PUEVSQVRPUlMiLCJidWlsdEluV29yZHMiLCJtZXRyaWNzQW5kS2V5d29yZHNSZWdleHAiLCJhZGRMYWJlbFRvUXVlcnkiLCJrZXkiLCJ2YWx1ZSIsIm9wZXJhdG9yIiwiaGFzTm9NZXRyaWNzIiwiRXJyb3IiLCJ0cmFuc2Zvcm1lZFZhbHVlIiwiSW5maW5pdHkiLCJ0b1N0cmluZyIsInByZXZpb3VzV29yZCIsInJlcGxhY2UiLCJtYXRjaCIsIndvcmQiLCJvZmZzZXQiLCJpc01ldHJpYyIsImlzV29yZE1ldHJpYyIsInNlbGVjdG9yUmVnZXhwIiwicGFydHMiLCJsYXN0SW5kZXgiLCJzdWZmaXgiLCJleGVjIiwicHJlZml4Iiwic2xpY2UiLCJpbmRleCIsImxlbmd0aCIsInN0YXJ0c1dpdGgiLCJwdXNoIiwic2VsZWN0b3IiLCJzZWxlY3RvcldpdGhMYWJlbCIsImFkZExhYmVsVG9TZWxlY3RvciIsImpvaW4iLCJsYWJlbFJlZ2V4cCIsImxhYmVsS2V5IiwibGFiZWxWYWx1ZSIsImxhYmVsT3BlcmF0b3IiLCJwYXJzZWRMYWJlbHMiLCJvcGVyYXRvckZvckxhYmVsS2V5IiwiZm9ybWF0dGVkIiwidW5pcVdpdGgiLCJjb21wYWN0Iiwic29ydEJ5IiwibWFwIiwiaXNQb3NpdGlvbkluc2lkZUNoYXJzIiwidGV4dCIsInBvc2l0aW9uIiwib3BlbkNoYXIiLCJjbG9zZUNoYXIiLCJuZXh0U2VsZWN0b3JTdGFydCIsImluZGV4T2YiLCJuZXh0U2VsZWN0b3JFbmQiLCJpbnNpZGVTZWxlY3RvciIsInByZXZpb3VzV29yZElzS2V5V29yZCIsImlzQ29sb25Cb3VuZGVkIiwiZW5kc1dpdGgiLCJzdGFydHNXaXRoUXVvdGUiLCJpc1RlbXBsYXRlVmFyaWFibGUiLCJpc1RpbWVVbml0IiwiaW5jbHVkZXMiLCJCb29sZWFuIiwiTnVtYmVyIiwiaXNEYXRhRnJhbWUiLCJGaWVsZFR5cGUiLCJMb2tpUXVlcnlUeXBlIiwibWFrZVRhYmxlRnJhbWVzIiwiZm9ybWF0UXVlcnkiLCJnZXRIaWdobGlnaHRlckV4cHJlc3Npb25zRnJvbVF1ZXJ5IiwibWFrZUlkRmllbGQiLCJpc01ldHJpY0ZyYW1lIiwiZnJhbWUiLCJmaWVsZHMiLCJldmVyeSIsImZpZWxkIiwidHlwZSIsInRpbWUiLCJudW1iZXIiLCJzZXRGcmFtZU1ldGEiLCJtZXRhIiwib2xkTWV0YSIsInJlc3QiLCJuZXdNZXRhIiwicHJvY2Vzc1N0cmVhbUZyYW1lIiwicHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGUiLCJzZWFyY2hXb3JkcyIsInVuZGVmaW5lZCIsImN1c3RvbSIsImxva2lRdWVyeVN0YXRLZXkiLCJuZXdGcmFtZSIsIm5ld0ZpZWxkcyIsIm5hbWUiLCJwcm9jZXNzU3RyZWFtc0ZyYW1lcyIsImZyYW1lcyIsInF1ZXJ5TWFwIiwicmVmSWQiLCJnZXQiLCJwcm9jZXNzTWV0cmljSW5zdGFudEZyYW1lcyIsInByb2Nlc3NNZXRyaWNSYW5nZUZyYW1lcyIsImdyb3VwRnJhbWVzIiwic3RyZWFtc0ZyYW1lcyIsIm1ldHJpY0luc3RhbnRGcmFtZXMiLCJtZXRyaWNSYW5nZUZyYW1lcyIsImZvckVhY2giLCJpc0luc3RhbnRGcmFtZSIsInF1ZXJ5VHlwZSIsIkluc3RhbnQiLCJ0cmFuc2Zvcm1CYWNrZW5kUmVzdWx0IiwicmVzcG9uc2UiLCJyZXF1ZXN0IiwiZGF0YSIsImRhdGFGcmFtZXMiLCJkIiwiTWFwIiwidGFyZ2V0cyIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsInNodWZmbGUiLCJERUZBVUxUX0VYQU1QTEVTIiwiUFJFRkVSUkVEX0xBQkVMUyIsIkVYQU1QTEVTX0xJTUlUIiwiTE9HUUxfRVhBTVBMRVMiLCJ0aXRsZSIsImV4cHJlc3Npb24iLCJsYWJlbCIsIkxva2lDaGVhdFNoZWV0IiwidXNlckV4YW1wbGVzIiwicHJvdmlkZXIiLCJwcm9wcyIsImRhdGFzb3VyY2UiLCJsYW5ndWFnZVByb3ZpZGVyIiwic3RhcnRlZCIsImxhYmVscyIsImdldExhYmVsS2V5cyIsInByZWZlcnJlZExhYmVsIiwiZmluZCIsImwiLCJ2YWx1ZXMiLCJnZXRMYWJlbFZhbHVlcyIsInNldFN0YXRlIiwic2NoZWR1bGVVc2VyTGFiZWxDaGVja2luZyIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJjbGVhclRpbWVvdXQiLCJ1c2VyTGFiZWxUaW1lciIsInNldFRpbWVvdXQiLCJjaGVja1VzZXJMYWJlbHMiLCJyZW5kZXJFeHByZXNzaW9uIiwib25DbGlja0V4YW1wbGUiLCJlIiwicmVuZGVyIiwic3RhdGUiLCJoYXNVc2VyRXhhbXBsZXMiLCJleGFtcGxlIiwiaXRlbSIsIm1lbW8iLCJMb2tpUXVlcnlGaWVsZCIsIkxva2lPcHRpb25GaWVsZHMiLCJMb2tpRXhwbG9yZVF1ZXJ5RWRpdG9yIiwiaGlzdG9yeSIsIm9uQ2hhbmdlIiwib25SdW5RdWVyeSIsInJhbmdlIiwidGVzdElkcyIsImVkaXRvciIsInJlc29sdXRpb24iLCJkaXNwbGF5TmFtZSIsIkJ1dHRvbiIsIkhvcml6b250YWxHcm91cCIsIklucHV0IiwiTGFiZWwiLCJMb2FkaW5nUGxhY2Vob2xkZXIiLCJ3aXRoVGhlbWUyIiwiQnJvd3NlckxhYmVsIiwiTG9raUxhYmVsIiwiZnV6enlNYXRjaCIsImNzcyIsImN4IiwiRml4ZWRTaXplTGlzdCIsIk1BWF9MQUJFTF9DT1VOVCIsIk1BWF9WQUxVRV9DT1VOVCIsIk1BWF9BVVRPX1NFTEVDVCIsIkVNUFRZX1NFTEVDVE9SIiwiYnVpbGRTZWxlY3RvciIsInNlbGVjdGVkTGFiZWxzIiwic2VsZWN0ZWQiLCJzZWxlY3RlZFZhbHVlcyIsImZpbHRlciIsImZhY2V0TGFiZWxzIiwicG9zc2libGVMYWJlbHMiLCJsYXN0RmFjZXR0ZWQiLCJwb3NzaWJsZVZhbHVlcyIsImV4aXN0aW5nVmFsdWVzIiwiU2V0IiwiaGFzIiwibG9hZGluZyIsImZhY2V0cyIsImhpZGRlbiIsImdldFN0eWxlcyIsInRoZW1lIiwid3JhcHBlciIsImNvbG9ycyIsImJhY2tncm91bmQiLCJzZWNvbmRhcnkiLCJzcGFjaW5nIiwibGlzdCIsInNlY3Rpb24iLCJ0eXBvZ3JhcGh5IiwiZm9udEZhbWlseU1vbm9zcGFjZSIsInN0YXR1cyIsInN0YXR1c1Nob3dpbmciLCJlcnJvciIsIm1haW4iLCJ2YWx1ZUxpc3QiLCJ2YWx1ZUxpc3RXcmFwcGVyIiwiYm9yZGVyIiwibWVkaXVtIiwidmFsdWVMaXN0QXJlYSIsInZhbHVlVGl0bGUiLCJ2YWxpZGF0aW9uU3RhdHVzIiwibWF4Q29udHJhc3QiLCJVbnRoZW1lZExva2lMYWJlbEJyb3dzZXIiLCJDb21wb25lbnQiLCJzZWFyY2hUZXJtIiwiZXZlbnQiLCJkZWxldGVMYXN0VXNlZExhYmVscyIsIm5leHRWYWx1ZSIsInVwZGF0ZUxhYmVsU3RhdGUiLCJkb0ZhY2V0dGluZ0ZvckxhYmVsIiwidiIsImRvRmFjZXR0aW5nIiwidmFsaWRhdGVTZWxlY3RvciIsImZldGNoVmFsdWVzIiwiZmV0Y2hTZXJpZXMiLCJ1cGRhdGVkRmllbGRzIiwiY2IiLCJhdXRvU2VsZWN0IiwibGFzdFVzZWRMYWJlbHMiLCJzdGFydCIsInRoZW4iLCJyYXdMYWJlbHMiLCJpIiwiYXJyIiwic3RvcmVMYXN0VXNlZExhYmVscyIsInJhd1ZhbHVlcyIsImNvbnNvbGUiLCJmZXRjaFNlcmllc0xhYmVscyIsIk9iamVjdCIsImtleXMiLCJzdHJlYW1zIiwic3R5bGVzIiwiZW1wdHkiLCJzZWFyY2hSZXN1bHRzIiwiaGlnaGxpZ2h0UGFydHMiLCJmdXp6eU1hdGNoUmVzdWx0IiwidG9Mb3dlckNhc2UiLCJmb3VuZCIsInJhbmdlcyIsIm9yZGVyIiwiZGlzdGFuY2UiLCJvbkNsaWNrTGFiZWwiLCJvbkNoYW5nZVNlYXJjaCIsInN0eWxlIiwib25DbGlja1ZhbHVlIiwib25DbGlja1J1bkxvZ3NRdWVyeSIsIm9uQ2xpY2tSdW5NZXRyaWNzUXVlcnkiLCJvbkNsaWNrVmFsaWRhdGUiLCJvbkNsaWNrQ2xlYXIiLCJMb2tpTGFiZWxCcm93c2VyIiwiSW5saW5lRm9ybUxhYmVsIiwiUmFkaW9CdXR0b25Hcm91cCIsIklubGluZUZpZWxkIiwiU2VsZWN0IiwiY29uZmlnIiwicXVlcnlUeXBlT3B0aW9ucyIsIlJhbmdlIiwiZGVzY3JpcHRpb24iLCJmZWF0dXJlVG9nZ2xlcyIsImxva2lMaXZlIiwiU3RyZWFtIiwiREVGQVVMVF9SRVNPTFVUSU9OIiwiUkVTT0xVVElPTl9PUFRJT05TIiwiY29uY2F0IiwibGluZUxpbWl0VmFsdWUiLCJydW5PbkJsdXIiLCJvbkNoYW5nZVF1ZXJ5TGltaXQiLCJuZXh0UXVlcnkiLCJwcmVwcm9jZXNzTWF4TGluZXMiLCJvblF1ZXJ5VHlwZUNoYW5nZSIsIm9uTWF4TGluZXNDaGFuZ2UiLCJjdXJyZW50VGFyZ2V0Iiwib25SZXR1cm5LZXlEb3duIiwib25SZXNvbHV0aW9uQ2hhbmdlIiwib3B0aW9uIiwiTmFOIiwiaXNOYU4iLCJMb2tpUXVlcnlFZGl0b3IiLCJvbkxlZ2VuZENoYW5nZSIsImxlZ2VuZEZvcm1hdCIsImxlZ2VuZEZpZWxkIiwiQ29yZUFwcCIsIkxva2lRdWVyeUVkaXRvckZvckFsZXJ0aW5nIiwiTG9raVF1ZXJ5RWRpdG9yU2VsZWN0b3IiLCJMb2tpUXVlcnlFZGl0b3JCeUFwcCIsImFwcCIsIkNsb3VkQWxlcnRpbmciLCJFeHBsb3JlIiwibG9raVF1ZXJ5QnVpbGRlciIsIlNsYXRlUHJpc20iLCJRdWVyeUZpZWxkIiwiQnJhY2VzUGx1Z2luIiwiRE9NVXRpbCIsIkljb24iLCJsYW5ndWFnZXMiLCJwcmlzbUxhbmd1YWdlcyIsInNob3VsZFJlZnJlc2hMYWJlbHMiLCJMb2NhbFN0b3JhZ2VWYWx1ZVByb3ZpZGVyIiwiTEFTVF9VU0VEX0xBQkVMU19LRVkiLCJnZXRDaG9vc2VyVGV4dCIsImhhc1N5bnRheCIsImhhc0xvZ0xhYmVscyIsIndpbGxBcHBseVN1Z2dlc3Rpb24iLCJzdWdnZXN0aW9uIiwidHlwZWFoZWFkQ29udGV4dCIsInR5cGVhaGVhZFRleHQiLCJuZXh0Q2hhciIsImdldE5leHRDaGFyYWN0ZXIiLCJvbkNoYW5nZVF1ZXJ5IiwibGFiZWxCcm93c2VyVmlzaWJsZSIsIm92ZXJyaWRlIiwidHlwZWFoZWFkIiwic3VnZ2VzdGlvbnMiLCJsb2tpTGFuZ3VhZ2VQcm92aWRlciIsIndyYXBwZXJDbGFzc2VzIiwicmVzdWx0IiwicHJvdmlkZUNvbXBsZXRpb25JdGVtcyIsImxhYmVsc0xvYWRlZCIsInBsdWdpbnMiLCJvbmx5SW4iLCJub2RlIiwib2JqZWN0IiwiZ2V0U3ludGF4IiwibG9ncWwiLCJfaXNNb3VudGVkIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicmVmcmVzaExhYmVscyIsImZldGNoTGFiZWxzIiwiRXh0cmFGaWVsZEVsZW1lbnQiLCJwbGFjZWhvbGRlciIsImNsZWFuVGV4dCIsImNob29zZXJUZXh0IiwiYnV0dG9uRGlzYWJsZWQiLCJvbkxhc3RVc2VkTGFiZWxzU2F2ZSIsIm9uTGFzdFVzZWRMYWJlbHNEZWxldGUiLCJvbkNsaWNrQ2hvb3NlckJ1dHRvbiIsIm9uVHlwZWFoZWFkIiwib25CbHVyIiwib25DaGFuZ2VMYWJlbEJyb3dzZXIiLCJBbGVydGluZ1NldHRpbmdzIiwiRGF0YVNvdXJjZUh0dHBTZXR0aW5ncyIsIk1heExpbmVzRmllbGQiLCJEZXJpdmVkRmllbGRzIiwiZ2V0QWxsQWxlcnRtYW5hZ2VyRGF0YVNvdXJjZXMiLCJtYWtlSnNvblVwZGF0ZXIiLCJvcHRpb25zIiwianNvbkRhdGEiLCJzZXRNYXhMaW5lcyIsInNldERlcml2ZWRGaWVsZHMiLCJDb25maWdFZGl0b3IiLCJvbk9wdGlvbnNDaGFuZ2UiLCJhbGVydG1hbmFnZXJzIiwiZGVyaXZlZEZpZWxkcyIsInVzZVN0YXRlIiwiTGVnYWN5Rm9ybXMiLCJGb3JtRmllbGQiLCJBcnJheVZlY3RvciIsImdldEZpZWxkTGlua3NGb3JFeHBsb3JlIiwiRGVidWdTZWN0aW9uIiwiY2xhc3NOYW1lIiwiZGVidWdUZXh0Iiwic2V0RGVidWdUZXh0IiwiZGVidWdGaWVsZHMiLCJtYWtlRGVidWdGaWVsZHMiLCJEZWJ1Z0ZpZWxkcyIsIm1lc3NhZ2UiLCJocmVmIiwibWF0Y2hlclJlZ2V4IiwidGVzdE1hdGNoIiwibGluayIsInVybCIsInN0cmluZyIsImxpbmtzIiwicm93SW5kZXgiLCJ1c2VFZmZlY3QiLCJEYXRhTGlua0lucHV0Iiwic3R5bGVzRmFjdG9yeSIsIkRhdGFTb3VyY2VQaWNrZXIiLCJ1c2VQcmV2aW91cyIsIlN3aXRjaCIsInJvdyIsIm5hbWVGaWVsZCIsInJlZ2V4RmllbGQiLCJ1cmxGaWVsZCIsInVybERpc3BsYXlMYWJlbEZpZWxkIiwiRGVyaXZlZEZpZWxkIiwib25EZWxldGUiLCJzaG93SW50ZXJuYWxMaW5rIiwic2V0U2hvd0ludGVybmFsTGluayIsImRhdGFzb3VyY2VVaWQiLCJwcmV2aW91c1VpZCIsImhhbmRsZUNoYW5nZSIsInByZXZlbnREZWZhdWx0IiwibmV3VmFsdWUiLCJ1cmxEaXNwbGF5TGFiZWwiLCJkcyIsInVpZCIsInVzZVRoZW1lMiIsIlZhcmlhYmxlT3JpZ2luIiwiRGF0YUxpbmtCdWlsdEluVmFycyIsImluZm9UZXh0IiwiZGVyaXZlZEZpZWxkIiwic2hvd0RlYnVnIiwic2V0U2hvd0RlYnVnIiwibmV3RmllbGQiLCJuZXdEZXJpdmVkRmllbGRzIiwic3BsaWNlIiwidmFsdWVSYXciLCJkb2N1bWVudGF0aW9uIiwib3JpZ2luIiwiVmFsdWUiLCJjbG9uZURlZXAiLCJpc0VtcHR5IiwibG9kYXNoTWFwIiwibGFzdFZhbHVlRnJvbSIsIm1lcmdlIiwib2YiLCJ0aHJvd0Vycm9yIiwiY2F0Y2hFcnJvciIsInN3aXRjaE1hcCIsIlByaXNtIiwiRGF0YUZyYW1lVmlldyIsImRhdGVNYXRoIiwiRmllbGRDYWNoZSIsImdldExvZ0xldmVsRnJvbUtleSIsIkxvYWRpbmdTdGF0ZSIsIkxvZ0xldmVsIiwiZ2V0QmFja2VuZFNydiIsIkRhdGFTb3VyY2VXaXRoQmFja2VuZCIsImdldFRlbXBsYXRlU3J2IiwiZ2V0VGltZVNydiIsImNvbnZlcnRUb1dlYlNvY2tldFVybCIsImxva2lSZXN1bHRzVG9UYWJsZU1vZGVsIiwibG9raVN0cmVhbVJlc3VsdFRvRGF0YUZyYW1lIiwibG9raVN0cmVhbXNUb0RhdGFGcmFtZXMiLCJwcm9jZXNzUmFuZ2VRdWVyeVJlc3BvbnNlIiwiYWRkUGFyc2VkTGFiZWxUb1F1ZXJ5IiwiZ2V0Tm9ybWFsaXplZExva2lRdWVyeSIsInF1ZXJ5SGFzUGlwZVBhcnNlciIsIkxva2lSZXN1bHRUeXBlIiwiTGl2ZVN0cmVhbXMiLCJMYW5ndWFnZVByb3ZpZGVyIiwic2VyaWFsaXplUGFyYW1zIiwic3ludGF4IiwicXVlcnlMb2dzVm9sdW1lIiwiZG9Mb2tpQ2hhbm5lbFN0cmVhbSIsInJlbmRlckxlZ2VuZEZvcm1hdCIsIkRFRkFVTFRfTUFYX0xJTkVTIiwiTE9LSV9FTkRQT0lOVCIsIk5TX0lOX01TIiwiUkFOR0VfUVVFUllfRU5EUE9JTlQiLCJJTlNUQU5UX1FVRVJZX0VORFBPSU5UIiwiREVGQVVMVF9RVUVSWV9QQVJBTVMiLCJkaXJlY3Rpb24iLCJsaW1pdCIsIkxva2lEYXRhc291cmNlIiwiaW5zdGFuY2VTZXR0aW5ncyIsInRlbXBsYXRlU3J2IiwidGltZVNydiIsInJlc3BvbnNlTGlzdExlbmd0aCIsInRpbWVOcyIsImdldFRpbWUiLCJ0byIsInF1ZXJ5TGltaXQiLCJpc01ldHJpY3NRdWVyeSIsIm1heERhdGFQb2ludHMiLCJNYXRoIiwibWluIiwiX3JlcXVlc3QiLCJwaXBlIiwicmVzdWx0VHlwZSIsImVyciIsInByb2Nlc3NFcnJvciIsImxpdmVTdHJlYW1pbmciLCJydW5MaXZlUXVlcnkiLCJjcmVhdGVSYW5nZVF1ZXJ5IiwiaGVhZGVycyIsInZvbHVtZVF1ZXJ5Iiwic2NvcGVkVmFycyIsInJldmVyc2UiLCJsaXZlVGFyZ2V0IiwiY3JlYXRlTGl2ZVRhcmdldCIsImdldFN0cmVhbSIsIlN0cmVhbWluZyIsInJlYXNvbiIsInByZXBhcmVMb2dSb3dDb250ZXh0UXVlcnlUYXJnZXQiLCJzdGF0dXNUZXh0IiwicmVzIiwic3RyZWFtIiwiY29udGV4dFRpbWVCdWZmZXIiLCJjb21tb25UYXJnZXRPcHRpb25zIiwiZmllbGRDYWNoZSIsImRhdGFGcmFtZSIsIm5zRmllbGQiLCJnZXRGaWVsZEJ5TmFtZSIsIm5zVGltZXN0YW1wIiwidGltZUVwb2NoTXMiLCJlbmQiLCJzZXR0aW5nc0RhdGEiLCJwYXJzZUludCIsImFwaVVybCIsImJhc2VVcmwiLCJwYXJhbXMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJiYXNpY0F1dGgiLCJBdXRob3JpemF0aW9uIiwicmVxIiwiZmV0Y2giLCJnZXRMb2dzVm9sdW1lRGF0YVByb3ZpZGVyIiwiaXNMb2dzVm9sdW1lQXZhaWxhYmxlIiwic29tZSIsImxvZ3NWb2x1bWVSZXF1ZXN0IiwiZXh0cmFjdExldmVsIiwic3ViUXVlcmllcyIsImdldFJhbmdlU2NvcGVkVmFycyIsInNob3VsZFJ1bkJhY2tlbmRRdWVyeSIsImxva2lCYWNrZW5kTW9kZSIsImZpeGVkUmVxdWVzdCIsImZpbHRlcmVkVGFyZ2V0cyIsImhpZGUiLCJhZGRBZEhvY0ZpbHRlcnMiLCJpbnRlcnBvbGF0ZVF1ZXJ5RXhwciIsInJ1bkluc3RhbnRRdWVyeSIsInJhbmdlUmF3IiwicnVuUmFuZ2VRdWVyeSIsIkRvbmUiLCJzdGFydE5zIiwiZnJvbSIsImVuZE5zIiwicmFuZ2VNcyIsImNlaWwiLCJhZGp1c3RlZEludGVydmFsIiwiYWRqdXN0SW50ZXJ2YWwiLCJpbnRlcnZhbE1zIiwic3RlcCIsInNpemUiLCJ0aW1lUmFuZ2UiLCJtc1JhbmdlIiwiZGlmZiIsInNSYW5nZSIsInJvdW5kIiwiX19yYW5nZV9tcyIsIl9fcmFuZ2VfcyIsIl9fcmFuZ2UiLCJpbnRlcnBvbGF0ZVZhcmlhYmxlc0luUXVlcmllcyIsInF1ZXJpZXMiLCJleHBhbmRlZFF1ZXJpZXMiLCJnZXRSZWYiLCJnZXRRdWVyeURpc3BsYXlUZXh0IiwiZ2V0VGltZVJhbmdlUGFyYW1zIiwidmFsdWVPZiIsImltcG9ydEZyb21BYnN0cmFjdFF1ZXJpZXMiLCJhYnN0cmFjdFF1ZXJpZXMiLCJleGlzdGluZ0tleXMiLCJsYWJlbEtleXMiLCJhYnN0cmFjdFF1ZXJ5IiwibGFiZWxNYXRjaGVycyIsImxhYmVsTWF0Y2hlciIsImltcG9ydEZyb21BYnN0cmFjdFF1ZXJ5IiwiZXhwb3J0VG9BYnN0cmFjdFF1ZXJpZXMiLCJleHBvcnRUb0Fic3RyYWN0UXVlcnkiLCJtZXRhZGF0YVJlcXVlc3QiLCJoaWRlRnJvbUluc3BlY3RvciIsIm1ldHJpY0ZpbmRRdWVyeSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW50ZXJwb2xhdGVkIiwicHJvY2Vzc01ldHJpY0ZpbmRRdWVyeSIsImxhYmVsTmFtZXNSZWdleCIsImxhYmVsVmFsdWVzUmVnZXgiLCJsYWJlbE5hbWVzIiwibGFiZWxOYW1lc1F1ZXJ5IiwibGFiZWxWYWx1ZXMiLCJsYWJlbFZhbHVlc1Nlcmllc1F1ZXJ5IiwibGFiZWxWYWx1ZXNRdWVyeSIsInRpbWVQYXJhbXMiLCJhZGQiLCJBcnJheSIsImdldFRhZ0tleXMiLCJnZXRUYWdWYWx1ZXMiLCJ2YXJpYWJsZSIsIm11bHRpIiwiaW5jbHVkZUFsbCIsImxva2lSZWd1bGFyRXNjYXBlIiwibG9raVNwZWNpYWxSZWdleEVzY2FwZSIsImVzY2FwZWRWYWx1ZXMiLCJtb2RpZnlRdWVyeSIsImFjdGlvbiIsImRhdGUiLCJyb3VuZFVwIiwicGFyc2UiLCJ0ZXN0RGF0YXNvdXJjZSIsInN0YXJ0TXMiLCJEYXRlIiwibm93IiwidGVzdFJlc3VsdCIsImFubm90YXRpb25RdWVyeSIsInN0ZXBJbnRlcnZhbCIsInRhZ0tleXMiLCJ0aXRsZUZvcm1hdCIsInRleHRGb3JtYXQiLCJpbnRlcnBvbGF0ZWRFeHByIiwiYW5ub3RhdGlvbnMiLCJzcGxpdEtleXMiLCJzcGxpdCIsImVudHJpZXMiLCJTdHJpbmciLCJ0cmltIiwidGFncyIsInJlZHVjZSIsImFjYyIsInZhbCIsImFwcGx5IiwidmlldyIsInRzIiwibGluZSIsInNob3dDb250ZXh0VG9nZ2xlIiwiZHluYW1pY0ludGVydmFsIiwic2FmZUludGVydmFsIiwibWF4IiwicXVlcnlFeHByIiwiYWRob2NGaWx0ZXJzIiwiZ2V0QWRob2NGaWx0ZXJzIiwibm90UGFyc2VkTGFiZWxPdmVycmlkZSIsImZpbHRlclF1ZXJ5IiwiYXBwbHlUZW1wbGF0ZVZhcmlhYmxlcyIsImludGVycG9sYXRlU3RyaW5nIiwiZ2V0VmFyaWFibGVzIiwidG9rZW5zIiwidG9rZW5pemUiLCJ0IiwidmFsdWVGaWVsZCIsImdldEZpcnN0RmllbGRPZlR5cGUiLCJnZXRMb2dMZXZlbEZyb21MYWJlbHMiLCJ1bmtub3duIiwibGV2ZWxMYWJlbCIsImxhYmVsTmFtZSIsImRpZmZlcmVuY2UiLCJMUlUiLCJleHRyYWN0TGFiZWxNYXRjaGVycyIsInBhcnNlU2VsZWN0b3IiLCJwcm9jZXNzTGFiZWxzIiwidG9Qcm9tTGlrZUV4cHIiLCJGVU5DVElPTlMiLCJQSVBFX1BBUlNFUlMiLCJQSVBFX09QRVJBVE9SUyIsImRhdGVUaW1lIiwiREVGQVVMVF9LRVlTIiwiSElTVE9SWV9JVEVNX0NPVU5UIiwiSElTVE9SWV9DT1VOVF9DVVRPRkYiLCJSQVRFX1JBTkdFUyIsInNvcnRWYWx1ZSIsIkxBQkVMX1JFRlJFU0hfSU5URVJWQUwiLCJ3cmFwTGFiZWwiLCJmaWx0ZXJUZXh0IiwiYWRkSGlzdG9yeU1ldGFkYXRhIiwiY3V0b2ZmVHMiLCJoaXN0b3J5Rm9ySXRlbSIsImgiLCJoaW50IiwicmVjZW50IiwibGFzdFF1ZXJpZWQiLCJmcm9tTm93IiwiTG9raUxhbmd1YWdlUHJvdmlkZXIiLCJpbml0aWFsVmFsdWVzIiwicyIsInN0YXJ0VGFzayIsImNvbnRleHQiLCJnZXRFbXB0eUNvbXBsZXRpb25JdGVtcyIsImdldFRlcm1Db21wbGV0aW9uSXRlbXMiLCJwcmVmaXhNYXRjaCIsIml0ZW1zIiwia2luZCIsImludGVycG9sYXRlZE1hdGNoIiwiY2FjaGVLZXkiLCJnZW5lcmF0ZUNhY2hlS2V5Iiwic2VyaWVzQ2FjaGUiLCJzZXQiLCJsYWJlbEZldGNoVHMiLCJhc3NpZ24iLCJpbnB1dCIsImVtcHR5UmVzdWx0IiwiZG9jdW1lbnQiLCJzZWxlY3RlZExpbmVzIiwiZ2V0VGV4dHNBdFJhbmdlIiwic2VsZWN0aW9uIiwiY3VycmVudExpbmUiLCJmaXJzdCIsImdldFRleHQiLCJuZXh0Q2hhcmFjdGVyIiwiYW5jaG9yIiwidG9rZW5SZWNvZ25pemVkIiwicHJlZml4VW5yZWNvZ25pemVkIiwibm9TdWZmaXgiLCJzYWZlUHJlZml4Iiwib3BlcmF0b3JzUGF0dGVybiIsImlzTmV4dE9wZXJhbmQiLCJnZXRSYW5nZUNvbXBsZXRpb25JdGVtcyIsImdldExhYmVsQ29tcGxldGlvbkl0ZW1zIiwiZ2V0UGlwZUNvbXBsZXRpb25JdGVtIiwiZ2V0QmVnaW5uaW5nQ29tcGxldGlvbkl0ZW1zIiwiaGlzdG9yeUl0ZW1zIiwidW5pcSIsInRha2UiLCJza2lwU29ydCIsImFuY2hvckJsb2NrIiwiY3Vyc29yT2Zmc2V0IiwiaXNWYWx1ZVN0YXJ0IiwicGFyc2VkU2VsZWN0b3IiLCJhbGxMYWJlbHMiLCJsYWJlbFZhbHVlc0ZvcktleSIsImdldFNlcmllc0xhYmVscyIsIndhcm4iLCJwb3NzaWJsZUtleXMiLCJuZXdJdGVtcyIsIm5ld1N1Z2dlc3Rpb24iLCJsYWJlbEJhc2VkUXVlcnkiLCJsb2tpUXVlcnkiLCJsb29rdXBzRGlzYWJsZWQiLCJpc0FycmF5Iiwic29ydCIsInJlZnJlc2hMb2dMYWJlbHMiLCJmb3JjZVJlZnJlc2giLCJwYXJhbSIsInJvdW5kVGltZSIsIm5hbm9zIiwiZmxvb3IiLCJmZXRjaExhYmVsVmFsdWVzIiwiaW50ZXJwb2xhdGVkS2V5IiwicmFuZ2VQYXJhbXMiLCJsYWJlbHNDYWNoZSIsInJvdW5kTXNUb01pbiIsIm1pbGxpc2Vjb25kcyIsInJvdW5kU2VjVG9NaW4iLCJzZWNvbmRzIiwicHJldlJhbmdlIiwic2FtZU1pbnV0ZUZyb20iLCJzYW1lTWludXRlVG8iLCJwYXJzZUxhYmVscyIsIkNpcmN1bGFyRGF0YUZyYW1lIiwidGltZXIiLCJ3ZWJTb2NrZXQiLCJmaW5hbGl6ZSIsInJldHJ5V2hlbiIsIm1lcmdlTWFwIiwiYXBwZW5kUmVzcG9uc2VUb0J1ZmZlcmVkRGF0YSIsInJldHJ5SW50ZXJ2YWwiLCJjYXBhY2l0eSIsImFkZEZpZWxkIiwib3RoZXIiLCJhdHRlbXB0cyIsInJldHJ5QXR0ZW1wdCIsImNvZGUiLCJ2NSIsInV1aWR2NSIsIlVVSURfTkFNRVNQQUNFIiwiY3JlYXRlVWlkIiwidXNlZFVpZHMiLCJpZCIsImNvdW50IiwidW5pcXVlSWQiLCJsYWJlbHNTdHJpbmciLCJ1aWRzIiwiZiIsImdyb3VwQnkiLCJpbnN0YW50TWV0cmljRnJhbWVzIiwiZnJhbWVzV2l0aFJlZklkIiwiZnJhbWVzQnlSZWZJZCIsIm1ha2VUYWJsZUZyYW1lIiwidGFibGVUaW1lRmllbGQiLCJ0YWJsZVZhbHVlRmllbGQiLCJhbGxMYWJlbE5hbWVzIiwiZmxhdCIsInNvcnRlZExhYmVsTmFtZXMiLCJsYWJlbEZpZWxkcyIsImZpbHRlcmFibGUiLCJ0aW1lRmllbGQiLCJ0aW1lQXJyYXkiLCJ0b0FycmF5IiwidmFsdWVBcnJheSIsIngiLCJEYXRhU291cmNlUGx1Z2luIiwicGx1Z2luIiwic2V0UXVlcnlFZGl0b3IiLCJzZXRDb25maWdFZGl0b3IiLCJzZXRRdWVyeUVkaXRvckhlbHAiLCJzZXRBbm5vdGF0aW9uUXVlcnlDdHJsIiwiZXNjYXBlUmVnRXhwIiwicmVzdWx0cyIsImZpbHRlclN0YXJ0Iiwic2VhcmNoIiwiZmlsdGVyT3BlcmF0b3IiLCJza2lwIiwiZmlsdGVyRW5kIiwiZmlsdGVyVGVybSIsInF1b3RlZFRlcm0iLCJiYWNrdGlja2VkVGVybSIsInRlcm0iLCJ1bndyYXBwZWRGaWx0ZXJUZXJtIiwicmVnZXhPcGVyYXRvciIsInBhcnNlcnMiLCJwYXJzZXIiLCJyZWdleHAiLCJSZWdFeHAiLCJ0ZXN0IiwiTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSIsImdldE9wZXJhdGlvbkRlZmluaXRpb25zIiwiTG9raU9wZXJhdGlvbklkIiwiTG9raVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkiLCJMb2tpUXVlcnlNb2RlbGxlciIsInNldE9wZXJhdGlvbkNhdGVnb3JpZXMiLCJBZ2dyZWdhdGlvbnMiLCJSYW5nZUZ1bmN0aW9ucyIsIkZvcm1hdHMiLCJCaW5hcnlPcHMiLCJMYWJlbEZpbHRlcnMiLCJMaW5lRmlsdGVycyIsInJlbmRlckxhYmVscyIsImdldFF1ZXJ5UGF0dGVybnMiLCJvcGVyYXRpb25zIiwiTGluZU1hdGNoZXNSZWdleCIsIkxvZ2ZtdCIsIkxhYmVsRmlsdGVyTm9FcnJvcnMiLCJMYWJlbEZpbHRlciIsIlVud3JhcCIsIlN1bU92ZXJUaW1lIiwiU3VtIiwibG9raVF1ZXJ5TW9kZWxsZXIiLCJkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlciIsImJpbmFyeVNjYWxhckRlZnMiLCJBZGRpdGlvbiIsInNpZ24iLCJTdWJ0cmFjdGlvbiIsIk11bHRpcGx5QnkiLCJEaXZpZGVCeSIsIk1vZHVsbyIsIkV4cG9uZW50IiwiRXF1YWxUbyIsImNvbXBhcmlzb24iLCJOb3RFcXVhbFRvIiwiR3JlYXRlclRoYW4iLCJMZXNzVGhhbiIsIkdyZWF0ZXJPckVxdWFsIiwiTGVzc09yRXF1YWwiLCJiaW5hcnlTY2FsYXJPcGVyYXRpb25zIiwib3BEZWYiLCJkZWZhdWx0UGFyYW1zIiwidW5zaGlmdCIsImFsdGVybmF0aXZlc0tleSIsImNhdGVnb3J5IiwicmVuZGVyZXIiLCJnZXRTaW1wbGVCaW5hcnlSZW5kZXJlciIsImFkZE9wZXJhdGlvbkhhbmRsZXIiLCJiaW5hcnlSZW5kZXJlciIsIm1vZGVsIiwiZGVmIiwiaW5uZXJFeHByIiwiYm9vbCIsIk9wZXJhdGlvbkxpc3QiLCJFZGl0b3JSb3ciLCJRdWVyeVByZXZpZXciLCJPcGVyYXRpb25zRWRpdG9yUm93IiwiTmVzdGVkUXVlcnlMaXN0IiwiTG9raVF1ZXJ5QnVpbGRlciIsIm5lc3RlZCIsIm9uQ2hhbmdlTGFiZWxzIiwid2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zIiwib3B0aW9uc1Byb21pc2UiLCJvbkdldExhYmVsTmFtZXMiLCJmb3JMYWJlbCIsImxhYmVsc1RvQ29uc2lkZXIiLCJzZXJpZXMiLCJvbkdldExhYmVsVmFsdWVzIiwiZm9yTGFiZWxJbnRlcnBvbGF0ZWQiLCJiaW5hcnlRdWVyaWVzIiwiU3RhY2siLCJPcGVyYXRpb25MaXN0RXhwbGFpbmVkIiwiT3BlcmF0aW9uRXhwbGFpbmVkQm94IiwiTG9raVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCIsIkVkaXRvckZpZWxkIiwiUXVlcnlPcHRpb25Hcm91cCIsIkF1dG9TaXplSW5wdXQiLCJMb2tpUXVlcnlCdWlsZGVyT3B0aW9ucyIsIm9uTGVnZW5kRm9ybWF0Q2hhbmdlZCIsImV2dCIsIm5ld01heExpbmVzIiwic2hvd01heExpbmVzIiwiZ2V0Q29sbGFwc2VkSW5mbyIsInF1ZXJ5VHlwZUxhYmVsIiwicmVzb2x1dGlvbkxhYmVsIiwidXNlU3R5bGVzMiIsIkxva2lRdWVyeUNvZGVFZGl0b3IiLCJFZGl0b3JIZWFkZXIiLCJFZGl0b3JSb3dzIiwiRmxleEl0ZW0iLCJJbmxpbmVTZWxlY3QiLCJTcGFjZSIsIkNvbmZpcm1Nb2RhbCIsIlF1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSIsIlF1ZXJ5RWRpdG9yTW9kZSIsInVzZUNhbGxiYWNrIiwiZ2V0UXVlcnlXaXRoRGVmYXVsdHMiLCJnZXREZWZhdWx0RW1wdHlRdWVyeSIsImJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIiwidmlzdWFsUXVlcnkiLCJzZXRWaXN1YWxRdWVyeSIsInBhcnNlTW9kYWxPcGVuIiwic2V0UGFyc2VNb2RhbE9wZW4iLCJwZW5kaW5nQ2hhbmdlIiwic2V0UGVuZGluZ0NoYW5nZSIsIm9uRWRpdG9yTW9kZUNoYW5nZSIsIm5ld01ldHJpY0VkaXRvck1vZGUiLCJjaGFuZ2UiLCJlZGl0b3JNb2RlIiwiQnVpbGRlciIsImVycm9ycyIsIm9uQ2hhbmdlVmlld01vZGVsIiwidXBkYXRlZFF1ZXJ5IiwicmVuZGVyUXVlcnkiLCJDb2RlIiwicnVuUXVlcnkiLCJMb2FkaW5nIiwiRXhwbGFpbiIsImNvbG9yIiwic3dpdGNoTGFiZWwiLCJmb250U2l6ZSIsImJvZHlTbWFsbCIsInRvT3B0aW9uIiwiSWNvbkJ1dHRvbiIsIk5lc3RlZFF1ZXJ5IiwibmVzdGVkUXVlcnkiLCJvblJlbW92ZSIsImNhcmQiLCJoZWFkZXIiLCJvcGVyYXRvcnMiLCJ2ZWN0b3JNYXRjaFdyYXBwZXIiLCJ2ZWN0b3JNYXRjaGVzVHlwZSIsInZlY3Rvck1hdGNoSW5wdXQiLCJ2ZWN0b3JNYXRjaGVzIiwiYm9keSIsInVwZGF0ZSIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwicGFkZGluZyIsImFsaWduSXRlbXMiLCJ3aGl0ZVNwYWNlIiwicGFkZGluZ0xlZnQiLCJtYXJnaW5MZWZ0IiwibmVzdGVkUXVlcmllcyIsIm9uTmVzdGVkUXVlcnlVcGRhdGUiLCJ1cGRhdGVkTGlzdCIsIkVkaXRvckZpZWxkR3JvdXAiLCJsb2tpR3JhbW1hciIsImhpZ2h0bGlnaHRlZCIsImhpZ2hsaWdodCIsImVkaXRvckZpZWxkIiwiX19odG1sIiwiZm9udEZhbWlseSIsImNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uIiwiY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0iLCJnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lIiwiTG9raU9wZXJhdGlvbk9yZGVyIiwiYWdncmVnYXRpb25zIiwiTWluIiwiTWF4IiwiQXZnIiwiU3RkZGV2IiwiU3RkdmFyIiwiQ291bnQiLCJmbGF0TWFwIiwib3BJZCIsImFkZExva2lPcGVyYXRpb24iLCJvcmRlclJhbmsiLCJMYXN0IiwiYWdncmVnYXRpb25zV2l0aFBhcmFtIiwiVG9wSyIsIkJvdHRvbUsiLCJjcmVhdGVSYW5nZU9wZXJhdGlvbiIsIlJhdGUiLCJDb3VudE92ZXJUaW1lIiwiQnl0ZXNSYXRlIiwiQnl0ZXNPdmVyVGltZSIsIkFic2VudE92ZXJUaW1lIiwiQXZnT3ZlclRpbWUiLCJNYXhPdmVyVGltZSIsIk1pbk92ZXJUaW1lIiwiRmlyc3RPdmVyVGltZSIsIkxhc3RPdmVyVGltZSIsIlN0ZHZhck92ZXJUaW1lIiwiU3RkZGV2T3ZlclRpbWUiLCJRdWFudGlsZU92ZXJUaW1lIiwiSnNvbiIsIkxpbmVGb3JtYXRzIiwicGlwZWxpbmVSZW5kZXJlciIsImV4cGxhaW5IYW5kbGVyIiwiUmVnZXhwIiwiaGlkZU5hbWUiLCJtaW5XaWR0aCIsIlBhdHRlcm4iLCJVbnBhY2siLCJMaW5lRm9ybWF0IiwiTGFiZWxGb3JtYXQiLCJMaW5lQ29udGFpbnMiLCJnZXRMaW5lRmlsdGVyUmVuZGVyZXIiLCJvcCIsIkxpbmVDb250YWluc05vdCIsIkxpbmVNYXRjaGVzUmVnZXhOb3QiLCJsYWJlbEZpbHRlclJlbmRlcmVyIiwiTm9FcnJvcnMiLCJhZGROZXN0ZWRRdWVyeUhhbmRsZXIiLCJnZXRSYW5nZVZlY3RvclBhcmFtRGVmIiwib3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIiLCJvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlckFuZFBhcmFtIiwiUmFuZ2VWZWN0b3JGdW5jdGlvbiIsIm9wRG9jcyIsImluc2VydFRleHQiLCJyYW5nZVZlY3RvciIsIm9wZXJhdGlvbiIsImxpbmVGaWx0ZXJSZW5kZXJlciIsImlzUmFuZ2VWZWN0b3JGdW5jdGlvbiIsImdldEluZGV4T2ZPckxhc3QiLCJxdWVyeU1vZGVsbGVyIiwiY29uZGl0aW9uIiwiZmluZEluZGV4IiwiZ2V0T3BlcmF0aW9uRGVmIiwibW9kZWxsZXIiLCJuZXdPcGVyYXRpb24iLCJleGlzdGluZ1JhbmdlVmVjdG9yRnVuY3Rpb24iLCJGdW5jdGlvbnMiLCJwbGFjZVRvSW5zZXJ0IiwiRXJyb3JOYW1lIiwiZ2V0QWxsQnlUeXBlIiwiZ2V0TGVmdE1vc3RDaGlsZCIsImdldFN0cmluZyIsIm1ha2VCaW5PcCIsIm1ha2VFcnJvciIsInJlcGxhY2VWYXJpYWJsZXMiLCJyZXBsYWNlZEV4cHIiLCJ0cmVlIiwidG9wTm9kZSIsInZpc1F1ZXJ5IiwiaGFuZGxlRXhwcmVzc2lvbiIsImlzRW1wdHlRdWVyeSIsImdldExhYmVsIiwiZ2V0Q2hpbGQiLCJnZXRMaW5lRmlsdGVyIiwiY3JlYXRlTm90U3VwcG9ydGVkRXJyb3IiLCJnZXRMYWJlbFBhcnNlciIsImdldExhYmVsRmlsdGVyIiwiZ2V0TGluZUZvcm1hdCIsImdldExhYmVsRm9ybWF0IiwiZ2V0VW53cmFwIiwiaGFuZGxlUmFuZ2VBZ2dyZWdhdGlvbiIsImhhbmRsZVZlY3RvckFnZ3JlZ2F0aW9uIiwiaGFuZGxlQmluYXJ5IiwiaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3IiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsImxhYmVsTm9kZSIsImlwTGluZUZpbHRlciIsIm1hcEZpbHRlciIsImZpbHRlckV4cHIiLCJoYW5kbGVRdW90ZXMiLCJwYXJzZXJOb2RlIiwidmFsdWVTdHJpbmciLCJpZGVudGlmaWVyIiwibmFtZU5vZGUiLCJmdW5jTmFtZSIsImxvZ0V4cHIiLCJncm91cGluZyIsImJ5TW9kaWZpZXIiLCJ3aXRob3V0TW9kaWZpZXIiLCJtZXRyaWNFeHByIiwib3BlcmF0b3JUb09wTmFtZSIsImxlZnQiLCJiaW5Nb2RpZmllciIsImdldEJpbmFyeU1vZGlmaWVyIiwicmlnaHQiLCJsYXN0Q2hpbGQiLCJsZWZ0TnVtYmVyIiwiZ2V0TGFzdENoaWxkV2l0aFNlbGVjdG9yIiwicmlnaHROdW1iZXIiLCJyaWdodEJpbmFyeSIsImlzQm9vbCIsImxlZnRNb3N0Q2hpbGQiLCJiaW5RdWVyeSIsImlzTWF0Y2hlciIsIm1hdGNoVHlwZSIsIm1hdGNoZXMiLCJtYXRjaGVyIiwicGFyZW50IiwiY2hpbGRyZW4iLCJzdG9yZSIsInF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXkiLCJjaGFuZ2VFZGl0b3JNb2RlIiwiZ2V0RGVmYXVsdEVkaXRvck1vZGUiLCJjYXBpdGFsaXplIiwiTXV0YWJsZURhdGFGcmFtZSIsImZpbmRVbmlxdWVMYWJlbHMiLCJ0b0RhdGFGcmFtZSIsImdldERhdGFTb3VyY2VTcnYiLCJUYWJsZU1vZGVsIiwidGltZXMiLCJ0aW1lc05zIiwibGluZXMiLCJ0b0lTT1N0cmluZyIsImNvbnN0cnVjdERhdGFGcmFtZSIsIm11dGFibGVEYXRhRnJhbWUiLCJiYXNlTGFiZWxzIiwidHNGaWVsZCIsInRzTnNGaWVsZCIsImxpbmVGaWVsZCIsImxhYmVsc0ZpZWxkIiwiaWRGaWVsZCIsInVuaXF1ZSIsImFsbExhYmVsc1N0cmluZyIsIm5ld0NvdW50IiwibG9raU1hdHJpeFRvVGltZVNlcmllcyIsIm1hdHJpeFJlc3VsdCIsImNyZWF0ZU1ldHJpY0xhYmVsIiwibWV0cmljIiwiZGF0YXBvaW50cyIsImxva2lQb2ludHNUb1RpbWVzZXJpZXNQb2ludHMiLCJwYXJzZVByb21ldGhldXNGb3JtYXRTYW1wbGVWYWx1ZSIsIlBPU0lUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJwYXJzZUZsb2F0IiwiZGF0YXBvaW50VmFsdWUiLCJ0aW1lc3RhbXAiLCJsb2tpUmVzdWx0cyIsInJlc3VsdENvdW50IiwidmFsdWVXaXRoUmVmSWQiLCJtZXRyaWNMYWJlbHMiLCJjdXIiLCJzb3J0ZWRMYWJlbHMiLCJ0YWJsZSIsImNvbHVtbnMiLCJuZXdTZXJpZXMiLCJyb3dzIiwiYSIsImIiLCJsYWJlbERhdGEiLCJnZXRPcmlnaW5hbE1ldHJpY05hbWUiLCJsYWJlbFBhcnQiLCJkZWNhbWVsaXplIiwibSIsImxva2lTdGF0c1RvTWV0YVN0YXQiLCJzdGF0cyIsInVuaXQiLCJlbmhhbmNlRGF0YUZyYW1lIiwiZGVyaXZlZEZpZWxkc0dyb3VwZWQiLCJmaWVsZEZyb21EZXJpdmVkRmllbGRDb25maWciLCJsb2dNYXRjaCIsImRlcml2ZWRGaWVsZENvbmZpZ3MiLCJkYXRhU291cmNlU3J2IiwiZGF0YUxpbmtzIiwiZGVyaXZlZEZpZWxkQ29uZmlnIiwiZHNTZXR0aW5ncyIsImdldEluc3RhbmNlU2V0dGluZ3MiLCJpbnRlcm5hbCIsImRhdGFzb3VyY2VOYW1lIiwicmFuZ2VRdWVyeVJlc3BvbnNlVG9UaW1lU2VyaWVzIiwidHJhbnNmb3JtZXJPcHRpb25zIiwiZm9ybWF0IiwiVmVjdG9yIiwidmVjUmVzdWx0IiwiTWF0cml4IiwicmFuZ2VRdWVyeVJlc3BvbnNlVG9EYXRhRnJhbWVzIiwiaW50ZXJ2YWwiLCJMaXZlQ2hhbm5lbFNjb3BlIiwiZ2V0R3JhZmFuYUxpdmVTcnYiLCJkZWZlciIsIlN0cmVhbWluZ0RhdGFGcmFtZSIsImdldExpdmVTdHJlYW1LZXkiLCJzdHIiLCJKU09OIiwic3RyaW5naWZ5IiwibXNnVWludDgiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImhhc2hCdWZmZXIiLCJjcnlwdG8iLCJzdWJ0bGUiLCJkaWdlc3QiLCJoYXNoQXJyYXkiLCJVaW50OEFycmF5IiwicGFkU3RhcnQiLCJtYXhEZWx0YSIsIm1heExlbmd0aCIsInVwZGF0ZUZyYW1lIiwibXNnIiwicCIsImZyb21EYXRhRnJhbWVKU09OIiwiZGlzcGxheU5hbWVGb3JtYXQiLCJzY29wZSIsIkRhdGFTb3VyY2UiLCJuYW1lc3BhY2UiLCJwYXRoIiwiQUdHUkVHQVRJT05fT1BFUkFUT1JTIiwibW92ZSIsImRldGFpbCIsIlJBTkdFX1ZFQ19GVU5DVElPTlMiLCJrZXl3b3JkIiwiY29tbWVudCIsInBhdHRlcm4iLCJsb29rYmVoaW5kIiwiaW5zaWRlIiwiYWxpYXMiLCJwdW5jdHVhdGlvbiIsImdyZWVkeSIsImZ1bmN0aW9uIiwicXVvdGUiLCJiYWNrdGlja3MiLCJQcm9tUXVlcnlNb2RlbGxlciIsInZlY3RvclNlbGVjdG9yUG9zaXRpb25zIiwiZ2V0VmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMiLCJ0b0xhYmVsRmlsdGVyIiwiYWRkRmlsdGVyIiwicG9zaXRpb25zIiwiaXRlcmF0ZSIsImVudGVyIiwic3Vic3RyaW5nIiwibmV3UXVlcnkiLCJwcmV2IiwiaXNMYXN0IiwibGFiZWxFeGlzdHMiLCJuZXdMYWJlbHMiLCJkZWZhdWx0cyIsImZvcmtKb2luIiwidGFwIiwicmFuZ2VVdGlsIiwidG9EYXRhUXVlcnlSZXNwb25zZSIsInNhZmVTdHJpbmdpZnlWYWx1ZSIsIlByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyIiwiZXhwYW5kUmVjb3JkaW5nUnVsZXMiLCJnZXRJbml0SGludHMiLCJnZXRRdWVyeUhpbnRzIiwidHJhbnNmb3JtIiwidHJhbnNmb3JtVjIiLCJQcm9tUXVlcnlUeXBlIiwiUHJvbWV0aGV1c1ZhcmlhYmxlU3VwcG9ydCIsIlByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkiLCJmZXRjaERhdGFTb3VyY2VCdWlsZEluZm8iLCJQcm9tQXBwbGljYXRpb24iLCJCYWRnZSIsIlRvb2x0aXAiLCJBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVCIsIkdFVF9BTkRfUE9TVF9NRVRBREFUQV9FTkRQT0lOVFMiLCJQcm9tZXRoZXVzRGF0YXNvdXJjZSIsImxvYWRSdWxlcyIsImV4ZW1wbGFyc0F2YWlsYWJsZSIsImFyZUV4ZW1wbGFyc0F2YWlsYWJsZSIsImFjdGl2ZVRhcmdldHMiLCJjbG9uZWRUYXJnZXRzIiwicmVxdWVzdElkIiwicGFuZWxJZCIsIm1ldHJpY05hbWUiLCJoaXN0b2dyYW1NZXRyaWNzIiwiaW5zdGFudFRhcmdldCIsInJhbmdlVGFyZ2V0IiwiZXhlbXBsYXIiLCJhY3RpdmVUYXJnZXQiLCJleGVtcGxhclRhcmdldCIsImNyZWF0ZVF1ZXJ5IiwiaW50ZXJ2YWxUb1NlY29uZHMiLCJ0YWdLZXlzQXJyYXkiLCJldmVudExpc3QiLCJ0aW1lVmFsdWVUdXBsZSIsImlkeCIsInRpbWVTdGFtcFZhbHVlIiwidmFsdWVWYWx1ZSIsInVzZVZhbHVlRm9yVGltZSIsImFjdGl2ZVZhbHVlcyIsImFjdGl2ZVZhbHVlc1RpbWVzdGFtcHMiLCJsYXRlc3RFdmVudCIsInRpbWVFbmQiLCJzdWJUeXBlIiwiUHJvbWV0aGV1cyIsInJ1bGVyRW5hYmxlZCIsImVkaXRvclNyYyIsImFjY2VzcyIsInRpbWVJbnRlcnZhbCIsInF1ZXJ5VGltZW91dCIsImh0dHBNZXRob2QiLCJkaXJlY3RVcmwiLCJleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMiLCJydWxlTWFwcGluZ3MiLCJkaXNhYmxlTWV0cmljc0xvb2t1cCIsImN1c3RvbVF1ZXJ5UGFyYW1ldGVycyIsIlVSTFNlYXJjaFBhcmFtcyIsInZhcmlhYmxlcyIsIl9hZGRUcmFjaW5nSGVhZGVycyIsImh0dHBPcHRpb25zIiwicHJveHlNb2RlIiwiZGFzaGJvYXJkSWQiLCJvdmVycmlkZXMiLCJtZXRob2QiLCJrIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZW5kcG9pbnQiLCJwcm9tZXRoZXVzUmVndWxhckVzY2FwZSIsInByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUiLCJ0YXJnZXRDb250YWluc1RlbXBsYXRlIiwiY29udGFpbnNUZW1wbGF0ZSIsInNob3VsZFJ1bkV4ZW1wbGFyUXVlcnkiLCJjdXJyZW50VGFyZ2V0SWR4IiwicHJvY2Vzc1RhcmdldFYyIiwicHJvY2Vzc2VkVGFyZ2V0IiwidGltZVNlcmllc1F1ZXJ5IiwidXRjT2Zmc2V0U2VjIiwidXRjT2Zmc2V0IiwiZ2V0UHJvbWV0aGV1c1RpbWUiLCJwcmVwYXJlVGFyZ2V0cyIsImV4cGxvcmVRdWVyeSIsInBhbmVsc1F1ZXJ5IiwicnVubmluZ1F1ZXJpZXNDb3VudCIsImZpbHRlckFuZE1hcFJlc3BvbnNlIiwiY2FuY2VsbGVkIiwib2JzZXJ2YWJsZXMiLCJjdXJyZW50IiwicGVyZm9ybUluc3RhbnRRdWVyeSIsImdldEV4ZW1wbGFycyIsInBlcmZvcm1UaW1lU2VyaWVzUXVlcnkiLCJoaW50aW5nIiwibWluSW50ZXJ2YWwiLCJzY3JhcGVJbnRlcnZhbCIsImludGVydmFsRmFjdG9yIiwiZ2V0UmF0ZUludGVydmFsU2NvcGVkVmFyaWFibGUiLCJfX2ludGVydmFsIiwiX19pbnRlcnZhbF9tcyIsImVuaGFuY2VFeHByV2l0aEFkSG9jRmlsdGVycyIsImFkanVzdGVkIiwiYWxpZ25SYW5nZSIsInJhdGVJbnRlcnZhbCIsIl9fcmF0ZV9pbnRlcnZhbCIsImhhbmRsZUVycm9ycyIsImludGVydmFsVG9NcyIsInByb2Nlc3MiLCJxdWVyeU1vZGVsIiwicnNwIiwicHJvY2Vzc0Fubm90YXRpb25SZXNwb25zZSIsImdldFN1YnRpdGxlIiwiYnVpbGRJbmZvIiwiZ2V0QnVpbGRJbmZvIiwiZ2V0QnVpbGRJbmZvTWVzc2FnZSIsInNlcmllc0xhYmVscyIsImFsbCIsInVuaXF1ZUxhYmVscyIsImVuYWJsZWQiLCJkaXNhYmxlZCIsInVuc3VwcG9ydGVkIiwiTE9HT1MiLCJDb3J0ZXgiLCJNaW1pciIsIkNPTE9SUyIsImFwcGxpY2F0aW9uU3ViVHlwZSIsIndpZHRoIiwiaGVpZ2h0IiwidmVydGljYWxBbGlnbiIsImFwcGxpY2F0aW9uIiwiZ3JpZFRlbXBsYXRlQ29sdW1ucyIsInJvd0dhcCIsImNvbHVtbkdhcCIsIm1hcmdpblRvcCIsImZlYXR1cmVzIiwicnVsZXJBcGlFbmFibGVkIiwiZGV0YWlscyIsInZlcmJvc2VNZXNzYWdlIiwiY2F0Y2giLCJleHBhbmRlZFF1ZXJ5IiwiZ3JvdXBzIiwiZXh0cmFjdFJ1bGVNYXBwaW5nRnJvbUdyb3VwcyIsImxvZyIsIm1hcHBpbmciLCJmaW5hbFF1ZXJ5IiwiYWxpZ25lZEVuZCIsImFsaWduZWRTdGFydCIsImdyb3VwIiwicnVsZXMiLCJydWxlIiwib25jZSIsIkFic3RyYWN0TGFiZWxPcGVyYXRvciIsIlNlYXJjaEZ1bmN0aW9uVHlwZSIsImFkZExpbWl0SW5mbyIsImZpeFN1bW1hcmllc01ldGFkYXRhIiwicHJvY2Vzc0hpc3RvZ3JhbU1ldHJpY3MiLCJ0b1Byb21MaWtlUXVlcnkiLCJQcm9tcWxTeW50YXgiLCJTVUdHRVNUSU9OU19MSU1JVCIsInNldEZ1bmN0aW9uS2luZCIsImFkZE1ldHJpY3NNZXRhZGF0YSIsIm1ldGFkYXRhIiwiZ2V0TWV0YWRhdGFTdHJpbmciLCJoZWxwIiwidG9VcHBlckNhc2UiLCJQUkVGSVhfREVMSU1JVEVSX1JFR0VYIiwiUHJvbVFsTGFuZ3VhZ2VQcm92aWRlciIsImRlZmF1bHRWYWx1ZSIsIm1ldHJpY3MiLCJsb2FkTWV0cmljc01ldGFkYXRhIiwiZ2V0QWdncmVnYXRpb25Db21wbGV0aW9uSXRlbXMiLCJzZWFyY2hGdW5jdGlvblR5cGUiLCJQcmVmaXgiLCJtZXRyaWNzTWV0YWRhdGEiLCJGdXp6eSIsInF1ZXJ5T2Zmc2V0IiwicXVlcnlUZXh0IiwiZ2V0QmxvY2tzIiwiYmxvY2siLCJibG9ja1RleHQiLCJvcGVuUGFyZW5zQWdncmVnYXRpb25JbmRleCIsImxhc3RJbmRleE9mIiwib3BlblBhcmVuc1NlbGVjdG9ySW5kZXgiLCJjbG9zZVBhcmVuc1NlbGVjdG9ySW5kZXgiLCJjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXgiLCJzZWxlY3RvclN0cmluZyIsImdldFNlcmllcyIsImxpbWl0SW5mbyIsInN1YnN0ciIsImlzVmFsdWVFbmQiLCJpc1ByZVZhbHVlIiwiaXNWYWx1ZUVtcHR5IiwiaGFzVmFsdWVQcmVmaXgiLCJjb250YWluc01ldHJpYyIsIndpdGhOYW1lIiwiaW50ZXJwb2xhdGVkTmFtZSIsInVybFBhcmFtcyIsImNhY2hlUGFyYW1zIiwibGFzdCIsInBvcCIsInRyaW1MZWZ0IiwicHJvbVF1ZXJ5IiwibmFtZUxhYmVsVmFsdWUiLCJnZXROYW1lTGFiZWxWYWx1ZSIsIkVxdWFsIiwiZmV0Y2hEZWZhdWx0U2VyaWVzIiwicHJvcCIsIlRva2VuIiwiaW52ZXJ0IiwicmVzdWx0U2V0IiwiaXNIaXN0b2dyYW1WYWx1ZSIsInZhbHVlU2V0IiwiX19uYW1lX18iLCJsaW1pdFN1Z2dlc3Rpb25zIiwicHJlZml4T3BlbiIsInByZWZpeENsb3NlIiwic3VmZml4Q2xvc2VJbmRleCIsInN1ZmZpeENsb3NlIiwic3VmZml4T3BlbkluZGV4Iiwic3VmZml4T3BlbiIsImxhYmVsT2Zmc2V0IiwidmFsdWVTdGFydCIsInZhbHVlRW5kIiwibWV0cmljUHJlZml4IiwibWV0cmljTWF0Y2giLCJjbGVhblNlbGVjdG9yIiwicnVsZU5hbWVzIiwicnVsZXNSZWdleCIsInByZSIsInBvc3QiLCJxdWVyeUFycmF5IiwiaW52YWxpZExhYmVsc1JlZ2V4IiwiY29ycmVjdGx5RXhwYW5kZWRRdWVyeUFycmF5IiwiYWRkTGFiZWxzVG9FeHByZXNzaW9uIiwiaW52YWxpZExhYmVsc1JlZ2V4cCIsImluZGV4T2ZSZWdleE1hdGNoIiwiZXhwckJlZm9yZVJlZ2V4TWF0Y2giLCJleHByQWZ0ZXJSZWdleE1hdGNoIiwiYXJyYXlPZkxhYmVsT2JqZWN0cyIsIm9iaiIsImJhc2VNZXRhZGF0YSIsInN1bW1hcnlNZXRhZGF0YSIsInN5bnRoZXRpY01ldGFkYXRhIiwiUkUyX01FVEFDSEFSQUNURVJTIiwiZXNjYXBlUHJvbWV0aGV1c1JlZ2V4cCIsImVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IiLCJlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yIiwiRnJvbVByb21MaWtlTWFwIiwiTm90RXF1YWwiLCJFcXVhbFJlZ0V4IiwiTm90RXF1YWxSZWdFeCIsIlRvUHJvbUxpa2VNYXAiLCJ0b2tlbiIsImNvbnRlbnRUb2tlbnMiLCJjb250ZW50IiwiY3VycmVudFRva2VuIiwiY3VycmVudFN0ciIsImxhYmVsQ29tcGFyYXRvciIsIl9tYXAiLCJtZXRyaWNOYW1lc1JlZ2V4IiwicXVlcnlSZXN1bHRSZWdleCIsIm1ldHJpY05hbWVzUXVlcnkiLCJtZXRyaWNOYW1lUXVlcnkiLCJxdWVyeVJlc3VsdFF1ZXJ5IiwibWV0cmljTmFtZUFuZExhYmVsc1F1ZXJ5IiwiX2xhYmVscyIsImV4cGFuZGFibGUiLCJtZXRyaWNGaWx0ZXJQYXR0ZXJuIiwiciIsIm1hdGNoZWRNZXRyaWNOYW1lIiwiaW5zdGFudFF1ZXJ5IiwibWV0cmljRGF0YSIsInNlbGYiLCJUUklHT05PTUVUUklDX0ZVTkNUSU9OUyIsInByb21xbEdyYW1tYXIiLCJpZExpc3QiLCJTVU1fSElOVF9USFJFU0hPTERfQ09VTlQiLCJoaW50cyIsImhpc3RvZ3JhbU1ldHJpYyIsImZpeCIsIm5hbWVNYXRjaCIsImNvdW50ZXJOYW1lTWV0cmljIiwibWV0cmljTWV0YWRhdGFLZXlzIiwiY2VydGFpbiIsIm1ldHJpY1JlZ2V4IiwiZml4YWJsZVF1ZXJ5IiwidmVyYiIsIm1hcHBpbmdGb3JRdWVyeSIsInJ1bGVOYW1lIiwic2ltcGxlTWV0cmljIiwicHJldmVudFN1Ym1pdCIsImdldEFnZ3JlZ2F0aW9uT3BlcmF0aW9ucyIsIlByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5IiwiYWxsT3BlcmF0aW9ucyIsImZ1bmMiLCJUcmlnb25vbWV0cmljIiwiVGltZSIsInByb21RdWVyeU1vZGVsbGVyIiwiYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yIiwiUHJvbU9wZXJhdGlvbklkIiwiQ291bnRWYWx1ZXMiLCJjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lIiwiUHJlc2VudE92ZXJUaW1lIiwiZ2V0T3BlcmF0aW9uUGFyYW1JZCIsIkxhYmVsUGFyYW1FZGl0b3IiLCJvcGVyYXRpb25JbmRleCIsImlzTG9hZGluZyIsImxvYWRHcm91cEJ5TGFiZWxzIiwiZnVuY3Rpb25SZW5kZXJlckxlZnQiLCJmdW5jdGlvblJlbmRlcmVyUmlnaHQiLCJyYW5nZVJlbmRlcmVyTGVmdFdpdGhQYXJhbXMiLCJyYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zIiwiSGlzdG9ncmFtUXVhbnRpbGUiLCJMYWJlbFJlcGxhY2UiLCJMbiIsImNyZWF0ZVJhbmdlRnVuY3Rpb24iLCJDaGFuZ2VzIiwiSXJhdGUiLCJJbmNyZWFzZSIsIklkZWx0YSIsIkRlbHRhIiwiY3JlYXRlRnVuY3Rpb24iLCJIb2x0V2ludGVycyIsImNoYW5nZVR5cGVIYW5kbGVyIiwib3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbiIsIlByZWRpY3RMaW5lYXIiLCJBYnNlbnQiLCJBY29zIiwiQWNvc2giLCJBc2luIiwiQXNpbmgiLCJBdGFuIiwiQXRhbmgiLCJDZWlsIiwiQ2xhbXAiLCJDbGFtcE1heCIsIkNsYW1wTWluIiwiQ29zIiwiQ29zaCIsIkRheU9mTW9udGgiLCJEYXlPZldlZWsiLCJEYXlzSW5Nb250aCIsIkRlZyIsIkRlcml2IiwiRXhwIiwiRmxvb3IiLCJHcm91cCIsIkhvdXIiLCJMYWJlbEpvaW4iLCJyZXN0UGFyYW0iLCJvcHRpb25hbCIsImxhYmVsSm9pblJlbmRlcmVyIiwibGFiZWxKb2luQWRkT3BlcmF0aW9uSGFuZGxlciIsIkxvZzEwIiwiTG9nMiIsIk1pbnV0ZSIsIk1vbnRoIiwiUGkiLCJRdWFudGlsZSIsIlJhZCIsIlJlc2V0cyIsIlJvdW5kIiwiU2NhbGFyIiwiU2duIiwiU2luIiwiU2luaCIsIlNvcnQiLCJTb3J0RGVzYyIsIlNxcnQiLCJUYW4iLCJUYW5oIiwiVGltZXN0YW1wIiwiWWVhciIsImRlZmluaXRpb24iLCJ3aXRoUmF0ZUludGVydmFsIiwibmV3RGVmIiwiZmlyc3RPcCIsInNlcGFyYXRvciIsImhhbmRsZUZ1bmN0aW9uIiwiaGFuZGxlQWdncmVnYXRpb24iLCJwcmV2U2libGluZyIsInJhbmdlRnVuY3Rpb25zIiwiY2FsbEFyZ3MiLCJ1cGRhdGVGdW5jdGlvbkFyZ3MiLCJtb2RpZmllciIsIm1lYXN1cmVUZXh0IiwiZm9yd2FyZFJlZiIsInJlZiIsIm1heFdpZHRoIiwib25Db21taXRDaGFuZ2UiLCJvbktleURvd24iLCJyZXN0UHJvcHMiLCJzZXRWYWx1ZSIsImlucHV0V2lkdGgiLCJzZXRJbnB1dFdpZHRoIiwiZ2V0V2lkdGhGb3IiLCJleHRyYVNwYWNlIiwicmVhbFdpZHRoIiwiQWNjZXNzb3J5QnV0dG9uIiwiSW5wdXRHcm91cCIsIkxhYmVsRmlsdGVySXRlbSIsImRlZmF1bHRPcCIsImlzTXVsdGlTZWxlY3QiLCJnZXRWYWx1ZSIsImdldE9wdGlvbnMiLCJpc0xvYWRpbmdMYWJlbE5hbWVzIiwiaXNMb2FkaW5nTGFiZWxWYWx1ZXMiLCJjaGFuZ2VzIiwiRWRpdG9yTGlzdCIsImxhYmVsc0ZpbHRlcnMiLCJzZXRJdGVtcyIsIm9uTGFiZWxzQ2hhbmdlIiwib25DaGFuZ2VJdGVtIiwiUmVnaXN0cnkiLCJnZXRPcGVyYXRpb25zIiwib3BlcmF0aW9uc1JlZ2lzdHkiLCJjYXRlZ29yaWVzIiwiZ2V0T3BlcmF0aW9uc0ZvckNhdGVnb3J5IiwiaGlkZUZyb21MaXN0IiwiZ2V0QWx0ZXJuYXRpdmVPcGVyYXRpb25zIiwiZ2V0Q2F0ZWdvcmllcyIsImdldElmRXhpc3RzIiwicmVuZGVyT3BlcmF0aW9ucyIsInF1ZXJ5U3RyaW5nIiwicmVuZGVyQmluYXJ5UXVlcmllcyIsInJlbmRlckJpbmFyeVF1ZXJ5IiwibGVmdE9wZXJhbmQiLCJiaW5hcnlRdWVyeSIsImhhc0JpbmFyeU9wIiwiRHJhZ2dhYmxlIiwiT3BlcmF0aW9uSGVhZGVyIiwiZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IiLCJPcGVyYXRpb25FZGl0b3IiLCJzaG91bGRIaWdobGlnaHQiLCJ1c2VIaWdobGlnaHQiLCJvblBhcmFtVmFsdWVDaGFuZ2VkIiwicGFyYW1JZHgiLCJjYWxsUGFyYW1DaGFuZ2VkVGhlbk9uQ2hhbmdlIiwib25BZGRSZXN0UGFyYW0iLCJvblJlbW92ZVJlc3RQYXJhbSIsIm9wZXJhdGlvbkVsZW1lbnRzIiwicGFyYW1JbmRleCIsInBhcmFtRGVmIiwiRWRpdG9yIiwicGFyYW1Sb3ciLCJwYXJhbU5hbWUiLCJpbmZvSWNvbiIsInBhcmFtVmFsdWUiLCJsYXN0UGFyYW1EZWYiLCJyZW5kZXJBZGRSZXN0UGFyYW1CdXR0b24iLCJwcm92aWRlZCIsImNhcmRIaWdobGlnaHQiLCJpbm5lclJlZiIsImRyYWdnYWJsZVByb3BzIiwiZHJhZ0hhbmRsZVByb3BzIiwiYXJyb3ciLCJhcnJvd0xpbmUiLCJhcnJvd0Fycm93Iiwia2VlcEhpZ2hsaWdodCIsInNldEtlZXBIaWdobGlnaHQiLCJwYXJhbUNoYW5nZWRIYW5kbGVyIiwicHJpbWFyeSIsImN1cnNvciIsImJvcmRlclJhZGl1cyIsInNoYXBlIiwibWFyZ2luQm90dG9tIiwidHJhbnNpdGlvbiIsImJveFNoYWRvdyIsIm1hcmdpbiIsImZvbnRXZWlnaHQiLCJmb250V2VpZ2h0TWVkaXVtIiwidG9wIiwiYmFja2dyb3VuZENvbG9yIiwic3Ryb25nIiwiYm9yZGVyVG9wIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyTGVmdCIsInJlbmRlck1hcmtkb3duIiwic3RlcE51bWJlciIsIm1hcmtkb3duIiwiYm94IiwiYm94SW5uZXIiLCJqdXN0aWZ5Q29udGVudCIsInBhZGRpbmdCb3R0b20iLCJ0ZXh0RGVjb3JhdGlvbiIsIk9wZXJhdGlvbkluZm9CdXR0b24iLCJvblRvZ2dsZVN3aXRjaGVyIiwiaXNPcGVuIiwiYWx0ZXJuYXRpdmVzIiwiYWx0Iiwib3BlcmF0aW9uSGVhZGVyQnV0dG9ucyIsInNlbGVjdFdyYXBwZXIiLCJjaGFuZ2VkT3AiLCJvcGFjaXR5IiwidHJhbnNpdGlvbnMiLCJjcmVhdGUiLCJkdXJhdGlvbiIsInNob3J0IiwicGFkZGluZ1JpZ2h0IiwiUG9ydGFsIiwidXNlUG9wcGVyVG9vbHRpcCIsInNob3ciLCJzZXRTaG93IiwiZ2V0VG9vbHRpcFByb3BzIiwic2V0VG9vbHRpcFJlZiIsInNldFRyaWdnZXJSZWYiLCJ2aXNpYmxlIiwicGxhY2VtZW50Iiwib25WaXNpYmxlQ2hhbmdlIiwiaW50ZXJhY3RpdmUiLCJ0cmlnZ2VyIiwiZG9jQm94IiwiZG9jQm94SGVhZGVyIiwiZG9jQm94Qm9keSIsImdldE9wZXJhdGlvbkRvY3MiLCJvdmVyZmxvdyIsInNoYWRvd3MiLCJ6MyIsInpJbmRleCIsInRvb2x0aXAiLCJoNSIsInNpZ25hdHVyZSIsImRyb3Bkb3duIiwiQ2FzY2FkZXIiLCJEcmFnRHJvcENvbnRleHQiLCJEcm9wcGFibGUiLCJ1c2VNb3VudGVkU3RhdGUiLCJvcHNUb0hpZ2hsaWdodCIsInVzZU9wZXJhdGlvbnNIaWdobGlnaHQiLCJjYXNjYWRlck9wZW4iLCJzZXRDYXNjYWRlck9wZW4iLCJvbk9wZXJhdGlvbkNoYW5nZSIsImFkZE9wdGlvbnMiLCJpc0xlYWYiLCJvbkFkZE9wZXJhdGlvbiIsIm9wZXJhdGlvbkRlZiIsIm9uRHJhZ0VuZCIsImRlc3RpbmF0aW9uIiwiZWxlbWVudCIsInNvdXJjZSIsIm9uQ2FzY2FkZXJCbHVyIiwib3BlcmF0aW9uTGlzdCIsImRyb3BwYWJsZVByb3BzIiwiYWRkQnV0dG9uIiwiaXNNb3VudGVkIiwicHJldk9wZXJhdGlvbnMiLCJuZXdPcHMiLCJuZXdPcCIsImlzU2FtZU9wIiwib3AxIiwib3AyIiwiaGVhZGluZyIsImZsZXhXcmFwIiwiQ2hlY2tib3giLCJTZWxlY3RJbnB1dFBhcmFtRWRpdG9yIiwiQm9vbElucHV0UGFyYW1FZGl0b3IiLCJTaW1wbGVJbnB1dFBhcmFtRWRpdG9yIiwiY2hlY2tlZCIsInNlbGVjdE9wdGlvbnMiLCJ2YWx1ZU9wdGlvbiIsInJvb3QiLCJUYWciLCJlZGl0b3JNb2RlcyIsImNvbXBvbmVudCIsIm1vZGUiLCJ1c2VUb2dnbGUiLCJjb2xsYXBzZWRJbmZvIiwidG9nZ2xlT3BlbiIsInRvZ2dsZSIsImVtcGhhc2l6ZSIsImZsZXhHcm93IiwicGFkZGluZ1RvcCIsIm1hcmdpblJpZ2h0IiwicGx1cmFsaXplIiwicmVuZGVyUGFyYW1zIiwicmFuZ2VSZW5kZXJlcldpdGhQYXJhbXMiLCJyZW5kZXJMZWZ0IiwiZ2V0T25MYWJlbEFkZGVkSGFuZGxlciIsImdldEFnZ3JlZ2F0aW9uRXhwbGFpbmVyIiwiZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyIiwiZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIiLCJnZXRBZ2dyZWdhdGlvbldpdGhvdXRSZW5kZXJlciIsInBhcmFtc0RlZiIsImdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIiLCJhZ2dyZWdhdGlvbiIsImFnZ3JlZ2F0aW9uUmVuZGVyZXIiLCJhZ2dyZWdhdGlvbk5hbWUiLCJhZ2dyZWdhdGlvbkV4cGxhaW5lciIsImxhYmVsV29yZCIsIm1hcFR5cGUiLCJyZXN0UGFyYW1zIiwiY2hhbmdlVG9PcGVyYXRpb25JZCIsIm9uUGFyYW1DaGFuZ2VkIiwicGFyZW50VHlwZSIsInZhcmlhYmxlUmVnZXgiLCJ2YXIxIiwidmFyMiIsImZtdDIiLCJ2YXIzIiwiZmllbGRQYXRoIiwiZm10MyIsImZtdCIsInZhclR5cGUiLCJ2YXJUeXBlRnVuYyIsInJldHVyblZhcmlhYmxlcyIsIm51bWJlck5vZGUiLCJoYXNCb29sIiwicG9zIiwiY2hpbGRBZnRlciIsImpzb24iLCJ0b0pzb24iLCJqc29uVG9UZXh0IiwidHJlZUpzb24iLCJub2RlVG9TdHJpbmciLCJpbmRlbnQiLCJuZXdJbmRlbnQiLCJpc0xhc3RDaGlsZCIsIkFycmF5RGF0YUZyYW1lIiwiRGF0YVRvcGljIiwiZm9ybWF0TGFiZWxzIiwiZ2V0RGlzcGxheVByb2Nlc3NvciIsIlRJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRSIsIlRJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUUiLCJEYXRhRnJhbWVUeXBlIiwicGFydGl0aW9uIiwiZGVzY2VuZGluZyIsImRldmlhdGlvbiIsImlzRXhlbXBsYXJEYXRhIiwiaXNNYXRyaXhEYXRhIiwiUE9TSVRJVkVfSU5GSU5JVFlfU0FNUExFX1ZBTFVFIiwiTkVHQVRJVkVfSU5GSU5JVFlfU0FNUExFX1ZBTFVFIiwiaXNUYWJsZVJlc3VsdCIsImlzSGVhdG1hcFJlc3VsdCIsInRhYmxlRnJhbWVzIiwiZnJhbWVzV2l0aG91dFRhYmxlIiwiZGYiLCJwcm9jZXNzZWRUYWJsZUZyYW1lcyIsInRyYW5zZm9ybURGVG9UYWJsZSIsImV4ZW1wbGFyRnJhbWVzIiwiZnJhbWVzV2l0aG91dFRhYmxlQW5kRXhlbXBsYXJzIiwiZGVzdGluYXRpb25zIiwicHJvY2Vzc2VkRXhlbXBsYXJGcmFtZXMiLCJleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiIsInRyYWNlSURGaWVsZCIsImdldERhdGFMaW5rcyIsImRhdGFUb3BpYyIsIkFubm90YXRpb25zIiwiaGVhdG1hcFJlc3VsdHMiLCJmcmFtZXNXaXRob3V0VGFibGVIZWF0bWFwc0FuZEV4ZW1wbGFycyIsInByb2Nlc3NlZEhlYXRtYXBGcmFtZXMiLCJtZXJnZUhlYXRtYXBGcmFtZXMiLCJ0cmFuc2Zvcm1Ub0hpc3RvZ3JhbU92ZXJUaW1lIiwic29ydFNlcmllc0J5TGFiZWwiLCJvdGhlckZyYW1lcyIsImRmcyIsImRhdGFGcmFtZXNCeVJlZklkIiwicmVmSWRzIiwidmFsdWVUZXh0IiwiZ2V0VmFsdWVUZXh0IiwiZ2V0VmFsdWVGaWVsZCIsInZhbHVlTmFtZSIsImdldFRpbWVGaWVsZCIsImZyYW1lVmFsdWVGaWVsZCIsInByb21MYWJlbHMiLCJudW1iZXJGaWVsZCIsInBhcnNlU2FtcGxlVmFsdWUiLCJsYWJlbHNGb3JGaWVsZCIsImdldExhYmVsVmFsdWUiLCJyZXNwb25zZUxlbmd0aCIsInRyYW5zZm9ybU9wdGlvbnMiLCJwcm9tZXRoZXVzUmVzdWx0IiwiZXZlbnRzIiwiZXhlbXBsYXJEYXRhIiwiZXhlbXBsYXJzIiwic2FtcGxlZEV4ZW1wbGFycyIsInNhbXBsZUV4ZW1wbGFycyIsInRhYmxlRGF0YSIsInRyYW5zZm9ybU1ldHJpY0RhdGFUb1RhYmxlIiwidHJhbnNmb3JtVG9EYXRhRnJhbWUiLCJ0YXJnZXRCbGFuayIsImJ1Y2tldGVkRXhlbXBsYXJzIiwiYWxpZ25lZFRzIiwic3RhbmRhcmREZXZpYXRpb24iLCJzYW1wbGVkQnVja2V0cyIsImV4ZW1wbGFyc0luQnVja2V0IiwiYnVja2V0VmFsdWVzIiwiZXgiLCJzYW1wbGVkQnVja2V0VmFsdWVzIiwiY3VyciIsImNyZWF0ZUxhYmVsSW5mbyIsInN0ZXBNcyIsImJhc2VUaW1lc3RhbXAiLCJkcHMiLCJkcFZhbHVlIiwiZW5kVGltZXN0YW1wIiwicGFyc2VWYWx1ZSIsImRpc3BsYXlOYW1lRnJvbURTIiwibWQiLCJtZXRyaWNGaWVsZHMiLCJtZXRyaWNGaWVsZCIsImhhc093blByb3BlcnR5IiwiaXNNcyIsImxhYmVsc1dpdGhvdXROYW1lIiwiY291bnRGaWVsZHMiLCJIZWF0bWFwQnVja2V0cyIsInNlcmllc0xpc3QiLCJ0b3BTZXJpZXMiLCJib3R0b21TZXJpZXMiLCJqIiwiYm90dG9tUG9pbnQiLCJzMSIsInMyIiwibGUxIiwibGUyIiwiTGVnZW5kRm9ybWF0TW9kZSIsIlN0YW5kYXJkVmFyaWFibGVTdXBwb3J0IiwibWV0cmljRmluZFN0cmVhbSIsInRvRGF0YVF1ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==