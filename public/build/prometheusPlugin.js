(self["webpackChunkgrafana"] = self["webpackChunkgrafana"] || []).push([["prometheusPlugin"],{

/***/ "./public/app/core/utils/CancelablePromise.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makePromiseCancelable": () => (/* binding */ makePromiseCancelable)
/* harmony export */ });
// https://github.com/facebook/react/issues/5465
const makePromiseCancelable = promise => {
  let hasCanceled_ = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(val => hasCanceled_ ? reject({
      isCanceled: true
    }) : resolve(val));
    promise.catch(error => hasCanceled_ ? reject({
      isCanceled: true
    }) : reject(error));
  });
  return {
    promise: wrappedPromise,

    cancel() {
      hasCanceled_ = true;
    }

  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/add_label_to_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLabelToQuery": () => (/* binding */ addLabelToQuery)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _querybuilder_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");




/**
 * Adds label filter to existing query. Useful for query modification for example for ad hoc filters.
 *
 * It uses PromQL parser to find instances of metric and labels, alters them and then splices them back into the query.
 * Ideally we could use the parse -> change -> render is a simple 3 steps but right now building the visual query
 * object does not support all possible queries.
 *
 * So instead this just operates on substrings of the query with labels and operates just on those. This makes this
 * more robust and can alter even invalid queries, and preserves in general the query structure and whitespace.
 * @param query
 * @param key
 * @param value
 * @param operator
 */
function addLabelToQuery(query, key, value, operator = '=') {
  if (!key || !value) {
    throw new Error('Need label to add to query.');
  }

  const vectorSelectorPositions = getVectorSelectorPositions(query);

  if (!vectorSelectorPositions.length) {
    return query;
  }

  const filter = toLabelFilter(key, value, operator);
  return addFilter(query, vectorSelectorPositions, filter);
}

/**
 * Parse the string and get all VectorSelector positions in the query together with parsed representation of the vector
 * selector.
 * @param query
 */
function getVectorSelectorPositions(query) {
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(query);
  const positions = [];
  tree.iterate({
    enter: (type, from, to, get) => {
      if (type.name === 'VectorSelector') {
        const visQuery = (0,_querybuilder_parsing__WEBPACK_IMPORTED_MODULE_1__.buildVisualQueryFromString)(query.substring(from, to));
        positions.push({
          query: visQuery.query,
          from,
          to
        });
        return false;
      }
    }
  });
  return positions;
}

function toLabelFilter(key, value, operator) {
  // We need to make sure that we convert the value back to string because it may be a number
  const transformedValue = value === Infinity ? '+Inf' : value.toString();
  return {
    label: key,
    op: operator,
    value: transformedValue
  };
}

function addFilter(query, vectorSelectorPositions, filter) {
  const modeller = new _querybuilder_PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__.PromQueryModeller();
  let newQuery = '';
  let prev = 0;

  for (let i = 0; i < vectorSelectorPositions.length; i++) {
    // This is basically just doing splice on a string for each matched vector selector.
    const match = vectorSelectorPositions[i];
    const isLast = i === vectorSelectorPositions.length - 1;
    const start = query.substring(prev, match.from);
    const end = isLast ? query.substring(match.to) : '';

    if (!labelExists(match.query.labels, filter)) {
      // We don't want to add duplicate labels.
      match.query.labels.push(filter);
    }

    const newLabels = modeller.renderQuery(match.query);
    newQuery += start + newLabels + end;
    prev = match.to;
  }

  return newQuery;
}
/**
 * Check if label exists in the list of labels but ignore the operator.
 * @param labels
 * @param filter
 */


function labelExists(labels, filter) {
  return labels.find(label => label.label === filter.label && label.value === filter.value);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;




const CHEAT_SHEET_ITEMS = [{
  title: 'Request Rate',
  expression: 'rate(http_request_total[5m])',
  label: 'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.'
}, {
  title: '95th Percentile of Request Latencies',
  expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',
  label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.'
}, {
  title: 'Alerts Firing',
  expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate="firing"}[24h])) by (alertname))',
  label: 'Sums up the alerts that have been firing over the last 24 hours.'
}, {
  title: 'Step',
  label: 'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.'
}];

const PromCheatSheet = props => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
  children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("h2", {
    children: "PromQL Cheat Sheet"
  })), CHEAT_SHEET_ITEMS.map((item, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("div", {
    className: "cheat-sheet-item",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__title",
      children: item.title
    }), item.expression ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__example",
      onClick: e => props.onClickExample({
        refId: 'A',
        expr: item.expression
      }),
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("code", {
        children: item.expression
      })
    }) : null, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
      className: "cheat-sheet-item__label",
      children: item.label
    })]
  }, index))]
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PromCheatSheet);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExemplarField": () => (/* binding */ PromExemplarField)
/* harmony export */ });
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["datasource", "onChange", "query"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function PromExemplarField(_ref) {
  let {
    datasource,
    onChange,
    query
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);

  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.useStyles2)(getStyles);
  const prevError = (0,react_use__WEBPACK_IMPORTED_MODULE_4__["default"])(error);
  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {
    if (!datasource.exemplarsAvailable) {
      setError('Exemplars for this query are not available');
      onChange(false);
    } else if (query.instant && !query.range) {
      setError('Exemplars are not available for instant queries');
      onChange(false);
    } else {
      setError(null); // If error is cleared, we want to change exemplar to true

      if (prevError && !error) {
        onChange(true);
      }
    }
  }, [datasource.exemplarsAvailable, query.instant, query.range, onChange, prevError, error]);
  const iconButtonStyles = (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.cx)({
    [styles.activeIcon]: !!query.exemplar
  }, styles.eyeIcon);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.InlineLabel, {
    width: "auto",
    "data-testid": rest['data-testid'],
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.Tooltip, {
      content: error !== null && error !== void 0 ? error : '',
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxs)("div", {
        className: styles.iconWrapper,
        children: ["Exemplars", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.IconButton, {
          name: "eye",
          tooltip: !!query.exemplar ? 'Disable query with exemplars' : 'Enable query with exemplars',
          disabled: !!error,
          className: iconButtonStyles,
          onClick: () => {
            onChange(!query.exemplar);
          }
        })]
      })
    })
  });
}

function getStyles(theme) {
  return {
    eyeIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
      margin-left: ${theme.spacing(2)};
    `,
    activeIcon: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
      color: ${theme.colors.primary.main};
    `,
    iconWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_1__.css`
      display: flex;
      align-items: center;
    `
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExploreExtraField": () => (/* binding */ PromExploreExtraField),
/* harmony export */   "getQueryTypeChangeHandler": () => (/* binding */ getQueryTypeChangeHandler),
/* harmony export */   "getQueryTypeOptions": () => (/* binding */ getQueryTypeOptions),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromExemplarField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2;









const PromExploreExtraField = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({
  query,
  datasource,
  onChange,
  onRunQuery
}) => {
  var _query$interval;

  const rangeOptions = getQueryTypeOptions(true);
  const prevQuery = (0,react_use__WEBPACK_IMPORTED_MODULE_6__["default"])(query);
  const onExemplarChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(exemplar => {
    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_1__.isEqual)(query, prevQuery) || exemplar !== query.exemplar) {
      onChange(Object.assign({}, query, {
        exemplar
      }));
    }
  }, [prevQuery, query, onChange]);

  function onChangeQueryStep(interval) {
    onChange(Object.assign({}, query, {
      interval
    }));
  }

  function onStepChange(e) {
    if (e.currentTarget.value !== query.interval) {
      onChangeQueryStep(e.currentTarget.value);
    }
  }

  function onReturnKeyDown(e) {
    if (e.key === 'Enter' && e.shiftKey) {
      onRunQuery();
    }
  }

  const onQueryTypeChange = getQueryTypeChangeHandler(query, onChange);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    "aria-label": "Prometheus extra field",
    className: "gf-form-inline",
    "data-testid": testIds.extraFieldEditor,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
      "data-testid": testIds.queryTypeField,
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.cx)('gf-form explore-input-margin', _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
              flex-wrap: nowrap;
            `),
      "aria-label": "Query type field",
      children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
        width: "auto",
        children: "Query type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.RadioButtonGroup, {
        options: rangeOptions,
        value: query.range && query.instant ? 'both' : query.instant ? 'instant' : 'range',
        onChange: onQueryTypeChange
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
      "data-testid": testIds.stepField,
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.cx)('gf-form', _emotion_css__WEBPACK_IMPORTED_MODULE_2__.css`
              flex-wrap: nowrap;
            `),
      "aria-label": "Step field",
      children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineFormLabel, {
        width: 6,
        tooltip: 'Time units and built-in variables can be used here, for example: $__interval, $__rate_interval, 5s, 1m, 3h, 1d, 1y (Default if no unit is specified: s)',
        children: "Min step"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("input", {
        type: 'text',
        className: "gf-form-input width-4",
        placeholder: 'auto',
        onChange: onStepChange,
        onKeyDown: onReturnKeyDown,
        value: (_query$interval = query.interval) !== null && _query$interval !== void 0 ? _query$interval : ''
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_PromExemplarField__WEBPACK_IMPORTED_MODULE_4__.PromExemplarField, {
      onChange: onExemplarChange,
      datasource: datasource,
      query: query
    })]
  });
});
PromExploreExtraField.displayName = 'PromExploreExtraField';
function getQueryTypeOptions(includeBoth) {
  const rangeOptions = [{
    value: 'range',
    label: 'Range',
    description: 'Run query over a range of time'
  }, {
    value: 'instant',
    label: 'Instant',
    description: 'Run query against a single point in time. For this query, the "To" time is used'
  }];

  if (includeBoth) {
    rangeOptions.push({
      value: 'both',
      label: 'Both',
      description: 'Run an Instant query and a Range query'
    });
  }

  return rangeOptions;
}
function getQueryTypeChangeHandler(query, onChange) {
  return queryType => {
    if (queryType === 'instant') {
      onChange(Object.assign({}, query, {
        instant: true,
        range: false,
        exemplar: false
      }));
    } else if (queryType === 'range') {
      onChange(Object.assign({}, query, {
        instant: false,
        range: true
      }));
    } else {
      onChange(Object.assign({}, query, {
        instant: true,
        range: true
      }));
    }
  };
}
const testIds = {
  extraFieldEditor: 'prom-editor-extra-field',
  stepField: 'prom-editor-extra-field-step',
  queryTypeField: 'prom-editor-extra-field-query-type'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromExploreQueryEditor": () => (/* binding */ PromExploreQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var _PromExploreExtraField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const PromExploreQueryEditor = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(props => {
  const {
    range,
    query,
    data,
    datasource,
    history,
    onChange,
    onRunQuery
  } = props; // Setting default values

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (query.expr === undefined) {
      onChange(Object.assign({}, query, {
        expr: ''
      }));
    }

    if (query.exemplar === undefined) {
      onChange(Object.assign({}, query, {
        exemplar: true
      }));
    } // Override query type to "Both" only for new queries (no query.expr).


    if (!query.instant && !query.range && !query.expr) {
      onChange(Object.assign({}, query, {
        instant: true,
        range: true
      }));
    }
  }, [onChange, query]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_2__["default"], {
    app: _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore,
    datasource: datasource,
    query: query,
    range: range,
    onRunQuery: onRunQuery,
    onChange: onChange,
    onBlur: () => {},
    history: history,
    data: data,
    "data-testid": testIds.editor,
    ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_3__.PromExploreExtraField, {
      query: query,
      onChange: onChange,
      datasource: datasource,
      onRunQuery: onRunQuery
    })
  });
});
PromExploreQueryEditor.displayName = 'PromExploreQueryEditor';
const testIds = {
  editor: 'prom-editor-explore'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromLink.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const PromLink = ({
  panelData,
  query,
  datasource
}) => {
  const [href, setHref] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    if (panelData) {
      const getExternalLink = () => {
        if (!panelData.request) {
          return '';
        }

        const {
          request: {
            range,
            interval,
            scopedVars
          }
        } = panelData;
        const start = datasource.getPrometheusTime(range.from, false);
        const end = datasource.getPrometheusTime(range.to, true);
        const rangeDiff = Math.ceil(end - start);
        const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');
        const enrichedScopedVars = Object.assign({}, scopedVars, datasource.getRateIntervalScopedVariable(_grafana_data__WEBPACK_IMPORTED_MODULE_2__.rangeUtil.intervalToSeconds(interval), _grafana_data__WEBPACK_IMPORTED_MODULE_2__.rangeUtil.intervalToSeconds(datasource.interval)));
        const options = {
          interval,
          scopedVars: enrichedScopedVars
        };
        const customQueryParameters = {};

        if (datasource.customQueryParameters) {
          for (const [k, v] of datasource.customQueryParameters) {
            customQueryParameters[k] = v;
          }
        }

        const queryOptions = datasource.createQuery(query, options, start, end);
        const expr = Object.assign({}, customQueryParameters, {
          'g0.expr': queryOptions.expr,
          'g0.range_input': rangeDiff + 's',
          'g0.end_input': endTime,
          'g0.step_input': queryOptions.step,
          'g0.tab': 0
        });
        const args = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(expr, (v, k) => {
          return k + '=' + encodeURIComponent(v);
        }).join('&');
        return `${datasource.directUrl}/graph?${args}`;
      };

      setHref(getExternalLink());
    }
  }, [datasource, panelData, query]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)("a", {
    href: _grafana_data__WEBPACK_IMPORTED_MODULE_2__.textUtil.sanitizeUrl(href),
    target: "_blank",
    rel: "noopener noreferrer",
    children: "Prometheus"
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(PromLink));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FORMAT_OPTIONS": () => (/* binding */ FORMAT_OPTIONS),
/* harmony export */   "INTERVAL_FACTOR_OPTIONS": () => (/* binding */ INTERVAL_FACTOR_OPTIONS),
/* harmony export */   "PromQueryEditor": () => (/* binding */ PromQueryEditor),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var _PromLink__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromLink.tsx");
/* harmony import */ var _PromExemplarField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExemplarField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2, _div, _div2;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // Types









const {
  Switch
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_2__.LegacyForms;
const FORMAT_OPTIONS = [{
  label: 'Time series',
  value: 'time_series'
}, {
  label: 'Table',
  value: 'table'
}, {
  label: 'Heatmap',
  value: 'heatmap'
}];
const INTERVAL_FACTOR_OPTIONS = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)([1, 2, 3, 4, 5, 10], value => ({
  value,
  label: '1/' + value
}));
class PromQueryEditor extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {
  // Query target to be modified and used for queries
  constructor(props) {
    super(props); // Use default query to prevent undefined input values

    _defineProperty(this, "query", void 0);

    _defineProperty(this, "onFieldChange", (query, override) => {
      this.query.expr = query.expr;
    });

    _defineProperty(this, "onFormatChange", option => {
      this.query.format = option.value;
      this.setState({
        formatOption: option
      }, this.onRunQuery);
    });

    _defineProperty(this, "onInstantChange", e => {
      const instant = e.target.checked;
      this.query.instant = instant;
      this.setState({
        instant
      }, this.onRunQuery);
    });

    _defineProperty(this, "onIntervalChange", e => {
      const interval = e.currentTarget.value;
      this.query.interval = interval;
      this.setState({
        interval
      });
    });

    _defineProperty(this, "onIntervalFactorChange", option => {
      this.query.intervalFactor = option.value;
      this.setState({
        intervalFactorOption: option
      }, this.onRunQuery);
    });

    _defineProperty(this, "onLegendChange", e => {
      const legendFormat = e.currentTarget.value;
      this.query.legendFormat = legendFormat;
      this.setState({
        legendFormat
      });
    });

    _defineProperty(this, "onExemplarChange", isEnabled => {
      this.query.exemplar = isEnabled;
      this.setState({
        exemplar: isEnabled
      }, this.onRunQuery);
    });

    _defineProperty(this, "onRunQuery", () => {
      const {
        query
      } = this; // Change of query.hide happens outside of this component and is just passed as prop. We have to update it when running queries.

      const {
        hide
      } = this.props.query;
      this.props.onChange(Object.assign({}, query, {
        hide
      }));
      this.props.onRunQuery();
    });

    const defaultQuery = {
      expr: '',
      legendFormat: '',
      interval: '',
      // Set exemplar to false for alerting queries
      exemplar: props.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.UnifiedAlerting ? false : true
    };

    const _query = Object.assign({}, defaultQuery, props.query);

    this.query = _query; // Query target properties that are fully controlled inputs

    this.state = {
      // Fully controlled text inputs
      interval: _query.interval,
      legendFormat: _query.legendFormat,
      // Select options
      formatOption: FORMAT_OPTIONS.find(option => option.value === _query.format) || FORMAT_OPTIONS[0],
      intervalFactorOption: INTERVAL_FACTOR_OPTIONS.find(option => option.value === _query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],
      // Switch options
      instant: Boolean(_query.instant),
      exemplar: Boolean(_query.exemplar)
    };
  }

  render() {
    const {
      datasource,
      query,
      range,
      data
    } = this.props;
    const {
      formatOption,
      instant,
      interval,
      intervalFactorOption,
      legendFormat
    } = this.state; //We want to hide exemplar field for unified alerting as exemplars in alerting don't make sense and are source of confusion

    const showExemplarField = this.props.app !== _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.UnifiedAlerting;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_4__["default"], {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: this.onRunQuery,
      onChange: this.onFieldChange,
      history: [],
      data: data,
      "data-testid": testIds.editor,
      ExtraFieldElement: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: "gf-form-inline",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFormLabel, {
            width: 7,
            tooltip: "Controls the name of the time series, using name or pattern. For example {{hostname}} will be replaced with label value for the label hostname.",
            children: "Legend"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("input", {
            type: "text",
            className: "gf-form-input",
            placeholder: "legend format",
            value: legendFormat,
            onChange: this.onLegendChange,
            onBlur: this.onRunQuery
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFormLabel, {
            width: 7,
            tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
              children: ["An additional lower limit for the step parameter of the Prometheus query and for the", ' ', /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("code", {
                children: "$__interval"
              }), " and ", /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("code", {
                children: "$__rate_interval"
              }), " variables. The limit is absolute and not modified by the \"Resolution\" setting."]
            }),
            children: "Min step"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("input", {
            type: "text",
            className: "gf-form-input width-8",
            "aria-label": "Set lower limit for the step parameter",
            placeholder: interval,
            onChange: this.onIntervalChange,
            onBlur: this.onRunQuery,
            value: interval
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
            className: "gf-form-label",
            children: "Resolution"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
            "aria-label": "Select resolution",
            menuShouldPortal: true,
            isSearchable: false,
            options: INTERVAL_FACTOR_OPTIONS,
            onChange: this.onIntervalFactorChange,
            value: intervalFactorOption
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
          className: "gf-form",
          children: [_div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
            className: "gf-form-label width-7",
            children: "Format"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
            menuShouldPortal: true,
            className: "select-container",
            width: 16,
            isSearchable: false,
            options: FORMAT_OPTIONS,
            onChange: this.onFormatChange,
            value: formatOption,
            "aria-label": "Select format"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Switch, {
            label: "Instant",
            checked: instant,
            onChange: this.onInstantChange
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.InlineFormLabel, {
            width: 10,
            tooltip: "Link to Graph in Prometheus",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromLink__WEBPACK_IMPORTED_MODULE_5__["default"], {
              datasource: datasource,
              query: this.query // Use modified query
              ,
              panelData: data
            })
          })]
        }), showExemplarField && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromExemplarField__WEBPACK_IMPORTED_MODULE_6__.PromExemplarField, {
          onChange: this.onExemplarChange,
          datasource: datasource,
          query: this.query,
          "data-testid": testIds.exemplar
        })]
      })
    });
  }

}
const testIds = {
  editor: 'prom-editor',
  exemplar: 'exemplar-editor'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditorByApp.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorByApp": () => (/* binding */ PromQueryEditorByApp),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _PromQueryEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _PromQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditorForAlerting.tsx");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryEditorSelector.tsx");
/* harmony import */ var _PromExploreQueryEditor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function PromQueryEditorByApp(props) {
  const {
    app
  } = props;

  switch (app) {
    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.CloudAlerting:
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryEditorForAlerting__WEBPACK_IMPORTED_MODULE_3__.PromQueryEditorForAlerting, Object.assign({}, props));

    case _grafana_data__WEBPACK_IMPORTED_MODULE_1__.CoreApp.Explore:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.config.featureToggles.promQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_5__.PromQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromExploreQueryEditor__WEBPACK_IMPORTED_MODULE_6__.PromExploreQueryEditor, Object.assign({}, props));

    default:
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.config.featureToggles.promQueryBuilder) {
        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_querybuilder_components_PromQueryEditorSelector__WEBPACK_IMPORTED_MODULE_5__.PromQueryEditorSelector, Object.assign({}, props));
      }

      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromQueryEditor__WEBPACK_IMPORTED_MODULE_2__.PromQueryEditor, Object.assign({}, props));
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(PromQueryEditorByApp));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryEditorForAlerting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorForAlerting": () => (/* binding */ PromQueryEditorForAlerting),
/* harmony export */   "testIds": () => (/* binding */ testIds)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _PromQueryField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");



function PromQueryEditorForAlerting(props) {
  const {
    datasource,
    query,
    range,
    data,
    onChange,
    onRunQuery
  } = props;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_PromQueryField__WEBPACK_IMPORTED_MODULE_1__["default"], {
    datasource: datasource,
    query: query,
    onRunQuery: onRunQuery,
    onChange: onChange,
    history: [],
    range: range,
    data: data,
    "data-testid": testIds.editor
  });
}
const testIds = {
  editor: 'prom-editor-cloud-alerting'
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RECORDING_RULES_GROUP": () => (/* binding */ RECORDING_RULES_GROUP),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "willApplySuggestion": () => (/* binding */ willApplySuggestion)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var app_core_utils_CancelablePromise__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/core/utils/CancelablePromise.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _PrometheusMetricsBrowser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PrometheusMetricsBrowser.tsx");
/* harmony import */ var _monaco_query_field_MonacoQueryFieldWrapper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldWrapper.tsx");
/* harmony import */ var app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/core/components/LocalStorageValueProvider/index.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // dom also includes Element polyfills










const RECORDING_RULES_GROUP = '__recording_rules__';
const LAST_USED_LABELS_KEY = 'grafana.datasources.prometheus.browser.labels';

function getChooserText(metricsLookupDisabled, hasSyntax, hasMetrics) {
  if (metricsLookupDisabled) {
    return '(Disabled)';
  }

  if (!hasSyntax) {
    return 'Loading metrics...';
  }

  if (!hasMetrics) {
    return '(No metrics found)';
  }

  return 'Metrics browser';
}

function willApplySuggestion(suggestion, {
  typeaheadContext,
  typeaheadText
}) {
  // Modify suggestion based on context
  switch (typeaheadContext) {
    case 'context-labels':
      {
        const nextChar = _grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DOMUtil.getNextCharacter();

        if (!nextChar || nextChar === '}' || nextChar === ',') {
          suggestion += '=';
        }

        break;
      }

    case 'context-label-values':
      {
        // Always add quotes and remove existing ones instead
        if (!typeaheadText.match(/^(!?=~?"|")/)) {
          suggestion = `"${suggestion}`;
        }

        if (_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DOMUtil.getNextCharacter() !== '"') {
          suggestion = `${suggestion}"`;
        }

        break;
      }

    default:
  }

  return suggestion;
}

class PromQueryField extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor(props, context) {
    super(props, context);

    _defineProperty(this, "plugins", void 0);

    _defineProperty(this, "refreshHint", () => {
      const {
        datasource,
        query,
        data
      } = this.props;
      const initHints = datasource.getInitHints();
      const initHint = initHints.length > 0 ? initHints[0] : null;

      if (!data || data.series.length === 0) {
        this.setState({
          hint: initHint
        });
        return;
      }

      const result = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_5__.isDataFrame)(data.series[0]) ? data.series.map(_grafana_data__WEBPACK_IMPORTED_MODULE_5__.toLegacyResponseData) : data.series;
      const queryHints = datasource.getQueryHints(query, result);
      let queryHint = queryHints.length > 0 ? queryHints[0] : null;
      this.setState({
        hint: queryHint !== null && queryHint !== void 0 ? queryHint : initHint
      });
    });

    _defineProperty(this, "refreshMetrics", async () => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;
      this.languageProviderInitializationPromise = (0,app_core_utils_CancelablePromise__WEBPACK_IMPORTED_MODULE_4__.makePromiseCancelable)(languageProvider.start());

      try {
        const remainingTasks = await this.languageProviderInitializationPromise.promise;
        await Promise.all(remainingTasks);
        this.onUpdateLanguage();
      } catch (err) {
        if (!err.isCanceled) {
          throw err;
        }
      }
    });

    _defineProperty(this, "onChangeLabelBrowser", selector => {
      this.onChangeQuery(selector, true);
      this.setState({
        labelBrowserVisible: false
      });
    });

    _defineProperty(this, "onChangeQuery", (value, override) => {
      // Send text change to parent
      const {
        query,
        onChange,
        onRunQuery
      } = this.props;

      if (onChange) {
        const nextQuery = Object.assign({}, query, {
          expr: value
        });
        onChange(nextQuery);

        if (override && onRunQuery) {
          onRunQuery();
        }
      }
    });

    _defineProperty(this, "onClickChooserButton", () => {
      this.setState(state => ({
        labelBrowserVisible: !state.labelBrowserVisible
      }));
    });

    _defineProperty(this, "onClickHintFix", () => {
      const {
        datasource,
        query,
        onChange,
        onRunQuery
      } = this.props;
      const {
        hint
      } = this.state;
      onChange(datasource.modifyQuery(query, hint.fix.action));
      onRunQuery();
    });

    _defineProperty(this, "onUpdateLanguage", () => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;
      const {
        metrics
      } = languageProvider;

      if (!metrics) {
        return;
      }

      this.setState({
        syntaxLoaded: true
      });
    });

    _defineProperty(this, "onTypeahead", async typeahead => {
      const {
        datasource: {
          languageProvider
        }
      } = this.props;

      if (!languageProvider) {
        return {
          suggestions: []
        };
      }

      const {
        history
      } = this.props;
      const {
        prefix,
        text,
        value,
        wrapperClasses,
        labelKey
      } = typeahead;
      const result = await languageProvider.provideCompletionItems({
        text,
        value,
        prefix,
        wrapperClasses,
        labelKey
      }, {
        history
      });
      return result;
    });

    this.plugins = [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BracesPlugin)(), (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.SlatePrism)({
      onlyIn: node => node.type === 'code_block',
      getSyntax: node => 'promql'
    }, Object.assign({}, prismjs__WEBPACK_IMPORTED_MODULE_2__.languages, {
      promql: this.props.datasource.languageProvider.syntax
    }))];
    this.state = {
      labelBrowserVisible: false,
      syntaxLoaded: false,
      hint: null
    };
  }

  componentDidMount() {
    if (this.props.datasource.languageProvider) {
      this.refreshMetrics();
    }

    this.refreshHint();
  }

  componentWillUnmount() {
    if (this.languageProviderInitializationPromise) {
      this.languageProviderInitializationPromise.cancel();
    }
  }

  componentDidUpdate(prevProps) {
    const {
      data,
      datasource: {
        languageProvider
      },
      range
    } = this.props;

    if (languageProvider !== prevProps.datasource.languageProvider) {
      // We reset this only on DS change so we do not flesh loading state on every rangeChange which happens on every
      // query run if using relative range.
      this.setState({
        syntaxLoaded: false
      });
    }

    const changedRangeToRefresh = this.rangeChangedToRefresh(range, prevProps.range); // We want to refresh metrics when language provider changes and/or when range changes (we round up intervals to a minute)

    if (languageProvider !== prevProps.datasource.languageProvider || changedRangeToRefresh) {
      this.refreshMetrics();
    }

    if (data && prevProps.data && prevProps.data.series !== data.series) {
      this.refreshHint();
    }
  }

  rangeChangedToRefresh(range, prevRange) {
    if (range && prevRange) {
      const sameMinuteFrom = (0,_language_utils__WEBPACK_IMPORTED_MODULE_3__.roundMsToMin)(range.from.valueOf()) === (0,_language_utils__WEBPACK_IMPORTED_MODULE_3__.roundMsToMin)(prevRange.from.valueOf());
      const sameMinuteTo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_3__.roundMsToMin)(range.to.valueOf()) === (0,_language_utils__WEBPACK_IMPORTED_MODULE_3__.roundMsToMin)(prevRange.to.valueOf()); // If both are same, don't need to refresh.

      return !(sameMinuteFrom && sameMinuteTo);
    }

    return false;
  }
  /**
   * TODO #33976: Remove this, add histogram group (query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;)
   */


  render() {
    const {
      datasource,
      datasource: {
        languageProvider
      },
      query,
      ExtraFieldElement,
      history = []
    } = this.props;
    const {
      labelBrowserVisible,
      syntaxLoaded,
      hint
    } = this.state;
    const hasMetrics = languageProvider.metrics.length > 0;
    const chooserText = getChooserText(datasource.lookupsDisabled, syntaxLoaded, hasMetrics);
    const buttonDisabled = !(syntaxLoaded && hasMetrics);
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(app_core_components_LocalStorageValueProvider__WEBPACK_IMPORTED_MODULE_8__.LocalStorageValueProvider, {
      storageKey: LAST_USED_LABELS_KEY,
      defaultValue: [],
      children: (lastUsedLabels, onLastUsedLabelsSave, onLastUsedLabelsDelete) => {
        var _query$expr;

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.Fragment, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
            className: "gf-form-inline gf-form-inline--xs-view-flex-column flex-grow-1",
            "data-testid": this.props['data-testid'],
            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("button", {
              className: "gf-form-label query-keyword pointer",
              onClick: this.onClickChooserButton,
              disabled: buttonDisabled,
              children: [chooserText, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Icon, {
                name: labelBrowserVisible ? 'angle-down' : 'angle-right'
              })]
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
              className: "gf-form gf-form--grow flex-shrink-1 min-width-15",
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_monaco_query_field_MonacoQueryFieldWrapper__WEBPACK_IMPORTED_MODULE_7__.MonacoQueryFieldWrapper, {
                runQueryOnBlur: this.props.app !== _grafana_data__WEBPACK_IMPORTED_MODULE_5__.CoreApp.Explore,
                languageProvider: languageProvider,
                history: history,
                onChange: this.onChangeQuery,
                onRunQuery: this.props.onRunQuery,
                initialValue: (_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : ''
              })
            })]
          }), labelBrowserVisible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "gf-form",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_PrometheusMetricsBrowser__WEBPACK_IMPORTED_MODULE_6__.PrometheusMetricsBrowser, {
              languageProvider: languageProvider,
              onChange: this.onChangeLabelBrowser,
              lastUsedLabels: lastUsedLabels || [],
              storeLastUsedLabels: onLastUsedLabelsSave,
              deleteLastUsedLabels: onLastUsedLabelsDelete
            })
          }), ExtraFieldElement, hint ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("div", {
            className: "query-row-break",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)("div", {
              className: "prom-query-field-info text-warning",
              children: [hint.label, ' ', hint.fix ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("a", {
                className: "text-link muted",
                onClick: this.onClickHintFix,
                children: hint.fix.label
              }) : null]
            })
          }) : null]
        });
      }
    });
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PromQueryField);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/PrometheusMetricsBrowser.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusMetricsBrowser": () => (/* binding */ PrometheusMetricsBrowser),
/* harmony export */   "UnthemedPrometheusMetricsBrowser": () => (/* binding */ UnthemedPrometheusMetricsBrowser),
/* harmony export */   "buildSelector": () => (/* binding */ buildSelector),
/* harmony export */   "facetLabels": () => (/* binding */ facetLabels)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react_window__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-window-virtual-0f9a8c6a67/0/cache/react-window-npm-1.8.6-4f5a230226-54ccf2b16c.zip/node_modules/react-window/dist/index.esm.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _LoadingPlaceholder, _Label, _Label2, _Label3, _Label4;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








// Hard limit on labels to render
const EMPTY_SELECTOR = '{}';
const METRIC_LABEL = '__name__';
const LIST_ITEM_SIZE = 25;
function buildSelector(labels) {
  let singleMetric = '';
  const selectedLabels = [];

  for (const label of labels) {
    if ((label.name === METRIC_LABEL || label.selected) && label.values && label.values.length > 0) {
      const selectedValues = label.values.filter(value => value.selected).map(value => value.name);

      if (selectedValues.length > 1) {
        selectedLabels.push(`${label.name}=~"${selectedValues.map(_language_utils__WEBPACK_IMPORTED_MODULE_2__.escapeLabelValueInRegexSelector).join('|')}"`);
      } else if (selectedValues.length === 1) {
        if (label.name === METRIC_LABEL) {
          singleMetric = selectedValues[0];
        } else {
          selectedLabels.push(`${label.name}="${(0,_language_utils__WEBPACK_IMPORTED_MODULE_2__.escapeLabelValueInExactSelector)(selectedValues[0])}"`);
        }
      }
    }
  }

  return [singleMetric, '{', selectedLabels.join(','), '}'].join('');
}
function facetLabels(labels, possibleLabels, lastFacetted) {
  return labels.map(label => {
    const possibleValues = possibleLabels[label.name];

    if (possibleValues) {
      let existingValues;

      if (label.name === lastFacetted && label.values) {
        // Facetting this label, show all values
        existingValues = label.values;
      } else {
        var _label$values;

        // Keep selection in other facets
        const selectedValues = new Set(((_label$values = label.values) === null || _label$values === void 0 ? void 0 : _label$values.filter(value => value.selected).map(value => value.name)) || []); // Values for this label have not been requested yet, let's use the facetted ones as the initial values

        existingValues = possibleValues.map(value => ({
          name: value,
          selected: selectedValues.has(value)
        }));
      }

      return Object.assign({}, label, {
        loading: false,
        values: existingValues,
        hidden: !possibleValues,
        facets: existingValues.length
      });
    } // Label is facetted out, hide all values


    return Object.assign({}, label, {
      loading: false,
      hidden: !possibleValues,
      values: undefined,
      facets: 0
    });
  });
}
const getStyles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.stylesFactory)(theme => ({
  wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    background-color: ${theme.colors.bg2};
    padding: ${theme.spacing.sm};
    width: 100%;
  `,
  list: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    margin-top: ${theme.spacing.sm};
    display: flex;
    flex-wrap: wrap;
    max-height: 200px;
    overflow: auto;
    align-content: flex-start;
  `,
  section: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    & + & {
      margin: ${theme.spacing.md} 0;
    }
    position: relative;
  `,
  selector: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    font-family: ${theme.typography.fontFamily.monospace};
    margin-bottom: ${theme.spacing.sm};
  `,
  status: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    padding: ${theme.spacing.xs};
    color: ${theme.colors.textSemiWeak};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* using absolute positioning because flex interferes with ellipsis */
    position: absolute;
    width: 50%;
    right: 0;
    text-align: right;
    transition: opacity 100ms linear;
    opacity: 0;
  `,
  statusShowing: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    opacity: 1;
  `,
  error: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    color: ${theme.palette.brandDanger};
  `,
  valueList: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    margin-right: ${theme.spacing.sm};
  `,
  valueListWrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    border-left: 1px solid ${theme.colors.border2};
    margin: ${theme.spacing.sm} 0;
    padding: ${theme.spacing.sm} 0 ${theme.spacing.sm} ${theme.spacing.sm};
  `,
  valueListArea: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    display: flex;
    flex-wrap: wrap;
    margin-top: ${theme.spacing.sm};
  `,
  valueTitle: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    margin-left: -${theme.spacing.xs};
    margin-bottom: ${theme.spacing.sm};
  `,
  validationStatus: _emotion_css__WEBPACK_IMPORTED_MODULE_3__.css`
    padding: ${theme.spacing.xs};
    margin-bottom: ${theme.spacing.sm};
    color: ${theme.colors.textStrong};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  `
}));
/**
 * TODO #33976: Remove duplicated code. The component is very similar to LokiLabelBrowser.tsx. Check if it's possible
 *              to create a single, generic component.
 */

class UnthemedPrometheusMetricsBrowser extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "valueListsRef", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createRef());

    _defineProperty(this, "state", {
      labels: [],
      labelSearchTerm: '',
      metricSearchTerm: '',
      status: 'Ready',
      error: '',
      validationStatus: '',
      valueSearchTerm: ''
    });

    _defineProperty(this, "onChangeLabelSearch", event => {
      this.setState({
        labelSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onChangeMetricSearch", event => {
      this.setState({
        metricSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onChangeValueSearch", event => {
      this.setState({
        valueSearchTerm: event.target.value
      });
    });

    _defineProperty(this, "onClickRunQuery", () => {
      const selector = buildSelector(this.state.labels);
      this.props.onChange(selector);
    });

    _defineProperty(this, "onClickRunRateQuery", () => {
      const selector = buildSelector(this.state.labels);
      const query = `rate(${selector}[$__interval])`;
      this.props.onChange(query);
    });

    _defineProperty(this, "onClickClear", () => {
      this.setState(state => {
        const labels = state.labels.map(label => Object.assign({}, label, {
          values: undefined,
          selected: false,
          loading: false,
          hidden: false,
          facets: undefined
        }));
        return {
          labels,
          labelSearchTerm: '',
          metricSearchTerm: '',
          status: '',
          error: '',
          validationStatus: '',
          valueSearchTerm: ''
        };
      });
      this.props.deleteLastUsedLabels(); // Get metrics

      this.fetchValues(METRIC_LABEL, EMPTY_SELECTOR);
    });

    _defineProperty(this, "onClickLabel", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label) {
        return;
      } // Toggle selected state


      const selected = !label.selected;
      let nextValue = {
        selected
      };

      if (label.values && !selected) {
        // Deselect all values if label was deselected
        const values = label.values.map(value => Object.assign({}, value, {
          selected: false
        }));
        nextValue = Object.assign({}, nextValue, {
          facets: 0,
          values
        });
      } // Resetting search to prevent empty results


      this.setState({
        labelSearchTerm: ''
      });
      this.updateLabelState(name, nextValue, '', () => this.doFacettingForLabel(name));
    });

    _defineProperty(this, "onClickValue", (name, value, event) => {
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        labelSearchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value ? !v.selected : v.selected
      }));
      this.updateLabelState(name, {
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickMetric", (name, value, event) => {
      // Finding special metric label
      const label = this.state.labels.find(l => l.name === name);

      if (!label || !label.values) {
        return;
      } // Resetting search to prevent empty results


      this.setState({
        metricSearchTerm: ''
      }); // Toggling value for selected label, leaving other values intact

      const values = label.values.map(v => Object.assign({}, v, {
        selected: v.name === value || v.selected ? !v.selected : v.selected
      })); // Toggle selected state of special metrics label

      const selected = values.some(v => v.selected);
      this.updateLabelState(name, {
        selected,
        values
      }, '', () => this.doFacetting(name));
    });

    _defineProperty(this, "onClickValidate", () => {
      const selector = buildSelector(this.state.labels);
      this.validateSelector(selector);
    });

    _defineProperty(this, "doFacetting", lastFacetted => {
      const selector = buildSelector(this.state.labels);

      if (selector === EMPTY_SELECTOR) {
        // Clear up facetting
        const labels = this.state.labels.map(label => {
          return Object.assign({}, label, {
            facets: 0,
            values: undefined,
            hidden: false
          });
        });
        this.setState({
          labels
        }, () => {
          // Get fresh set of values
          this.state.labels.forEach(label => (label.selected || label.name === METRIC_LABEL) && this.fetchValues(label.name, selector));
        });
      } else {
        // Do facetting
        this.fetchSeries(selector, lastFacetted);
      }
    });
  }

  updateLabelState(name, updatedFields, status = '', cb) {
    this.setState(state => {
      const labels = state.labels.map(label => {
        if (label.name === name) {
          return Object.assign({}, label, updatedFields);
        }

        return label;
      }); // New status overrides errors

      const error = status ? '' : state.error;
      return {
        labels,
        status,
        error,
        validationStatus: ''
      };
    }, cb);
  }

  componentDidMount() {
    const {
      languageProvider,
      lastUsedLabels
    } = this.props;

    if (languageProvider) {
      const selectedLabels = lastUsedLabels;
      languageProvider.start().then(() => {
        let rawLabels = languageProvider.getLabelKeys(); // Get metrics

        this.fetchValues(METRIC_LABEL, EMPTY_SELECTOR); // Auto-select previously selected labels

        const labels = rawLabels.map((label, i, arr) => ({
          name: label,
          selected: selectedLabels.includes(label),
          loading: false
        })); // Pre-fetch values for selected labels

        this.setState({
          labels
        }, () => {
          this.state.labels.forEach(label => {
            if (label.selected) {
              this.fetchValues(label.name, EMPTY_SELECTOR);
            }
          });
        });
      });
    }
  }

  doFacettingForLabel(name) {
    const label = this.state.labels.find(l => l.name === name);

    if (!label) {
      return;
    }

    const selectedLabels = this.state.labels.filter(label => label.selected).map(label => label.name);
    this.props.storeLastUsedLabels(selectedLabels);

    if (label.selected) {
      // Refetch values for newly selected label...
      if (!label.values) {
        this.fetchValues(name, buildSelector(this.state.labels));
      }
    } else {
      // Only need to facet when deselecting labels
      this.doFacetting();
    }
  }

  async fetchValues(name, selector) {
    const {
      languageProvider
    } = this.props;
    this.updateLabelState(name, {
      loading: true
    }, `Fetching values for ${name}`);

    try {
      let rawValues = await languageProvider.getLabelValues(name); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        this.updateLabelState(name, {
          loading: false
        });
        return;
      }

      const values = [];
      const {
        metricsMetadata
      } = languageProvider;

      for (const labelValue of rawValues) {
        const value = {
          name: labelValue
        }; // Adding type/help text to metrics

        if (name === METRIC_LABEL && metricsMetadata) {
          const meta = metricsMetadata[labelValue];

          if (meta) {
            value.details = `(${meta.type}) ${meta.help}`;
          }
        }

        values.push(value);
      }

      this.updateLabelState(name, {
        values,
        loading: false
      });
    } catch (error) {
      console.error(error);
    }
  }

  async fetchSeries(selector, lastFacetted) {
    const {
      languageProvider
    } = this.props;

    if (lastFacetted) {
      this.updateLabelState(lastFacetted, {
        loading: true
      }, `Facetting labels for ${selector}`);
    }

    try {
      const possibleLabels = await languageProvider.fetchSeriesLabels(selector, true); // If selector changed, clear loading state and discard result by returning early

      if (selector !== buildSelector(this.state.labels)) {
        if (lastFacetted) {
          this.updateLabelState(lastFacetted, {
            loading: false
          });
        }

        return;
      }

      if (Object.keys(possibleLabels).length === 0) {
        this.setState({
          error: `Empty results, no matching label for ${selector}`
        });
        return;
      }

      const labels = facetLabels(this.state.labels, possibleLabels, lastFacetted);
      this.setState({
        labels,
        error: ''
      });

      if (lastFacetted) {
        this.updateLabelState(lastFacetted, {
          loading: false
        });
      }
    } catch (error) {
      console.error(error);
    }
  }

  async validateSelector(selector) {
    const {
      languageProvider
    } = this.props;
    this.setState({
      validationStatus: `Validating selector ${selector}`,
      error: ''
    });
    const streams = await languageProvider.fetchSeries(selector);
    this.setState({
      validationStatus: `Selector is valid (${streams.length} series found)`
    });
  }

  render() {
    var _metrics, _metrics$values2;

    const {
      theme
    } = this.props;
    const {
      labels,
      labelSearchTerm,
      metricSearchTerm,
      status,
      error,
      validationStatus,
      valueSearchTerm
    } = this.state;
    const styles = getStyles(theme);

    if (labels.length === 0) {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.wrapper,
        children: _LoadingPlaceholder || (_LoadingPlaceholder = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.LoadingPlaceholder, {
          text: "Loading labels..."
        }))
      });
    } // Filter metrics


    let metrics = labels.find(label => label.name === METRIC_LABEL);

    if (metrics && metricSearchTerm) {
      var _metrics$values;

      metrics = Object.assign({}, metrics, {
        values: (_metrics$values = metrics.values) === null || _metrics$values === void 0 ? void 0 : _metrics$values.filter(value => value.selected || value.name.includes(metricSearchTerm))
      });
    } // Filter labels


    let nonMetricLabels = labels.filter(label => !label.hidden && label.name !== METRIC_LABEL);

    if (labelSearchTerm) {
      nonMetricLabels = nonMetricLabels.filter(label => label.selected || label.name.includes(labelSearchTerm));
    } // Filter non-metric label values


    let selectedLabels = nonMetricLabels.filter(label => label.selected && label.values);

    if (valueSearchTerm) {
      selectedLabels = selectedLabels.map(label => {
        var _label$values2;

        return Object.assign({}, label, {
          values: (_label$values2 = label.values) === null || _label$values2 === void 0 ? void 0 : _label$values2.filter(value => value.selected || value.name.includes(valueSearchTerm))
        });
      });
    }

    const selector = buildSelector(this.state.labels);
    const empty = selector === EMPTY_SELECTOR;
    const metricCount = ((_metrics = metrics) === null || _metrics === void 0 ? void 0 : (_metrics$values2 = _metrics.values) === null || _metrics$values2 === void 0 ? void 0 : _metrics$values2.length) || 0;
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.wrapper,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.HorizontalGroup, {
        align: "flex-start",
        spacing: "lg",
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label || (_Label = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Label, {
              description: "Once a metric is selected only possible labels are shown.",
              children: "1. Select a metric"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Input, {
                onChange: this.onChangeMetricSearch,
                "aria-label": "Filter expression for metric",
                value: metricSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              role: "list",
              className: styles.valueListWrapper,
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_5__.FixedSizeList, {
                height: Math.min(450, metricCount * LIST_ITEM_SIZE),
                itemCount: metricCount,
                itemSize: LIST_ITEM_SIZE,
                itemKey: i => metrics.values[i].name,
                width: 300,
                className: styles.valueList,
                children: ({
                  index,
                  style
                }) => {
                  var _metrics2, _metrics2$values;

                  const value = (_metrics2 = metrics) === null || _metrics2 === void 0 ? void 0 : (_metrics2$values = _metrics2.values) === null || _metrics2$values === void 0 ? void 0 : _metrics2$values[index];

                  if (!value) {
                    return null;
                  }

                  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                    style: style,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BrowserLabel, {
                      name: metrics.name,
                      value: value === null || value === void 0 ? void 0 : value.name,
                      title: value.details,
                      active: value === null || value === void 0 ? void 0 : value.selected,
                      onClick: this.onClickMetric,
                      searchTerm: metricSearchTerm
                    })
                  });
                }
              })
            })]
          })
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label2 || (_Label2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Label, {
              description: "Once label values are selected, only possible label combinations are shown.",
              children: "2. Select labels to search in"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Input, {
                onChange: this.onChangeLabelSearch,
                "aria-label": "Filter expression for label",
                value: labelSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              className: styles.list,
              style: {
                height: 120
              },
              children: nonMetricLabels.map(label => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BrowserLabel, {
                name: label.name,
                loading: label.loading,
                active: label.selected,
                hidden: label.hidden,
                facets: label.facets,
                onClick: this.onClickLabel,
                searchTerm: labelSearchTerm
              }, label.name))
            })]
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
            className: styles.section,
            children: [_Label3 || (_Label3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Label, {
              description: "Use the search field to find values across selected labels.",
              children: "3. Select (multiple) values for your labels"
            })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Input, {
                onChange: this.onChangeValueSearch,
                "aria-label": "Filter expression for label values",
                value: valueSearchTerm
              })
            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
              className: styles.valueListArea,
              ref: this.valueListsRef,
              children: selectedLabels.map(label => {
                var _label$values3, _label$values4, _label$values5;

                return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
                  role: "list",
                  "aria-label": `Values for ${label.name}`,
                  className: styles.valueListWrapper,
                  children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                    className: styles.valueTitle,
                    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BrowserLabel, {
                      name: label.name,
                      loading: label.loading,
                      active: label.selected,
                      hidden: label.hidden //If no facets, we want to show number of all label values
                      ,
                      facets: label.facets || ((_label$values3 = label.values) === null || _label$values3 === void 0 ? void 0 : _label$values3.length),
                      onClick: this.onClickLabel
                    })
                  }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_window__WEBPACK_IMPORTED_MODULE_5__.FixedSizeList, {
                    height: Math.min(200, LIST_ITEM_SIZE * (((_label$values4 = label.values) === null || _label$values4 === void 0 ? void 0 : _label$values4.length) || 0)),
                    itemCount: ((_label$values5 = label.values) === null || _label$values5 === void 0 ? void 0 : _label$values5.length) || 0,
                    itemSize: 28,
                    itemKey: i => label.values[i].name,
                    width: 200,
                    className: styles.valueList,
                    children: ({
                      index,
                      style
                    }) => {
                      var _label$values6;

                      const value = (_label$values6 = label.values) === null || _label$values6 === void 0 ? void 0 : _label$values6[index];

                      if (!value) {
                        return null;
                      }

                      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
                        style: style,
                        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.BrowserLabel, {
                          name: label.name,
                          value: value === null || value === void 0 ? void 0 : value.name,
                          active: value === null || value === void 0 ? void 0 : value.selected,
                          onClick: this.onClickValue,
                          searchTerm: valueSearchTerm
                        })
                      });
                    }
                  })]
                }, label.name);
              })
            })]
          })]
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.section,
        children: [_Label4 || (_Label4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Label, {
          children: "4. Resulting selector"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          "aria-label": "selector",
          className: styles.selector,
          children: selector
        }), validationStatus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: styles.validationStatus,
          children: validationStatus
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.HorizontalGroup, {
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
            "aria-label": "Use selector for query button",
            disabled: empty,
            onClick: this.onClickRunQuery,
            children: "Use query"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
            "aria-label": "Use selector as metrics button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickRunRateQuery,
            children: "Use as rate query"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
            "aria-label": "Validate submit button",
            variant: "secondary",
            disabled: empty,
            onClick: this.onClickValidate,
            children: "Validate selector"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Button, {
            "aria-label": "Selector clear button",
            variant: "secondary",
            onClick: this.onClickClear,
            children: "Clear"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
            className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_3__.cx)(styles.status, (status || error) && styles.statusShowing),
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
              className: error ? styles.error : '',
              children: error || status
            })
          })]
        })]
      })]
    });
  }

}
const PrometheusMetricsBrowser = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.withTheme)(UnthemedPrometheusMetricsBrowser);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldLazy.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MonacoQueryFieldLazy": () => (/* binding */ MonacoQueryFieldLazy)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");


const Field = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.lazy(() => __webpack_require__.e(/* import() | prom-query-field */ "prom-query-field").then(__webpack_require__.bind(__webpack_require__, "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryField.tsx")));
const MonacoQueryFieldLazy = props => {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
    fallback: null,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Field, Object.assign({}, props))
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldWrapper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MonacoQueryFieldWrapper": () => (/* binding */ MonacoQueryFieldWrapper)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _MonacoQueryFieldLazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryFieldLazy.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["runQueryOnBlur", "onRunQuery", "onChange"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




const MonacoQueryFieldWrapper = props => {
  const lastRunValueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);

  const {
    runQueryOnBlur,
    onRunQuery,
    onChange
  } = props,
        rest = _objectWithoutPropertiesLoose(props, _excluded);

  const handleRunQuery = value => {
    lastRunValueRef.current = value;
    onChange(value);
    onRunQuery();
  };

  const handleBlur = value => {
    if (runQueryOnBlur) {
      // run handleRunQuery only if the current value is different from the last-time-executed value
      if (value !== lastRunValueRef.current) {
        handleRunQuery(value);
      }
    } else {
      onChange(value);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_MonacoQueryFieldLazy__WEBPACK_IMPORTED_MODULE_1__.MonacoQueryFieldLazy, Object.assign({
    onRunQuery: handleRunQuery,
    onBlur: handleBlur
  }, rest));
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureAuthSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureAuthSettings": () => (/* binding */ AzureAuthSettings),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");
/* harmony import */ var _AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts");
/* harmony import */ var _AzureCredentialsForm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsForm.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h, _h2, _InlineFormLabel;










const AzureAuthSettings = props => {
  const {
    dataSourceConfig,
    onChange
  } = props;
  const credentials = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__.getCredentials)(dataSourceConfig), [dataSourceConfig]);

  const onCredentialsChange = credentials => {
    onChange((0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_4__.updateCredentials)(dataSourceConfig, credentials));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h6", {
      children: "Azure Authentication"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_AzureCredentialsForm__WEBPACK_IMPORTED_MODULE_5__.AzureCredentialsForm, {
      managedIdentityEnabled: _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.azure.managedIdentityEnabled,
      credentials: credentials,
      azureCloudOptions: _AzureCredentials__WEBPACK_IMPORTED_MODULE_3__.KnownAzureClouds,
      onCredentialsChange: onCredentialsChange
    }), _h2 || (_h2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("h6", {
      children: "Azure Configuration"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
      className: "gf-form-group",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "AAD resource ID"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Input, {
              className: "width-30",
              value: dataSourceConfig.jsonData.azureEndpointResourceId || '',
              onChange: event => onChange(Object.assign({}, dataSourceConfig, {
                jsonData: Object.assign({}, dataSourceConfig.jsonData, {
                  azureEndpointResourceId: event.currentTarget.value
                })
              }))
            })
          })]
        })
      })
    })]
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AzureAuthSettings);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureCloud": () => (/* binding */ AzureCloud),
/* harmony export */   "KnownAzureClouds": () => (/* binding */ KnownAzureClouds),
/* harmony export */   "isCredentialsComplete": () => (/* binding */ isCredentialsComplete)
/* harmony export */ });
let AzureCloud;

(function (AzureCloud) {
  AzureCloud["Public"] = "AzureCloud";
  AzureCloud["China"] = "AzureChinaCloud";
  AzureCloud["USGovernment"] = "AzureUSGovernment";
  AzureCloud["Germany"] = "AzureGermanCloud";
  AzureCloud["None"] = "";
})(AzureCloud || (AzureCloud = {}));

const KnownAzureClouds = [{
  value: AzureCloud.Public,
  label: 'Azure'
}, {
  value: AzureCloud.China,
  label: 'Azure China'
}, {
  value: AzureCloud.USGovernment,
  label: 'Azure US Government'
}, {
  value: AzureCloud.Germany,
  label: 'Azure Germany'
}];
function isCredentialsComplete(credentials) {
  switch (credentials.authType) {
    case 'msi':
      return true;

    case 'clientsecret':
      return !!(credentials.azureCloud && credentials.tenantId && credentials.clientId && credentials.clientSecret);
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCredentials": () => (/* binding */ getCredentials),
/* harmony export */   "getDefaultCredentials": () => (/* binding */ getDefaultCredentials),
/* harmony export */   "hasCredentials": () => (/* binding */ hasCredentials),
/* harmony export */   "resetCredentials": () => (/* binding */ resetCredentials),
/* harmony export */   "setDefaultCredentials": () => (/* binding */ setDefaultCredentials),
/* harmony export */   "updateCredentials": () => (/* binding */ updateCredentials)
/* harmony export */ });
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");


const concealed = Symbol('Concealed client secret');

function getDefaultAzureCloud() {
  return _grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.cloud || _AzureCredentials__WEBPACK_IMPORTED_MODULE_1__.AzureCloud.Public;
}

function getSecret(options) {
  if (options.secureJsonFields.azureClientSecret) {
    // The secret is concealed on server
    return concealed;
  } else {
    var _options$secureJsonDa;

    const secret = (_options$secureJsonDa = options.secureJsonData) === null || _options$secureJsonDa === void 0 ? void 0 : _options$secureJsonDa.azureClientSecret;
    return typeof secret === 'string' && secret.length > 0 ? secret : undefined;
  }
}

function hasCredentials(options) {
  return !!options.jsonData.azureCredentials;
}
function getDefaultCredentials() {
  if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
    return {
      authType: 'msi'
    };
  } else {
    return {
      authType: 'clientsecret',
      azureCloud: getDefaultAzureCloud()
    };
  }
}
function getCredentials(options) {
  const credentials = options.jsonData.azureCredentials; // If no credentials saved, then return empty credentials
  // of type based on whether the managed identity enabled

  if (!credentials) {
    return getDefaultCredentials();
  }

  switch (credentials.authType) {
    case 'msi':
      if (_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
        return {
          authType: 'msi'
        };
      } else {
        // If authentication type is managed identity but managed identities were disabled in Grafana config,
        // then we should fallback to an empty app registration (client secret) configuration
        return {
          authType: 'clientsecret',
          azureCloud: getDefaultAzureCloud()
        };
      }

    case 'clientsecret':
      return {
        authType: 'clientsecret',
        azureCloud: credentials.azureCloud || getDefaultAzureCloud(),
        tenantId: credentials.tenantId,
        clientId: credentials.clientId,
        clientSecret: getSecret(options)
      };
  }
}
function updateCredentials(options, credentials) {
  switch (credentials.authType) {
    case 'msi':
      if (!_grafana_runtime__WEBPACK_IMPORTED_MODULE_0__.config.azure.managedIdentityEnabled) {
        throw new Error('Managed Identity authentication is not enabled in Grafana config.');
      }

      options = Object.assign({}, options, {
        jsonData: Object.assign({}, options.jsonData, {
          azureCredentials: {
            authType: 'msi'
          }
        })
      });
      return options;

    case 'clientsecret':
      options = Object.assign({}, options, {
        jsonData: Object.assign({}, options.jsonData, {
          azureCredentials: {
            authType: 'clientsecret',
            azureCloud: credentials.azureCloud || getDefaultAzureCloud(),
            tenantId: credentials.tenantId,
            clientId: credentials.clientId
          }
        }),
        secureJsonData: Object.assign({}, options.secureJsonData, {
          azureClientSecret: typeof credentials.clientSecret === 'string' && credentials.clientSecret.length > 0 ? credentials.clientSecret : undefined
        }),
        secureJsonFields: Object.assign({}, options.secureJsonFields, {
          azureClientSecret: typeof credentials.clientSecret === 'symbol'
        })
      });
      return options;
  }
}
function setDefaultCredentials(options) {
  return {
    jsonData: Object.assign({}, options.jsonData, {
      azureCredentials: getDefaultCredentials()
    })
  };
}
function resetCredentials(options) {
  return {
    jsonData: Object.assign({}, options.jsonData, {
      azureAuth: undefined,
      azureCredentials: undefined,
      azureEndpointResourceId: undefined
    })
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsForm.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzureCredentialsForm": () => (/* binding */ AzureCredentialsForm),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/components/index.ts");
/* harmony import */ var _grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/Legacy/Select/Select.tsx");
/* harmony import */ var _grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/components/Forms/Legacy/Input/Input.tsx");
/* harmony import */ var _AzureCredentials__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentials.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _InlineFormLabel2, _InlineFormLabel3, _InlineFormLabel4, _div, _InlineFormLabel5, _InlineFormLabel6;









const authTypeOptions = [{
  value: 'msi',
  label: 'Managed Identity'
}, {
  value: 'clientsecret',
  label: 'App Registration'
}];
const AzureCredentialsForm = props => {
  const {
    credentials,
    azureCloudOptions,
    onCredentialsChange,
    getSubscriptions
  } = props;
  const hasRequiredFields = (0,_AzureCredentials__WEBPACK_IMPORTED_MODULE_4__.isCredentialsComplete)(credentials);
  const [subscriptions, setSubscriptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const [loadSubscriptionsClicked, onLoadSubscriptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(val => val + 1, 0);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!getSubscriptions || !hasRequiredFields) {
      updateSubscriptions([]);
      return;
    }

    let canceled = false;
    getSubscriptions().then(result => {
      if (!canceled) {
        updateSubscriptions(result, loadSubscriptionsClicked);
      }
    });
    return () => {
      canceled = true;
    }; // This effect is intended to be called only once initially and on Load Subscriptions click
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [loadSubscriptionsClicked]);

  const updateSubscriptions = (received, autoSelect = false) => {
    setSubscriptions(received);

    if (getSubscriptions) {
      if (autoSelect && !credentials.defaultSubscriptionId && received.length > 0) {
        // Selecting the default subscription if subscriptions received but no default subscription selected
        onSubscriptionChange(received[0]);
      } else if (credentials.defaultSubscriptionId) {
        const found = received.find(opt => opt.value === credentials.defaultSubscriptionId);

        if (!found) {
          // Unselecting the default subscription if it isn't found among the received subscriptions
          onSubscriptionChange(undefined);
        }
      }
    }
  };

  const onAuthTypeChange = selected => {
    if (onCredentialsChange) {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        authType: selected.value || 'msi',
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onAzureCloudChange = selected => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        azureCloud: selected.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onTenantIdChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        tenantId: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientIdChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientId: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientSecretChange = event => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientSecret: event.target.value,
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onClientSecretReset = () => {
    if (onCredentialsChange && credentials.authType === 'clientsecret') {
      setSubscriptions([]);
      const updated = Object.assign({}, credentials, {
        clientSecret: '',
        defaultSubscriptionId: undefined
      });
      onCredentialsChange(updated);
    }
  };

  const onSubscriptionChange = selected => {
    if (onCredentialsChange) {
      const updated = Object.assign({}, credentials, {
        defaultSubscriptionId: selected === null || selected === void 0 ? void 0 : selected.value
      });
      onCredentialsChange(updated);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: "gf-form-group",
    children: [props.managedIdentityEnabled && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: "gf-form-inline",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: "gf-form",
        children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
          className: "width-12",
          tooltip: "Choose the type of authentication to Azure services",
          children: "Authentication"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_2__.Select, {
          menuShouldPortal: true,
          className: "width-15",
          value: authTypeOptions.find(opt => opt.value === credentials.authType),
          options: authTypeOptions,
          onChange: onAuthTypeChange
        })]
      })
    }), credentials.authType === 'clientsecret' && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [azureCloudOptions && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel2 || (_InlineFormLabel2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            tooltip: "Choose an Azure Cloud",
            children: "Azure Cloud"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_2__.Select, {
            menuShouldPortal: true,
            className: "width-15",
            value: azureCloudOptions.find(opt => opt.value === credentials.azureCloud),
            options: azureCloudOptions,
            onChange: onAzureCloudChange
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel3 || (_InlineFormLabel3 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Directory (tenant) ID"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_3__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.tenantId || '',
              onChange: onTenantIdChange
            })
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel4 || (_InlineFormLabel4 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Application (client) ID"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_3__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.clientId || '',
              onChange: onClientIdChange
            })
          })]
        })
      }), typeof credentials.clientSecret === 'symbol' ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: "gf-form-inline",
        children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Client Secret"
          }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_3__.Input, {
            className: "width-25",
            placeholder: "configured",
            disabled: true
          })]
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "max-width-30 gf-form-inline",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.Button, {
              variant: "secondary",
              type: "button",
              onClick: onClientSecretReset,
              children: "reset"
            })
          })
        })]
      }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel5 || (_InlineFormLabel5 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Client Secret"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-15",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Input_Input__WEBPACK_IMPORTED_MODULE_3__.Input, {
              className: "width-30",
              placeholder: "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
              value: credentials.clientSecret || '',
              onChange: onClientSecretChange
            })
          })]
        })
      })]
    }), getSubscriptions && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: "gf-form",
          children: [_InlineFormLabel6 || (_InlineFormLabel6 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
            className: "width-12",
            children: "Default Subscription"
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "width-25",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components_Forms_Legacy_Select_Select__WEBPACK_IMPORTED_MODULE_2__.Select, {
              menuShouldPortal: true,
              value: credentials.defaultSubscriptionId ? subscriptions.find(opt => opt.value === credentials.defaultSubscriptionId) : undefined,
              options: subscriptions,
              onChange: onSubscriptionChange
            })
          })]
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
            className: "max-width-30 gf-form-inline",
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui_src_components__WEBPACK_IMPORTED_MODULE_1__.Button, {
              variant: "secondary",
              size: "sm",
              type: "button",
              onClick: onLoadSubscriptions,
              disabled: !hasRequiredFields,
              children: "Load Subscriptions"
            })
          })
        })
      })]
    })]
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AzureCredentialsForm);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigEditor": () => (/* binding */ ConfigEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var app_core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/core/config.ts");
/* harmony import */ var _AzureAuthSettings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureAuthSettings.tsx");
/* harmony import */ var _PromSettings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx");
/* harmony import */ var _AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/AzureCredentialsConfig.ts");
/* harmony import */ var app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/alerting/unified/utils/alertmanager.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Alert;











const ConfigEditor = props => {
  var _config$featureToggle;

  const {
    options,
    onOptionsChange
  } = props;
  const alertmanagers = (0,app_features_alerting_unified_utils_alertmanager__WEBPACK_IMPORTED_MODULE_6__.getAllAlertmanagerDataSources)();
  const azureAuthSettings = {
    azureAuthSupported: (_config$featureToggle = app_core_config__WEBPACK_IMPORTED_MODULE_2__.config.featureToggles.prometheus_azure_auth) !== null && _config$featureToggle !== void 0 ? _config$featureToggle : false,
    getAzureAuthEnabled: config => (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_5__.hasCredentials)(config),
    setAzureAuthEnabled: (config, enabled) => enabled ? (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_5__.setDefaultCredentials)(config) : (0,_AzureCredentialsConfig__WEBPACK_IMPORTED_MODULE_5__.resetCredentials)(config),
    azureSettingsUI: _AzureAuthSettings__WEBPACK_IMPORTED_MODULE_3__.AzureAuthSettings
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.Fragment, {
    children: [options.access === 'direct' && (_Alert || (_Alert = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Alert, {
      title: "Deprecation Notice",
      severity: "warning",
      children: "Browser access mode in the Prometheus datasource is deprecated and will be removed in a future release."
    }))), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.DataSourceHttpSettings, {
      defaultUrl: "http://localhost:9090",
      dataSourceConfig: options,
      showAccessOptions: true,
      onChange: onOptionsChange,
      sigV4AuthToggleEnabled: app_core_config__WEBPACK_IMPORTED_MODULE_2__.config.sigV4AuthEnabled,
      azureAuthSettings: azureAuthSettings
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.AlertingSettings, {
      alertmanagerDataSources: alertmanagers,
      options: options,
      onOptionsChange: onOptionsChange
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_PromSettings__WEBPACK_IMPORTED_MODULE_4__.PromSettings, {
      options: options,
      onOptionsChange: onOptionsChange
    })]
  });
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ExemplarSetting.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ExemplarSetting)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-e2e-selectors/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








function ExemplarSetting({
  value,
  onChange,
  onDelete
}) {
  const [isInternalLink, setIsInternalLink] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(Boolean(value.datasourceUid));
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: "gf-form-group",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
      label: "Internal link",
      labelWidth: 24,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineSwitch, {
          value: isInternalLink,
          "aria-label": _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_1__.selectors.components.DataSource.Prometheus.configPage.internalLinkSwitch,
          onChange: ev => setIsInternalLink(ev.currentTarget.checked)
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
          variant: "destructive",
          title: "Remove link",
          icon: "times",
          onClick: event => {
            event.preventDefault();
            onDelete();
          },
          className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
              margin-left: 8px;
            `
        })]
      })
    }), isInternalLink ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
      label: "Data source",
      labelWidth: 24,
      tooltip: "The data source the exemplar is going to navigate to.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.DataSourcePicker, {
        tracing: true,
        current: value.datasourceUid,
        noDefault: true,
        width: 40,
        onChange: ds => onChange(Object.assign({}, value, {
          datasourceUid: ds.uid,
          url: undefined
        }))
      })
    }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
      label: "URL",
      labelWidth: 24,
      tooltip: "The URL of the trace backend the user would go to see its trace.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Input, {
        placeholder: "https://example.com/${__value.raw}",
        spellCheck: false,
        width: 40,
        value: value.url,
        onChange: event => onChange(Object.assign({}, value, {
          datasourceUid: undefined,
          url: event.currentTarget.value
        }))
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
      label: "URL Label",
      labelWidth: 24,
      tooltip: "Use to override the button label on the exemplar traceID field.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Input, {
        placeholder: "Go to example.com",
        spellCheck: false,
        width: 40,
        value: value.urlDisplayLabel,
        onChange: event => onChange(Object.assign({}, value, {
          urlDisplayLabel: event.currentTarget.value
        }))
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.InlineField, {
      label: "Label name",
      labelWidth: 24,
      tooltip: "The name of the field in the labels object that should be used to get the traceID.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Input, {
        placeholder: "traceID",
        spellCheck: false,
        width: 40,
        value: value.name,
        onChange: event => onChange(Object.assign({}, value, {
          name: event.currentTarget.value
        }))
      })
    })]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/ExemplarsSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExemplarsSettings": () => (/* binding */ ExemplarsSettings)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-e2e-selectors/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _ExemplarSetting__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ExemplarSetting.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _h;









function ExemplarsSettings({
  options,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [_h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("h3", {
      className: "page-heading",
      children: "Exemplars"
    })), options && options.map((option, index) => {
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_ExemplarSetting__WEBPACK_IMPORTED_MODULE_4__["default"], {
        value: option,
        onChange: newField => {
          const newOptions = [...options];
          newOptions.splice(index, 1, newField);
          onChange(newOptions);
        },
        onDelete: () => {
          const newOptions = [...options];
          newOptions.splice(index, 1);
          onChange(newOptions);
        }
      }, index);
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
      variant: "secondary",
      "aria-label": _grafana_e2e_selectors__WEBPACK_IMPORTED_MODULE_1__.selectors.components.DataSource.Prometheus.configPage.exemplarsAddButton,
      className: _emotion_css__WEBPACK_IMPORTED_MODULE_0__.css`
          margin-bottom: 10px;
        `,
      icon: "plus",
      onClick: event => {
        event.preventDefault();
        const newOptions = [...(options || []), {
          name: 'traceID'
        }];
        onChange(newOptions);
      },
      children: "Add"
    })]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromSettings": () => (/* binding */ PromSettings),
/* harmony export */   "getValueFromEventItem": () => (/* binding */ getValueFromEventItem),
/* harmony export */   "promSettingsValidationEvents": () => (/* binding */ promSettingsValidationEvents)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _ExemplarsSettings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ExemplarsSettings.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _InlineFormLabel, _h;








const {
  Select,
  Input,
  FormField,
  Switch
} = _grafana_ui__WEBPACK_IMPORTED_MODULE_1__.LegacyForms;
const httpOptions = [{
  value: 'POST',
  label: 'POST'
}, {
  value: 'GET',
  label: 'GET'
}];
const PromSettings = props => {
  var _options$jsonData$dis;

  const {
    options,
    onOptionsChange
  } = props; // We are explicitly adding httpMethod so it is correctly displayed in dropdown. This way, it is more predictable for users.

  if (!options.jsonData.httpMethod) {
    options.jsonData.httpMethod = 'POST';
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Scrape interval",
            labelWidth: 13,
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-6",
              value: options.jsonData.timeInterval,
              spellCheck: false,
              placeholder: "15s",
              onChange: onChangeHandler('timeInterval', options, onOptionsChange),
              validationEvents: promSettingsValidationEvents
            }),
            tooltip: "Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s."
          })
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Query timeout",
            labelWidth: 13,
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-6",
              value: options.jsonData.queryTimeout,
              onChange: onChangeHandler('queryTimeout', options, onOptionsChange),
              spellCheck: false,
              placeholder: "60s",
              validationEvents: promSettingsValidationEvents
            }),
            tooltip: "Set the Prometheus query timeout."
          })
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: "gf-form",
        children: [_InlineFormLabel || (_InlineFormLabel = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.InlineFormLabel, {
          width: 13,
          tooltip: "You can use either POST or GET HTTP method to query your Prometheus data source. POST is the recommended method as it allows bigger queries. Change this to GET if you have a Prometheus version older than 2.1 or if POST requests are restricted in your network.",
          children: "HTTP Method"
        })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Select, {
          "aria-label": "Select HTTP method",
          menuShouldPortal: true,
          options: httpOptions,
          value: httpOptions.find(o => o.value === options.jsonData.httpMethod),
          onChange: onChangeHandler('httpMethod', options, onOptionsChange),
          width: 7
        })]
      })]
    }), _h || (_h = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h3", {
      className: "page-heading",
      children: "Misc"
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: "gf-form-group",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Switch, {
          checked: (_options$jsonData$dis = options.jsonData.disableMetricsLookup) !== null && _options$jsonData$dis !== void 0 ? _options$jsonData$dis : false,
          label: "Disable metrics lookup",
          labelClass: "width-14",
          onChange: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.onUpdateDatasourceJsonDataOptionChecked)(props, 'disableMetricsLookup'),
          tooltip: "Checking this option will disable the metrics chooser and metric/label support in the query field's autocomplete. This helps if you have performance issues with bigger Prometheus instances."
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: "gf-form-inline",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          className: "gf-form max-width-30",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(FormField, {
            label: "Custom query parameters",
            labelWidth: 14,
            tooltip: "Add Custom parameters to all Prometheus or Thanos queries.",
            inputEl: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Input, {
              className: "width-25",
              value: options.jsonData.customQueryParameters,
              onChange: onChangeHandler('customQueryParameters', options, onOptionsChange),
              spellCheck: false,
              placeholder: "Example: max_source_resolution=5m&timeout=10"
            })
          })
        })
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_ExemplarsSettings__WEBPACK_IMPORTED_MODULE_3__.ExemplarsSettings, {
      options: options.jsonData.exemplarTraceIdDestinations,
      onChange: exemplarOptions => (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.updateDatasourcePluginJsonDataOption)({
        onOptionsChange,
        options
      }, 'exemplarTraceIdDestinations', exemplarOptions)
    })]
  });
};
const promSettingsValidationEvents = {
  [_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.EventsWithValidation.onBlur]: [(0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.regexValidation)(/^$|^\d+(ms|[Mwdhmsy])$/, 'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s')]
};
const getValueFromEventItem = eventItem => {
  if (!eventItem) {
    return '';
  }

  if (eventItem.hasOwnProperty('currentTarget')) {
    return eventItem.currentTarget.value;
  }

  return eventItem.value;
};

const onChangeHandler = (key, options, onOptionsChange) => eventItem => {
  onOptionsChange(Object.assign({}, options, {
    jsonData: Object.assign({}, options.jsonData, {
      [key]: getValueFromEventItem(eventItem)
    })
  }));
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/datasource.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ANNOTATION_QUERY_STEP_DEFAULT": () => (/* binding */ ANNOTATION_QUERY_STEP_DEFAULT),
/* harmony export */   "PrometheusDatasource": () => (/* binding */ PrometheusDatasource),
/* harmony export */   "alignRange": () => (/* binding */ alignRange),
/* harmony export */   "extractRuleMappingFromGroups": () => (/* binding */ extractRuleMappingFromGroups),
/* harmony export */   "prometheusRegularEscape": () => (/* binding */ prometheusRegularEscape),
/* harmony export */   "prometheusSpecialRegexEscape": () => (/* binding */ prometheusSpecialRegexEscape)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/util/pipe.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/merge.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/throwError.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/tap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/catchError.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.7.1-726274dc4d-f362c5a2cf.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var app_core_utils_explore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/core/utils/explore.ts");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
/* harmony import */ var app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/features/templating/template_srv.ts");
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _query_hints__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/prometheus/query_hints.ts");
/* harmony import */ var _result_transformer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/prometheus/result_transformer.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _variables__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/prometheus/variables.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
/* harmony import */ var app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./public/app/features/alerting/unified/api/buildInfo.ts");
/* harmony import */ var app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./public/app/types/unified-alerting-dto.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Badge, _Badge2, _Tooltip, _div, _div2;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


























const ANNOTATION_QUERY_STEP_DEFAULT = '60s';
const GET_AND_POST_METADATA_ENDPOINTS = ['api/v1/query', 'api/v1/query_range', 'api/v1/series', 'api/v1/labels'];
class PrometheusDatasource extends _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.DataSourceWithBackend {
  constructor(instanceSettings, templateSrv = (0,app_features_templating_template_srv__WEBPACK_IMPORTED_MODULE_7__.getTemplateSrv)(), timeSrv = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_6__.getTimeSrv)(), languageProvider) {
    var _instanceSettings$jso, _instanceSettings$jso2;

    super(instanceSettings);
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "editorSrc", void 0);

    _defineProperty(this, "ruleMappings", void 0);

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "directUrl", void 0);

    _defineProperty(this, "access", void 0);

    _defineProperty(this, "basicAuth", void 0);

    _defineProperty(this, "withCredentials", void 0);

    _defineProperty(this, "metricsNameCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_2___default())({
      max: 10
    }));

    _defineProperty(this, "interval", void 0);

    _defineProperty(this, "queryTimeout", void 0);

    _defineProperty(this, "httpMethod", void 0);

    _defineProperty(this, "languageProvider", void 0);

    _defineProperty(this, "exemplarTraceIdDestinations", void 0);

    _defineProperty(this, "lookupsDisabled", void 0);

    _defineProperty(this, "customQueryParameters", void 0);

    _defineProperty(this, "exemplarsAvailable", void 0);

    _defineProperty(this, "subType", void 0);

    _defineProperty(this, "rulerEnabled", void 0);

    _defineProperty(this, "init", async () => {
      this.loadRules();
      this.exemplarsAvailable = await this.areExemplarsAvailable();
    });

    _defineProperty(this, "prepareTargets", (options, start, end) => {
      const queries = [];
      const activeTargets = [];
      const clonedTargets = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(options.targets);

      for (const target of clonedTargets) {
        if (!target.expr || target.hide) {
          continue;
        }

        target.requestId = options.panelId + target.refId;
        const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // In Explore, we run both (instant and range) queries if both are true (selected) or both are undefined (legacy Explore queries)

        if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore && target.range === target.instant) {
          // Create instant target
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
          instantTarget.format = 'table';
          instantTarget.instant = true;
          instantTarget.range = false;
          instantTarget.valueWithRefId = true;
          delete instantTarget.maxDataPoints;
          instantTarget.requestId += '_instant'; // Create range target

          const rangeTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
          rangeTarget.format = 'time_series';
          rangeTarget.instant = false;
          instantTarget.range = true; // Create exemplar query

          if (target.exemplar) {
            // Only create exemplar target for different metric names
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
              exemplarTarget.instant = false;
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            instantTarget.exemplar = false;
            rangeTarget.exemplar = false;
          } // Add both targets to activeTargets and queries arrays


          activeTargets.push(instantTarget, rangeTarget);
          queries.push(this.createQuery(instantTarget, options, start, end), this.createQuery(rangeTarget, options, start, end)); // If running only instant query in Explore, format as table
        } else if (target.instant && options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
          const instantTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
          instantTarget.format = 'table';
          queries.push(this.createQuery(instantTarget, options, start, end));
          activeTargets.push(instantTarget);
        } else {
          // It doesn't make sense to query for exemplars in dashboard if only instant is selected
          if (target.exemplar && !target.instant) {
            if (!metricName || metricName && !activeTargets.some(activeTarget => activeTarget.expr.includes(metricName))) {
              const exemplarTarget = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(target);
              exemplarTarget.requestId += '_exemplar';
              queries.push(this.createQuery(exemplarTarget, options, start, end));
              activeTargets.push(exemplarTarget);
            }

            target.exemplar = false;
          }

          queries.push(this.createQuery(target, options, start, end));
          activeTargets.push(target);
        }
      }

      return {
        queries,
        activeTargets
      };
    });

    _defineProperty(this, "handleErrors", (err, target) => {
      const error = {
        message: err && err.statusText || 'Unknown error during query transaction. Please check JS console logs.',
        refId: target.refId
      };

      if (err.data) {
        if (typeof err.data === 'string') {
          error.message = err.data;
        } else if (err.data.error) {
          error.message = (0,app_core_utils_explore__WEBPACK_IMPORTED_MODULE_5__.safeStringifyValue)(err.data.error);
        }
      } else if (err.message) {
        error.message = err.message;
      } else if (typeof err === 'string') {
        error.message = err;
      }

      error.status = err.status;
      error.statusText = err.statusText;
      return error;
    });

    _defineProperty(this, "processAnnotationResponse", (options, data) => {
      const frames = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.toDataQueryResponse)({
        data: data
      }).data;

      if (!frames || !frames.length) {
        return [];
      }

      const annotation = options.annotation;
      const {
        tagKeys = '',
        titleFormat = '',
        textFormat = ''
      } = annotation;
      const step = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(annotation.step || ANNOTATION_QUERY_STEP_DEFAULT) * 1000;
      const tagKeysArray = tagKeys.split(',');
      const eventList = [];

      for (const frame of frames) {
        const timeField = frame.fields[0];
        const valueField = frame.fields[1];
        const labels = (valueField === null || valueField === void 0 ? void 0 : valueField.labels) || {};
        const tags = Object.keys(labels).filter(label => tagKeysArray.includes(label)).map(label => labels[label]);
        const timeValueTuple = [];
        let idx = 0;
        valueField.values.toArray().forEach(value => {
          let timeStampValue;
          let valueValue;
          const time = timeField.values.get(idx); // If we want to use value as a time, we use value as timeStampValue and valueValue will be 1

          if (options.annotation.useValueForTime) {
            timeStampValue = Math.floor(parseFloat(value));
            valueValue = 1;
          } else {
            timeStampValue = Math.floor(parseFloat(time));
            valueValue = parseFloat(value);
          }

          idx++;
          timeValueTuple.push([timeStampValue, valueValue]);
        });
        const activeValues = timeValueTuple.filter(value => value[1] >= 1);
        const activeValuesTimestamps = activeValues.map(value => value[0]); // Instead of creating singular annotation for each active event we group events into region if they are less
        // or equal to `step` apart.

        let latestEvent = null;

        for (const timestamp of activeValuesTimestamps) {
          var _latestEvent$timeEnd;

          // We already have event `open` and we have new event that is inside the `step` so we just update the end.
          if (latestEvent && ((_latestEvent$timeEnd = latestEvent.timeEnd) !== null && _latestEvent$timeEnd !== void 0 ? _latestEvent$timeEnd : 0) + step >= timestamp) {
            latestEvent.timeEnd = timestamp;
            continue;
          } // Event exists but new one is outside of the `step` so we add it to eventList.


          if (latestEvent) {
            eventList.push(latestEvent);
          } // We start a new region.


          latestEvent = {
            time: timestamp,
            timeEnd: timestamp,
            annotation,
            title: (0,_legend__WEBPACK_IMPORTED_MODULE_16__.renderLegendFormat)(titleFormat, labels),
            tags,
            text: (0,_legend__WEBPACK_IMPORTED_MODULE_16__.renderLegendFormat)(textFormat, labels)
          };
        }

        if (latestEvent) {
          // Finish up last point if we have one
          latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];
          eventList.push(latestEvent);
        }
      }

      return eventList;
    });

    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.type = 'prometheus';
    this.subType = app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus;
    this.rulerEnabled = false;
    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';
    this.id = instanceSettings.id;
    this.url = instanceSettings.url;
    this.access = instanceSettings.access;
    this.basicAuth = instanceSettings.basicAuth;
    this.withCredentials = instanceSettings.withCredentials;
    this.interval = instanceSettings.jsonData.timeInterval || '15s';
    this.queryTimeout = instanceSettings.jsonData.queryTimeout;
    this.httpMethod = instanceSettings.jsonData.httpMethod || 'POST'; // `directUrl` is never undefined, we set it at https://github.com/grafana/grafana/blob/main/pkg/api/frontendsettings.go#L108
    // here we "fall back" to this.url to make typescript happy, but it should never happen

    this.directUrl = (_instanceSettings$jso = instanceSettings.jsonData.directUrl) !== null && _instanceSettings$jso !== void 0 ? _instanceSettings$jso : this.url;
    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;
    this.ruleMappings = {};
    this.languageProvider = languageProvider !== null && languageProvider !== void 0 ? languageProvider : new _language_provider__WEBPACK_IMPORTED_MODULE_9__["default"](this);
    this.lookupsDisabled = (_instanceSettings$jso2 = instanceSettings.jsonData.disableMetricsLookup) !== null && _instanceSettings$jso2 !== void 0 ? _instanceSettings$jso2 : false;
    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);
    this.variables = new _variables__WEBPACK_IMPORTED_MODULE_14__.PrometheusVariableSupport(this, this.templateSrv, this.timeSrv);
    this.exemplarsAvailable = true;
  }

  getQueryDisplayText(query) {
    return query.expr;
  }

  _addTracingHeaders(httpOptions, options) {
    httpOptions.headers = {};
    const proxyMode = !this.url.match(/^http/);

    if (proxyMode) {
      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;
      httpOptions.headers['X-Panel-Id'] = options.panelId;
    }
  }
  /**
   * Any request done from this data source should go through here as it contains some common processing for the
   * request. Any processing done here needs to be also copied on the backend as this goes through data source proxy
   * but not through the same code as alerting.
   */


  _request(url, data, overrides = {}) {
    data = data || {};

    for (const [key, value] of this.customQueryParameters) {
      if (data[key] == null) {
        data[key] = value;
      }
    }

    const options = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.defaults)(overrides, {
      url: this.url + url,
      method: this.httpMethod,
      headers: {}
    });

    if (options.method === 'GET') {
      if (data && Object.keys(data).length) {
        options.url = options.url + (options.url.search(/\?/) >= 0 ? '&' : '?') + Object.entries(data).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');
      }
    } else {
      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
      options.data = data;
    }

    if (this.basicAuth || this.withCredentials) {
      options.withCredentials = true;
    }

    if (this.basicAuth) {
      options.headers.Authorization = this.basicAuth;
    }

    return (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch(options);
  }

  async importFromAbstractQueries(abstractQueries) {
    return abstractQueries.map(abstractQuery => this.languageProvider.importFromAbstractQuery(abstractQuery));
  }

  async exportToAbstractQueries(queries) {
    return queries.map(query => this.languageProvider.exportToAbstractQuery(query));
  } // Use this for tab completion features, wont publish response to other components


  async metadataRequest(url, params = {}) {
    // If URL includes endpoint that supports POST and GET method, try to use configured method. This might fail as POST is supported only in v2.10+.
    if (GET_AND_POST_METADATA_ENDPOINTS.some(endpoint => url.includes(endpoint))) {
      try {
        return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this._request(url, params, {
          method: this.httpMethod,
          hideFromInspector: true
        }));
      } catch (err) {
        // If status code of error is Method Not Allowed (405) and HTTP method is POST, retry with GET
        if (this.httpMethod === 'POST' && err.status === 405) {
          console.warn(`Couldn't use configured POST HTTP method for this request. Trying to use GET method instead.`);
        } else {
          throw err;
        }
      }
    }

    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this._request(url, params, {
      method: 'GET',
      hideFromInspector: true
    })); // toPromise until we change getTagValues, getTagKeys to Observable
  }

  interpolateQueryExpr(value = [], variable) {
    // if no multi or include all do not regexEscape
    if (!variable.multi && !variable.includeAll) {
      return prometheusRegularEscape(value);
    }

    if (typeof value === 'string') {
      return prometheusSpecialRegexEscape(value);
    }

    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));

    if (escapedValues.length === 1) {
      return escapedValues[0];
    }

    return '(' + escapedValues.join('|') + ')';
  }

  targetContainsTemplate(target) {
    return this.templateSrv.containsTemplate(target.expr);
  }

  shouldRunExemplarQuery(target, request) {
    if (target.exemplar) {
      // We check all already processed targets and only create exemplar target for not used metric names
      const metricName = this.languageProvider.histogramMetrics.find(m => target.expr.includes(m)); // Remove targets that weren't processed yet (in targets array they are after current target)

      const currentTargetIdx = request.targets.findIndex(t => t.refId === target.refId);
      const targets = request.targets.slice(0, currentTargetIdx);

      if (!metricName || metricName && !targets.some(t => t.expr.includes(metricName))) {
        return true;
      }

      return false;
    }

    return false;
  }

  processTargetV2(target, request) {
    const processedTarget = Object.assign({}, target, {
      queryType: _types__WEBPACK_IMPORTED_MODULE_13__.PromQueryType.timeSeriesQuery,
      exemplar: this.shouldRunExemplarQuery(target, request),
      requestId: request.panelId + target.refId,
      // We need to pass utcOffsetSec to backend to calculate aligned range
      utcOffsetSec: this.timeSrv.timeRange().to.utcOffset() * 60
    });
    return processedTarget;
  }

  query(request) {
    if (this.access === 'proxy') {
      const targets = request.targets.map(target => this.processTargetV2(target, request));
      return super.query(Object.assign({}, request, {
        targets
      })).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => (0,_result_transformer__WEBPACK_IMPORTED_MODULE_12__.transformV2)(response, request, {
        exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
      }))); // Run queries trough browser/proxy
    } else {
      const start = this.getPrometheusTime(request.range.from, false);
      const end = this.getPrometheusTime(request.range.to, true);
      const {
        queries,
        activeTargets
      } = this.prepareTargets(request, start, end); // No valid targets, return the empty result to save a round trip.

      if (!queries || !queries.length) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }

      if (request.app === _grafana_data__WEBPACK_IMPORTED_MODULE_3__.CoreApp.Explore) {
        return this.exploreQuery(queries, activeTargets, end);
      }

      return this.panelsQuery(queries, activeTargets, end, request.requestId, request.scopedVars);
    }
  }

  exploreQuery(queries, activeTargets, end) {
    let runningQueriesCount = queries.length;
    const subQueries = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.pipe)( // Decrease the counter here. We assume that each request returns only single value and then completes
      // (should hold until there is some streaming requests involved).
      (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_25__.tap)(() => runningQueriesCount--), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_12__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return {
          data,
          key: query.requestId,
          state: runningQueriesCount === 0 ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Loading
        };
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_27__.merge)(...subQueries);
  }

  panelsQuery(queries, activeTargets, end, requestId, scopedVars) {
    const observables = queries.map((query, index) => {
      const target = activeTargets[index];
      const filterAndMapResponse = (0,rxjs__WEBPACK_IMPORTED_MODULE_24__.pipe)((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_26__.filter)(response => response.cancelled ? false : true), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(response => {
        const data = (0,_result_transformer__WEBPACK_IMPORTED_MODULE_12__.transform)(response, {
          query,
          target,
          responseListLength: queries.length,
          scopedVars,
          exemplarTraceIdDestinations: this.exemplarTraceIdDestinations
        });
        return data;
      }));
      return this.runQuery(query, end, filterAndMapResponse);
    });
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_28__.forkJoin)(observables).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(results => {
      const data = results.reduce((result, current) => {
        return [...result, ...current];
      }, []);
      return {
        data,
        key: requestId,
        state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
      };
    }));
  }

  runQuery(query, end, filter) {
    if (query.instant) {
      return this.performInstantQuery(query, end).pipe(filter);
    }

    if (query.exemplar) {
      return this.getExemplars(query).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(() => {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)({
          data: [],
          state: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done
        });
      }), filter);
    }

    return this.performTimeSeriesQuery(query, query.start, query.end).pipe(filter);
  }

  createQuery(target, options, start, end) {
    const query = {
      hinting: target.hinting,
      instant: target.instant,
      exemplar: target.exemplar,
      step: 0,
      expr: '',
      requestId: target.requestId,
      refId: target.refId,
      start: 0,
      end: 0
    };
    const range = Math.ceil(end - start); // options.interval is the dynamically calculated interval

    let interval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(options.interval); // Minimum interval ("Min step"), if specified for the query, or same as interval otherwise.

    const minInterval = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval || options.interval, options.scopedVars)); // Scrape interval as specified for the query ("Min step") or otherwise taken from the datasource.
    // Min step field can have template variables in it, make sure to replace it.

    const scrapeInterval = target.interval ? _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.templateSrv.replace(target.interval, options.scopedVars)) : _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToSeconds(this.interval);
    const intervalFactor = target.intervalFactor || 1; // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits

    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);
    let scopedVars = Object.assign({}, options.scopedVars, this.getRangeScopedVars(options.range), this.getRateIntervalScopedVariable(adjustedInterval, scrapeInterval)); // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars

    if (interval !== adjustedInterval) {
      interval = adjustedInterval;
      scopedVars = Object.assign({}, options.scopedVars, Object.assign({
        __interval: {
          text: interval + 's',
          value: interval + 's'
        },
        __interval_ms: {
          text: interval * 1000,
          value: interval * 1000
        }
      }, this.getRateIntervalScopedVariable(interval, scrapeInterval), this.getRangeScopedVars(options.range)));
    }

    query.step = interval;
    let expr = target.expr; // Apply adhoc filters

    expr = this.enhanceExprWithAdHocFilters(expr); // Only replace vars in expression after having (possibly) updated interval vars

    query.expr = this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr); // Align query interval with step to allow query caching and to ensure
    // that about-same-time query results look the same.

    const adjusted = alignRange(start, end, query.step, this.timeSrv.timeRange().to.utcOffset() * 60);
    query.start = adjusted.start;
    query.end = adjusted.end;

    this._addTracingHeaders(query, options);

    return query;
  }

  getRateIntervalScopedVariable(interval, scrapeInterval) {
    // Fall back to the default scrape interval of 15s if scrapeInterval is 0 for some reason.
    if (scrapeInterval === 0) {
      scrapeInterval = 15;
    }

    const rateInterval = Math.max(interval + scrapeInterval, 4 * scrapeInterval);
    return {
      __rate_interval: {
        text: rateInterval + 's',
        value: rateInterval + 's'
      }
    };
  }

  adjustInterval(interval, minInterval, range, intervalFactor) {
    // Prometheus will drop queries that might return more than 11000 data points.
    // Calculate a safe interval as an additional minimum to take into account.
    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1
    // If this is the case take the ceil of the value.
    let safeInterval = range / 11000;

    if (safeInterval > 1) {
      safeInterval = Math.ceil(safeInterval);
    }

    return Math.max(interval * intervalFactor, minInterval, safeInterval);
  }

  performTimeSeriesQuery(query, start, end) {
    if (start > end) {
      throw {
        message: 'Invalid time range'
      };
    }

    const url = '/api/v1/query_range';
    const data = {
      query: query.expr,
      start,
      end,
      step: query.step
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_30__.throwError)(this.handleErrors(err, query));
    }));
  }

  performInstantQuery(query, time) {
    const url = '/api/v1/query';
    const data = {
      query: query.expr,
      time
    };

    if (this.queryTimeout) {
      data['timeout'] = this.queryTimeout;
    }

    return this._request(url, data, {
      requestId: query.requestId,
      headers: query.headers
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_29__.catchError)(err => {
      if (err.cancelled) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_23__.of)(err);
      }

      return (0,rxjs__WEBPACK_IMPORTED_MODULE_30__.throwError)(this.handleErrors(err, query));
    }));
  }

  metricFindQuery(query) {
    if (!query) {
      return Promise.resolve([]);
    }

    const scopedVars = Object.assign({
      __interval: {
        text: this.interval,
        value: this.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.rangeUtil.intervalToMs(this.interval)
      }
    }, this.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_15__["default"](this, interpolated);
    return metricFindQuery.process();
  }

  getRangeScopedVars(range = this.timeSrv.timeRange()) {
    const msRange = range.to.diff(range.from);
    const sRange = Math.round(msRange / 1000);
    return {
      __range_ms: {
        text: msRange,
        value: msRange
      },
      __range_s: {
        text: sRange,
        value: sRange
      },
      __range: {
        text: sRange + 's',
        value: sRange + 's'
      }
    };
  }

  async annotationQuery(options) {
    const annotation = options.annotation;
    const {
      expr = ''
    } = annotation;

    if (!expr) {
      return Promise.resolve([]);
    }

    const step = options.annotation.step || ANNOTATION_QUERY_STEP_DEFAULT;
    const queryModel = {
      expr,
      range: true,
      instant: false,
      exemplar: false,
      interval: step,
      queryType: _types__WEBPACK_IMPORTED_MODULE_13__.PromQueryType.timeSeriesQuery,
      refId: 'X',
      datasource: this.getRef()
    };
    return await (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().fetch({
      url: '/api/ds/query',
      method: 'POST',
      data: {
        from: (this.getPrometheusTime(options.range.from, false) * 1000).toString(),
        to: (this.getPrometheusTime(options.range.to, true) * 1000).toString(),
        queries: [this.applyTemplateVariables(queryModel, {})]
      },
      requestId: `prom-query-${annotation.name}`
    }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.map)(rsp => {
      return this.processAnnotationResponse(options, rsp.data);
    })));
  }

  getExemplars(query) {
    const url = '/api/v1/query_exemplars';
    return this._request(url, {
      query: query.expr,
      start: query.start.toString(),
      end: query.end.toString()
    }, {
      requestId: query.requestId,
      headers: query.headers
    });
  }

  async getSubtitle() {
    const buildInfo = await this.getBuildInfo();
    return buildInfo ? this.getBuildInfoMessage(buildInfo) : null;
  }

  async getTagKeys(options) {
    if (options !== null && options !== void 0 && options.series) {
      // Get tags for the provided series only
      const seriesLabels = await Promise.all(options.series.map(series => this.languageProvider.fetchSeriesLabels(series)));
      const uniqueLabels = [...new Set(...seriesLabels.map(value => Object.keys(value)))];
      return uniqueLabels.map(value => ({
        text: value
      }));
    } else {
      var _result$data$data$map, _result$data, _result$data$data;

      // Get all tags
      const result = await this.metadataRequest('/api/v1/labels');
      return (_result$data$data$map = result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$data = _result$data.data) === null || _result$data$data === void 0 ? void 0 : _result$data$data.map(value => ({
        text: value
      }))) !== null && _result$data$data$map !== void 0 ? _result$data$data$map : [];
    }
  }

  async getTagValues(options = {}) {
    var _result$data$data$map2, _result$data2, _result$data2$data;

    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);
    return (_result$data$data$map2 = result === null || result === void 0 ? void 0 : (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : (_result$data2$data = _result$data2.data) === null || _result$data2$data === void 0 ? void 0 : _result$data2$data.map(value => ({
      text: value
    }))) !== null && _result$data$data$map2 !== void 0 ? _result$data$data$map2 : [];
  }

  async getBuildInfo() {
    try {
      const buildInfo = await (0,app_features_alerting_unified_api_buildInfo__WEBPACK_IMPORTED_MODULE_17__.fetchDataSourceBuildInfo)(this);
      return buildInfo;
    } catch (error) {
      // We don't want to break the rest of functionality if build info does not work correctly
      return undefined;
    }
  }

  getBuildInfoMessage(buildInfo) {
    var _buildInfo$applicatio, _buildInfo$applicatio2;

    const enabled = _Badge || (_Badge = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Badge, {
      color: "green",
      icon: "check",
      text: "Ruler API enabled"
    }));

    const disabled = _Badge2 || (_Badge2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Badge, {
      color: "orange",
      icon: "exclamation-triangle",
      text: "Ruler API not enabled"
    }));

    const unsupported = _Tooltip || (_Tooltip = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Tooltip, {
      placement: "top",
      content: "Prometheus does not allow editing rules, connect to either a Mimir or Cortex datasource to manage alerts via Grafana.",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Badge, {
          color: "red",
          icon: "exclamation-triangle",
          text: "Ruler API not supported"
        })
      })
    }));

    const LOGOS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Cortex]: '/public/app/plugins/datasource/prometheus/img/cortex_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Mimir]: '/public/app/plugins/datasource/prometheus/img/mimir_logo.svg',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus]: '/public/app/plugins/datasource/prometheus/img/prometheus_logo.svg'
    };
    const COLORS = {
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Cortex]: 'blue',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Mimir]: 'orange',
      [app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus]: 'red'
    }; // this will inform the user about what "subtype" the datasource is; Mimir, Cortex or vanilla Prometheus

    const applicationSubType = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_19__.Badge, {
      text: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)("span", {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("img", {
          style: {
            width: 14,
            height: 14,
            verticalAlign: 'text-bottom'
          },
          src: LOGOS[(_buildInfo$applicatio = buildInfo.application) !== null && _buildInfo$applicatio !== void 0 ? _buildInfo$applicatio : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus]
        }), ' ', buildInfo.application]
      }),
      color: COLORS[(_buildInfo$applicatio2 = buildInfo.application) !== null && _buildInfo$applicatio2 !== void 0 ? _buildInfo$applicatio2 : app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus]
    });

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'max-content max-content',
        rowGap: '0.5rem',
        columnGap: '2rem',
        marginTop: '1rem'
      },
      children: [_div || (_div = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: "Type"
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
        children: applicationSubType
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.Fragment, {
        children: [_div2 || (_div2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: "Ruler API"
        })), buildInfo.application === app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: unsupported
        }), buildInfo.application !== app_types_unified_alerting_dto__WEBPACK_IMPORTED_MODULE_18__.PromApplication.Prometheus && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_20__.jsx)("div", {
          children: buildInfo.features.rulerApiEnabled ? enabled : disabled
        })]
      })]
    });
  }

  async testDatasource() {
    const now = new Date().getTime();
    const request = {
      targets: [{
        refId: 'test',
        expr: '1+1',
        instant: true
      }],
      requestId: `${this.id}-health`,
      scopedVars: {},
      dashboardId: 0,
      panelId: 0,
      interval: '1m',
      intervalMs: 60000,
      maxDataPoints: 1,
      range: {
        from: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now - 1000),
        to: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(now)
      }
    };
    const buildInfo = await this.getBuildInfo();
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_21__.lastValueFrom)(this.query(request)).then(res => {
      if (!res || !res.data || res.state !== _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LoadingState.Done) {
        var _res$error;

        return {
          status: 'error',
          message: `Error reading Prometheus: ${res === null || res === void 0 ? void 0 : (_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message}`
        };
      } else {
        return {
          status: 'success',
          message: 'Data source is working',
          details: buildInfo && {
            verboseMessage: this.getBuildInfoMessage(buildInfo)
          }
        };
      }
    }).catch(err => {
      console.error('Prometheus Error', err);
      return {
        status: 'error',
        message: err.message
      };
    });
  }

  interpolateVariablesInQueries(queries, scopedVars) {
    let expandedQueries = queries;

    if (queries && queries.length) {
      expandedQueries = queries.map(query => {
        const expandedQuery = Object.assign({}, query, {
          datasource: this.getRef(),
          expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),
          interval: this.templateSrv.replace(query.interval, scopedVars)
        });
        return expandedQuery;
      });
    }

    return expandedQueries;
  }

  getQueryHints(query, result) {
    var _query$expr;

    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_11__.getQueryHints)((_query$expr = query.expr) !== null && _query$expr !== void 0 ? _query$expr : '', result, this);
  }

  getInitHints() {
    return (0,_query_hints__WEBPACK_IMPORTED_MODULE_11__.getInitHints)(this);
  }

  async loadRules() {
    try {
      var _res$data, _res$data$data;

      const res = await this.metadataRequest('/api/v1/rules');
      const groups = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : (_res$data$data = _res$data.data) === null || _res$data$data === void 0 ? void 0 : _res$data$data.groups;

      if (groups) {
        this.ruleMappings = extractRuleMappingFromGroups(groups);
      }
    } catch (e) {
      console.log('Rules API is experimental. Ignore next error.');
      console.error(e);
    }
  }

  async areExemplarsAvailable() {
    try {
      const res = await this.metadataRequest('/api/v1/query_exemplars', {
        query: 'test'
      });

      if (res.data.status === 'success') {
        return true;
      }

      return false;
    } catch (err) {
      return false;
    }
  }

  modifyQuery(query, action) {
    var _query$expr2;

    let expression = (_query$expr2 = query.expr) !== null && _query$expr2 !== void 0 ? _query$expr2 : '';

    switch (action.type) {
      case 'ADD_FILTER':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_8__.addLabelToQuery)(expression, action.key, action.value);
          break;
        }

      case 'ADD_FILTER_OUT':
        {
          expression = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_8__.addLabelToQuery)(expression, action.key, action.value, '!=');
          break;
        }

      case 'ADD_HISTOGRAM_QUANTILE':
        {
          expression = `histogram_quantile(0.95, sum(rate(${expression}[$__rate_interval])) by (le))`;
          break;
        }

      case 'ADD_RATE':
        {
          expression = `rate(${expression}[$__rate_interval])`;
          break;
        }

      case 'ADD_SUM':
        {
          expression = `sum(${expression.trim()}) by ($1)`;
          break;
        }

      case 'EXPAND_RULES':
        {
          if (action.mapping) {
            expression = (0,_language_utils__WEBPACK_IMPORTED_MODULE_10__.expandRecordingRules)(expression, action.mapping);
          }

          break;
        }

      default:
        break;
    }

    return Object.assign({}, query, {
      expr: expression
    });
  }

  getPrometheusTime(date, roundUp) {
    if (typeof date === 'string') {
      date = _grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateMath.parse(date, roundUp);
    }

    return Math.ceil(date.valueOf() / 1000);
  }

  getTimeRangeParams() {
    const range = this.timeSrv.timeRange();
    return {
      start: this.getPrometheusTime(range.from, false).toString(),
      end: this.getPrometheusTime(range.to, true).toString()
    };
  }

  getOriginalMetricName(labelData) {
    return (0,_result_transformer__WEBPACK_IMPORTED_MODULE_12__.getOriginalMetricName)(labelData);
  }

  enhanceExprWithAdHocFilters(expr) {
    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);
    const finalQuery = adhocFilters.reduce((acc, filter) => {
      const {
        key,
        operator
      } = filter;
      let {
        value
      } = filter;

      if (operator === '=~' || operator === '!~') {
        value = prometheusRegularEscape(value);
      }

      return (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_8__.addLabelToQuery)(acc, key, value, operator);
    }, expr);
    return finalQuery;
  } // Used when running queries trough backend


  filterQuery(query) {
    if (query.hide || !query.expr) {
      return false;
    }

    return true;
  } // Used when running queries trough backend


  applyTemplateVariables(target, scopedVars) {
    const variables = (0,lodash__WEBPACK_IMPORTED_MODULE_1__.cloneDeep)(scopedVars); // We want to interpolate these variables on backend

    delete variables.__interval;
    delete variables.__interval_ms; //Add ad hoc filters

    const expr = this.enhanceExprWithAdHocFilters(target.expr);
    return Object.assign({}, target, {
      legendFormat: this.templateSrv.replace(target.legendFormat, variables),
      expr: this.templateSrv.replace(expr, variables, this.interpolateQueryExpr),
      interval: this.templateSrv.replace(target.interval, variables)
    });
  }

  getVariables() {
    return this.templateSrv.getVariables().map(v => `$${v.name}`);
  }

  interpolateString(string) {
    return this.templateSrv.replace(string, undefined, this.interpolateQueryExpr);
  }

}
/**
 * Align query range to step.
 * Rounds start and end down to a multiple of step.
 * @param start Timestamp marking the beginning of the range.
 * @param end Timestamp marking the end of the range.
 * @param step Interval to align start and end with.
 * @param utcOffsetSec Number of seconds current timezone is offset from UTC
 */

function alignRange(start, end, step, utcOffsetSec) {
  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;
  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;
  return {
    end: alignedEnd,
    start: alignedStart
  };
}
function extractRuleMappingFromGroups(groups) {
  return groups.reduce((mapping, group) => group.rules.filter(rule => rule.type === 'recording').reduce((acc, rule) => Object.assign({}, acc, {
    [rule.name]: rule.query
  }), mapping), {});
} // NOTE: these two functions are very similar to the escapeLabelValueIn* functions
// in language_utils.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.

function prometheusRegularEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\').replace(/'/g, "\\\\'") : value;
}
function prometheusSpecialRegexEscape(value) {
  return typeof value === 'string' ? value.replace(/\\/g, '\\\\\\\\').replace(/[$^*{}\[\]\'+?.()|]/g, '\\\\$&') : value;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_provider.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUGGESTIONS_LIMIT": () => (/* binding */ SUGGESTIONS_LIMIT),
/* harmony export */   "addHistoryMetadata": () => (/* binding */ addHistoryMetadata),
/* harmony export */   "default": () => (/* binding */ PromQlLanguageProvider),
/* harmony export */   "getMetadataString": () => (/* binding */ getMetadataString)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lru-cache-npm-7.7.1-726274dc4d-f362c5a2cf.zip/node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _language_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_utils.ts");
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const DEFAULT_KEYS = ['job', 'instance'];
const EMPTY_SELECTOR = '{}';
const HISTORY_ITEM_COUNT = 5;
const HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h
// Max number of items (metrics, labels, values) that we display as suggestions. Prevents from running out of memory.

const SUGGESTIONS_LIMIT = 10000;

const wrapLabel = label => ({
  label
});

const setFunctionKind = suggestion => {
  suggestion.kind = 'function';
  return suggestion;
};

function addHistoryMetadata(item, history) {
  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;
  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);
  const count = historyForItem.length;
  const recent = historyForItem[0];
  let hint = `Queried ${count} times in the last 24h.`;

  if (recent) {
    const lastQueried = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_3__.dateTime)(recent.ts).fromNow();
    hint = `${hint} Last queried ${lastQueried}.`;
  }

  return Object.assign({}, item, {
    documentation: hint
  });
}

function addMetricsMetadata(metric, metadata) {
  const item = {
    label: metric
  };

  if (metadata && metadata[metric]) {
    item.documentation = getMetadataString(metric, metadata);
  }

  return item;
}

function getMetadataString(metric, metadata) {
  if (!metadata[metric]) {
    return undefined;
  }

  const {
    type,
    help
  } = metadata[metric];
  return `${type.toUpperCase()}: ${help}`;
}
const PREFIX_DELIMITER_REGEX = /(="|!="|=~"|!~"|\{|\[|\(|\+|-|\/|\*|%|\^|\band\b|\bor\b|\bunless\b|==|>=|!=|<=|>|<|=|~|,)/;
class PromQlLanguageProvider extends _grafana_data__WEBPACK_IMPORTED_MODULE_3__.LanguageProvider {
  /**
   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does
   *  not account for different size of a response. If that is needed a `length` function can be added in the options.
   *  10 as a max size is totally arbitrary right now.
   */
  constructor(datasource, initialValues) {
    super();

    _defineProperty(this, "histogramMetrics", void 0);

    _defineProperty(this, "timeRange", void 0);

    _defineProperty(this, "metrics", void 0);

    _defineProperty(this, "metricsMetadata", void 0);

    _defineProperty(this, "datasource", void 0);

    _defineProperty(this, "labelKeys", []);

    _defineProperty(this, "labelsCache", new (lru_cache__WEBPACK_IMPORTED_MODULE_1___default())({
      max: 10
    }));

    _defineProperty(this, "request", async (url, defaultValue, params = {}) => {
      try {
        const res = await this.datasource.metadataRequest(url, params);
        return res.data.data;
      } catch (error) {
        console.error(error);
      }

      return defaultValue;
    });

    _defineProperty(this, "start", async () => {
      if (this.datasource.lookupsDisabled) {
        return [];
      } // TODO #33976: make those requests parallel


      await this.fetchLabels();
      this.metrics = (await this.fetchLabelValues('__name__')) || [];
      await this.loadMetricsMetadata();
      this.histogramMetrics = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processHistogramMetrics)(this.metrics).sort();
      return [];
    });

    _defineProperty(this, "provideCompletionItems", async ({
      prefix,
      text,
      value,
      labelKey,
      wrapperClasses
    }, context = {}) => {
      const emptyResult = {
        suggestions: []
      };

      if (!value) {
        return emptyResult;
      } // Local text properties


      const empty = value.document.text.length === 0;
      const selectedLines = value.document.getTextsAtRange(value.selection);
      const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;
      const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null; // Syntax spans have 3 classes by default. More indicate a recognized token

      const tokenRecognized = wrapperClasses.length > 3; // Non-empty prefix, but not inside known token

      const prefixUnrecognized = prefix && !tokenRecognized; // Prevent suggestions in `function(|suffix)`

      const noSuffix = !nextCharacter || nextCharacter === ')'; // Prefix is safe if it does not immediately follow a complete expression and has no text after it

      const safePrefix = prefix && !text.match(/^[\]})\s]+$/) && noSuffix; // About to type next operand if preceded by binary operator

      const operatorsPattern = /[+\-*/^%]/;
      const isNextOperand = text.match(operatorsPattern); // Determine candidates by CSS context

      if (wrapperClasses.includes('context-range')) {
        // Suggestions for metric[|]
        return this.getRangeCompletionItems();
      } else if (wrapperClasses.includes('context-labels')) {
        // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}
        return this.getLabelCompletionItems({
          prefix,
          text,
          value,
          labelKey,
          wrapperClasses
        });
      } else if (wrapperClasses.includes('context-aggregation')) {
        // Suggestions for sum(metric) by (|)
        return this.getAggregationCompletionItems(value);
      } else if (empty) {
        // Suggestions for empty query field
        return this.getEmptyCompletionItems(context);
      } else if (prefixUnrecognized && noSuffix && !isNextOperand) {
        // Show term suggestions in a couple of scenarios
        return this.getBeginningCompletionItems(context);
      } else if (prefixUnrecognized && safePrefix) {
        // Show term suggestions in a couple of scenarios
        return this.getTermCompletionItems();
      }

      return emptyResult;
    });

    _defineProperty(this, "getBeginningCompletionItems", context => {
      return {
        suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions]
      };
    });

    _defineProperty(this, "getEmptyCompletionItems", context => {
      const {
        history
      } = context;
      const suggestions = [];

      if (history && history.length) {
        const historyItems = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(history).map(h => h.query.expr).filter().uniq().take(HISTORY_ITEM_COUNT).map(wrapLabel).map(item => addHistoryMetadata(item, history)).value();
        suggestions.push({
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
          skipSort: true,
          label: 'History',
          items: historyItems
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getTermCompletionItems", () => {
      const {
        metrics,
        metricsMetadata
      } = this;
      const suggestions = [];
      suggestions.push({
        searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Prefix,
        label: 'Functions',
        items: _promql__WEBPACK_IMPORTED_MODULE_6__.FUNCTIONS.map(setFunctionKind)
      });

      if (metrics && metrics.length) {
        suggestions.push({
          label: 'Metrics',
          items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return {
        suggestions
      };
    });

    _defineProperty(this, "getAggregationCompletionItems", async value => {
      const suggestions = []; // Stitch all query lines together to support multi-line queries

      let queryOffset;
      const queryText = value.document.getBlocks().reduce((text, block) => {
        if (text === undefined) {
          return '';
        }

        if (!block) {
          return text;
        }

        const blockText = block === null || block === void 0 ? void 0 : block.getText();

        if (value.anchorBlock.key === block.key) {
          // Newline characters are not accounted for but this is irrelevant
          // for the purpose of extracting the selector string
          queryOffset = value.selection.anchor.offset + text.length;
        }

        return text + blockText;
      }, ''); // Try search for selector part on the left-hand side, such as `sum (m) by (l)`

      const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);
      let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);
      let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex); // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`

      if (openParensSelectorIndex === -1) {
        const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);
        closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);
        openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);
      }

      const result = {
        suggestions,
        context: 'context-aggregation'
      }; // Suggestions are useless for alternative aggregation clauses without a selector in context

      if (openParensSelectorIndex === -1) {
        return result;
      } // Range vector syntax not accounted for by subsequent parse so discard it if present


      const selectorString = queryText.slice(openParensSelectorIndex + 1, closeParensSelectorIndex).replace(/\[[^\]]+\]$/, '');
      const selector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(selectorString, selectorString.length - 2).selector;
      const series = await this.getSeries(selector);
      const labelKeys = Object.keys(series);

      if (labelKeys.length > 0) {
        const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(labelKeys);
        suggestions.push({
          label: `Labels${limitInfo}`,
          items: labelKeys.map(wrapLabel),
          searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
        });
      }

      return result;
    });

    _defineProperty(this, "getLabelCompletionItems", async ({
      text,
      wrapperClasses,
      labelKey,
      value
    }) => {
      if (!value) {
        return {
          suggestions: []
        };
      }

      const suggestions = [];
      const line = value.anchorBlock.getText();
      const cursorOffset = value.selection.anchor.offset;
      const suffix = line.substr(cursorOffset);
      const prefix = line.substr(0, cursorOffset);
      const isValueStart = text.match(/^(=|=~|!=|!~)/);
      const isValueEnd = suffix.match(/^"?[,}]|$/); // Detect cursor in front of value, e.g., {key=|"}

      const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^"/); // Don't suggest anything at the beginning or inside a value

      const isValueEmpty = isValueStart && isValueEnd;
      const hasValuePrefix = isValueEnd && !isValueStart;

      if (!isValueEmpty && !hasValuePrefix || isPreValue) {
        return {
          suggestions
        };
      } // Get normalized selector


      let selector;
      let parsedSelector;

      try {
        parsedSelector = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.parseSelector)(line, cursorOffset);
        selector = parsedSelector.selector;
      } catch {
        selector = EMPTY_SELECTOR;
      }

      const containsMetric = selector.includes('__name__=');
      const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];
      let series = {}; // Query labels for selector

      if (selector) {
        series = await this.getSeries(selector, !containsMetric);
      }

      if (Object.keys(series).length === 0) {
        console.warn(`Server did not return any values for selector = ${selector}`);
        return {
          suggestions
        };
      }

      let context;

      if (text && isValueStart || wrapperClasses.includes('attr-value')) {
        // Label values
        if (labelKey && series[labelKey]) {
          context = 'context-label-values';
          const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(series[labelKey]);
          suggestions.push({
            label: `Label values for "${labelKey}"${limitInfo}`,
            items: series[labelKey].map(wrapLabel),
            searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
          });
        }
      } else {
        // Label keys
        const labelKeys = series ? Object.keys(series) : containsMetric ? null : DEFAULT_KEYS;

        if (labelKeys) {
          const possibleKeys = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.difference)(labelKeys, existingKeys);

          if (possibleKeys.length) {
            context = 'context-labels';
            const newItems = possibleKeys.map(key => ({
              label: key
            }));
            const limitInfo = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.addLimitInfo)(newItems);
            const newSuggestion = {
              label: `Labels${limitInfo}`,
              items: newItems,
              searchFunctionType: _grafana_ui__WEBPACK_IMPORTED_MODULE_4__.SearchFunctionType.Fuzzy
            };
            suggestions.push(newSuggestion);
          }
        }
      }

      return {
        context,
        suggestions
      };
    });

    _defineProperty(this, "fetchLabelValues", async key => {
      const params = this.datasource.getTimeRangeParams();
      const url = `/api/v1/label/${this.datasource.interpolateString(key)}/values`;
      return await this.request(url, [], params);
    });

    _defineProperty(this, "fetchSeriesLabels", async (name, withName) => {
      const interpolatedName = this.datasource.interpolateString(name);
      const range = this.datasource.getTimeRangeParams();
      const urlParams = Object.assign({}, range, {
        'match[]': interpolatedName
      });
      const url = `/api/v1/series`; // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.
      // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every
      // millisecond while still actually getting all the keys for the correct interval. This still can create problems
      // when user does not the newest values for a minute if already cached.

      const cacheParams = new URLSearchParams({
        'match[]': interpolatedName,
        start: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.start, 10)).toString(),
        end: (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.roundSecToMin)(parseInt(range.end, 10)).toString(),
        withName: withName ? 'true' : 'false'
      });
      const cacheKey = `/api/v1/series?${cacheParams.toString()}`;
      let value = this.labelsCache.get(cacheKey);

      if (!value) {
        const data = await this.request(url, [], urlParams);
        const {
          values
        } = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.processLabels)(data, withName);
        value = values;
        this.labelsCache.set(cacheKey, value);
      }

      return value;
    });

    _defineProperty(this, "fetchSeries", async match => {
      const url = '/api/v1/series';
      const range = this.datasource.getTimeRangeParams();
      const params = Object.assign({}, range, {
        'match[]': match
      });
      return await this.request(url, {}, params);
    });

    _defineProperty(this, "fetchDefaultSeries", (0,lodash__WEBPACK_IMPORTED_MODULE_0__.once)(async () => {
      const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));
      return DEFAULT_KEYS.reduce((acc, key, i) => Object.assign({}, acc, {
        [key]: values[i]
      }), {});
    }));

    this.datasource = datasource;
    this.histogramMetrics = [];
    this.timeRange = {
      start: 0,
      end: 0
    };
    this.metrics = [];
    Object.assign(this, initialValues);
  } // Strip syntax chars so that typeahead suggestions can work on clean inputs


  cleanText(s) {
    const parts = s.split(PREFIX_DELIMITER_REGEX);
    const last = parts.pop();
    return last.trimLeft().replace(/"$/, '').replace(/^"/, '');
  }

  get syntax() {
    return _promql__WEBPACK_IMPORTED_MODULE_6__["default"];
  }

  async loadMetricsMetadata() {
    this.metricsMetadata = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.fixSummariesMetadata)(await this.request('/api/v1/metadata', {}));
  }

  getLabelKeys() {
    return this.labelKeys;
  }

  getRangeCompletionItems() {
    return {
      context: 'context-range',
      suggestions: [{
        label: 'Range vector',
        items: [..._promql__WEBPACK_IMPORTED_MODULE_6__.RATE_RANGES]
      }]
    };
  }

  importFromAbstractQuery(labelBasedQuery) {
    return (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.toPromLikeQuery)(labelBasedQuery);
  }

  exportToAbstractQuery(query) {
    const promQuery = query.expr;

    if (!promQuery || promQuery.length === 0) {
      return {
        refId: query.refId,
        labelMatchers: []
      };
    }

    const tokens = prismjs__WEBPACK_IMPORTED_MODULE_2___default().tokenize(promQuery, _promql__WEBPACK_IMPORTED_MODULE_6__["default"]);
    const labelMatchers = (0,_language_utils__WEBPACK_IMPORTED_MODULE_5__.extractLabelMatchers)(tokens);
    const nameLabelValue = getNameLabelValue(promQuery, tokens);

    if (nameLabelValue && nameLabelValue.length > 0) {
      labelMatchers.push({
        name: '__name__',
        operator: _grafana_data__WEBPACK_IMPORTED_MODULE_3__.AbstractLabelOperator.Equal,
        value: nameLabelValue
      });
    }

    return {
      refId: query.refId,
      labelMatchers
    };
  }

  async getSeries(selector, withName) {
    if (this.datasource.lookupsDisabled) {
      return {};
    }

    try {
      if (selector === EMPTY_SELECTOR) {
        return await this.fetchDefaultSeries();
      } else {
        return await this.fetchSeriesLabels(selector, withName);
      }
    } catch (error) {
      // TODO: better error handling
      console.error(error);
      return {};
    }
  }

  async getLabelValues(key) {
    return await this.fetchLabelValues(key);
  }
  /**
   * Fetches all label keys
   */


  async fetchLabels() {
    const url = '/api/v1/labels';
    const params = this.datasource.getTimeRangeParams();
    this.labelFetchTs = Date.now().valueOf();
    const res = await this.request(url, [], params);

    if (Array.isArray(res)) {
      this.labelKeys = res.slice().sort();
    }

    return [];
  }
  /**
   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as
   * they can change over requested time.
   * @param name
   * @param withName
   */


}

function getNameLabelValue(promQuery, tokens) {
  let nameLabelValue = '';

  for (let prop in tokens) {
    if (typeof tokens[prop] === 'string') {
      nameLabelValue = tokens[prop];
      break;
    }
  }

  return nameLabelValue;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/language_utils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addLimitInfo": () => (/* binding */ addLimitInfo),
/* harmony export */   "escapeLabelValueInExactSelector": () => (/* binding */ escapeLabelValueInExactSelector),
/* harmony export */   "escapeLabelValueInRegexSelector": () => (/* binding */ escapeLabelValueInRegexSelector),
/* harmony export */   "expandRecordingRules": () => (/* binding */ expandRecordingRules),
/* harmony export */   "extractLabelMatchers": () => (/* binding */ extractLabelMatchers),
/* harmony export */   "fixSummariesMetadata": () => (/* binding */ fixSummariesMetadata),
/* harmony export */   "labelRegexp": () => (/* binding */ labelRegexp),
/* harmony export */   "limitSuggestions": () => (/* binding */ limitSuggestions),
/* harmony export */   "parseSelector": () => (/* binding */ parseSelector),
/* harmony export */   "processHistogramMetrics": () => (/* binding */ processHistogramMetrics),
/* harmony export */   "processLabels": () => (/* binding */ processLabels),
/* harmony export */   "roundMsToMin": () => (/* binding */ roundMsToMin),
/* harmony export */   "roundSecToMin": () => (/* binding */ roundSecToMin),
/* harmony export */   "selectorRegexp": () => (/* binding */ selectorRegexp),
/* harmony export */   "toPromLikeExpr": () => (/* binding */ toPromLikeExpr),
/* harmony export */   "toPromLikeQuery": () => (/* binding */ toPromLikeQuery)
/* harmony export */ });
/* harmony import */ var _add_label_to_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/add_label_to_query.ts");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const processHistogramMetrics = metrics => {
  const resultSet = new Set();
  const regexp = new RegExp('_bucket($|:)');

  for (let index = 0; index < metrics.length; index++) {
    const metric = metrics[index];
    const isHistogramValue = regexp.test(metric);

    if (isHistogramValue) {
      resultSet.add(metric);
    }
  }

  return [...resultSet];
};
function processLabels(labels, withName = false) {
  // For processing we are going to use sets as they have significantly better performance than arrays
  // After we process labels, we will convert sets to arrays and return object with label values in arrays
  const valueSet = {};
  labels.forEach(label => {
    const {
      __name__
    } = label,
          rest = _objectWithoutPropertiesLoose(label, _excluded);

    if (withName) {
      valueSet['__name__'] = valueSet['__name__'] || new Set();

      if (!valueSet['__name__'].has(__name__)) {
        valueSet['__name__'].add(__name__);
      }
    }

    Object.keys(rest).forEach(key => {
      if (!valueSet[key]) {
        valueSet[key] = new Set();
      }

      if (!valueSet[key].has(rest[key])) {
        valueSet[key].add(rest[key]);
      }
    });
  }); // valueArray that we are going to return in the object

  const valueArray = {};
  limitSuggestions(Object.keys(valueSet)).forEach(key => {
    valueArray[key] = limitSuggestions(Array.from(valueSet[key]));
  });
  return {
    values: valueArray,
    keys: Object.keys(valueArray)
  };
} // const cleanSelectorRegexp = /\{(\w+="[^"\n]*?")(,\w+="[^"\n]*?")*\}/;

const selectorRegexp = /\{[^}]*?(\}|$)/;
const labelRegexp = /\b(\w+)(!?=~?)("[^"\n]*?")/g;
function parseSelector(query, cursorOffset = 1) {
  if (!query.match(selectorRegexp)) {
    // Special matcher for metrics
    if (query.match(/^[A-Za-z:][\w:]*$/)) {
      return {
        selector: `{__name__="${query}"}`,
        labelKeys: ['__name__']
      };
    }

    throw new Error('Query must contain a selector: ' + query);
  } // Check if inside a selector


  const prefix = query.slice(0, cursorOffset);
  const prefixOpen = prefix.lastIndexOf('{');
  const prefixClose = prefix.lastIndexOf('}');

  if (prefixOpen === -1) {
    throw new Error('Not inside selector, missing open brace: ' + prefix);
  }

  if (prefixClose > -1 && prefixClose > prefixOpen) {
    throw new Error('Not inside selector, previous selector already closed: ' + prefix);
  }

  const suffix = query.slice(cursorOffset);
  const suffixCloseIndex = suffix.indexOf('}');
  const suffixClose = suffixCloseIndex + cursorOffset;
  const suffixOpenIndex = suffix.indexOf('{');
  const suffixOpen = suffixOpenIndex + cursorOffset;

  if (suffixClose === -1) {
    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);
  }

  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {
    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);
  } // Extract clean labels to form clean selector, incomplete labels are dropped


  const selector = query.slice(prefixOpen, suffixClose);
  const labels = {};
  selector.replace(labelRegexp, (label, key, operator, value) => {
    const labelOffset = query.indexOf(label);
    const valueStart = labelOffset + key.length + operator.length + 1;
    const valueEnd = labelOffset + key.length + operator.length + value.length - 1; // Skip label if cursor is in value

    if (cursorOffset < valueStart || cursorOffset > valueEnd) {
      labels[key] = {
        value,
        operator
      };
    }

    return '';
  }); // Add metric if there is one before the selector

  const metricPrefix = query.slice(0, prefixOpen);
  const metricMatch = metricPrefix.match(/[A-Za-z:][\w:]*$/);

  if (metricMatch) {
    labels['__name__'] = {
      value: `"${metricMatch[0]}"`,
      operator: '='
    };
  } // Build sorted selector


  const labelKeys = Object.keys(labels).sort();
  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');
  const selectorString = ['{', cleanSelector, '}'].join('');
  return {
    labelKeys,
    selector: selectorString
  };
}
function expandRecordingRules(query, mapping) {
  const ruleNames = Object.keys(mapping);
  const rulesRegex = new RegExp(`(\\s|^)(${ruleNames.join('|')})(\\s|$|\\(|\\[|\\{)`, 'ig');
  const expandedQuery = query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`); // Split query into array, so if query uses operators, we can correctly add labels to each individual part.

  const queryArray = expandedQuery.split(/(\+|\-|\*|\/|\%|\^)/); // Regex that matches occurrences of ){ or }{ or ]{ which is a sign of incorrecly added labels.

  const invalidLabelsRegex = /(\)\{|\}\{|\]\{)/;
  const correctlyExpandedQueryArray = queryArray.map(query => {
    return addLabelsToExpression(query, invalidLabelsRegex);
  });
  return correctlyExpandedQueryArray.join('');
}

function addLabelsToExpression(expr, invalidLabelsRegexp) {
  var _match$index;

  const match = expr.match(invalidLabelsRegexp);

  if (!match) {
    return expr;
  } // Split query into 2 parts - before the invalidLabelsRegex match and after.


  const indexOfRegexMatch = (_match$index = match.index) !== null && _match$index !== void 0 ? _match$index : 0;
  const exprBeforeRegexMatch = expr.slice(0, indexOfRegexMatch + 1);
  const exprAfterRegexMatch = expr.slice(indexOfRegexMatch + 1); // Create arrayOfLabelObjects with label objects that have key, operator and value.

  const arrayOfLabelObjects = [];
  exprAfterRegexMatch.replace(labelRegexp, (label, key, operator, value) => {
    arrayOfLabelObjects.push({
      key,
      operator,
      value
    });
    return '';
  }); // Loop through all label objects and add them to query.
  // As a starting point we have valid query without the labels.

  let result = exprBeforeRegexMatch;
  arrayOfLabelObjects.filter(Boolean).forEach(obj => {
    // Remove extra set of quotes from obj.value
    const value = obj.value.slice(1, -1);
    result = (0,_add_label_to_query__WEBPACK_IMPORTED_MODULE_0__.addLabelToQuery)(result, obj.key, value, obj.operator);
  });
  return result;
}
/**
 * Adds metadata for synthetic metrics for which the API does not provide metadata.
 * See https://github.com/grafana/grafana/issues/22337 for details.
 *
 * @param metadata HELP and TYPE metadata from /api/v1/metadata
 */


function fixSummariesMetadata(metadata) {
  if (!metadata) {
    return metadata;
  }

  const baseMetadata = {};
  const summaryMetadata = {};

  for (const metric in metadata) {
    // NOTE: based on prometheus-documentation, we can receive
    // multiple metadata-entries for the given metric, it seems
    // it happens when the same metric is on multiple targets
    // and their help-text differs
    // (https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata)
    // for now we just use the first entry.
    const item = metadata[metric][0];
    baseMetadata[metric] = item;

    if (item.type === 'histogram') {
      summaryMetadata[`${metric}_bucket`] = {
        type: 'counter',
        help: `Cumulative counters for the observation buckets (${item.help})`
      };
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the histogram metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the histogram metric (${item.help})`
      };
    }

    if (item.type === 'summary') {
      summaryMetadata[`${metric}_count`] = {
        type: 'counter',
        help: `Count of events that have been observed for the base metric (${item.help})`
      };
      summaryMetadata[`${metric}_sum`] = {
        type: 'counter',
        help: `Total sum of all observed values for the base metric (${item.help})`
      };
    }
  } // Synthetic series


  const syntheticMetadata = {};
  syntheticMetadata['ALERTS'] = {
    type: 'counter',
    help: 'Time series showing pending and firing alerts. The sample value is set to 1 as long as the alert is in the indicated active (pending or firing) state.'
  };
  return Object.assign({}, baseMetadata, summaryMetadata, syntheticMetadata);
}
function roundMsToMin(milliseconds) {
  return roundSecToMin(milliseconds / 1000);
}
function roundSecToMin(seconds) {
  return Math.floor(seconds / 60);
}
function limitSuggestions(items) {
  return items.slice(0, _language_provider__WEBPACK_IMPORTED_MODULE_1__.SUGGESTIONS_LIMIT);
}
function addLimitInfo(items) {
  return items && items.length >= _language_provider__WEBPACK_IMPORTED_MODULE_1__.SUGGESTIONS_LIMIT ? `, limited to the first ${_language_provider__WEBPACK_IMPORTED_MODULE_1__.SUGGESTIONS_LIMIT} received items` : '';
} // NOTE: the following 2 exported functions are very similar to the prometheus*Escape
// functions in datasource.ts, but they are not exactly the same algorithm, and we found
// no way to reuse one in the another or vice versa.
// Prometheus regular-expressions use the RE2 syntax (https://github.com/google/re2/wiki/Syntax),
// so every character that matches something in that list has to be escaped.
// the list of metacharacters is: *+?()|\.[]{}^$
// we make a javascript regular expression that matches those characters:

const RE2_METACHARACTERS = /[*+?()|\\.\[\]{}^$]/g;

function escapePrometheusRegexp(value) {
  return value.replace(RE2_METACHARACTERS, '\\$&');
} // based on the openmetrics-documentation, the 3 symbols we have to handle are:
// - \n ... the newline character
// - \  ... the backslash character
// - "  ... the double-quote character


function escapeLabelValueInExactSelector(labelValue) {
  return labelValue.replace(/\\/g, '\\\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
}
function escapeLabelValueInRegexSelector(labelValue) {
  return escapeLabelValueInExactSelector(escapePrometheusRegexp(labelValue));
}
const FromPromLikeMap = {
  '=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.Equal,
  '!=': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqual,
  '=~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.EqualRegEx,
  '!~': _grafana_data__WEBPACK_IMPORTED_MODULE_2__.AbstractLabelOperator.NotEqualRegEx
};
const ToPromLikeMap = (0,lodash__WEBPACK_IMPORTED_MODULE_4__.invert)(FromPromLikeMap);
function toPromLikeExpr(labelBasedQuery) {
  const expr = labelBasedQuery.labelMatchers.map(selector => {
    const operator = ToPromLikeMap[selector.operator];

    if (operator) {
      return `${selector.name}${operator}"${selector.value}"`;
    } else {
      return '';
    }
  }).filter(e => e !== '').join(', ');
  return expr ? `{${expr}}` : '';
}
function toPromLikeQuery(labelBasedQuery) {
  return {
    refId: labelBasedQuery.refId,
    expr: toPromLikeExpr(labelBasedQuery),
    range: true
  };
}
function extractLabelMatchers(tokens) {
  const labelMatchers = [];

  for (let prop in tokens) {
    if (tokens[prop] instanceof prismjs__WEBPACK_IMPORTED_MODULE_3__.Token) {
      let token = tokens[prop];

      if (token.type === 'context-labels') {
        let labelKey = '';
        let labelValue = '';
        let labelOperator = '';
        let contentTokens = token.content;

        for (let currentToken in contentTokens) {
          if (typeof contentTokens[currentToken] === 'string') {
            let currentStr;
            currentStr = contentTokens[currentToken];

            if (currentStr === '=' || currentStr === '!=' || currentStr === '=~' || currentStr === '!~') {
              labelOperator = currentStr;
            }
          } else if (contentTokens[currentToken] instanceof prismjs__WEBPACK_IMPORTED_MODULE_3__.Token) {
            switch (contentTokens[currentToken].type) {
              case 'label-key':
                labelKey = contentTokens[currentToken].content;
                break;

              case 'label-value':
                labelValue = contentTokens[currentToken].content;
                labelValue = labelValue.substring(1, labelValue.length - 1);
                const labelComparator = FromPromLikeMap[labelOperator];

                if (labelComparator) {
                  labelMatchers.push({
                    name: labelKey,
                    operator: labelComparator,
                    value: labelValue
                  });
                }

                break;
            }
          }
        }
      }
    }
  }

  return labelMatchers;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/metric_find_query.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PrometheusMetricFindQuery)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





class PrometheusMetricFindQuery {
  constructor(datasource, query) {
    this.datasource = datasource;
    this.query = query;

    _defineProperty(this, "range", void 0);

    this.datasource = datasource;
    this.query = query;
    this.datasource = datasource;
    this.query = query;
    this.range = (0,app_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_1__.getTimeSrv)().timeRange();
  }

  process() {
    const labelNamesRegex = /^label_names\(\)\s*$/;
    const labelValuesRegex = /^label_values\((?:(.+),\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\)\s*$/;
    const metricNamesRegex = /^metrics\((.+)\)\s*$/;
    const queryResultRegex = /^query_result\((.+)\)\s*$/;
    const labelNamesQuery = this.query.match(labelNamesRegex);

    if (labelNamesQuery) {
      return this.labelNamesQuery();
    }

    const labelValuesQuery = this.query.match(labelValuesRegex);

    if (labelValuesQuery) {
      if (labelValuesQuery[1]) {
        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);
      } else {
        return this.labelValuesQuery(labelValuesQuery[2]);
      }
    }

    const metricNamesQuery = this.query.match(metricNamesRegex);

    if (metricNamesQuery) {
      return this.metricNameQuery(metricNamesQuery[1]);
    }

    const queryResultQuery = this.query.match(queryResultRegex);

    if (queryResultQuery) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.lastValueFrom)(this.queryResultQuery(queryResultQuery[1]));
    } // if query contains full metric name, return metric name and label list


    return this.metricNameAndLabelsQuery(this.query);
  }

  labelNamesQuery() {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/labels`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
        return {
          text: value
        };
      });
    });
  }

  labelValuesQuery(label, metric) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    let url;

    if (!metric) {
      const params = {
        start: start.toString(),
        end: end.toString()
      }; // return label values globally

      url = `/api/v1/label/${label}/values`;
      return this.datasource.metadataRequest(url, params).then(result => {
        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, value => {
          return {
            text: value
          };
        });
      });
    } else {
      const params = {
        'match[]': metric,
        start: start.toString(),
        end: end.toString()
      };
      url = `/api/v1/series`;
      return this.datasource.metadataRequest(url, params).then(result => {
        const _labels = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
          return metric[label] || '';
        }).filter(label => {
          return label !== '';
        });

        return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.uniq)(_labels).map(metric => {
          return {
            text: metric,
            expandable: true
          };
        });
      });
    }
  }

  metricNameQuery(metricFilterPattern) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/label/__name__/values`;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.chain)(result.data.data).filter(metricName => {
        const r = new RegExp(metricFilterPattern);
        return r.test(metricName);
      }).map(matchedMetricName => {
        return {
          text: matchedMetricName,
          expandable: true
        };
      }).value();
    });
  }

  queryResultQuery(query) {
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const instantQuery = {
      expr: query
    };
    return this.datasource.performInstantQuery(instantQuery, end).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data.result, metricData => {
        let text = metricData.metric.__name__ || '';
        delete metricData.metric.__name__;
        text += '{' + (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(metricData.metric, (v, k) => {
          return k + '="' + v + '"';
        }).join(',') + '}';
        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;
        return {
          text: text,
          expandable: true
        };
      });
    }));
  }

  metricNameAndLabelsQuery(query) {
    const start = this.datasource.getPrometheusTime(this.range.from, false);
    const end = this.datasource.getPrometheusTime(this.range.to, true);
    const params = {
      'match[]': query,
      start: start.toString(),
      end: end.toString()
    };
    const url = `/api/v1/series`;
    const self = this;
    return this.datasource.metadataRequest(url, params).then(result => {
      return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.map)(result.data.data, metric => {
        return {
          text: self.datasource.getOriginalMetricName(metric),
          expandable: true
        };
      });
    });
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/module.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "plugin": () => (/* binding */ plugin)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/datasource.tsx");
/* harmony import */ var _components_PromQueryEditorByApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditorByApp.tsx");
/* harmony import */ var _components_PromCheatSheet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx");
/* harmony import */ var _configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







class PrometheusAnnotationsQueryCtrl {
  constructor() {
    _defineProperty(this, "stepDefaultValuePlaceholder", _datasource__WEBPACK_IMPORTED_MODULE_1__.ANNOTATION_QUERY_STEP_DEFAULT);
  }

}

_defineProperty(PrometheusAnnotationsQueryCtrl, "templateUrl", 'partials/annotations.editor.html');

const plugin = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataSourcePlugin(_datasource__WEBPACK_IMPORTED_MODULE_1__.PrometheusDatasource).setQueryEditor(_components_PromQueryEditorByApp__WEBPACK_IMPORTED_MODULE_2__["default"]).setConfigEditor(_configuration_ConfigEditor__WEBPACK_IMPORTED_MODULE_4__.ConfigEditor).setAnnotationQueryCtrl(PrometheusAnnotationsQueryCtrl).setQueryEditorHelp(_components_PromCheatSheet__WEBPACK_IMPORTED_MODULE_3__["default"]);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/promql.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FUNCTIONS": () => (/* binding */ FUNCTIONS),
/* harmony export */   "LOGICAL_OPERATORS": () => (/* binding */ LOGICAL_OPERATORS),
/* harmony export */   "OPERATORS": () => (/* binding */ OPERATORS),
/* harmony export */   "PROM_KEYWORDS": () => (/* binding */ PROM_KEYWORDS),
/* harmony export */   "RATE_RANGES": () => (/* binding */ RATE_RANGES),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "promqlGrammar": () => (/* binding */ promqlGrammar)
/* harmony export */ });
// When changing RATE_RANGES, check if Loki/LogQL ranges should be changed too
// @see public/app/plugins/datasource/loki/language_provider.ts
const RATE_RANGES = [{
  label: '$__interval',
  sortValue: '$__interval'
}, {
  label: '$__rate_interval',
  sortValue: '$__rate_interval'
}, {
  label: '$__range',
  sortValue: '$__range'
}, {
  label: '1m',
  sortValue: '00:01:00'
}, {
  label: '5m',
  sortValue: '00:05:00'
}, {
  label: '10m',
  sortValue: '00:10:00'
}, {
  label: '30m',
  sortValue: '00:30:00'
}, {
  label: '1h',
  sortValue: '01:00:00'
}, {
  label: '1d',
  sortValue: '24:00:00'
}];
const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];
const LOGICAL_OPERATORS = ['or', 'and', 'unless'];
const TRIGONOMETRIC_FUNCTIONS = [{
  label: 'acos',
  insertText: 'acos',
  detail: 'acos(v instant-vector)',
  documentation: 'calculates the arccosine of all elements in v'
}, {
  label: 'acosh',
  insertText: 'acosh',
  detail: 'acosh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic cosine of all elements in v'
}, {
  label: 'asin',
  insertText: 'asin',
  detail: 'asin(v instant-vector)',
  documentation: 'calculates the arcsine of all elements in v'
}, {
  label: 'asinh',
  insertText: 'asinh',
  detail: 'asinh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic sine of all elements in v'
}, {
  label: 'atan',
  insertText: 'atan',
  detail: 'atan(v instant-vector)',
  documentation: 'calculates the arctangent of all elements in v'
}, {
  label: 'atanh',
  insertText: 'atanh',
  detail: 'atanh(v instant-vector)',
  documentation: 'calculates the inverse hyperbolic tangent of all elements in v'
}, {
  label: 'cos',
  insertText: 'cos',
  detail: 'cos(v instant-vector)',
  documentation: 'calculates the cosine of all elements in v'
}, {
  label: 'cosh',
  insertText: 'cosh',
  detail: 'cosh(v instant-vector)',
  documentation: 'calculates the hyperbolic cosine of all elements in v'
}, {
  label: 'sin',
  insertText: 'sin',
  detail: 'sin(v instant-vector)',
  documentation: 'calculates the sine of all elements in v'
}, {
  label: 'sinh',
  insertText: 'sinh',
  detail: 'sinh(v instant-vector)',
  documentation: 'calculates the hyperbolic sine of all elements in v'
}, {
  label: 'tan',
  insertText: 'tan',
  detail: 'tan(v instant-vector)',
  documentation: 'calculates the tangent of all elements in v'
}, {
  label: 'tanh',
  insertText: 'tanh',
  detail: 'tanh(v instant-vector)',
  documentation: 'calculates the hyperbolic tangent of all elements in v'
}];
const AGGREGATION_OPERATORS = [{
  label: 'sum',
  insertText: 'sum',
  documentation: 'Calculate sum over dimensions'
}, {
  label: 'min',
  insertText: 'min',
  documentation: 'Select minimum over dimensions'
}, {
  label: 'max',
  insertText: 'max',
  documentation: 'Select maximum over dimensions'
}, {
  label: 'avg',
  insertText: 'avg',
  documentation: 'Calculate the average over dimensions'
}, {
  label: 'group',
  insertText: 'group',
  documentation: 'All values in the resulting vector are 1'
}, {
  label: 'stddev',
  insertText: 'stddev',
  documentation: 'Calculate population standard deviation over dimensions'
}, {
  label: 'stdvar',
  insertText: 'stdvar',
  documentation: 'Calculate population standard variance over dimensions'
}, {
  label: 'count',
  insertText: 'count',
  documentation: 'Count number of elements in the vector'
}, {
  label: 'count_values',
  insertText: 'count_values',
  documentation: 'Count number of elements with the same value'
}, {
  label: 'bottomk',
  insertText: 'bottomk',
  documentation: 'Smallest k elements by sample value'
}, {
  label: 'topk',
  insertText: 'topk',
  documentation: 'Largest k elements by sample value'
}, {
  label: 'quantile',
  insertText: 'quantile',
  documentation: 'Calculate -quantile (0    1) over dimensions'
}];
const FUNCTIONS = [...AGGREGATION_OPERATORS, ...TRIGONOMETRIC_FUNCTIONS, {
  insertText: 'abs',
  label: 'abs',
  detail: 'abs(v instant-vector)',
  documentation: 'Returns the input vector with all sample values converted to their absolute value.'
}, {
  insertText: 'absent',
  label: 'absent',
  detail: 'absent(v instant-vector)',
  documentation: 'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.'
}, {
  insertText: 'absent_over_time',
  label: 'absent_over_time',
  detail: 'absent(v range-vector)',
  documentation: 'Returns an empty vector if the range vector passed to it has any elements and a 1-element vector with the value 1 if the range vector passed to it has no elements.'
}, {
  insertText: 'ceil',
  label: 'ceil',
  detail: 'ceil(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.'
}, {
  insertText: 'changes',
  label: 'changes',
  detail: 'changes(v range-vector)',
  documentation: 'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.'
}, {
  insertText: 'clamp',
  label: 'clamp',
  detail: 'clamp(v instant-vector, min scalar, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min` and an upper limit of `max`.'
}, {
  insertText: 'clamp_max',
  label: 'clamp_max',
  detail: 'clamp_max(v instant-vector, max scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.'
}, {
  insertText: 'clamp_min',
  label: 'clamp_min',
  detail: 'clamp_min(v instant-vector, min scalar)',
  documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.'
}, {
  insertText: 'count_scalar',
  label: 'count_scalar',
  detail: 'count_scalar(v instant-vector)',
  documentation: 'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.'
}, {
  insertText: 'deg',
  label: 'deg',
  detail: 'deg(v instant-vector)',
  documentation: 'Converts radians to degrees for all elements in v'
}, {
  insertText: 'day_of_month',
  label: 'day_of_month',
  detail: 'day_of_month(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.'
}, {
  insertText: 'day_of_week',
  label: 'day_of_week',
  detail: 'day_of_week(v=vector(time()) instant-vector)',
  documentation: 'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.'
}, {
  insertText: 'days_in_month',
  label: 'days_in_month',
  detail: 'days_in_month(v=vector(time()) instant-vector)',
  documentation: 'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.'
}, {
  insertText: 'delta',
  label: 'delta',
  detail: 'delta(v range-vector)',
  documentation: 'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.'
}, {
  insertText: 'deriv',
  label: 'deriv',
  detail: 'deriv(v range-vector)',
  documentation: 'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.'
}, {
  insertText: 'drop_common_labels',
  label: 'drop_common_labels',
  detail: 'drop_common_labels(instant-vector)',
  documentation: 'Drops all labels that have the same name and value across all series in the input vector.'
}, {
  insertText: 'exp',
  label: 'exp',
  detail: 'exp(v instant-vector)',
  documentation: 'Calculates the exponential function for all elements in `v`.\nSpecial cases are:\n* `Exp(+Inf) = +Inf` \n* `Exp(NaN) = NaN`'
}, {
  insertText: 'floor',
  label: 'floor',
  detail: 'floor(v instant-vector)',
  documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.'
}, {
  insertText: 'histogram_quantile',
  label: 'histogram_quantile',
  detail: 'histogram_quantile( float, b instant-vector)',
  documentation: 'Calculates the -quantile (0    1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.'
}, {
  insertText: 'holt_winters',
  label: 'holt_winters',
  detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',
  documentation: 'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.'
}, {
  insertText: 'hour',
  label: 'hour',
  detail: 'hour(v=vector(time()) instant-vector)',
  documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.'
}, {
  insertText: 'idelta',
  label: 'idelta',
  detail: 'idelta(v range-vector)',
  documentation: 'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.'
}, {
  insertText: 'increase',
  label: 'increase',
  detail: 'increase(v range-vector)',
  documentation: 'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.'
}, {
  insertText: 'irate',
  label: 'irate',
  detail: 'irate(v range-vector)',
  documentation: 'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.'
}, {
  insertText: 'label_join',
  label: 'label_join',
  detail: 'label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)',
  documentation: 'For each timeseries in `v`, joins all the values of all the `src_labels` using `separator` and returns the timeseries with the label `dst_label` containing the joined value. There can be any number of `src_labels` in this function.'
}, {
  insertText: 'label_replace',
  label: 'label_replace',
  detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',
  documentation: "For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged."
}, {
  insertText: 'ln',
  label: 'ln',
  detail: 'ln(v instant-vector)',
  documentation: 'Calculates the natural logarithm for all elements in `v`.\nSpecial cases are:\n * `ln(+Inf) = +Inf`\n * `ln(0) = -Inf`\n * `ln(x < 0) = NaN`\n * `ln(NaN) = NaN`'
}, {
  insertText: 'log2',
  label: 'log2',
  detail: 'log2(v instant-vector)',
  documentation: 'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'log10',
  label: 'log10',
  detail: 'log10(v instant-vector)',
  documentation: 'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.'
}, {
  insertText: 'minute',
  label: 'minute',
  detail: 'minute(v=vector(time()) instant-vector)',
  documentation: 'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.'
}, {
  insertText: 'month',
  label: 'month',
  detail: 'month(v=vector(time()) instant-vector)',
  documentation: 'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.'
}, {
  insertText: 'pi',
  label: 'pi',
  detail: 'pi()',
  documentation: 'Returns pi'
}, {
  insertText: 'predict_linear',
  label: 'predict_linear',
  detail: 'predict_linear(v range-vector, t scalar)',
  documentation: 'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.'
}, {
  insertText: 'rad',
  label: 'rad',
  detail: 'rad(v instant-vector)',
  documentation: 'Converts degrees to radians for all elements in v'
}, {
  insertText: 'rate',
  label: 'rate',
  detail: 'rate(v range-vector)',
  documentation: "Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period."
}, {
  insertText: 'resets',
  label: 'resets',
  detail: 'resets(v range-vector)',
  documentation: 'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.'
}, {
  insertText: 'round',
  label: 'round',
  detail: 'round(v instant-vector, to_nearest=1 scalar)',
  documentation: 'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.'
}, {
  insertText: 'scalar',
  label: 'scalar',
  detail: 'scalar(v instant-vector)',
  documentation: 'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.'
}, {
  insertText: 'sgn',
  label: 'sgn',
  detail: 'sgn(v instant-vector)',
  documentation: 'Returns a vector with all sample values converted to their sign, defined as this: 1 if v is positive, -1 if v is negative and 0 if v is equal to zero.'
}, {
  insertText: 'sort',
  label: 'sort',
  detail: 'sort(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in ascending order.'
}, {
  insertText: 'sort_desc',
  label: 'sort_desc',
  detail: 'sort_desc(v instant-vector)',
  documentation: 'Returns vector elements sorted by their sample values, in descending order.'
}, {
  insertText: 'sqrt',
  label: 'sqrt',
  detail: 'sqrt(v instant-vector)',
  documentation: 'Calculates the square root of all elements in `v`.'
}, {
  insertText: 'time',
  label: 'time',
  detail: 'time()',
  documentation: 'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.'
}, {
  insertText: 'timestamp',
  label: 'timestamp',
  detail: 'timestamp(v instant-vector)',
  documentation: 'Returns the timestamp of each of the samples of the given vector as the number of seconds since January 1, 1970 UTC.'
}, {
  insertText: 'vector',
  label: 'vector',
  detail: 'vector(s scalar)',
  documentation: 'Returns the scalar `s` as a vector with no labels.'
}, {
  insertText: 'year',
  label: 'year',
  detail: 'year(v=vector(time()) instant-vector)',
  documentation: 'Returns the year for each of the given times in UTC.'
}, {
  insertText: 'avg_over_time',
  label: 'avg_over_time',
  detail: 'avg_over_time(range-vector)',
  documentation: 'The average value of all points in the specified interval.'
}, {
  insertText: 'min_over_time',
  label: 'min_over_time',
  detail: 'min_over_time(range-vector)',
  documentation: 'The minimum value of all points in the specified interval.'
}, {
  insertText: 'max_over_time',
  label: 'max_over_time',
  detail: 'max_over_time(range-vector)',
  documentation: 'The maximum value of all points in the specified interval.'
}, {
  insertText: 'sum_over_time',
  label: 'sum_over_time',
  detail: 'sum_over_time(range-vector)',
  documentation: 'The sum of all values in the specified interval.'
}, {
  insertText: 'count_over_time',
  label: 'count_over_time',
  detail: 'count_over_time(range-vector)',
  documentation: 'The count of all values in the specified interval.'
}, {
  insertText: 'quantile_over_time',
  label: 'quantile_over_time',
  detail: 'quantile_over_time(scalar, range-vector)',
  documentation: 'The -quantile (0    1) of the values in the specified interval.'
}, {
  insertText: 'stddev_over_time',
  label: 'stddev_over_time',
  detail: 'stddev_over_time(range-vector)',
  documentation: 'The population standard deviation of the values in the specified interval.'
}, {
  insertText: 'stdvar_over_time',
  label: 'stdvar_over_time',
  detail: 'stdvar_over_time(range-vector)',
  documentation: 'The population standard variance of the values in the specified interval.'
}, {
  insertText: 'last_over_time',
  label: 'last_over_time',
  detail: 'last_over_time(range-vector)',
  documentation: 'The most recent point value in specified interval.'
}];
const PROM_KEYWORDS = FUNCTIONS.map(keyword => keyword.label);
const promqlGrammar = {
  comment: {
    pattern: /#.*/
  },
  'context-aggregation': {
    pattern: /((by|without)\s*)\([^)]*\)/,
    // by ()
    lookbehind: true,
    inside: {
      'label-key': {
        pattern: /[^(),\s][^,)]*[^),\s]*/,
        alias: 'attr-name'
      },
      punctuation: /[()]/
    }
  },
  'context-labels': {
    pattern: /\{[^}]*(?=}?)/,
    greedy: true,
    inside: {
      comment: {
        pattern: /#.*/
      },
      'label-key': {
        pattern: /[a-z_]\w*(?=\s*(=|!=|=~|!~))/,
        alias: 'attr-name',
        greedy: true
      },
      'label-value': {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        alias: 'attr-value'
      },
      punctuation: /[{]/
    }
  },
  function: new RegExp(`\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\s*\\()`, 'i'),
  'context-range': [{
    pattern: /\[[^\]]*(?=])/,
    // [1m]
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }, {
    pattern: /(offset\s+)\w+/,
    // offset 1m
    lookbehind: true,
    inside: {
      'range-duration': {
        pattern: /\b\d+[smhdwy]\b/i,
        alias: 'number'
      }
    }
  }],
  idList: {
    pattern: /\d+(\|\d+)+/,
    alias: 'number'
  },
  number: /\b-?\d+((\.\d*)?([eE][+-]?\d+)?)?\b/,
  operator: new RegExp(`/[-+*/=%^~]|&&?|\\|?\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:${OPERATORS.join('|')})\\b`, 'i'),
  punctuation: /[{};()`,.]/
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (promqlGrammar);

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/query_hints.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SUM_HINT_THRESHOLD_COUNT": () => (/* binding */ SUM_HINT_THRESHOLD_COUNT),
/* harmony export */   "getInitHints": () => (/* binding */ getInitHints),
/* harmony export */   "getQueryHints": () => (/* binding */ getQueryHints)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Number of time series results needed before starting to suggest sum aggregation hints
 */
const SUM_HINT_THRESHOLD_COUNT = 20;
function getQueryHints(query, series, datasource) {
  const hints = []; // ..._bucket metric needs a histogram_quantile()

  const histogramMetric = query.trim().match(/^\w+_bucket$|^\w+_bucket{.*}$/);

  if (histogramMetric) {
    const label = 'Selected metric has buckets.';
    hints.push({
      type: 'HISTOGRAM_QUANTILE',
      label,
      fix: {
        label: 'Consider calculating aggregated quantile by adding histogram_quantile().',
        action: {
          type: 'ADD_HISTOGRAM_QUANTILE',
          query
        }
      }
    });
  } // Check for need of rate()


  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {
    var _datasource$languageP, _datasource$languageP2;

    // Use metric metadata for exact types
    const nameMatch = query.match(/\b(\w+_(total|sum|count))\b/);
    let counterNameMetric = nameMatch ? nameMatch[1] : '';
    const metricsMetadata = (_datasource$languageP = datasource === null || datasource === void 0 ? void 0 : (_datasource$languageP2 = datasource.languageProvider) === null || _datasource$languageP2 === void 0 ? void 0 : _datasource$languageP2.metricsMetadata) !== null && _datasource$languageP !== void 0 ? _datasource$languageP : {};
    const metricMetadataKeys = Object.keys(metricsMetadata);
    let certain = false;

    if (metricMetadataKeys.length > 0) {
      var _metricMetadataKeys$f;

      counterNameMetric = (_metricMetadataKeys$f = metricMetadataKeys.find(metricName => {
        // Only considering first type information, could be non-deterministic
        const metadata = metricsMetadata[metricName];

        if (metadata.type.toLowerCase() === 'counter') {
          const metricRegex = new RegExp(`\\b${metricName}\\b`);

          if (query.match(metricRegex)) {
            certain = true;
            return true;
          }
        }

        return false;
      })) !== null && _metricMetadataKeys$f !== void 0 ? _metricMetadataKeys$f : '';
    }

    if (counterNameMetric) {
      // FixableQuery consists of metric name and optionally label-value pairs. We are not offering fix for complex queries yet.
      const fixableQuery = query.trim().match(/^\w+$|^\w+{.*}$/);
      const verb = certain ? 'is' : 'looks like';
      let label = `Selected metric ${verb} a counter.`;
      let fix;

      if (fixableQuery) {
        fix = {
          label: 'Consider calculating rate of counter by adding rate().',
          action: {
            type: 'ADD_RATE',
            query
          }
        };
      } else {
        label = `${label} Consider calculating rate of counter by adding rate().`;
      }

      hints.push({
        type: 'APPLY_RATE',
        label,
        fix
      });
    }
  } // Check for recording rules expansion


  if (datasource && datasource.ruleMappings) {
    const mapping = datasource.ruleMappings;
    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {
      if (query.search(ruleName) > -1) {
        return Object.assign({}, acc, {
          [ruleName]: mapping[ruleName]
        });
      }

      return acc;
    }, {});

    if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.size)(mappingForQuery) > 0) {
      const label = 'Query contains recording rules.';
      hints.push({
        type: 'EXPAND_RULES',
        label,
        fix: {
          label: 'Expand rules',
          action: {
            type: 'EXPAND_RULES',
            query,
            mapping: mappingForQuery
          }
        }
      });
    }
  }

  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {
    const simpleMetric = query.trim().match(/^\w+$/);

    if (simpleMetric) {
      hints.push({
        type: 'ADD_SUM',
        label: 'Many time series results returned.',
        fix: {
          label: 'Consider aggregating with sum().',
          action: {
            type: 'ADD_SUM',
            query: query,
            preventSubmit: true
          }
        }
      });
    }
  }

  return hints;
}
function getInitHints(datasource) {
  const hints = []; // Hint if using Loki as Prometheus data source

  if (datasource.directUrl.includes('/loki') && !datasource.languageProvider.metrics.length) {
    hints.push({
      label: `Using Loki as a Prometheus data source is no longer supported. You must use the Loki data source for your Loki instance.`,
      type: 'INFO'
    });
  } // Hint for big disabled lookups


  if (datasource.lookupsDisabled) {
    hints.push({
      label: `Labels and metrics lookup was disabled in data source settings.`,
      type: 'INFO'
    });
  }

  return hints;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryModeller": () => (/* binding */ PromQueryModeller),
/* harmony export */   "promQueryModeller": () => (/* binding */ promQueryModeller)
/* harmony export */ });
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var _aggregations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts");
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");





class PromQueryModeller extends _shared_LokiAndPromQueryModellerBase__WEBPACK_IMPORTED_MODULE_3__.LokiAndPromQueryModellerBase {
  constructor() {
    super(() => {
      const allOperations = [...(0,_operations__WEBPACK_IMPORTED_MODULE_2__.getOperationDefinitions)(), ...(0,_aggregations__WEBPACK_IMPORTED_MODULE_1__.getAggregationOperations)()];

      for (const op of allOperations) {
        const func = _promql__WEBPACK_IMPORTED_MODULE_0__.FUNCTIONS.find(x => x.insertText === op.id);

        if (func) {
          op.documentation = func.documentation;
        }
      }

      return allOperations;
    });
    this.setOperationCategories([_types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Aggregations, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.RangeFunctions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Functions, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.BinaryOps, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Trigonometric, _types__WEBPACK_IMPORTED_MODULE_4__.PromVisualQueryOperationCategory.Time]);
  }

  getQueryPatterns() {
    return [{
      name: 'Rate then sum',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: 'sum',
        params: []
      }]
    }, {
      name: 'Rate then sum by(label) then avg',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['']
      }, {
        id: 'avg',
        params: []
      }]
    }, {
      name: 'Histogram quantile on rate',
      operations: [{
        id: 'rate',
        params: ['$__rate_interval']
      }, {
        id: '__sum_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }, {
      name: 'Histogram quantile on increase ',
      operations: [{
        id: 'increase',
        params: ['$__rate_interval']
      }, {
        id: '__max_by',
        params: ['le']
      }, {
        id: 'histogram_quantile',
        params: [0.95]
      }]
    }];
  }

}
const promQueryModeller = new PromQueryModeller();

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/aggregations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAggregationOperations": () => (/* binding */ getAggregationOperations)
/* harmony export */ });
/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/operations.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");



function getAggregationOperations() {
  return [...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sum), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Avg), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Min), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Max), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperation)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Count), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.TopK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.BottomK, {
    params: [{
      name: 'K-value',
      type: 'number'
    }],
    defaultParams: [5]
  }), ...(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.createAggregationOperationWithParam)(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountValues, {
    params: [{
      name: 'Identifier',
      type: 'string'
    }],
    defaultParams: ['count']
  }), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.SumOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AvgOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MinOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.MaxOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.CountOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LastOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.PresentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.AbsentOverTime), createAggregationOverTime(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.StddevOverTime)];
}

function createAggregationOverTime(name) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)()],
    defaultParams: ['$__interval'],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: _operations__WEBPACK_IMPORTED_MODULE_0__.addOperationWithRangeVector
  };
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '$__interval';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "binaryScalarDefs": () => (/* binding */ binaryScalarDefs),
/* harmony export */   "binaryScalarOperations": () => (/* binding */ binaryScalarOperations)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");


const binaryScalarDefs = [{
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.Addition,
  name: 'Add scalar',
  sign: '+'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.Subtraction,
  name: 'Subtract scalar',
  sign: '-'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.MultiplyBy,
  name: 'Multiply by scalar',
  sign: '*'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.DivideBy,
  name: 'Divide by scalar',
  sign: '/'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.Modulo,
  name: 'Modulo by scalar',
  sign: '%'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.Exponent,
  name: 'Exponent',
  sign: '^'
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.EqualTo,
  name: 'Equal to',
  sign: '==',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.NotEqualTo,
  name: 'Not equal to',
  sign: '!=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.GreaterThan,
  name: 'Greater than',
  sign: '>',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.LessThan,
  name: 'Less than',
  sign: '<',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.GreaterOrEqual,
  name: 'Greater or equal to',
  sign: '>=',
  comparison: true
}, {
  id: _types__WEBPACK_IMPORTED_MODULE_0__.PromOperationId.LessOrEqual,
  name: 'Less or equal to',
  sign: '<=',
  comparison: true
}]; // Not sure about this one. It could also be a more generic 'Simple math operation' where user specifies
// both the operator and the operand in a single input

const binaryScalarOperations = binaryScalarDefs.map(opDef => {
  const params = [{
    name: 'Value',
    type: 'number'
  }];
  const defaultParams = [2];

  if (opDef.comparison) {
    params.push({
      name: 'Bool',
      type: 'boolean',
      description: 'If checked comparison will return 0 or 1 for the value rather than filtering.'
    });
    defaultParams.push(false);
  }

  return {
    id: opDef.id,
    name: opDef.name,
    params,
    defaultParams,
    alternativesKey: 'binary scalar operations',
    category: _types__WEBPACK_IMPORTED_MODULE_0__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: getSimpleBinaryRenderer(opDef.sign),
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  };
});

function getSimpleBinaryRenderer(operator) {
  return function binaryRenderer(model, def, innerExpr) {
    let param = model.params[0];
    let bool = '';

    if (model.params.length === 2) {
      bool = model.params[1] ? ' bool' : '';
    }

    return `${innerExpr} ${operator}${bool} ${param}`;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelParamEditor": () => (/* binding */ LabelParamEditor)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _datasource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/datasource.tsx");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function LabelParamEditor({
  onChange,
  index,
  operationIndex,
  value,
  query,
  datasource
}) {
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
    inputId: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_5__.getOperationParamId)(operationIndex, index),
    menuShouldPortal: true,
    autoFocus: value === '' ? true : undefined,
    openMenuOnFocus: true,
    onOpenMenu: async () => {
      setState({
        isLoading: true
      });
      const options = await loadGroupByLabels(query, datasource);
      setState({
        options,
        isLoading: undefined
      });
    },
    isLoading: state.isLoading,
    allowCustomValue: true,
    noOptionsMessage: "No labels found",
    loadingMessage: "Loading labels",
    options: state.options,
    value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.toOption)(value),
    onChange: value => onChange(index, value.value)
  });
}

async function loadGroupByLabels(query, datasource) {
  let labels = query.labels; // This function is used by both Prometheus and Loki and this the only difference

  if (datasource instanceof _datasource__WEBPACK_IMPORTED_MODULE_3__.PrometheusDatasource) {
    labels = [{
      label: '__name__',
      op: '=',
      value: query.metric
    }, ...query.labels];
  }

  const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__.promQueryModeller.renderLabels(labels);
  const result = await datasource.languageProvider.fetchSeriesLabels(expr);
  return Object.keys(result).map(x => ({
    label: x,
    value: x
  }));
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/MetricSelect.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MetricSelect": () => (/* binding */ MetricSelect)
/* harmony export */ });
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react_highlight_words__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-highlight-words-virtual-d2265e757c/0/cache/react-highlight-words-npm-0.17.0-880b4a18ed-41b3d0e451.zip/node_modules/react-highlight-words/dist/main.js");
/* harmony import */ var react_highlight_words__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_highlight_words__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





 // We are matching words split with space


const splitSeparator = ' ';
function MetricSelect({
  query,
  onChange,
  onGetMetrics
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});
  const customFilterOption = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((option, searchQuery) => {
    var _option$label;

    const label = (_option$label = option.label) !== null && _option$label !== void 0 ? _option$label : option.value;

    if (!label) {
      return false;
    }

    const searchWords = searchQuery.split(splitSeparator);
    return searchWords.reduce((acc, cur) => acc && label.toLowerCase().includes(cur.toLowerCase()), true);
  }, []);
  const formatOptionLabel = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((option, meta) => {
    var _option$label2;

    // For newly created custom value we don't want to add highlight
    if (option['__isNew__']) {
      return option.label;
    }

    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)((react_highlight_words__WEBPACK_IMPORTED_MODULE_5___default()), {
      searchWords: meta.inputValue.split(splitSeparator),
      textToHighlight: (_option$label2 = option.label) !== null && _option$label2 !== void 0 ? _option$label2 : '',
      highlightClassName: styles.highlight
    });
  }, [styles.highlight]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorField, {
      label: "Metric",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.Select, {
        inputId: "prometheus-metric-select",
        className: styles.select,
        value: query.metric ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(query.metric) : undefined,
        placeholder: "Select metric",
        allowCustomValue: true,
        formatOptionLabel: formatOptionLabel,
        filterOption: customFilterOption,
        onOpenMenu: async () => {
          setState({
            isLoading: true
          });
          const metrics = await onGetMetrics();
          setState({
            metrics,
            isLoading: undefined
          });
        },
        isLoading: state.isLoading,
        options: state.metrics,
        onChange: ({
          value
        }) => {
          if (value) {
            onChange(Object.assign({}, query, {
              metric: value
            }));
          }
        }
      })
    })
  });
}

const getStyles = theme => ({
  select: _emotion_css__WEBPACK_IMPORTED_MODULE_4__.css`
    min-width: 125px;
  `,
  highlight: _emotion_css__WEBPACK_IMPORTED_MODULE_4__.css`
    label: select__match-highlight;
    background: inherit;
    padding: inherit;
    color: ${theme.colors.warning.main};
    background-color: rgba(${theme.colors.warning.main}, 0.1);
  `
});

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQuery.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQuery": () => (/* binding */ NestedQuery)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _PromQueryBuilder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;











const NestedQuery = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.memo(({
  nestedQuery,
  index,
  datasource,
  onChange,
  onRemove,
  onRunQuery
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
    className: styles.card,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
      className: styles.header,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: styles.name,
        children: "Operator"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
        width: "auto",
        options: operators,
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.toOption)(nestedQuery.operator),
        onChange: value => {
          onChange(index, Object.assign({}, nestedQuery, {
            operator: value.value
          }));
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
        className: styles.name,
        children: "Vector matches"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsxs)("div", {
        className: styles.vectorMatchWrapper,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          width: "auto",
          value: nestedQuery.vectorMatchesType || 'on',
          allowCustomValue: true,
          options: [{
            value: 'on',
            label: 'on'
          }, {
            value: 'ignoring',
            label: 'ignoring'
          }],
          onChange: val => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatchesType: val.value
            }));
          }
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_5__.AutoSizeInput, {
          className: styles.vectorMatchInput,
          minWidth: 20,
          defaultValue: nestedQuery.vectorMatches,
          onCommitChange: evt => {
            onChange(index, Object.assign({}, nestedQuery, {
              vectorMatches: evt.currentTarget.value,
              vectorMatchesType: nestedQuery.vectorMatchesType || 'on'
            }));
          }
        })]
      }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.IconButton, {
        name: "times",
        size: "sm",
        onClick: () => onRemove(index)
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)("div", {
      className: styles.body,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRows, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_8__.jsx)(_PromQueryBuilder__WEBPACK_IMPORTED_MODULE_6__.PromQueryBuilder, {
          query: nestedQuery.query,
          datasource: datasource,
          nested: true,
          onRunQuery: onRunQuery,
          onChange: update => {
            onChange(index, Object.assign({}, nestedQuery, {
              query: update
            }));
          }
        })
      })
    })]
  });
});
const operators = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_7__.binaryScalarDefs.map(def => ({
  label: def.sign,
  value: def.sign
}));
NestedQuery.displayName = 'NestedQuery';

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'card',
      display: 'flex',
      flexDirection: 'column',
      gap: theme.spacing(0.5)
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'header',
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      gap: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    name: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'name',
      whiteSpace: 'nowrap'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'body',
      paddingLeft: theme.spacing(2)
    }),
    vectorMatchInput: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchInput',
      marginLeft: -1
    }),
    vectorMatchWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'vectorMatchWrapper',
      display: 'flex'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQueryList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NestedQueryList": () => (/* binding */ NestedQueryList)
/* harmony export */ });
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _NestedQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQuery.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function NestedQueryList({
  query,
  datasource,
  onChange,
  onRunQuery
}) {
  var _query$binaryQueries;

  const nestedQueries = (_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : [];

  const onNestedQueryUpdate = (index, update) => {
    const updatedList = [...nestedQueries];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...nestedQueries.slice(0, index), ...nestedQueries.slice(index + 1)];
    onChange(Object.assign({}, query, {
      binaryQueries: updatedList
    }));
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_0__.Stack, {
    direction: "column",
    gap: 1,
    children: nestedQueries.map((nestedQuery, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_NestedQuery__WEBPACK_IMPORTED_MODULE_2__.NestedQuery, {
      nestedQuery: nestedQuery,
      index: index,
      onChange: onNestedQueryUpdate,
      datasource: datasource,
      onRemove: onRemove,
      onRunQuery: onRunQuery
    }, index.toString()))
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilder": () => (/* binding */ PromQueryBuilder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _MetricSelect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/MetricSelect.tsx");
/* harmony import */ var _shared_LabelFilters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx");
/* harmony import */ var _shared_OperationList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _NestedQueryList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/NestedQueryList.tsx");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx");
/* harmony import */ var _PromQueryBuilderHints__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderHints.tsx");
/* harmony import */ var _language_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/language_provider.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");













const PromQueryBuilder = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  datasource,
  query,
  onChange,
  onRunQuery,
  data
}) => {
  const onChangeLabels = labels => {
    onChange(Object.assign({}, query, {
      labels
    }));
  };
  /**
   * Map metric metadata to SelectableValue for Select component and also adds defined template variables to the list.
   */


  const withTemplateVariableOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async optionsPromise => {
    const variables = datasource.getVariables();
    const options = await optionsPromise;
    return [...variables.map(value => ({
      label: value,
      value
    })), ...options.map(option => ({
      label: option.value,
      value: option.value,
      title: option.description
    }))];
  }, [datasource]);

  const onGetLabelNames = async forLabel => {
    // If no metric we need to use a different method
    if (!query.metric) {
      // Todo add caching but inside language provider!
      await datasource.languageProvider.fetchLabels();
      return datasource.languageProvider.getLabelKeys().map(k => ({
        value: k
      }));
    }

    const labelsToConsider = query.labels.filter(x => x !== forLabel);
    labelsToConsider.push({
      label: '__name__',
      op: '=',
      value: query.metric
    });
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_6__.promQueryModeller.renderLabels(labelsToConsider);
    const labelsIndex = await datasource.languageProvider.fetchSeriesLabels(expr); // filter out already used labels

    return Object.keys(labelsIndex).filter(labelName => !labelsToConsider.find(filter => filter.label === labelName)).map(k => ({
      value: k
    }));
  };

  const onGetLabelValues = async forLabel => {
    var _result$forLabelInter;

    if (!forLabel.label) {
      return [];
    } // If no metric we need to use a different method


    if (!query.metric) {
      return (await datasource.languageProvider.getLabelValues(forLabel.label)).map(v => ({
        value: v
      }));
    }

    const labelsToConsider = query.labels.filter(x => x !== forLabel);
    labelsToConsider.push({
      label: '__name__',
      op: '=',
      value: query.metric
    });
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_6__.promQueryModeller.renderLabels(labelsToConsider);
    const result = await datasource.languageProvider.fetchSeriesLabels(expr);
    const forLabelInterpolated = datasource.interpolateString(forLabel.label);
    return (_result$forLabelInter = result[forLabelInterpolated].map(v => ({
      value: v
    }))) !== null && _result$forLabelInter !== void 0 ? _result$forLabelInter : [];
  };

  const onGetMetrics = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    return withTemplateVariableOptions(getMetrics(datasource, query));
  }, [datasource, query, withTemplateVariableOptions]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_4__.EditorRow, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_MetricSelect__WEBPACK_IMPORTED_MODULE_1__.MetricSelect, {
        query: query,
        onChange: onChange,
        onGetMetrics: onGetMetrics
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_shared_LabelFilters__WEBPACK_IMPORTED_MODULE_2__.LabelFilters, {
        labelsFilters: query.labels,
        onChange: onChangeLabels,
        onGetLabelNames: forLabel => withTemplateVariableOptions(onGetLabelNames(forLabel)),
        onGetLabelValues: forLabel => withTemplateVariableOptions(onGetLabelValues(forLabel))
      })]
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsxs)(_shared_OperationsEditorRow__WEBPACK_IMPORTED_MODULE_7__.OperationsEditorRow, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_shared_OperationList__WEBPACK_IMPORTED_MODULE_3__.OperationList, {
        queryModeller: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_6__.promQueryModeller,
        datasource: datasource,
        query: query,
        onChange: onChange,
        onRunQuery: onRunQuery
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_PromQueryBuilderHints__WEBPACK_IMPORTED_MODULE_8__.PromQueryBuilderHints, {
        datasource: datasource,
        query: query,
        onChange: onChange,
        data: data
      })]
    }), query.binaryQueries && query.binaryQueries.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_10__.jsx)(_NestedQueryList__WEBPACK_IMPORTED_MODULE_5__.NestedQueryList, {
      query: query,
      datasource: datasource,
      onChange: onChange,
      onRunQuery: onRunQuery
    })]
  });
});
/**
 * Returns list of metrics, either all or filtered by query param. It also adds description string to each metric if it
 * exists.
 * @param datasource
 * @param query
 */

async function getMetrics(datasource, query) {
  // Makes sure we loaded the metadata for metrics. Usually this is done in the start() method of the provider but we
  // don't use it with the visual builder and there is no need to run all the start() setup anyway.
  if (!datasource.languageProvider.metricsMetadata) {
    await datasource.languageProvider.loadMetricsMetadata();
  }

  let metrics;

  if (query.labels.length > 0) {
    var _await$datasource$lan;

    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_6__.promQueryModeller.renderLabels(query.labels);
    metrics = (_await$datasource$lan = (await datasource.languageProvider.getSeries(expr, true))['__name__']) !== null && _await$datasource$lan !== void 0 ? _await$datasource$lan : [];
  } else {
    var _await$datasource$lan2;

    metrics = (_await$datasource$lan2 = await datasource.languageProvider.getLabelValues('__name__')) !== null && _await$datasource$lan2 !== void 0 ? _await$datasource$lan2 : [];
  }

  return metrics.map(m => ({
    value: m,
    description: (0,_language_provider__WEBPACK_IMPORTED_MODULE_9__.getMetadataString)(m, datasource.languageProvider.metricsMetadata)
  }));
}

PromQueryBuilder.displayName = 'PromQueryBuilder';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderContainer.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderContainer": () => (/* binding */ PromQueryBuilderContainer)
/* harmony export */ });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/@reduxjs-toolkit-virtual-7692db070f/0/cache/@reduxjs-toolkit-npm-1.7.2-7ced4ba4dc-41c17c660f.zip/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _PromQueryBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilder.tsx");
/* harmony import */ var _QueryPreview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/QueryPreview.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










/**
 * This component is here just to contain the translation logic between string query and the visual query builder model.
 */
function PromQueryBuilderContainer(props) {
  const {
    query,
    onChange,
    onRunQuery,
    datasource,
    data
  } = props;
  const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(stateSlice.reducer, {
    expr: query.expr
  }); // Only rebuild visual query if expr changes from outside

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    dispatch(exprChanged(query.expr));
  }, [query.expr]);

  const onVisQueryChange = visQuery => {
    const expr = _PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__.promQueryModeller.renderQuery(visQuery);
    dispatch(visualQueryChange({
      visQuery,
      expr
    }));
    onChange(Object.assign({}, props.query, {
      expr: expr
    }));
  };

  if (!state.visQuery) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_PromQueryBuilder__WEBPACK_IMPORTED_MODULE_3__.PromQueryBuilder, {
      query: state.visQuery,
      datasource: datasource,
      onChange: onVisQueryChange,
      onRunQuery: onRunQuery,
      data: data
    }), query.rawQuery && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_QueryPreview__WEBPACK_IMPORTED_MODULE_4__.QueryPreview, {
      query: query.expr
    })]
  });
}
const stateSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_6__.createSlice)({
  name: 'prom-builder-container',
  initialState: {
    expr: ''
  },
  reducers: {
    visualQueryChange: (state, action) => {
      state.expr = action.payload.expr;
      state.visQuery = action.payload.visQuery;
    },
    exprChanged: (state, action) => {
      if (!state.visQuery || state.expr !== action.payload) {
        state.expr = action.payload;
        const parseResult = (0,_parsing__WEBPACK_IMPORTED_MODULE_1__.buildVisualQueryFromString)(action.payload);
        state.visQuery = parseResult.query;
      }
    }
  }
});
const {
  visualQueryChange,
  exprChanged
} = stateSlice.actions;

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderExplained": () => (/* binding */ PromQueryBuilderExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx");
/* harmony import */ var _shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








const PromQueryBuilderExplained = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  nested
}) => {
  const visQuery = (0,_parsing__WEBPACK_IMPORTED_MODULE_5__.buildVisualQueryFromString)(query || '').query;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_shared_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_4__.OperationExplainedBox, {
      stepNumber: 1,
      title: `${visQuery.metric} ${_PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__.promQueryModeller.renderLabels(visQuery.labels)}`,
      children: "Fetch all series matching metric name and label filters."
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_shared_OperationListExplained__WEBPACK_IMPORTED_MODULE_3__.OperationListExplained, {
      stepNumber: 2,
      queryModeller: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_2__.promQueryModeller,
      query: visQuery
    })]
  });
});
PromQueryBuilderExplained.displayName = 'PromQueryBuilderExplained';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderHints.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderHints": () => (/* binding */ PromQueryBuilderHints)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







const PromQueryBuilderHints = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  datasource,
  query,
  onChange,
  data
}) => {
  const [hints, setHints] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const promQuery = {
      expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__.promQueryModeller.renderQuery(query),
      refId: ''
    }; // For now show only actionable hints

    const hints = datasource.getQueryHints(promQuery, (data === null || data === void 0 ? void 0 : data.series) || []).filter(hint => {
      var _hint$fix;

      return (_hint$fix = hint.fix) === null || _hint$fix === void 0 ? void 0 : _hint$fix.action;
    });
    setHints(hints);
  }, [datasource, query, onChange, data, styles.hint]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: hints.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.container,
      children: hints.map(hint => {
        var _hint$fix2, _hint$fix3, _hint$fix3$action;

        return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Tooltip, {
          content: `${hint.label} ${(_hint$fix2 = hint.fix) === null || _hint$fix2 === void 0 ? void 0 : _hint$fix2.label}`,
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            onClick: () => {
              const promQuery = {
                expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_1__.promQueryModeller.renderQuery(query),
                refId: ''
              };
              const newPromQuery = datasource.modifyQuery(promQuery, hint.fix.action);
              const visualQuery = (0,_parsing__WEBPACK_IMPORTED_MODULE_2__.buildVisualQueryFromString)(newPromQuery.expr);
              return onChange(visualQuery.query);
            },
            fill: "outline",
            size: "sm",
            className: styles.hint,
            children: 'hint: ' + ((_hint$fix3 = hint.fix) === null || _hint$fix3 === void 0 ? void 0 : (_hint$fix3$action = _hint$fix3.action) === null || _hint$fix3$action === void 0 ? void 0 : _hint$fix3$action.type.toLowerCase().replace('_', ' ')) + '()'
          })
        }, hint.type);
      })
    })
  });
});
PromQueryBuilderHints.displayName = 'PromQueryBuilderHints';

const getStyles = theme => {
  return {
    container: _emotion_css__WEBPACK_IMPORTED_MODULE_4__.css`
      display: flex;
      margin-bottom: ${theme.spacing(1)};
      align-items: center;
    `,
    hint: _emotion_css__WEBPACK_IMPORTED_MODULE_4__.css`
      margin-right: ${theme.spacing(1)};
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderOptions.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryBuilderOptions": () => (/* binding */ PromQueryBuilderOptions)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx");
/* harmony import */ var _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx");
/* harmony import */ var _PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryLegendEditor.tsx");
/* harmony import */ var _shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _code, _code2;













const PromQueryBuilderOptions = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  query,
  app,
  onChange,
  onRunQuery
}) => {
  const onChangeFormat = value => {
    onChange(Object.assign({}, query, {
      format: value.value
    }));
    onRunQuery();
  };

  const onChangeStep = evt => {
    onChange(Object.assign({}, query, {
      interval: evt.currentTarget.value
    }));
    onRunQuery();
  };

  const queryTypeOptions = (0,_components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_6__.getQueryTypeOptions)(app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.Explore);
  const onQueryTypeChange = (0,_components_PromExploreExtraField__WEBPACK_IMPORTED_MODULE_6__.getQueryTypeChangeHandler)(query, onChange);

  const onExemplarChange = event => {
    const isEnabled = event.currentTarget.checked;
    onChange(Object.assign({}, query, {
      exemplar: isEnabled
    }));
    onRunQuery();
  };

  const onIntervalFactorChange = value => {
    onChange(Object.assign({}, query, {
      intervalFactor: value.value
    }));
    onRunQuery();
  };

  const formatOption = _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS.find(option => option.value === query.format) || _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS[0];
  const queryTypeValue = getQueryTypeValue(query);
  const queryTypeLabel = queryTypeOptions.find(x => x.value === queryTypeValue).label;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(_shared_QueryOptionGroup__WEBPACK_IMPORTED_MODULE_4__.QueryOptionGroup, {
      title: "Options",
      collapsedInfo: getCollapsedInfo(query, formatOption.label, queryTypeLabel),
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_7__.PromQueryLegendEditor, {
        legendFormat: query.legendFormat,
        onChange: legendFormat => onChange(Object.assign({}, query, {
          legendFormat
        })),
        onRunQuery: onRunQuery
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Min step",
        tooltip: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.Fragment, {
          children: ["An additional lower limit for the step parameter of the Prometheus query and for the", ' ', _code || (_code = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("code", {
            children: "$__interval"
          })), " and ", _code2 || (_code2 = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)("code", {
            children: "$__rate_interval"
          })), " variables."]
        }),
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_8__.AutoSizeInput, {
          type: "text",
          "aria-label": "Set lower limit for the step parameter",
          placeholder: 'auto',
          minWidth: 10,
          onCommitChange: onChangeStep,
          defaultValue: query.interval
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Format",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          value: formatOption,
          allowCustomValue: true,
          onChange: onChangeFormat,
          options: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.FORMAT_OPTIONS
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Type",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.RadioButtonGroup, {
          options: queryTypeOptions,
          value: queryTypeValue,
          onChange: onQueryTypeChange
        })
      }), shouldShowExemplarSwitch(query, app) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Exemplars",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Switch, {
          value: query.exemplar,
          onChange: onExemplarChange
        })
      }), query.intervalFactor && query.intervalFactor > 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
        label: "Resolution",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_9__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Select, {
          "aria-label": "Select resolution",
          menuShouldPortal: true,
          isSearchable: false,
          options: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.INTERVAL_FACTOR_OPTIONS,
          onChange: onIntervalFactorChange,
          value: _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_5__.INTERVAL_FACTOR_OPTIONS.find(option => option.value === query.intervalFactor)
        })
      })]
    })
  });
});

function shouldShowExemplarSwitch(query, app) {
  if (app === _grafana_data__WEBPACK_IMPORTED_MODULE_2__.CoreApp.UnifiedAlerting || !query.range) {
    return false;
  }

  return true;
}

function getQueryTypeValue(query) {
  return query.range && query.instant ? 'both' : query.instant ? 'instant' : 'range';
}

function getCollapsedInfo(query, formatOption, queryType) {
  const items = [];
  items.push(`Legend: ${(0,_PromQueryLegendEditor__WEBPACK_IMPORTED_MODULE_7__.getLegendModeLabel)(query.legendFormat)}`);
  items.push(`Format: ${formatOption}`);

  if (query.interval) {
    items.push(`Step ${query.interval}`);
  }

  items.push(`Type: ${queryType}`);

  if (query.exemplar) {
    items.push(`Exemplars: true`);
  }

  return items;
}

PromQueryBuilderOptions.displayName = 'PromQueryBuilderOptions';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryCodeEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryCodeEditor": () => (/* binding */ PromQueryCodeEditor)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _components_PromQueryField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx");
/* harmony import */ var _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function PromQueryCodeEditor({
  query,
  datasource,
  range,
  onRunQuery,
  onChange,
  data,
  app
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
    className: styles.wrapper,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_components_PromQueryField__WEBPACK_IMPORTED_MODULE_1__["default"], {
      datasource: datasource,
      query: query,
      range: range,
      onRunQuery: onRunQuery,
      onChange: onChange,
      history: [],
      data: data,
      "data-testid": _components_PromQueryEditor__WEBPACK_IMPORTED_MODULE_2__.testIds.editor,
      app: app
    })
  });
}

const getStyles = theme => {
  return {
    // This wrapper styling can be removed after the old PromQueryEditor is removed.
    // This is removing margin bottom on the old legacy inline form styles
    wrapper: _emotion_css__WEBPACK_IMPORTED_MODULE_4__.css`
      .gf-form {
        margin-bottom: 0;
      }
    `
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryEditorSelector.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryEditorSelector": () => (/* binding */ PromQueryEditorSelector)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/PromQueryModeller.ts");
/* harmony import */ var _shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx");
/* harmony import */ var _shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx");
/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var _PromQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderExplained.tsx");
/* harmony import */ var _parsing__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts");
/* harmony import */ var _PromQueryCodeEditor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryCodeEditor.tsx");
/* harmony import */ var _PromQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderContainer.tsx");
/* harmony import */ var _PromQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryBuilderOptions.tsx");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/state.ts");
/* harmony import */ var _shared_FeedbackLink__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/FeedbackLink.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FeedbackLink, _FlexItem, _Space;



















const PromQueryEditorSelector = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(props => {
  const {
    onChange,
    onRunQuery,
    data
  } = props;
  const [parseModalOpen, setParseModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [dataIsStale, setDataIsStale] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const query = (0,_state__WEBPACK_IMPORTED_MODULE_13__.getQueryWithDefaults)(props.query, props.app);
  const editorMode = query.editorMode;
  const onEditorModeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(newMetricEditorMode => {
    if (newMetricEditorMode === _shared_types__WEBPACK_IMPORTED_MODULE_7__.QueryEditorMode.Builder) {
      const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_9__.buildVisualQueryFromString)(query.expr || ''); // If there are errors, give user a chance to decide if they want to go to builder as that can loose some data.

      if (result.errors.length) {
        setParseModalOpen(true);
        return;
      }
    }

    (0,_state__WEBPACK_IMPORTED_MODULE_13__.changeEditorMode)(query, newMetricEditorMode, onChange);
  }, [onChange, query]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    setDataIsStale(false);
  }, [data]);

  const onQueryPreviewChange = event => {
    const isEnabled = event.currentTarget.checked;
    onChange(Object.assign({}, query, {
      rawQuery: isEnabled
    }));
  };

  const onChangeInternal = query => {
    setDataIsStale(true);
    onChange(query);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.ConfirmModal, {
      isOpen: parseModalOpen,
      title: "Query parsing",
      body: "There were errors while trying to parse the query. Continuing to visual builder may loose some parts of the query.",
      confirmText: "Continue",
      onConfirm: () => {
        (0,_state__WEBPACK_IMPORTED_MODULE_13__.changeEditorMode)(query, _shared_types__WEBPACK_IMPORTED_MODULE_7__.QueryEditorMode.Builder, onChange);
        setParseModalOpen(false);
      },
      onDismiss: () => setParseModalOpen(false)
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorHeader, {
      children: [editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_7__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.InlineSelect, {
          value: null,
          placeholder: "Query patterns",
          allowCustomValue: true,
          onChange: ({
            value
          }) => {
            // TODO: Bit convoluted as we don't have access to visualQuery model here. Maybe would make sense to
            //  move it inside the editor?
            const result = (0,_parsing__WEBPACK_IMPORTED_MODULE_9__.buildVisualQueryFromString)(query.expr || '');
            result.query.operations = value === null || value === void 0 ? void 0 : value.operations;
            onChange(Object.assign({}, query, {
              expr: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__.promQueryModeller.renderQuery(result.query)
            }));
          },
          options: _PromQueryModeller__WEBPACK_IMPORTED_MODULE_4__.promQueryModeller.getQueryPatterns().map(x => ({
            label: x.name,
            value: x
          }))
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_shared_QueryHeaderSwitch__WEBPACK_IMPORTED_MODULE_6__.QueryHeaderSwitch, {
          label: "Raw query",
          value: query.rawQuery,
          onChange: onQueryPreviewChange
        })]
      }), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_7__.QueryEditorMode.Builder && (_FeedbackLink || (_FeedbackLink = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_shared_FeedbackLink__WEBPACK_IMPORTED_MODULE_14__.FeedbackLink, {
        feedbackUrl: "https://github.com/grafana/grafana/discussions/47693"
      }))), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
        variant: dataIsStale ? 'primary' : 'secondary',
        size: "sm",
        onClick: onRunQuery,
        icon: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading ? 'fa fa-spinner' : undefined,
        disabled: (data === null || data === void 0 ? void 0 : data.state) === _grafana_data__WEBPACK_IMPORTED_MODULE_1__.LoadingState.Loading,
        children: "Run query"
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_shared_QueryEditorModeToggle__WEBPACK_IMPORTED_MODULE_5__.QueryEditorModeToggle, {
        mode: editorMode,
        onChange: onEditorModeChange
      })]
    }), _Space || (_Space = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Space, {
      v: 0.5
    })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.EditorRows, {
      children: [editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_7__.QueryEditorMode.Code && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_PromQueryCodeEditor__WEBPACK_IMPORTED_MODULE_10__.PromQueryCodeEditor, Object.assign({}, props)), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_7__.QueryEditorMode.Builder && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_PromQueryBuilderContainer__WEBPACK_IMPORTED_MODULE_11__.PromQueryBuilderContainer, {
        query: query,
        datasource: props.datasource,
        onChange: onChangeInternal,
        onRunQuery: props.onRunQuery,
        data: data
      }), editorMode === _shared_types__WEBPACK_IMPORTED_MODULE_7__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_PromQueryBuilderExplained__WEBPACK_IMPORTED_MODULE_8__.PromQueryBuilderExplained, {
        query: query.expr
      }), editorMode !== _shared_types__WEBPACK_IMPORTED_MODULE_7__.QueryEditorMode.Explain && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_15__.jsx)(_PromQueryBuilderOptions__WEBPACK_IMPORTED_MODULE_12__.PromQueryBuilderOptions, {
        query: query,
        app: props.app,
        onChange: onChange,
        onRunQuery: onRunQuery
      })]
    })]
  });
});
PromQueryEditorSelector.displayName = 'PromQueryEditorSelector';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/PromQueryLegendEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromQueryLegendEditor": () => (/* binding */ PromQueryLegendEditor),
/* harmony export */   "getLegendModeLabel": () => (/* binding */ getLegendModeLabel)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");








const legendModeOptions = [{
  label: 'Auto',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto,
  description: 'Only includes unique labels'
}, {
  label: 'Verbose',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose,
  description: 'All label names and values'
}, {
  label: 'Custom',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom,
  description: 'Provide a naming template'
}];
/**
 * Tests for this component are on the parent level (PromQueryBuilderOptions).
 */

const PromQueryLegendEditor = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(({
  legendFormat,
  onChange,
  onRunQuery
}) => {
  const mode = getLegendMode(legendFormat);
  const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);

  const onLegendFormatChanged = evt => {
    let newFormat = evt.currentTarget.value;

    if (newFormat.length === 0) {
      newFormat = _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto;
    }

    if (newFormat !== legendFormat) {
      onChange(newFormat);
      onRunQuery();
    }
  };

  const onLegendModeChanged = value => {
    switch (value.value) {
      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto:
        onChange(_types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto);
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom:
        onChange('{{label_name}}');
        setTimeout(() => {
          var _inputRef$current, _inputRef$current2;

          (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
          (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(2, 12, 'forward');
        }, 10);
        break;

      case _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose:
        onChange('');
        break;
    }

    onRunQuery();
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.EditorField, {
    label: "Legend",
    tooltip: "Series name override or template. Ex. {{hostname}} will be replaced with label value for hostname.",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [mode === _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_shared_AutoSizeInput__WEBPACK_IMPORTED_MODULE_4__.AutoSizeInput, {
        id: "legendFormat",
        minWidth: 22,
        placeholder: "auto",
        defaultValue: legendFormat,
        onCommitChange: onLegendFormatChanged,
        ref: inputRef
      }), mode !== _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
        inputId: "legend.mode",
        isSearchable: false,
        placeholder: "Select legend mode",
        options: legendModeOptions,
        width: 22,
        onChange: onLegendModeChanged,
        value: legendModeOptions.find(x => x.value === mode)
      })]
    })
  });
});
PromQueryLegendEditor.displayName = 'PromQueryLegendEditor';

function getLegendMode(legendFormat) {
  // This special value means the new smart minimal series naming
  if (legendFormat === _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto) {
    return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Auto;
  } // Missing or empty legend format is the old verbose behavior


  if (legendFormat == null || legendFormat === '') {
    return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Verbose;
  }

  return _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom;
}

function getLegendModeLabel(legendFormat) {
  const mode = getLegendMode(legendFormat);

  if (mode !== _types__WEBPACK_IMPORTED_MODULE_3__.LegendFormatMode.Custom) {
    var _legendModeOptions$fi;

    return (_legendModeOptions$fi = legendModeOptions.find(x => x.value === mode)) === null || _legendModeOptions$fi === void 0 ? void 0 : _legendModeOptions$fi.label;
  }

  return legendFormat;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/components/QueryPreview.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryPreview": () => (/* binding */ QueryPreview)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/prismjs-npm-1.27.0-ca4e1667c6-85c7f4a3e9.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _promql__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/promql.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryPreview({
  query
}) {
  const theme = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.useTheme2)();
  const styles = getStyles(theme);
  const hightlighted = prismjs__WEBPACK_IMPORTED_MODULE_4___default().highlight(query, _promql__WEBPACK_IMPORTED_MODULE_5__.promqlGrammar, 'promql');
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorRow, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorFieldGroup, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.EditorField, {
        label: "Raw query",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_6__.jsx)("div", {
          className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.cx)(styles.editorField, 'prism-syntax-highlight'),
          "aria-label": "selector",
          dangerouslySetInnerHTML: {
            __html: hightlighted
          }
        })
      })
    })
  });
}

const getStyles = theme => {
  return {
    editorField: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.css)({
      fontFamily: theme.typography.fontFamilyMonospace,
      fontSize: theme.typography.bodySmall.fontSize
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/operations.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addOperationWithRangeVector": () => (/* binding */ addOperationWithRangeVector),
/* harmony export */   "createFunction": () => (/* binding */ createFunction),
/* harmony export */   "createRangeFunction": () => (/* binding */ createRangeFunction),
/* harmony export */   "getOperationDefinitions": () => (/* binding */ getOperationDefinitions),
/* harmony export */   "operationWithRangeVectorRenderer": () => (/* binding */ operationWithRangeVectorRenderer)
/* harmony export */ });
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");




function getOperationDefinitions() {
  const list = [{
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.HistogramQuantile,
    name: 'Histogram quantile',
    params: [{
      name: 'Quantile',
      type: 'number',
      options: [0.99, 0.95, 0.9, 0.75, 0.5, 0.25]
    }],
    defaultParams: [0.9],
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LabelReplace,
    name: 'Label replace',
    params: [{
      name: 'Destination label',
      type: 'string'
    }, {
      name: 'Replacement',
      type: 'string'
    }, {
      name: 'Source label',
      type: 'string'
    }, {
      name: 'Regex',
      type: 'string'
    }],
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    defaultParams: ['', '$1', '', '(.*)'],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererRight,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  }, {
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Ln,
    name: 'Ln',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererLeft,
    addOperationHandler: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  }, createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Changes), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Rate, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Irate), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Increase, true), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Idelta), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Delta), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.HoltWinters,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)(), {
      name: 'Smoothing Factor',
      type: 'number'
    }, {
      name: 'Trend Factor',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5, 0.5],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.PredictLinear,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)(), {
      name: 'Seconds from now',
      type: 'number'
    }],
    defaultParams: ['$__interval', 60],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.rangeRendererRightWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.QuantileOverTime,
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)(), {
      name: 'Quantile',
      type: 'number'
    }],
    defaultParams: ['$__interval', 0.5],
    alternativesKey: 'overtime function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.rangeRendererLeftWithParams,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  }), ..._binaryScalarOperations__WEBPACK_IMPORTED_MODULE_3__.binaryScalarOperations, {
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.NestedQuery,
    name: 'Binary operation with query',
    params: [],
    defaultParams: [],
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.BinaryOps,
    renderer: (model, def, innerExpr) => innerExpr,
    addOperationHandler: addNestedQueryHandler
  }, createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Absent
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Acos,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Acosh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Asin,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Asinh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Atan,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Atanh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Ceil
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Clamp,
    name: 'Clamp',
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }, {
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1, 1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.ClampMax,
    params: [{
      name: 'Maximum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.ClampMin,
    params: [{
      name: 'Minimum Scalar',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Cos,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Cosh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.DayOfMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.DayOfWeek,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.DaysInMonth,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Time
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Deg
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Deriv), //
  createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Exp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Floor
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Group
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Hour
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.LabelJoin,
    params: [{
      name: 'Destination Label',
      type: 'string',
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_0__.LabelParamEditor
    }, {
      name: 'Separator',
      type: 'string'
    }, {
      name: 'Source Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_0__.LabelParamEditor
    }],
    defaultParams: ['', ',', ''],
    renderer: labelJoinRenderer,
    addOperationHandler: labelJoinAddOperationHandler
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Log10
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Log2
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Minute
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Month
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Pi,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Quantile,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererLeft
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Rad
  }), createRangeFunction(_types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Resets), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Round,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    params: [{
      name: 'To Nearest',
      type: 'number'
    }],
    defaultParams: [1]
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Scalar
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sgn
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sin,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sinh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sort
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.SortDesc
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Sqrt
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Stddev
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Tan,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Tanh,
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Trigonometric
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Time,
    renderer: model => `${model.id}()`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Timestamp
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Vector,
    params: [{
      name: 'Value',
      type: 'number'
    }],
    defaultParams: [1],
    renderer: model => `${model.id}(${model.params[0]})`
  }), createFunction({
    id: _types__WEBPACK_IMPORTED_MODULE_2__.PromOperationId.Year
  })];
  return list;
}
function createFunction(definition) {
  var _definition$name, _definition$params, _definition$defaultPa, _definition$category, _definition$renderer, _definition$addOperat;

  return Object.assign({}, definition, {
    id: definition.id,
    name: (_definition$name = definition.name) !== null && _definition$name !== void 0 ? _definition$name : (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(definition.id),
    params: (_definition$params = definition.params) !== null && _definition$params !== void 0 ? _definition$params : [],
    defaultParams: (_definition$defaultPa = definition.defaultParams) !== null && _definition$defaultPa !== void 0 ? _definition$defaultPa : [],
    category: (_definition$category = definition.category) !== null && _definition$category !== void 0 ? _definition$category : _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Functions,
    renderer: (_definition$renderer = definition.renderer) !== null && _definition$renderer !== void 0 ? _definition$renderer : definition.params ? _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererRight : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.functionRendererLeft,
    addOperationHandler: (_definition$addOperat = definition.addOperationHandler) !== null && _definition$addOperat !== void 0 ? _definition$addOperat : _shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.defaultAddOperationHandler
  });
}
function createRangeFunction(name, withRateInterval = false) {
  return {
    id: name,
    name: (0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getPromAndLokiOperationDisplayName)(name),
    params: [(0,_shared_operationUtils__WEBPACK_IMPORTED_MODULE_1__.getRangeVectorParamDef)(withRateInterval)],
    defaultParams: [withRateInterval ? '$__rate_interval' : '$__interval'],
    alternativesKey: 'range function',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.RangeFunctions,
    renderer: operationWithRangeVectorRenderer,
    addOperationHandler: addOperationWithRangeVector,
    changeTypeHandler: operationTypeChangedHandlerForRangeFunction
  };
}

function operationTypeChangedHandlerForRangeFunction(operation, newDef) {
  // validate current parameter
  if (operation.params[0] === '$__rate_interval' && newDef.defaultParams[0] !== '$__rate_interval') {
    operation.params = newDef.defaultParams;
  } else if (operation.params[0] === '$__interval' && newDef.defaultParams[0] !== '$__interval') {
    operation.params = newDef.defaultParams;
  }

  return operation;
}

function operationWithRangeVectorRenderer(model, def, innerExpr) {
  var _, _model$params;

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m';
  return `${def.id}(${innerExpr}[${rangeVector}])`;
}
/**
 * Since there can only be one operation with range vector this will replace the current one (if one was added )
 */

function addOperationWithRangeVector(def, query, modeller) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };

  if (query.operations.length > 0) {
    // If operation exists it has to be in the registry so no point to check if it was found
    const firstOp = modeller.getOperationDef(query.operations[0].id);

    if (firstOp.addOperationHandler === addOperationWithRangeVector) {
      return Object.assign({}, query, {
        operations: [newOperation, ...query.operations.slice(1)]
      });
    }
  }

  return Object.assign({}, query, {
    operations: [newOperation, ...query.operations]
  });
}

function addNestedQueryHandler(def, query) {
  var _query$binaryQueries;

  return Object.assign({}, query, {
    binaryQueries: [...((_query$binaryQueries = query.binaryQueries) !== null && _query$binaryQueries !== void 0 ? _query$binaryQueries : []), {
      operator: '/',
      query
    }]
  });
}

function labelJoinRenderer(model, def, innerExpr) {
  if (typeof model.params[1] !== 'string') {
    throw 'The separator must be a string';
  }

  const separator = `"${model.params[1]}"`;
  return `${model.id}(${innerExpr}, "${model.params[0]}", ${separator}, "${model.params.slice(2).join(separator)}")`;
}

function labelJoinAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/parsing.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildVisualQueryFromString": () => (/* binding */ buildVisualQueryFromString),
/* harmony export */   "handleExpression": () => (/* binding */ handleExpression)
/* harmony export */ });
/* harmony import */ var lezer_promql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js");
/* harmony import */ var _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/binaryScalarOperations.ts");
/* harmony import */ var _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts");



/**
 * Parses a PromQL query into a visual query model.
 *
 * It traverses the tree and uses sort of state machine to update the query model. The query model is modified
 * during the traversal and sent to each handler as context.
 *
 * @param expr
 */

function buildVisualQueryFromString(expr) {
  const replacedExpr = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.replaceVariables)(expr);
  const tree = lezer_promql__WEBPACK_IMPORTED_MODULE_0__.parser.parse(replacedExpr);
  const node = tree.topNode; // This will be modified in the handlers.

  const visQuery = {
    metric: '',
    labels: [],
    operations: []
  };
  const context = {
    query: visQuery,
    errors: []
  };

  try {
    handleExpression(replacedExpr, node, context);
  } catch (err) {
    // Not ideal to log it here, but otherwise we would lose the stack trace.
    console.error(err);
    context.errors.push({
      text: err.message
    });
  } // If we have empty query, we want to reset errors


  if (isEmptyQuery(context.query)) {
    context.errors = [];
  }

  return context;
}

/**
 * Handler for default state. It will traverse the tree and call the appropriate handler for each node. The node
 * handled here does not necessarily need to be of type == Expr.
 * @param expr
 * @param node
 * @param context
 */
function handleExpression(expr, node, context) {
  const visQuery = context.query;

  switch (node.name) {
    case 'MetricIdentifier':
      {
        // Expectation is that there is only one of those per query.
        visQuery.metric = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node);
        break;
      }

    case 'LabelMatcher':
      {
        // Same as MetricIdentifier should be just one per query.
        visQuery.labels.push(getLabel(expr, node));
        const err = node.getChild(_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName);

        if (err) {
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, err));
        }

        break;
      }

    case 'FunctionCall':
      {
        handleFunction(expr, node, context);
        break;
      }

    case 'AggregateExpr':
      {
        handleAggregation(expr, node, context);
        break;
      }

    case 'BinaryExpr':
      {
        handleBinary(expr, node, context);
        break;
      }

    case _shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.ErrorName:
      {
        if (isIntervalVariableError(node)) {
          break;
        }

        context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        break;
      }

    default:
      {
        if (node.name === 'ParenExpr') {
          // We don't support parenthesis in the query to group expressions. We just report error but go on with the
          // parsing.
          context.errors.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeError)(expr, node));
        } // Any other nodes we just ignore and go to it's children. This should be fine as there are lot's of wrapper
        // nodes that can be skipped.
        // TODO: there are probably cases where we will just skip nodes we don't support and we should be able to
        //  detect those and report back.


        let child = node.firstChild;

        while (child) {
          handleExpression(expr, child, context);
          child = child.nextSibling;
        }
      }
  }
}

function isIntervalVariableError(node) {
  var _node$prevSibling, _node$prevSibling2, _node$prevSibling2$fi;

  return ((_node$prevSibling = node.prevSibling) === null || _node$prevSibling === void 0 ? void 0 : _node$prevSibling.name) === 'Expr' && ((_node$prevSibling2 = node.prevSibling) === null || _node$prevSibling2 === void 0 ? void 0 : (_node$prevSibling2$fi = _node$prevSibling2.firstChild) === null || _node$prevSibling2$fi === void 0 ? void 0 : _node$prevSibling2$fi.name) === 'VectorSelector';
}

function getLabel(expr, node) {
  const label = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('LabelName'));
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('MatchOp'));
  const value = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node.getChild('StringLiteral')).replace(/"/g, '');
  return {
    label,
    op,
    value
  };
}

const rangeFunctions = ['changes', 'rate', 'irate', 'increase', 'delta'];
/**
 * Handle function call which is usually and identifier and its body > arguments.
 * @param expr
 * @param node
 * @param context
 */

function handleFunction(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('FunctionIdentifier');
  const funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const params = [];
  let interval = ''; // This is a bit of a shortcut to get the interval argument. Reasons are
  // - interval is not part of the function args per promQL grammar but we model it as argument for the function in
  //   the query model.
  // - it is easier to handle template variables this way as template variable is an error for the parser

  if (rangeFunctions.includes(funcName) || funcName.endsWith('_over_time')) {
    let match = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).match(/\[(.+)\]/);

    if (match !== null && match !== void 0 && match[1]) {
      interval = match[1];
      params.push(match[1]);
    }
  }

  const op = {
    id: funcName,
    params
  }; // We unshift operations to keep the more natural order that we want to have in the visual query editor.

  visQuery.operations.unshift(op);

  if (callArgs) {
    if ((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, callArgs) === interval + ']') {
      // This is a special case where we have a function with a single argument and it is the interval.
      // This happens when you start adding operations in query builder and did not set a metric yet.
      return;
    }

    updateFunctionArgs(expr, callArgs, context, op);
  }
}
/**
 * Handle aggregation as they are distinct type from other functions.
 * @param expr
 * @param node
 * @param context
 */


function handleAggregation(expr, node, context) {
  const visQuery = context.query;
  const nameNode = node.getChild('AggregateOp');
  let funcName = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, nameNode);
  const modifier = node.getChild('AggregateModifier');
  const labels = [];

  if (modifier) {
    const byModifier = modifier.getChild(`By`);

    if (byModifier && funcName) {
      funcName = `__${funcName}_by`;
    }

    const withoutModifier = modifier.getChild(`Without`);

    if (withoutModifier) {
      funcName = `__${funcName}_without`;
    }

    labels.push(...(0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getAllByType)(expr, modifier, 'GroupingLabel'));
  }

  const body = node.getChild('FunctionCallBody');
  const callArgs = body.getChild('FunctionCallArgs');
  const op = {
    id: funcName,
    params: []
  };
  visQuery.operations.unshift(op);
  updateFunctionArgs(expr, callArgs, context, op); // We add labels after params in the visual query editor.

  op.params.push(...labels);
}
/**
 * Handle (probably) all types of arguments that function or aggregation can have.
 *
 *  FunctionCallArgs are nested bit weirdly basically its [firstArg, ...rest] where rest is again FunctionCallArgs so
 *  we cannot just get all the children and iterate them as arguments we have to again recursively traverse through
 *  them.
 *
 * @param expr
 * @param node
 * @param context
 * @param op - We need the operation to add the params to as an additional context.
 */


function updateFunctionArgs(expr, node, context, op) {
  if (!node) {
    return;
  }

  switch (node.name) {
    // In case we have an expression we don't know what kind so we have to look at the child as it can be anything.
    case 'Expr': // FunctionCallArgs are nested bit weirdly as mentioned so we have to go one deeper in this case.

    case 'FunctionCallArgs':
      {
        let child = node.firstChild;

        while (child) {
          updateFunctionArgs(expr, child, context, op);
          child = child.nextSibling;
        }

        break;
      }

    case 'NumberLiteral':
      {
        op.params.push(parseFloat((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node)));
        break;
      }

    case 'StringLiteral':
      {
        op.params.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, node).replace(/"/g, ''));
        break;
      }

    default:
      {
        // Means we get to something that does not seem like simple function arg and is probably nested query so jump
        // back to main context
        handleExpression(expr, node, context);
      }
  }
}

const operatorToOpName = _binaryScalarOperations__WEBPACK_IMPORTED_MODULE_1__.binaryScalarDefs.reduce((acc, def) => {
  acc[def.sign] = {
    id: def.id,
    comparison: def.comparison
  };
  return acc;
}, {});
/**
 * Right now binary expressions can be represented in 2 way in visual query. As additional operation in case it is
 * just operation with scalar or it creates a binaryQuery when it's 2 queries.
 * @param expr
 * @param node
 * @param context
 */

function handleBinary(expr, node, context) {
  const visQuery = context.query;
  const left = node.firstChild;
  const op = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, left.nextSibling);
  const binModifier = getBinaryModifier(expr, node.getChild('BinModifiers'));
  const right = node.lastChild;
  const opDef = operatorToOpName[op];
  const leftNumber = left.getChild('NumberLiteral');
  const rightNumber = right.getChild('NumberLiteral');
  const rightBinary = right.getChild('BinaryExpr');

  if (leftNumber) {// TODO: this should be already handled in case parent is binary expression as it has to be added to parent
    //  if query starts with a number that isn't handled now.
  } else {
    // If this is binary we don't really know if there is a query or just chained scalars. So
    // we have to traverse a bit deeper to know
    handleExpression(expr, left, context);
  }

  if (rightNumber) {
    visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, right, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
  } else if (rightBinary) {
    // Due to the way binary ops are parsed we can get a binary operation on the right that starts with a number which
    // is a factor for a current binary operation. So we have to add it as an operation now.
    const leftMostChild = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getLeftMostChild)(right);

    if ((leftMostChild === null || leftMostChild === void 0 ? void 0 : leftMostChild.name) === 'NumberLiteral') {
      visQuery.operations.push((0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.makeBinOp)(opDef, expr, leftMostChild, !!(binModifier !== null && binModifier !== void 0 && binModifier.isBool)));
    } // If we added the first number literal as operation here we still can continue and handle the rest as the first
    // number will be just skipped.


    handleExpression(expr, right, context);
  } else {
    visQuery.binaryQueries = visQuery.binaryQueries || [];
    const binQuery = {
      operator: op,
      query: {
        metric: '',
        labels: [],
        operations: []
      }
    };

    if (binModifier !== null && binModifier !== void 0 && binModifier.isMatcher) {
      binQuery.vectorMatchesType = binModifier.matchType;
      binQuery.vectorMatches = binModifier.matches;
    }

    visQuery.binaryQueries.push(binQuery);
    handleExpression(expr, right, {
      query: binQuery.query,
      errors: context.errors
    });
  }
}

function getBinaryModifier(expr, node) {
  if (!node) {
    return undefined;
  }

  if (node.getChild('Bool')) {
    return {
      isBool: true,
      isMatcher: false
    };
  } else {
    var _matcher$getChild;

    const matcher = node.getChild('OnOrIgnoring');

    if (!matcher) {
      // Not sure what this could be, maybe should be an error.
      return undefined;
    }

    const labels = (0,_shared_parsingUtils__WEBPACK_IMPORTED_MODULE_2__.getString)(expr, (_matcher$getChild = matcher.getChild('GroupingLabels')) === null || _matcher$getChild === void 0 ? void 0 : _matcher$getChild.getChild('GroupingLabelList'));
    return {
      isMatcher: true,
      isBool: false,
      matches: labels,
      matchType: matcher.getChild('On') ? 'on' : 'ignoring'
    };
  }
}

function isEmptyQuery(query) {
  if (query.labels.length === 0 && query.operations.length === 0 && !query.metric) {
    return true;
  }

  return false;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutoSizeInput": () => (/* binding */ AutoSizeInput)
/* harmony export */ });
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["defaultValue", "minWidth", "maxWidth", "onCommitChange", "onKeyDown", "onBlur"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




const AutoSizeInput = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref) => {
  const {
    defaultValue = '',
    minWidth = 10,
    maxWidth,
    onCommitChange,
    onKeyDown,
    onBlur
  } = props,
        restProps = _objectWithoutPropertiesLoose(props, _excluded);

  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_1__.useState(defaultValue);
  const [inputWidth, setInputWidth] = react__WEBPACK_IMPORTED_MODULE_1__.useState(minWidth);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
    setInputWidth(getWidthFor(value.toString(), minWidth, maxWidth));
  }, [value, maxWidth, minWidth]);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.Input, Object.assign({}, restProps, {
    ref: ref,
    value: value.toString(),
    onChange: event => {
      setValue(event.currentTarget.value);
    },
    width: inputWidth,
    onBlur: event => {
      if (onCommitChange) {
        onCommitChange(event);
      }

      if (onBlur) {
        onBlur(event);
      }
    },
    onKeyDown: event => {
      if (event.key === 'Enter' && onCommitChange) {
        onCommitChange(event);
      }

      if (onKeyDown) {
        onKeyDown(event);
      }
    },
    "data-testid": 'autosize-input'
  }));
});

function getWidthFor(value, minWidth, maxWidth) {
  if (!value) {
    return minWidth;
  }

  const extraSpace = 3;
  const realWidth = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.measureText)(value.toString(), 14).width / 8 + extraSpace;

  if (minWidth && realWidth < minWidth) {
    return minWidth;
  }

  if (maxWidth && realWidth > maxWidth) {
    return realWidth;
  }

  return realWidth;
}

AutoSizeInput.displayName = 'AutoSizeInput';

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/FeedbackLink.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FeedbackLink": () => (/* binding */ FeedbackLink)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _Icon;








function FeedbackLink({
  feedbackUrl
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);

  if (!_grafana_runtime__WEBPACK_IMPORTED_MODULE_2__.config.feedbackLinksEnabled) {
    return null;
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 1,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("a", {
      href: feedbackUrl,
      className: styles.link,
      title: "This query builder is new, please let us know how we can improve it",
      target: "_blank",
      rel: "noreferrer noopener",
      children: [_Icon || (_Icon = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
        name: "comment-alt-message"
      })), " Give feedback"]
    })
  });
}

function getStyles(theme) {
  return {
    link: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      ':hover': {
        color: theme.colors.text.link
      }
    })
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilterItem": () => (/* binding */ LabelFilterItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function LabelFilterItem({
  item,
  defaultOp,
  onChange,
  onDelete,
  onGetLabelNames,
  onGetLabelValues
}) {
  var _item$op2;

  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});

  const isMultiSelect = () => {
    return item.op === operators[0].label;
  };

  const getValue = item => {
    if (item && item.value) {
      if (item.value.indexOf('|') > 0) {
        return item.value.split('|').map(x => ({
          label: x,
          value: x
        }));
      }

      return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(item.value);
    }

    return null;
  };

  const getOptions = () => {
    if (!state.labelValues && item && item.value && item.value.indexOf('|') > 0) {
      return getValue(item);
    }

    return state.labelValues;
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": "prometheus-dimensions-filter-item",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.InputGroup, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
        inputId: "prometheus-dimensions-filter-item-key",
        width: "auto",
        value: item.label ? (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)(item.label) : null,
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelNames: true
          });
          const labelNames = await onGetLabelNames(item);
          setState({
            labelNames,
            isLoadingLabelNames: undefined
          });
        },
        isLoading: state.isLoadingLabelNames,
        options: state.labelNames,
        onChange: change => {
          if (change.label) {
            var _item$op;

            onChange(Object.assign({}, item, {
              op: (_item$op = item.op) !== null && _item$op !== void 0 ? _item$op : defaultOp,
              label: change.label
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
        value: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_2__.toOption)((_item$op2 = item.op) !== null && _item$op2 !== void 0 ? _item$op2 : defaultOp),
        options: operators,
        width: "auto",
        onChange: change => {
          if (change.value != null) {
            onChange(Object.assign({}, item, {
              op: change.value
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
        inputId: "prometheus-dimensions-filter-item-value",
        width: "auto",
        value: getValue(item),
        allowCustomValue: true,
        onOpenMenu: async () => {
          setState({
            isLoadingLabelValues: true
          });
          const labelValues = await onGetLabelValues(item);
          setState(Object.assign({}, state, {
            labelValues,
            isLoadingLabelValues: undefined
          }));
        },
        isMulti: isMultiSelect(),
        isLoading: state.isLoadingLabelValues,
        options: getOptions(),
        onChange: change => {
          if (change.value) {
            var _item$op3;

            onChange(Object.assign({}, item, {
              value: change.value,
              op: (_item$op3 = item.op) !== null && _item$op3 !== void 0 ? _item$op3 : defaultOp
            }));
          } else {
            var _item$op4;

            const changes = change.map(change => {
              return change.label;
            }).join('|');
            onChange(Object.assign({}, item, {
              value: changes,
              op: (_item$op4 = item.op) !== null && _item$op4 !== void 0 ? _item$op4 : defaultOp
            }));
          }
        }
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_3__.AccessoryButton, {
        "aria-label": "remove",
        icon: "times",
        variant: "secondary",
        onClick: onDelete
      })]
    })
  });
}
const operators = [{
  label: '=~',
  value: '=~'
}, {
  label: '=',
  value: '='
}, {
  label: '!=',
  value: '!='
}, {
  label: '!~',
  value: '!~'
}];

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilters.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelFilters": () => (/* binding */ LabelFilters)
/* harmony export */ });
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/LabelFilterItem.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function LabelFilters({
  labelsFilters,
  onChange,
  onGetLabelNames,
  onGetLabelValues
}) {
  const defaultOp = '=';
  const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([{
    op: defaultOp
  }]);
  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => {
    if (labelsFilters.length > 0) {
      setItems(labelsFilters);
    } else {
      setItems([{
        op: defaultOp
      }]);
    }
  }, [labelsFilters]);

  const onLabelsChange = newItems => {
    setItems(newItems); // Extract full label filters with both label & value

    const newLabels = newItems.filter(x => x.label != null && x.value != null);

    if (!(0,lodash__WEBPACK_IMPORTED_MODULE_1__.isEqual)(newLabels, labelsFilters)) {
      onChange(newLabels);
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_0__.EditorFieldGroup, {
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_0__.EditorField, {
      label: "Labels",
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_0__.EditorList, {
        items: items,
        onChange: onLabelsChange,
        renderItem: (item, onChangeItem, onDelete) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_LabelFilterItem__WEBPACK_IMPORTED_MODULE_3__.LabelFilterItem, {
          item: item,
          defaultOp: defaultOp,
          onChange: onChangeItem,
          onDelete: onDelete,
          onGetLabelNames: onGetLabelNames,
          onGetLabelValues: onGetLabelValues
        })
      })
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/LokiAndPromQueryModellerBase.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LokiAndPromQueryModellerBase": () => (/* binding */ LokiAndPromQueryModellerBase)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



class LokiAndPromQueryModellerBase {
  constructor(getOperations) {
    _defineProperty(this, "operationsRegisty", void 0);

    _defineProperty(this, "categories", []);

    this.operationsRegisty = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.Registry(getOperations);
  }

  setOperationCategories(categories) {
    this.categories = categories;
  }

  getOperationsForCategory(category) {
    return this.operationsRegisty.list().filter(op => op.category === category && !op.hideFromList);
  }

  getAlternativeOperations(key) {
    return this.operationsRegisty.list().filter(op => op.alternativesKey === key);
  }

  getCategories() {
    return this.categories;
  }

  getOperationDef(id) {
    return this.operationsRegisty.getIfExists(id);
  }

  renderOperations(queryString, operations) {
    for (const operation of operations) {
      const def = this.operationsRegisty.getIfExists(operation.id);

      if (!def) {
        throw new Error(`Could not find operation ${operation.id} in the registry`);
      }

      queryString = def.renderer(operation, def, queryString);
    }

    return queryString;
  }

  renderBinaryQueries(queryString, binaryQueries) {
    if (binaryQueries) {
      for (const binQuery of binaryQueries) {
        queryString = `${this.renderBinaryQuery(queryString, binQuery)}`;
      }
    }

    return queryString;
  }

  renderBinaryQuery(leftOperand, binaryQuery) {
    let result = leftOperand + ` ${binaryQuery.operator} `;

    if (binaryQuery.vectorMatches) {
      result += `${binaryQuery.vectorMatchesType}(${binaryQuery.vectorMatches}) `;
    }

    return result + this.renderQuery(binaryQuery.query, true);
  }

  renderLabels(labels) {
    if (labels.length === 0) {
      return '';
    }

    let expr = '{';

    for (const filter of labels) {
      if (expr !== '{') {
        expr += ', ';
      }

      expr += `${filter.label}${filter.op}"${filter.value}"`;
    }

    return expr + `}`;
  }

  renderQuery(query, nested) {
    var _query$metric, _query$binaryQueries, _query$binaryQueries2;

    let queryString = `${(_query$metric = query.metric) !== null && _query$metric !== void 0 ? _query$metric : ''}${this.renderLabels(query.labels)}`;
    queryString = this.renderOperations(queryString, query.operations);

    if (!nested && this.hasBinaryOp(query) && Boolean((_query$binaryQueries = query.binaryQueries) === null || _query$binaryQueries === void 0 ? void 0 : _query$binaryQueries.length)) {
      queryString = `(${queryString})`;
    }

    queryString = this.renderBinaryQueries(queryString, query.binaryQueries);

    if (nested && (this.hasBinaryOp(query) || Boolean((_query$binaryQueries2 = query.binaryQueries) === null || _query$binaryQueries2 === void 0 ? void 0 : _query$binaryQueries2.length))) {
      queryString = `(${queryString})`;
    }

    return queryString;
  }

  hasBinaryOp(query) {
    return query.operations.find(op => {
      const def = this.getOperationDef(op.id);
      return (def === null || def === void 0 ? void 0 : def.category) === _types__WEBPACK_IMPORTED_MODULE_1__.PromVisualQueryOperationCategory.BinaryOps;
    }) !== undefined;
  }

}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationEditor": () => (/* binding */ OperationEditor)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var _OperationHeader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx");
/* harmony import */ var _OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");










function OperationEditor({
  operation,
  index,
  onRemove,
  onChange,
  onRunQuery,
  queryModeller,
  query,
  datasource,
  highlight
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const def = queryModeller.getOperationDef(operation.id);
  const shouldHighlight = useHighlight(highlight);

  if (!def) {
    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("span", {
      children: ["Operation ", operation.id, " not found"]
    });
  }

  const onParamValueChanged = (paramIdx, value) => {
    const update = Object.assign({}, operation, {
      params: [...operation.params]
    });
    update.params[paramIdx] = value;
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const onAddRestParam = () => {
    const update = Object.assign({}, operation, {
      params: [...operation.params, '']
    });
    callParamChangedThenOnChange(def, update, index, operation.params.length, onChange);
  };

  const onRemoveRestParam = paramIdx => {
    const update = Object.assign({}, operation, {
      params: [...operation.params.slice(0, paramIdx), ...operation.params.slice(paramIdx + 1)]
    });
    callParamChangedThenOnChange(def, update, index, paramIdx, onChange);
  };

  const operationElements = [];

  for (let paramIndex = 0; paramIndex < operation.params.length; paramIndex++) {
    const paramDef = def.params[Math.min(def.params.length - 1, paramIndex)];
    const Editor = (0,_OperationParamEditor__WEBPACK_IMPORTED_MODULE_5__.getOperationParamEditor)(paramDef);
    operationElements.push( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
      className: styles.paramRow,
      children: [!paramDef.hideName && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.paramName,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("label", {
          htmlFor: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_6__.getOperationParamId)(index, paramIndex),
          children: paramDef.name
        }), paramDef.description && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Tooltip, {
          placement: "top",
          content: paramDef.description,
          theme: "info",
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, {
            name: "info-circle",
            size: "sm",
            className: styles.infoIcon
          })
        })]
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.paramValue,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
          gap: 0.5,
          direction: "row",
          alignItems: "center",
          wrap: false,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(Editor, {
            index: paramIndex,
            paramDef: paramDef,
            value: operation.params[paramIndex],
            operation: operation,
            operationIndex: index,
            onChange: onParamValueChanged,
            onRunQuery: onRunQuery,
            query: query,
            datasource: datasource
          }), paramDef.restParam && (operation.params.length > def.params.length || paramDef.optional) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
            "data-testid": `operations.${index}.remove-rest-param`,
            size: "sm",
            fill: "text",
            icon: "times",
            variant: "secondary",
            title: `Remove ${paramDef.name}`,
            onClick: () => onRemoveRestParam(paramIndex)
          })]
        })
      })]
    }, `${paramIndex}-1`));
  } // Handle adding button for rest params


  let restParam;

  if (def.params.length > 0) {
    const lastParamDef = def.params[def.params.length - 1];

    if (lastParamDef.restParam) {
      restParam = renderAddRestParamButton(lastParamDef, onAddRestParam, index, operation.params.length, styles);
    }
  }

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_8__.Draggable, {
    draggableId: `operation-${index}`,
    index: index,
    children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", Object.assign({
      className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.cx)(styles.card, shouldHighlight && styles.cardHighlight),
      ref: provided.innerRef
    }, provided.draggableProps, {
      "data-testid": `operations.${index}.wrapper`,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_OperationHeader__WEBPACK_IMPORTED_MODULE_4__.OperationHeader, {
        operation: operation,
        dragHandleProps: provided.dragHandleProps,
        def: def,
        index: index,
        onChange: onChange,
        onRemove: onRemove,
        queryModeller: queryModeller
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
        className: styles.body,
        children: operationElements
      }), restParam, index < query.operations.length - 1 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxs)("div", {
        className: styles.arrow,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowLine
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
          className: styles.arrowArrow
        })]
      })]
    }))
  });
}
/**
 * When highlight is switched on makes sure it is switched of right away, so we just flash the highlight and then fade
 * out.
 * @param highlight
 */

function useHighlight(highlight) {
  const [keepHighlight, setKeepHighlight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {
    let t;

    if (highlight) {
      t = setTimeout(() => {
        setKeepHighlight(false);
      }, 1);
    } else {
      setKeepHighlight(true);
    }

    return () => clearTimeout(t);
  }, [highlight]);
  return keepHighlight && highlight;
}

function renderAddRestParamButton(paramDef, onAddRestParam, operationIndex, paramIndex, styles) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)("div", {
    className: styles.restParam,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_7__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
      size: "sm",
      icon: "plus",
      title: `Add ${paramDef.name}`,
      variant: "secondary",
      onClick: onAddRestParam,
      "data-testid": `operations.${operationIndex}.add-rest-param`,
      children: paramDef.name
    })
  }, `${paramIndex}-2`);
}

function callParamChangedThenOnChange(def, operation, operationIndex, paramIndex, onChange) {
  if (def.paramChangedHandler) {
    onChange(operationIndex, def.paramChangedHandler(paramIndex, operation, def));
  } else {
    onChange(operationIndex, operation);
  }
}

const getStyles = theme => {
  return {
    card: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.medium}`,
      display: 'flex',
      flexDirection: 'column',
      cursor: 'grab',
      borderRadius: theme.shape.borderRadius(1),
      marginBottom: theme.spacing(1),
      position: 'relative',
      transition: 'all 1s ease-in 0s'
    }),
    cardHighlight: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      boxShadow: `0px 0px 4px 0px ${theme.colors.primary.border}`,
      border: `1px solid ${theme.colors.primary.border}`
    }),
    infoIcon: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(0.5),
      color: theme.colors.text.secondary,
      ':hover': {
        color: theme.colors.text.primary
      }
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      margin: theme.spacing(1, 1, 0.5, 1),
      display: 'table'
    }),
    paramRow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramRow',
      display: 'table-row',
      verticalAlign: 'middle'
    }),
    paramName: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      display: 'table-cell',
      padding: theme.spacing(0, 1, 0, 0),
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      verticalAlign: 'middle',
      height: '32px'
    }),
    paramValue: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'paramValue',
      display: 'table-cell',
      verticalAlign: 'middle'
    }),
    restParam: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(0, 1, 1, 1)
    }),
    arrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      position: 'absolute',
      top: '0',
      right: '-18px',
      display: 'flex'
    }),
    arrowLine: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      height: '2px',
      width: '8px',
      backgroundColor: theme.colors.border.strong,
      position: 'relative',
      top: '14px'
    }),
    arrowArrow: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      width: 0,
      height: 0,
      borderTop: `5px solid transparent`,
      borderBottom: `5px solid transparent`,
      borderLeft: `7px solid ${theme.colors.border.strong}`,
      position: 'relative',
      top: '10px'
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationExplainedBox": () => (/* binding */ OperationExplainedBox)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function OperationExplainedBox({
  title,
  stepNumber,
  markdown,
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
    className: styles.box,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.stepNumber,
      children: stepNumber
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.boxInner,
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.header,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: title
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        className: styles.body,
        children: [markdown && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
          dangerouslySetInnerHTML: {
            __html: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.renderMarkdown)(markdown)
          }
        }), children]
      })]
    })]
  });
}

const getStyles = theme => {
  return {
    box: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      background: theme.colors.background.secondary,
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      position: 'relative',
      marginBottom: theme.spacing(0.5)
    }),
    boxInner: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      marginLeft: theme.spacing(4)
    }),
    stepNumber: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontWeight: theme.typography.fontWeightMedium,
      background: theme.colors.secondary.main,
      width: '20px',
      height: '20px',
      borderRadius: '50%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'absolute',
      top: '10px',
      left: '11px',
      fontSize: theme.typography.bodySmall.fontSize
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingBottom: theme.spacing(0.5),
      display: 'flex',
      alignItems: 'center',
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      'p:last-child': {
        margin: 0
      },
      a: {
        color: theme.colors.text.link,
        textDecoration: 'underline'
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationHeader.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationHeader": () => (/* binding */ OperationHeader)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;









const OperationHeader = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3__.memo(({
  operation,
  def,
  index,
  onChange,
  onRemove,
  queryModeller,
  dragHandleProps
}) => {
  var _def$name;

  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({});

  const onToggleSwitcher = () => {
    if (state.isOpen) {
      setState(Object.assign({}, state, {
        isOpen: false
      }));
    } else {
      const alternatives = queryModeller.getAlternativeOperations(def.alternativesKey).map(alt => ({
        label: alt.name,
        value: alt
      }));
      setState({
        isOpen: true,
        alternatives
      });
    }
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
    className: styles.header,
    children: [!state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", Object.assign({}, dragHandleProps, {
        children: (_def$name = def.name) !== null && _def$name !== void 0 ? _def$name : def.id
      })), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.FlexItem, {
        grow: 1
      })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
        className: `${styles.operationHeaderButtons} operation-header-show-on-hover`,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          icon: "angle-down",
          size: "sm",
          onClick: onToggleSwitcher,
          fill: "text",
          variant: "secondary",
          title: "Click to view alternative operations"
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationInfoButton__WEBPACK_IMPORTED_MODULE_4__.OperationInfoButton, {
          def: def,
          operation: operation
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          icon: "times",
          size: "sm",
          onClick: () => onRemove(index),
          fill: "text",
          variant: "secondary",
          title: "Remove operation"
        })]
      })]
    }), state.isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
      className: styles.selectWrapper,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {
        autoFocus: true,
        openMenuOnFocus: true,
        placeholder: "Replace with",
        options: state.alternatives,
        isOpen: true,
        onCloseMenu: onToggleSwitcher,
        onChange: value => {
          if (value.value) {
            // Operation should exist if it is selectable
            const newDef = queryModeller.getOperationDef(value.value.id);
            let changedOp = Object.assign({}, operation, {
              id: value.value.id
            });
            onChange(index, def.changeTypeHandler ? def.changeTypeHandler(changedOp, newDef) : changedOp);
          }
        }
      })
    })]
  });
});
OperationHeader.displayName = 'OperationHeader';

const getStyles = theme => {
  return {
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      borderBottom: `1px solid ${theme.colors.border.medium}`,
      padding: theme.spacing(0.5, 0.5, 0.5, 1),
      display: 'flex',
      alignItems: 'center',
      '&:hover .operation-header-show-on-hover': (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
        opacity: 1
      })
    }),
    operationHeaderButtons: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      transition: theme.transitions.create(['opacity'], {
        duration: theme.transitions.duration.short
      })
    }),
    selectWrapper: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      paddingRight: theme.spacing(2)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationInfoButton.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationInfoButton": () => (/* binding */ OperationInfoButton)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-popper-tooltip-virtual-d9d7047333/0/cache/react-popper-tooltip-npm-4.3.1-91318ee546-82ae84c3b7.zip/node_modules/react-popper-tooltip/dist/esm/react-popper-tooltip.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
var _FlexItem;










const OperationInfoButton = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.memo(({
  def,
  operation
}) => {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  const [show, setShow] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(false);
  const {
    getTooltipProps,
    setTooltipRef,
    setTriggerRef,
    visible
  } = (0,react_popper_tooltip__WEBPACK_IMPORTED_MODULE_6__.usePopperTooltip)({
    placement: 'top',
    visible: show,
    offset: [0, 16],
    onVisibleChange: setShow,
    interactive: true,
    trigger: ['click']
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
      title: "Click to show description",
      ref: setTriggerRef,
      icon: "info-circle",
      size: "sm",
      variant: "secondary",
      fill: "text"
    }), visible && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Portal, {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
        ref: setTooltipRef
      }, getTooltipProps(), {
        className: styles.docBox,
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", {
          className: styles.docBoxHeader,
          children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("span", {
            children: def.renderer(operation, def, '<expr>')
          }), _FlexItem || (_FlexItem = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.FlexItem, {
            grow: 1
          })), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Button, {
            icon: "times",
            onClick: () => setShow(false),
            fill: "text",
            variant: "secondary",
            title: "Remove operation"
          })]
        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
          className: styles.docBoxBody,
          dangerouslySetInnerHTML: {
            __html: getOperationDocs(def, operation)
          }
        })]
      }))
    })]
  });
});
OperationInfoButton.displayName = 'OperationDocs';

const getStyles = theme => {
  return {
    docBox: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      overflow: 'hidden',
      background: theme.colors.background.primary,
      border: `1px solid ${theme.colors.border.strong}`,
      boxShadow: theme.shadows.z3,
      maxWidth: '600px',
      padding: theme.spacing(1),
      borderRadius: theme.shape.borderRadius(),
      zIndex: theme.zIndex.tooltip
    }),
    docBoxHeader: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.h5.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace,
      paddingBottom: theme.spacing(1),
      display: 'flex',
      alignItems: 'center'
    }),
    docBoxBody: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      // The markdown paragraph has a marginBottom this removes it
      marginBottom: theme.spacing(-1),
      color: theme.colors.text.secondary
    }),
    signature: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      fontSize: theme.typography.bodySmall.fontSize,
      fontFamily: theme.typography.fontFamilyMonospace
    }),
    dropdown: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      opacity: 0,
      color: theme.colors.text.secondary
    })
  };
};

function getOperationDocs(def, op) {
  var _def$documentation;

  return (0,_grafana_data__WEBPACK_IMPORTED_MODULE_1__.renderMarkdown)(def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs');
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationList.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationList": () => (/* binding */ OperationList)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/__virtual__/react-beautiful-dnd-virtual-27e4b658e7/0/cache/react-beautiful-dnd-npm-13.1.0-fcf5568b1c-12b7e9fbe8.zip/node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useMountedState.js");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js");
/* harmony import */ var _OperationEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationEditor.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");









function OperationList({
  query,
  datasource,
  queryModeller,
  onChange,
  onRunQuery
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  const {
    operations
  } = query;
  const opsToHighlight = useOperationsHighlight(operations);
  const [cascaderOpen, setCascaderOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);

  const onOperationChange = (index, update) => {
    const updatedList = [...operations];
    updatedList.splice(index, 1, update);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onRemove = index => {
    const updatedList = [...operations.slice(0, index), ...operations.slice(index + 1)];
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const addOptions = queryModeller.getCategories().map(category => {
    return {
      value: category,
      label: category,
      items: queryModeller.getOperationsForCategory(category).map(operation => ({
        value: operation.id,
        label: operation.name,
        isLeaf: true
      }))
    };
  });

  const onAddOperation = value => {
    const operationDef = queryModeller.getOperationDef(value);

    if (!operationDef) {
      return;
    }

    onChange(operationDef.addOperationHandler(operationDef, query, queryModeller));
    setCascaderOpen(false);
  };

  const onDragEnd = result => {
    if (!result.destination) {
      return;
    }

    const updatedList = [...operations];
    const element = updatedList[result.source.index];
    updatedList.splice(result.source.index, 1);
    updatedList.splice(result.destination.index, 0, element);
    onChange(Object.assign({}, query, {
      operations: updatedList
    }));
  };

  const onCascaderBlur = () => {
    setCascaderOpen(false);
  };

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 1,
    direction: "column",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
      gap: 1,
      children: [operations.length > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.DragDropContext, {
        onDragEnd: onDragEnd,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react_beautiful_dnd__WEBPACK_IMPORTED_MODULE_6__.Droppable, {
          droppableId: "sortable-field-mappings",
          direction: "horizontal",
          children: provided => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div", Object.assign({
            className: styles.operationList,
            ref: provided.innerRef
          }, provided.droppableProps, {
            children: [operations.map((op, index) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_OperationEditor__WEBPACK_IMPORTED_MODULE_4__.OperationEditor, {
              queryModeller: queryModeller,
              index: index,
              operation: op,
              query: query,
              datasource: datasource,
              onChange: onOperationChange,
              onRemove: onRemove,
              onRunQuery: onRunQuery,
              highlight: opsToHighlight[index]
            }, op.id + index)), provided.placeholder]
          }))
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div", {
        className: styles.addButton,
        children: cascaderOpen ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Cascader, {
          options: addOptions,
          onSelect: onAddOperation,
          onBlur: onCascaderBlur,
          autoFocus: true,
          alwaysOpen: true,
          hideActiveLevelLabel: true,
          placeholder: 'Search'
        }) : /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Button, {
          icon: 'plus',
          variant: 'secondary',
          onClick: () => setCascaderOpen(true),
          title: 'Add operation',
          children: "Operations"
        })
      })]
    })
  });
}
/**
 * Returns indexes of operations that should be highlighted. We check the diff of operations added but at the same time
 * we want to highlight operations only after the initial render, so we check for mounted state and calculate the diff
 * only after.
 * @param operations
 */

function useOperationsHighlight(operations) {
  const isMounted = (0,react_use__WEBPACK_IMPORTED_MODULE_7__["default"])();
  const prevOperations = (0,react_use__WEBPACK_IMPORTED_MODULE_8__["default"])(operations);

  if (!isMounted()) {
    return operations.map(() => false);
  }

  if (!prevOperations) {
    return operations.map(() => true);
  }

  let newOps = [];

  if (prevOperations.length - 1 === operations.length && operations.every(op => prevOperations.includes(op))) {
    // In case we remove one op and does not change any ops then don't highlight anything.
    return operations.map(() => false);
  }

  if (prevOperations.length + 1 === operations.length && prevOperations.every(op => operations.includes(op))) {
    // If we add a single op just find it and highlight just that.
    const newOp = operations.find(op => !prevOperations.includes(op));
    newOps = operations.map(op => {
      return op === newOp;
    });
  } else {
    // Default diff of all ops.
    newOps = operations.map((op, index) => {
      var _prevOperations$index;

      return !isSameOp(op.id, (_prevOperations$index = prevOperations[index]) === null || _prevOperations$index === void 0 ? void 0 : _prevOperations$index.id);
    });
  }

  return newOps;
}

function isSameOp(op1, op2) {
  return op1 === op2 || `__${op1}_by` === op2 || op1 === `__${op2}_by`;
}

const getStyles = theme => {
  return {
    heading: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'heading',
      fontSize: 12,
      fontWeight: theme.typography.fontWeightMedium,
      marginBottom: 0
    }),
    operationList: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'operationList',
      display: 'flex',
      flexWrap: 'wrap',
      gap: theme.spacing(2)
    }),
    addButton: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      label: 'addButton',
      width: 126,
      paddingBottom: theme.spacing(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationListExplained.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationListExplained": () => (/* binding */ OperationListExplained)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationExplainedBox.tsx");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");




function OperationListExplained({
  query,
  queryModeller,
  stepNumber
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
    children: query.operations.map((op, index) => {
      var _def$documentation;

      const def = queryModeller.getOperationDef(op.id);

      if (!def) {
        return `Operation ${op.id} not found`;
      }

      const title = def.renderer(op, def, '<expr>');
      const body = def.explainHandler ? def.explainHandler(op, def) : (_def$documentation = def.documentation) !== null && _def$documentation !== void 0 ? _def$documentation : 'no docs';
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_OperationExplainedBox__WEBPACK_IMPORTED_MODULE_1__.OperationExplainedBox, {
        stepNumber: index + stepNumber,
        title: title,
        markdown: body
      }, index);
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationParamEditor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOperationParamEditor": () => (/* binding */ getOperationParamEditor)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/AutoSizeInput.tsx");
/* harmony import */ var _operationUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");






function getOperationParamEditor(paramDef) {
  if (paramDef.editor) {
    return paramDef.editor;
  }

  if (paramDef.options) {
    return SelectInputParamEditor;
  }

  switch (paramDef.type) {
    case 'boolean':
      return BoolInputParamEditor;

    case 'number':
    case 'string':
    default:
      return SimpleInputParamEditor;
  }
}

function SimpleInputParamEditor(props) {
  var _props$value;

  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_AutoSizeInput__WEBPACK_IMPORTED_MODULE_3__.AutoSizeInput, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(props.operationIndex, props.index),
    defaultValue: (_props$value = props.value) === null || _props$value === void 0 ? void 0 : _props$value.toString(),
    minWidth: props.paramDef.minWidth,
    placeholder: props.paramDef.placeholder,
    title: props.paramDef.description,
    onCommitChange: evt => {
      props.onChange(props.index, evt.currentTarget.value);
    }
  });
}

function BoolInputParamEditor(props) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Checkbox, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(props.operationIndex, props.index),
    value: props.value,
    onChange: evt => props.onChange(props.index, evt.currentTarget.checked)
  });
}

function SelectInputParamEditor({
  paramDef,
  value,
  index,
  operationIndex,
  onChange
}) {
  var _selectOptions$, _selectOptions$find;

  let selectOptions = paramDef.options;

  if (!((_selectOptions$ = selectOptions[0]) !== null && _selectOptions$ !== void 0 && _selectOptions$.label)) {
    selectOptions = paramDef.options.map(option => ({
      label: option.toString(),
      value: option
    }));
  }

  let valueOption = (_selectOptions$find = selectOptions.find(x => x.value === value)) !== null && _selectOptions$find !== void 0 ? _selectOptions$find : (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.toOption)(value);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_1__.Select, {
    id: (0,_operationUtils__WEBPACK_IMPORTED_MODULE_4__.getOperationParamId)(operationIndex, index),
    menuShouldPortal: true,
    value: valueOption,
    options: selectOptions,
    placeholder: paramDef.placeholder,
    allowCustomValue: true,
    onChange: value => onChange(index, value.value)
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/OperationsEditorRow.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OperationsEditorRow": () => (/* binding */ OperationsEditorRow)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





function OperationsEditorRow({
  children
}) {
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    className: styles.root,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
      gap: 1,
      children: children
    })
  });
}

const getStyles = theme => {
  return {
    root: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      padding: theme.spacing(1, 1, 0, 1),
      backgroundColor: theme.colors.background.secondary,
      borderRadius: theme.shape.borderRadius(1)
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryEditorModeToggle.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorModeToggle": () => (/* binding */ QueryEditorModeToggle)
/* harmony export */ });
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");





const editorModes = [{
  label: 'Explain',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Explain
}, {
  label: 'Builder',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder,
  component: () => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.Tag, {
    className: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_2__.css)({
      fontSize: 10,
      padding: '1px 5px',
      verticalAlign: 'text-bottom'
    }),
    name: 'Beta',
    colorIndex: 1
  })
}, {
  label: 'Code',
  value: _types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code
}];
function QueryEditorModeToggle({
  mode,
  onChange
}) {
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    "data-testid": 'QueryEditorModeToggle',
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_0__.RadioButtonGroup, {
      options: editorModes,
      size: "sm",
      value: mode,
      onChange: onChange
    })
  });
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryHeaderSwitch.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryHeaderSwitch": () => (/* binding */ QueryHeaderSwitch)
/* harmony export */ });
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");
const _excluded = ["label"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








function QueryHeaderSwitch(_ref) {
  let {
    label
  } = _ref,
      inputProps = _objectWithoutPropertiesLoose(_ref, _excluded);

  const switchIdRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)((0,lodash__WEBPACK_IMPORTED_MODULE_3__.uniqueId)(`switch-${label}`));
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_1__.Stack, {
    gap: 1,
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("label", {
      htmlFor: switchIdRef.current,
      className: styles.switchLabel,
      children: label
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Switch, Object.assign({}, inputProps, {
      id: switchIdRef.current
    }))]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_0__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/QueryOptionGroup.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryOptionGroup": () => (/* binding */ QueryOptionGroup)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./.yarn/__virtual__/@emotion-css-virtual-72c314ddb1/0/cache/@emotion-css-npm-11.7.1-25ff8755a7-ac1f56656f.zip/node_modules/@emotion/css/dist/emotion-css.esm.js");
/* harmony import */ var _grafana_experimental__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/__virtual__/@grafana-experimental-virtual-920bad95a1/0/cache/@grafana-experimental-npm-0.0.2-canary.22-45d2c4f135-b9a64c0abc.zip/node_modules/@grafana/experimental/index.js");
/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/grafana-ui/src/index.ts");
/* harmony import */ var react_use__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useToggle.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-runtime.js");







function QueryOptionGroup({
  title,
  children,
  collapsedInfo
}) {
  const [isOpen, toggleOpen] = (0,react_use__WEBPACK_IMPORTED_MODULE_5__["default"])(false);
  const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.useStyles2)(getStyles);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_grafana_experimental__WEBPACK_IMPORTED_MODULE_2__.Stack, {
    gap: 0,
    direction: "column",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
      className: styles.header,
      onClick: toggleOpen,
      title: "Click to edit options",
      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.toggle,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_grafana_ui__WEBPACK_IMPORTED_MODULE_3__.Icon, {
          name: isOpen ? 'angle-down' : 'angle-right'
        })
      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("h6", {
        className: styles.title,
        children: title
      }), !isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
        className: styles.description,
        children: collapsedInfo.map((x, i) => /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("span", {
          children: x
        }, i))
      })]
    }), isOpen && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      className: styles.body,
      children: children
    })]
  });
}

const getStyles = theme => {
  return {
    switchLabel: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      color: theme.colors.text.secondary,
      cursor: 'pointer',
      fontSize: theme.typography.bodySmall.fontSize,
      '&:hover': {
        color: theme.colors.text.primary
      }
    }),
    header: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      display: 'flex',
      cursor: 'pointer',
      alignItems: 'baseline',
      color: theme.colors.text.primary,
      '&:hover': {
        background: theme.colors.emphasize(theme.colors.background.primary, 0.03)
      }
    }),
    title: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      flexGrow: 1,
      overflow: 'hidden',
      fontSize: theme.typography.bodySmall.fontSize,
      fontWeight: theme.typography.fontWeightMedium,
      margin: 0
    }),
    description: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      color: theme.colors.text.secondary,
      fontSize: theme.typography.bodySmall.fontSize,
      paddingLeft: theme.spacing(2),
      gap: theme.spacing(2),
      display: 'flex'
    }),
    body: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      display: 'flex',
      paddingTop: theme.spacing(2),
      gap: theme.spacing(2),
      flexWrap: 'wrap'
    }),
    toggle: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)({
      color: theme.colors.text.secondary,
      marginRight: `${theme.spacing(1)}`
    })
  };
};

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/operationUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAggregationOperation": () => (/* binding */ createAggregationOperation),
/* harmony export */   "createAggregationOperationWithParam": () => (/* binding */ createAggregationOperationWithParam),
/* harmony export */   "defaultAddOperationHandler": () => (/* binding */ defaultAddOperationHandler),
/* harmony export */   "functionRendererLeft": () => (/* binding */ functionRendererLeft),
/* harmony export */   "functionRendererRight": () => (/* binding */ functionRendererRight),
/* harmony export */   "getOperationParamId": () => (/* binding */ getOperationParamId),
/* harmony export */   "getPromAndLokiOperationDisplayName": () => (/* binding */ getPromAndLokiOperationDisplayName),
/* harmony export */   "getRangeVectorParamDef": () => (/* binding */ getRangeVectorParamDef),
/* harmony export */   "rangeRendererLeftWithParams": () => (/* binding */ rangeRendererLeftWithParams),
/* harmony export */   "rangeRendererRightWithParams": () => (/* binding */ rangeRendererRightWithParams)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/components/LabelParamEditor.tsx");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/types.ts");
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/pluralize-npm-8.0.0-f5f044ed52-08931d4a6a.zip/node_modules/pluralize/pluralize.js");
/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pluralize__WEBPACK_IMPORTED_MODULE_3__);




function functionRendererLeft(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.push(innerExpr);
  }

  return str + params.join(', ') + ')';
}
function functionRendererRight(model, def, innerExpr) {
  const params = renderParams(model, def, innerExpr);
  const str = model.id + '(';

  if (innerExpr) {
    params.unshift(innerExpr);
  }

  return str + params.join(', ') + ')';
}

function rangeRendererWithParams(model, def, innerExpr, renderLeft) {
  var _, _model$params;

  if (def.params.length < 2) {
    throw `Cannot render a function with params of length [${def.params.length}]`;
  }

  let rangeVector = (_ = ((_model$params = model.params) !== null && _model$params !== void 0 ? _model$params : [])[0]) !== null && _ !== void 0 ? _ : '5m'; // Next frame the remaining parameters, but get rid of the first one because it's used to move the
  // instant vector into a range vector.

  const params = renderParams(Object.assign({}, model, {
    params: model.params.slice(1)
  }), Object.assign({}, def, {
    params: def.params.slice(1),
    defaultParams: def.defaultParams.slice(1)
  }), innerExpr);
  const str = model.id + '('; // Depending on the renderLeft variable, render parameters to the left or right
  // renderLeft === true (renderLeft) => (param1, param2, rangeVector[...])
  // renderLeft === false (renderRight) => (rangeVector[...], param1, param2)

  if (innerExpr) {
    renderLeft ? params.push(`${innerExpr}[${rangeVector}]`) : params.unshift(`${innerExpr}[${rangeVector}]`);
  } // stick everything together


  return str + params.join(', ') + ')';
}

function rangeRendererRightWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, false);
}
function rangeRendererLeftWithParams(model, def, innerExpr) {
  return rangeRendererWithParams(model, def, innerExpr, true);
}

function renderParams(model, def, innerExpr) {
  var _model$params2;

  return ((_model$params2 = model.params) !== null && _model$params2 !== void 0 ? _model$params2 : []).map((value, index) => {
    const paramDef = def.params[index];

    if (paramDef.type === 'string') {
      return '"' + value + '"';
    }

    return value;
  });
}

function defaultAddOperationHandler(def, query) {
  const newOperation = {
    id: def.id,
    params: def.defaultParams
  };
  return Object.assign({}, query, {
    operations: [...query.operations, newOperation]
  });
}
function getPromAndLokiOperationDisplayName(funcName) {
  return (0,lodash__WEBPACK_IMPORTED_MODULE_0__.capitalize)(funcName.replace(/_/g, ' '));
}
function getOperationParamId(operationIndex, paramIndex) {
  return `operations.${operationIndex}.param.${paramIndex}`;
}
function getRangeVectorParamDef(withRateInterval = false) {
  const param = {
    name: 'Range',
    type: 'string',
    options: [{
      label: '$__interval',
      value: '$__interval' // tooltip: 'Dynamic interval based on max data points, scrape and min interval',

    }, {
      label: '1m',
      value: '1m'
    }, {
      label: '5m',
      value: '5m'
    }, {
      label: '10m',
      value: '10m'
    }, {
      label: '1h',
      value: '1h'
    }, {
      label: '24h',
      value: '24h'
    }]
  };

  if (withRateInterval) {
    param.options.unshift({
      label: '$__rate_interval',
      value: '$__rate_interval' // tooltip: 'Always above 4x scrape interval',

    });
  }

  return param;
}
/**
 * This function is shared between Prometheus and Loki variants
 */

function createAggregationOperation(name, overrides = {}) {
  const operations = [Object.assign({
    id: name,
    name: getPromAndLokiOperationDisplayName(name),
    params: [{
      name: 'By label',
      type: 'string',
      restParam: true,
      optional: true
    }],
    defaultParams: [],
    alternativesKey: 'plain aggregations',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Aggregations,
    renderer: functionRendererLeft,
    paramChangedHandler: getOnLabelAddedHandler(`__${name}_by`),
    explainHandler: getAggregationExplainer(name, ''),
    addOperationHandler: defaultAddOperationHandler
  }, overrides), Object.assign({
    id: `__${name}_by`,
    name: `${getPromAndLokiOperationDisplayName(name)} by`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationByRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'by'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides), Object.assign({
    id: `__${name}_without`,
    name: `${getPromAndLokiOperationDisplayName(name)} without`,
    params: [{
      name: 'Label',
      type: 'string',
      restParam: true,
      optional: true,
      editor: _components_LabelParamEditor__WEBPACK_IMPORTED_MODULE_1__.LabelParamEditor
    }],
    defaultParams: [''],
    alternativesKey: 'aggregations by',
    category: _types__WEBPACK_IMPORTED_MODULE_2__.PromVisualQueryOperationCategory.Aggregations,
    renderer: getAggregationWithoutRenderer(name),
    paramChangedHandler: getLastLabelRemovedHandler(name),
    explainHandler: getAggregationExplainer(name, 'without'),
    addOperationHandler: defaultAddOperationHandler,
    hideFromList: true
  }, overrides)];
  return operations;
}
function createAggregationOperationWithParam(name, paramsDef, overrides = {}) {
  const operations = createAggregationOperation(name, overrides);
  operations[0].params.unshift(...paramsDef.params);
  operations[1].params.unshift(...paramsDef.params);
  operations[2].params.unshift(...paramsDef.params);
  operations[0].defaultParams = paramsDef.defaultParams;
  operations[1].defaultParams = [...paramsDef.defaultParams, ''];
  operations[2].defaultParams = [...paramsDef.defaultParams, ''];
  operations[1].renderer = getAggregationByRendererWithParameter(name);
  operations[2].renderer = getAggregationByRendererWithParameter(name);
  return operations;
}

function getAggregationByRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} by(${model.params.join(', ')}) (${innerExpr})`;
  };
}

function getAggregationWithoutRenderer(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    return `${aggregation} without(${model.params.join(', ')}) (${innerExpr})`;
  };
}
/**
 * Very simple poc implementation, needs to be modified to support all aggregation operators
 */


function getAggregationExplainer(aggregationName, mode) {
  return function aggregationExplainer(model) {
    const labels = model.params.map(label => `\`${label}\``).join(' and ');
    const labelWord = pluralize__WEBPACK_IMPORTED_MODULE_3___default()('label', model.params.length);

    switch (mode) {
      case 'by':
        return `Calculates ${aggregationName} over dimensions while preserving ${labelWord} ${labels}.`;

      case 'without':
        return `Calculates ${aggregationName} over the dimensions ${labels}. All other labels are preserved.`;

      default:
        return `Calculates ${aggregationName} over the dimensions.`;
    }
  };
}

function getAggregationByRendererWithParameter(aggregation) {
  return function aggregationRenderer(model, def, innerExpr) {
    function mapType(p) {
      if (typeof p === 'string') {
        return `\"${p}\"`;
      }

      return p;
    }

    const params = model.params.slice(0, -1);
    const restParams = model.params.slice(1);
    return `${aggregation} by(${restParams.join(', ')}) (${params.map(mapType).join(', ')}, ${innerExpr})`;
  };
}
/**
 * This function will transform operations without labels to their plan aggregation operation
 */


function getLastLabelRemovedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // If definition has more params then is defined there are no optional rest params anymore.
    // We then transform this operation into a different one
    if (op.params.length < def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

function getOnLabelAddedHandler(changeToOperationId) {
  return function onParamChanged(index, op, def) {
    // Check if we actually have the label param. As it's optional the aggregation can have one less, which is the
    // case of just simple aggregation without label. When user adds the label it now has the same number of params
    // as it's definition, and now we can change it to it's `_by` variant.
    if (op.params.length === def.params.length) {
      return Object.assign({}, op, {
        id: changeToOperationId
      });
    }

    return op;
  };
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/parsingUtils.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorName": () => (/* binding */ ErrorName),
/* harmony export */   "getAllByType": () => (/* binding */ getAllByType),
/* harmony export */   "getLeftMostChild": () => (/* binding */ getLeftMostChild),
/* harmony export */   "getString": () => (/* binding */ getString),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "makeBinOp": () => (/* binding */ makeBinOp),
/* harmony export */   "makeError": () => (/* binding */ makeError),
/* harmony export */   "replaceVariables": () => (/* binding */ replaceVariables)
/* harmony export */ });
// This is used for error type for some reason
const ErrorName = '';
function getLeftMostChild(cur) {
  return cur.firstChild ? getLeftMostChild(cur.firstChild) : cur;
}
function makeError(expr, node) {
  var _node$parent;

  return {
    text: getString(expr, node),
    // TODO: this are positions in the string with the replaced variables. Means it cannot be used to show exact
    //  placement of the error for the user. We need some translation table to positions before the variable
    //  replace.
    from: node.from,
    to: node.to,
    parentType: (_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.name
  };
} // Taken from template_srv, but copied so to not mess with the regex.index which is manipulated in the service

/*
 * This regex matches 3 types of variable reference with an optional format specifier
 * \$(\w+)                          $var1
 * \[\[([\s\S]+?)(?::(\w+))?\]\]    [[var2]] or [[var2:fmt2]]
 * \${(\w+)(?::(\w+))?}             ${var3} or ${var3:fmt3}
 */

const variableRegex = /\$(\w+)|\[\[([\s\S]+?)(?::(\w+))?\]\]|\${(\w+)(?:\.([^:^\}]+))?(?::([^\}]+))?}/g;
/**
 * As variables with $ are creating parsing errors, we first replace them with magic string that is parsable and at
 * the same time we can get the variable and it's format back from it.
 * @param expr
 */

function replaceVariables(expr) {
  return expr.replace(variableRegex, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {
    const fmt = fmt2 || fmt3;
    let variable = var1;
    let varType = '0';

    if (var2) {
      variable = var2;
      varType = '1';
    }

    if (var3) {
      variable = var3;
      varType = '2';
    }

    return `__V_${varType}__` + variable + '__V__' + (fmt ? '__F__' + fmt + '__F__' : '');
  });
}
const varTypeFunc = [(v, f) => `\$${v}`, (v, f) => `[[${v}${f ? `:${f}` : ''}]]`, (v, f) => `\$\{${v}${f ? `:${f}` : ''}\}`];
/**
 * Get back the text with variables in their original format.
 * @param expr
 */

function returnVariables(expr) {
  return expr.replace(/__V_(\d)__(.+?)__V__(?:__F__(\w+)__F__)?/g, (match, type, v, f) => {
    return varTypeFunc[parseInt(type, 10)](v, f);
  });
}
/**
 * Get the actual string of the expression. That is not stored in the tree so we have to get the indexes from the node
 * and then based on that get it from the expression.
 * @param expr
 * @param node
 */


function getString(expr, node) {
  if (!node) {
    return '';
  }

  return returnVariables(expr.substring(node.from, node.to));
}
/**
 * Create simple scalar binary op object.
 * @param opDef - definition of the op to be created
 * @param expr
 * @param numberNode - the node for the scalar
 * @param hasBool - whether operation has a bool modifier. Is used only for ops for which it makes sense.
 */

function makeBinOp(opDef, expr, numberNode, hasBool) {
  const params = [parseFloat(getString(expr, numberNode))];

  if (opDef.comparison) {
    params.push(hasBool);
  }

  return {
    id: opDef.id,
    params
  };
}
/**
 * Get all nodes with type in the tree. This traverses the tree so it is safe only when you know there shouldn't be
 * too much nesting but you just want to skip some of the wrappers. For example getting function args this way would
 * not be safe is it would also find arguments of nested functions.
 * @param expr
 * @param cur
 * @param type
 */

function getAllByType(expr, cur, type) {
  if (cur.name === type) {
    return [getString(expr, cur)];
  }

  const values = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    values.push(...getAllByType(expr, child, type));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  return values;
} // Debugging function for convenience. Gives you nice output similar to linux tree util.
// @ts-ignore

function log(expr, cur) {
  if (!cur) {
    console.log('<empty>');
    return;
  }

  const json = toJson(expr, cur);
  const text = jsonToText(json);

  if (!text) {
    console.log('<empty>');
    return;
  }

  console.log(text);
}

function toJson(expr, cur) {
  const treeJson = {};
  const name = nodeToString(expr, cur);
  const children = [];
  let pos = 0;
  let child = cur.childAfter(pos);

  while (child) {
    children.push(toJson(expr, child));
    pos = child.to;
    child = cur.childAfter(pos);
  }

  treeJson.name = name;
  treeJson.children = children;
  return treeJson;
}

function jsonToText(node, context = {
  lastChild: true,
  indent: ''
}) {
  const name = node.name;
  const {
    lastChild,
    indent
  } = context;
  const newIndent = indent !== '' ? indent + (lastChild ? '' : '') : '';
  let text = newIndent + name;
  const children = node.children;
  children.forEach((child, index) => {
    const isLastChild = index === children.length - 1;
    text += '\n' + jsonToText(child, {
      lastChild: isLastChild,
      indent: indent + (lastChild ? '  ' : ' ')
    });
  });
  return text;
}

function nodeToString(expr, node) {
  return node.name + ': ' + getString(expr, node);
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueryEditorMode": () => (/* binding */ QueryEditorMode)
/* harmony export */ });
/**
 * Shared types that can be reused by Loki and other data sources
 */
let QueryEditorMode;

(function (QueryEditorMode) {
  QueryEditorMode["Code"] = "code";
  QueryEditorMode["Builder"] = "builder";
  QueryEditorMode["Explain"] = "explain";
})(QueryEditorMode || (QueryEditorMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/state.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "changeEditorMode": () => (/* binding */ changeEditorMode),
/* harmony export */   "getQueryWithDefaults": () => (/* binding */ getQueryWithDefaults)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var app_core_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./public/app/core/store.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/plugins/datasource/prometheus/querybuilder/shared/types.ts");




const queryEditorModeDefaultLocalStorageKey = 'PrometheusQueryEditorModeDefault';
function changeEditorMode(query, editorMode, onChange) {
  // If empty query store new mode as default
  if (query.expr === '') {
    app_core_store__WEBPACK_IMPORTED_MODULE_1__["default"].set(queryEditorModeDefaultLocalStorageKey, editorMode);
  }

  onChange(Object.assign({}, query, {
    editorMode
  }));
} // @ts-ignore Will be used after builder is out of beta

function getDefaultEditorMode(expr) {
  // If we already have an expression default to code view
  if (expr != null && expr !== '') {
    return _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code;
  }

  const value = app_core_store__WEBPACK_IMPORTED_MODULE_1__["default"].get(queryEditorModeDefaultLocalStorageKey);

  switch (value) {
    case _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder:
    case _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code:
    case _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Explain:
      return value;

    default:
      return _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Builder;
  }
}
/**
 * Returns query with defaults, and boolean true/false depending on change was required
 */


function getQueryWithDefaults(query, app) {
  let result = query;

  if (!query.editorMode) {
    // Default to Code mode until we are out of beta with the builder, then use getDefaultEditorMode.
    result = Object.assign({}, query, {
      editorMode: _shared_types__WEBPACK_IMPORTED_MODULE_3__.QueryEditorMode.Code
    });
  }

  if (query.expr == null) {
    result = Object.assign({}, result, {
      expr: '',
      legendFormat: _types__WEBPACK_IMPORTED_MODULE_2__.LegendFormatMode.Auto
    });
  }

  if (query.range == null && query.instant == null) {
    // Default to range query
    result = Object.assign({}, result, {
      range: true
    }); // In explore we default to both instant & range

    if (app === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.CoreApp.Explore) {
      result.instant = true;
    }
  }

  return result;
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/querybuilder/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PromOperationId": () => (/* binding */ PromOperationId),
/* harmony export */   "PromVisualQueryOperationCategory": () => (/* binding */ PromVisualQueryOperationCategory)
/* harmony export */ });
/**
 * Visual query model
 */
let PromVisualQueryOperationCategory;

(function (PromVisualQueryOperationCategory) {
  PromVisualQueryOperationCategory["Aggregations"] = "Aggregations";
  PromVisualQueryOperationCategory["RangeFunctions"] = "Range functions";
  PromVisualQueryOperationCategory["Functions"] = "Functions";
  PromVisualQueryOperationCategory["BinaryOps"] = "Binary operations";
  PromVisualQueryOperationCategory["Trigonometric"] = "Trigonometric";
  PromVisualQueryOperationCategory["Time"] = "Time Functions";
})(PromVisualQueryOperationCategory || (PromVisualQueryOperationCategory = {}));

let PromOperationId;

(function (PromOperationId) {
  PromOperationId["Abs"] = "abs";
  PromOperationId["Absent"] = "absent";
  PromOperationId["AbsentOverTime"] = "absent_over_time";
  PromOperationId["Acos"] = "acos";
  PromOperationId["Acosh"] = "acosh";
  PromOperationId["Asin"] = "asin";
  PromOperationId["Asinh"] = "asinh";
  PromOperationId["Atan"] = "atan";
  PromOperationId["Atanh"] = "atanh";
  PromOperationId["Avg"] = "avg";
  PromOperationId["AvgOverTime"] = "avg_over_time";
  PromOperationId["BottomK"] = "bottomk";
  PromOperationId["Ceil"] = "ceil";
  PromOperationId["Changes"] = "changes";
  PromOperationId["Clamp"] = "clamp";
  PromOperationId["ClampMax"] = "clamp_max";
  PromOperationId["ClampMin"] = "clamp_min";
  PromOperationId["Cos"] = "cos";
  PromOperationId["Cosh"] = "cosh";
  PromOperationId["Count"] = "count";
  PromOperationId["CountOverTime"] = "count_over_time";
  PromOperationId["CountScalar"] = "count_scalar";
  PromOperationId["CountValues"] = "count_values";
  PromOperationId["DayOfMonth"] = "day_of_month";
  PromOperationId["DayOfWeek"] = "day_of_week";
  PromOperationId["DaysInMonth"] = "days_in_month";
  PromOperationId["Deg"] = "deg";
  PromOperationId["Delta"] = "delta";
  PromOperationId["Deriv"] = "deriv";
  PromOperationId["DropCommonLabels"] = "drop_common_labels";
  PromOperationId["Exp"] = "exp";
  PromOperationId["Floor"] = "floor";
  PromOperationId["Group"] = "group";
  PromOperationId["HistogramQuantile"] = "histogram_quantile";
  PromOperationId["HoltWinters"] = "holt_winters";
  PromOperationId["Hour"] = "hour";
  PromOperationId["Idelta"] = "idelta";
  PromOperationId["Increase"] = "increase";
  PromOperationId["Irate"] = "irate";
  PromOperationId["LabelJoin"] = "label_join";
  PromOperationId["LabelReplace"] = "label_replace";
  PromOperationId["Last"] = "last";
  PromOperationId["LastOverTime"] = "last_over_time";
  PromOperationId["Ln"] = "ln";
  PromOperationId["Log10"] = "log10";
  PromOperationId["Log2"] = "log2";
  PromOperationId["Max"] = "max";
  PromOperationId["MaxOverTime"] = "max_over_time";
  PromOperationId["Min"] = "min";
  PromOperationId["MinOverTime"] = "min_over_time";
  PromOperationId["Minute"] = "minute";
  PromOperationId["Month"] = "month";
  PromOperationId["Pi"] = "pi";
  PromOperationId["PredictLinear"] = "predict_linear";
  PromOperationId["Present"] = "present";
  PromOperationId["PresentOverTime"] = "present_over_time";
  PromOperationId["Quantile"] = "quantile";
  PromOperationId["QuantileOverTime"] = "quantile_over_time";
  PromOperationId["Rad"] = "rad";
  PromOperationId["Rate"] = "rate";
  PromOperationId["Resets"] = "resets";
  PromOperationId["Round"] = "round";
  PromOperationId["Scalar"] = "scalar";
  PromOperationId["Sgn"] = "sgn";
  PromOperationId["Sin"] = "sin";
  PromOperationId["Sinh"] = "sinh";
  PromOperationId["Sort"] = "sort";
  PromOperationId["SortDesc"] = "sort_desc";
  PromOperationId["Sqrt"] = "sqrt";
  PromOperationId["Stddev"] = "stddev";
  PromOperationId["StddevOverTime"] = "stddev_over_time";
  PromOperationId["Sum"] = "sum";
  PromOperationId["SumOverTime"] = "sum_over_time";
  PromOperationId["Tan"] = "tan";
  PromOperationId["Tanh"] = "tanh";
  PromOperationId["Time"] = "time";
  PromOperationId["Timestamp"] = "timestamp";
  PromOperationId["TopK"] = "topk";
  PromOperationId["Vector"] = "vector";
  PromOperationId["Year"] = "year";
  PromOperationId["Addition"] = "__addition";
  PromOperationId["Subtraction"] = "__subtraction";
  PromOperationId["MultiplyBy"] = "__multiply_by";
  PromOperationId["DivideBy"] = "__divide_by";
  PromOperationId["Modulo"] = "__modulo";
  PromOperationId["Exponent"] = "__exponent";
  PromOperationId["NestedQuery"] = "__nested_query";
  PromOperationId["EqualTo"] = "__equal_to";
  PromOperationId["NotEqualTo"] = "__not_equal_to";
  PromOperationId["GreaterThan"] = "__greater_than";
  PromOperationId["LessThan"] = "__less_than";
  PromOperationId["GreaterOrEqual"] = "__greater_or_equal";
  PromOperationId["LessOrEqual"] = "__less_or_equal";
})(PromOperationId || (PromOperationId = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/result_transformer.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOriginalMetricName": () => (/* binding */ getOriginalMetricName),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformDFToTable": () => (/* binding */ transformDFToTable),
/* harmony export */   "transformV2": () => (/* binding */ transformV2)
/* harmony export */ });
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./.yarn/cache/lodash-npm-4.17.21-6382451519-eb835a2e51.zip/node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./.yarn/cache/d3-npm-5.15.0-0c7696026f-7342d82e55.zip/node_modules/d3/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./public/app/plugins/datasource/prometheus/types.ts");
/* harmony import */ var _legend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./public/app/plugins/datasource/prometheus/legend.ts");
const _excluded = ["__name__"];

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







const POSITIVE_INFINITY_SAMPLE_VALUE = '+Inf';
const NEGATIVE_INFINITY_SAMPLE_VALUE = '-Inf';

const isTableResult = (dataFrame, options) => {
  var _dataFrame$meta, _dataFrame$meta$custo, _dataFrame$meta2, _dataFrame$meta2$cust;

  // We want to process vector and scalar results in Explore as table
  if (options.app === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.CoreApp.Explore && (((_dataFrame$meta = dataFrame.meta) === null || _dataFrame$meta === void 0 ? void 0 : (_dataFrame$meta$custo = _dataFrame$meta.custom) === null || _dataFrame$meta$custo === void 0 ? void 0 : _dataFrame$meta$custo.resultType) === 'vector' || ((_dataFrame$meta2 = dataFrame.meta) === null || _dataFrame$meta2 === void 0 ? void 0 : (_dataFrame$meta2$cust = _dataFrame$meta2.custom) === null || _dataFrame$meta2$cust === void 0 ? void 0 : _dataFrame$meta2$cust.resultType) === 'scalar')) {
    return true;
  } // We want to process all dataFrames with target.format === 'table' as table


  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'table';
};

const isHeatmapResult = (dataFrame, options) => {
  const target = options.targets.find(target => target.refId === dataFrame.refId);
  return (target === null || target === void 0 ? void 0 : target.format) === 'heatmap';
}; // V2 result trasnformer used to transform query results from queries that were run trough prometheus backend


function transformV2(response, request, options) {
  const [tableFrames, framesWithoutTable] = (0,lodash__WEBPACK_IMPORTED_MODULE_2__.partition)(response.data, df => isTableResult(df, request));
  const processedTableFrames = transformDFToTable(tableFrames);
  const [exemplarFrames, framesWithoutTableAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_2__.partition)(framesWithoutTable, df => {
    var _df$meta, _df$meta$custom;

    return ((_df$meta = df.meta) === null || _df$meta === void 0 ? void 0 : (_df$meta$custom = _df$meta.custom) === null || _df$meta$custom === void 0 ? void 0 : _df$meta$custom.resultType) === 'exemplar';
  }); // EXEMPLAR FRAMES: We enrich exemplar frames with data links and add dataTopic meta info

  const {
    exemplarTraceIdDestinations: destinations
  } = options;
  const processedExemplarFrames = exemplarFrames.map(dataFrame => {
    if (destinations !== null && destinations !== void 0 && destinations.length) {
      for (const exemplarTraceIdDestination of destinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$ = traceIDField.config.links) !== null && _traceIDField$config$ !== void 0 && _traceIDField$config$.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataTopic.Annotations
      })
    });
  });
  const [heatmapResults, framesWithoutTableHeatmapsAndExemplars] = (0,lodash__WEBPACK_IMPORTED_MODULE_2__.partition)(framesWithoutTableAndExemplars, df => isHeatmapResult(df, request));
  const processedHeatmapFrames = mergeHeatmapFrames(transformToHistogramOverTime(heatmapResults.sort(sortSeriesByLabel))); // Everything else is processed as time_series result and graph preferredVisualisationType

  const otherFrames = framesWithoutTableHeatmapsAndExemplars.map(dataFrame => {
    const df = Object.assign({}, dataFrame, {
      meta: Object.assign({}, dataFrame.meta, {
        preferredVisualisationType: 'graph'
      })
    });
    return df;
  });
  return Object.assign({}, response, {
    data: [...otherFrames, ...processedTableFrames, ...processedHeatmapFrames, ...processedExemplarFrames]
  });
}
function transformDFToTable(dfs) {
  // If no dataFrames or if 1 dataFrames with no values, return original dataFrame
  if (dfs.length === 0 || dfs.length === 1 && dfs[0].length === 0) {
    return dfs;
  } // Group results by refId and process dataFrames with the same refId as 1 dataFrame


  const dataFramesByRefId = (0,lodash__WEBPACK_IMPORTED_MODULE_2__.groupBy)(dfs, 'refId');
  const refIds = Object.keys(dataFramesByRefId);
  const frames = refIds.map(refId => {
    // Create timeField, valueField and labelFields
    const valueText = getValueText(refIds.length, refId);
    const valueField = getValueField({
      data: [],
      valueName: valueText
    });
    const timeField = getTimeField([]);
    const labelFields = []; // Fill labelsFields with labels from dataFrames

    dataFramesByRefId[refId].forEach(df => {
      var _frameValueField$labe;

      const frameValueField = df.fields[1];
      const promLabels = (_frameValueField$labe = frameValueField.labels) !== null && _frameValueField$labe !== void 0 ? _frameValueField$labe : {};
      Object.keys(promLabels).sort().forEach(label => {
        // If we don't have label in labelFields, add it
        if (!labelFields.some(l => l.name === label)) {
          const numberField = label === 'le';
          labelFields.push({
            name: label,
            config: {
              filterable: true
            },
            type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string,
            values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector()
          });
        }
      });
    }); // Fill valueField, timeField and labelFields with values

    dataFramesByRefId[refId].forEach(df => {
      df.fields[0].values.toArray().forEach(value => timeField.values.add(value));
      df.fields[1].values.toArray().forEach(value => {
        var _df$fields$1$labels;

        valueField.values.add(parseSampleValue(value));
        const labelsForField = (_df$fields$1$labels = df.fields[1].labels) !== null && _df$fields$1$labels !== void 0 ? _df$fields$1$labels : {};
        labelFields.forEach(field => field.values.add(getLabelValue(labelsForField, field.name)));
      });
    });
    const fields = [timeField, ...labelFields, valueField];
    return {
      refId,
      fields,
      meta: Object.assign({}, dfs[0].meta, {
        preferredVisualisationType: 'table'
      }),
      length: timeField.values.length
    };
  });
  return frames;
}

function getValueText(responseLength, refId = '') {
  return responseLength > 1 ? `Value #${refId}` : 'Value';
}

function transform(response, transformOptions) {
  // Create options object from transformOptions
  const options = {
    format: transformOptions.target.format,
    step: transformOptions.query.step,
    legendFormat: transformOptions.target.legendFormat,
    start: transformOptions.query.start,
    end: transformOptions.query.end,
    query: transformOptions.query.expr,
    responseListLength: transformOptions.responseListLength,
    scopedVars: transformOptions.scopedVars,
    refId: transformOptions.target.refId,
    valueWithRefId: transformOptions.target.valueWithRefId,
    meta: {
      // Fix for showing of Prometheus results in Explore table
      preferredVisualisationType: transformOptions.query.instant ? 'table' : 'graph'
    }
  };
  const prometheusResult = response.data.data;

  if ((0,_types__WEBPACK_IMPORTED_MODULE_4__.isExemplarData)(prometheusResult)) {
    var _transformOptions$exe;

    const events = [];
    prometheusResult.forEach(exemplarData => {
      const data = exemplarData.exemplars.map(exemplar => {
        return Object.assign({
          [_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_TIME_FIELD_NAME]: exemplar.timestamp * 1000,
          [_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME]: exemplar.value
        }, exemplar.labels, exemplarData.seriesLabels);
      });
      events.push(...data);
    }); // Grouping exemplars by step

    const sampledExemplars = sampleExemplars(events, options);
    const dataFrame = new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayDataFrame(sampledExemplars);
    dataFrame.meta = {
      dataTopic: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataTopic.Annotations
    }; // Add data links if configured

    if ((_transformOptions$exe = transformOptions.exemplarTraceIdDestinations) !== null && _transformOptions$exe !== void 0 && _transformOptions$exe.length) {
      for (const exemplarTraceIdDestination of transformOptions.exemplarTraceIdDestinations) {
        const traceIDField = dataFrame.fields.find(field => field.name === exemplarTraceIdDestination.name);

        if (traceIDField) {
          var _traceIDField$config$2;

          const links = getDataLinks(exemplarTraceIdDestination);
          traceIDField.config.links = (_traceIDField$config$2 = traceIDField.config.links) !== null && _traceIDField$config$2 !== void 0 && _traceIDField$config$2.length ? [...traceIDField.config.links, ...links] : links;
        }
      }
    }

    return [dataFrame];
  }

  if (!(prometheusResult !== null && prometheusResult !== void 0 && prometheusResult.result)) {
    return [];
  } // Return early if result type is scalar


  if (prometheusResult.resultType === 'scalar') {
    return [{
      meta: options.meta,
      refId: options.refId,
      length: 1,
      fields: [getTimeField([prometheusResult.result]), getValueField({
        data: [prometheusResult.result]
      })]
    }];
  } // Return early again if the format is table, this needs special transformation.


  if (options.format === 'table') {
    const tableData = transformMetricDataToTable(prometheusResult.result, options);
    return [tableData];
  } // Process matrix and vector results to DataFrame


  const dataFrame = [];
  prometheusResult.result.forEach(data => dataFrame.push(transformToDataFrame(data, options))); // When format is heatmap use the already created data frames and transform it more

  if (options.format === 'heatmap') {
    return mergeHeatmapFrames(transformToHistogramOverTime(dataFrame.sort(sortSeriesByLabel)));
  } // Return matrix or vector result as DataFrame[]


  return dataFrame;
}

function getDataLinks(options) {
  const dataLinks = [];

  if (options.datasourceUid) {
    var _dsSettings$name;

    const dataSourceSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getDataSourceSrv)();
    const dsSettings = dataSourceSrv.getInstanceSettings(options.datasourceUid);
    dataLinks.push({
      title: options.urlDisplayLabel || `Query with ${dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name}`,
      url: '',
      internal: {
        query: {
          query: '${__value.raw}',
          queryType: 'traceId'
        },
        datasourceUid: options.datasourceUid,
        datasourceName: (_dsSettings$name = dsSettings === null || dsSettings === void 0 ? void 0 : dsSettings.name) !== null && _dsSettings$name !== void 0 ? _dsSettings$name : 'Data source not found'
      }
    });
  }

  if (options.url) {
    dataLinks.push({
      title: options.urlDisplayLabel || `Go to ${options.url}`,
      url: options.url,
      targetBlank: true
    });
  }

  return dataLinks;
}
/**
 * Reduce the density of the exemplars by making sure that the highest value exemplar is included
 * and then only the ones that are 2 times the standard deviation of the all the values.
 * This makes sure not to show too many dots near each other.
 */


function sampleExemplars(events, options) {
  const step = options.step || 15;
  const bucketedExemplars = {};
  const values = [];

  for (const exemplar of events) {
    // Align exemplar timestamp to nearest step second
    const alignedTs = String(Math.floor(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_TIME_FIELD_NAME] / 1000 / step) * step * 1000);

    if (!bucketedExemplars[alignedTs]) {
      // New bucket found
      bucketedExemplars[alignedTs] = [];
    }

    bucketedExemplars[alignedTs].push(exemplar);
    values.push(exemplar[_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME]);
  } // Getting exemplars from each bucket


  const standardDeviation = (0,d3__WEBPACK_IMPORTED_MODULE_3__.deviation)(values);
  const sampledBuckets = Object.keys(bucketedExemplars).sort();
  const sampledExemplars = [];

  for (const ts of sampledBuckets) {
    const exemplarsInBucket = bucketedExemplars[ts];

    if (exemplarsInBucket.length === 1) {
      sampledExemplars.push(exemplarsInBucket[0]);
    } else {
      // Choose which values to sample
      const bucketValues = exemplarsInBucket.map(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME]).sort(d3__WEBPACK_IMPORTED_MODULE_3__.descending);
      const sampledBucketValues = bucketValues.reduce((acc, curr) => {
        if (acc.length === 0) {
          // First value is max and is always added
          acc.push(curr);
        } else {
          // Then take values only when at least 2 standard deviation distance to previously taken value
          const prev = acc[acc.length - 1];

          if (standardDeviation && prev - curr >= 2 * standardDeviation) {
            acc.push(curr);
          }
        }

        return acc;
      }, []); // Find the exemplars for the sampled values

      sampledExemplars.push(...sampledBucketValues.map(value => exemplarsInBucket.find(ex => ex[_grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME] === value)));
    }
  }

  return sampledExemplars;
}
/**
 * Transforms matrix and vector result from Prometheus result to DataFrame
 */


function transformToDataFrame(data, options) {
  const {
    name,
    labels
  } = createLabelInfo(data.metric, options);
  const fields = [];

  if ((0,_types__WEBPACK_IMPORTED_MODULE_4__.isMatrixData)(data)) {
    const stepMs = options.step ? options.step * 1000 : NaN;
    let baseTimestamp = options.start * 1000;
    const dps = [];

    for (const value of data.values) {
      let dpValue = parseSampleValue(value[1]);

      if (isNaN(dpValue)) {
        dpValue = null;
      }

      const timestamp = value[0] * 1000;

      for (let t = baseTimestamp; t < timestamp; t += stepMs) {
        dps.push([t, null]);
      }

      baseTimestamp = timestamp + stepMs;
      dps.push([timestamp, dpValue]);
    }

    const endTimestamp = options.end * 1000;

    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {
      dps.push([t, null]);
    }

    fields.push(getTimeField(dps, true));
    fields.push(getValueField({
      data: dps,
      parseValue: false,
      labels,
      displayNameFromDS: name
    }));
  } else {
    fields.push(getTimeField([data.value]));
    fields.push(getValueField({
      data: [data.value],
      labels,
      displayNameFromDS: name
    }));
  }

  return {
    meta: options.meta,
    refId: options.refId,
    length: fields[0].values.length,
    fields,
    name
  };
}

function transformMetricDataToTable(md, options) {
  if (!md || md.length === 0) {
    return {
      meta: options.meta,
      refId: options.refId,
      length: 0,
      fields: []
    };
  }

  const valueText = options.responseListLength > 1 || options.valueWithRefId ? `Value #${options.refId}` : 'Value';
  const timeField = getTimeField([]);
  const metricFields = Object.keys(md.reduce((acc, series) => Object.assign({}, acc, series.metric), {})).sort().map(label => {
    // Labels have string field type, otherwise table tries to figure out the type which can result in unexpected results
    // Only "le" label has a number field type
    const numberField = label === 'le';
    return {
      name: label,
      config: {
        filterable: true
      },
      type: numberField ? _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number : _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.string,
      values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector()
    };
  });
  const valueField = getValueField({
    data: [],
    valueName: valueText
  });
  md.forEach(d => {
    if ((0,_types__WEBPACK_IMPORTED_MODULE_4__.isMatrixData)(d)) {
      d.values.forEach(val => {
        timeField.values.add(val[0] * 1000);
        metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
        valueField.values.add(parseSampleValue(val[1]));
      });
    } else {
      timeField.values.add(d.value[0] * 1000);
      metricFields.forEach(metricField => metricField.values.add(getLabelValue(d.metric, metricField.name)));
      valueField.values.add(parseSampleValue(d.value[1]));
    }
  });
  return {
    meta: options.meta,
    refId: options.refId,
    length: timeField.values.length,
    fields: [timeField, ...metricFields, valueField]
  };
}

function getLabelValue(metric, label) {
  if (metric.hasOwnProperty(label)) {
    if (label === 'le') {
      return parseSampleValue(metric[label]);
    }

    return metric[label];
  }

  return '';
}

function getTimeField(data, isMs = false) {
  return {
    name: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_TIME_FIELD_NAME,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time,
    config: {},
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector(data.map(val => isMs ? val[0] : val[0] * 1000))
  };
}

function getValueField({
  data,
  valueName = _grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME,
  parseValue = true,
  labels,
  displayNameFromDS
}) {
  return {
    name: valueName,
    type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number,
    display: (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.getDisplayProcessor)(),
    config: {
      displayNameFromDS
    },
    labels,
    values: new _grafana_data__WEBPACK_IMPORTED_MODULE_0__.ArrayVector(data.map(val => parseValue ? parseSampleValue(val[1]) : val[1]))
  };
}

function createLabelInfo(labels, options) {
  if (options !== null && options !== void 0 && options.legendFormat) {
    const title = (0,_legend__WEBPACK_IMPORTED_MODULE_5__.renderLegendFormat)((0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getTemplateSrv)().replace(options.legendFormat, options === null || options === void 0 ? void 0 : options.scopedVars), labels);
    return {
      name: title,
      labels
    };
  }

  const {
    __name__
  } = labels,
        labelsWithoutName = _objectWithoutPropertiesLoose(labels, _excluded);

  const labelPart = (0,_grafana_data__WEBPACK_IMPORTED_MODULE_0__.formatLabels)(labelsWithoutName);
  let title = `${__name__ !== null && __name__ !== void 0 ? __name__ : ''}${labelPart}`;

  if (!title) {
    title = options.query;
  }

  return {
    name: title,
    labels: labelsWithoutName
  };
}

function getOriginalMetricName(labelData) {
  const metricName = labelData.__name__ || '';
  delete labelData.__name__;
  const labelPart = Object.entries(labelData).map(label => `${label[0]}="${label[1]}"`).join(',');
  return `${metricName}{${labelPart}}`;
}

function mergeHeatmapFrames(frames) {
  if (frames.length === 0) {
    return [];
  }

  const timeField = frames[0].fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.time);
  const countFields = frames.map(frame => {
    let field = frame.fields.find(field => field.type === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.FieldType.number);
    return Object.assign({}, field, {
      name: field.config.displayNameFromDS
    });
  });
  return [Object.assign({}, frames[0], {
    meta: Object.assign({}, frames[0].meta, {
      type: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.DataFrameType.HeatmapBuckets
    }),
    fields: [timeField, ...countFields]
  })];
}

function transformToHistogramOverTime(seriesList) {
  /*      t1 = timestamp1, t2 = timestamp2 etc.
            t1  t2  t3          t1  t2  t3
    le10    10  10  0     =>    10  10  0
    le20    20  10  30    =>    10  0   30
    le30    30  10  35    =>    10  0   5
    */
  for (let i = seriesList.length - 1; i > 0; i--) {
    const topSeries = seriesList[i].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME);
    const bottomSeries = seriesList[i - 1].fields.find(s => s.name === _grafana_data__WEBPACK_IMPORTED_MODULE_0__.TIME_SERIES_VALUE_FIELD_NAME);

    if (!topSeries || !bottomSeries) {
      throw new Error('Prometheus heatmap transform error: data should be a time series');
    }

    for (let j = 0; j < topSeries.values.length; j++) {
      const bottomPoint = bottomSeries.values.get(j) || [0];
      topSeries.values.toArray()[j] -= bottomPoint;
    }
  }

  return seriesList;
}

function sortSeriesByLabel(s1, s2) {
  let le1, le2;

  try {
    var _s1$name, _s2$name;

    // fail if not integer. might happen with bad queries
    le1 = parseSampleValue((_s1$name = s1.name) !== null && _s1$name !== void 0 ? _s1$name : '');
    le2 = parseSampleValue((_s2$name = s2.name) !== null && _s2$name !== void 0 ? _s2$name : '');
  } catch (err) {
    console.error(err);
    return 0;
  }

  if (le1 > le2) {
    return 1;
  }

  if (le1 < le2) {
    return -1;
  }

  return 0;
}

function parseSampleValue(value) {
  switch (value) {
    case POSITIVE_INFINITY_SAMPLE_VALUE:
      return Number.POSITIVE_INFINITY;

    case NEGATIVE_INFINITY_SAMPLE_VALUE:
      return Number.NEGATIVE_INFINITY;

    default:
      return parseFloat(value);
  }
}

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegendFormatMode": () => (/* binding */ LegendFormatMode),
/* harmony export */   "PromQueryType": () => (/* binding */ PromQueryType),
/* harmony export */   "isExemplarData": () => (/* binding */ isExemplarData),
/* harmony export */   "isMatrixData": () => (/* binding */ isMatrixData)
/* harmony export */ });
let PromQueryType;

(function (PromQueryType) {
  PromQueryType["timeSeriesQuery"] = "timeSeriesQuery";
})(PromQueryType || (PromQueryType = {}));

function isMatrixData(result) {
  return 'values' in result;
}
function isExemplarData(result) {
  if (result == null || !Array.isArray(result)) {
    return false;
  }

  return result.length ? 'exemplars' in result[0] : false;
}

/**
 * Auto = query.legendFormat == '__auto'
 * Verbose = query.legendFormat == null/undefined/''
 * Custom query.legendFormat.length > 0 && query.legendFormat !== '__auto'
 */
let LegendFormatMode;

(function (LegendFormatMode) {
  LegendFormatMode["Auto"] = "__auto";
  LegendFormatMode["Verbose"] = "__verbose";
  LegendFormatMode["Custom"] = "__custom";
})(LegendFormatMode || (LegendFormatMode = {}));

/***/ }),

/***/ "./public/app/plugins/datasource/prometheus/variables.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrometheusVariableSupport": () => (/* binding */ PrometheusVariableSupport)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/of.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/observable/from.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./.yarn/cache/rxjs-npm-7.5.5-d0546b1ccb-e034f60805.zip/node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var _grafana_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/grafana-data/src/index.ts");
/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/grafana-runtime/src/index.ts");
/* harmony import */ var _metric_find_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./public/app/plugins/datasource/prometheus/metric_find_query.ts");
/* harmony import */ var _features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./public/app/features/dashboard/services/TimeSrv.ts");






class PrometheusVariableSupport extends _grafana_data__WEBPACK_IMPORTED_MODULE_0__.StandardVariableSupport {
  constructor(datasource, templateSrv = (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_1__.getTemplateSrv)(), timeSrv = (0,_features_dashboard_services_TimeSrv__WEBPACK_IMPORTED_MODULE_3__.getTimeSrv)()) {
    super();
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.datasource = datasource;
    this.templateSrv = templateSrv;
    this.timeSrv = timeSrv;
    this.query = this.query.bind(this);
  }

  query(request) {
    const query = request.targets[0].expr;

    if (!query) {
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.of)({
        data: []
      });
    }

    const scopedVars = Object.assign({}, request.scopedVars, {
      __interval: {
        text: this.datasource.interval,
        value: this.datasource.interval
      },
      __interval_ms: {
        text: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval),
        value: _grafana_data__WEBPACK_IMPORTED_MODULE_0__.rangeUtil.intervalToMs(this.datasource.interval)
      }
    }, this.datasource.getRangeScopedVars(this.timeSrv.timeRange()));
    const interpolated = this.templateSrv.replace(query, scopedVars, this.datasource.interpolateQueryExpr);
    const metricFindQuery = new _metric_find_query__WEBPACK_IMPORTED_MODULE_2__["default"](this.datasource, interpolated);
    const metricFindStream = (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(metricFindQuery.process());
    return metricFindStream.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(results => ({
      data: results
    })));
  }

  toDataQuery(query) {
    return {
      refId: 'PrometheusDatasource-VariableQuery',
      expr: query.query
    };
  }

}

/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/usePrevious.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

function usePrevious(state) {
    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
        ref.current = state;
    });
    return ref.current;
}


/***/ }),

/***/ "./.yarn/__virtual__/react-use-virtual-00326e70ba/0/cache/react-use-npm-17.3.2-a032cbeb01-7379460f51.zip/node_modules/react-use/esm/useToggle.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

var toggleReducer = function (state, nextValue) {
    return typeof nextValue === 'boolean' ? nextValue : !state;
};
var useToggle = function (initialValue) {
    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(toggleReducer, initialValue);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useToggle);


/***/ }),

/***/ "./.yarn/cache/lru-cache-npm-7.7.1-726274dc4d-f362c5a2cf.zip/node_modules/lru-cache/index.js":
/***/ ((module) => {

const perf = typeof performance === 'object' && performance &&
  typeof performance.now === 'function' ? performance : Date

const hasAbortController = typeof AbortController !== 'undefined'

/* istanbul ignore next - minimal backwards compatibility polyfill */
const AC = hasAbortController ? AbortController : Object.assign(
  class AbortController {
    constructor () { this.signal = new AC.AbortSignal }
    abort () { this.signal.aborted = true }
  },
  { AbortSignal: class AbortSignal { constructor () { this.aborted = false }}}
)

const warned = new Set()
const deprecatedOption = (opt, instead) => {
  const code = `LRU_CACHE_OPTION_${opt}`
  if (shouldWarn(code)) {
    warn(code, `${opt} option`, `options.${instead}`, LRUCache)
  }
}
const deprecatedMethod = (method, instead) => {
  const code = `LRU_CACHE_METHOD_${method}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, method)
    warn(code, `${method} method`, `cache.${instead}()`, get)
  }
}
const deprecatedProperty = (field, instead) => {
  const code = `LRU_CACHE_PROPERTY_${field}`
  if (shouldWarn(code)) {
    const { prototype } = LRUCache
    const { get } = Object.getOwnPropertyDescriptor(prototype, field)
    warn(code, `${field} property`, `cache.${instead}`, get)
  }
}

const shouldWarn = code => typeof process === 'object' &&
  process &&
  !warned.has(code)

const warn = (code, what, instead, fn) => {
  warned.add(code)
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`
  process.emitWarning(msg, 'DeprecationWarning', code, fn)
}

const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)

/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */
const getUintArray = max => !isPosInt(max) ? null
: max <= Math.pow(2, 8) ? Uint8Array
: max <= Math.pow(2, 16) ? Uint16Array
: max <= Math.pow(2, 32) ? Uint32Array
: max <= Number.MAX_SAFE_INTEGER ? ZeroArray
: null

class ZeroArray extends Array {
  constructor (size) {
    super(size)
    this.fill(0)
  }
}

class Stack {
  constructor (max) {
    const UintArray = max ? getUintArray(max) : Array
    this.heap = new UintArray(max)
    this.length = 0
  }
  push (n) {
    this.heap[this.length++] = n
  }
  pop () {
    return this.heap[--this.length]
  }
}

class LRUCache {
  constructor (options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      sizeCalculation,
      fetchMethod,
    } = options

    // deprecated options, don't trigger a warning for getting them if
    // the thing being passed in is another LRUCache we're copying.
    const {
      length,
      maxAge,
      stale,
    } = options instanceof LRUCache ? {} : options

    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError('max option must be a nonnegative integer')
    }

    const UintArray = max ? getUintArray(max) : Array
    if (!UintArray) {
      throw new Error('invalid max value: ' + max)
    }

    this.max = max
    this.maxSize = maxSize
    this.sizeCalculation = sizeCalculation || length
    if (this.sizeCalculation) {
      if (!this.maxSize) {
        throw new TypeError('cannot set sizeCalculation without setting maxSize')
      }
      if (typeof this.sizeCalculation !== 'function') {
        throw new TypeError('sizeCalculating set to non-function')
      }
    }

    this.fetchMethod = fetchMethod || null
    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
      throw new TypeError('fetchMethod must be a function if specified')
    }


    this.keyMap = new Map()
    this.keyList = new Array(max).fill(null)
    this.valList = new Array(max).fill(null)
    this.next = new UintArray(max)
    this.prev = new UintArray(max)
    this.head = 0
    this.tail = 0
    this.free = new Stack(max)
    this.initialFill = 1
    this.size = 0

    if (typeof dispose === 'function') {
      this.dispose = dispose
    }
    if (typeof disposeAfter === 'function') {
      this.disposeAfter = disposeAfter
      this.disposed = []
    } else {
      this.disposeAfter = null
      this.disposed = null
    }
    this.noDisposeOnSet = !!noDisposeOnSet
    this.noUpdateTTL = !!noUpdateTTL

    if (this.maxSize !== 0) {
      if (!isPosInt(this.maxSize)) {
        throw new TypeError('maxSize must be a positive integer if specified')
      }
      this.initializeSizeTracking()
    }

    this.allowStale = !!allowStale || !!stale
    this.updateAgeOnGet = !!updateAgeOnGet
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0
      ? ttlResolution : 1
    this.ttlAutopurge = !!ttlAutopurge
    this.ttl = ttl || maxAge || 0
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError('ttl must be a positive integer if specified')
      }
      this.initializeTTLTracking()
    }

    // do not allow completely unbounded caches
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError('At least one of max, maxSize, or ttl is required')
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code = 'LRU_CACHE_UNBOUNDED'
      if (shouldWarn(code)) {
        warned.add(code)
        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
          'result in unbounded memory consumption.'
        process.emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
      }
    }

    if (stale) {
      deprecatedOption('stale', 'allowStale')
    }
    if (maxAge) {
      deprecatedOption('maxAge', 'ttl')
    }
    if (length) {
      deprecatedOption('length', 'sizeCalculation')
    }
  }

  getRemainingTTL (key) {
    return this.has(key) ? Infinity : 0
  }

  initializeTTLTracking () {
    this.ttls = new ZeroArray(this.max)
    this.starts = new ZeroArray(this.max)

    this.setItemTTL = (index, ttl) => {
      this.starts[index] = ttl !== 0 ? perf.now() : 0
      this.ttls[index] = ttl
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.isStale(index)) {
            this.delete(this.keyList[index])
          }
        }, ttl + 1)
        /* istanbul ignore else - unref() not supported on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
    }

    this.updateItemAge = (index) => {
      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0
    }

    // debounce calls to perf.now() to 1s so we're not hitting
    // that costly call repeatedly.
    let cachedNow = 0
    const getNow = () => {
      const n = perf.now()
      if (this.ttlResolution > 0) {
        cachedNow = n
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution)
        /* istanbul ignore else - not available on all platforms */
        if (t.unref) {
          t.unref()
        }
      }
      return n
    }

    this.getRemainingTTL = (key) => {
      const index = this.keyMap.get(key)
      if (index === undefined) {
        return 0
      }
      return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity
        : ((this.starts[index] + this.ttls[index]) - (cachedNow || getNow()))
    }

    this.isStale = (index) => {
      return this.ttls[index] !== 0 && this.starts[index] !== 0 &&
        ((cachedNow || getNow()) - this.starts[index] > this.ttls[index])
    }
  }
  updateItemAge (index) {}
  setItemTTL (index, ttl) {}
  isStale (index) { return false }

  initializeSizeTracking () {
    this.calculatedSize = 0
    this.sizes = new ZeroArray(this.max)
    this.removeItemSize = index => this.calculatedSize -= this.sizes[index]
    this.requireSize = (k, v, size, sizeCalculation) => {
      if (sizeCalculation && !size) {
        size = sizeCalculation(v, k)
      }
      if (!isPosInt(size)) {
        throw new TypeError('size must be positive integer')
      }
      return size
    }
    this.addItemSize = (index, v, k, size) => {
      this.sizes[index] = size
      const maxSize = this.maxSize - this.sizes[index]
      while (this.calculatedSize > maxSize) {
        this.evict()
      }
      this.calculatedSize += this.sizes[index]
    }
    this.delete = k => {
      if (this.size !== 0) {
        const index = this.keyMap.get(k)
        if (index !== undefined) {
          this.calculatedSize -= this.sizes[index]
        }
      }
      return LRUCache.prototype.delete.call(this, k)
    }
  }
  removeItemSize (index) {}
  addItemSize (index, v, k, size) {}
  requireSize (k, v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError('cannot set size without setting maxSize on cache')
    }
  }

  *indexes ({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.tail; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.head) {
          break
        } else {
          i = this.prev[i]
        }
      }
    }
  }

  *rindexes ({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i = this.head; true; ) {
        if (!this.isValidIndex(i)) {
          break
        }
        if (allowStale || !this.isStale(i)) {
          yield i
        }
        if (i === this.tail) {
          break
        } else {
          i = this.next[i]
        }
      }
    }
  }

  isValidIndex (index) {
    return this.keyMap.get(this.keyList[index]) === index
  }

  *entries () {
    for (const i of this.indexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }
  *rentries () {
    for (const i of this.rindexes()) {
      yield [this.keyList[i], this.valList[i]]
    }
  }

  *keys () {
    for (const i of this.indexes()) {
      yield this.keyList[i]
    }
  }
  *rkeys () {
    for (const i of this.rindexes()) {
      yield this.keyList[i]
    }
  }

  *values () {
    for (const i of this.indexes()) {
      yield this.valList[i]
    }
  }
  *rvalues () {
    for (const i of this.rindexes()) {
      yield this.valList[i]
    }
  }

  [Symbol.iterator] () {
    return this.entries()
  }

  find (fn, getOptions = {}) {
    for (const i of this.indexes()) {
      if (fn(this.valList[i], this.keyList[i], this)) {
        return this.get(this.keyList[i], getOptions)
      }
    }
  }

  forEach (fn, thisp = this) {
    for (const i of this.indexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  rforEach (fn, thisp = this) {
    for (const i of this.rindexes()) {
      fn.call(thisp, this.valList[i], this.keyList[i], this)
    }
  }

  get prune () {
    deprecatedMethod('prune', 'purgeStale')
    return this.purgeStale
  }

  purgeStale () {
    let deleted = false
    for (const i of this.rindexes({ allowStale: true })) {
      if (this.isStale(i)) {
        this.delete(this.keyList[i])
        deleted = true
      }
    }
    return deleted
  }

  dump () {
    const arr = []
    for (const i of this.indexes()) {
      const key = this.keyList[i]
      const value = this.valList[i]
      const entry = { value }
      if (this.ttls) {
        entry.ttl = this.ttls[i]
      }
      if (this.sizes) {
        entry.size = this.sizes[i]
      }
      arr.unshift([key, entry])
    }
    return arr
  }

  load (arr) {
    this.clear()
    for (const [key, entry] of arr) {
      this.set(key, entry.value, entry)
    }
  }

  dispose (v, k, reason) {}

  set (k, v, {
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
  } = {}) {
    size = this.requireSize(k, v, size, sizeCalculation)
    let index = this.size === 0 ? undefined : this.keyMap.get(k)
    if (index === undefined) {
      // addition
      index = this.newIndex()
      this.keyList[index] = k
      this.valList[index] = v
      this.keyMap.set(k, index)
      this.next[this.tail] = index
      this.prev[index] = this.tail
      this.tail = index
      this.size ++
      this.addItemSize(index, v, k, size)
      noUpdateTTL = false
    } else {
      // update
      const oldVal = this.valList[index]
      if (v !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort()
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k, 'set')
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k, 'set'])
            }
          }
        }
        this.removeItemSize(index)
        this.valList[index] = v
        this.addItemSize(index, v, k, size)
      }
      this.moveToTail(index)
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking()
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index, ttl)
    }
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return this
  }

  newIndex () {
    if (this.size === 0) {
      return this.tail
    }
    if (this.size === this.max) {
      return this.evict()
    }
    if (this.free.length !== 0) {
      return this.free.pop()
    }
    // initial fill, just keep writing down the list
    return this.initialFill++
  }

  pop () {
    if (this.size) {
      const val = this.valList[this.head]
      this.evict()
      return val
    }
  }

  evict () {
    const head = this.head
    const k = this.keyList[head]
    const v = this.valList[head]
    if (this.isBackgroundFetch(v)) {
      v.__abortController.abort()
    } else {
      this.dispose(v, k, 'evict')
      if (this.disposeAfter) {
        this.disposed.push([v, k, 'evict'])
      }
    }
    this.removeItemSize(head)
    this.head = this.next[head]
    this.keyMap.delete(k)
    this.size --
    return head
  }

  has (k) {
    return this.keyMap.has(k) && !this.isStale(this.keyMap.get(k))
  }

  // like get(), but without any LRU updating or TTL expiration
  peek (k, { allowStale = this.allowStale } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined && (allowStale || !this.isStale(index))) {
      return this.valList[index]
    }
  }

  backgroundFetch (k, index, options) {
    const v = index === undefined ? undefined : this.valList[index]
    if (this.isBackgroundFetch(v)) {
      return v
    }
    const ac = new AbortController()
    const fetchOpts = {
      signal: ac.signal,
      options,
    }
    const p = Promise.resolve(this.fetchMethod(k, v, fetchOpts)).then(v => {
      if (!ac.signal.aborted) {
        this.set(k, v, fetchOpts.options)
      }
      return v
    })
    p.__abortController = ac
    p.__staleWhileFetching = v
    if (index === undefined) {
      this.set(k, p, fetchOpts.options)
      index = this.keyMap.get(k)
    } else {
      this.valList[index] = p
    }
    return p
  }

  isBackgroundFetch (p) {
    return p && typeof p === 'object' && typeof p.then === 'function' &&
      Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching')
  }

  // this takes the union of get() and set() opts, because it does both
  async fetch (k, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
  } = {}) {
    if (!this.fetchMethod) {
      return this.get(k, {allowStale, updateAgeOnGet})
    }

    const options = {
      allowStale,
      updateAgeOnGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
    }

    let index = this.keyMap.get(k)
    if (index === undefined) {
      return this.backgroundFetch(k, index, options)
    } else {
      // in cache, maybe already fetching
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        return allowStale && v.__staleWhileFetching !== undefined
          ? v.__staleWhileFetching : v
      }

      if (!this.isStale(index)) {
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return v
      }

      // ok, it is stale, and not already fetching
      // refresh the cache.
      const p = this.backgroundFetch(k, index, options)
      return allowStale && p.__staleWhileFetching !== undefined
        ? p.__staleWhileFetching : p
    }
  }

  get (k, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
  } = {}) {
    const index = this.keyMap.get(k)
    if (index !== undefined) {
      const value = this.valList[index]
      const fetching = this.isBackgroundFetch(value)
      if (this.isStale(index)) {
        // delete only if not an in-flight background fetch
        if (!fetching) {
          this.delete(k)
          return allowStale ? value : undefined
        } else {
          return allowStale ? value.__staleWhileFetching : undefined
        }
      } else {
        // if we're currently fetching it, we don't actually have it yet
        // it's not stale, which means this isn't a staleWhileRefetching,
        // so we just return undefined
        if (fetching) {
          return undefined
        }
        this.moveToTail(index)
        if (updateAgeOnGet) {
          this.updateItemAge(index)
        }
        return value
      }
    }
  }

  connect (p, n) {
    this.prev[n] = p
    this.next[p] = n
  }

  moveToTail (index) {
    // if tail already, nothing to do
    // if head, move head to next[index]
    // else
    //   move next[prev[index]] to next[index] (head has no prev)
    //   move prev[next[index]] to prev[index]
    // prev[index] = tail
    // next[tail] = index
    // tail = index
    if (index !== this.tail) {
      if (index === this.head) {
        this.head = this.next[index]
      } else {
        this.connect(this.prev[index], this.next[index])
      }
      this.connect(this.tail, index)
      this.tail = index
    }
  }

  get del () {
    deprecatedMethod('del', 'delete')
    return this.delete
  }
  delete (k) {
    let deleted = false
    if (this.size !== 0) {
      const index = this.keyMap.get(k)
      if (index !== undefined) {
        deleted = true
        if (this.size === 1) {
          this.clear()
        } else {
          this.removeItemSize(index)
          const v = this.valList[index]
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort()
          } else {
            this.dispose(v, k, 'delete')
            if (this.disposeAfter) {
              this.disposed.push([v, k, 'delete'])
            }
          }
          this.keyMap.delete(k)
          this.keyList[index] = null
          this.valList[index] = null
          if (index === this.tail) {
            this.tail = this.prev[index]
          } else if (index === this.head) {
            this.head = this.next[index]
          } else {
            this.next[this.prev[index]] = this.next[index]
            this.prev[this.next[index]] = this.prev[index]
          }
          this.size --
          this.free.push(index)
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
    return deleted
  }

  clear () {
    for (const index of this.rindexes({ allowStale: true })) {
      const v = this.valList[index]
      if (this.isBackgroundFetch(v)) {
        v.__abortController.abort()
      } else {
        const k = this.keyList[index]
        this.dispose(v, k, 'delete')
        if (this.disposeAfter) {
          this.disposed.push([v, k, 'delete'])
        }
      }
    }

    this.keyMap.clear()
    this.valList.fill(null)
    this.keyList.fill(null)
    if (this.ttls) {
      this.ttls.fill(0)
      this.starts.fill(0)
    }
    if (this.sizes) {
      this.sizes.fill(0)
    }
    this.head = 0
    this.tail = 0
    this.initialFill = 1
    this.free.length = 0
    this.calculatedSize = 0
    this.size = 0
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift())
      }
    }
  }
  get reset () {
    deprecatedMethod('reset', 'clear')
    return this.clear
  }

  get length () {
    deprecatedProperty('length', 'size')
    return this.size
  }
}

module.exports = LRUCache


/***/ }),

/***/ "./.yarn/__virtual__/lezer-promql-virtual-eaf88aa77a/0/cache/lezer-promql-npm-0.22.0-867da6afaa-cdce054700.zip/node_modules/lezer-promql/index.es.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Abs": () => (/* binding */ Abs),
/* harmony export */   "Absent": () => (/* binding */ Absent),
/* harmony export */   "AbsentOverTime": () => (/* binding */ AbsentOverTime),
/* harmony export */   "Acos": () => (/* binding */ Acos),
/* harmony export */   "Acosh": () => (/* binding */ Acosh),
/* harmony export */   "Add": () => (/* binding */ Add),
/* harmony export */   "AggregateExpr": () => (/* binding */ AggregateExpr),
/* harmony export */   "AggregateModifier": () => (/* binding */ AggregateModifier),
/* harmony export */   "AggregateOp": () => (/* binding */ AggregateOp),
/* harmony export */   "And": () => (/* binding */ And$1),
/* harmony export */   "Asin": () => (/* binding */ Asin),
/* harmony export */   "Asinh": () => (/* binding */ Asinh),
/* harmony export */   "At": () => (/* binding */ At),
/* harmony export */   "AtModifierPreprocessors": () => (/* binding */ AtModifierPreprocessors),
/* harmony export */   "Atan": () => (/* binding */ Atan),
/* harmony export */   "Atan2": () => (/* binding */ Atan2$1),
/* harmony export */   "Atanh": () => (/* binding */ Atanh),
/* harmony export */   "Avg": () => (/* binding */ Avg$1),
/* harmony export */   "AvgOverTime": () => (/* binding */ AvgOverTime),
/* harmony export */   "BinModifiers": () => (/* binding */ BinModifiers),
/* harmony export */   "BinaryExpr": () => (/* binding */ BinaryExpr),
/* harmony export */   "Bool": () => (/* binding */ Bool$1),
/* harmony export */   "Bottomk": () => (/* binding */ Bottomk$1),
/* harmony export */   "By": () => (/* binding */ By$1),
/* harmony export */   "Ceil": () => (/* binding */ Ceil),
/* harmony export */   "Changes": () => (/* binding */ Changes),
/* harmony export */   "Clamp": () => (/* binding */ Clamp),
/* harmony export */   "ClampMax": () => (/* binding */ ClampMax),
/* harmony export */   "ClampMin": () => (/* binding */ ClampMin),
/* harmony export */   "Cos": () => (/* binding */ Cos),
/* harmony export */   "Cosh": () => (/* binding */ Cosh),
/* harmony export */   "Count": () => (/* binding */ Count$1),
/* harmony export */   "CountOverTime": () => (/* binding */ CountOverTime),
/* harmony export */   "CountValues": () => (/* binding */ CountValues$1),
/* harmony export */   "DayOfMonth": () => (/* binding */ DayOfMonth),
/* harmony export */   "DayOfWeek": () => (/* binding */ DayOfWeek),
/* harmony export */   "DaysInMonth": () => (/* binding */ DaysInMonth),
/* harmony export */   "Deg": () => (/* binding */ Deg),
/* harmony export */   "Delta": () => (/* binding */ Delta),
/* harmony export */   "Deriv": () => (/* binding */ Deriv),
/* harmony export */   "Div": () => (/* binding */ Div),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "End": () => (/* binding */ End$1),
/* harmony export */   "Eql": () => (/* binding */ Eql),
/* harmony export */   "EqlRegex": () => (/* binding */ EqlRegex),
/* harmony export */   "EqlSingle": () => (/* binding */ EqlSingle),
/* harmony export */   "Exp": () => (/* binding */ Exp),
/* harmony export */   "Expr": () => (/* binding */ Expr),
/* harmony export */   "Floor": () => (/* binding */ Floor),
/* harmony export */   "FunctionCall": () => (/* binding */ FunctionCall),
/* harmony export */   "FunctionCallArgs": () => (/* binding */ FunctionCallArgs),
/* harmony export */   "FunctionCallBody": () => (/* binding */ FunctionCallBody),
/* harmony export */   "FunctionIdentifier": () => (/* binding */ FunctionIdentifier),
/* harmony export */   "Group": () => (/* binding */ Group$1),
/* harmony export */   "GroupLeft": () => (/* binding */ GroupLeft$1),
/* harmony export */   "GroupRight": () => (/* binding */ GroupRight$1),
/* harmony export */   "GroupingLabel": () => (/* binding */ GroupingLabel),
/* harmony export */   "GroupingLabelList": () => (/* binding */ GroupingLabelList),
/* harmony export */   "GroupingLabels": () => (/* binding */ GroupingLabels),
/* harmony export */   "Gte": () => (/* binding */ Gte),
/* harmony export */   "Gtr": () => (/* binding */ Gtr),
/* harmony export */   "HistogramQuantile": () => (/* binding */ HistogramQuantile),
/* harmony export */   "HoltWinters": () => (/* binding */ HoltWinters),
/* harmony export */   "Hour": () => (/* binding */ Hour),
/* harmony export */   "Idelta": () => (/* binding */ Idelta),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Ignoring": () => (/* binding */ Ignoring$1),
/* harmony export */   "Increase": () => (/* binding */ Increase),
/* harmony export */   "Irate": () => (/* binding */ Irate),
/* harmony export */   "LabelJoin": () => (/* binding */ LabelJoin),
/* harmony export */   "LabelMatchList": () => (/* binding */ LabelMatchList),
/* harmony export */   "LabelMatcher": () => (/* binding */ LabelMatcher),
/* harmony export */   "LabelMatchers": () => (/* binding */ LabelMatchers),
/* harmony export */   "LabelName": () => (/* binding */ LabelName),
/* harmony export */   "LabelReplace": () => (/* binding */ LabelReplace),
/* harmony export */   "LastOverTime": () => (/* binding */ LastOverTime),
/* harmony export */   "LineComment": () => (/* binding */ LineComment),
/* harmony export */   "Ln": () => (/* binding */ Ln),
/* harmony export */   "Log10": () => (/* binding */ Log10),
/* harmony export */   "Log2": () => (/* binding */ Log2),
/* harmony export */   "Lss": () => (/* binding */ Lss),
/* harmony export */   "Lte": () => (/* binding */ Lte),
/* harmony export */   "MatchOp": () => (/* binding */ MatchOp),
/* harmony export */   "MatrixSelector": () => (/* binding */ MatrixSelector),
/* harmony export */   "Max": () => (/* binding */ Max$1),
/* harmony export */   "MaxOverTime": () => (/* binding */ MaxOverTime),
/* harmony export */   "MetricIdentifier": () => (/* binding */ MetricIdentifier),
/* harmony export */   "MetricName": () => (/* binding */ MetricName),
/* harmony export */   "Min": () => (/* binding */ Min$1),
/* harmony export */   "MinOverTime": () => (/* binding */ MinOverTime),
/* harmony export */   "Minute": () => (/* binding */ Minute),
/* harmony export */   "Mod": () => (/* binding */ Mod),
/* harmony export */   "Month": () => (/* binding */ Month),
/* harmony export */   "Mul": () => (/* binding */ Mul),
/* harmony export */   "Neq": () => (/* binding */ Neq),
/* harmony export */   "NeqRegex": () => (/* binding */ NeqRegex),
/* harmony export */   "NumberLiteral": () => (/* binding */ NumberLiteral),
/* harmony export */   "Offset": () => (/* binding */ Offset$1),
/* harmony export */   "OffsetExpr": () => (/* binding */ OffsetExpr),
/* harmony export */   "On": () => (/* binding */ On$1),
/* harmony export */   "OnOrIgnoring": () => (/* binding */ OnOrIgnoring),
/* harmony export */   "Or": () => (/* binding */ Or$1),
/* harmony export */   "ParenExpr": () => (/* binding */ ParenExpr),
/* harmony export */   "Pi": () => (/* binding */ Pi),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "PredictLinear": () => (/* binding */ PredictLinear),
/* harmony export */   "PresentOverTime": () => (/* binding */ PresentOverTime),
/* harmony export */   "PromQL": () => (/* binding */ PromQL),
/* harmony export */   "Quantile": () => (/* binding */ Quantile$1),
/* harmony export */   "QuantileOverTime": () => (/* binding */ QuantileOverTime),
/* harmony export */   "Rad": () => (/* binding */ Rad),
/* harmony export */   "Rate": () => (/* binding */ Rate),
/* harmony export */   "Resets": () => (/* binding */ Resets),
/* harmony export */   "Round": () => (/* binding */ Round),
/* harmony export */   "Scalar": () => (/* binding */ Scalar),
/* harmony export */   "Sgn": () => (/* binding */ Sgn),
/* harmony export */   "Sin": () => (/* binding */ Sin),
/* harmony export */   "Sinh": () => (/* binding */ Sinh),
/* harmony export */   "Sort": () => (/* binding */ Sort),
/* harmony export */   "SortDesc": () => (/* binding */ SortDesc),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "Start": () => (/* binding */ Start$1),
/* harmony export */   "Stddev": () => (/* binding */ Stddev$1),
/* harmony export */   "StddevOverTime": () => (/* binding */ StddevOverTime),
/* harmony export */   "Stdvar": () => (/* binding */ Stdvar$1),
/* harmony export */   "StdvarOverTime": () => (/* binding */ StdvarOverTime),
/* harmony export */   "StepInvariantExpr": () => (/* binding */ StepInvariantExpr),
/* harmony export */   "StringLiteral": () => (/* binding */ StringLiteral),
/* harmony export */   "Sub": () => (/* binding */ Sub),
/* harmony export */   "SubqueryExpr": () => (/* binding */ SubqueryExpr),
/* harmony export */   "Sum": () => (/* binding */ Sum$1),
/* harmony export */   "SumOverTime": () => (/* binding */ SumOverTime),
/* harmony export */   "Tan": () => (/* binding */ Tan),
/* harmony export */   "Tanh": () => (/* binding */ Tanh),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "Timestamp": () => (/* binding */ Timestamp),
/* harmony export */   "Topk": () => (/* binding */ Topk$1),
/* harmony export */   "UnaryExpr": () => (/* binding */ UnaryExpr),
/* harmony export */   "UnaryOp": () => (/* binding */ UnaryOp),
/* harmony export */   "Unless": () => (/* binding */ Unless$1),
/* harmony export */   "Vector": () => (/* binding */ Vector),
/* harmony export */   "VectorSelector": () => (/* binding */ VectorSelector),
/* harmony export */   "Without": () => (/* binding */ Without$1),
/* harmony export */   "Year": () => (/* binding */ Year),
/* harmony export */   "inf": () => (/* binding */ inf$1),
/* harmony export */   "nan": () => (/* binding */ nan$1),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js");


// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf = 146,
  nan = 147,
  Bool = 1,
  Ignoring = 2,
  On = 3,
  GroupLeft = 4,
  GroupRight = 5,
  Offset = 6,
  Atan2 = 7,
  Avg = 8,
  Bottomk = 9,
  Count = 10,
  CountValues = 11,
  Group = 12,
  Max = 13,
  Min = 14,
  Quantile = 15,
  Stddev = 16,
  Stdvar = 17,
  Sum = 18,
  Topk = 19,
  By = 20,
  Without = 21,
  And = 22,
  Or = 23,
  Unless = 24,
  Start = 25,
  End = 26;

// Copyright 2021 The Prometheus Authors

const keywordTokens = {
    inf: inf,
    nan: nan,
    bool: Bool,
    ignoring: Ignoring,
    on: On,
    group_left: GroupLeft,
    group_right: GroupRight,
    offset: Offset,
};

const specializeIdentifier = (value, stack) => {
    return keywordTokens[value.toLowerCase()] || -1;
};

const contextualKeywordTokens = {
    avg: Avg,
    atan2: Atan2,
    bottomk: Bottomk,
    count: Count,
    count_values: CountValues,
    group: Group,
    max: Max,
    min: Min,
    quantile: Quantile,
    stddev: Stddev,
    stdvar: Stdvar,
    sum: Sum,
    topk: Topk,
    by: By,
    without: Without,
    and: And,
    or: Or,
    unless: Unless,
    start: Start,
    end: End,
};

const extendIdentifier = (value, stack) => {
    return contextualKeywordTokens[value.toLowerCase()] || -1;
};

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,absent_over_time:307, absent:309, abs:311, acos:313, acosh:315, asin:317, asinh:319, atan:321, atanh:323, avg_over_time:325, ceil:327, changes:329, clamp:331, clamp_max:333, clamp_min:335, cos:337, cosh:339, count_over_time:341, days_in_month:343, day_of_month:345, day_of_week:347, deg:349, delta:351, deriv:353, exp:355, floor:357, histogram_quantile:359, holt_winters:361, hour:363, idelta:365, increase:367, irate:369, label_replace:371, label_join:373, last_over_time:375, ln:377, log10:379, log2:381, max_over_time:383, min_over_time:385, minute:387, month:389, pi:391, predict_linear:393, present_over_time:395, quantile_over_time:397, rad:399, rate:401, resets:403, round:405, scalar:407, sgn:409, sin:411, sinh:413, sort:415, sort_desc:417, sqrt:419, stddev_over_time:421, stdvar_over_time:423, sum_over_time:425, tan:427, tanh:429, timestamp:431, time:433, vector:435, year:437};
const parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({
  version: 13,
  states: "6[OYQPOOO&{QPOOOOQO'#C{'#C{O'QQPO'#CzQ']QQOOOOQO'#De'#DeO'WQPO'#DdOOQO'#E}'#E}O(jQPO'#FTOYQPO'#FPOYQPO'#FSOOQO'#FV'#FVO.fQSO'#FWO.nQQO'#FUOOQO'#FU'#FUOOQO'#Cy'#CyOOQO'#Df'#DfOOQO'#Dh'#DhOOQO'#Di'#DiOOQO'#Dj'#DjOOQO'#Dk'#DkOOQO'#Dl'#DlOOQO'#Dm'#DmOOQO'#Dn'#DnOOQO'#Do'#DoOOQO'#Dp'#DpOOQO'#Dq'#DqOOQO'#Dr'#DrOOQO'#Ds'#DsOOQO'#Dt'#DtOOQO'#Du'#DuOOQO'#Dv'#DvOOQO'#Dw'#DwOOQO'#Dx'#DxOOQO'#Dy'#DyOOQO'#Dz'#DzOOQO'#D{'#D{OOQO'#D|'#D|OOQO'#D}'#D}OOQO'#EO'#EOOOQO'#EP'#EPOOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETOOQO'#EU'#EUOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EY'#EYOOQO'#EZ'#EZOOQO'#E['#E[OOQO'#E]'#E]OOQO'#E^'#E^OOQO'#E_'#E_OOQO'#E`'#E`OOQO'#Ea'#EaOOQO'#Eb'#EbOOQO'#Ec'#EcOOQO'#Ed'#EdOOQO'#Ee'#EeOOQO'#Ef'#EfOOQO'#Eg'#EgOOQO'#Eh'#EhOOQO'#Ei'#EiOOQO'#Ej'#EjOOQO'#Ek'#EkOOQO'#El'#ElOOQO'#Em'#EmOOQO'#En'#EnOOQO'#Eo'#EoOOQO'#Ep'#EpOOQO'#Eq'#EqOOQO'#Er'#ErOOQO'#Es'#EsOOQO'#Et'#EtOOQO'#Eu'#EuOOQO'#Ev'#EvOOQO'#Ew'#EwOOQO'#Ex'#ExOOQO'#Ey'#EyOOQO'#Ez'#EzQOQPOOO0XQPO'#C|O0^QPO'#DRO'WQPO,59fO0eQQO,59fO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO2RQPO,59oO7}QQO,5;gO8SQQO,5;jO8[QPO,5;yOOQO,5:O,5:OOOQO,5;i,5;iO8sQQO,5;kO8zQQO,5;nO:bQPO'#FYO:pQPO,5;rOOQO'#FX'#FXOOQO,5;r,5;rOOQO,5;p,5;pO:xQSO'#C}OOQO,59h,59hO;QQPO,59mO;YQQO'#DSOOQO,59m,59mOOQO1G/Q1G/QO0XQPO'#DWOAVQPO'#DVOAaQPO'#DVOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOYQPO1G/ZOAkQSO1G1ROOQO1G1U1G1UOAsQQO1G1UOAxQPO'#E}OOQO'#Fa'#FaOOQO1G1e1G1eOBTQPO1G1eOOQO1G1V1G1VOOQO'#FZ'#FZOBYQPO,5;tOB_QSO1G1^OOQO1G1^1G1^OOQO'#DP'#DPOBgQPO,59iOOQO'#DO'#DOOOQO,59i,59iOYQPO,59nOOQO1G/X1G/XOOQO,59r,59rOH_QPO,59qOHfQPO,59qOI}QQO7+$uOJ_QQO7+$uOKsQQO7+$uOLZQQO7+$uOMrQQO7+$uOOQO7+&m7+&mON]QQO7+&sOOQO7+&p7+&pONeQPO7+'POOQO1G1`1G1`OOQO1G1_1G1_OOQO7+&x7+&xONjQSO1G/TOOQO1G/T1G/TONrQQO1G/YOOQO1G/]1G/]ON|QPO1G/]OOQO<<J_<<J_O!&oQPO<<J_OOQO<<Jk<<JkOOQO1G/U1G/UOOQO7+$o7+$oOOQO7+$w7+$wOOQOAN?yAN?y",
  stateData: "!&t~O$ZOSkOS~OWQOXQOYQOZQO[QO]QO^QO_QO`QOaQObQOcQO!ZZO#t_O$WVO$XVO$[XO$_`O$`aO$abO$bcO$cdO$deO$efO$fgO$ghO$hiO$ijO$jkO$klO$lmO$mnO$noO$opO$pqO$qrO$rsO$stO$tuO$uvO$vwO$wxO$xyO$yzO$z{O${|O$|}O$}!OO%O!PO%P!QO%Q!RO%R!SO%S!TO%T!UO%U!VO%V!WO%W!XO%X!YO%Y!ZO%Z![O%[!]O%]!^O%^!_O%_!`O%`!aO%a!bO%b!cO%c!dO%d!eO%e!fO%f!gO%g!hO%h!iO%i!jO%j!kO%k!lO%l!mO%m!nO%n!oO%o!pO%p!qO%q!rO%r!sO%uWO%vWO%wVO%y[O~O!ZZO~Od!uOe!uO$[!vO~OU#POV!yOf!|Og!}Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O$S#QO%s#OO~O$W#SO$X#SO%w#SOW#wXX#wXY#wXZ#wX[#wX]#wX^#wX_#wX`#wXa#wXb#wXc#wX!Z#wX#t#wX$W#wX$X#wX$[#wX$_#wX$`#wX$a#wX$b#wX$c#wX$d#wX$e#wX$f#wX$g#wX$h#wX$i#wX$j#wX$k#wX$l#wX$m#wX$n#wX$o#wX$p#wX$q#wX$r#wX$s#wX$t#wX$u#wX$v#wX$w#wX$x#wX$y#wX$z#wX${#wX$|#wX$}#wX%O#wX%P#wX%Q#wX%R#wX%S#wX%T#wX%U#wX%V#wX%W#wX%X#wX%Y#wX%Z#wX%[#wX%]#wX%^#wX%_#wX%`#wX%a#wX%b#wX%c#wX%d#wX%e#wX%f#wX%g#wX%h#wX%i#wX%j#wX%k#wX%l#wX%m#wX%n#wX%o#wX%p#wX%q#wX%r#wX%u#wX%v#wX%w#wX%y#wX~Ot#VO%z#YO~O%y[OU#xXV#xXf#xXg#xXh#xXx#xX{#xX|#xX}#xX!O#xX!P#xX!Q#xX!R#xX!S#xX!T#xX!U#xX!V#xX$S#xX$V#xX%s#xX$^#xX$]#xX~O$[#[O~O$^#`O~PYOd!uOe!uOUnaVnafnagnahnaxna{na|na}na!Ona!Pna!Qna!Rna!Sna!Tna!Una!Vna$Sna$Vna%sna$^na$]na~OP#dOQ#bOR#bOWyPXyPYyPZyP[yP]yP^yP_yP`yPayPbyPcyP!ZyP#tyP$WyP$XyP$[yP$_yP$`yP$ayP$byP$cyP$dyP$eyP$fyP$gyP$hyP$iyP$jyP$kyP$lyP$myP$nyP$oyP$pyP$qyP$ryP$syP$tyP$uyP$vyP$wyP$xyP$yyP$zyP${yP$|yP$}yP%OyP%PyP%QyP%RyP%SyP%TyP%UyP%VyP%WyP%XyP%YyP%ZyP%[yP%]yP%^yP%_yP%`yP%ayP%byP%cyP%dyP%eyP%fyP%gyP%hyP%iyP%jyP%kyP%lyP%myP%nyP%oyP%pyP%qyP%ryP%uyP%vyP%wyP%yyP~O#p#jO~O!P#lO#p#kO~Oi#nOj#nO$WVO$XVO%u#mO%v#mO%wVO~O$^#qO~P']Ox!yOU#vaV#vaf#vag#vah#va{#va|#va}#va!O#va!P#va!Q#va!R#va!S#va!T#va!U#va!V#va$S#va$V#va%s#va$^#va$]#va~O!V#rO$O#rO$P#rO$Q#rO~O$]#tO%z#uO~Ot#vO$^#yO~O$]#zO$^#{O~O$]vX$^vX~P']OWyXXyXYyXZyX[yX]yX^yX_yX`yXayXbyXcyX!ZyX#tyX$WyX$XyX$[yX$_yX$`yX$ayX$byX$cyX$dyX$eyX$fyX$gyX$hyX$iyX$jyX$kyX$lyX$myX$nyX$oyX$pyX$qyX$ryX$syX$tyX$uyX$vyX$wyX$xyX$yyX$zyX${yX$|yX$}yX%OyX%PyX%QyX%RyX%SyX%TyX%UyX%VyX%WyX%XyX%YyX%ZyX%[yX%]yX%^yX%_yX%`yX%ayX%byX%cyX%dyX%eyX%fyX%gyX%hyX%iyX%jyX%kyX%lyX%myX%nyX%oyX%pyX%qyX%ryX%uyX%vyX%wyX%yyX~OS#}OT#}O~P;dOQ#bOR#bO~P;dO%t$UO%x$VO~O#p$WO~O$W#SO$X#SO%w#SO~O$[$XO~O#t$YO~Ot#VO%z$[O~O$]$]O$^$^O~OWyaXyaYyaZya[ya]ya^ya_ya`yaayabyacya!Zya#tya$Wya$Xya$_ya$`ya$aya$bya$cya$dya$eya$fya$gya$hya$iya$jya$kya$lya$mya$nya$oya$pya$qya$rya$sya$tya$uya$vya$wya$xya$yya$zya${ya$|ya$}ya%Oya%Pya%Qya%Rya%Sya%Tya%Uya%Vya%Wya%Xya%Yya%Zya%[ya%]ya%^ya%_ya%`ya%aya%bya%cya%dya%eya%fya%gya%hya%iya%jya%kya%lya%mya%nya%oya%pya%qya%rya%uya%vya%wya%yya~O$[#[O~PBoOS$aOT$aO$[ya~PBoOx!yOUwqfwqgwqhwq!Owq!Pwq!Qwq!Rwq!Swq!Twq!Uwq!Vwq$Swq$Vwq%swq$^wq$]wq~OVwq{wq|wq}wq~PHsOV!yO{!yO|!yO}!yO~PHsOV!yOx!yO{!yO|!yO}!yO!O!zO!P!zOUwqfwqgwqhwq$Swq$Vwq%swq$^wq$]wq~O!Qwq!Rwq!Swq!Twq!Uwq!Vwq~PJoO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~PJoOV!yOf!|Oh!|Ox!yO{!yO|!yO}!yO!O!zO!P!zO!Q!{O!R!{O!S!{O!T!{O!U!{O!V!{O~OUwqgwq$Swq$Vwq%swq$^wq$]wq~PLqO#p$cO%t$bO~O$^$dO~Ot#vO$^$fO~O$]vi$^vi~P']O$[#[OWyiXyiYyiZyi[yi]yi^yi_yi`yiayibyicyi!Zyi#tyi$Wyi$Xyi$_yi$`yi$ayi$byi$cyi$dyi$eyi$fyi$gyi$hyi$iyi$jyi$kyi$lyi$myi$nyi$oyi$pyi$qyi$ryi$syi$tyi$uyi$vyi$wyi$xyi$yyi$zyi${yi$|yi$}yi%Oyi%Pyi%Qyi%Ryi%Syi%Tyi%Uyi%Vyi%Wyi%Xyi%Yyi%Zyi%[yi%]yi%^yi%_yi%`yi%ayi%byi%cyi%dyi%eyi%fyi%gyi%hyi%iyi%jyi%kyi%lyi%myi%nyi%oyi%pyi%qyi%ryi%uyi%vyi%wyi%yyi~O%t$hO~O",
  goto: "(u$UPPPPPPPPPPPPPPPPPPPPPPPPPPPPP$V$u%R%_%e%q%tP%z&T$uP&W&gPPPPPPPPPPP$u&q&}P&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}&}$uP'Z$u$uP$u$u'j$u'v(V(f(i(oPPP$uP(rQSOQ#TXQ#UYQ#_!vQ$P#eQ$Q#fQ$R#gQ$S#hQ$T#iR$_#ze_OXY!v#e#f#g#h#i#zeROXY!v#e#f#g#h#i#zQ!wRR#a!xQ#]!uQ#|#bQ$`#}R$g$aR#w#[Q#x#[R$e$]Q!xRQ#RUR#a!wR#^!vQ#e!yQ#f!zQ#g!{Q#h!|R#i!}Y#c!y!z!{!|!}R$O#deUOXY!v#e#f#g#h#i#zeTOXY!v#e#f#g#h#i#zd_OXY!v#e#f#g#h#i#zR#o#QeYOXY!v#e#f#g#h#i#zd]OXY!v#e#f#g#h#i#zR!tPd^OXY!v#e#f#g#h#i#zR#Z]R#W[Q#X[R$Z#tR#s#VR#p#Q",
  nodeNames: " Bool Ignoring On GroupLeft GroupRight Offset Atan2 Avg Bottomk Count CountValues Group Max Min Quantile Stddev Stdvar Sum Topk By Without And Or Unless Start End LineComment PromQL Expr AggregateExpr AggregateOp AggregateModifier GroupingLabels GroupingLabelList GroupingLabel LabelName FunctionCallBody FunctionCallArgs BinaryExpr Pow BinModifiers OnOrIgnoring Mul Div Mod Add Sub Eql Gte Gtr Lte Lss Neq FunctionCall FunctionIdentifier AbsentOverTime Identifier Absent Abs Acos Acosh Asin Asinh Atan Atanh AvgOverTime Ceil Changes Clamp ClampMax ClampMin Cos Cosh CountOverTime DaysInMonth DayOfMonth DayOfWeek Deg Delta Deriv Exp Floor HistogramQuantile HoltWinters Hour Idelta Increase Irate LabelReplace LabelJoin LastOverTime Ln Log10 Log2 MaxOverTime MinOverTime Minute Month Pi PredictLinear PresentOverTime QuantileOverTime Rad Rate Resets Round Scalar Sgn Sin Sinh Sort SortDesc Sqrt StddevOverTime StdvarOverTime SumOverTime Tan Tanh Timestamp Time Vector Year MatrixSelector Duration NumberLiteral OffsetExpr ParenExpr StringLiteral SubqueryExpr UnaryExpr UnaryOp VectorSelector MetricIdentifier LabelMatchers LabelMatchList LabelMatcher MatchOp EqlSingle EqlRegex NeqRegex StepInvariantExpr At AtModifierPreprocessors MetricName",
  maxTerm: 226,
  skippedNodes: [0,27],
  repeatNodeCount: 0,
  tokenData: "1R~RwX^#lpq#lqr$ars$tst%huv%swx%xxy&gyz&lz{&q{|&v|}&}}!O'S!O!P'Z!P!Q(Z!Q!R(`!R![)W![!]-r!^!_.n!_!`.{!`!a/b!b!c/o!c!}/t!}#O0[#P#Q0a#Q#R0f#R#S/t#S#T0k#T#o/t#o#p0w#q#r0|#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~#qY$Z~X^#lpq#l#y#z#l$f$g#l#BY#BZ#l$IS$I_#l$I|$JO#l$JT$JU#l$KV$KW#l&FU&FV#l~$dQ!_!`$j#r#s$o~$oO!V~~$tO$Q~~$yU#t~OY$tZr$trs%]s#O$t#O#P%b#P~$t~%bO#t~~%ePO~$t~%mQk~OY%hZ~%h~%xO}~~%}U#t~OY%xZw%xwx%]x#O%x#O#P&a#P~%x~&dPO~%x~&lO$[~~&qO$^~~&vO{~R&}O%vP!OQ~'SO$]~R'ZO%uP!PQP'^P!Q!['aP'fR%wP!Q!['a!g!h'o#X#Y'oP'rR{|'{}!O'{!Q![(RP(OP!Q![(RP(WP%wP!Q![(R~(`O|~R(eZ%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#l#m-W#m#n,iR)]Y%wP!O!P'a!Q![)W!g!h'o#W#X){#X#Y'o#[#]*d#a#b*x#g#h+l#k#l+}#m#n,iQ*QP#pQ!Q![*TQ*WS!Q![*T#[#]*d#a#b*x#g#h+lQ*iP#pQ!Q![*lQ*oR!Q![*l#a#b*x#g#h+lQ*}Q#pQ!Q![+T#g#h+gQ+WR!Q![+T#a#b+a#g#h+lQ+dP#g#h+gQ+lO#pQQ+qP#pQ!Q![+tQ+wQ!Q![+t#a#b+aQ,SP#pQ!Q![,VQ,YT!Q![,V#W#X){#[#]*d#a#b*x#g#h+lQ,nP#pQ!Q![,qQ,tU!Q![,q#W#X){#[#]*d#a#b*x#g#h+l#k#l+}P-ZR!Q![-d!c!i-d#T#Z-dP-iR%wP!Q![-d!c!i-d#T#Z-dV-yT%xS!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.YR._T!ZR!Q![.Y![!].Y!c!}.Y#R#S.Y#T#o.Y~.sP!U~!_!`.v~.{O!T~~/QQ$OP!_!`/W#r#s/]Q/]O!QQ~/bO$P~~/gP!S~!_!`/j~/oO!R~~/tO$S~V/{T!ZRtS!Q![/t![!].Y!c!}/t#R#S/t#T#o/t~0aO%s~~0fO%t~~0kOx~~0nRO#S0k#S#T%]#T~0k~0|O%y~~1RO%z~",
  tokenizers: [0, 1, 2],
  topRules: {"PromQL":[0,28],"MetricName":[1,144]},
  specialized: [{term: 57, get: (value, stack) => (specializeIdentifier(value) << 1)},{term: 57, get: (value, stack) => (extendIdentifier(value) << 1) | 1},{term: 57, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});
// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  inf$1 = 146,
  nan$1 = 147,
  Bool$1 = 1,
  Ignoring$1 = 2,
  On$1 = 3,
  GroupLeft$1 = 4,
  GroupRight$1 = 5,
  Offset$1 = 6,
  Atan2$1 = 7,
  Avg$1 = 8,
  Bottomk$1 = 9,
  Count$1 = 10,
  CountValues$1 = 11,
  Group$1 = 12,
  Max$1 = 13,
  Min$1 = 14,
  Quantile$1 = 15,
  Stddev$1 = 16,
  Stdvar$1 = 17,
  Sum$1 = 18,
  Topk$1 = 19,
  By$1 = 20,
  Without$1 = 21,
  And$1 = 22,
  Or$1 = 23,
  Unless$1 = 24,
  Start$1 = 25,
  End$1 = 26,
  LineComment = 27,
  PromQL = 28,
  Expr = 29,
  AggregateExpr = 30,
  AggregateOp = 31,
  AggregateModifier = 32,
  GroupingLabels = 33,
  GroupingLabelList = 34,
  GroupingLabel = 35,
  LabelName = 36,
  FunctionCallBody = 37,
  FunctionCallArgs = 38,
  BinaryExpr = 39,
  Pow = 40,
  BinModifiers = 41,
  OnOrIgnoring = 42,
  Mul = 43,
  Div = 44,
  Mod = 45,
  Add = 46,
  Sub = 47,
  Eql = 48,
  Gte = 49,
  Gtr = 50,
  Lte = 51,
  Lss = 52,
  Neq = 53,
  FunctionCall = 54,
  FunctionIdentifier = 55,
  AbsentOverTime = 56,
  Identifier = 57,
  Absent = 58,
  Abs = 59,
  Acos = 60,
  Acosh = 61,
  Asin = 62,
  Asinh = 63,
  Atan = 64,
  Atanh = 65,
  AvgOverTime = 66,
  Ceil = 67,
  Changes = 68,
  Clamp = 69,
  ClampMax = 70,
  ClampMin = 71,
  Cos = 72,
  Cosh = 73,
  CountOverTime = 74,
  DaysInMonth = 75,
  DayOfMonth = 76,
  DayOfWeek = 77,
  Deg = 78,
  Delta = 79,
  Deriv = 80,
  Exp = 81,
  Floor = 82,
  HistogramQuantile = 83,
  HoltWinters = 84,
  Hour = 85,
  Idelta = 86,
  Increase = 87,
  Irate = 88,
  LabelReplace = 89,
  LabelJoin = 90,
  LastOverTime = 91,
  Ln = 92,
  Log10 = 93,
  Log2 = 94,
  MaxOverTime = 95,
  MinOverTime = 96,
  Minute = 97,
  Month = 98,
  Pi = 99,
  PredictLinear = 100,
  PresentOverTime = 101,
  QuantileOverTime = 102,
  Rad = 103,
  Rate = 104,
  Resets = 105,
  Round = 106,
  Scalar = 107,
  Sgn = 108,
  Sin = 109,
  Sinh = 110,
  Sort = 111,
  SortDesc = 112,
  Sqrt = 113,
  StddevOverTime = 114,
  StdvarOverTime = 115,
  SumOverTime = 116,
  Tan = 117,
  Tanh = 118,
  Timestamp = 119,
  Time = 120,
  Vector = 121,
  Year = 122,
  MatrixSelector = 123,
  Duration = 124,
  NumberLiteral = 125,
  OffsetExpr = 126,
  ParenExpr = 127,
  StringLiteral = 128,
  SubqueryExpr = 129,
  UnaryExpr = 130,
  UnaryOp = 131,
  VectorSelector = 132,
  MetricIdentifier = 133,
  LabelMatchers = 134,
  LabelMatchList = 135,
  LabelMatcher = 136,
  MatchOp = 137,
  EqlSingle = 138,
  EqlRegex = 139,
  NeqRegex = 140,
  StepInvariantExpr = 141,
  At = 142,
  AtModifierPreprocessors = 143,
  MetricName = 144;




/***/ }),

/***/ "./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultBufferLength": () => (/* binding */ DefaultBufferLength),
/* harmony export */   "MountedTree": () => (/* binding */ MountedTree),
/* harmony export */   "NodeProp": () => (/* binding */ NodeProp),
/* harmony export */   "NodeSet": () => (/* binding */ NodeSet),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "Parser": () => (/* binding */ Parser),
/* harmony export */   "Tree": () => (/* binding */ Tree),
/* harmony export */   "TreeBuffer": () => (/* binding */ TreeBuffer),
/* harmony export */   "TreeCursor": () => (/* binding */ TreeCursor),
/* harmony export */   "TreeFragment": () => (/* binding */ TreeFragment),
/* harmony export */   "parseMixed": () => (/* binding */ parseMixed)
/* harmony export */ });
// FIXME profile adding a per-Tree TreeNode cache, validating it by
// parent pointer
/// The default maximum length of a `TreeBuffer` node (1024).
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)
/// can have metadata associated with it in props. Instances of this
/// class represent prop names.
class NodeProp {
    /// Create a new node prop type.
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /// This is meant to be used with
    /// [`NodeSet.extend`](#common.NodeSet.extend) or
    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
    /// prop values for each node type in the set. Takes a [match
    /// object](#common.NodeType^match) or function that returns undefined
    /// if the node type doesn't get this prop, and the prop's value if
    /// it does.
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/// Prop that is used to describe matching delimiters. For opening
/// delimiters, this holds an array of node names (written as a
/// space-separated string when declaring this prop in a grammar)
/// for the node types of closing delimiters that match it.
NodeProp.closedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
/// attached to closing delimiters, holding an array of node names
/// of types of matching opening delimiters.
NodeProp.openedBy = new NodeProp({ deserialize: str => str.split(" ") });
/// Used to assign node types to groups (for example, all node
/// types that represent an expression could be tagged with an
/// `"Expression"` group).
NodeProp.group = new NodeProp({ deserialize: str => str.split(" ") });
/// The hash of the [context](#lr.ContextTracker.constructor)
/// that the node was parsed in, if any. Used to limit reuse of
/// contextual nodes.
NodeProp.contextHash = new NodeProp({ perNode: true });
/// The distance beyond the end of the node that the tokenizer
/// looked ahead for any of the tokens inside the node. (The LR
/// parser only stores this when it is larger than 25, for
/// efficiency reasons.)
NodeProp.lookAhead = new NodeProp({ perNode: true });
/// This per-node prop is used to replace a given node, or part of a
/// node, with another tree. This is useful to include trees from
/// different languages.
NodeProp.mounted = new NodeProp({ perNode: true });
/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on
/// a tree node to indicate that parts of its content are
/// represented by another tree.
class MountedTree {
    constructor(
    /// The inner tree.
    tree, 
    /// If this is null, this tree replaces the entire node (it will
    /// be included in the regular iteration instead of its host
    /// node). If not, only the given ranges are considered to be
    /// covered by this tree. This is used for trees that are mixed in
    /// a way that isn't strictly hierarchical. Such mounted trees are
    /// only entered by [`resolveInner`](#common.Tree.resolveInner)
    /// and [`enter`](#common.SyntaxNode.enter).
    overlay, 
    /// The parser used to create this subtree.
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
}
const noProps = Object.create(null);
/// Each node in a syntax tree has a node type associated with it.
class NodeType {
    /// @internal
    constructor(
    /// The name of the node type. Not necessarily unique, but if the
    /// grammar was written properly, different node types with the
    /// same name within a node set should play the same semantic
    /// role.
    name, 
    /// @internal
    props, 
    /// The id of this node in its set. Corresponds to the term ids
    /// used in the parser.
    id, 
    /// @internal
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |
            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);
        let type = new NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /// Retrieves a node prop for this type. Will return `undefined` if
    /// the prop isn't present on this node.
    prop(prop) { return this.props[prop.id]; }
    /// True when this is the top node of a grammar.
    get isTop() { return (this.flags & 1 /* Top */) > 0; }
    /// True when this node is produced by a skip rule.
    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }
    /// Indicates whether this is an error node.
    get isError() { return (this.flags & 4 /* Error */) > 0; }
    /// When true, this node type doesn't correspond to a user-declared
    /// named node, for example because it is used to cache repetition.
    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }
    /// Returns true when this node's name or one of its
    /// [groups](#common.NodeProp^group) matches the given string.
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /// Create a function from node types to arbitrary values by
    /// specifying an object whose property names are node or
    /// [group](#common.NodeProp^group) names. Often useful with
    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    /// names, separated by spaces, in a single property name to map
    /// multiple node names to a single value.
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/// An empty dummy node type to use when no actual type is available.
NodeType.none = new NodeType("", Object.create(null), 0, 8 /* Anonymous */);
/// A node set holds a collection of node types. It is used to
/// compactly represent trees by storing their type ids, rather than a
/// full pointer to the type object, in a numeric array. Each parser
/// [has](#lr.LRParser.nodeSet) a node set, and [tree
/// buffers](#common.TreeBuffer) can only store collections of nodes
/// from the same set. A set can have a maximum of 2**16 (65536) node
/// types in it, so that the ids fit into 16-bit typed array slots.
class NodeSet {
    /// Create a set with the given types. The `id` property of each
    /// type should correspond to its position within the array.
    constructor(
    /// The node types in this set, by id.
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /// Create a copy of this set with some node properties added. The
    /// arguments to this method should be created with
    /// [`NodeProp.add`](#common.NodeProp.add).
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/// A piece of syntax tree. There are two ways to approach these
/// trees: the way they are actually stored in memory, and the
/// convenient way.
///
/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
/// objects. By packing detail information into `TreeBuffer` leaf
/// nodes, the representation is made a lot more memory-efficient.
///
/// However, when you want to actually work with tree nodes, this
/// representation is very awkward, so most client code will want to
/// use the [`TreeCursor`](#common.TreeCursor) or
/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
/// a view on some part of this data structure, and can be used to
/// move around to adjacent nodes.
class Tree {
    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    constructor(
    /// The type of the top node.
    type, 
    /// This node's child nodes.
    children, 
    /// The positions (offsets relative to the start of this tree) of
    /// the children.
    positions, 
    /// The total length of this tree
    length, 
    /// Per-node [node props](#common.NodeProp) to associate with this node.
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /// @internal
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /// @internal
    toString() {
        let mounted = this.prop(NodeProp.mounted);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When
    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)
    /// to the given position and side.
    cursor(pos, side = 0) {
        let scope = (pos != null && CachedNode.get(this)) || this.topNode;
        let cursor = new TreeCursor(scope);
        if (pos != null) {
            cursor.moveTo(pos, side);
            CachedNode.set(this, cursor._tree);
        }
        return cursor;
    }
    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular
    /// cursors, doesn't skip through
    /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't
    /// automatically enter mounted nodes.
    fullCursor() {
        return new TreeCursor(this.topNode, 1 /* Full */);
    }
    /// Get a [syntax node](#common.SyntaxNode) object for the top of the
    /// tree.
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /// Get the [syntax node](#common.SyntaxNode) at the given position.
    /// If `side` is -1, this will move into nodes that end at the
    /// position. If 1, it'll move into nodes that start at the
    /// position. With 0, it'll only enter nodes that cover the position
    /// from both sides.
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /// Like [`resolve`](#common.Tree.resolve), but will enter
    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    /// pointing into the innermost overlaid tree at the given position
    /// (with parent links going through all parent structure, including
    /// the host trees).
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /// Iterate over the tree and its children, calling `enter` for any
    /// node that touches the `from`/`to` region (if given) before
    /// running over such a node's children, and `leave` (if given) when
    /// leaving the node. When `enter` returns `false`, that node will
    /// not have its children iterated over (or `leave` called).
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        for (let c = this.cursor(), get = () => c.node;;) {
            let mustLeave = false;
            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {
                if (c.firstChild())
                    continue;
                if (!c.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(c.type, c.from, c.to, get);
                mustLeave = c.type.isAnonymous;
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                mustLeave = true;
            }
        }
    }
    /// Get the value of the given [node prop](#common.NodeProp) for this
    /// node. Works with both per-node and per-type props.
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
    /// format that can be passed to the [`Tree`](#common.Tree)
    /// constructor.
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /// Balance the direct children of this tree, producing a copy of
    /// which may have children grouped into subtrees with type
    /// [`NodeType.none`](#common.NodeType^none).
    balance(config = {}) {
        return this.children.length <= 8 /* BranchFactor */ ? this :
            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    /// Build a tree from a postfix-ordered buffer of node information,
    /// or a cursor over such a buffer.
    static build(data) { return buildTree(data); }
}
/// The empty tree
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/// Tree buffers contain (type, start, end, endIndex) quads for each
/// node. In such a buffer, nodes are stored in prefix order (parents
/// before children, with the endIndex of the parent indicating which
/// children belong to it)
class TreeBuffer {
    /// Create a tree buffer.
    constructor(
    /// The buffer's content.
    buffer, 
    /// The total length of the group of nodes in the buffer.
    length, 
    /// The node set used in this buffer.
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /// @internal
    get type() { return NodeType.none; }
    /// @internal
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /// @internal
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /// @internal
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /// @internal
    slice(startI, endI, from, to) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI);
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
        }
        return new TreeBuffer(copy, to - from, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Before */: return from < pos;
        case -1 /* AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Around */: return from < pos && to > pos;
        case 1 /* AtOrAfter */: return from <= pos && to > pos;
        case 2 /* After */: return to > pos;
        case 4 /* DontCare */: return true;
    }
}
function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to)
            break;
        if (last.type.isError && last.from == last.to) {
            node = scan;
            scan = last.prevSibling;
        }
        else {
            scan = last;
        }
    }
    return node;
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, overlays);
        if (!inner)
            return node;
        node = inner;
    }
}
class TreeNode {
    constructor(node, _from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        this.node = node;
        this._from = _from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this.node.type; }
    get name() { return this.node.type.name; }
    get from() { return this._from; }
    get to() { return this._from + this.node.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent._from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & 2 /* NoEnterBuffer */)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & 1 /* Full */) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent.node.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }
    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }
    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }
    enter(pos, side, overlays = true, buffers = true) {
        let mounted;
        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return this.node; }
    toTree() { return this.node; }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    /// @internal
    toString() { return this.node.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode {
    constructor(context, _parent, index) {
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }
    enter(pos, side, overlays, buffers = true) {
        if (!buffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
    }
    get cursor() { return new TreeCursor(this); }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
            children.push(buffer.slice(startI, endI, from, to));
            positions.push(0);
        }
        return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }
    /// @internal
    toString() { return this.context.buffer.childString(this.index); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
}
/// A tree cursor object focuses on a given node in a syntax tree, and
/// allows you to move to adjacent nodes.
class TreeCursor {
    /// @internal
    constructor(node, 
    /// @internal
    mode = 0) {
        this.mode = mode;
        this.buffer = null;
        this.stack = [];
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    /// Shorthand for `.type.name`.
    get name() { return this.type.name; }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /// @internal
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /// @internal
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /// Move the cursor to this node's first child. When this returns
    /// false, the node has no child, and the cursor has not been moved.
    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }
    /// Move the cursor to this node's last child.
    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }
    /// Move the cursor to the first child that ends after `pos`.
    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }
    /// Move to the last child that starts before `pos`.
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }
    /// Move the cursor to the child around `pos`. If side is -1 the
    /// child may end at that position, when 1 it may start there. This
    /// will also enter [overlaid](#common.MountedTree.overlay)
    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    /// set to false.
    enter(pos, side, overlays = true, buffers = true) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1 /* Full */), buffers));
        return buffers ? this.enterChild(1, pos, side) : false;
    }
    /// Move to the node's parent node, if this isn't the top node.
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /// @internal
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;
    }
    /// Move to this node's next sibling, if any.
    nextSibling() { return this.sibling(1); }
    /// Move to this node's previous sibling, if any.
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
                    let child = parent.node.children[i];
                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /// Move to the next node in a
    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
    /// traversal, going from a node to its first child or, if the
    /// current node is empty or `enter` is false, its next sibling or
    /// the next sibling of the first parent node that has one.
    next(enter = true) { return this.move(1, enter); }
    /// Move to the next node in a last-to-first pre-order traveral. A
    /// node is followed by its last child or, if it has none, its
    /// previous sibling or the previous sibling of the first parent
    /// node that has one.
    prev(enter = true) { return this.move(-1, enter); }
    /// Move the cursor to the innermost node that covers `pos`. If
    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    /// it will enter nodes that start at `pos`.
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
    /// position.
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /// Get the [tree](#common.Tree) that represents the current node, if
    /// any. Will return null when the node is in a [tree
    /// buffer](#common.TreeBuffer).
    get tree() {
        return this.buffer ? null : this._tree.node;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}

/// Tree fragments are used during [incremental
/// parsing](#common.Parser.startParse) to track parts of old trees
/// that can be reused in a new parse. An array of fragments is used
/// to track regions of an old tree whose nodes might be reused in new
/// parses. Use the static
/// [`applyChanges`](#common.TreeFragment^applyChanges) method to
/// update fragments for document changes.
class TreeFragment {
    /// Construct a tree fragment.
    constructor(
    /// The start of the unchanged range pointed to by this fragment.
    /// This refers to an offset in the _updated_ document (as opposed
    /// to the original tree).
    from, 
    /// The end of the unchanged range.
    to, 
    /// The tree that this fragment is based on.
    tree, 
    /// The offset between the fragment's tree and the document that
    /// this fragment can be used against. Add this when going from
    /// document to tree positions, subtract it to go from tree to
    /// document positions.
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);
    }
    /// Whether the start of the fragment represents the start of a
    /// parse, or the end of a change. (In the second case, it may not
    /// be safe to reuse some nodes at the start, depending on the
    /// parsing algorithm.)
    get openStart() { return (this.open & 1 /* Start */) > 0; }
    /// Whether the end of the fragment represents the end of a
    /// full-document parse, or the start of a change.
    get openEnd() { return (this.open & 2 /* End */) > 0; }
    /// Create a set of fragments from a freshly parsed tree, or update
    /// an existing set of fragments by replacing the ones that overlap
    /// with a tree with content from the new tree. When `partial` is
    /// true, the parse is treated as incomplete, and the resulting
    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    /// true.
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /// Apply a set of edits to an array of fragments, removing or
    /// splitting fragments as necessary to remove edited ranges, and
    /// adjusting offsets for fragments that moved.
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/// A superclass that parsers should extend.
class Parser {
    /// Start a parse, returning a [partial parse](#common.PartialParse)
    /// object. [`fragments`](#common.TreeFragment) can be passed in to
    /// make the parse incremental.
    ///
    /// By default, the entire input is parsed. You can pass `ranges`,
    /// which should be a sorted array of non-empty, non-overlapping
    /// ranges, to parse only those ranges. The tree returned in that
    /// case will start at `ranges[0].from`.
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /// Run a full parse, returning the resulting tree.
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/// Create a parse wrapper that, after the inner parse completes,
/// scans its tree for mixed language regions with the `nest`
/// function, runs the resulting [inner parses](#common.NestedParse),
/// and then [mounts](#common.NodeProp^mounted) their results onto the
/// tree.
///
/// The nesting function is passed a cursor to provide context for a
/// node, but _should not_ move that cursor, only inspect its
/// properties and optionally access its
/// [node object](#common.TreeCursor.node).
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, ranges) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.ranges = ranges;
    }
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].ranges[0].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);
        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {
            let enter = true, range;
            if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Full */;
            }
            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);
                    if (ranges.length)
                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length)
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;
    }
    return 0 /* None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];
        nodes.push(buf.slice(startI, endI, from, to));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, depth = 0;
    // Scan up to the nearest tree
    do {
        cursor.parent();
        depth++;
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let i = 0, base = cursor.tree, off = 0;
    for (;; i++) {
        off = base.positions[i] + cursor.from;
        if (off <= node.from && off + base.children[i].length >= node.to)
            break;
    }
    let buf = base.children[i], b = buf.buffer;
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length) {
        let i = startI;
        while (b[i + 2] + off <= node.from)
            i = b[i + 3];
        let children = [], positions = [];
        sliceBuf(buf, startI, i, children, positions, innerOffset);
        let from = b[i + 1], to = b[i + 2];
        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;
        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));
        positions.push(from - innerOffset);
        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);
        return new Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    // Move the cursor back to the target node
    for (let d = 0; d <= depth; d++)
        cursor.childAfter(node.from);
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.fullCursor();
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));
        }
    }
    return result;
}




/***/ }),

/***/ "./.yarn/cache/@lezer-lr-npm-0.15.8-8c481c39cd-e741225d6a.zip/node_modules/@lezer/lr/dist/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextTracker": () => (/* binding */ ContextTracker),
/* harmony export */   "ExternalTokenizer": () => (/* binding */ ExternalTokenizer),
/* harmony export */   "InputStream": () => (/* binding */ InputStream),
/* harmony export */   "LRParser": () => (/* binding */ LRParser),
/* harmony export */   "Stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./.yarn/cache/@lezer-common-npm-0.15.12-62017272b0-dae6581618.zip/node_modules/@lezer/common/dist/index.js");


/// A parse stack. These are used internally by the parser to track
/// parsing progress. They also provide some properties and methods
/// that external code such as a tokenizer can use to get information
/// about the parse state.
class Stack {
    /// @internal
    constructor(
    /// The parse that this stack is part of @internal
    p, 
    /// Holds state, input pos, buffer index triplets for all but the
    /// top state @internal
    stack, 
    /// The current parse state @internal
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /// @internal
    reducePos, 
    /// The input position up to which this stack has parsed.
    pos, 
    /// The dynamic score of the stack, including dynamic precedence
    /// and error-recovery penalties
    /// @internal
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /// @internal
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /// @internal
    bufferBase, 
    /// @internal
    curContext, 
    /// @internal
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /// @internal
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /// @internal
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /// @internal
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /// The stack's current [context](#lr.ContextTracker) value, if
    /// any. Its type will depend on the context tracker's type
    /// parameter, or it will be `null` if there is no context
    /// tracker.
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /// @internal
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /// @internal
    reduce(action) {
        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;
        let { parser } = this.p;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special casethey add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);
        let start = this.stack[base - 2];
        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /// @internal
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /// @internal
    shift(action, next, nextEnd) {
        let start = this.pos;
        if (action & 131072 /* GotoFlag */) {
            this.pushState(action & 65535 /* ValueMask */, this.pos);
        }
        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (nextEnd > this.pos || next <= parser.maxNode) {
                this.pos = nextEnd;
                if (!parser.stateFlag(nextState, 1 /* Skipped */))
                    this.reducePos = nextEnd;
            }
            this.pushState(nextState, start);
            this.shiftContext(next, start);
            if (next <= parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = nextEnd;
            this.shiftContext(next, start);
            if (next <= this.p.parser.maxNode)
                this.buffer.push(next, start, nextEnd, 4);
        }
    }
    // Apply an action
    /// @internal
    apply(action, next, nextEnd) {
        if (action & 65536 /* ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /// @internal
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /// @internal
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /// @internal
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Delete */;
    }
    /// Check if the given term would be able to be shifted (optionally
    /// after some reductions) on this stack. This can be useful for
    /// external tokenizers that want to make sure they only provide a
    /// given token when it applies.
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if ((action & 65536 /* ReduceFlag */) == 0)
                return true;
            if (action == 0)
                return false;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /// @internal
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);
            stack.pushState(s, this.pos);
            stack.shiftContext(nextStates[i], this.pos);
            stack.score -= 200 /* Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /// @internal
    forceReduce() {
        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);
        if ((reduce & 65536 /* ReduceFlag */) == 0)
            return false;
        let { parser } = this.p;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)
                return false;
            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);
            this.score -= 100 /* Reduce */;
        }
        this.reduce(reduce);
        return true;
    }
    /// @internal
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /// Check whether this state has no further actions (assumed to be a direct descendant of the
    /// top state, since any other states must be able to continue
    /// somehow). @internal
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&
            !parser.stateSlot(this.state, 4 /* DefaultReduce */);
    }
    /// Restart the stack (put it back in its start state). Only safe
    /// when this.stack.length == 3 (state is directly below the top
    /// state). @internal
    restart() {
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /// @internal
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /// Get the parser used by this stack.
    get parser() { return this.p.parser; }
    /// Test whether a given dialect (by numeric ID, as exported from
    /// the terms file) is enabled.
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /// @internal
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    /// @internal
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /// @internal
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /// @internal
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
var Recover;
(function (Recover) {
    Recover[Recover["Insert"] = 200] = "Insert";
    Recover[Recover["Delete"] = 190] = "Delete";
    Recover[Recover["Reduce"] = 100] = "Reduce";
    Recover[Recover["MaxNext"] = 4] = "MaxNext";
    Recover[Recover["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover[Recover["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/// [Tokenizers](#lr.ExternalTokenizer) interact with the input
/// through this interface. It presents the input as a stream of
/// characters, tracking lookahead and hiding the complexity of
/// [ranges](#common.Parser.parse^ranges) from tokenizer code.
class InputStream {
    /// @internal
    constructor(
    /// @internal
    input, 
    /// @internal
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /// @internal
        this.chunk = "";
        /// @internal
        this.chunkOff = 0;
        /// Backup chunk
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /// The character code of the next code unit in the input, or -1
        /// when the stream is at the end of the input.
        this.next = -1;
        /// @internal
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /// Look at a code unit near the stream position. `.peek(0)` equals
    /// `.next`, `.peek(-1)` gives you the previous character, and so
    /// on.
    ///
    /// Note that looking around during tokenizing creates dependencies
    /// on potentially far-away content, which may reduce the
    /// effectiveness incremental parsingwhen looking forwardor even
    /// cause invalid reparses when looking backward more than 25 code
    /// units, since the library does not track lookbehind.
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /// Accept a token. By default, the end of the token is set to the
    /// current stream position, but you can pass an offset (relative to
    /// the stream position) to change that.
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /// Move the stream forward N (defaults to 1) code units. Returns
    /// the new value of [`next`](#lr.InputStream.next).
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /// @internal
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /// @internal
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/// @internal
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) { readToken(this.data, input, stack, this.id); }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/// `@external tokens` declarations in the grammar should resolve to
/// an instance of this class.
class ExternalTokenizer {
    /// Create a tokenizer. The first argument is the function that,
    /// given an input stream, scans for the types of tokens it
    /// recognizes at the stream's position, and calls
    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    /// one.
    constructor(
    /// @internal
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `token` when it matches a token.
function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {
                    input.acceptToken(term);
                    break;
                }
            }
        // Do a binary search on the state's edges
        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1];
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* BigValCode */) {
                value = 65535 /* BigVal */;
                break;
            }
            if (next >= 92 /* Gap2 */)
                next--;
            if (next >= 34 /* Gap1 */)
                next--;
            let digit = next - 32 /* Start */;
            if (digit >= 46 /* Base */) {
                digit -= 46 /* Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

// FIXME find some way to reduce recovery work done when the input
// doesn't match the grammar at all.
// Environment variable used to control console output
const verbose = typeof process != "undefined" && /\bparse\b/.test(({"NODE_ENV":"development"}).LOG);
let stackIDs = null;
var Safety;
(function (Safety) {
    Safety[Safety["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
    let cursor = tree.fullCursor();
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        tokenizer.token(this.stream.reset(stack.pos, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Err */;
            token.end = Math.min(stack.p.stream.end, stack.pos + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {
                if (data[i] == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
var Rec;
(function (Rec) {
    Rec[Rec["Distance"] = 5] = "Distance";
    Rec[Rec["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    // When two stacks have been running independently long enough to
    // add this many elements to their buffers, prune one.
    Rec[Rec["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec[Rec["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    // Once a stack reaches this depth (in .stack.length) force-reduce
    // it back to CutTo to avoid creating trees that overflow the stack
    // on recursive traversal.
    Rec[Rec["CutDepth"] = 15000] = "CutDepth";
    Rec[Rec["CutTo"] = 9000] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // , , , , , , , , , , , , , 
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished)
                return this.stackToTree(finished);
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished)
                return this.stackToTree(finished.forceAll());
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 15000 /* CutDepth */) {
            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            localStack.apply(action, term, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/// Context trackers are used to track stateful context (such as
/// indentation in the Python grammar, or parent elements in the XML
/// grammar) needed by external tokenizers. You declare them in a
/// grammar file as `@context exportName from "module"`.
///
/// Context values should be immutable, and can be updated (replaced)
/// on shift or reduce actions.
///
/// The export used in a `@context` declaration should be of this
/// type.
class ContextTracker {
    /// Define a context tracker.
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/// A parser holds the parse tables for a given grammar, as generated
/// by `lezer-generator`.
class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {
    /// @internal
    constructor(spec) {
        super();
        /// @internal
        this.wrappers = [];
        if (spec.version != 13 /* Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        this.strict = false;
        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
        this.specializers = [];
        if (spec.specialized)
            for (let i = 0; i < spec.specialized.length; i++) {
                this.specialized[i] = spec.specialized[i].term;
                this.specializers[i] = spec.specialized[i].get;
            }
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /// Get a goto table entry @internal
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /// Check if this state has an action for a given terminal @internal
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* End */) {
                    if (data[i + 1] == 1 /* Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /// @internal
    stateSlot(state, slot) {
        return this.states[(state * 6 /* Size */) + slot];
    }
    /// @internal
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;
    }
    /// @internal
    validAction(state, action) {
        if (action == this.stateSlot(state, 4 /* DefaultReduce */))
            return true;
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    return false;
            }
            if (action == pair(this.data, i + 1))
                return true;
        }
    }
    /// Get the states that can follow this one through shift actions or
    /// goto jumps. @internal
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {
            if (this.data[i] == 65535 /* End */) {
                if (this.data[i + 1] == 1 /* Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /// @internal
    overrides(token, prev) {
        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    /// Configure the parser. Returns a new parser instance that has the
    /// given settings modified. Settings not provided in `config` are
    /// kept from the original parser.
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /// Returns the name associated with a given term. This will only
    /// work for all terms when the parser was generated with the
    /// `--names` option. By default, only the names of tagged terms are
    /// stored.
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /// The eof term id is always allocated directly after the node
    /// types. @internal
    get eofTerm() { return this.maxNode + 1; }
    /// The type of top node produced by the parser.
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /// @internal
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /// @internal
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /// (used by the output of the parser generator) @internal
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0FBQUFBLEVBQUFBO0dBQUFBLG9CQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Qlo7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFZQTtBQUVBLE1BQU15bEIsOEJB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QW1DOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLCtCQUErQixJQUFJO0FBQ2pEO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0JBQStCLElBQUk7QUFDbEQ7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtCQUErQixJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNHJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25QNXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2REFBNkQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQTBEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsYUFBYSxVQUFVO0FBQzdFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsMkRBQTJELHlDQUF5QztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw4QkFBOEIscUNBQXFDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9jb3JlL3V0aWxzL0NhbmNlbGFibGVQcm9taXNlLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2FkZF9sYWJlbF90b19xdWVyeS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21DaGVhdFNoZWV0LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21FeGVtcGxhckZpZWxkLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21FeHBsb3JlRXh0cmFGaWVsZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tRXhwbG9yZVF1ZXJ5RWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21MaW5rLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL1Byb21RdWVyeUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3JCeUFwcC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3JGb3JBbGVydGluZy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tUXVlcnlGaWVsZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29tcG9uZW50cy9Qcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbXBvbmVudHMvbW9uYWNvLXF1ZXJ5LWZpZWxkL01vbmFjb1F1ZXJ5RmllbGRMYXp5LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb21wb25lbnRzL21vbmFjby1xdWVyeS1maWVsZC9Nb25hY29RdWVyeUZpZWxkV3JhcHBlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29uZmlndXJhdGlvbi9BenVyZUF1dGhTZXR0aW5ncy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29uZmlndXJhdGlvbi9BenVyZUNyZWRlbnRpYWxzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbmZpZ3VyYXRpb24vQXp1cmVDcmVkZW50aWFsc0NvbmZpZy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb25maWd1cmF0aW9uL0F6dXJlQ3JlZGVudGlhbHNGb3JtLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9jb25maWd1cmF0aW9uL0NvbmZpZ0VkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvY29uZmlndXJhdGlvbi9FeGVtcGxhclNldHRpbmcudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbmZpZ3VyYXRpb24vRXhlbXBsYXJzU2V0dGluZ3MudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2NvbmZpZ3VyYXRpb24vUHJvbVNldHRpbmdzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9kYXRhc291cmNlLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9sYW5ndWFnZV9wcm92aWRlci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9sYW5ndWFnZV91dGlscy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9tZXRyaWNfZmluZF9xdWVyeS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcHJvbXFsLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5X2hpbnRzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9Qcm9tUXVlcnlNb2RlbGxlci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvYWdncmVnYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9iaW5hcnlTY2FsYXJPcGVyYXRpb25zLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL01ldHJpY1NlbGVjdC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvTmVzdGVkUXVlcnkudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL05lc3RlZFF1ZXJ5TGlzdC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5QnVpbGRlci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5QnVpbGRlckNvbnRhaW5lci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5QnVpbGRlckV4cGxhaW5lZC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5QnVpbGRlckhpbnRzLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvY29tcG9uZW50cy9Qcm9tUXVlcnlCdWlsZGVyT3B0aW9ucy50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5Q29kZUVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3IudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUxlZ2VuZEVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL2NvbXBvbmVudHMvUXVlcnlQcmV2aWV3LnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvb3BlcmF0aW9ucy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvcGFyc2luZy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0F1dG9TaXplSW5wdXQudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvRmVlZGJhY2tMaW5rLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL0xhYmVsRmlsdGVySXRlbS50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9MYWJlbEZpbHRlcnMudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZS50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkVkaXRvci50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25FeHBsYWluZWRCb3gudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uSGVhZGVyLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbkluZm9CdXR0b24udHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvT3BlcmF0aW9uTGlzdC50c3giLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9PcGVyYXRpb25MaXN0RXhwbGFpbmVkLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvblBhcmFtRWRpdG9yLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL09wZXJhdGlvbnNFZGl0b3JSb3cudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvUXVlcnlFZGl0b3JNb2RlVG9nZ2xlLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL1F1ZXJ5SGVhZGVyU3dpdGNoLnRzeCIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc2hhcmVkL1F1ZXJ5T3B0aW9uR3JvdXAudHN4Iiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3F1ZXJ5YnVpbGRlci9zaGFyZWQvb3BlcmF0aW9uVXRpbHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC9wYXJzaW5nVXRpbHMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy9xdWVyeWJ1aWxkZXIvc3RhdGUudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvcXVlcnlidWlsZGVyL3R5cGVzLnRzIiwid2VicGFjazovL2dyYWZhbmEvLi9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL3Jlc3VsdF90cmFuc2Zvcm1lci50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy90eXBlcy50cyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vcHVibGljL2FwcC9wbHVnaW5zL2RhdGFzb3VyY2UvcHJvbWV0aGV1cy92YXJpYWJsZXMudHMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL19fdmlydHVhbF9fL3JlYWN0LXVzZS12aXJ0dWFsLTAwMzI2ZTcwYmEvMC9jYWNoZS9yZWFjdC11c2UtbnBtLTE3LjMuMi1hMDMyY2JlYjAxLTczNzk0NjBmNTEuemlwL25vZGVfbW9kdWxlcy9yZWFjdC11c2UvZXNtL3VzZVByZXZpb3VzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9yZWFjdC11c2UtdmlydHVhbC0wMDMyNmU3MGJhLzAvY2FjaGUvcmVhY3QtdXNlLW5wbS0xNy4zLjItYTAzMmNiZWIwMS03Mzc5NDYwZjUxLnppcC9ub2RlX21vZHVsZXMvcmVhY3QtdXNlL2VzbS91c2VUb2dnbGUuanMiLCJ3ZWJwYWNrOi8vZ3JhZmFuYS8uLy55YXJuL2NhY2hlL2xydS1jYWNoZS1ucG0tNy43LjEtNzI2Mjc0ZGM0ZC1mMzYyYzVhMmNmLnppcC9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9fX3ZpcnR1YWxfXy9sZXplci1wcm9tcWwtdmlydHVhbC1lYWY4OGFhNzdhLzAvY2FjaGUvbGV6ZXItcHJvbXFsLW5wbS0wLjIyLjAtODY3ZGE2YWZhYS1jZGNlMDU0NzAwLnppcC9ub2RlX21vZHVsZXMvbGV6ZXItcHJvbXFsL2luZGV4LmVzLmpzIiwid2VicGFjazovL2dyYWZhbmEvLi8ueWFybi9jYWNoZS9AbGV6ZXItY29tbW9uLW5wbS0wLjE1LjEyLTYyMDE3MjcyYjAtZGFlNjU4MTYxOC56aXAvbm9kZV9tb2R1bGVzL0BsZXplci9jb21tb24vZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9ncmFmYW5hLy4vLnlhcm4vY2FjaGUvQGxlemVyLWxyLW5wbS0wLjE1LjgtOGM0ODFjMzljZC1lNzQxMjI1ZDZhLnppcC9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy81NDY1XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZVByb21pc2U8VD4ge1xuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xuICBjYW5jZWw6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBtYWtlUHJvbWlzZUNhbmNlbGFibGUgPSA8VD4ocHJvbWlzZTogUHJvbWlzZTxUPik6IENhbmNlbGFibGVQcm9taXNlPFQ+ID0+IHtcbiAgbGV0IGhhc0NhbmNlbGVkXyA9IGZhbHNlO1xuXG4gIGNvbnN0IHdyYXBwZWRQcm9taXNlID0gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHByb21pc2UudGhlbigodmFsKSA9PiAoaGFzQ2FuY2VsZWRfID8gcmVqZWN0KHsgaXNDYW5jZWxlZDogdHJ1ZSB9KSA6IHJlc29sdmUodmFsKSkpO1xuICAgIHByb21pc2UuY2F0Y2goKGVycm9yKSA9PiAoaGFzQ2FuY2VsZWRfID8gcmVqZWN0KHsgaXNDYW5jZWxlZDogdHJ1ZSB9KSA6IHJlamVjdChlcnJvcikpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlOiB3cmFwcGVkUHJvbWlzZSxcbiAgICBjYW5jZWwoKSB7XG4gICAgICBoYXNDYW5jZWxlZF8gPSB0cnVlO1xuICAgIH0sXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnbGV6ZXItcHJvbXFsJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvcGFyc2luZyc7XG5pbXBvcnQgeyBQcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vcXVlcnlidWlsZGVyL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi9xdWVyeWJ1aWxkZXIvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21WaXN1YWxRdWVyeSB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3R5cGVzJztcblxuLyoqXG4gKiBBZGRzIGxhYmVsIGZpbHRlciB0byBleGlzdGluZyBxdWVyeS4gVXNlZnVsIGZvciBxdWVyeSBtb2RpZmljYXRpb24gZm9yIGV4YW1wbGUgZm9yIGFkIGhvYyBmaWx0ZXJzLlxuICpcbiAqIEl0IHVzZXMgUHJvbVFMIHBhcnNlciB0byBmaW5kIGluc3RhbmNlcyBvZiBtZXRyaWMgYW5kIGxhYmVscywgYWx0ZXJzIHRoZW0gYW5kIHRoZW4gc3BsaWNlcyB0aGVtIGJhY2sgaW50byB0aGUgcXVlcnkuXG4gKiBJZGVhbGx5IHdlIGNvdWxkIHVzZSB0aGUgcGFyc2UgLT4gY2hhbmdlIC0+IHJlbmRlciBpcyBhIHNpbXBsZSAzIHN0ZXBzIGJ1dCByaWdodCBub3cgYnVpbGRpbmcgdGhlIHZpc3VhbCBxdWVyeVxuICogb2JqZWN0IGRvZXMgbm90IHN1cHBvcnQgYWxsIHBvc3NpYmxlIHF1ZXJpZXMuXG4gKlxuICogU28gaW5zdGVhZCB0aGlzIGp1c3Qgb3BlcmF0ZXMgb24gc3Vic3RyaW5ncyBvZiB0aGUgcXVlcnkgd2l0aCBsYWJlbHMgYW5kIG9wZXJhdGVzIGp1c3Qgb24gdGhvc2UuIFRoaXMgbWFrZXMgdGhpc1xuICogbW9yZSByb2J1c3QgYW5kIGNhbiBhbHRlciBldmVuIGludmFsaWQgcXVlcmllcywgYW5kIHByZXNlcnZlcyBpbiBnZW5lcmFsIHRoZSBxdWVyeSBzdHJ1Y3R1cmUgYW5kIHdoaXRlc3BhY2UuXG4gKiBAcGFyYW0gcXVlcnlcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG9wZXJhdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRMYWJlbFRvUXVlcnkocXVlcnk6IHN0cmluZywga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIG9wZXJhdG9yID0gJz0nKTogc3RyaW5nIHtcbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGxhYmVsIHRvIGFkZCB0byBxdWVyeS4nKTtcbiAgfVxuXG4gIGNvbnN0IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zID0gZ2V0VmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMocXVlcnkpO1xuICBpZiAoIXZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlciA9IHRvTGFiZWxGaWx0ZXIoa2V5LCB2YWx1ZSwgb3BlcmF0b3IpO1xuICByZXR1cm4gYWRkRmlsdGVyKHF1ZXJ5LCB2ZWN0b3JTZWxlY3RvclBvc2l0aW9ucywgZmlsdGVyKTtcbn1cblxudHlwZSBWZWN0b3JTZWxlY3RvclBvc2l0aW9uID0geyBmcm9tOiBudW1iZXI7IHRvOiBudW1iZXI7IHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgc3RyaW5nIGFuZCBnZXQgYWxsIFZlY3RvclNlbGVjdG9yIHBvc2l0aW9ucyBpbiB0aGUgcXVlcnkgdG9nZXRoZXIgd2l0aCBwYXJzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICogc2VsZWN0b3IuXG4gKiBAcGFyYW0gcXVlcnlcbiAqL1xuZnVuY3Rpb24gZ2V0VmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMocXVlcnk6IHN0cmluZyk6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSB7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZXIucGFyc2UocXVlcnkpO1xuICBjb25zdCBwb3NpdGlvbnM6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSA9IFtdO1xuICB0cmVlLml0ZXJhdGUoe1xuICAgIGVudGVyOiAodHlwZSwgZnJvbSwgdG8sIGdldCk6IGZhbHNlIHwgdm9pZCA9PiB7XG4gICAgICBpZiAodHlwZS5uYW1lID09PSAnVmVjdG9yU2VsZWN0b3InKSB7XG4gICAgICAgIGNvbnN0IHZpc1F1ZXJ5ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcocXVlcnkuc3Vic3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHsgcXVlcnk6IHZpc1F1ZXJ5LnF1ZXJ5LCBmcm9tLCB0byB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG5mdW5jdGlvbiB0b0xhYmVsRmlsdGVyKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBvcGVyYXRvcjogc3RyaW5nKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGNvbnZlcnQgdGhlIHZhbHVlIGJhY2sgdG8gc3RyaW5nIGJlY2F1c2UgaXQgbWF5IGJlIGEgbnVtYmVyXG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB2YWx1ZSA9PT0gSW5maW5pdHkgPyAnK0luZicgOiB2YWx1ZS50b1N0cmluZygpO1xuICByZXR1cm4geyBsYWJlbDoga2V5LCBvcDogb3BlcmF0b3IsIHZhbHVlOiB0cmFuc2Zvcm1lZFZhbHVlIH07XG59XG5cbmZ1bmN0aW9uIGFkZEZpbHRlcihcbiAgcXVlcnk6IHN0cmluZyxcbiAgdmVjdG9yU2VsZWN0b3JQb3NpdGlvbnM6IFZlY3RvclNlbGVjdG9yUG9zaXRpb25bXSxcbiAgZmlsdGVyOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlclxuKTogc3RyaW5nIHtcbiAgY29uc3QgbW9kZWxsZXIgPSBuZXcgUHJvbVF1ZXJ5TW9kZWxsZXIoKTtcbiAgbGV0IG5ld1F1ZXJ5ID0gJyc7XG4gIGxldCBwcmV2ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gVGhpcyBpcyBiYXNpY2FsbHkganVzdCBkb2luZyBzcGxpY2Ugb24gYSBzdHJpbmcgZm9yIGVhY2ggbWF0Y2hlZCB2ZWN0b3Igc2VsZWN0b3IuXG5cbiAgICBjb25zdCBtYXRjaCA9IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zW2ldO1xuICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IHZlY3RvclNlbGVjdG9yUG9zaXRpb25zLmxlbmd0aCAtIDE7XG5cbiAgICBjb25zdCBzdGFydCA9IHF1ZXJ5LnN1YnN0cmluZyhwcmV2LCBtYXRjaC5mcm9tKTtcbiAgICBjb25zdCBlbmQgPSBpc0xhc3QgPyBxdWVyeS5zdWJzdHJpbmcobWF0Y2gudG8pIDogJyc7XG5cbiAgICBpZiAoIWxhYmVsRXhpc3RzKG1hdGNoLnF1ZXJ5LmxhYmVscywgZmlsdGVyKSkge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBhZGQgZHVwbGljYXRlIGxhYmVscy5cbiAgICAgIG1hdGNoLnF1ZXJ5LmxhYmVscy5wdXNoKGZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0xhYmVscyA9IG1vZGVsbGVyLnJlbmRlclF1ZXJ5KG1hdGNoLnF1ZXJ5KTtcbiAgICBuZXdRdWVyeSArPSBzdGFydCArIG5ld0xhYmVscyArIGVuZDtcbiAgICBwcmV2ID0gbWF0Y2gudG87XG4gIH1cbiAgcmV0dXJuIG5ld1F1ZXJ5O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGxhYmVsIGV4aXN0cyBpbiB0aGUgbGlzdCBvZiBsYWJlbHMgYnV0IGlnbm9yZSB0aGUgb3BlcmF0b3IuXG4gKiBAcGFyYW0gbGFiZWxzXG4gKiBAcGFyYW0gZmlsdGVyXG4gKi9cbmZ1bmN0aW9uIGxhYmVsRXhpc3RzKGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSwgZmlsdGVyOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcikge1xuICByZXR1cm4gbGFiZWxzLmZpbmQoKGxhYmVsKSA9PiBsYWJlbC5sYWJlbCA9PT0gZmlsdGVyLmxhYmVsICYmIGxhYmVsLnZhbHVlID09PSBmaWx0ZXIudmFsdWUpO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFF1ZXJ5RWRpdG9ySGVscFByb3BzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IENIRUFUX1NIRUVUX0lURU1TID0gW1xuICB7XG4gICAgdGl0bGU6ICdSZXF1ZXN0IFJhdGUnLFxuICAgIGV4cHJlc3Npb246ICdyYXRlKGh0dHBfcmVxdWVzdF90b3RhbFs1bV0pJyxcbiAgICBsYWJlbDpcbiAgICAgICdHaXZlbiBhbiBIVFRQIHJlcXVlc3QgY291bnRlciwgdGhpcyBxdWVyeSBjYWxjdWxhdGVzIHRoZSBwZXItc2Vjb25kIGF2ZXJhZ2UgcmVxdWVzdCByYXRlIG92ZXIgdGhlIGxhc3QgNSBtaW51dGVzLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJzk1dGggUGVyY2VudGlsZSBvZiBSZXF1ZXN0IExhdGVuY2llcycsXG4gICAgZXhwcmVzc2lvbjogJ2hpc3RvZ3JhbV9xdWFudGlsZSgwLjk1LCBzdW0ocmF0ZShwcm9tZXRoZXVzX2h0dHBfcmVxdWVzdF9kdXJhdGlvbl9zZWNvbmRzX2J1Y2tldFs1bV0pKSBieSAobGUpKScsXG4gICAgbGFiZWw6ICdDYWxjdWxhdGVzIHRoZSA5NXRoIHBlcmNlbnRpbGUgb2YgSFRUUCByZXF1ZXN0IHJhdGUgb3ZlciA1IG1pbnV0ZSB3aW5kb3dzLicsXG4gIH0sXG4gIHtcbiAgICB0aXRsZTogJ0FsZXJ0cyBGaXJpbmcnLFxuICAgIGV4cHJlc3Npb246ICdzb3J0X2Rlc2Moc3VtKHN1bV9vdmVyX3RpbWUoQUxFUlRTe2FsZXJ0c3RhdGU9XCJmaXJpbmdcIn1bMjRoXSkpIGJ5IChhbGVydG5hbWUpKScsXG4gICAgbGFiZWw6ICdTdW1zIHVwIHRoZSBhbGVydHMgdGhhdCBoYXZlIGJlZW4gZmlyaW5nIG92ZXIgdGhlIGxhc3QgMjQgaG91cnMuJyxcbiAgfSxcbiAge1xuICAgIHRpdGxlOiAnU3RlcCcsXG4gICAgbGFiZWw6XG4gICAgICAnRGVmaW5lcyB0aGUgZ3JhcGggcmVzb2x1dGlvbiB1c2luZyBhIGR1cmF0aW9uIGZvcm1hdCAoMTVzLCAxbSwgM2gsIC4uLikuIFNtYWxsIHN0ZXBzIGNyZWF0ZSBoaWdoLXJlc29sdXRpb24gZ3JhcGhzIGJ1dCBjYW4gYmUgc2xvdyBvdmVyIGxhcmdlciB0aW1lIHJhbmdlcy4gVXNpbmcgYSBsb25nZXIgc3RlcCBsb3dlcnMgdGhlIHJlc29sdXRpb24gYW5kIHNtb290aHMgdGhlIGdyYXBoIGJ5IHByb2R1Y2luZyBmZXdlciBkYXRhcG9pbnRzLiBJZiBubyBzdGVwIGlzIGdpdmVuIHRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseS4nLFxuICB9LFxuXTtcblxuY29uc3QgUHJvbUNoZWF0U2hlZXQgPSAocHJvcHM6IFF1ZXJ5RWRpdG9ySGVscFByb3BzPFByb21RdWVyeT4pID0+IChcbiAgPGRpdj5cbiAgICA8aDI+UHJvbVFMIENoZWF0IFNoZWV0PC9oMj5cbiAgICB7Q0hFQVRfU0hFRVRfSVRFTVMubWFwKChpdGVtLCBpbmRleCkgPT4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtXCIga2V5PXtpbmRleH0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fdGl0bGVcIj57aXRlbS50aXRsZX08L2Rpdj5cbiAgICAgICAge2l0ZW0uZXhwcmVzc2lvbiA/IChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjaGVhdC1zaGVldC1pdGVtX19leGFtcGxlXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiBwcm9wcy5vbkNsaWNrRXhhbXBsZSh7IHJlZklkOiAnQScsIGV4cHI6IGl0ZW0uZXhwcmVzc2lvbiB9KX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Y29kZT57aXRlbS5leHByZXNzaW9ufTwvY29kZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlYXQtc2hlZXQtaXRlbV9fbGFiZWxcIj57aXRlbS5sYWJlbH08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICkpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21DaGVhdFNoZWV0O1xuIiwiaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgSW5saW5lTGFiZWwsIFRvb2x0aXAsIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUHJldmlvdXMgfSBmcm9tICdyZWFjdC11c2UnO1xuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgb25DaGFuZ2U6IChleGVtcGxhcjogYm9vbGVhbikgPT4gdm9pZDtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIHF1ZXJ5OiBQcm9tUXVlcnk7XG4gICdkYXRhLXRlc3RpZCc/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm9tRXhlbXBsYXJGaWVsZCh7IGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBxdWVyeSwgLi4ucmVzdCB9OiBQcm9wcykge1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IHByZXZFcnJvciA9IHVzZVByZXZpb3VzKGVycm9yKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZGF0YXNvdXJjZS5leGVtcGxhcnNBdmFpbGFibGUpIHtcbiAgICAgIHNldEVycm9yKCdFeGVtcGxhcnMgZm9yIHRoaXMgcXVlcnkgYXJlIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgIG9uQ2hhbmdlKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHF1ZXJ5Lmluc3RhbnQgJiYgIXF1ZXJ5LnJhbmdlKSB7XG4gICAgICBzZXRFcnJvcignRXhlbXBsYXJzIGFyZSBub3QgYXZhaWxhYmxlIGZvciBpbnN0YW50IHF1ZXJpZXMnKTtcbiAgICAgIG9uQ2hhbmdlKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAvLyBJZiBlcnJvciBpcyBjbGVhcmVkLCB3ZSB3YW50IHRvIGNoYW5nZSBleGVtcGxhciB0byB0cnVlXG4gICAgICBpZiAocHJldkVycm9yICYmICFlcnJvcikge1xuICAgICAgICBvbkNoYW5nZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtkYXRhc291cmNlLmV4ZW1wbGFyc0F2YWlsYWJsZSwgcXVlcnkuaW5zdGFudCwgcXVlcnkucmFuZ2UsIG9uQ2hhbmdlLCBwcmV2RXJyb3IsIGVycm9yXSk7XG5cbiAgY29uc3QgaWNvbkJ1dHRvblN0eWxlcyA9IGN4KFxuICAgIHtcbiAgICAgIFtzdHlsZXMuYWN0aXZlSWNvbl06ICEhcXVlcnkuZXhlbXBsYXIsXG4gICAgfSxcbiAgICBzdHlsZXMuZXllSWNvblxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPElubGluZUxhYmVsIHdpZHRoPVwiYXV0b1wiIGRhdGEtdGVzdGlkPXtyZXN0WydkYXRhLXRlc3RpZCddfT5cbiAgICAgIDxUb29sdGlwIGNvbnRlbnQ9e2Vycm9yID8/ICcnfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pY29uV3JhcHBlcn0+XG4gICAgICAgICAgRXhlbXBsYXJzXG4gICAgICAgICAgPEljb25CdXR0b25cbiAgICAgICAgICAgIG5hbWU9XCJleWVcIlxuICAgICAgICAgICAgdG9vbHRpcD17ISFxdWVyeS5leGVtcGxhciA/ICdEaXNhYmxlIHF1ZXJ5IHdpdGggZXhlbXBsYXJzJyA6ICdFbmFibGUgcXVlcnkgd2l0aCBleGVtcGxhcnMnfVxuICAgICAgICAgICAgZGlzYWJsZWQ9eyEhZXJyb3J9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2ljb25CdXR0b25TdHlsZXN9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKCFxdWVyeS5leGVtcGxhcik7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9Ub29sdGlwPlxuICAgIDwvSW5saW5lTGFiZWw+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlcyh0aGVtZTogR3JhZmFuYVRoZW1lMikge1xuICByZXR1cm4ge1xuICAgIGV5ZUljb246IGNzc2BcbiAgICAgIG1hcmdpbi1sZWZ0OiAke3RoZW1lLnNwYWNpbmcoMil9O1xuICAgIGAsXG4gICAgYWN0aXZlSWNvbjogY3NzYFxuICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnByaW1hcnkubWFpbn07XG4gICAgYCxcbiAgICBpY29uV3JhcHBlcjogY3NzYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYCxcbiAgfTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBtZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVByZXZpb3VzIH0gZnJvbSAncmVhY3QtdXNlJztcbmltcG9ydCB7IGlzRXF1YWwgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgY3NzLCBjeCB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBJbmxpbmVGb3JtTGFiZWwsIFJhZGlvQnV0dG9uR3JvdXAgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBQcm9tUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBQcm9tRXhlbXBsYXJGaWVsZCB9IGZyb20gJy4vUHJvbUV4ZW1wbGFyRmllbGQnO1xuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9tRXhwbG9yZUV4dHJhRmllbGRQcm9wcyB7XG4gIHF1ZXJ5OiBQcm9tUXVlcnk7XG4gIG9uQ2hhbmdlOiAodmFsdWU6IFByb21RdWVyeSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG59XG5cbmV4cG9ydCBjb25zdCBQcm9tRXhwbG9yZUV4dHJhRmllbGQ6IFJlYWN0LkZDPFByb21FeHBsb3JlRXh0cmFGaWVsZFByb3BzPiA9IG1lbW8oXG4gICh7IHF1ZXJ5LCBkYXRhc291cmNlLCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VPcHRpb25zID0gZ2V0UXVlcnlUeXBlT3B0aW9ucyh0cnVlKTtcbiAgICBjb25zdCBwcmV2UXVlcnkgPSB1c2VQcmV2aW91cyhxdWVyeSk7XG5cbiAgICBjb25zdCBvbkV4ZW1wbGFyQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZXhlbXBsYXI6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKCFpc0VxdWFsKHF1ZXJ5LCBwcmV2UXVlcnkpIHx8IGV4ZW1wbGFyICE9PSBxdWVyeS5leGVtcGxhcikge1xuICAgICAgICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGV4ZW1wbGFyIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW3ByZXZRdWVyeSwgcXVlcnksIG9uQ2hhbmdlXVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZVF1ZXJ5U3RlcChpbnRlcnZhbDogc3RyaW5nKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBpbnRlcnZhbCB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblN0ZXBDaGFuZ2UoZTogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pIHtcbiAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQudmFsdWUgIT09IHF1ZXJ5LmludGVydmFsKSB7XG4gICAgICAgIG9uQ2hhbmdlUXVlcnlTdGVwKGUuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXR1cm5LZXlEb3duKGU6IFJlYWN0LktleWJvYXJkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pIHtcbiAgICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJyAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICAgIG9uUnVuUXVlcnkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvblF1ZXJ5VHlwZUNoYW5nZSA9IGdldFF1ZXJ5VHlwZUNoYW5nZUhhbmRsZXIocXVlcnksIG9uQ2hhbmdlKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XCJQcm9tZXRoZXVzIGV4dHJhIGZpZWxkXCIgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIiBkYXRhLXRlc3RpZD17dGVzdElkcy5leHRyYUZpZWxkRWRpdG9yfT5cbiAgICAgICAgey8qUXVlcnkgdHlwZSBmaWVsZCovfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMucXVlcnlUeXBlRmllbGR9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAgICdnZi1mb3JtIGV4cGxvcmUtaW5wdXQtbWFyZ2luJyxcbiAgICAgICAgICAgIGNzc2BcbiAgICAgICAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAgICAgICAgICBgXG4gICAgICAgICAgKX1cbiAgICAgICAgICBhcmlhLWxhYmVsPVwiUXVlcnkgdHlwZSBmaWVsZFwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIHdpZHRoPVwiYXV0b1wiPlF1ZXJ5IHR5cGU8L0lubGluZUZvcm1MYWJlbD5cblxuICAgICAgICAgIDxSYWRpb0J1dHRvbkdyb3VwXG4gICAgICAgICAgICBvcHRpb25zPXtyYW5nZU9wdGlvbnN9XG4gICAgICAgICAgICB2YWx1ZT17cXVlcnkucmFuZ2UgJiYgcXVlcnkuaW5zdGFudCA/ICdib3RoJyA6IHF1ZXJ5Lmluc3RhbnQgPyAnaW5zdGFudCcgOiAncmFuZ2UnfVxuICAgICAgICAgICAgb25DaGFuZ2U9e29uUXVlcnlUeXBlQ2hhbmdlfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7LypTdGVwIGZpZWxkKi99XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5zdGVwRmllbGR9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAgICdnZi1mb3JtJyxcbiAgICAgICAgICAgIGNzc2BcbiAgICAgICAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAgICAgICAgICBgXG4gICAgICAgICAgKX1cbiAgICAgICAgICBhcmlhLWxhYmVsPVwiU3RlcCBmaWVsZFwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsXG4gICAgICAgICAgICB3aWR0aD17Nn1cbiAgICAgICAgICAgIHRvb2x0aXA9e1xuICAgICAgICAgICAgICAnVGltZSB1bml0cyBhbmQgYnVpbHQtaW4gdmFyaWFibGVzIGNhbiBiZSB1c2VkIGhlcmUsIGZvciBleGFtcGxlOiAkX19pbnRlcnZhbCwgJF9fcmF0ZV9pbnRlcnZhbCwgNXMsIDFtLCAzaCwgMWQsIDF5IChEZWZhdWx0IGlmIG5vIHVuaXQgaXMgc3BlY2lmaWVkOiBzKSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBNaW4gc3RlcFxuICAgICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdHlwZT17J3RleHQnfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbnB1dCB3aWR0aC00XCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXsnYXV0byd9XG4gICAgICAgICAgICBvbkNoYW5nZT17b25TdGVwQ2hhbmdlfVxuICAgICAgICAgICAgb25LZXlEb3duPXtvblJldHVybktleURvd259XG4gICAgICAgICAgICB2YWx1ZT17cXVlcnkuaW50ZXJ2YWwgPz8gJyd9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPFByb21FeGVtcGxhckZpZWxkIG9uQ2hhbmdlPXtvbkV4ZW1wbGFyQ2hhbmdlfSBkYXRhc291cmNlPXtkYXRhc291cmNlfSBxdWVyeT17cXVlcnl9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4pO1xuXG5Qcm9tRXhwbG9yZUV4dHJhRmllbGQuZGlzcGxheU5hbWUgPSAnUHJvbUV4cGxvcmVFeHRyYUZpZWxkJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFF1ZXJ5VHlwZU9wdGlvbnMoaW5jbHVkZUJvdGg6IGJvb2xlYW4pIHtcbiAgY29uc3QgcmFuZ2VPcHRpb25zID0gW1xuICAgIHsgdmFsdWU6ICdyYW5nZScsIGxhYmVsOiAnUmFuZ2UnLCBkZXNjcmlwdGlvbjogJ1J1biBxdWVyeSBvdmVyIGEgcmFuZ2Ugb2YgdGltZScgfSxcbiAgICB7XG4gICAgICB2YWx1ZTogJ2luc3RhbnQnLFxuICAgICAgbGFiZWw6ICdJbnN0YW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUnVuIHF1ZXJ5IGFnYWluc3QgYSBzaW5nbGUgcG9pbnQgaW4gdGltZS4gRm9yIHRoaXMgcXVlcnksIHRoZSBcIlRvXCIgdGltZSBpcyB1c2VkJyxcbiAgICB9LFxuICBdO1xuXG4gIGlmIChpbmNsdWRlQm90aCkge1xuICAgIHJhbmdlT3B0aW9ucy5wdXNoKHsgdmFsdWU6ICdib3RoJywgbGFiZWw6ICdCb3RoJywgZGVzY3JpcHRpb246ICdSdW4gYW4gSW5zdGFudCBxdWVyeSBhbmQgYSBSYW5nZSBxdWVyeScgfSk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2VPcHRpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVlcnlUeXBlQ2hhbmdlSGFuZGxlcihxdWVyeTogUHJvbVF1ZXJ5LCBvbkNoYW5nZTogKHVwZGF0ZTogUHJvbVF1ZXJ5KSA9PiB2b2lkKSB7XG4gIHJldHVybiAocXVlcnlUeXBlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocXVlcnlUeXBlID09PSAnaW5zdGFudCcpIHtcbiAgICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGluc3RhbnQ6IHRydWUsIHJhbmdlOiBmYWxzZSwgZXhlbXBsYXI6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSBpZiAocXVlcnlUeXBlID09PSAncmFuZ2UnKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBpbnN0YW50OiBmYWxzZSwgcmFuZ2U6IHRydWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGluc3RhbnQ6IHRydWUsIHJhbmdlOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHRlc3RJZHMgPSB7XG4gIGV4dHJhRmllbGRFZGl0b3I6ICdwcm9tLWVkaXRvci1leHRyYS1maWVsZCcsXG4gIHN0ZXBGaWVsZDogJ3Byb20tZWRpdG9yLWV4dHJhLWZpZWxkLXN0ZXAnLFxuICBxdWVyeVR5cGVGaWVsZDogJ3Byb20tZWRpdG9yLWV4dHJhLWZpZWxkLXF1ZXJ5LXR5cGUnLFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyBtZW1vLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBRdWVyeUVkaXRvclByb3BzLCBDb3JlQXBwIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5LCBQcm9tT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBQcm9tUXVlcnlGaWVsZCBmcm9tICcuL1Byb21RdWVyeUZpZWxkJztcbmltcG9ydCB7IFByb21FeHBsb3JlRXh0cmFGaWVsZCB9IGZyb20gJy4vUHJvbUV4cGxvcmVFeHRyYUZpZWxkJztcblxuZXhwb3J0IHR5cGUgUHJvcHMgPSBRdWVyeUVkaXRvclByb3BzPFByb21ldGhldXNEYXRhc291cmNlLCBQcm9tUXVlcnksIFByb21PcHRpb25zPjtcblxuZXhwb3J0IGNvbnN0IFByb21FeHBsb3JlUXVlcnlFZGl0b3IgPSBtZW1vKChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyByYW5nZSwgcXVlcnksIGRhdGEsIGRhdGFzb3VyY2UsIGhpc3RvcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSBwcm9wcztcblxuICAvLyBTZXR0aW5nIGRlZmF1bHQgdmFsdWVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHF1ZXJ5LmV4cHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgZXhwcjogJycgfSk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5leGVtcGxhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBleGVtcGxhcjogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBxdWVyeSB0eXBlIHRvIFwiQm90aFwiIG9ubHkgZm9yIG5ldyBxdWVyaWVzIChubyBxdWVyeS5leHByKS5cbiAgICBpZiAoIXF1ZXJ5Lmluc3RhbnQgJiYgIXF1ZXJ5LnJhbmdlICYmICFxdWVyeS5leHByKSB7XG4gICAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBpbnN0YW50OiB0cnVlLCByYW5nZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0sIFtvbkNoYW5nZSwgcXVlcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxQcm9tUXVlcnlGaWVsZFxuICAgICAgYXBwPXtDb3JlQXBwLkV4cGxvcmV9XG4gICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgcmFuZ2U9e3JhbmdlfVxuICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uQmx1cj17KCkgPT4ge319XG4gICAgICBoaXN0b3J5PXtoaXN0b3J5fVxuICAgICAgZGF0YT17ZGF0YX1cbiAgICAgIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLmVkaXRvcn1cbiAgICAgIEV4dHJhRmllbGRFbGVtZW50PXtcbiAgICAgICAgPFByb21FeHBsb3JlRXh0cmFGaWVsZCBxdWVyeT17cXVlcnl9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0gb25SdW5RdWVyeT17b25SdW5RdWVyeX0gLz5cbiAgICAgIH1cbiAgICAvPlxuICApO1xufSk7XG5cblByb21FeHBsb3JlUXVlcnlFZGl0b3IuZGlzcGxheU5hbWUgPSAnUHJvbUV4cGxvcmVRdWVyeUVkaXRvcic7XG5cbmV4cG9ydCBjb25zdCB0ZXN0SWRzID0ge1xuICBlZGl0b3I6ICdwcm9tLWVkaXRvci1leHBsb3JlJyxcbn07XG4iLCJpbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IEZDLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRGF0YVF1ZXJ5UmVxdWVzdCwgUGFuZWxEYXRhLCBTY29wZWRWYXJzLCB0ZXh0VXRpbCwgcmFuZ2VVdGlsIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlO1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuICBwYW5lbERhdGE/OiBQYW5lbERhdGE7XG59XG5cbmNvbnN0IFByb21MaW5rOiBGQzxQcm9wcz4gPSAoeyBwYW5lbERhdGEsIHF1ZXJ5LCBkYXRhc291cmNlIH0pID0+IHtcbiAgY29uc3QgW2hyZWYsIHNldEhyZWZdID0gdXNlU3RhdGUoJycpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHBhbmVsRGF0YSkge1xuICAgICAgY29uc3QgZ2V0RXh0ZXJuYWxMaW5rID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXBhbmVsRGF0YS5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlcXVlc3Q6IHsgcmFuZ2UsIGludGVydmFsLCBzY29wZWRWYXJzIH0sXG4gICAgICAgIH0gPSBwYW5lbERhdGE7XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBkYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICAgICAgY29uc3QgZW5kID0gZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZShyYW5nZS50bywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJhbmdlRGlmZiA9IE1hdGguY2VpbChlbmQgLSBzdGFydCk7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSByYW5nZS50by51dGMoKS5mb3JtYXQoJ1lZWVktTU0tREQgSEg6bW0nKTtcblxuICAgICAgICBjb25zdCBlbnJpY2hlZFNjb3BlZFZhcnM6IFNjb3BlZFZhcnMgPSB7XG4gICAgICAgICAgLi4uc2NvcGVkVmFycyxcbiAgICAgICAgICAvLyBBcyB3ZSBzdXBwb3J0ICRfX3JhdGVfaW50ZXJ2YWwgdmFyaWFibGUgaW4gbWluIHN0ZXAsIHdlIG5lZWQgYWRkIGl0IHRvIHNjb3BlZFZhcnNcbiAgICAgICAgICAuLi5kYXRhc291cmNlLmdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKFxuICAgICAgICAgICAgcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKGludGVydmFsKSxcbiAgICAgICAgICAgIHJhbmdlVXRpbC5pbnRlcnZhbFRvU2Vjb25kcyhkYXRhc291cmNlLmludGVydmFsKVxuICAgICAgICAgICksXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgICBzY29wZWRWYXJzOiBlbnJpY2hlZFNjb3BlZFZhcnMsXG4gICAgICAgIH0gYXMgRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+O1xuXG4gICAgICAgIGNvbnN0IGN1c3RvbVF1ZXJ5UGFyYW1ldGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICBpZiAoZGF0YXNvdXJjZS5jdXN0b21RdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBkYXRhc291cmNlLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgICAgICAgY3VzdG9tUXVlcnlQYXJhbWV0ZXJzW2tdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSBkYXRhc291cmNlLmNyZWF0ZVF1ZXJ5KHF1ZXJ5LCBvcHRpb25zLCBzdGFydCwgZW5kKTtcblxuICAgICAgICBjb25zdCBleHByID0ge1xuICAgICAgICAgIC4uLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAnZzAuZXhwcic6IHF1ZXJ5T3B0aW9ucy5leHByLFxuICAgICAgICAgICdnMC5yYW5nZV9pbnB1dCc6IHJhbmdlRGlmZiArICdzJyxcbiAgICAgICAgICAnZzAuZW5kX2lucHV0JzogZW5kVGltZSxcbiAgICAgICAgICAnZzAuc3RlcF9pbnB1dCc6IHF1ZXJ5T3B0aW9ucy5zdGVwLFxuICAgICAgICAgICdnMC50YWInOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBtYXAoZXhwciwgKHY6IHN0cmluZywgazogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGsgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodik7XG4gICAgICAgIH0pLmpvaW4oJyYnKTtcbiAgICAgICAgcmV0dXJuIGAke2RhdGFzb3VyY2UuZGlyZWN0VXJsfS9ncmFwaD8ke2FyZ3N9YDtcbiAgICAgIH07XG5cbiAgICAgIHNldEhyZWYoZ2V0RXh0ZXJuYWxMaW5rKCkpO1xuICAgIH1cbiAgfSwgW2RhdGFzb3VyY2UsIHBhbmVsRGF0YSwgcXVlcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxhIGhyZWY9e3RleHRVdGlsLnNhbml0aXplVXJsKGhyZWYpfSB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCI+XG4gICAgICBQcm9tZXRoZXVzXG4gICAgPC9hPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWVtbyhQcm9tTGluayk7XG4iLCJpbXBvcnQgeyBtYXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbi8vIFR5cGVzXG5pbXBvcnQgeyBJbmxpbmVGb3JtTGFiZWwsIExlZ2FjeUZvcm1zLCBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBDb3JlQXBwLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IFByb21RdWVyeUZpZWxkIGZyb20gJy4vUHJvbVF1ZXJ5RmllbGQnO1xuaW1wb3J0IFByb21MaW5rIGZyb20gJy4vUHJvbUxpbmsnO1xuaW1wb3J0IHsgUHJvbUV4ZW1wbGFyRmllbGQgfSBmcm9tICcuL1Byb21FeGVtcGxhckZpZWxkJztcbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IHsgU3dpdGNoIH0gPSBMZWdhY3lGb3JtcztcblxuZXhwb3J0IGNvbnN0IEZPUk1BVF9PUFRJT05TOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPj4gPSBbXG4gIHsgbGFiZWw6ICdUaW1lIHNlcmllcycsIHZhbHVlOiAndGltZV9zZXJpZXMnIH0sXG4gIHsgbGFiZWw6ICdUYWJsZScsIHZhbHVlOiAndGFibGUnIH0sXG4gIHsgbGFiZWw6ICdIZWF0bWFwJywgdmFsdWU6ICdoZWF0bWFwJyB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IElOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TOiBBcnJheTxTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPj4gPSBtYXAoWzEsIDIsIDMsIDQsIDUsIDEwXSwgKHZhbHVlOiBudW1iZXIpID0+ICh7XG4gIHZhbHVlLFxuICBsYWJlbDogJzEvJyArIHZhbHVlLFxufSkpO1xuXG5pbnRlcmZhY2UgU3RhdGUge1xuICBsZWdlbmRGb3JtYXQ/OiBzdHJpbmc7XG4gIGZvcm1hdE9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPHN0cmluZz47XG4gIGludGVydmFsPzogc3RyaW5nO1xuICBpbnRlcnZhbEZhY3Rvck9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPG51bWJlcj47XG4gIGluc3RhbnQ6IGJvb2xlYW47XG4gIGV4ZW1wbGFyOiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgUHJvbVF1ZXJ5RWRpdG9yIGV4dGVuZHMgUHVyZUNvbXBvbmVudDxQcm9tUXVlcnlFZGl0b3JQcm9wcywgU3RhdGU+IHtcbiAgLy8gUXVlcnkgdGFyZ2V0IHRvIGJlIG1vZGlmaWVkIGFuZCB1c2VkIGZvciBxdWVyaWVzXG4gIHF1ZXJ5OiBQcm9tUXVlcnk7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFByb21RdWVyeUVkaXRvclByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIC8vIFVzZSBkZWZhdWx0IHF1ZXJ5IHRvIHByZXZlbnQgdW5kZWZpbmVkIGlucHV0IHZhbHVlc1xuICAgIGNvbnN0IGRlZmF1bHRRdWVyeTogUGFydGlhbDxQcm9tUXVlcnk+ID0ge1xuICAgICAgZXhwcjogJycsXG4gICAgICBsZWdlbmRGb3JtYXQ6ICcnLFxuICAgICAgaW50ZXJ2YWw6ICcnLFxuICAgICAgLy8gU2V0IGV4ZW1wbGFyIHRvIGZhbHNlIGZvciBhbGVydGluZyBxdWVyaWVzXG4gICAgICBleGVtcGxhcjogcHJvcHMuYXBwID09PSBDb3JlQXBwLlVuaWZpZWRBbGVydGluZyA/IGZhbHNlIDogdHJ1ZSxcbiAgICB9O1xuICAgIGNvbnN0IHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFF1ZXJ5LCBwcm9wcy5xdWVyeSk7XG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIC8vIFF1ZXJ5IHRhcmdldCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGZ1bGx5IGNvbnRyb2xsZWQgaW5wdXRzXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIEZ1bGx5IGNvbnRyb2xsZWQgdGV4dCBpbnB1dHNcbiAgICAgIGludGVydmFsOiBxdWVyeS5pbnRlcnZhbCxcbiAgICAgIGxlZ2VuZEZvcm1hdDogcXVlcnkubGVnZW5kRm9ybWF0LFxuICAgICAgLy8gU2VsZWN0IG9wdGlvbnNcbiAgICAgIGZvcm1hdE9wdGlvbjogRk9STUFUX09QVElPTlMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUgPT09IHF1ZXJ5LmZvcm1hdCkgfHwgRk9STUFUX09QVElPTlNbMF0sXG4gICAgICBpbnRlcnZhbEZhY3Rvck9wdGlvbjpcbiAgICAgICAgSU5URVJWQUxfRkFDVE9SX09QVElPTlMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUgPT09IHF1ZXJ5LmludGVydmFsRmFjdG9yKSB8fCBJTlRFUlZBTF9GQUNUT1JfT1BUSU9OU1swXSxcbiAgICAgIC8vIFN3aXRjaCBvcHRpb25zXG4gICAgICBpbnN0YW50OiBCb29sZWFuKHF1ZXJ5Lmluc3RhbnQpLFxuICAgICAgZXhlbXBsYXI6IEJvb2xlYW4ocXVlcnkuZXhlbXBsYXIpLFxuICAgIH07XG4gIH1cblxuICBvbkZpZWxkQ2hhbmdlID0gKHF1ZXJ5OiBQcm9tUXVlcnksIG92ZXJyaWRlPzogYW55KSA9PiB7XG4gICAgdGhpcy5xdWVyeS5leHByID0gcXVlcnkuZXhwcjtcbiAgfTtcblxuICBvbkZvcm1hdENoYW5nZSA9IChvcHRpb246IFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+KSA9PiB7XG4gICAgdGhpcy5xdWVyeS5mb3JtYXQgPSBvcHRpb24udmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvcm1hdE9wdGlvbjogb3B0aW9uIH0sIHRoaXMub25SdW5RdWVyeSk7XG4gIH07XG5cbiAgb25JbnN0YW50Q2hhbmdlID0gKGU6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgaW5zdGFudCA9IChlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkO1xuICAgIHRoaXMucXVlcnkuaW5zdGFudCA9IGluc3RhbnQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGluc3RhbnQgfSwgdGhpcy5vblJ1blF1ZXJ5KTtcbiAgfTtcblxuICBvbkludGVydmFsQ2hhbmdlID0gKGU6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gICAgdGhpcy5xdWVyeS5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBpbnRlcnZhbCB9KTtcbiAgfTtcblxuICBvbkludGVydmFsRmFjdG9yQ2hhbmdlID0gKG9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPG51bWJlcj4pID0+IHtcbiAgICB0aGlzLnF1ZXJ5LmludGVydmFsRmFjdG9yID0gb3B0aW9uLnZhbHVlO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBpbnRlcnZhbEZhY3Rvck9wdGlvbjogb3B0aW9uIH0sIHRoaXMub25SdW5RdWVyeSk7XG4gIH07XG5cbiAgb25MZWdlbmRDaGFuZ2UgPSAoZTogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBsZWdlbmRGb3JtYXQgPSBlLmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gICAgdGhpcy5xdWVyeS5sZWdlbmRGb3JtYXQgPSBsZWdlbmRGb3JtYXQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxlZ2VuZEZvcm1hdCB9KTtcbiAgfTtcblxuICBvbkV4ZW1wbGFyQ2hhbmdlID0gKGlzRW5hYmxlZDogYm9vbGVhbikgPT4ge1xuICAgIHRoaXMucXVlcnkuZXhlbXBsYXIgPSBpc0VuYWJsZWQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGV4ZW1wbGFyOiBpc0VuYWJsZWQgfSwgdGhpcy5vblJ1blF1ZXJ5KTtcbiAgfTtcblxuICBvblJ1blF1ZXJ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcXVlcnkgfSA9IHRoaXM7XG4gICAgLy8gQ2hhbmdlIG9mIHF1ZXJ5LmhpZGUgaGFwcGVucyBvdXRzaWRlIG9mIHRoaXMgY29tcG9uZW50IGFuZCBpcyBqdXN0IHBhc3NlZCBhcyBwcm9wLiBXZSBoYXZlIHRvIHVwZGF0ZSBpdCB3aGVuIHJ1bm5pbmcgcXVlcmllcy5cbiAgICBjb25zdCB7IGhpZGUgfSA9IHRoaXMucHJvcHMucXVlcnk7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7IC4uLnF1ZXJ5LCBoaWRlIH0pO1xuICAgIHRoaXMucHJvcHMub25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRhdGFzb3VyY2UsIHF1ZXJ5LCByYW5nZSwgZGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGZvcm1hdE9wdGlvbiwgaW5zdGFudCwgaW50ZXJ2YWwsIGludGVydmFsRmFjdG9yT3B0aW9uLCBsZWdlbmRGb3JtYXQgfSA9IHRoaXMuc3RhdGU7XG4gICAgLy9XZSB3YW50IHRvIGhpZGUgZXhlbXBsYXIgZmllbGQgZm9yIHVuaWZpZWQgYWxlcnRpbmcgYXMgZXhlbXBsYXJzIGluIGFsZXJ0aW5nIGRvbid0IG1ha2Ugc2Vuc2UgYW5kIGFyZSBzb3VyY2Ugb2YgY29uZnVzaW9uXG4gICAgY29uc3Qgc2hvd0V4ZW1wbGFyRmllbGQgPSB0aGlzLnByb3BzLmFwcCAhPT0gQ29yZUFwcC5VbmlmaWVkQWxlcnRpbmc7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFByb21RdWVyeUZpZWxkXG4gICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgcmFuZ2U9e3JhbmdlfVxuICAgICAgICBvblJ1blF1ZXJ5PXt0aGlzLm9uUnVuUXVlcnl9XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uRmllbGRDaGFuZ2V9XG4gICAgICAgIGhpc3Rvcnk9e1tdfVxuICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICBkYXRhLXRlc3RpZD17dGVzdElkcy5lZGl0b3J9XG4gICAgICAgIEV4dHJhRmllbGRFbGVtZW50PXtcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbFxuICAgICAgICAgICAgICAgIHdpZHRoPXs3fVxuICAgICAgICAgICAgICAgIHRvb2x0aXA9XCJDb250cm9scyB0aGUgbmFtZSBvZiB0aGUgdGltZSBzZXJpZXMsIHVzaW5nIG5hbWUgb3IgcGF0dGVybi4gRm9yIGV4YW1wbGVcbiAgICAgICAge3tob3N0bmFtZX19IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBsYWJlbCB2YWx1ZSBmb3IgdGhlIGxhYmVsIGhvc3RuYW1lLlwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBMZWdlbmRcbiAgICAgICAgICAgICAgPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZi1mb3JtLWlucHV0XCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cImxlZ2VuZCBmb3JtYXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtsZWdlbmRGb3JtYXR9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25MZWdlbmRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgb25CbHVyPXt0aGlzLm9uUnVuUXVlcnl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWxcbiAgICAgICAgICAgICAgICB3aWR0aD17N31cbiAgICAgICAgICAgICAgICB0b29sdGlwPXtcbiAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIEFuIGFkZGl0aW9uYWwgbG93ZXIgbGltaXQgZm9yIHRoZSBzdGVwIHBhcmFtZXRlciBvZiB0aGUgUHJvbWV0aGV1cyBxdWVyeSBhbmQgZm9yIHRoZXsnICd9XG4gICAgICAgICAgICAgICAgICAgIDxjb2RlPiRfX2ludGVydmFsPC9jb2RlPiBhbmQgPGNvZGU+JF9fcmF0ZV9pbnRlcnZhbDwvY29kZT4gdmFyaWFibGVzLiBUaGUgbGltaXQgaXMgYWJzb2x1dGUgYW5kIG5vdFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCBieSB0aGUgJnF1b3Q7UmVzb2x1dGlvbiZxdW90OyBzZXR0aW5nLlxuICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgTWluIHN0ZXBcbiAgICAgICAgICAgICAgPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJnZi1mb3JtLWlucHV0IHdpZHRoLThcIlxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZXQgbG93ZXIgbGltaXQgZm9yIHRoZSBzdGVwIHBhcmFtZXRlclwiXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2ludGVydmFsfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uSW50ZXJ2YWxDaGFuZ2V9XG4gICAgICAgICAgICAgICAgb25CbHVyPXt0aGlzLm9uUnVuUXVlcnl9XG4gICAgICAgICAgICAgICAgdmFsdWU9e2ludGVydmFsfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tbGFiZWxcIj5SZXNvbHV0aW9uPC9kaXY+XG4gICAgICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiU2VsZWN0IHJlc29sdXRpb25cIlxuICAgICAgICAgICAgICAgIG1lbnVTaG91bGRQb3J0YWxcbiAgICAgICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e0lOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uSW50ZXJ2YWxGYWN0b3JDaGFuZ2V9XG4gICAgICAgICAgICAgICAgdmFsdWU9e2ludGVydmFsRmFjdG9yT3B0aW9ufVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tbGFiZWwgd2lkdGgtN1wiPkZvcm1hdDwvZGl2PlxuICAgICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgbWVudVNob3VsZFBvcnRhbFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNlbGVjdC1jb250YWluZXJcIlxuICAgICAgICAgICAgICAgIHdpZHRoPXsxNn1cbiAgICAgICAgICAgICAgICBpc1NlYXJjaGFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e0ZPUk1BVF9PUFRJT05TfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uRm9ybWF0Q2hhbmdlfVxuICAgICAgICAgICAgICAgIHZhbHVlPXtmb3JtYXRPcHRpb259XG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNlbGVjdCBmb3JtYXRcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8U3dpdGNoIGxhYmVsPVwiSW5zdGFudFwiIGNoZWNrZWQ9e2luc3RhbnR9IG9uQ2hhbmdlPXt0aGlzLm9uSW5zdGFudENoYW5nZX0gLz5cblxuICAgICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIHdpZHRoPXsxMH0gdG9vbHRpcD1cIkxpbmsgdG8gR3JhcGggaW4gUHJvbWV0aGV1c1wiPlxuICAgICAgICAgICAgICAgIDxQcm9tTGlua1xuICAgICAgICAgICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICAgICAgICAgIHF1ZXJ5PXt0aGlzLnF1ZXJ5fSAvLyBVc2UgbW9kaWZpZWQgcXVlcnlcbiAgICAgICAgICAgICAgICAgIHBhbmVsRGF0YT17ZGF0YX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3Nob3dFeGVtcGxhckZpZWxkICYmIChcbiAgICAgICAgICAgICAgPFByb21FeGVtcGxhckZpZWxkXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25FeGVtcGxhckNoYW5nZX1cbiAgICAgICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgICAgIHF1ZXJ5PXt0aGlzLnF1ZXJ5fVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLmV4ZW1wbGFyfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgfVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0ZXN0SWRzID0ge1xuICBlZGl0b3I6ICdwcm9tLWVkaXRvcicsXG4gIGV4ZW1wbGFyOiAnZXhlbXBsYXItZWRpdG9yJyxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENvcmVBcHAgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBQcm9tUXVlcnlFZGl0b3IgfSBmcm9tICcuL1Byb21RdWVyeUVkaXRvcic7XG5pbXBvcnQgeyBQcm9tUXVlcnlFZGl0b3JGb3JBbGVydGluZyB9IGZyb20gJy4vUHJvbVF1ZXJ5RWRpdG9yRm9yQWxlcnRpbmcnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGdyYWZhbmEvcnVudGltZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnlFZGl0b3JTZWxlY3RvciB9IGZyb20gJy4uL3F1ZXJ5YnVpbGRlci9jb21wb25lbnRzL1Byb21RdWVyeUVkaXRvclNlbGVjdG9yJztcbmltcG9ydCB7IFByb21FeHBsb3JlUXVlcnlFZGl0b3IgfSBmcm9tICcuL1Byb21FeHBsb3JlUXVlcnlFZGl0b3InO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvbVF1ZXJ5RWRpdG9yQnlBcHAocHJvcHM6IFByb21RdWVyeUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IHsgYXBwIH0gPSBwcm9wcztcblxuICBzd2l0Y2ggKGFwcCkge1xuICAgIGNhc2UgQ29yZUFwcC5DbG91ZEFsZXJ0aW5nOlxuICAgICAgcmV0dXJuIDxQcm9tUXVlcnlFZGl0b3JGb3JBbGVydGluZyB7Li4ucHJvcHN9IC8+O1xuICAgIGNhc2UgQ29yZUFwcC5FeHBsb3JlOlxuICAgICAgaWYgKGNvbmZpZy5mZWF0dXJlVG9nZ2xlcy5wcm9tUXVlcnlCdWlsZGVyKSB7XG4gICAgICAgIHJldHVybiA8UHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3Igey4uLnByb3BzfSAvPjtcbiAgICAgIH1cbiAgICAgIHJldHVybiA8UHJvbUV4cGxvcmVRdWVyeUVkaXRvciB7Li4ucHJvcHN9IC8+O1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY29uZmlnLmZlYXR1cmVUb2dnbGVzLnByb21RdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgcmV0dXJuIDxQcm9tUXVlcnlFZGl0b3JTZWxlY3RvciB7Li4ucHJvcHN9IC8+O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDxQcm9tUXVlcnlFZGl0b3Igey4uLnByb3BzfSAvPjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vKFByb21RdWVyeUVkaXRvckJ5QXBwKTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvbVF1ZXJ5RmllbGQgZnJvbSAnLi9Qcm9tUXVlcnlGaWVsZCc7XG5pbXBvcnQgeyBQcm9tUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvbVF1ZXJ5RWRpdG9yRm9yQWxlcnRpbmcocHJvcHM6IFByb21RdWVyeUVkaXRvclByb3BzKSB7XG4gIGNvbnN0IHsgZGF0YXNvdXJjZSwgcXVlcnksIHJhbmdlLCBkYXRhLCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8UHJvbVF1ZXJ5RmllbGRcbiAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICBxdWVyeT17cXVlcnl9XG4gICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgaGlzdG9yeT17W119XG4gICAgICByYW5nZT17cmFuZ2V9XG4gICAgICBkYXRhPXtkYXRhfVxuICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZWRpdG9yfVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCB0ZXN0SWRzID0ge1xuICBlZGl0b3I6ICdwcm9tLWVkaXRvci1jbG91ZC1hbGVydGluZycsXG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IHtcbiAgU2xhdGVQcmlzbSxcbiAgVHlwZWFoZWFkSW5wdXQsXG4gIFR5cGVhaGVhZE91dHB1dCxcbiAgQnJhY2VzUGx1Z2luLFxuICBET01VdGlsLFxuICBTdWdnZXN0aW9uc1N0YXRlLFxuICBJY29uLFxufSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbmltcG9ydCB7IExhbmd1YWdlTWFwLCBsYW5ndWFnZXMgYXMgcHJpc21MYW5ndWFnZXMgfSBmcm9tICdwcmlzbWpzJztcblxuLy8gZG9tIGFsc28gaW5jbHVkZXMgRWxlbWVudCBwb2x5ZmlsbHNcbmltcG9ydCB7IFByb21RdWVyeSwgUHJvbU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyByb3VuZE1zVG9NaW4gfSBmcm9tICcuLi9sYW5ndWFnZV91dGlscyc7XG5pbXBvcnQgeyBDYW5jZWxhYmxlUHJvbWlzZSwgbWFrZVByb21pc2VDYW5jZWxhYmxlIH0gZnJvbSAnYXBwL2NvcmUvdXRpbHMvQ2FuY2VsYWJsZVByb21pc2UnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JQcm9wcywgUXVlcnlIaW50LCBpc0RhdGFGcmFtZSwgdG9MZWdhY3lSZXNwb25zZURhdGEsIFRpbWVSYW5nZSwgQ29yZUFwcCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi9kYXRhc291cmNlJztcbmltcG9ydCB7IFByb21ldGhldXNNZXRyaWNzQnJvd3NlciB9IGZyb20gJy4vUHJvbWV0aGV1c01ldHJpY3NCcm93c2VyJztcbmltcG9ydCB7IE1vbmFjb1F1ZXJ5RmllbGRXcmFwcGVyIH0gZnJvbSAnLi9tb25hY28tcXVlcnktZmllbGQvTW9uYWNvUXVlcnlGaWVsZFdyYXBwZXInO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlciB9IGZyb20gJ2FwcC9jb3JlL2NvbXBvbmVudHMvTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlcic7XG5cbmV4cG9ydCBjb25zdCBSRUNPUkRJTkdfUlVMRVNfR1JPVVAgPSAnX19yZWNvcmRpbmdfcnVsZXNfXyc7XG5jb25zdCBMQVNUX1VTRURfTEFCRUxTX0tFWSA9ICdncmFmYW5hLmRhdGFzb3VyY2VzLnByb21ldGhldXMuYnJvd3Nlci5sYWJlbHMnO1xuXG5mdW5jdGlvbiBnZXRDaG9vc2VyVGV4dChtZXRyaWNzTG9va3VwRGlzYWJsZWQ6IGJvb2xlYW4sIGhhc1N5bnRheDogYm9vbGVhbiwgaGFzTWV0cmljczogYm9vbGVhbikge1xuICBpZiAobWV0cmljc0xvb2t1cERpc2FibGVkKSB7XG4gICAgcmV0dXJuICcoRGlzYWJsZWQpJztcbiAgfVxuXG4gIGlmICghaGFzU3ludGF4KSB7XG4gICAgcmV0dXJuICdMb2FkaW5nIG1ldHJpY3MuLi4nO1xuICB9XG5cbiAgaWYgKCFoYXNNZXRyaWNzKSB7XG4gICAgcmV0dXJuICcoTm8gbWV0cmljcyBmb3VuZCknO1xuICB9XG5cbiAgcmV0dXJuICdNZXRyaWNzIGJyb3dzZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2lsbEFwcGx5U3VnZ2VzdGlvbihzdWdnZXN0aW9uOiBzdHJpbmcsIHsgdHlwZWFoZWFkQ29udGV4dCwgdHlwZWFoZWFkVGV4dCB9OiBTdWdnZXN0aW9uc1N0YXRlKTogc3RyaW5nIHtcbiAgLy8gTW9kaWZ5IHN1Z2dlc3Rpb24gYmFzZWQgb24gY29udGV4dFxuICBzd2l0Y2ggKHR5cGVhaGVhZENvbnRleHQpIHtcbiAgICBjYXNlICdjb250ZXh0LWxhYmVscyc6IHtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gRE9NVXRpbC5nZXROZXh0Q2hhcmFjdGVyKCk7XG4gICAgICBpZiAoIW5leHRDaGFyIHx8IG5leHRDaGFyID09PSAnfScgfHwgbmV4dENoYXIgPT09ICcsJykge1xuICAgICAgICBzdWdnZXN0aW9uICs9ICc9JztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ2NvbnRleHQtbGFiZWwtdmFsdWVzJzoge1xuICAgICAgLy8gQWx3YXlzIGFkZCBxdW90ZXMgYW5kIHJlbW92ZSBleGlzdGluZyBvbmVzIGluc3RlYWRcbiAgICAgIGlmICghdHlwZWFoZWFkVGV4dC5tYXRjaCgvXighPz1+P1wifFwiKS8pKSB7XG4gICAgICAgIHN1Z2dlc3Rpb24gPSBgXCIke3N1Z2dlc3Rpb259YDtcbiAgICAgIH1cbiAgICAgIGlmIChET01VdGlsLmdldE5leHRDaGFyYWN0ZXIoKSAhPT0gJ1wiJykge1xuICAgICAgICBzdWdnZXN0aW9uID0gYCR7c3VnZ2VzdGlvbn1cImA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiBzdWdnZXN0aW9uO1xufVxuXG5pbnRlcmZhY2UgUHJvbVF1ZXJ5RmllbGRQcm9wcyBleHRlbmRzIFF1ZXJ5RWRpdG9yUHJvcHM8UHJvbWV0aGV1c0RhdGFzb3VyY2UsIFByb21RdWVyeSwgUHJvbU9wdGlvbnM+IHtcbiAgRXh0cmFGaWVsZEVsZW1lbnQ/OiBSZWFjdE5vZGU7XG4gICdkYXRhLXRlc3RpZCc/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBQcm9tUXVlcnlGaWVsZFN0YXRlIHtcbiAgbGFiZWxCcm93c2VyVmlzaWJsZTogYm9vbGVhbjtcbiAgc3ludGF4TG9hZGVkOiBib29sZWFuO1xuICBoaW50OiBRdWVyeUhpbnQgfCBudWxsO1xufVxuXG5jbGFzcyBQcm9tUXVlcnlGaWVsZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvbVF1ZXJ5RmllbGRQcm9wcywgUHJvbVF1ZXJ5RmllbGRTdGF0ZT4ge1xuICBwbHVnaW5zOiBQbHVnaW5bXTtcbiAgZGVjbGFyZSBsYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlOiBDYW5jZWxhYmxlUHJvbWlzZTxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9tUXVlcnlGaWVsZFByb3BzLCBjb250ZXh0OiBSZWFjdC5Db250ZXh0PGFueT4pIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG5cbiAgICB0aGlzLnBsdWdpbnMgPSBbXG4gICAgICBCcmFjZXNQbHVnaW4oKSxcbiAgICAgIFNsYXRlUHJpc20oXG4gICAgICAgIHtcbiAgICAgICAgICBvbmx5SW46IChub2RlOiBhbnkpID0+IG5vZGUudHlwZSA9PT0gJ2NvZGVfYmxvY2snLFxuICAgICAgICAgIGdldFN5bnRheDogKG5vZGU6IGFueSkgPT4gJ3Byb21xbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHsgLi4uKHByaXNtTGFuZ3VhZ2VzIGFzIExhbmd1YWdlTWFwKSwgcHJvbXFsOiB0aGlzLnByb3BzLmRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5zeW50YXggfVxuICAgICAgKSxcbiAgICBdO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxhYmVsQnJvd3NlclZpc2libGU6IGZhbHNlLFxuICAgICAgc3ludGF4TG9hZGVkOiBmYWxzZSxcbiAgICAgIGhpbnQ6IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLmRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlcikge1xuICAgICAgdGhpcy5yZWZyZXNoTWV0cmljcygpO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hIaW50KCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5sYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICB0aGlzLmxhbmd1YWdlUHJvdmlkZXJJbml0aWFsaXphdGlvblByb21pc2UuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvbVF1ZXJ5RmllbGRQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBkYXRhc291cmNlOiB7IGxhbmd1YWdlUHJvdmlkZXIgfSxcbiAgICAgIHJhbmdlLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGxhbmd1YWdlUHJvdmlkZXIgIT09IHByZXZQcm9wcy5kYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIpIHtcbiAgICAgIC8vIFdlIHJlc2V0IHRoaXMgb25seSBvbiBEUyBjaGFuZ2Ugc28gd2UgZG8gbm90IGZsZXNoIGxvYWRpbmcgc3RhdGUgb24gZXZlcnkgcmFuZ2VDaGFuZ2Ugd2hpY2ggaGFwcGVucyBvbiBldmVyeVxuICAgICAgLy8gcXVlcnkgcnVuIGlmIHVzaW5nIHJlbGF0aXZlIHJhbmdlLlxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN5bnRheExvYWRlZDogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkUmFuZ2VUb1JlZnJlc2ggPSB0aGlzLnJhbmdlQ2hhbmdlZFRvUmVmcmVzaChyYW5nZSwgcHJldlByb3BzLnJhbmdlKTtcbiAgICAvLyBXZSB3YW50IHRvIHJlZnJlc2ggbWV0cmljcyB3aGVuIGxhbmd1YWdlIHByb3ZpZGVyIGNoYW5nZXMgYW5kL29yIHdoZW4gcmFuZ2UgY2hhbmdlcyAod2Ugcm91bmQgdXAgaW50ZXJ2YWxzIHRvIGEgbWludXRlKVxuICAgIGlmIChsYW5ndWFnZVByb3ZpZGVyICE9PSBwcmV2UHJvcHMuZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyIHx8IGNoYW5nZWRSYW5nZVRvUmVmcmVzaCkge1xuICAgICAgdGhpcy5yZWZyZXNoTWV0cmljcygpO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIHByZXZQcm9wcy5kYXRhICYmIHByZXZQcm9wcy5kYXRhLnNlcmllcyAhPT0gZGF0YS5zZXJpZXMpIHtcbiAgICAgIHRoaXMucmVmcmVzaEhpbnQoKTtcbiAgICB9XG4gIH1cblxuICByZWZyZXNoSGludCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRhdGFzb3VyY2UsIHF1ZXJ5LCBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGluaXRIaW50cyA9IGRhdGFzb3VyY2UuZ2V0SW5pdEhpbnRzKCk7XG4gICAgY29uc3QgaW5pdEhpbnQgPSBpbml0SGludHMubGVuZ3RoID4gMCA/IGluaXRIaW50c1swXSA6IG51bGw7XG5cbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5zZXJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaGludDogaW5pdEhpbnQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpc0RhdGFGcmFtZShkYXRhLnNlcmllc1swXSkgPyBkYXRhLnNlcmllcy5tYXAodG9MZWdhY3lSZXNwb25zZURhdGEpIDogZGF0YS5zZXJpZXM7XG4gICAgY29uc3QgcXVlcnlIaW50cyA9IGRhdGFzb3VyY2UuZ2V0UXVlcnlIaW50cyhxdWVyeSwgcmVzdWx0KTtcbiAgICBsZXQgcXVlcnlIaW50ID0gcXVlcnlIaW50cy5sZW5ndGggPiAwID8gcXVlcnlIaW50c1swXSA6IG51bGw7XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgaGludDogcXVlcnlIaW50ID8/IGluaXRIaW50IH0pO1xuICB9O1xuXG4gIHJlZnJlc2hNZXRyaWNzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFzb3VyY2U6IHsgbGFuZ3VhZ2VQcm92aWRlciB9LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5sYW5ndWFnZVByb3ZpZGVySW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbWFrZVByb21pc2VDYW5jZWxhYmxlKGxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVtYWluaW5nVGFza3MgPSBhd2FpdCB0aGlzLmxhbmd1YWdlUHJvdmlkZXJJbml0aWFsaXphdGlvblByb21pc2UucHJvbWlzZTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlbWFpbmluZ1Rhc2tzKTtcbiAgICAgIHRoaXMub25VcGRhdGVMYW5ndWFnZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIuaXNDYW5jZWxlZCkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJhbmdlQ2hhbmdlZFRvUmVmcmVzaChyYW5nZT86IFRpbWVSYW5nZSwgcHJldlJhbmdlPzogVGltZVJhbmdlKTogYm9vbGVhbiB7XG4gICAgaWYgKHJhbmdlICYmIHByZXZSYW5nZSkge1xuICAgICAgY29uc3Qgc2FtZU1pbnV0ZUZyb20gPSByb3VuZE1zVG9NaW4ocmFuZ2UuZnJvbS52YWx1ZU9mKCkpID09PSByb3VuZE1zVG9NaW4ocHJldlJhbmdlLmZyb20udmFsdWVPZigpKTtcbiAgICAgIGNvbnN0IHNhbWVNaW51dGVUbyA9IHJvdW5kTXNUb01pbihyYW5nZS50by52YWx1ZU9mKCkpID09PSByb3VuZE1zVG9NaW4ocHJldlJhbmdlLnRvLnZhbHVlT2YoKSk7XG4gICAgICAvLyBJZiBib3RoIGFyZSBzYW1lLCBkb24ndCBuZWVkIHRvIHJlZnJlc2guXG4gICAgICByZXR1cm4gIShzYW1lTWludXRlRnJvbSAmJiBzYW1lTWludXRlVG8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVE9ETyAjMzM5NzY6IFJlbW92ZSB0aGlzLCBhZGQgaGlzdG9ncmFtIGdyb3VwIChxdWVyeSA9IGBoaXN0b2dyYW1fcXVhbnRpbGUoMC45NSwgc3VtKHJhdGUoJHttZXRyaWN9WzVtXSkpIGJ5IChsZSkpYDspXG4gICAqL1xuICBvbkNoYW5nZUxhYmVsQnJvd3NlciA9IChzZWxlY3Rvcjogc3RyaW5nKSA9PiB7XG4gICAgdGhpcy5vbkNoYW5nZVF1ZXJ5KHNlbGVjdG9yLCB0cnVlKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxCcm93c2VyVmlzaWJsZTogZmFsc2UgfSk7XG4gIH07XG5cbiAgb25DaGFuZ2VRdWVyeSA9ICh2YWx1ZTogc3RyaW5nLCBvdmVycmlkZT86IGJvb2xlYW4pID0+IHtcbiAgICAvLyBTZW5kIHRleHQgY2hhbmdlIHRvIHBhcmVudFxuICAgIGNvbnN0IHsgcXVlcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgY29uc3QgbmV4dFF1ZXJ5OiBQcm9tUXVlcnkgPSB7IC4uLnF1ZXJ5LCBleHByOiB2YWx1ZSB9O1xuICAgICAgb25DaGFuZ2UobmV4dFF1ZXJ5KTtcblxuICAgICAgaWYgKG92ZXJyaWRlICYmIG9uUnVuUXVlcnkpIHtcbiAgICAgICAgb25SdW5RdWVyeSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvbkNsaWNrQ2hvb3NlckJ1dHRvbiA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKChzdGF0ZSkgPT4gKHsgbGFiZWxCcm93c2VyVmlzaWJsZTogIXN0YXRlLmxhYmVsQnJvd3NlclZpc2libGUgfSkpO1xuICB9O1xuXG4gIG9uQ2xpY2tIaW50Rml4ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YXNvdXJjZSwgcXVlcnksIG9uQ2hhbmdlLCBvblJ1blF1ZXJ5IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaGludCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIG9uQ2hhbmdlKGRhdGFzb3VyY2UubW9kaWZ5UXVlcnkocXVlcnksIGhpbnQhLmZpeCEuYWN0aW9uKSk7XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIG9uVXBkYXRlTGFuZ3VhZ2UgPSAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXNvdXJjZTogeyBsYW5ndWFnZVByb3ZpZGVyIH0sXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBtZXRyaWNzIH0gPSBsYW5ndWFnZVByb3ZpZGVyO1xuXG4gICAgaWYgKCFtZXRyaWNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHN5bnRheExvYWRlZDogdHJ1ZSB9KTtcbiAgfTtcblxuICBvblR5cGVhaGVhZCA9IGFzeW5jICh0eXBlYWhlYWQ6IFR5cGVhaGVhZElucHV0KTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhc291cmNlOiB7IGxhbmd1YWdlUHJvdmlkZXIgfSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghbGFuZ3VhZ2VQcm92aWRlcikge1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnM6IFtdIH07XG4gICAgfVxuXG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcHJlZml4LCB0ZXh0LCB2YWx1ZSwgd3JhcHBlckNsYXNzZXMsIGxhYmVsS2V5IH0gPSB0eXBlYWhlYWQ7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLnByb3ZpZGVDb21wbGV0aW9uSXRlbXMoXG4gICAgICB7IHRleHQsIHZhbHVlLCBwcmVmaXgsIHdyYXBwZXJDbGFzc2VzLCBsYWJlbEtleSB9LFxuICAgICAgeyBoaXN0b3J5IH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YXNvdXJjZSxcbiAgICAgIGRhdGFzb3VyY2U6IHsgbGFuZ3VhZ2VQcm92aWRlciB9LFxuICAgICAgcXVlcnksXG4gICAgICBFeHRyYUZpZWxkRWxlbWVudCxcbiAgICAgIGhpc3RvcnkgPSBbXSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHsgbGFiZWxCcm93c2VyVmlzaWJsZSwgc3ludGF4TG9hZGVkLCBoaW50IH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGhhc01ldHJpY3MgPSBsYW5ndWFnZVByb3ZpZGVyLm1ldHJpY3MubGVuZ3RoID4gMDtcbiAgICBjb25zdCBjaG9vc2VyVGV4dCA9IGdldENob29zZXJUZXh0KGRhdGFzb3VyY2UubG9va3Vwc0Rpc2FibGVkLCBzeW50YXhMb2FkZWQsIGhhc01ldHJpY3MpO1xuICAgIGNvbnN0IGJ1dHRvbkRpc2FibGVkID0gIShzeW50YXhMb2FkZWQgJiYgaGFzTWV0cmljcyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPExvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXI8c3RyaW5nW10+IHN0b3JhZ2VLZXk9e0xBU1RfVVNFRF9MQUJFTFNfS0VZfSBkZWZhdWx0VmFsdWU9e1tdfT5cbiAgICAgICAgeyhsYXN0VXNlZExhYmVscywgb25MYXN0VXNlZExhYmVsc1NhdmUsIG9uTGFzdFVzZWRMYWJlbHNEZWxldGUpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lIGdmLWZvcm0taW5saW5lLS14cy12aWV3LWZsZXgtY29sdW1uIGZsZXgtZ3Jvdy0xXCJcbiAgICAgICAgICAgICAgICBkYXRhLXRlc3RpZD17dGhpcy5wcm9wc1snZGF0YS10ZXN0aWQnXX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdmLWZvcm0tbGFiZWwgcXVlcnkta2V5d29yZCBwb2ludGVyXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja0Nob29zZXJCdXR0b259XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17YnV0dG9uRGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge2Nob29zZXJUZXh0fVxuICAgICAgICAgICAgICAgICAgPEljb24gbmFtZT17bGFiZWxCcm93c2VyVmlzaWJsZSA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCd9IC8+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0gZ2YtZm9ybS0tZ3JvdyBmbGV4LXNocmluay0xIG1pbi13aWR0aC0xNVwiPlxuICAgICAgICAgICAgICAgICAgPE1vbmFjb1F1ZXJ5RmllbGRXcmFwcGVyXG4gICAgICAgICAgICAgICAgICAgIHJ1blF1ZXJ5T25CbHVyPXt0aGlzLnByb3BzLmFwcCAhPT0gQ29yZUFwcC5FeHBsb3JlfVxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVByb3ZpZGVyPXtsYW5ndWFnZVByb3ZpZGVyfVxuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5PXtoaXN0b3J5fVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZVF1ZXJ5fVxuICAgICAgICAgICAgICAgICAgICBvblJ1blF1ZXJ5PXt0aGlzLnByb3BzLm9uUnVuUXVlcnl9XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZT17cXVlcnkuZXhwciA/PyAnJ31cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7bGFiZWxCcm93c2VyVmlzaWJsZSAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgICAgICA8UHJvbWV0aGV1c01ldHJpY3NCcm93c2VyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlUHJvdmlkZXI9e2xhbmd1YWdlUHJvdmlkZXJ9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlTGFiZWxCcm93c2VyfVxuICAgICAgICAgICAgICAgICAgICBsYXN0VXNlZExhYmVscz17bGFzdFVzZWRMYWJlbHMgfHwgW119XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTGFzdFVzZWRMYWJlbHM9e29uTGFzdFVzZWRMYWJlbHNTYXZlfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVMYXN0VXNlZExhYmVscz17b25MYXN0VXNlZExhYmVsc0RlbGV0ZX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgICAge0V4dHJhRmllbGRFbGVtZW50fVxuICAgICAgICAgICAgICB7aGludCA/IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInF1ZXJ5LXJvdy1icmVha1wiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9tLXF1ZXJ5LWZpZWxkLWluZm8gdGV4dC13YXJuaW5nXCI+XG4gICAgICAgICAgICAgICAgICAgIHtoaW50LmxhYmVsfXsnICd9XG4gICAgICAgICAgICAgICAgICAgIHtoaW50LmZpeCA/IChcbiAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJ0ZXh0LWxpbmsgbXV0ZWRcIiBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tIaW50Rml4fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtoaW50LmZpeC5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgKTtcbiAgICAgICAgfX1cbiAgICAgIDwvTG9jYWxTdG9yYWdlVmFsdWVQcm92aWRlcj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb21RdWVyeUZpZWxkO1xuIiwiaW1wb3J0IFJlYWN0LCB7IENoYW5nZUV2ZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgQnV0dG9uLFxuICBIb3Jpem9udGFsR3JvdXAsXG4gIElucHV0LFxuICBMYWJlbCxcbiAgTG9hZGluZ1BsYWNlaG9sZGVyLFxuICBzdHlsZXNGYWN0b3J5LFxuICB3aXRoVGhlbWUsXG4gIEJyb3dzZXJMYWJlbCBhcyBQcm9tTGFiZWwsXG59IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBQcm9tUWxMYW5ndWFnZVByb3ZpZGVyIGZyb20gJy4uL2xhbmd1YWdlX3Byb3ZpZGVyJztcbmltcG9ydCB7IGVzY2FwZUxhYmVsVmFsdWVJbkV4YWN0U2VsZWN0b3IsIGVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IgfSBmcm9tICcuLi9sYW5ndWFnZV91dGlscyc7XG5pbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEZpeGVkU2l6ZUxpc3QgfSBmcm9tICdyZWFjdC13aW5kb3cnO1xuXG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcblxuLy8gSGFyZCBsaW1pdCBvbiBsYWJlbHMgdG8gcmVuZGVyXG5jb25zdCBFTVBUWV9TRUxFQ1RPUiA9ICd7fSc7XG5jb25zdCBNRVRSSUNfTEFCRUwgPSAnX19uYW1lX18nO1xuY29uc3QgTElTVF9JVEVNX1NJWkUgPSAyNTtcblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUHJvcHMge1xuICBsYW5ndWFnZVByb3ZpZGVyOiBQcm9tUWxMYW5ndWFnZVByb3ZpZGVyO1xuICBvbkNoYW5nZTogKHNlbGVjdG9yOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHRoZW1lOiBHcmFmYW5hVGhlbWU7XG4gIGF1dG9TZWxlY3Q/OiBudW1iZXI7XG4gIGhpZGU/OiAoKSA9PiB2b2lkO1xuICBsYXN0VXNlZExhYmVsczogc3RyaW5nW107XG4gIHN0b3JlTGFzdFVzZWRMYWJlbHM6IChsYWJlbHM6IHN0cmluZ1tdKSA9PiB2b2lkO1xuICBkZWxldGVMYXN0VXNlZExhYmVsczogKCkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIEJyb3dzZXJTdGF0ZSB7XG4gIGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW107XG4gIGxhYmVsU2VhcmNoVGVybTogc3RyaW5nO1xuICBtZXRyaWNTZWFyY2hUZXJtOiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICBlcnJvcjogc3RyaW5nO1xuICB2YWxpZGF0aW9uU3RhdHVzOiBzdHJpbmc7XG4gIHZhbHVlU2VhcmNoVGVybTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmFjZXR0YWJsZVZhbHVlIHtcbiAgbmFtZTogc3RyaW5nO1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIGRldGFpbHM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0YWJsZUxhYmVsIHtcbiAgbmFtZTogc3RyaW5nO1xuICBzZWxlY3RlZD86IGJvb2xlYW47XG4gIGxvYWRpbmc/OiBib29sZWFuO1xuICB2YWx1ZXM/OiBGYWNldHRhYmxlVmFsdWVbXTtcbiAgaGlkZGVuPzogYm9vbGVhbjtcbiAgZmFjZXRzPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTZWxlY3RvcihsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdKTogc3RyaW5nIHtcbiAgbGV0IHNpbmdsZU1ldHJpYyA9ICcnO1xuICBjb25zdCBzZWxlY3RlZExhYmVscyA9IFtdO1xuICBmb3IgKGNvbnN0IGxhYmVsIG9mIGxhYmVscykge1xuICAgIGlmICgobGFiZWwubmFtZSA9PT0gTUVUUklDX0xBQkVMIHx8IGxhYmVsLnNlbGVjdGVkKSAmJiBsYWJlbC52YWx1ZXMgJiYgbGFiZWwudmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsdWVzID0gbGFiZWwudmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5uYW1lKTtcbiAgICAgIGlmIChzZWxlY3RlZFZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNlbGVjdGVkTGFiZWxzLnB1c2goYCR7bGFiZWwubmFtZX09flwiJHtzZWxlY3RlZFZhbHVlcy5tYXAoZXNjYXBlTGFiZWxWYWx1ZUluUmVnZXhTZWxlY3Rvcikuam9pbignfCcpfVwiYCk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAobGFiZWwubmFtZSA9PT0gTUVUUklDX0xBQkVMKSB7XG4gICAgICAgICAgc2luZ2xlTWV0cmljID0gc2VsZWN0ZWRWYWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWRMYWJlbHMucHVzaChgJHtsYWJlbC5uYW1lfT1cIiR7ZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvcihzZWxlY3RlZFZhbHVlc1swXSl9XCJgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW3NpbmdsZU1ldHJpYywgJ3snLCBzZWxlY3RlZExhYmVscy5qb2luKCcsJyksICd9J10uam9pbignJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWNldExhYmVscyhcbiAgbGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXSxcbiAgcG9zc2libGVMYWJlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPixcbiAgbGFzdEZhY2V0dGVkPzogc3RyaW5nXG4pOiBTZWxlY3RhYmxlTGFiZWxbXSB7XG4gIHJldHVybiBsYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgIGNvbnN0IHBvc3NpYmxlVmFsdWVzID0gcG9zc2libGVMYWJlbHNbbGFiZWwubmFtZV07XG4gICAgaWYgKHBvc3NpYmxlVmFsdWVzKSB7XG4gICAgICBsZXQgZXhpc3RpbmdWYWx1ZXM6IEZhY2V0dGFibGVWYWx1ZVtdO1xuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IGxhc3RGYWNldHRlZCAmJiBsYWJlbC52YWx1ZXMpIHtcbiAgICAgICAgLy8gRmFjZXR0aW5nIHRoaXMgbGFiZWwsIHNob3cgYWxsIHZhbHVlc1xuICAgICAgICBleGlzdGluZ1ZhbHVlcyA9IGxhYmVsLnZhbHVlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgc2VsZWN0aW9uIGluIG90aGVyIGZhY2V0c1xuICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KFxuICAgICAgICAgIGxhYmVsLnZhbHVlcz8uZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUuc2VsZWN0ZWQpLm1hcCgodmFsdWUpID0+IHZhbHVlLm5hbWUpIHx8IFtdXG4gICAgICAgICk7XG4gICAgICAgIC8vIFZhbHVlcyBmb3IgdGhpcyBsYWJlbCBoYXZlIG5vdCBiZWVuIHJlcXVlc3RlZCB5ZXQsIGxldCdzIHVzZSB0aGUgZmFjZXR0ZWQgb25lcyBhcyB0aGUgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgZXhpc3RpbmdWYWx1ZXMgPSBwb3NzaWJsZVZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoeyBuYW1lOiB2YWx1ZSwgc2VsZWN0ZWQ6IHNlbGVjdGVkVmFsdWVzLmhhcyh2YWx1ZSkgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICB2YWx1ZXM6IGV4aXN0aW5nVmFsdWVzLFxuICAgICAgICBoaWRkZW46ICFwb3NzaWJsZVZhbHVlcyxcbiAgICAgICAgZmFjZXRzOiBleGlzdGluZ1ZhbHVlcy5sZW5ndGgsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIExhYmVsIGlzIGZhY2V0dGVkIG91dCwgaGlkZSBhbGwgdmFsdWVzXG4gICAgcmV0dXJuIHsgLi4ubGFiZWwsIGxvYWRpbmc6IGZhbHNlLCBoaWRkZW46ICFwb3NzaWJsZVZhbHVlcywgdmFsdWVzOiB1bmRlZmluZWQsIGZhY2V0czogMCB9O1xuICB9KTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gc3R5bGVzRmFjdG9yeSgodGhlbWU6IEdyYWZhbmFUaGVtZSkgPT4gKHtcbiAgd3JhcHBlcjogY3NzYFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLmJnMn07XG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgICB3aWR0aDogMTAwJTtcbiAgYCxcbiAgbGlzdDogY3NzYFxuICAgIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgbWF4LWhlaWdodDogMjAwcHg7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgYCxcbiAgc2VjdGlvbjogY3NzYFxuICAgICYgKyAmIHtcbiAgICAgIG1hcmdpbjogJHt0aGVtZS5zcGFjaW5nLm1kfSAwO1xuICAgIH1cbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGAsXG4gIHNlbGVjdG9yOiBjc3NgXG4gICAgZm9udC1mYW1pbHk6ICR7dGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5Lm1vbm9zcGFjZX07XG4gICAgbWFyZ2luLWJvdHRvbTogJHt0aGVtZS5zcGFjaW5nLnNtfTtcbiAgYCxcbiAgc3RhdHVzOiBjc3NgXG4gICAgcGFkZGluZzogJHt0aGVtZS5zcGFjaW5nLnhzfTtcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMudGV4dFNlbWlXZWFrfTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgLyogdXNpbmcgYWJzb2x1dGUgcG9zaXRpb25pbmcgYmVjYXVzZSBmbGV4IGludGVyZmVyZXMgd2l0aCBlbGxpcHNpcyAqL1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogNTAlO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMTAwbXMgbGluZWFyO1xuICAgIG9wYWNpdHk6IDA7XG4gIGAsXG4gIHN0YXR1c1Nob3dpbmc6IGNzc2BcbiAgICBvcGFjaXR5OiAxO1xuICBgLFxuICBlcnJvcjogY3NzYFxuICAgIGNvbG9yOiAke3RoZW1lLnBhbGV0dGUuYnJhbmREYW5nZXJ9O1xuICBgLFxuICB2YWx1ZUxpc3Q6IGNzc2BcbiAgICBtYXJnaW4tcmlnaHQ6ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gIGAsXG4gIHZhbHVlTGlzdFdyYXBwZXI6IGNzc2BcbiAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlcjJ9O1xuICAgIG1hcmdpbjogJHt0aGVtZS5zcGFjaW5nLnNtfSAwO1xuICAgIHBhZGRpbmc6ICR7dGhlbWUuc3BhY2luZy5zbX0gMCAke3RoZW1lLnNwYWNpbmcuc219ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gIGAsXG4gIHZhbHVlTGlzdEFyZWE6IGNzc2BcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBtYXJnaW4tdG9wOiAke3RoZW1lLnNwYWNpbmcuc219O1xuICBgLFxuICB2YWx1ZVRpdGxlOiBjc3NgXG4gICAgbWFyZ2luLWxlZnQ6IC0ke3RoZW1lLnNwYWNpbmcueHN9O1xuICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gIGAsXG4gIHZhbGlkYXRpb25TdGF0dXM6IGNzc2BcbiAgICBwYWRkaW5nOiAke3RoZW1lLnNwYWNpbmcueHN9O1xuICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZy5zbX07XG4gICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLnRleHRTdHJvbmd9O1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgYCxcbn0pKTtcblxuLyoqXG4gKiBUT0RPICMzMzk3NjogUmVtb3ZlIGR1cGxpY2F0ZWQgY29kZS4gVGhlIGNvbXBvbmVudCBpcyB2ZXJ5IHNpbWlsYXIgdG8gTG9raUxhYmVsQnJvd3Nlci50c3guIENoZWNrIGlmIGl0J3MgcG9zc2libGVcbiAqICAgICAgICAgICAgICB0byBjcmVhdGUgYSBzaW5nbGUsIGdlbmVyaWMgY29tcG9uZW50LlxuICovXG5leHBvcnQgY2xhc3MgVW50aGVtZWRQcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8QnJvd3NlclByb3BzLCBCcm93c2VyU3RhdGU+IHtcbiAgdmFsdWVMaXN0c1JlZiA9IFJlYWN0LmNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcbiAgc3RhdGU6IEJyb3dzZXJTdGF0ZSA9IHtcbiAgICBsYWJlbHM6IFtdIGFzIFNlbGVjdGFibGVMYWJlbFtdLFxuICAgIGxhYmVsU2VhcmNoVGVybTogJycsXG4gICAgbWV0cmljU2VhcmNoVGVybTogJycsXG4gICAgc3RhdHVzOiAnUmVhZHknLFxuICAgIGVycm9yOiAnJyxcbiAgICB2YWxpZGF0aW9uU3RhdHVzOiAnJyxcbiAgICB2YWx1ZVNlYXJjaFRlcm06ICcnLFxuICB9O1xuXG4gIG9uQ2hhbmdlTGFiZWxTZWFyY2ggPSAoZXZlbnQ6IENoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsU2VhcmNoVGVybTogZXZlbnQudGFyZ2V0LnZhbHVlIH0pO1xuICB9O1xuXG4gIG9uQ2hhbmdlTWV0cmljU2VhcmNoID0gKGV2ZW50OiBDaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBtZXRyaWNTZWFyY2hUZXJtOiBldmVudC50YXJnZXQudmFsdWUgfSk7XG4gIH07XG5cbiAgb25DaGFuZ2VWYWx1ZVNlYXJjaCA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgdmFsdWVTZWFyY2hUZXJtOiBldmVudC50YXJnZXQudmFsdWUgfSk7XG4gIH07XG5cbiAgb25DbGlja1J1blF1ZXJ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZShzZWxlY3Rvcik7XG4gIH07XG5cbiAgb25DbGlja1J1blJhdGVRdWVyeSA9ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGJ1aWxkU2VsZWN0b3IodGhpcy5zdGF0ZS5sYWJlbHMpO1xuICAgIGNvbnN0IHF1ZXJ5ID0gYHJhdGUoJHtzZWxlY3Rvcn1bJF9faW50ZXJ2YWxdKWA7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZShxdWVyeSk7XG4gIH07XG5cbiAgb25DbGlja0NsZWFyID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gc3RhdGUubGFiZWxzLm1hcCgobGFiZWwpID0+ICh7XG4gICAgICAgIC4uLmxhYmVsLFxuICAgICAgICB2YWx1ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgZmFjZXRzOiB1bmRlZmluZWQsXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbHMsXG4gICAgICAgIGxhYmVsU2VhcmNoVGVybTogJycsXG4gICAgICAgIG1ldHJpY1NlYXJjaFRlcm06ICcnLFxuICAgICAgICBzdGF0dXM6ICcnLFxuICAgICAgICBlcnJvcjogJycsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0dXM6ICcnLFxuICAgICAgICB2YWx1ZVNlYXJjaFRlcm06ICcnLFxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLmRlbGV0ZUxhc3RVc2VkTGFiZWxzKCk7XG4gICAgLy8gR2V0IG1ldHJpY3NcbiAgICB0aGlzLmZldGNoVmFsdWVzKE1FVFJJQ19MQUJFTCwgRU1QVFlfU0VMRUNUT1IpO1xuICB9O1xuXG4gIG9uQ2xpY2tMYWJlbCA9IChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5zdGF0ZS5sYWJlbHMuZmluZCgobCkgPT4gbC5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRvZ2dsZSBzZWxlY3RlZCBzdGF0ZVxuICAgIGNvbnN0IHNlbGVjdGVkID0gIWxhYmVsLnNlbGVjdGVkO1xuICAgIGxldCBuZXh0VmFsdWU6IFBhcnRpYWw8U2VsZWN0YWJsZUxhYmVsPiA9IHsgc2VsZWN0ZWQgfTtcbiAgICBpZiAobGFiZWwudmFsdWVzICYmICFzZWxlY3RlZCkge1xuICAgICAgLy8gRGVzZWxlY3QgYWxsIHZhbHVlcyBpZiBsYWJlbCB3YXMgZGVzZWxlY3RlZFxuICAgICAgY29uc3QgdmFsdWVzID0gbGFiZWwudmFsdWVzLm1hcCgodmFsdWUpID0+ICh7IC4uLnZhbHVlLCBzZWxlY3RlZDogZmFsc2UgfSkpO1xuICAgICAgbmV4dFZhbHVlID0geyAuLi5uZXh0VmFsdWUsIGZhY2V0czogMCwgdmFsdWVzIH07XG4gICAgfVxuICAgIC8vIFJlc2V0dGluZyBzZWFyY2ggdG8gcHJldmVudCBlbXB0eSByZXN1bHRzXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsU2VhcmNoVGVybTogJycgfSk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIG5leHRWYWx1ZSwgJycsICgpID0+IHRoaXMuZG9GYWNldHRpbmdGb3JMYWJlbChuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja1ZhbHVlID0gKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwgfHwgIWxhYmVsLnZhbHVlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXNldHRpbmcgc2VhcmNoIHRvIHByZXZlbnQgZW1wdHkgcmVzdWx0c1xuICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbFNlYXJjaFRlcm06ICcnIH0pO1xuICAgIC8vIFRvZ2dsaW5nIHZhbHVlIGZvciBzZWxlY3RlZCBsYWJlbCwgbGVhdmluZyBvdGhlciB2YWx1ZXMgaW50YWN0XG4gICAgY29uc3QgdmFsdWVzID0gbGFiZWwudmFsdWVzLm1hcCgodikgPT4gKHsgLi4udiwgc2VsZWN0ZWQ6IHYubmFtZSA9PT0gdmFsdWUgPyAhdi5zZWxlY3RlZCA6IHYuc2VsZWN0ZWQgfSkpO1xuICAgIHRoaXMudXBkYXRlTGFiZWxTdGF0ZShuYW1lLCB7IHZhbHVlcyB9LCAnJywgKCkgPT4gdGhpcy5kb0ZhY2V0dGluZyhuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja01ldHJpYyA9IChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxFbGVtZW50PikgPT4ge1xuICAgIC8vIEZpbmRpbmcgc3BlY2lhbCBtZXRyaWMgbGFiZWxcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWxzLmZpbmQoKGwpID0+IGwubmFtZSA9PT0gbmFtZSk7XG4gICAgaWYgKCFsYWJlbCB8fCAhbGFiZWwudmFsdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlc2V0dGluZyBzZWFyY2ggdG8gcHJldmVudCBlbXB0eSByZXN1bHRzXG4gICAgdGhpcy5zZXRTdGF0ZSh7IG1ldHJpY1NlYXJjaFRlcm06ICcnIH0pO1xuICAgIC8vIFRvZ2dsaW5nIHZhbHVlIGZvciBzZWxlY3RlZCBsYWJlbCwgbGVhdmluZyBvdGhlciB2YWx1ZXMgaW50YWN0XG4gICAgY29uc3QgdmFsdWVzID0gbGFiZWwudmFsdWVzLm1hcCgodikgPT4gKHtcbiAgICAgIC4uLnYsXG4gICAgICBzZWxlY3RlZDogdi5uYW1lID09PSB2YWx1ZSB8fCB2LnNlbGVjdGVkID8gIXYuc2VsZWN0ZWQgOiB2LnNlbGVjdGVkLFxuICAgIH0pKTtcbiAgICAvLyBUb2dnbGUgc2VsZWN0ZWQgc3RhdGUgb2Ygc3BlY2lhbCBtZXRyaWNzIGxhYmVsXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB2YWx1ZXMuc29tZSgodikgPT4gdi5zZWxlY3RlZCk7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgc2VsZWN0ZWQsIHZhbHVlcyB9LCAnJywgKCkgPT4gdGhpcy5kb0ZhY2V0dGluZyhuYW1lKSk7XG4gIH07XG5cbiAgb25DbGlja1ZhbGlkYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgdGhpcy52YWxpZGF0ZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcblxuICB1cGRhdGVMYWJlbFN0YXRlKG5hbWU6IHN0cmluZywgdXBkYXRlZEZpZWxkczogUGFydGlhbDxTZWxlY3RhYmxlTGFiZWw+LCBzdGF0dXMgPSAnJywgY2I/OiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsczogU2VsZWN0YWJsZUxhYmVsW10gPSBzdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgICAgICBpZiAobGFiZWwubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiB7IC4uLmxhYmVsLCAuLi51cGRhdGVkRmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSk7XG4gICAgICAvLyBOZXcgc3RhdHVzIG92ZXJyaWRlcyBlcnJvcnNcbiAgICAgIGNvbnN0IGVycm9yID0gc3RhdHVzID8gJycgOiBzdGF0ZS5lcnJvcjtcbiAgICAgIHJldHVybiB7IGxhYmVscywgc3RhdHVzLCBlcnJvciwgdmFsaWRhdGlvblN0YXR1czogJycgfTtcbiAgICB9LCBjYik7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIsIGxhc3RVc2VkTGFiZWxzIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChsYW5ndWFnZVByb3ZpZGVyKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZExhYmVsczogc3RyaW5nW10gPSBsYXN0VXNlZExhYmVscztcbiAgICAgIGxhbmd1YWdlUHJvdmlkZXIuc3RhcnQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgbGV0IHJhd0xhYmVsczogc3RyaW5nW10gPSBsYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsS2V5cygpO1xuICAgICAgICAvLyBHZXQgbWV0cmljc1xuICAgICAgICB0aGlzLmZldGNoVmFsdWVzKE1FVFJJQ19MQUJFTCwgRU1QVFlfU0VMRUNUT1IpO1xuICAgICAgICAvLyBBdXRvLXNlbGVjdCBwcmV2aW91c2x5IHNlbGVjdGVkIGxhYmVsc1xuICAgICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gcmF3TGFiZWxzLm1hcCgobGFiZWwsIGksIGFycikgPT4gKHtcbiAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobGFiZWwpLFxuICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIFByZS1mZXRjaCB2YWx1ZXMgZm9yIHNlbGVjdGVkIGxhYmVsc1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmxhYmVscy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhYmVsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgRU1QVFlfU0VMRUNUT1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nRm9yTGFiZWwobmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiBsYWJlbC5zZWxlY3RlZCkubWFwKChsYWJlbCkgPT4gbGFiZWwubmFtZSk7XG4gICAgdGhpcy5wcm9wcy5zdG9yZUxhc3RVc2VkTGFiZWxzKHNlbGVjdGVkTGFiZWxzKTtcbiAgICBpZiAobGFiZWwuc2VsZWN0ZWQpIHtcbiAgICAgIC8vIFJlZmV0Y2ggdmFsdWVzIGZvciBuZXdseSBzZWxlY3RlZCBsYWJlbC4uLlxuICAgICAgaWYgKCFsYWJlbC52YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5mZXRjaFZhbHVlcyhuYW1lLCBidWlsZFNlbGVjdG9yKHRoaXMuc3RhdGUubGFiZWxzKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgbmVlZCB0byBmYWNldCB3aGVuIGRlc2VsZWN0aW5nIGxhYmVsc1xuICAgICAgdGhpcy5kb0ZhY2V0dGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGRvRmFjZXR0aW5nID0gKGxhc3RGYWNldHRlZD86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgaWYgKHNlbGVjdG9yID09PSBFTVBUWV9TRUxFQ1RPUikge1xuICAgICAgLy8gQ2xlYXIgdXAgZmFjZXR0aW5nXG4gICAgICBjb25zdCBsYWJlbHM6IFNlbGVjdGFibGVMYWJlbFtdID0gdGhpcy5zdGF0ZS5sYWJlbHMubWFwKChsYWJlbCkgPT4ge1xuICAgICAgICByZXR1cm4geyAuLi5sYWJlbCwgZmFjZXRzOiAwLCB2YWx1ZXM6IHVuZGVmaW5lZCwgaGlkZGVuOiBmYWxzZSB9O1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgbGFiZWxzIH0sICgpID0+IHtcbiAgICAgICAgLy8gR2V0IGZyZXNoIHNldCBvZiB2YWx1ZXNcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMuZm9yRWFjaChcbiAgICAgICAgICAobGFiZWwpID0+IChsYWJlbC5zZWxlY3RlZCB8fCBsYWJlbC5uYW1lID09PSBNRVRSSUNfTEFCRUwpICYmIHRoaXMuZmV0Y2hWYWx1ZXMobGFiZWwubmFtZSwgc2VsZWN0b3IpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG8gZmFjZXR0aW5nXG4gICAgICB0aGlzLmZldGNoU2VyaWVzKHNlbGVjdG9yLCBsYXN0RmFjZXR0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBhc3luYyBmZXRjaFZhbHVlcyhuYW1lOiBzdHJpbmcsIHNlbGVjdG9yOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGxhbmd1YWdlUHJvdmlkZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgbG9hZGluZzogdHJ1ZSB9LCBgRmV0Y2hpbmcgdmFsdWVzIGZvciAke25hbWV9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCByYXdWYWx1ZXMgPSBhd2FpdCBsYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsVmFsdWVzKG5hbWUpO1xuICAgICAgLy8gSWYgc2VsZWN0b3IgY2hhbmdlZCwgY2xlYXIgbG9hZGluZyBzdGF0ZSBhbmQgZGlzY2FyZCByZXN1bHQgYnkgcmV0dXJuaW5nIGVhcmx5XG4gICAgICBpZiAoc2VsZWN0b3IgIT09IGJ1aWxkU2VsZWN0b3IodGhpcy5zdGF0ZS5sYWJlbHMpKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxTdGF0ZShuYW1lLCB7IGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZXM6IEZhY2V0dGFibGVWYWx1ZVtdID0gW107XG4gICAgICBjb25zdCB7IG1ldHJpY3NNZXRhZGF0YSB9ID0gbGFuZ3VhZ2VQcm92aWRlcjtcbiAgICAgIGZvciAoY29uc3QgbGFiZWxWYWx1ZSBvZiByYXdWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWU6IEZhY2V0dGFibGVWYWx1ZSA9IHsgbmFtZTogbGFiZWxWYWx1ZSB9O1xuICAgICAgICAvLyBBZGRpbmcgdHlwZS9oZWxwIHRleHQgdG8gbWV0cmljc1xuICAgICAgICBpZiAobmFtZSA9PT0gTUVUUklDX0xBQkVMICYmIG1ldHJpY3NNZXRhZGF0YSkge1xuICAgICAgICAgIGNvbnN0IG1ldGEgPSBtZXRyaWNzTWV0YWRhdGFbbGFiZWxWYWx1ZV07XG4gICAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIHZhbHVlLmRldGFpbHMgPSBgKCR7bWV0YS50eXBlfSkgJHttZXRhLmhlbHB9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKG5hbWUsIHsgdmFsdWVzLCBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hTZXJpZXMoc2VsZWN0b3I6IHN0cmluZywgbGFzdEZhY2V0dGVkPzogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBsYW5ndWFnZVByb3ZpZGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChsYXN0RmFjZXR0ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxTdGF0ZShsYXN0RmFjZXR0ZWQsIHsgbG9hZGluZzogdHJ1ZSB9LCBgRmFjZXR0aW5nIGxhYmVscyBmb3IgJHtzZWxlY3Rvcn1gKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlTGFiZWxzID0gYXdhaXQgbGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAvLyBJZiBzZWxlY3RvciBjaGFuZ2VkLCBjbGVhciBsb2FkaW5nIHN0YXRlIGFuZCBkaXNjYXJkIHJlc3VsdCBieSByZXR1cm5pbmcgZWFybHlcbiAgICAgIGlmIChzZWxlY3RvciAhPT0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscykpIHtcbiAgICAgICAgaWYgKGxhc3RGYWNldHRlZCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxTdGF0ZShsYXN0RmFjZXR0ZWQsIHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHBvc3NpYmxlTGFiZWxzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yOiBgRW1wdHkgcmVzdWx0cywgbm8gbWF0Y2hpbmcgbGFiZWwgZm9yICR7c2VsZWN0b3J9YCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxzOiBTZWxlY3RhYmxlTGFiZWxbXSA9IGZhY2V0TGFiZWxzKHRoaXMuc3RhdGUubGFiZWxzLCBwb3NzaWJsZUxhYmVscywgbGFzdEZhY2V0dGVkKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbHMsIGVycm9yOiAnJyB9KTtcbiAgICAgIGlmIChsYXN0RmFjZXR0ZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbFN0YXRlKGxhc3RGYWNldHRlZCwgeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdmFsaWRhdGVTZWxlY3RvcihzZWxlY3Rvcjogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBsYW5ndWFnZVByb3ZpZGVyIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWxpZGF0aW9uU3RhdHVzOiBgVmFsaWRhdGluZyBzZWxlY3RvciAke3NlbGVjdG9yfWAsIGVycm9yOiAnJyB9KTtcbiAgICBjb25zdCBzdHJlYW1zID0gYXdhaXQgbGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllcyhzZWxlY3Rvcik7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHZhbGlkYXRpb25TdGF0dXM6IGBTZWxlY3RvciBpcyB2YWxpZCAoJHtzdHJlYW1zLmxlbmd0aH0gc2VyaWVzIGZvdW5kKWAgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB0aGVtZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGxhYmVscywgbGFiZWxTZWFyY2hUZXJtLCBtZXRyaWNTZWFyY2hUZXJtLCBzdGF0dXMsIGVycm9yLCB2YWxpZGF0aW9uU3RhdHVzLCB2YWx1ZVNlYXJjaFRlcm0gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVzKHRoZW1lKTtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgICA8TG9hZGluZ1BsYWNlaG9sZGVyIHRleHQ9XCJMb2FkaW5nIGxhYmVscy4uLlwiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgbWV0cmljc1xuICAgIGxldCBtZXRyaWNzID0gbGFiZWxzLmZpbmQoKGxhYmVsKSA9PiBsYWJlbC5uYW1lID09PSBNRVRSSUNfTEFCRUwpO1xuICAgIGlmIChtZXRyaWNzICYmIG1ldHJpY1NlYXJjaFRlcm0pIHtcbiAgICAgIG1ldHJpY3MgPSB7XG4gICAgICAgIC4uLm1ldHJpY3MsXG4gICAgICAgIHZhbHVlczogbWV0cmljcy52YWx1ZXM/LmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkIHx8IHZhbHVlLm5hbWUuaW5jbHVkZXMobWV0cmljU2VhcmNoVGVybSkpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgbGFiZWxzXG4gICAgbGV0IG5vbk1ldHJpY0xhYmVscyA9IGxhYmVscy5maWx0ZXIoKGxhYmVsKSA9PiAhbGFiZWwuaGlkZGVuICYmIGxhYmVsLm5hbWUgIT09IE1FVFJJQ19MQUJFTCk7XG4gICAgaWYgKGxhYmVsU2VhcmNoVGVybSkge1xuICAgICAgbm9uTWV0cmljTGFiZWxzID0gbm9uTWV0cmljTGFiZWxzLmZpbHRlcigobGFiZWwpID0+IGxhYmVsLnNlbGVjdGVkIHx8IGxhYmVsLm5hbWUuaW5jbHVkZXMobGFiZWxTZWFyY2hUZXJtKSk7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIG5vbi1tZXRyaWMgbGFiZWwgdmFsdWVzXG4gICAgbGV0IHNlbGVjdGVkTGFiZWxzID0gbm9uTWV0cmljTGFiZWxzLmZpbHRlcigobGFiZWwpID0+IGxhYmVsLnNlbGVjdGVkICYmIGxhYmVsLnZhbHVlcyk7XG4gICAgaWYgKHZhbHVlU2VhcmNoVGVybSkge1xuICAgICAgc2VsZWN0ZWRMYWJlbHMgPSBzZWxlY3RlZExhYmVscy5tYXAoKGxhYmVsKSA9PiAoe1xuICAgICAgICAuLi5sYWJlbCxcbiAgICAgICAgdmFsdWVzOiBsYWJlbC52YWx1ZXM/LmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnNlbGVjdGVkIHx8IHZhbHVlLm5hbWUuaW5jbHVkZXModmFsdWVTZWFyY2hUZXJtKSksXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdG9yID0gYnVpbGRTZWxlY3Rvcih0aGlzLnN0YXRlLmxhYmVscyk7XG4gICAgY29uc3QgZW1wdHkgPSBzZWxlY3RvciA9PT0gRU1QVFlfU0VMRUNUT1I7XG4gICAgY29uc3QgbWV0cmljQ291bnQgPSBtZXRyaWNzPy52YWx1ZXM/Lmxlbmd0aCB8fCAwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0+XG4gICAgICAgIDxIb3Jpem9udGFsR3JvdXAgYWxpZ249XCJmbGV4LXN0YXJ0XCIgc3BhY2luZz1cImxnXCI+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc2VjdGlvbn0+XG4gICAgICAgICAgICAgIDxMYWJlbCBkZXNjcmlwdGlvbj1cIk9uY2UgYSBtZXRyaWMgaXMgc2VsZWN0ZWQgb25seSBwb3NzaWJsZSBsYWJlbHMgYXJlIHNob3duLlwiPjEuIFNlbGVjdCBhIG1ldHJpYzwvTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZU1ldHJpY1NlYXJjaH1cbiAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJGaWx0ZXIgZXhwcmVzc2lvbiBmb3IgbWV0cmljXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXttZXRyaWNTZWFyY2hUZXJtfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IHJvbGU9XCJsaXN0XCIgY2xhc3NOYW1lPXtzdHlsZXMudmFsdWVMaXN0V3JhcHBlcn0+XG4gICAgICAgICAgICAgICAgPEZpeGVkU2l6ZUxpc3RcbiAgICAgICAgICAgICAgICAgIGhlaWdodD17TWF0aC5taW4oNDUwLCBtZXRyaWNDb3VudCAqIExJU1RfSVRFTV9TSVpFKX1cbiAgICAgICAgICAgICAgICAgIGl0ZW1Db3VudD17bWV0cmljQ291bnR9XG4gICAgICAgICAgICAgICAgICBpdGVtU2l6ZT17TElTVF9JVEVNX1NJWkV9XG4gICAgICAgICAgICAgICAgICBpdGVtS2V5PXsoaSkgPT4gKG1ldHJpY3MhLnZhbHVlcyBhcyBGYWNldHRhYmxlVmFsdWVbXSlbaV0ubmFtZX1cbiAgICAgICAgICAgICAgICAgIHdpZHRoPXszMDB9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3R9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgeyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWV0cmljcz8udmFsdWVzPy5baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXtzdHlsZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvbUxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e21ldHJpY3MhLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZT8ubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3ZhbHVlLmRldGFpbHN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17dmFsdWU/LnNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tNZXRyaWN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm09e21ldHJpY1NlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA8L0ZpeGVkU2l6ZUxpc3Q+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICAgICAgPExhYmVsIGRlc2NyaXB0aW9uPVwiT25jZSBsYWJlbCB2YWx1ZXMgYXJlIHNlbGVjdGVkLCBvbmx5IHBvc3NpYmxlIGxhYmVsIGNvbWJpbmF0aW9ucyBhcmUgc2hvd24uXCI+XG4gICAgICAgICAgICAgICAgMi4gU2VsZWN0IGxhYmVscyB0byBzZWFyY2ggaW5cbiAgICAgICAgICAgICAgPC9MYWJlbD5cbiAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlTGFiZWxTZWFyY2h9XG4gICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiRmlsdGVyIGV4cHJlc3Npb24gZm9yIGxhYmVsXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtsYWJlbFNlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHsvKiBVc2luZyBmaXhlZCBoZWlnaHQgaGVyZSB0byBwcmV2ZW50IGp1bXB5IGxheW91dCAqL31cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5saXN0fSBzdHlsZT17eyBoZWlnaHQ6IDEyMCB9fT5cbiAgICAgICAgICAgICAgICB7bm9uTWV0cmljTGFiZWxzLm1hcCgobGFiZWwpID0+IChcbiAgICAgICAgICAgICAgICAgIDxQcm9tTGFiZWxcbiAgICAgICAgICAgICAgICAgICAga2V5PXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsYWJlbC5sb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2xhYmVsLnNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICBoaWRkZW49e2xhYmVsLmhpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAgZmFjZXRzPXtsYWJlbC5mYWNldHN9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMub25DbGlja0xhYmVsfVxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hUZXJtPXtsYWJlbFNlYXJjaFRlcm19XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9ufT5cbiAgICAgICAgICAgICAgPExhYmVsIGRlc2NyaXB0aW9uPVwiVXNlIHRoZSBzZWFyY2ggZmllbGQgdG8gZmluZCB2YWx1ZXMgYWNyb3NzIHNlbGVjdGVkIGxhYmVscy5cIj5cbiAgICAgICAgICAgICAgICAzLiBTZWxlY3QgKG11bHRpcGxlKSB2YWx1ZXMgZm9yIHlvdXIgbGFiZWxzXG4gICAgICAgICAgICAgIDwvTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZVZhbHVlU2VhcmNofVxuICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkZpbHRlciBleHByZXNzaW9uIGZvciBsYWJlbCB2YWx1ZXNcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlU2VhcmNoVGVybX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3RBcmVhfSByZWY9e3RoaXMudmFsdWVMaXN0c1JlZn0+XG4gICAgICAgICAgICAgICAge3NlbGVjdGVkTGFiZWxzLm1hcCgobGFiZWwpID0+IChcbiAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cImxpc3RcIlxuICAgICAgICAgICAgICAgICAgICBrZXk9e2xhYmVsLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2BWYWx1ZXMgZm9yICR7bGFiZWwubmFtZX1gfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3RXcmFwcGVyfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnZhbHVlVGl0bGV9PlxuICAgICAgICAgICAgICAgICAgICAgIDxQcm9tTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9e2xhYmVsLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtsYWJlbC5sb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtsYWJlbC5zZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbj17bGFiZWwuaGlkZGVufVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBubyBmYWNldHMsIHdlIHdhbnQgdG8gc2hvdyBudW1iZXIgb2YgYWxsIGxhYmVsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXRzPXtsYWJlbC5mYWNldHMgfHwgbGFiZWwudmFsdWVzPy5sZW5ndGh9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tMYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPEZpeGVkU2l6ZUxpc3RcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e01hdGgubWluKDIwMCwgTElTVF9JVEVNX1NJWkUgKiAobGFiZWwudmFsdWVzPy5sZW5ndGggfHwgMCkpfVxuICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db3VudD17bGFiZWwudmFsdWVzPy5sZW5ndGggfHwgMH1cbiAgICAgICAgICAgICAgICAgICAgICBpdGVtU2l6ZT17Mjh9XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbUtleT17KGkpID0+IChsYWJlbC52YWx1ZXMgYXMgRmFjZXR0YWJsZVZhbHVlW10pW2ldLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg9ezIwMH1cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52YWx1ZUxpc3R9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7KHsgaW5kZXgsIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGFiZWwudmFsdWVzPy5baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UHJvbUxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtsYWJlbC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlPy5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXt2YWx1ZT8uc2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm09e3ZhbHVlU2VhcmNoVGVybX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgPC9GaXhlZFNpemVMaXN0PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvSG9yaXpvbnRhbEdyb3VwPlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc2VjdGlvbn0+XG4gICAgICAgICAgPExhYmVsPjQuIFJlc3VsdGluZyBzZWxlY3RvcjwvTGFiZWw+XG4gICAgICAgICAgPGRpdiBhcmlhLWxhYmVsPVwic2VsZWN0b3JcIiBjbGFzc05hbWU9e3N0eWxlcy5zZWxlY3Rvcn0+XG4gICAgICAgICAgICB7c2VsZWN0b3J9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3ZhbGlkYXRpb25TdGF0dXMgJiYgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy52YWxpZGF0aW9uU3RhdHVzfT57dmFsaWRhdGlvblN0YXR1c308L2Rpdj59XG4gICAgICAgICAgPEhvcml6b250YWxHcm91cD5cbiAgICAgICAgICAgIDxCdXR0b24gYXJpYS1sYWJlbD1cIlVzZSBzZWxlY3RvciBmb3IgcXVlcnkgYnV0dG9uXCIgZGlzYWJsZWQ9e2VtcHR5fSBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tSdW5RdWVyeX0+XG4gICAgICAgICAgICAgIFVzZSBxdWVyeVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJVc2Ugc2VsZWN0b3IgYXMgbWV0cmljcyBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tSdW5SYXRlUXVlcnl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFVzZSBhcyByYXRlIHF1ZXJ5XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlZhbGlkYXRlIHN1Ym1pdCBidXR0b25cIlxuICAgICAgICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2VtcHR5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uQ2xpY2tWYWxpZGF0ZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgVmFsaWRhdGUgc2VsZWN0b3JcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJ1dHRvbiBhcmlhLWxhYmVsPVwiU2VsZWN0b3IgY2xlYXIgYnV0dG9uXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMub25DbGlja0NsZWFyfT5cbiAgICAgICAgICAgICAgQ2xlYXJcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2N4KHN0eWxlcy5zdGF0dXMsIChzdGF0dXMgfHwgZXJyb3IpICYmIHN0eWxlcy5zdGF0dXNTaG93aW5nKX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17ZXJyb3IgPyBzdHlsZXMuZXJyb3IgOiAnJ30+e2Vycm9yIHx8IHN0YXR1c308L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L0hvcml6b250YWxHcm91cD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIgPSB3aXRoVGhlbWUoVW50aGVtZWRQcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIpO1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvcHMgfSBmcm9tICcuL01vbmFjb1F1ZXJ5RmllbGRQcm9wcyc7XG5cbmNvbnN0IEZpZWxkID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJwcm9tLXF1ZXJ5LWZpZWxkXCIgKi8gJy4vTW9uYWNvUXVlcnlGaWVsZCcpKTtcblxuZXhwb3J0IGNvbnN0IE1vbmFjb1F1ZXJ5RmllbGRMYXp5ID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17bnVsbH0+XG4gICAgICA8RmllbGQgey4uLnByb3BzfSAvPlxuICAgIDwvU3VzcGVuc2U+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1vbmFjb1F1ZXJ5RmllbGRMYXp5IH0gZnJvbSAnLi9Nb25hY29RdWVyeUZpZWxkTGF6eSc7XG5pbXBvcnQgeyBQcm9wcyBhcyBNb25hY29Qcm9wcyB9IGZyb20gJy4vTW9uYWNvUXVlcnlGaWVsZFByb3BzJztcblxudHlwZSBQcm9wcyA9IE9taXQ8TW9uYWNvUHJvcHMsICdvblJ1blF1ZXJ5JyB8ICdvbkJsdXInPiAmIHtcbiAgb25DaGFuZ2U6IChxdWVyeTogc3RyaW5nKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xuICBydW5RdWVyeU9uQmx1cjogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBjb25zdCBNb25hY29RdWVyeUZpZWxkV3JhcHBlciA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgbGFzdFJ1blZhbHVlUmVmID0gdXNlUmVmPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCB7IHJ1blF1ZXJ5T25CbHVyLCBvblJ1blF1ZXJ5LCBvbkNoYW5nZSwgLi4ucmVzdCB9ID0gcHJvcHM7XG5cbiAgY29uc3QgaGFuZGxlUnVuUXVlcnkgPSAodmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGxhc3RSdW5WYWx1ZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgb25DaGFuZ2UodmFsdWUpO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVCbHVyID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocnVuUXVlcnlPbkJsdXIpIHtcbiAgICAgIC8vIHJ1biBoYW5kbGVSdW5RdWVyeSBvbmx5IGlmIHRoZSBjdXJyZW50IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBsYXN0LXRpbWUtZXhlY3V0ZWQgdmFsdWVcbiAgICAgIGlmICh2YWx1ZSAhPT0gbGFzdFJ1blZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaGFuZGxlUnVuUXVlcnkodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbkNoYW5nZSh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiA8TW9uYWNvUXVlcnlGaWVsZExhenkgb25SdW5RdWVyeT17aGFuZGxlUnVuUXVlcnl9IG9uQmx1cj17aGFuZGxlQmx1cn0gey4uLnJlc3R9IC8+O1xufTtcbiIsImltcG9ydCBSZWFjdCwgeyBGdW5jdGlvbkNvbXBvbmVudCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IElubGluZUZvcm1MYWJlbCwgSW5wdXQgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IEtub3duQXp1cmVDbG91ZHMsIEF6dXJlQ3JlZGVudGlhbHMgfSBmcm9tICcuL0F6dXJlQ3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgZ2V0Q3JlZGVudGlhbHMsIHVwZGF0ZUNyZWRlbnRpYWxzIH0gZnJvbSAnLi9BenVyZUNyZWRlbnRpYWxzQ29uZmlnJztcbmltcG9ydCB7IEF6dXJlQ3JlZGVudGlhbHNGb3JtIH0gZnJvbSAnLi9BenVyZUNyZWRlbnRpYWxzRm9ybSc7XG5pbXBvcnQgeyBIdHRwU2V0dGluZ3NCYXNlUHJvcHMgfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cy9EYXRhU291cmNlU2V0dGluZ3MvdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgQXp1cmVBdXRoU2V0dGluZ3M6IEZ1bmN0aW9uQ29tcG9uZW50PEh0dHBTZXR0aW5nc0Jhc2VQcm9wcz4gPSAocHJvcHM6IEh0dHBTZXR0aW5nc0Jhc2VQcm9wcykgPT4ge1xuICBjb25zdCB7IGRhdGFTb3VyY2VDb25maWcsIG9uQ2hhbmdlIH0gPSBwcm9wcztcblxuICBjb25zdCBjcmVkZW50aWFscyA9IHVzZU1lbW8oKCkgPT4gZ2V0Q3JlZGVudGlhbHMoZGF0YVNvdXJjZUNvbmZpZyksIFtkYXRhU291cmNlQ29uZmlnXSk7XG5cbiAgY29uc3Qgb25DcmVkZW50aWFsc0NoYW5nZSA9IChjcmVkZW50aWFsczogQXp1cmVDcmVkZW50aWFscyk6IHZvaWQgPT4ge1xuICAgIG9uQ2hhbmdlKHVwZGF0ZUNyZWRlbnRpYWxzKGRhdGFTb3VyY2VDb25maWcsIGNyZWRlbnRpYWxzKSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGg2PkF6dXJlIEF1dGhlbnRpY2F0aW9uPC9oNj5cbiAgICAgIDxBenVyZUNyZWRlbnRpYWxzRm9ybVxuICAgICAgICBtYW5hZ2VkSWRlbnRpdHlFbmFibGVkPXtjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZH1cbiAgICAgICAgY3JlZGVudGlhbHM9e2NyZWRlbnRpYWxzfVxuICAgICAgICBhenVyZUNsb3VkT3B0aW9ucz17S25vd25BenVyZUNsb3Vkc31cbiAgICAgICAgb25DcmVkZW50aWFsc0NoYW5nZT17b25DcmVkZW50aWFsc0NoYW5nZX1cbiAgICAgIC8+XG4gICAgICA8aDY+QXp1cmUgQ29uZmlndXJhdGlvbjwvaDY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tZ3JvdXBcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbCBjbGFzc05hbWU9XCJ3aWR0aC0xMlwiPkFBRCByZXNvdXJjZSBJRDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWR0aC0xNVwiPlxuICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC0zMFwiXG4gICAgICAgICAgICAgICAgdmFsdWU9e2RhdGFTb3VyY2VDb25maWcuanNvbkRhdGEuYXp1cmVFbmRwb2ludFJlc291cmNlSWQgfHwgJyd9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT5cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YVNvdXJjZUNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAganNvbkRhdGE6IHsgLi4uZGF0YVNvdXJjZUNvbmZpZy5qc29uRGF0YSwgYXp1cmVFbmRwb2ludFJlc291cmNlSWQ6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBenVyZUF1dGhTZXR0aW5ncztcbiIsImltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5leHBvcnQgZW51bSBBenVyZUNsb3VkIHtcbiAgUHVibGljID0gJ0F6dXJlQ2xvdWQnLFxuICBDaGluYSA9ICdBenVyZUNoaW5hQ2xvdWQnLFxuICBVU0dvdmVybm1lbnQgPSAnQXp1cmVVU0dvdmVybm1lbnQnLFxuICBHZXJtYW55ID0gJ0F6dXJlR2VybWFuQ2xvdWQnLFxuICBOb25lID0gJycsXG59XG5cbmV4cG9ydCBjb25zdCBLbm93bkF6dXJlQ2xvdWRzID0gW1xuICB7IHZhbHVlOiBBenVyZUNsb3VkLlB1YmxpYywgbGFiZWw6ICdBenVyZScgfSxcbiAgeyB2YWx1ZTogQXp1cmVDbG91ZC5DaGluYSwgbGFiZWw6ICdBenVyZSBDaGluYScgfSxcbiAgeyB2YWx1ZTogQXp1cmVDbG91ZC5VU0dvdmVybm1lbnQsIGxhYmVsOiAnQXp1cmUgVVMgR292ZXJubWVudCcgfSxcbiAgeyB2YWx1ZTogQXp1cmVDbG91ZC5HZXJtYW55LCBsYWJlbDogJ0F6dXJlIEdlcm1hbnknIH0sXG5dIGFzIFNlbGVjdGFibGVWYWx1ZVtdO1xuXG5leHBvcnQgdHlwZSBBenVyZUF1dGhUeXBlID0gJ21zaScgfCAnY2xpZW50c2VjcmV0JztcblxuZXhwb3J0IHR5cGUgQ29uY2VhbGVkU2VjcmV0ID0gc3ltYm9sO1xuXG5pbnRlcmZhY2UgQXp1cmVDcmVkZW50aWFsc0Jhc2Uge1xuICBhdXRoVHlwZTogQXp1cmVBdXRoVHlwZTtcbiAgZGVmYXVsdFN1YnNjcmlwdGlvbklkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF6dXJlTWFuYWdlZElkZW50aXR5Q3JlZGVudGlhbHMgZXh0ZW5kcyBBenVyZUNyZWRlbnRpYWxzQmFzZSB7XG4gIGF1dGhUeXBlOiAnbXNpJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBenVyZUNsaWVudFNlY3JldENyZWRlbnRpYWxzIGV4dGVuZHMgQXp1cmVDcmVkZW50aWFsc0Jhc2Uge1xuICBhdXRoVHlwZTogJ2NsaWVudHNlY3JldCc7XG4gIGF6dXJlQ2xvdWQ/OiBzdHJpbmc7XG4gIHRlbmFudElkPzogc3RyaW5nO1xuICBjbGllbnRJZD86IHN0cmluZztcbiAgY2xpZW50U2VjcmV0Pzogc3RyaW5nIHwgQ29uY2VhbGVkU2VjcmV0O1xufVxuXG5leHBvcnQgdHlwZSBBenVyZUNyZWRlbnRpYWxzID0gQXp1cmVNYW5hZ2VkSWRlbnRpdHlDcmVkZW50aWFscyB8IEF6dXJlQ2xpZW50U2VjcmV0Q3JlZGVudGlhbHM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NyZWRlbnRpYWxzQ29tcGxldGUoY3JlZGVudGlhbHM6IEF6dXJlQ3JlZGVudGlhbHMpOiBib29sZWFuIHtcbiAgc3dpdGNoIChjcmVkZW50aWFscy5hdXRoVHlwZSkge1xuICAgIGNhc2UgJ21zaSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdjbGllbnRzZWNyZXQnOlxuICAgICAgcmV0dXJuICEhKGNyZWRlbnRpYWxzLmF6dXJlQ2xvdWQgJiYgY3JlZGVudGlhbHMudGVuYW50SWQgJiYgY3JlZGVudGlhbHMuY2xpZW50SWQgJiYgY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0KTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0YVNvdXJjZVNldHRpbmdzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcbmltcG9ydCB7IEF6dXJlQ2xvdWQsIEF6dXJlQ3JlZGVudGlhbHMsIENvbmNlYWxlZFNlY3JldCB9IGZyb20gJy4vQXp1cmVDcmVkZW50aWFscyc7XG5cbmNvbnN0IGNvbmNlYWxlZDogQ29uY2VhbGVkU2VjcmV0ID0gU3ltYm9sKCdDb25jZWFsZWQgY2xpZW50IHNlY3JldCcpO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0QXp1cmVDbG91ZCgpOiBzdHJpbmcge1xuICByZXR1cm4gY29uZmlnLmF6dXJlLmNsb3VkIHx8IEF6dXJlQ2xvdWQuUHVibGljO1xufVxuXG5mdW5jdGlvbiBnZXRTZWNyZXQob3B0aW9uczogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55Pik6IHVuZGVmaW5lZCB8IHN0cmluZyB8IENvbmNlYWxlZFNlY3JldCB7XG4gIGlmIChvcHRpb25zLnNlY3VyZUpzb25GaWVsZHMuYXp1cmVDbGllbnRTZWNyZXQpIHtcbiAgICAvLyBUaGUgc2VjcmV0IGlzIGNvbmNlYWxlZCBvbiBzZXJ2ZXJcbiAgICByZXR1cm4gY29uY2VhbGVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNlY3JldCA9IG9wdGlvbnMuc2VjdXJlSnNvbkRhdGE/LmF6dXJlQ2xpZW50U2VjcmV0O1xuICAgIHJldHVybiB0eXBlb2Ygc2VjcmV0ID09PSAnc3RyaW5nJyAmJiBzZWNyZXQubGVuZ3RoID4gMCA/IHNlY3JldCA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQ3JlZGVudGlhbHMob3B0aW9uczogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55Pik6IGJvb2xlYW4ge1xuICByZXR1cm4gISFvcHRpb25zLmpzb25EYXRhLmF6dXJlQ3JlZGVudGlhbHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q3JlZGVudGlhbHMoKTogQXp1cmVDcmVkZW50aWFscyB7XG4gIGlmIChjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgIHJldHVybiB7IGF1dGhUeXBlOiAnbXNpJyB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGF1dGhUeXBlOiAnY2xpZW50c2VjcmV0JywgYXp1cmVDbG91ZDogZ2V0RGVmYXVsdEF6dXJlQ2xvdWQoKSB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogQXp1cmVDcmVkZW50aWFscyB7XG4gIGNvbnN0IGNyZWRlbnRpYWxzID0gb3B0aW9ucy5qc29uRGF0YS5henVyZUNyZWRlbnRpYWxzIGFzIEF6dXJlQ3JlZGVudGlhbHMgfCB1bmRlZmluZWQ7XG5cbiAgLy8gSWYgbm8gY3JlZGVudGlhbHMgc2F2ZWQsIHRoZW4gcmV0dXJuIGVtcHR5IGNyZWRlbnRpYWxzXG4gIC8vIG9mIHR5cGUgYmFzZWQgb24gd2hldGhlciB0aGUgbWFuYWdlZCBpZGVudGl0eSBlbmFibGVkXG4gIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdENyZWRlbnRpYWxzKCk7XG4gIH1cblxuICBzd2l0Y2ggKGNyZWRlbnRpYWxzLmF1dGhUeXBlKSB7XG4gICAgY2FzZSAnbXNpJzpcbiAgICAgIGlmIChjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGF1dGhUeXBlOiAnbXNpJyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGF1dGhlbnRpY2F0aW9uIHR5cGUgaXMgbWFuYWdlZCBpZGVudGl0eSBidXQgbWFuYWdlZCBpZGVudGl0aWVzIHdlcmUgZGlzYWJsZWQgaW4gR3JhZmFuYSBjb25maWcsXG4gICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIGZhbGxiYWNrIHRvIGFuIGVtcHR5IGFwcCByZWdpc3RyYXRpb24gKGNsaWVudCBzZWNyZXQpIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhdXRoVHlwZTogJ2NsaWVudHNlY3JldCcsXG4gICAgICAgICAgYXp1cmVDbG91ZDogZ2V0RGVmYXVsdEF6dXJlQ2xvdWQoKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdjbGllbnRzZWNyZXQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aFR5cGU6ICdjbGllbnRzZWNyZXQnLFxuICAgICAgICBhenVyZUNsb3VkOiBjcmVkZW50aWFscy5henVyZUNsb3VkIHx8IGdldERlZmF1bHRBenVyZUNsb3VkKCksXG4gICAgICAgIHRlbmFudElkOiBjcmVkZW50aWFscy50ZW5hbnRJZCxcbiAgICAgICAgY2xpZW50SWQ6IGNyZWRlbnRpYWxzLmNsaWVudElkLFxuICAgICAgICBjbGllbnRTZWNyZXQ6IGdldFNlY3JldChvcHRpb25zKSxcbiAgICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNyZWRlbnRpYWxzKFxuICBvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+LFxuICBjcmVkZW50aWFsczogQXp1cmVDcmVkZW50aWFsc1xuKTogRGF0YVNvdXJjZVNldHRpbmdzPGFueSwgYW55PiB7XG4gIHN3aXRjaCAoY3JlZGVudGlhbHMuYXV0aFR5cGUpIHtcbiAgICBjYXNlICdtc2knOlxuICAgICAgaWYgKCFjb25maWcuYXp1cmUubWFuYWdlZElkZW50aXR5RW5hYmxlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbmFnZWQgSWRlbnRpdHkgYXV0aGVudGljYXRpb24gaXMgbm90IGVuYWJsZWQgaW4gR3JhZmFuYSBjb25maWcuJyk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGpzb25EYXRhOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5qc29uRGF0YSxcbiAgICAgICAgICBhenVyZUNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICBhdXRoVHlwZTogJ21zaScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuXG4gICAgY2FzZSAnY2xpZW50c2VjcmV0JzpcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGpzb25EYXRhOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5qc29uRGF0YSxcbiAgICAgICAgICBhenVyZUNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICBhdXRoVHlwZTogJ2NsaWVudHNlY3JldCcsXG4gICAgICAgICAgICBhenVyZUNsb3VkOiBjcmVkZW50aWFscy5henVyZUNsb3VkIHx8IGdldERlZmF1bHRBenVyZUNsb3VkKCksXG4gICAgICAgICAgICB0ZW5hbnRJZDogY3JlZGVudGlhbHMudGVuYW50SWQsXG4gICAgICAgICAgICBjbGllbnRJZDogY3JlZGVudGlhbHMuY2xpZW50SWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgc2VjdXJlSnNvbkRhdGE6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLnNlY3VyZUpzb25EYXRhLFxuICAgICAgICAgIGF6dXJlQ2xpZW50U2VjcmV0OlxuICAgICAgICAgICAgdHlwZW9mIGNyZWRlbnRpYWxzLmNsaWVudFNlY3JldCA9PT0gJ3N0cmluZycgJiYgY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0Lmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgPyBjcmVkZW50aWFscy5jbGllbnRTZWNyZXRcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIHNlY3VyZUpzb25GaWVsZHM6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLnNlY3VyZUpzb25GaWVsZHMsXG4gICAgICAgICAgYXp1cmVDbGllbnRTZWNyZXQ6IHR5cGVvZiBjcmVkZW50aWFscy5jbGllbnRTZWNyZXQgPT09ICdzeW1ib2wnLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogUGFydGlhbDxEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+PiB7XG4gIHJldHVybiB7XG4gICAganNvbkRhdGE6IHtcbiAgICAgIC4uLm9wdGlvbnMuanNvbkRhdGEsXG4gICAgICBhenVyZUNyZWRlbnRpYWxzOiBnZXREZWZhdWx0Q3JlZGVudGlhbHMoKSxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRDcmVkZW50aWFscyhvcHRpb25zOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogUGFydGlhbDxEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+PiB7XG4gIHJldHVybiB7XG4gICAganNvbkRhdGE6IHtcbiAgICAgIC4uLm9wdGlvbnMuanNvbkRhdGEsXG4gICAgICBhenVyZUF1dGg6IHVuZGVmaW5lZCxcbiAgICAgIGF6dXJlQ3JlZGVudGlhbHM6IHVuZGVmaW5lZCxcbiAgICAgIGF6dXJlRW5kcG9pbnRSZXNvdXJjZUlkOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDaGFuZ2VFdmVudCwgRnVuY3Rpb25Db21wb25lbnQsIHVzZUVmZmVjdCwgdXNlUmVkdWNlciwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IElubGluZUZvcm1MYWJlbCwgQnV0dG9uIH0gZnJvbSAnQGdyYWZhbmEvdWkvc3JjL2NvbXBvbmVudHMnO1xuaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWkvc3JjL2NvbXBvbmVudHMvRm9ybXMvTGVnYWN5L1NlbGVjdC9TZWxlY3QnO1xuaW1wb3J0IHsgSW5wdXQgfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cy9Gb3Jtcy9MZWdhY3kvSW5wdXQvSW5wdXQnO1xuaW1wb3J0IHsgQXp1cmVBdXRoVHlwZSwgQXp1cmVDcmVkZW50aWFscywgaXNDcmVkZW50aWFsc0NvbXBsZXRlIH0gZnJvbSAnLi9BenVyZUNyZWRlbnRpYWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG1hbmFnZWRJZGVudGl0eUVuYWJsZWQ6IGJvb2xlYW47XG4gIGNyZWRlbnRpYWxzOiBBenVyZUNyZWRlbnRpYWxzO1xuICBhenVyZUNsb3VkT3B0aW9ucz86IFNlbGVjdGFibGVWYWx1ZVtdO1xuICBvbkNyZWRlbnRpYWxzQ2hhbmdlOiAodXBkYXRlZENyZWRlbnRpYWxzOiBBenVyZUNyZWRlbnRpYWxzKSA9PiB2b2lkO1xuICBnZXRTdWJzY3JpcHRpb25zPzogKCkgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG59XG5cbmNvbnN0IGF1dGhUeXBlT3B0aW9uczogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPEF6dXJlQXV0aFR5cGU+PiA9IFtcbiAge1xuICAgIHZhbHVlOiAnbXNpJyxcbiAgICBsYWJlbDogJ01hbmFnZWQgSWRlbnRpdHknLFxuICB9LFxuICB7XG4gICAgdmFsdWU6ICdjbGllbnRzZWNyZXQnLFxuICAgIGxhYmVsOiAnQXBwIFJlZ2lzdHJhdGlvbicsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgQXp1cmVDcmVkZW50aWFsc0Zvcm06IEZ1bmN0aW9uQ29tcG9uZW50PFByb3BzPiA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjcmVkZW50aWFscywgYXp1cmVDbG91ZE9wdGlvbnMsIG9uQ3JlZGVudGlhbHNDaGFuZ2UsIGdldFN1YnNjcmlwdGlvbnMgfSA9IHByb3BzO1xuICBjb25zdCBoYXNSZXF1aXJlZEZpZWxkcyA9IGlzQ3JlZGVudGlhbHNDb21wbGV0ZShjcmVkZW50aWFscyk7XG5cbiAgY29uc3QgW3N1YnNjcmlwdGlvbnMsIHNldFN1YnNjcmlwdGlvbnNdID0gdXNlU3RhdGU8QXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+PihbXSk7XG4gIGNvbnN0IFtsb2FkU3Vic2NyaXB0aW9uc0NsaWNrZWQsIG9uTG9hZFN1YnNjcmlwdGlvbnNdID0gdXNlUmVkdWNlcigodmFsKSA9PiB2YWwgKyAxLCAwKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWdldFN1YnNjcmlwdGlvbnMgfHwgIWhhc1JlcXVpcmVkRmllbGRzKSB7XG4gICAgICB1cGRhdGVTdWJzY3JpcHRpb25zKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgZ2V0U3Vic2NyaXB0aW9ucygpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKCFjYW5jZWxlZCkge1xuICAgICAgICB1cGRhdGVTdWJzY3JpcHRpb25zKHJlc3VsdCwgbG9hZFN1YnNjcmlwdGlvbnNDbGlja2VkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLy8gVGhpcyBlZmZlY3QgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9ubHkgb25jZSBpbml0aWFsbHkgYW5kIG9uIExvYWQgU3Vic2NyaXB0aW9ucyBjbGlja1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2xvYWRTdWJzY3JpcHRpb25zQ2xpY2tlZF0pO1xuXG4gIGNvbnN0IHVwZGF0ZVN1YnNjcmlwdGlvbnMgPSAocmVjZWl2ZWQ6IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxzdHJpbmc+PiwgYXV0b1NlbGVjdCA9IGZhbHNlKSA9PiB7XG4gICAgc2V0U3Vic2NyaXB0aW9ucyhyZWNlaXZlZCk7XG4gICAgaWYgKGdldFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIGlmIChhdXRvU2VsZWN0ICYmICFjcmVkZW50aWFscy5kZWZhdWx0U3Vic2NyaXB0aW9uSWQgJiYgcmVjZWl2ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBTZWxlY3RpbmcgdGhlIGRlZmF1bHQgc3Vic2NyaXB0aW9uIGlmIHN1YnNjcmlwdGlvbnMgcmVjZWl2ZWQgYnV0IG5vIGRlZmF1bHQgc3Vic2NyaXB0aW9uIHNlbGVjdGVkXG4gICAgICAgIG9uU3Vic2NyaXB0aW9uQ2hhbmdlKHJlY2VpdmVkWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAoY3JlZGVudGlhbHMuZGVmYXVsdFN1YnNjcmlwdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gcmVjZWl2ZWQuZmluZCgob3B0KSA9PiBvcHQudmFsdWUgPT09IGNyZWRlbnRpYWxzLmRlZmF1bHRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAvLyBVbnNlbGVjdGluZyB0aGUgZGVmYXVsdCBzdWJzY3JpcHRpb24gaWYgaXQgaXNuJ3QgZm91bmQgYW1vbmcgdGhlIHJlY2VpdmVkIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICBvblN1YnNjcmlwdGlvbkNoYW5nZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uQXV0aFR5cGVDaGFuZ2UgPSAoc2VsZWN0ZWQ6IFNlbGVjdGFibGVWYWx1ZTxBenVyZUF1dGhUeXBlPikgPT4ge1xuICAgIGlmIChvbkNyZWRlbnRpYWxzQ2hhbmdlKSB7XG4gICAgICBzZXRTdWJzY3JpcHRpb25zKFtdKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQ6IEF6dXJlQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIC4uLmNyZWRlbnRpYWxzLFxuICAgICAgICBhdXRoVHlwZTogc2VsZWN0ZWQudmFsdWUgfHwgJ21zaScsXG4gICAgICAgIGRlZmF1bHRTdWJzY3JpcHRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIG9uQ3JlZGVudGlhbHNDaGFuZ2UodXBkYXRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uQXp1cmVDbG91ZENoYW5nZSA9IChzZWxlY3RlZDogU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4pID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSAmJiBjcmVkZW50aWFscy5hdXRoVHlwZSA9PT0gJ2NsaWVudHNlY3JldCcpIHtcbiAgICAgIHNldFN1YnNjcmlwdGlvbnMoW10pO1xuICAgICAgY29uc3QgdXBkYXRlZDogQXp1cmVDcmVkZW50aWFscyA9IHtcbiAgICAgICAgLi4uY3JlZGVudGlhbHMsXG4gICAgICAgIGF6dXJlQ2xvdWQ6IHNlbGVjdGVkLnZhbHVlLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvblRlbmFudElkQ2hhbmdlID0gKGV2ZW50OiBDaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGlmIChvbkNyZWRlbnRpYWxzQ2hhbmdlICYmIGNyZWRlbnRpYWxzLmF1dGhUeXBlID09PSAnY2xpZW50c2VjcmV0Jykge1xuICAgICAgc2V0U3Vic2NyaXB0aW9ucyhbXSk7XG4gICAgICBjb25zdCB1cGRhdGVkOiBBenVyZUNyZWRlbnRpYWxzID0ge1xuICAgICAgICAuLi5jcmVkZW50aWFscyxcbiAgICAgICAgdGVuYW50SWQ6IGV2ZW50LnRhcmdldC52YWx1ZSxcbiAgICAgICAgZGVmYXVsdFN1YnNjcmlwdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgICAgb25DcmVkZW50aWFsc0NoYW5nZSh1cGRhdGVkKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb25DbGllbnRJZENoYW5nZSA9IChldmVudDogQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSAmJiBjcmVkZW50aWFscy5hdXRoVHlwZSA9PT0gJ2NsaWVudHNlY3JldCcpIHtcbiAgICAgIHNldFN1YnNjcmlwdGlvbnMoW10pO1xuICAgICAgY29uc3QgdXBkYXRlZDogQXp1cmVDcmVkZW50aWFscyA9IHtcbiAgICAgICAgLi4uY3JlZGVudGlhbHMsXG4gICAgICAgIGNsaWVudElkOiBldmVudC50YXJnZXQudmFsdWUsXG4gICAgICAgIGRlZmF1bHRTdWJzY3JpcHRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIG9uQ3JlZGVudGlhbHNDaGFuZ2UodXBkYXRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uQ2xpZW50U2VjcmV0Q2hhbmdlID0gKGV2ZW50OiBDaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGlmIChvbkNyZWRlbnRpYWxzQ2hhbmdlICYmIGNyZWRlbnRpYWxzLmF1dGhUeXBlID09PSAnY2xpZW50c2VjcmV0Jykge1xuICAgICAgc2V0U3Vic2NyaXB0aW9ucyhbXSk7XG4gICAgICBjb25zdCB1cGRhdGVkOiBBenVyZUNyZWRlbnRpYWxzID0ge1xuICAgICAgICAuLi5jcmVkZW50aWFscyxcbiAgICAgICAgY2xpZW50U2VjcmV0OiBldmVudC50YXJnZXQudmFsdWUsXG4gICAgICAgIGRlZmF1bHRTdWJzY3JpcHRpb25JZDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIG9uQ3JlZGVudGlhbHNDaGFuZ2UodXBkYXRlZCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uQ2xpZW50U2VjcmV0UmVzZXQgPSAoKSA9PiB7XG4gICAgaWYgKG9uQ3JlZGVudGlhbHNDaGFuZ2UgJiYgY3JlZGVudGlhbHMuYXV0aFR5cGUgPT09ICdjbGllbnRzZWNyZXQnKSB7XG4gICAgICBzZXRTdWJzY3JpcHRpb25zKFtdKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQ6IEF6dXJlQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIC4uLmNyZWRlbnRpYWxzLFxuICAgICAgICBjbGllbnRTZWNyZXQ6ICcnLFxuICAgICAgICBkZWZhdWx0U3Vic2NyaXB0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBvbkNyZWRlbnRpYWxzQ2hhbmdlKHVwZGF0ZWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvblN1YnNjcmlwdGlvbkNoYW5nZSA9IChzZWxlY3RlZDogU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4gfCB1bmRlZmluZWQpID0+IHtcbiAgICBpZiAob25DcmVkZW50aWFsc0NoYW5nZSkge1xuICAgICAgY29uc3QgdXBkYXRlZDogQXp1cmVDcmVkZW50aWFscyA9IHtcbiAgICAgICAgLi4uY3JlZGVudGlhbHMsXG4gICAgICAgIGRlZmF1bHRTdWJzY3JpcHRpb25JZDogc2VsZWN0ZWQ/LnZhbHVlLFxuICAgICAgfTtcbiAgICAgIG9uQ3JlZGVudGlhbHNDaGFuZ2UodXBkYXRlZCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWdyb3VwXCI+XG4gICAgICB7cHJvcHMubWFuYWdlZElkZW50aXR5RW5hYmxlZCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIiB0b29sdGlwPVwiQ2hvb3NlIHRoZSB0eXBlIG9mIGF1dGhlbnRpY2F0aW9uIHRvIEF6dXJlIHNlcnZpY2VzXCI+XG4gICAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICA8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgICAgbWVudVNob3VsZFBvcnRhbFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC0xNVwiXG4gICAgICAgICAgICAgIHZhbHVlPXthdXRoVHlwZU9wdGlvbnMuZmluZCgob3B0KSA9PiBvcHQudmFsdWUgPT09IGNyZWRlbnRpYWxzLmF1dGhUeXBlKX1cbiAgICAgICAgICAgICAgb3B0aW9ucz17YXV0aFR5cGVPcHRpb25zfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17b25BdXRoVHlwZUNoYW5nZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIHtjcmVkZW50aWFscy5hdXRoVHlwZSA9PT0gJ2NsaWVudHNlY3JldCcgJiYgKFxuICAgICAgICA8PlxuICAgICAgICAgIHthenVyZUNsb3VkT3B0aW9ucyAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIiB0b29sdGlwPVwiQ2hvb3NlIGFuIEF6dXJlIENsb3VkXCI+XG4gICAgICAgICAgICAgICAgICBBenVyZSBDbG91ZFxuICAgICAgICAgICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgICAgICAgIG1lbnVTaG91bGRQb3J0YWxcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTE1XCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXthenVyZUNsb3VkT3B0aW9ucy5maW5kKChvcHQpID0+IG9wdC52YWx1ZSA9PT0gY3JlZGVudGlhbHMuYXp1cmVDbG91ZCl9XG4gICAgICAgICAgICAgICAgICBvcHRpb25zPXthenVyZUNsb3VkT3B0aW9uc31cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkF6dXJlQ2xvdWRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIGNsYXNzTmFtZT1cIndpZHRoLTEyXCI+RGlyZWN0b3J5ICh0ZW5hbnQpIElEPC9JbmxpbmVGb3JtTGFiZWw+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkdGgtMTVcIj5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTMwXCJcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtjcmVkZW50aWFscy50ZW5hbnRJZCB8fCAnJ31cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvblRlbmFudElkQ2hhbmdlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIj5BcHBsaWNhdGlvbiAoY2xpZW50KSBJRDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndpZHRoLTE1XCI+XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC0zMFwiXG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFwiXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17Y3JlZGVudGlhbHMuY2xpZW50SWQgfHwgJyd9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DbGllbnRJZENoYW5nZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHt0eXBlb2YgY3JlZGVudGlhbHMuY2xpZW50U2VjcmV0ID09PSAnc3ltYm9sJyA/IChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgICAgPElubGluZUZvcm1MYWJlbCBjbGFzc05hbWU9XCJ3aWR0aC0xMlwiPkNsaWVudCBTZWNyZXQ8L0lubGluZUZvcm1MYWJlbD5cbiAgICAgICAgICAgICAgICA8SW5wdXQgY2xhc3NOYW1lPVwid2lkdGgtMjVcIiBwbGFjZWhvbGRlcj1cImNvbmZpZ3VyZWRcIiBkaXNhYmxlZD17dHJ1ZX0gLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWF4LXdpZHRoLTMwIGdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgICAgICAgICA8QnV0dG9uIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17b25DbGllbnRTZWNyZXRSZXNldH0+XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0XG4gICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICAgICAgICA8SW5saW5lRm9ybUxhYmVsIGNsYXNzTmFtZT1cIndpZHRoLTEyXCI+Q2xpZW50IFNlY3JldDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2lkdGgtMTVcIj5cbiAgICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC0zMFwiXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXCJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2NyZWRlbnRpYWxzLmNsaWVudFNlY3JldCB8fCAnJ31cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2xpZW50U2VjcmV0Q2hhbmdlfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8Lz5cbiAgICAgICl9XG4gICAgICB7Z2V0U3Vic2NyaXB0aW9ucyAmJiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWwgY2xhc3NOYW1lPVwid2lkdGgtMTJcIj5EZWZhdWx0IFN1YnNjcmlwdGlvbjwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndpZHRoLTI1XCI+XG4gICAgICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICAgICAgbWVudVNob3VsZFBvcnRhbFxuICAgICAgICAgICAgICAgICAgdmFsdWU9e1xuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFscy5kZWZhdWx0U3Vic2NyaXB0aW9uSWRcbiAgICAgICAgICAgICAgICAgICAgICA/IHN1YnNjcmlwdGlvbnMuZmluZCgob3B0KSA9PiBvcHQudmFsdWUgPT09IGNyZWRlbnRpYWxzLmRlZmF1bHRTdWJzY3JpcHRpb25JZClcbiAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3B0aW9ucz17c3Vic2NyaXB0aW9uc31cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvblN1YnNjcmlwdGlvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1pbmxpbmVcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13aWR0aC0zMCBnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17b25Mb2FkU3Vic2NyaXB0aW9uc31cbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXshaGFzUmVxdWlyZWRGaWVsZHN9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgTG9hZCBTdWJzY3JpcHRpb25zXG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF6dXJlQ3JlZGVudGlhbHNGb3JtO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFsZXJ0aW5nU2V0dGluZ3MsIERhdGFTb3VyY2VIdHRwU2V0dGluZ3MsIEFsZXJ0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgRGF0YVNvdXJjZVBsdWdpbk9wdGlvbnNFZGl0b3JQcm9wcywgRGF0YVNvdXJjZVNldHRpbmdzIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICdhcHAvY29yZS9jb25maWcnO1xuaW1wb3J0IHsgUHJvbU9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBBenVyZUF1dGhTZXR0aW5ncyB9IGZyb20gJy4vQXp1cmVBdXRoU2V0dGluZ3MnO1xuaW1wb3J0IHsgUHJvbVNldHRpbmdzIH0gZnJvbSAnLi9Qcm9tU2V0dGluZ3MnO1xuaW1wb3J0IHsgaGFzQ3JlZGVudGlhbHMsIHNldERlZmF1bHRDcmVkZW50aWFscywgcmVzZXRDcmVkZW50aWFscyB9IGZyb20gJy4vQXp1cmVDcmVkZW50aWFsc0NvbmZpZyc7XG5pbXBvcnQgeyBnZXRBbGxBbGVydG1hbmFnZXJEYXRhU291cmNlcyB9IGZyb20gJ2FwcC9mZWF0dXJlcy9hbGVydGluZy91bmlmaWVkL3V0aWxzL2FsZXJ0bWFuYWdlcic7XG5cbmV4cG9ydCB0eXBlIFByb3BzID0gRGF0YVNvdXJjZVBsdWdpbk9wdGlvbnNFZGl0b3JQcm9wczxQcm9tT3B0aW9ucz47XG5leHBvcnQgY29uc3QgQ29uZmlnRWRpdG9yID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICBjb25zdCB7IG9wdGlvbnMsIG9uT3B0aW9uc0NoYW5nZSB9ID0gcHJvcHM7XG4gIGNvbnN0IGFsZXJ0bWFuYWdlcnMgPSBnZXRBbGxBbGVydG1hbmFnZXJEYXRhU291cmNlcygpO1xuXG4gIGNvbnN0IGF6dXJlQXV0aFNldHRpbmdzID0ge1xuICAgIGF6dXJlQXV0aFN1cHBvcnRlZDogY29uZmlnLmZlYXR1cmVUb2dnbGVzWydwcm9tZXRoZXVzX2F6dXJlX2F1dGgnXSA/PyBmYWxzZSxcbiAgICBnZXRBenVyZUF1dGhFbmFibGVkOiAoY29uZmlnOiBEYXRhU291cmNlU2V0dGluZ3M8YW55LCBhbnk+KTogYm9vbGVhbiA9PiBoYXNDcmVkZW50aWFscyhjb25maWcpLFxuICAgIHNldEF6dXJlQXV0aEVuYWJsZWQ6IChjb25maWc6IERhdGFTb3VyY2VTZXR0aW5nczxhbnksIGFueT4sIGVuYWJsZWQ6IGJvb2xlYW4pID0+XG4gICAgICBlbmFibGVkID8gc2V0RGVmYXVsdENyZWRlbnRpYWxzKGNvbmZpZykgOiByZXNldENyZWRlbnRpYWxzKGNvbmZpZyksXG4gICAgYXp1cmVTZXR0aW5nc1VJOiBBenVyZUF1dGhTZXR0aW5ncyxcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7b3B0aW9ucy5hY2Nlc3MgPT09ICdkaXJlY3QnICYmIChcbiAgICAgICAgPEFsZXJ0IHRpdGxlPVwiRGVwcmVjYXRpb24gTm90aWNlXCIgc2V2ZXJpdHk9XCJ3YXJuaW5nXCI+XG4gICAgICAgICAgQnJvd3NlciBhY2Nlc3MgbW9kZSBpbiB0aGUgUHJvbWV0aGV1cyBkYXRhc291cmNlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgICAgICA8L0FsZXJ0PlxuICAgICAgKX1cblxuICAgICAgPERhdGFTb3VyY2VIdHRwU2V0dGluZ3NcbiAgICAgICAgZGVmYXVsdFVybD1cImh0dHA6Ly9sb2NhbGhvc3Q6OTA5MFwiXG4gICAgICAgIGRhdGFTb3VyY2VDb25maWc9e29wdGlvbnN9XG4gICAgICAgIHNob3dBY2Nlc3NPcHRpb25zPXt0cnVlfVxuICAgICAgICBvbkNoYW5nZT17b25PcHRpb25zQ2hhbmdlfVxuICAgICAgICBzaWdWNEF1dGhUb2dnbGVFbmFibGVkPXtjb25maWcuc2lnVjRBdXRoRW5hYmxlZH1cbiAgICAgICAgYXp1cmVBdXRoU2V0dGluZ3M9e2F6dXJlQXV0aFNldHRpbmdzfVxuICAgICAgLz5cblxuICAgICAgPEFsZXJ0aW5nU2V0dGluZ3M8UHJvbU9wdGlvbnM+XG4gICAgICAgIGFsZXJ0bWFuYWdlckRhdGFTb3VyY2VzPXthbGVydG1hbmFnZXJzfVxuICAgICAgICBvcHRpb25zPXtvcHRpb25zfVxuICAgICAgICBvbk9wdGlvbnNDaGFuZ2U9e29uT3B0aW9uc0NoYW5nZX1cbiAgICAgIC8+XG5cbiAgICAgIDxQcm9tU2V0dGluZ3Mgb3B0aW9ucz17b3B0aW9uc30gb25PcHRpb25zQ2hhbmdlPXtvbk9wdGlvbnNDaGFuZ2V9IC8+XG4gICAgPC8+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IHNlbGVjdG9ycyB9IGZyb20gJ0BncmFmYW5hL2UyZS1zZWxlY3RvcnMnO1xuaW1wb3J0IHsgRGF0YVNvdXJjZVBpY2tlciB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgQnV0dG9uLCBJbmxpbmVGaWVsZCwgSW5saW5lU3dpdGNoLCBJbnB1dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG50eXBlIFByb3BzID0ge1xuICB2YWx1ZTogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb247XG4gIG9uQ2hhbmdlOiAodmFsdWU6IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uKSA9PiB2b2lkO1xuICBvbkRlbGV0ZTogKCkgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEV4ZW1wbGFyU2V0dGluZyh7IHZhbHVlLCBvbkNoYW5nZSwgb25EZWxldGUgfTogUHJvcHMpIHtcbiAgY29uc3QgW2lzSW50ZXJuYWxMaW5rLCBzZXRJc0ludGVybmFsTGlua10gPSB1c2VTdGF0ZShCb29sZWFuKHZhbHVlLmRhdGFzb3VyY2VVaWQpKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAgPElubGluZUZpZWxkIGxhYmVsPVwiSW50ZXJuYWwgbGlua1wiIGxhYmVsV2lkdGg9ezI0fT5cbiAgICAgICAgPD5cbiAgICAgICAgICA8SW5saW5lU3dpdGNoXG4gICAgICAgICAgICB2YWx1ZT17aXNJbnRlcm5hbExpbmt9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXtzZWxlY3RvcnMuY29tcG9uZW50cy5EYXRhU291cmNlLlByb21ldGhldXMuY29uZmlnUGFnZS5pbnRlcm5hbExpbmtTd2l0Y2h9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGV2KSA9PiBzZXRJc0ludGVybmFsTGluayhldi5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgdmFyaWFudD1cImRlc3RydWN0aXZlXCJcbiAgICAgICAgICAgIHRpdGxlPVwiUmVtb3ZlIGxpbmtcIlxuICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBvbkRlbGV0ZSgpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICBtYXJnaW4tbGVmdDogOHB4O1xuICAgICAgICAgICAgYH1cbiAgICAgICAgICAvPlxuICAgICAgICA8Lz5cbiAgICAgIDwvSW5saW5lRmllbGQ+XG5cbiAgICAgIHtpc0ludGVybmFsTGluayA/IChcbiAgICAgICAgPElubGluZUZpZWxkXG4gICAgICAgICAgbGFiZWw9XCJEYXRhIHNvdXJjZVwiXG4gICAgICAgICAgbGFiZWxXaWR0aD17MjR9XG4gICAgICAgICAgdG9vbHRpcD1cIlRoZSBkYXRhIHNvdXJjZSB0aGUgZXhlbXBsYXIgaXMgZ29pbmcgdG8gbmF2aWdhdGUgdG8uXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxEYXRhU291cmNlUGlja2VyXG4gICAgICAgICAgICB0cmFjaW5nPXt0cnVlfVxuICAgICAgICAgICAgY3VycmVudD17dmFsdWUuZGF0YXNvdXJjZVVpZH1cbiAgICAgICAgICAgIG5vRGVmYXVsdD17dHJ1ZX1cbiAgICAgICAgICAgIHdpZHRoPXs0MH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZHMpID0+XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhc291cmNlVWlkOiBkcy51aWQsXG4gICAgICAgICAgICAgICAgdXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9JbmxpbmVGaWVsZD5cbiAgICAgICkgOiAoXG4gICAgICAgIDxJbmxpbmVGaWVsZFxuICAgICAgICAgIGxhYmVsPVwiVVJMXCJcbiAgICAgICAgICBsYWJlbFdpZHRoPXsyNH1cbiAgICAgICAgICB0b29sdGlwPVwiVGhlIFVSTCBvZiB0aGUgdHJhY2UgYmFja2VuZCB0aGUgdXNlciB3b3VsZCBnbyB0byBzZWUgaXRzIHRyYWNlLlwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiaHR0cHM6Ly9leGFtcGxlLmNvbS8ke19fdmFsdWUucmF3fVwiXG4gICAgICAgICAgICBzcGVsbENoZWNrPXtmYWxzZX1cbiAgICAgICAgICAgIHdpZHRoPXs0MH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZS51cmx9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PlxuICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YXNvdXJjZVVpZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVybDogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgKX1cblxuICAgICAgPElubGluZUZpZWxkXG4gICAgICAgIGxhYmVsPVwiVVJMIExhYmVsXCJcbiAgICAgICAgbGFiZWxXaWR0aD17MjR9XG4gICAgICAgIHRvb2x0aXA9XCJVc2UgdG8gb3ZlcnJpZGUgdGhlIGJ1dHRvbiBsYWJlbCBvbiB0aGUgZXhlbXBsYXIgdHJhY2VJRCBmaWVsZC5cIlxuICAgICAgPlxuICAgICAgICA8SW5wdXRcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkdvIHRvIGV4YW1wbGUuY29tXCJcbiAgICAgICAgICBzcGVsbENoZWNrPXtmYWxzZX1cbiAgICAgICAgICB3aWR0aD17NDB9XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlLnVybERpc3BsYXlMYWJlbH1cbiAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PlxuICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgdXJsRGlzcGxheUxhYmVsOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIC8+XG4gICAgICA8L0lubGluZUZpZWxkPlxuICAgICAgPElubGluZUZpZWxkXG4gICAgICAgIGxhYmVsPVwiTGFiZWwgbmFtZVwiXG4gICAgICAgIGxhYmVsV2lkdGg9ezI0fVxuICAgICAgICB0b29sdGlwPVwiVGhlIG5hbWUgb2YgdGhlIGZpZWxkIGluIHRoZSBsYWJlbHMgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IHRoZSB0cmFjZUlELlwiXG4gICAgICA+XG4gICAgICAgIDxJbnB1dFxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwidHJhY2VJRFwiXG4gICAgICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XG4gICAgICAgICAgd2lkdGg9ezQwfVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZS5uYW1lfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+XG4gICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICBuYW1lOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIC8+XG4gICAgICA8L0lubGluZUZpZWxkPlxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IHNlbGVjdG9ycyB9IGZyb20gJ0BncmFmYW5hL2UyZS1zZWxlY3RvcnMnO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IEV4ZW1wbGFyU2V0dGluZyBmcm9tICcuL0V4ZW1wbGFyU2V0dGluZyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIG9wdGlvbnM/OiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdO1xuICBvbkNoYW5nZTogKHZhbHVlOiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIEV4ZW1wbGFyc1NldHRpbmdzKHsgb3B0aW9ucywgb25DaGFuZ2UgfTogUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGgzIGNsYXNzTmFtZT1cInBhZ2UtaGVhZGluZ1wiPkV4ZW1wbGFyczwvaDM+XG5cbiAgICAgIHtvcHRpb25zICYmXG4gICAgICAgIG9wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxFeGVtcGxhclNldHRpbmdcbiAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbn1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhuZXdGaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBbLi4ub3B0aW9uc107XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9ucy5zcGxpY2UoaW5kZXgsIDEsIG5ld0ZpZWxkKTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgb25EZWxldGU9eygpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdPcHRpb25zID0gWy4uLm9wdGlvbnNdO1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG5cbiAgICAgIDxCdXR0b25cbiAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3NlbGVjdG9ycy5jb21wb25lbnRzLkRhdGFTb3VyY2UuUHJvbWV0aGV1cy5jb25maWdQYWdlLmV4ZW1wbGFyc0FkZEJ1dHRvbn1cbiAgICAgICAgY2xhc3NOYW1lPXtjc3NgXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDtcbiAgICAgICAgYH1cbiAgICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgICBvbkNsaWNrPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBbLi4uKG9wdGlvbnMgfHwgW10pLCB7IG5hbWU6ICd0cmFjZUlEJyB9XTtcbiAgICAgICAgICBvbkNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgQWRkXG4gICAgICA8L0J1dHRvbj5cbiAgICA8Lz5cbiAgKTtcbn1cbiIsImltcG9ydCB7XG4gIERhdGFTb3VyY2VQbHVnaW5PcHRpb25zRWRpdG9yUHJvcHMsXG4gIG9uVXBkYXRlRGF0YXNvdXJjZUpzb25EYXRhT3B0aW9uQ2hlY2tlZCxcbiAgU2VsZWN0YWJsZVZhbHVlLFxuICB1cGRhdGVEYXRhc291cmNlUGx1Z2luSnNvbkRhdGFPcHRpb24sXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRXZlbnRzV2l0aFZhbGlkYXRpb24sIElubGluZUZvcm1MYWJlbCwgTGVnYWN5Rm9ybXMsIHJlZ2V4VmFsaWRhdGlvbiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyBTeW50aGV0aWNFdmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByb21PcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRXhlbXBsYXJzU2V0dGluZ3MgfSBmcm9tICcuL0V4ZW1wbGFyc1NldHRpbmdzJztcbmNvbnN0IHsgU2VsZWN0LCBJbnB1dCwgRm9ybUZpZWxkLCBTd2l0Y2ggfSA9IExlZ2FjeUZvcm1zO1xuXG5jb25zdCBodHRwT3B0aW9ucyA9IFtcbiAgeyB2YWx1ZTogJ1BPU1QnLCBsYWJlbDogJ1BPU1QnIH0sXG4gIHsgdmFsdWU6ICdHRVQnLCBsYWJlbDogJ0dFVCcgfSxcbl07XG5cbnR5cGUgUHJvcHMgPSBQaWNrPERhdGFTb3VyY2VQbHVnaW5PcHRpb25zRWRpdG9yUHJvcHM8UHJvbU9wdGlvbnM+LCAnb3B0aW9ucycgfCAnb25PcHRpb25zQ2hhbmdlJz47XG5cbmV4cG9ydCBjb25zdCBQcm9tU2V0dGluZ3MgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9ucywgb25PcHRpb25zQ2hhbmdlIH0gPSBwcm9wcztcblxuICAvLyBXZSBhcmUgZXhwbGljaXRseSBhZGRpbmcgaHR0cE1ldGhvZCBzbyBpdCBpcyBjb3JyZWN0bHkgZGlzcGxheWVkIGluIGRyb3Bkb3duLiBUaGlzIHdheSwgaXQgaXMgbW9yZSBwcmVkaWN0YWJsZSBmb3IgdXNlcnMuXG5cbiAgaWYgKCFvcHRpb25zLmpzb25EYXRhLmh0dHBNZXRob2QpIHtcbiAgICBvcHRpb25zLmpzb25EYXRhLmh0dHBNZXRob2QgPSAnUE9TVCc7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0tZ3JvdXBcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtLWlubGluZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgICAgPEZvcm1GaWVsZFxuICAgICAgICAgICAgICBsYWJlbD1cIlNjcmFwZSBpbnRlcnZhbFwiXG4gICAgICAgICAgICAgIGxhYmVsV2lkdGg9ezEzfVxuICAgICAgICAgICAgICBpbnB1dEVsPXtcbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTZcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbnMuanNvbkRhdGEudGltZUludGVydmFsfVxuICAgICAgICAgICAgICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIjE1c1wiXG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VIYW5kbGVyKCd0aW1lSW50ZXJ2YWwnLCBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UpfVxuICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbkV2ZW50cz17cHJvbVNldHRpbmdzVmFsaWRhdGlvbkV2ZW50c31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvb2x0aXA9XCJTZXQgdGhpcyB0byB0aGUgdHlwaWNhbCBzY3JhcGUgYW5kIGV2YWx1YXRpb24gaW50ZXJ2YWwgY29uZmlndXJlZCBpbiBQcm9tZXRoZXVzLiBEZWZhdWx0cyB0byAxNXMuXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtXCI+XG4gICAgICAgICAgICA8Rm9ybUZpZWxkXG4gICAgICAgICAgICAgIGxhYmVsPVwiUXVlcnkgdGltZW91dFwiXG4gICAgICAgICAgICAgIGxhYmVsV2lkdGg9ezEzfVxuICAgICAgICAgICAgICBpbnB1dEVsPXtcbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndpZHRoLTZcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbnMuanNvbkRhdGEucXVlcnlUaW1lb3V0fVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlSGFuZGxlcigncXVlcnlUaW1lb3V0Jywgb3B0aW9ucywgb25PcHRpb25zQ2hhbmdlKX1cbiAgICAgICAgICAgICAgICAgIHNwZWxsQ2hlY2s9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCI2MHNcIlxuICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbkV2ZW50cz17cHJvbVNldHRpbmdzVmFsaWRhdGlvbkV2ZW50c31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvb2x0aXA9XCJTZXQgdGhlIFByb21ldGhldXMgcXVlcnkgdGltZW91dC5cIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybVwiPlxuICAgICAgICAgIDxJbmxpbmVGb3JtTGFiZWxcbiAgICAgICAgICAgIHdpZHRoPXsxM31cbiAgICAgICAgICAgIHRvb2x0aXA9XCJZb3UgY2FuIHVzZSBlaXRoZXIgUE9TVCBvciBHRVQgSFRUUCBtZXRob2QgdG8gcXVlcnkgeW91ciBQcm9tZXRoZXVzIGRhdGEgc291cmNlLiBQT1NUIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2QgYXMgaXQgYWxsb3dzIGJpZ2dlciBxdWVyaWVzLiBDaGFuZ2UgdGhpcyB0byBHRVQgaWYgeW91IGhhdmUgYSBQcm9tZXRoZXVzIHZlcnNpb24gb2xkZXIgdGhhbiAyLjEgb3IgaWYgUE9TVCByZXF1ZXN0cyBhcmUgcmVzdHJpY3RlZCBpbiB5b3VyIG5ldHdvcmsuXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICBIVFRQIE1ldGhvZFxuICAgICAgICAgIDwvSW5saW5lRm9ybUxhYmVsPlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZWxlY3QgSFRUUCBtZXRob2RcIlxuICAgICAgICAgICAgbWVudVNob3VsZFBvcnRhbFxuICAgICAgICAgICAgb3B0aW9ucz17aHR0cE9wdGlvbnN9XG4gICAgICAgICAgICB2YWx1ZT17aHR0cE9wdGlvbnMuZmluZCgobykgPT4gby52YWx1ZSA9PT0gb3B0aW9ucy5qc29uRGF0YS5odHRwTWV0aG9kKX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZUhhbmRsZXIoJ2h0dHBNZXRob2QnLCBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UpfVxuICAgICAgICAgICAgd2lkdGg9ezd9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxoMyBjbGFzc05hbWU9XCJwYWdlLWhlYWRpbmdcIj5NaXNjPC9oMz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2YtZm9ybS1ncm91cFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm1cIj5cbiAgICAgICAgICA8U3dpdGNoXG4gICAgICAgICAgICBjaGVja2VkPXtvcHRpb25zLmpzb25EYXRhLmRpc2FibGVNZXRyaWNzTG9va3VwID8/IGZhbHNlfVxuICAgICAgICAgICAgbGFiZWw9XCJEaXNhYmxlIG1ldHJpY3MgbG9va3VwXCJcbiAgICAgICAgICAgIGxhYmVsQ2xhc3M9XCJ3aWR0aC0xNFwiXG4gICAgICAgICAgICBvbkNoYW5nZT17b25VcGRhdGVEYXRhc291cmNlSnNvbkRhdGFPcHRpb25DaGVja2VkKHByb3BzLCAnZGlzYWJsZU1ldHJpY3NMb29rdXAnKX1cbiAgICAgICAgICAgIHRvb2x0aXA9XCJDaGVja2luZyB0aGlzIG9wdGlvbiB3aWxsIGRpc2FibGUgdGhlIG1ldHJpY3MgY2hvb3NlciBhbmQgbWV0cmljL2xhYmVsIHN1cHBvcnQgaW4gdGhlIHF1ZXJ5IGZpZWxkJ3MgYXV0b2NvbXBsZXRlLiBUaGlzIGhlbHBzIGlmIHlvdSBoYXZlIHBlcmZvcm1hbmNlIGlzc3VlcyB3aXRoIGJpZ2dlciBQcm9tZXRoZXVzIGluc3RhbmNlcy5cIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdmLWZvcm0taW5saW5lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnZi1mb3JtIG1heC13aWR0aC0zMFwiPlxuICAgICAgICAgICAgPEZvcm1GaWVsZFxuICAgICAgICAgICAgICBsYWJlbD1cIkN1c3RvbSBxdWVyeSBwYXJhbWV0ZXJzXCJcbiAgICAgICAgICAgICAgbGFiZWxXaWR0aD17MTR9XG4gICAgICAgICAgICAgIHRvb2x0aXA9XCJBZGQgQ3VzdG9tIHBhcmFtZXRlcnMgdG8gYWxsIFByb21ldGhldXMgb3IgVGhhbm9zIHF1ZXJpZXMuXCJcbiAgICAgICAgICAgICAgaW5wdXRFbD17XG4gICAgICAgICAgICAgICAgPElucHV0XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aWR0aC0yNVwiXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17b3B0aW9ucy5qc29uRGF0YS5jdXN0b21RdWVyeVBhcmFtZXRlcnN9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VIYW5kbGVyKCdjdXN0b21RdWVyeVBhcmFtZXRlcnMnLCBvcHRpb25zLCBvbk9wdGlvbnNDaGFuZ2UpfVxuICAgICAgICAgICAgICAgICAgc3BlbGxDaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkV4YW1wbGU6IG1heF9zb3VyY2VfcmVzb2x1dGlvbj01bSZ0aW1lb3V0PTEwXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPEV4ZW1wbGFyc1NldHRpbmdzXG4gICAgICAgIG9wdGlvbnM9e29wdGlvbnMuanNvbkRhdGEuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zfVxuICAgICAgICBvbkNoYW5nZT17KGV4ZW1wbGFyT3B0aW9ucykgPT5cbiAgICAgICAgICB1cGRhdGVEYXRhc291cmNlUGx1Z2luSnNvbkRhdGFPcHRpb24oXG4gICAgICAgICAgICB7IG9uT3B0aW9uc0NoYW5nZSwgb3B0aW9ucyB9LFxuICAgICAgICAgICAgJ2V4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucycsXG4gICAgICAgICAgICBleGVtcGxhck9wdGlvbnNcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIC8+XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgcHJvbVNldHRpbmdzVmFsaWRhdGlvbkV2ZW50cyA9IHtcbiAgW0V2ZW50c1dpdGhWYWxpZGF0aW9uLm9uQmx1cl06IFtcbiAgICByZWdleFZhbGlkYXRpb24oXG4gICAgICAvXiR8XlxcZCsobXN8W013ZGhtc3ldKSQvLFxuICAgICAgJ1ZhbHVlIGlzIG5vdCB2YWxpZCwgeW91IGNhbiB1c2UgbnVtYmVyIHdpdGggdGltZSB1bml0IHNwZWNpZmllcjogeSwgTSwgdywgZCwgaCwgbSwgcydcbiAgICApLFxuICBdLFxufTtcblxuZXhwb3J0IGNvbnN0IGdldFZhbHVlRnJvbUV2ZW50SXRlbSA9IChldmVudEl0ZW06IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+IHwgU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4pID0+IHtcbiAgaWYgKCFldmVudEl0ZW0pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoZXZlbnRJdGVtLmhhc093blByb3BlcnR5KCdjdXJyZW50VGFyZ2V0JykpIHtcbiAgICByZXR1cm4gZXZlbnRJdGVtLmN1cnJlbnRUYXJnZXQudmFsdWU7XG4gIH1cblxuICByZXR1cm4gKGV2ZW50SXRlbSBhcyBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPikudmFsdWU7XG59O1xuXG5jb25zdCBvbkNoYW5nZUhhbmRsZXIgPVxuICAoa2V5OiBrZXlvZiBQcm9tT3B0aW9ucywgb3B0aW9uczogUHJvcHNbJ29wdGlvbnMnXSwgb25PcHRpb25zQ2hhbmdlOiBQcm9wc1snb25PcHRpb25zQ2hhbmdlJ10pID0+XG4gIChldmVudEl0ZW06IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+IHwgU2VsZWN0YWJsZVZhbHVlPHN0cmluZz4pID0+IHtcbiAgICBvbk9wdGlvbnNDaGFuZ2Uoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGpzb25EYXRhOiB7XG4gICAgICAgIC4uLm9wdGlvbnMuanNvbkRhdGEsXG4gICAgICAgIFtrZXldOiBnZXRWYWx1ZUZyb21FdmVudEl0ZW0oZXZlbnRJdGVtKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY2xvbmVEZWVwLCBkZWZhdWx0cyB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBmb3JrSm9pbiwgbGFzdFZhbHVlRnJvbSwgbWVyZ2UsIE9ic2VydmFibGUsIG9mLCBPcGVyYXRvckZ1bmN0aW9uLCBwaXBlLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBmaWx0ZXIsIG1hcCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IHtcbiAgQW5ub3RhdGlvbkV2ZW50LFxuICBDb3JlQXBwLFxuICBEYXRhUXVlcnlFcnJvcixcbiAgRGF0YVF1ZXJ5UmVxdWVzdCxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIERhdGFTb3VyY2VJbnN0YW5jZVNldHRpbmdzLFxuICBEYXRhU291cmNlV2l0aFF1ZXJ5RXhwb3J0U3VwcG9ydCxcbiAgRGF0YVNvdXJjZVdpdGhRdWVyeUltcG9ydFN1cHBvcnQsXG4gIGRhdGVNYXRoLFxuICBEYXRlVGltZSxcbiAgQWJzdHJhY3RRdWVyeSxcbiAgTG9hZGluZ1N0YXRlLFxuICByYW5nZVV0aWwsXG4gIFNjb3BlZFZhcnMsXG4gIFRpbWVSYW5nZSxcbiAgRGF0YUZyYW1lLFxuICBkYXRlVGltZSxcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQge1xuICBCYWNrZW5kU3J2UmVxdWVzdCxcbiAgRmV0Y2hFcnJvcixcbiAgRmV0Y2hSZXNwb25zZSxcbiAgZ2V0QmFja2VuZFNydixcbiAgRGF0YVNvdXJjZVdpdGhCYWNrZW5kLFxuICBCYWNrZW5kRGF0YVNvdXJjZVJlc3BvbnNlLFxuICB0b0RhdGFRdWVyeVJlc3BvbnNlLFxufSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IHsgc2FmZVN0cmluZ2lmeVZhbHVlIH0gZnJvbSAnYXBwL2NvcmUvdXRpbHMvZXhwbG9yZSc7XG5pbXBvcnQgeyBnZXRUaW1lU3J2LCBUaW1lU3J2IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9zZXJ2aWNlcy9UaW1lU3J2JztcbmltcG9ydCB7IGdldFRlbXBsYXRlU3J2LCBUZW1wbGF0ZVNydiB9IGZyb20gJ2FwcC9mZWF0dXJlcy90ZW1wbGF0aW5nL3RlbXBsYXRlX3Nydic7XG5pbXBvcnQgeyBhZGRMYWJlbFRvUXVlcnkgfSBmcm9tICcuL2FkZF9sYWJlbF90b19xdWVyeSc7XG5pbXBvcnQgUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXIgZnJvbSAnLi9sYW5ndWFnZV9wcm92aWRlcic7XG5pbXBvcnQgeyBleHBhbmRSZWNvcmRpbmdSdWxlcyB9IGZyb20gJy4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IHsgZ2V0SW5pdEhpbnRzLCBnZXRRdWVyeUhpbnRzIH0gZnJvbSAnLi9xdWVyeV9oaW50cyc7XG5pbXBvcnQgeyBnZXRPcmlnaW5hbE1ldHJpY05hbWUsIHRyYW5zZm9ybSwgdHJhbnNmb3JtVjIgfSBmcm9tICcuL3Jlc3VsdF90cmFuc2Zvcm1lcic7XG5pbXBvcnQge1xuICBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbixcbiAgUHJvbURhdGFFcnJvclJlc3BvbnNlLFxuICBQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZSxcbiAgUHJvbUV4ZW1wbGFyRGF0YSxcbiAgUHJvbU1hdHJpeERhdGEsXG4gIFByb21PcHRpb25zLFxuICBQcm9tUXVlcnksXG4gIFByb21RdWVyeVJlcXVlc3QsXG4gIFByb21RdWVyeVR5cGUsXG4gIFByb21TY2FsYXJEYXRhLFxuICBQcm9tVmVjdG9yRGF0YSxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBQcm9tZXRoZXVzVmFyaWFibGVTdXBwb3J0IH0gZnJvbSAnLi92YXJpYWJsZXMnO1xuaW1wb3J0IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkgZnJvbSAnLi9tZXRyaWNfZmluZF9xdWVyeSc7XG5pbXBvcnQgeyByZW5kZXJMZWdlbmRGb3JtYXQgfSBmcm9tICcuL2xlZ2VuZCc7XG5pbXBvcnQgeyBmZXRjaERhdGFTb3VyY2VCdWlsZEluZm8gfSBmcm9tICdhcHAvZmVhdHVyZXMvYWxlcnRpbmcvdW5pZmllZC9hcGkvYnVpbGRJbmZvJztcbmltcG9ydCB7IFByb21BcHBsaWNhdGlvbiwgUHJvbUJ1aWxkSW5mbyB9IGZyb20gJ2FwcC90eXBlcy91bmlmaWVkLWFsZXJ0aW5nLWR0byc7XG5pbXBvcnQgeyBCYWRnZSwgQmFkZ2VDb2xvciwgVG9vbHRpcCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuZXhwb3J0IGNvbnN0IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxUID0gJzYwcyc7XG5jb25zdCBHRVRfQU5EX1BPU1RfTUVUQURBVEFfRU5EUE9JTlRTID0gWydhcGkvdjEvcXVlcnknLCAnYXBpL3YxL3F1ZXJ5X3JhbmdlJywgJ2FwaS92MS9zZXJpZXMnLCAnYXBpL3YxL2xhYmVscyddO1xuXG5leHBvcnQgY2xhc3MgUHJvbWV0aGV1c0RhdGFzb3VyY2VcbiAgZXh0ZW5kcyBEYXRhU291cmNlV2l0aEJhY2tlbmQ8UHJvbVF1ZXJ5LCBQcm9tT3B0aW9ucz5cbiAgaW1wbGVtZW50cyBEYXRhU291cmNlV2l0aFF1ZXJ5SW1wb3J0U3VwcG9ydDxQcm9tUXVlcnk+LCBEYXRhU291cmNlV2l0aFF1ZXJ5RXhwb3J0U3VwcG9ydDxQcm9tUXVlcnk+XG57XG4gIHR5cGU6IHN0cmluZztcbiAgZWRpdG9yU3JjOiBzdHJpbmc7XG4gIHJ1bGVNYXBwaW5nczogeyBbaW5kZXg6IHN0cmluZ106IHN0cmluZyB9O1xuICB1cmw6IHN0cmluZztcbiAgaWQ6IG51bWJlcjtcbiAgZGlyZWN0VXJsOiBzdHJpbmc7XG4gIGFjY2VzczogJ2RpcmVjdCcgfCAncHJveHknO1xuICBiYXNpY0F1dGg6IGFueTtcbiAgd2l0aENyZWRlbnRpYWxzOiBhbnk7XG4gIG1ldHJpY3NOYW1lQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgc3RyaW5nW10+KHsgbWF4OiAxMCB9KTtcbiAgaW50ZXJ2YWw6IHN0cmluZztcbiAgcXVlcnlUaW1lb3V0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGh0dHBNZXRob2Q6IHN0cmluZztcbiAgbGFuZ3VhZ2VQcm92aWRlcjogUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXI7XG4gIGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25bXSB8IHVuZGVmaW5lZDtcbiAgbG9va3Vwc0Rpc2FibGVkOiBib29sZWFuO1xuICBjdXN0b21RdWVyeVBhcmFtZXRlcnM6IGFueTtcbiAgZXhlbXBsYXJzQXZhaWxhYmxlOiBib29sZWFuO1xuICBzdWJUeXBlOiBQcm9tQXBwbGljYXRpb247XG4gIHJ1bGVyRW5hYmxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBpbnN0YW5jZVNldHRpbmdzOiBEYXRhU291cmNlSW5zdGFuY2VTZXR0aW5nczxQcm9tT3B0aW9ucz4sXG4gICAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVNydjogVGVtcGxhdGVTcnYgPSBnZXRUZW1wbGF0ZVNydigpLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGltZVNydjogVGltZVNydiA9IGdldFRpbWVTcnYoKSxcbiAgICBsYW5ndWFnZVByb3ZpZGVyPzogUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXJcbiAgKSB7XG4gICAgc3VwZXIoaW5zdGFuY2VTZXR0aW5ncyk7XG5cbiAgICB0aGlzLnR5cGUgPSAncHJvbWV0aGV1cyc7XG4gICAgdGhpcy5zdWJUeXBlID0gUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXM7XG4gICAgdGhpcy5ydWxlckVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVkaXRvclNyYyA9ICdhcHAvZmVhdHVyZXMvcHJvbWV0aGV1cy9wYXJ0aWFscy9xdWVyeS5lZGl0b3IuaHRtbCc7XG4gICAgdGhpcy5pZCA9IGluc3RhbmNlU2V0dGluZ3MuaWQ7XG4gICAgdGhpcy51cmwgPSBpbnN0YW5jZVNldHRpbmdzLnVybCE7XG4gICAgdGhpcy5hY2Nlc3MgPSBpbnN0YW5jZVNldHRpbmdzLmFjY2VzcztcbiAgICB0aGlzLmJhc2ljQXV0aCA9IGluc3RhbmNlU2V0dGluZ3MuYmFzaWNBdXRoO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gaW5zdGFuY2VTZXR0aW5ncy53aXRoQ3JlZGVudGlhbHM7XG4gICAgdGhpcy5pbnRlcnZhbCA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEudGltZUludGVydmFsIHx8ICcxNXMnO1xuICAgIHRoaXMucXVlcnlUaW1lb3V0ID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5xdWVyeVRpbWVvdXQ7XG4gICAgdGhpcy5odHRwTWV0aG9kID0gaW5zdGFuY2VTZXR0aW5ncy5qc29uRGF0YS5odHRwTWV0aG9kIHx8ICdQT1NUJztcbiAgICAvLyBgZGlyZWN0VXJsYCBpcyBuZXZlciB1bmRlZmluZWQsIHdlIHNldCBpdCBhdCBodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hL2Jsb2IvbWFpbi9wa2cvYXBpL2Zyb250ZW5kc2V0dGluZ3MuZ28jTDEwOFxuICAgIC8vIGhlcmUgd2UgXCJmYWxsIGJhY2tcIiB0byB0aGlzLnVybCB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHksIGJ1dCBpdCBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgdGhpcy5kaXJlY3RVcmwgPSBpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLmRpcmVjdFVybCA/PyB0aGlzLnVybDtcbiAgICB0aGlzLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucyA9IGluc3RhbmNlU2V0dGluZ3MuanNvbkRhdGEuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zO1xuICAgIHRoaXMucnVsZU1hcHBpbmdzID0ge307XG4gICAgdGhpcy5sYW5ndWFnZVByb3ZpZGVyID0gbGFuZ3VhZ2VQcm92aWRlciA/PyBuZXcgUHJvbWV0aGV1c0xhbmd1YWdlUHJvdmlkZXIodGhpcyk7XG4gICAgdGhpcy5sb29rdXBzRGlzYWJsZWQgPSBpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLmRpc2FibGVNZXRyaWNzTG9va3VwID8/IGZhbHNlO1xuICAgIHRoaXMuY3VzdG9tUXVlcnlQYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhpbnN0YW5jZVNldHRpbmdzLmpzb25EYXRhLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycyk7XG4gICAgdGhpcy52YXJpYWJsZXMgPSBuZXcgUHJvbWV0aGV1c1ZhcmlhYmxlU3VwcG9ydCh0aGlzLCB0aGlzLnRlbXBsYXRlU3J2LCB0aGlzLnRpbWVTcnYpO1xuICAgIHRoaXMuZXhlbXBsYXJzQXZhaWxhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIGluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5sb2FkUnVsZXMoKTtcbiAgICB0aGlzLmV4ZW1wbGFyc0F2YWlsYWJsZSA9IGF3YWl0IHRoaXMuYXJlRXhlbXBsYXJzQXZhaWxhYmxlKCk7XG4gIH07XG5cbiAgZ2V0UXVlcnlEaXNwbGF5VGV4dChxdWVyeTogUHJvbVF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5LmV4cHI7XG4gIH1cblxuICBfYWRkVHJhY2luZ0hlYWRlcnMoaHR0cE9wdGlvbnM6IFByb21RdWVyeVJlcXVlc3QsIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pikge1xuICAgIGh0dHBPcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgICBjb25zdCBwcm94eU1vZGUgPSAhdGhpcy51cmwubWF0Y2goL15odHRwLyk7XG4gICAgaWYgKHByb3h5TW9kZSkge1xuICAgICAgaHR0cE9wdGlvbnMuaGVhZGVyc1snWC1EYXNoYm9hcmQtSWQnXSA9IG9wdGlvbnMuZGFzaGJvYXJkSWQ7XG4gICAgICBodHRwT3B0aW9ucy5oZWFkZXJzWydYLVBhbmVsLUlkJ10gPSBvcHRpb25zLnBhbmVsSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFueSByZXF1ZXN0IGRvbmUgZnJvbSB0aGlzIGRhdGEgc291cmNlIHNob3VsZCBnbyB0aHJvdWdoIGhlcmUgYXMgaXQgY29udGFpbnMgc29tZSBjb21tb24gcHJvY2Vzc2luZyBmb3IgdGhlXG4gICAqIHJlcXVlc3QuIEFueSBwcm9jZXNzaW5nIGRvbmUgaGVyZSBuZWVkcyB0byBiZSBhbHNvIGNvcGllZCBvbiB0aGUgYmFja2VuZCBhcyB0aGlzIGdvZXMgdGhyb3VnaCBkYXRhIHNvdXJjZSBwcm94eVxuICAgKiBidXQgbm90IHRocm91Z2ggdGhlIHNhbWUgY29kZSBhcyBhbGVydGluZy5cbiAgICovXG4gIF9yZXF1ZXN0PFQgPSBhbnk+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIGRhdGE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBudWxsLFxuICAgIG92ZXJyaWRlczogUGFydGlhbDxCYWNrZW5kU3J2UmVxdWVzdD4gPSB7fVxuICApOiBPYnNlcnZhYmxlPEZldGNoUmVzcG9uc2U8VD4+IHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmN1c3RvbVF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgaWYgKGRhdGFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnM6IEJhY2tlbmRTcnZSZXF1ZXN0ID0gZGVmYXVsdHMob3ZlcnJpZGVzLCB7XG4gICAgICB1cmw6IHRoaXMudXJsICsgdXJsLFxuICAgICAgbWV0aG9kOiB0aGlzLmh0dHBNZXRob2QsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25zLnVybCA9XG4gICAgICAgICAgb3B0aW9ucy51cmwgK1xuICAgICAgICAgIChvcHRpb25zLnVybC5zZWFyY2goL1xcPy8pID49IDAgPyAnJicgOiAnPycpICtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhKVxuICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoayl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHYpfWApXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMhWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgb3B0aW9ucy5kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYXNpY0F1dGggfHwgdGhpcy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYXNpY0F1dGgpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyEuQXV0aG9yaXphdGlvbiA9IHRoaXMuYmFzaWNBdXRoO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRCYWNrZW5kU3J2KCkuZmV0Y2g8VD4ob3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBpbXBvcnRGcm9tQWJzdHJhY3RRdWVyaWVzKGFic3RyYWN0UXVlcmllczogQWJzdHJhY3RRdWVyeVtdKTogUHJvbWlzZTxQcm9tUXVlcnlbXT4ge1xuICAgIHJldHVybiBhYnN0cmFjdFF1ZXJpZXMubWFwKChhYnN0cmFjdFF1ZXJ5KSA9PiB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaW1wb3J0RnJvbUFic3RyYWN0UXVlcnkoYWJzdHJhY3RRdWVyeSkpO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0VG9BYnN0cmFjdFF1ZXJpZXMocXVlcmllczogUHJvbVF1ZXJ5W10pOiBQcm9taXNlPEFic3RyYWN0UXVlcnlbXT4ge1xuICAgIHJldHVybiBxdWVyaWVzLm1hcCgocXVlcnkpID0+IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5leHBvcnRUb0Fic3RyYWN0UXVlcnkocXVlcnkpKTtcbiAgfVxuXG4gIC8vIFVzZSB0aGlzIGZvciB0YWIgY29tcGxldGlvbiBmZWF0dXJlcywgd29udCBwdWJsaXNoIHJlc3BvbnNlIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgYXN5bmMgbWV0YWRhdGFSZXF1ZXN0PFQgPSBhbnk+KHVybDogc3RyaW5nLCBwYXJhbXMgPSB7fSkge1xuICAgIC8vIElmIFVSTCBpbmNsdWRlcyBlbmRwb2ludCB0aGF0IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBtZXRob2QsIHRyeSB0byB1c2UgY29uZmlndXJlZCBtZXRob2QuIFRoaXMgbWlnaHQgZmFpbCBhcyBQT1NUIGlzIHN1cHBvcnRlZCBvbmx5IGluIHYyLjEwKy5cbiAgICBpZiAoR0VUX0FORF9QT1NUX01FVEFEQVRBX0VORFBPSU5UUy5zb21lKChlbmRwb2ludCkgPT4gdXJsLmluY2x1ZGVzKGVuZHBvaW50KSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBsYXN0VmFsdWVGcm9tKHRoaXMuX3JlcXVlc3Q8VD4odXJsLCBwYXJhbXMsIHsgbWV0aG9kOiB0aGlzLmh0dHBNZXRob2QsIGhpZGVGcm9tSW5zcGVjdG9yOiB0cnVlIH0pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiBzdGF0dXMgY29kZSBvZiBlcnJvciBpcyBNZXRob2QgTm90IEFsbG93ZWQgKDQwNSkgYW5kIEhUVFAgbWV0aG9kIGlzIFBPU1QsIHJldHJ5IHdpdGggR0VUXG4gICAgICAgIGlmICh0aGlzLmh0dHBNZXRob2QgPT09ICdQT1NUJyAmJiBlcnIuc3RhdHVzID09PSA0MDUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkbid0IHVzZSBjb25maWd1cmVkIFBPU1QgSFRUUCBtZXRob2QgZm9yIHRoaXMgcmVxdWVzdC4gVHJ5aW5nIHRvIHVzZSBHRVQgbWV0aG9kIGluc3RlYWQuYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IGxhc3RWYWx1ZUZyb20odGhpcy5fcmVxdWVzdDxUPih1cmwsIHBhcmFtcywgeyBtZXRob2Q6ICdHRVQnLCBoaWRlRnJvbUluc3BlY3RvcjogdHJ1ZSB9KSk7IC8vIHRvUHJvbWlzZSB1bnRpbCB3ZSBjaGFuZ2UgZ2V0VGFnVmFsdWVzLCBnZXRUYWdLZXlzIHRvIE9ic2VydmFibGVcbiAgfVxuXG4gIGludGVycG9sYXRlUXVlcnlFeHByKHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSA9IFtdLCB2YXJpYWJsZTogYW55KSB7XG4gICAgLy8gaWYgbm8gbXVsdGkgb3IgaW5jbHVkZSBhbGwgZG8gbm90IHJlZ2V4RXNjYXBlXG4gICAgaWYgKCF2YXJpYWJsZS5tdWx0aSAmJiAhdmFyaWFibGUuaW5jbHVkZUFsbCkge1xuICAgICAgcmV0dXJuIHByb21ldGhldXNSZWd1bGFyRXNjYXBlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUodmFsdWUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVzY2FwZWRWYWx1ZXMgPSB2YWx1ZS5tYXAoKHZhbCkgPT4gcHJvbWV0aGV1c1NwZWNpYWxSZWdleEVzY2FwZSh2YWwpKTtcblxuICAgIGlmIChlc2NhcGVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGVzY2FwZWRWYWx1ZXNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuICcoJyArIGVzY2FwZWRWYWx1ZXMuam9pbignfCcpICsgJyknO1xuICB9XG5cbiAgdGFyZ2V0Q29udGFpbnNUZW1wbGF0ZSh0YXJnZXQ6IFByb21RdWVyeSkge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlU3J2LmNvbnRhaW5zVGVtcGxhdGUodGFyZ2V0LmV4cHIpO1xuICB9XG5cbiAgcHJlcGFyZVRhcmdldHMgPSAob3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHF1ZXJpZXM6IFByb21RdWVyeVJlcXVlc3RbXSA9IFtdO1xuICAgIGNvbnN0IGFjdGl2ZVRhcmdldHM6IFByb21RdWVyeVtdID0gW107XG4gICAgY29uc3QgY2xvbmVkVGFyZ2V0cyA9IGNsb25lRGVlcChvcHRpb25zLnRhcmdldHMpO1xuXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgY2xvbmVkVGFyZ2V0cykge1xuICAgICAgaWYgKCF0YXJnZXQuZXhwciB8fCB0YXJnZXQuaGlkZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnJlcXVlc3RJZCA9IG9wdGlvbnMucGFuZWxJZCArIHRhcmdldC5yZWZJZDtcbiAgICAgIGNvbnN0IG1ldHJpY05hbWUgPSB0aGlzLmxhbmd1YWdlUHJvdmlkZXIuaGlzdG9ncmFtTWV0cmljcy5maW5kKChtKSA9PiB0YXJnZXQuZXhwci5pbmNsdWRlcyhtKSk7XG5cbiAgICAgIC8vIEluIEV4cGxvcmUsIHdlIHJ1biBib3RoIChpbnN0YW50IGFuZCByYW5nZSkgcXVlcmllcyBpZiBib3RoIGFyZSB0cnVlIChzZWxlY3RlZCkgb3IgYm90aCBhcmUgdW5kZWZpbmVkIChsZWdhY3kgRXhwbG9yZSBxdWVyaWVzKVxuICAgICAgaWYgKG9wdGlvbnMuYXBwID09PSBDb3JlQXBwLkV4cGxvcmUgJiYgdGFyZ2V0LnJhbmdlID09PSB0YXJnZXQuaW5zdGFudCkge1xuICAgICAgICAvLyBDcmVhdGUgaW5zdGFudCB0YXJnZXRcbiAgICAgICAgY29uc3QgaW5zdGFudFRhcmdldDogYW55ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgIGluc3RhbnRUYXJnZXQuZm9ybWF0ID0gJ3RhYmxlJztcbiAgICAgICAgaW5zdGFudFRhcmdldC5pbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgaW5zdGFudFRhcmdldC5yYW5nZSA9IGZhbHNlO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LnZhbHVlV2l0aFJlZklkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIGluc3RhbnRUYXJnZXQubWF4RGF0YVBvaW50cztcbiAgICAgICAgaW5zdGFudFRhcmdldC5yZXF1ZXN0SWQgKz0gJ19pbnN0YW50JztcblxuICAgICAgICAvLyBDcmVhdGUgcmFuZ2UgdGFyZ2V0XG4gICAgICAgIGNvbnN0IHJhbmdlVGFyZ2V0OiBhbnkgPSBjbG9uZURlZXAodGFyZ2V0KTtcbiAgICAgICAgcmFuZ2VUYXJnZXQuZm9ybWF0ID0gJ3RpbWVfc2VyaWVzJztcbiAgICAgICAgcmFuZ2VUYXJnZXQuaW5zdGFudCA9IGZhbHNlO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LnJhbmdlID0gdHJ1ZTtcblxuICAgICAgICAvLyBDcmVhdGUgZXhlbXBsYXIgcXVlcnlcbiAgICAgICAgaWYgKHRhcmdldC5leGVtcGxhcikge1xuICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIGV4ZW1wbGFyIHRhcmdldCBmb3IgZGlmZmVyZW50IG1ldHJpYyBuYW1lc1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtZXRyaWNOYW1lIHx8XG4gICAgICAgICAgICAobWV0cmljTmFtZSAmJiAhYWN0aXZlVGFyZ2V0cy5zb21lKChhY3RpdmVUYXJnZXQpID0+IGFjdGl2ZVRhcmdldC5leHByLmluY2x1ZGVzKG1ldHJpY05hbWUpKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZW1wbGFyVGFyZ2V0ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgICAgICBleGVtcGxhclRhcmdldC5pbnN0YW50ID0gZmFsc2U7XG4gICAgICAgICAgICBleGVtcGxhclRhcmdldC5yZXF1ZXN0SWQgKz0gJ19leGVtcGxhcic7XG4gICAgICAgICAgICBxdWVyaWVzLnB1c2godGhpcy5jcmVhdGVRdWVyeShleGVtcGxhclRhcmdldCwgb3B0aW9ucywgc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKGV4ZW1wbGFyVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFudFRhcmdldC5leGVtcGxhciA9IGZhbHNlO1xuICAgICAgICAgIHJhbmdlVGFyZ2V0LmV4ZW1wbGFyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYm90aCB0YXJnZXRzIHRvIGFjdGl2ZVRhcmdldHMgYW5kIHF1ZXJpZXMgYXJyYXlzXG4gICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaChpbnN0YW50VGFyZ2V0LCByYW5nZVRhcmdldCk7XG4gICAgICAgIHF1ZXJpZXMucHVzaChcbiAgICAgICAgICB0aGlzLmNyZWF0ZVF1ZXJ5KGluc3RhbnRUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIHRoaXMuY3JlYXRlUXVlcnkocmFuZ2VUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpXG4gICAgICAgICk7XG4gICAgICAgIC8vIElmIHJ1bm5pbmcgb25seSBpbnN0YW50IHF1ZXJ5IGluIEV4cGxvcmUsIGZvcm1hdCBhcyB0YWJsZVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuaW5zdGFudCAmJiBvcHRpb25zLmFwcCA9PT0gQ29yZUFwcC5FeHBsb3JlKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbnRUYXJnZXQ6IGFueSA9IGNsb25lRGVlcCh0YXJnZXQpO1xuICAgICAgICBpbnN0YW50VGFyZ2V0LmZvcm1hdCA9ICd0YWJsZSc7XG4gICAgICAgIHF1ZXJpZXMucHVzaCh0aGlzLmNyZWF0ZVF1ZXJ5KGluc3RhbnRUYXJnZXQsIG9wdGlvbnMsIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKGluc3RhbnRUYXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHF1ZXJ5IGZvciBleGVtcGxhcnMgaW4gZGFzaGJvYXJkIGlmIG9ubHkgaW5zdGFudCBpcyBzZWxlY3RlZFxuICAgICAgICBpZiAodGFyZ2V0LmV4ZW1wbGFyICYmICF0YXJnZXQuaW5zdGFudCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtZXRyaWNOYW1lIHx8XG4gICAgICAgICAgICAobWV0cmljTmFtZSAmJiAhYWN0aXZlVGFyZ2V0cy5zb21lKChhY3RpdmVUYXJnZXQpID0+IGFjdGl2ZVRhcmdldC5leHByLmluY2x1ZGVzKG1ldHJpY05hbWUpKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZW1wbGFyVGFyZ2V0ID0gY2xvbmVEZWVwKHRhcmdldCk7XG4gICAgICAgICAgICBleGVtcGxhclRhcmdldC5yZXF1ZXN0SWQgKz0gJ19leGVtcGxhcic7XG4gICAgICAgICAgICBxdWVyaWVzLnB1c2godGhpcy5jcmVhdGVRdWVyeShleGVtcGxhclRhcmdldCwgb3B0aW9ucywgc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKGV4ZW1wbGFyVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LmV4ZW1wbGFyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcmllcy5wdXNoKHRoaXMuY3JlYXRlUXVlcnkodGFyZ2V0LCBvcHRpb25zLCBzdGFydCwgZW5kKSk7XG4gICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBxdWVyaWVzLFxuICAgICAgYWN0aXZlVGFyZ2V0cyxcbiAgICB9O1xuICB9O1xuXG4gIHNob3VsZFJ1bkV4ZW1wbGFyUXVlcnkodGFyZ2V0OiBQcm9tUXVlcnksIHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IGJvb2xlYW4ge1xuICAgIGlmICh0YXJnZXQuZXhlbXBsYXIpIHtcbiAgICAgIC8vIFdlIGNoZWNrIGFsbCBhbHJlYWR5IHByb2Nlc3NlZCB0YXJnZXRzIGFuZCBvbmx5IGNyZWF0ZSBleGVtcGxhciB0YXJnZXQgZm9yIG5vdCB1c2VkIG1ldHJpYyBuYW1lc1xuICAgICAgY29uc3QgbWV0cmljTmFtZSA9IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5oaXN0b2dyYW1NZXRyaWNzLmZpbmQoKG0pID0+IHRhcmdldC5leHByLmluY2x1ZGVzKG0pKTtcbiAgICAgIC8vIFJlbW92ZSB0YXJnZXRzIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQgeWV0IChpbiB0YXJnZXRzIGFycmF5IHRoZXkgYXJlIGFmdGVyIGN1cnJlbnQgdGFyZ2V0KVxuICAgICAgY29uc3QgY3VycmVudFRhcmdldElkeCA9IHJlcXVlc3QudGFyZ2V0cy5maW5kSW5kZXgoKHQpID0+IHQucmVmSWQgPT09IHRhcmdldC5yZWZJZCk7XG4gICAgICBjb25zdCB0YXJnZXRzID0gcmVxdWVzdC50YXJnZXRzLnNsaWNlKDAsIGN1cnJlbnRUYXJnZXRJZHgpO1xuXG4gICAgICBpZiAoIW1ldHJpY05hbWUgfHwgKG1ldHJpY05hbWUgJiYgIXRhcmdldHMuc29tZSgodCkgPT4gdC5leHByLmluY2x1ZGVzKG1ldHJpY05hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByb2Nlc3NUYXJnZXRWMih0YXJnZXQ6IFByb21RdWVyeSwgcmVxdWVzdDogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+KSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkVGFyZ2V0ID0ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgcXVlcnlUeXBlOiBQcm9tUXVlcnlUeXBlLnRpbWVTZXJpZXNRdWVyeSxcbiAgICAgIGV4ZW1wbGFyOiB0aGlzLnNob3VsZFJ1bkV4ZW1wbGFyUXVlcnkodGFyZ2V0LCByZXF1ZXN0KSxcbiAgICAgIHJlcXVlc3RJZDogcmVxdWVzdC5wYW5lbElkICsgdGFyZ2V0LnJlZklkLFxuICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIHV0Y09mZnNldFNlYyB0byBiYWNrZW5kIHRvIGNhbGN1bGF0ZSBhbGlnbmVkIHJhbmdlXG4gICAgICB1dGNPZmZzZXRTZWM6IHRoaXMudGltZVNydi50aW1lUmFuZ2UoKS50by51dGNPZmZzZXQoKSAqIDYwLFxuICAgIH07XG4gICAgcmV0dXJuIHByb2Nlc3NlZFRhcmdldDtcbiAgfVxuXG4gIHF1ZXJ5KHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+IHtcbiAgICBpZiAodGhpcy5hY2Nlc3MgPT09ICdwcm94eScpIHtcbiAgICAgIGNvbnN0IHRhcmdldHMgPSByZXF1ZXN0LnRhcmdldHMubWFwKCh0YXJnZXQpID0+IHRoaXMucHJvY2Vzc1RhcmdldFYyKHRhcmdldCwgcmVxdWVzdCkpO1xuICAgICAgcmV0dXJuIHN1cGVyXG4gICAgICAgIC5xdWVyeSh7IC4uLnJlcXVlc3QsIHRhcmdldHMgfSlcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgICAgIHRyYW5zZm9ybVYyKHJlc3BvbnNlLCByZXF1ZXN0LCB7IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uczogdGhpcy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAvLyBSdW4gcXVlcmllcyB0cm91Z2ggYnJvd3Nlci9wcm94eVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGFydCA9IHRoaXMuZ2V0UHJvbWV0aGV1c1RpbWUocmVxdWVzdC5yYW5nZS5mcm9tLCBmYWxzZSk7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLmdldFByb21ldGhldXNUaW1lKHJlcXVlc3QucmFuZ2UudG8sIHRydWUpO1xuICAgICAgY29uc3QgeyBxdWVyaWVzLCBhY3RpdmVUYXJnZXRzIH0gPSB0aGlzLnByZXBhcmVUYXJnZXRzKHJlcXVlc3QsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAvLyBObyB2YWxpZCB0YXJnZXRzLCByZXR1cm4gdGhlIGVtcHR5IHJlc3VsdCB0byBzYXZlIGEgcm91bmQgdHJpcC5cbiAgICAgIGlmICghcXVlcmllcyB8fCAhcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9mKHtcbiAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLkRvbmUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdC5hcHAgPT09IENvcmVBcHAuRXhwbG9yZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBsb3JlUXVlcnkocXVlcmllcywgYWN0aXZlVGFyZ2V0cywgZW5kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFuZWxzUXVlcnkocXVlcmllcywgYWN0aXZlVGFyZ2V0cywgZW5kLCByZXF1ZXN0LnJlcXVlc3RJZCwgcmVxdWVzdC5zY29wZWRWYXJzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGV4cGxvcmVRdWVyeShxdWVyaWVzOiBQcm9tUXVlcnlSZXF1ZXN0W10sIGFjdGl2ZVRhcmdldHM6IFByb21RdWVyeVtdLCBlbmQ6IG51bWJlcikge1xuICAgIGxldCBydW5uaW5nUXVlcmllc0NvdW50ID0gcXVlcmllcy5sZW5ndGg7XG5cbiAgICBjb25zdCBzdWJRdWVyaWVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0c1tpbmRleF07XG5cbiAgICAgIGNvbnN0IGZpbHRlckFuZE1hcFJlc3BvbnNlID0gcGlwZShcbiAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGNvdW50ZXIgaGVyZS4gV2UgYXNzdW1lIHRoYXQgZWFjaCByZXF1ZXN0IHJldHVybnMgb25seSBzaW5nbGUgdmFsdWUgYW5kIHRoZW4gY29tcGxldGVzXG4gICAgICAgIC8vIChzaG91bGQgaG9sZCB1bnRpbCB0aGVyZSBpcyBzb21lIHN0cmVhbWluZyByZXF1ZXN0cyBpbnZvbHZlZCkuXG4gICAgICAgIHRhcCgoKSA9PiBydW5uaW5nUXVlcmllc0NvdW50LS0pLFxuICAgICAgICBmaWx0ZXIoKHJlc3BvbnNlOiBhbnkpID0+IChyZXNwb25zZS5jYW5jZWxsZWQgPyBmYWxzZSA6IHRydWUpKSxcbiAgICAgICAgbWFwKChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHRyYW5zZm9ybShyZXNwb25zZSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICByZXNwb25zZUxpc3RMZW5ndGg6IHF1ZXJpZXMubGVuZ3RoLFxuICAgICAgICAgICAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zOiB0aGlzLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGtleTogcXVlcnkucmVxdWVzdElkLFxuICAgICAgICAgICAgc3RhdGU6IHJ1bm5pbmdRdWVyaWVzQ291bnQgPT09IDAgPyBMb2FkaW5nU3RhdGUuRG9uZSA6IExvYWRpbmdTdGF0ZS5Mb2FkaW5nLFxuICAgICAgICAgIH0gYXMgRGF0YVF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeShxdWVyeSwgZW5kLCBmaWx0ZXJBbmRNYXBSZXNwb25zZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWVyZ2UoLi4uc3ViUXVlcmllcyk7XG4gIH1cblxuICBwcml2YXRlIHBhbmVsc1F1ZXJ5KFxuICAgIHF1ZXJpZXM6IFByb21RdWVyeVJlcXVlc3RbXSxcbiAgICBhY3RpdmVUYXJnZXRzOiBQcm9tUXVlcnlbXSxcbiAgICBlbmQ6IG51bWJlcixcbiAgICByZXF1ZXN0SWQ6IHN0cmluZyxcbiAgICBzY29wZWRWYXJzOiBTY29wZWRWYXJzXG4gICkge1xuICAgIGNvbnN0IG9ic2VydmFibGVzID0gcXVlcmllcy5tYXAoKHF1ZXJ5LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0c1tpbmRleF07XG5cbiAgICAgIGNvbnN0IGZpbHRlckFuZE1hcFJlc3BvbnNlID0gcGlwZShcbiAgICAgICAgZmlsdGVyKChyZXNwb25zZTogYW55KSA9PiAocmVzcG9uc2UuY2FuY2VsbGVkID8gZmFsc2UgOiB0cnVlKSksXG4gICAgICAgIG1hcCgocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0cmFuc2Zvcm0ocmVzcG9uc2UsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBxdWVyaWVzLmxlbmd0aCxcbiAgICAgICAgICAgIHNjb3BlZFZhcnMsXG4gICAgICAgICAgICBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM6IHRoaXMuZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMucnVuUXVlcnkocXVlcnksIGVuZCwgZmlsdGVyQW5kTWFwUmVzcG9uc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvcmtKb2luKG9ic2VydmFibGVzKS5waXBlKFxuICAgICAgbWFwKChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXN1bHRzLnJlZHVjZSgocmVzdWx0LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5yZXN1bHQsIC4uLmN1cnJlbnRdO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBrZXk6IHJlcXVlc3RJZCxcbiAgICAgICAgICBzdGF0ZTogTG9hZGluZ1N0YXRlLkRvbmUsXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHJ1blF1ZXJ5PFQ+KHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0LCBlbmQ6IG51bWJlciwgZmlsdGVyOiBPcGVyYXRvckZ1bmN0aW9uPGFueSwgVD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBpZiAocXVlcnkuaW5zdGFudCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybUluc3RhbnRRdWVyeShxdWVyeSwgZW5kKS5waXBlKGZpbHRlcik7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5LmV4ZW1wbGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRFeGVtcGxhcnMocXVlcnkpLnBpcGUoXG4gICAgICAgIGNhdGNoRXJyb3IoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvZih7XG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIHN0YXRlOiBMb2FkaW5nU3RhdGUuRG9uZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlclxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wZXJmb3JtVGltZVNlcmllc1F1ZXJ5KHF1ZXJ5LCBxdWVyeS5zdGFydCwgcXVlcnkuZW5kKS5waXBlKGZpbHRlcik7XG4gIH1cblxuICBjcmVhdGVRdWVyeSh0YXJnZXQ6IFByb21RdWVyeSwgb3B0aW9uczogRGF0YVF1ZXJ5UmVxdWVzdDxQcm9tUXVlcnk+LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIGNvbnN0IHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0ID0ge1xuICAgICAgaGludGluZzogdGFyZ2V0LmhpbnRpbmcsXG4gICAgICBpbnN0YW50OiB0YXJnZXQuaW5zdGFudCxcbiAgICAgIGV4ZW1wbGFyOiB0YXJnZXQuZXhlbXBsYXIsXG4gICAgICBzdGVwOiAwLFxuICAgICAgZXhwcjogJycsXG4gICAgICByZXF1ZXN0SWQ6IHRhcmdldC5yZXF1ZXN0SWQsXG4gICAgICByZWZJZDogdGFyZ2V0LnJlZklkLFxuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDAsXG4gICAgfTtcbiAgICBjb25zdCByYW5nZSA9IE1hdGguY2VpbChlbmQgLSBzdGFydCk7XG5cbiAgICAvLyBvcHRpb25zLmludGVydmFsIGlzIHRoZSBkeW5hbWljYWxseSBjYWxjdWxhdGVkIGludGVydmFsXG4gICAgbGV0IGludGVydmFsOiBudW1iZXIgPSByYW5nZVV0aWwuaW50ZXJ2YWxUb1NlY29uZHMob3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgLy8gTWluaW11bSBpbnRlcnZhbCAoXCJNaW4gc3RlcFwiKSwgaWYgc3BlY2lmaWVkIGZvciB0aGUgcXVlcnksIG9yIHNhbWUgYXMgaW50ZXJ2YWwgb3RoZXJ3aXNlLlxuICAgIGNvbnN0IG1pbkludGVydmFsID0gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKFxuICAgICAgdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5pbnRlcnZhbCB8fCBvcHRpb25zLmludGVydmFsLCBvcHRpb25zLnNjb3BlZFZhcnMpXG4gICAgKTtcbiAgICAvLyBTY3JhcGUgaW50ZXJ2YWwgYXMgc3BlY2lmaWVkIGZvciB0aGUgcXVlcnkgKFwiTWluIHN0ZXBcIikgb3Igb3RoZXJ3aXNlIHRha2VuIGZyb20gdGhlIGRhdGFzb3VyY2UuXG4gICAgLy8gTWluIHN0ZXAgZmllbGQgY2FuIGhhdmUgdGVtcGxhdGUgdmFyaWFibGVzIGluIGl0LCBtYWtlIHN1cmUgdG8gcmVwbGFjZSBpdC5cbiAgICBjb25zdCBzY3JhcGVJbnRlcnZhbCA9IHRhcmdldC5pbnRlcnZhbFxuICAgICAgPyByYW5nZVV0aWwuaW50ZXJ2YWxUb1NlY29uZHModGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5pbnRlcnZhbCwgb3B0aW9ucy5zY29wZWRWYXJzKSlcbiAgICAgIDogcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKHRoaXMuaW50ZXJ2YWwpO1xuXG4gICAgY29uc3QgaW50ZXJ2YWxGYWN0b3IgPSB0YXJnZXQuaW50ZXJ2YWxGYWN0b3IgfHwgMTtcbiAgICAvLyBBZGp1c3QgdGhlIGludGVydmFsIHRvIHRha2UgaW50byBhY2NvdW50IGFueSBzcGVjaWZpZWQgbWluaW11bSBhbmQgaW50ZXJ2YWwgZmFjdG9yIHBsdXMgUHJvbWV0aGV1cyBsaW1pdHNcbiAgICBjb25zdCBhZGp1c3RlZEludGVydmFsID0gdGhpcy5hZGp1c3RJbnRlcnZhbChpbnRlcnZhbCwgbWluSW50ZXJ2YWwsIHJhbmdlLCBpbnRlcnZhbEZhY3Rvcik7XG4gICAgbGV0IHNjb3BlZFZhcnMgPSB7XG4gICAgICAuLi5vcHRpb25zLnNjb3BlZFZhcnMsXG4gICAgICAuLi50aGlzLmdldFJhbmdlU2NvcGVkVmFycyhvcHRpb25zLnJhbmdlKSxcbiAgICAgIC4uLnRoaXMuZ2V0UmF0ZUludGVydmFsU2NvcGVkVmFyaWFibGUoYWRqdXN0ZWRJbnRlcnZhbCwgc2NyYXBlSW50ZXJ2YWwpLFxuICAgIH07XG4gICAgLy8gSWYgdGhlIGludGVydmFsIHdhcyBhZGp1c3RlZCwgbWFrZSBhIHNoYWxsb3cgY29weSBvZiBzY29wZWRWYXJzIHdpdGggdXBkYXRlZCBpbnRlcnZhbCB2YXJzXG4gICAgaWYgKGludGVydmFsICE9PSBhZGp1c3RlZEludGVydmFsKSB7XG4gICAgICBpbnRlcnZhbCA9IGFkanVzdGVkSW50ZXJ2YWw7XG4gICAgICBzY29wZWRWYXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5zY29wZWRWYXJzLCB7XG4gICAgICAgIF9faW50ZXJ2YWw6IHsgdGV4dDogaW50ZXJ2YWwgKyAncycsIHZhbHVlOiBpbnRlcnZhbCArICdzJyB9LFxuICAgICAgICBfX2ludGVydmFsX21zOiB7IHRleHQ6IGludGVydmFsICogMTAwMCwgdmFsdWU6IGludGVydmFsICogMTAwMCB9LFxuICAgICAgICAuLi50aGlzLmdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKGludGVydmFsLCBzY3JhcGVJbnRlcnZhbCksXG4gICAgICAgIC4uLnRoaXMuZ2V0UmFuZ2VTY29wZWRWYXJzKG9wdGlvbnMucmFuZ2UpLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXJ5LnN0ZXAgPSBpbnRlcnZhbDtcblxuICAgIGxldCBleHByID0gdGFyZ2V0LmV4cHI7XG5cbiAgICAvLyBBcHBseSBhZGhvYyBmaWx0ZXJzXG4gICAgZXhwciA9IHRoaXMuZW5oYW5jZUV4cHJXaXRoQWRIb2NGaWx0ZXJzKGV4cHIpO1xuXG4gICAgLy8gT25seSByZXBsYWNlIHZhcnMgaW4gZXhwcmVzc2lvbiBhZnRlciBoYXZpbmcgKHBvc3NpYmx5KSB1cGRhdGVkIGludGVydmFsIHZhcnNcbiAgICBxdWVyeS5leHByID0gdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKGV4cHIsIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuXG4gICAgLy8gQWxpZ24gcXVlcnkgaW50ZXJ2YWwgd2l0aCBzdGVwIHRvIGFsbG93IHF1ZXJ5IGNhY2hpbmcgYW5kIHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgYWJvdXQtc2FtZS10aW1lIHF1ZXJ5IHJlc3VsdHMgbG9vayB0aGUgc2FtZS5cbiAgICBjb25zdCBhZGp1c3RlZCA9IGFsaWduUmFuZ2Uoc3RhcnQsIGVuZCwgcXVlcnkuc3RlcCwgdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpLnRvLnV0Y09mZnNldCgpICogNjApO1xuICAgIHF1ZXJ5LnN0YXJ0ID0gYWRqdXN0ZWQuc3RhcnQ7XG4gICAgcXVlcnkuZW5kID0gYWRqdXN0ZWQuZW5kO1xuICAgIHRoaXMuX2FkZFRyYWNpbmdIZWFkZXJzKHF1ZXJ5LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIGdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlKGludGVydmFsOiBudW1iZXIsIHNjcmFwZUludGVydmFsOiBudW1iZXIpIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgc2NyYXBlIGludGVydmFsIG9mIDE1cyBpZiBzY3JhcGVJbnRlcnZhbCBpcyAwIGZvciBzb21lIHJlYXNvbi5cbiAgICBpZiAoc2NyYXBlSW50ZXJ2YWwgPT09IDApIHtcbiAgICAgIHNjcmFwZUludGVydmFsID0gMTU7XG4gICAgfVxuICAgIGNvbnN0IHJhdGVJbnRlcnZhbCA9IE1hdGgubWF4KGludGVydmFsICsgc2NyYXBlSW50ZXJ2YWwsIDQgKiBzY3JhcGVJbnRlcnZhbCk7XG4gICAgcmV0dXJuIHsgX19yYXRlX2ludGVydmFsOiB7IHRleHQ6IHJhdGVJbnRlcnZhbCArICdzJywgdmFsdWU6IHJhdGVJbnRlcnZhbCArICdzJyB9IH07XG4gIH1cblxuICBhZGp1c3RJbnRlcnZhbChpbnRlcnZhbDogbnVtYmVyLCBtaW5JbnRlcnZhbDogbnVtYmVyLCByYW5nZTogbnVtYmVyLCBpbnRlcnZhbEZhY3RvcjogbnVtYmVyKSB7XG4gICAgLy8gUHJvbWV0aGV1cyB3aWxsIGRyb3AgcXVlcmllcyB0aGF0IG1pZ2h0IHJldHVybiBtb3JlIHRoYW4gMTEwMDAgZGF0YSBwb2ludHMuXG4gICAgLy8gQ2FsY3VsYXRlIGEgc2FmZSBpbnRlcnZhbCBhcyBhbiBhZGRpdGlvbmFsIG1pbmltdW0gdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgLy8gRnJhY3Rpb25hbCBzYWZlSW50ZXJ2YWxzIGFyZSBhbGxvd2VkLCBob3dldmVyIHNlcnZlIGxpdHRsZSBwdXJwb3NlIGlmIHRoZSBpbnRlcnZhbCBpcyBncmVhdGVyIHRoYW4gMVxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGNhc2UgdGFrZSB0aGUgY2VpbCBvZiB0aGUgdmFsdWUuXG4gICAgbGV0IHNhZmVJbnRlcnZhbCA9IHJhbmdlIC8gMTEwMDA7XG4gICAgaWYgKHNhZmVJbnRlcnZhbCA+IDEpIHtcbiAgICAgIHNhZmVJbnRlcnZhbCA9IE1hdGguY2VpbChzYWZlSW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoaW50ZXJ2YWwgKiBpbnRlcnZhbEZhY3RvciwgbWluSW50ZXJ2YWwsIHNhZmVJbnRlcnZhbCk7XG4gIH1cblxuICBwZXJmb3JtVGltZVNlcmllc1F1ZXJ5KHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgdGhyb3cgeyBtZXNzYWdlOiAnSW52YWxpZCB0aW1lIHJhbmdlJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL3F1ZXJ5X3JhbmdlJztcbiAgICBjb25zdCBkYXRhOiBhbnkgPSB7XG4gICAgICBxdWVyeTogcXVlcnkuZXhwcixcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgc3RlcDogcXVlcnkuc3RlcCxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMucXVlcnlUaW1lb3V0KSB7XG4gICAgICBkYXRhWyd0aW1lb3V0J10gPSB0aGlzLnF1ZXJ5VGltZW91dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tTWF0cml4RGF0YT4+KHVybCwgZGF0YSwge1xuICAgICAgcmVxdWVzdElkOiBxdWVyeS5yZXF1ZXN0SWQsXG4gICAgICBoZWFkZXJzOiBxdWVyeS5oZWFkZXJzLFxuICAgIH0pLnBpcGUoXG4gICAgICBjYXRjaEVycm9yKChlcnI6IEZldGNoRXJyb3I8UHJvbURhdGFFcnJvclJlc3BvbnNlPFByb21NYXRyaXhEYXRhPj4pID0+IHtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm4gb2YoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKHRoaXMuaGFuZGxlRXJyb3JzKGVyciwgcXVlcnkpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHBlcmZvcm1JbnN0YW50UXVlcnkoXG4gICAgcXVlcnk6IFByb21RdWVyeVJlcXVlc3QsXG4gICAgdGltZTogbnVtYmVyXG4gICk6IE9ic2VydmFibGU8RmV0Y2hSZXNwb25zZTxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tVmVjdG9yRGF0YSB8IFByb21TY2FsYXJEYXRhPj4gfCBGZXRjaEVycm9yPiB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvcXVlcnknO1xuICAgIGNvbnN0IGRhdGE6IGFueSA9IHtcbiAgICAgIHF1ZXJ5OiBxdWVyeS5leHByLFxuICAgICAgdGltZSxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMucXVlcnlUaW1lb3V0KSB7XG4gICAgICBkYXRhWyd0aW1lb3V0J10gPSB0aGlzLnF1ZXJ5VGltZW91dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tVmVjdG9yRGF0YSB8IFByb21TY2FsYXJEYXRhPj4odXJsLCBkYXRhLCB7XG4gICAgICByZXF1ZXN0SWQ6IHF1ZXJ5LnJlcXVlc3RJZCxcbiAgICAgIGhlYWRlcnM6IHF1ZXJ5LmhlYWRlcnMsXG4gICAgfSkucGlwZShcbiAgICAgIGNhdGNoRXJyb3IoKGVycjogRmV0Y2hFcnJvcjxQcm9tRGF0YUVycm9yUmVzcG9uc2U8UHJvbVZlY3RvckRhdGEgfCBQcm9tU2NhbGFyRGF0YT4+KSA9PiB7XG4gICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcih0aGlzLmhhbmRsZUVycm9ycyhlcnIsIHF1ZXJ5KSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBoYW5kbGVFcnJvcnMgPSAoZXJyOiBhbnksIHRhcmdldDogUHJvbVF1ZXJ5KSA9PiB7XG4gICAgY29uc3QgZXJyb3I6IERhdGFRdWVyeUVycm9yID0ge1xuICAgICAgbWVzc2FnZTogKGVyciAmJiBlcnIuc3RhdHVzVGV4dCkgfHwgJ1Vua25vd24gZXJyb3IgZHVyaW5nIHF1ZXJ5IHRyYW5zYWN0aW9uLiBQbGVhc2UgY2hlY2sgSlMgY29uc29sZSBsb2dzLicsXG4gICAgICByZWZJZDogdGFyZ2V0LnJlZklkLFxuICAgIH07XG5cbiAgICBpZiAoZXJyLmRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2YgZXJyLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnIuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IHNhZmVTdHJpbmdpZnlWYWx1ZShlcnIuZGF0YS5lcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgZXJyb3IubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnI7XG4gICAgfVxuXG4gICAgZXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcbiAgICBlcnJvci5zdGF0dXNUZXh0ID0gZXJyLnN0YXR1c1RleHQ7XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH07XG5cbiAgbWV0cmljRmluZFF1ZXJ5KHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZWRWYXJzID0ge1xuICAgICAgX19pbnRlcnZhbDogeyB0ZXh0OiB0aGlzLmludGVydmFsLCB2YWx1ZTogdGhpcy5pbnRlcnZhbCB9LFxuICAgICAgX19pbnRlcnZhbF9tczogeyB0ZXh0OiByYW5nZVV0aWwuaW50ZXJ2YWxUb01zKHRoaXMuaW50ZXJ2YWwpLCB2YWx1ZTogcmFuZ2VVdGlsLmludGVydmFsVG9Ncyh0aGlzLmludGVydmFsKSB9LFxuICAgICAgLi4udGhpcy5nZXRSYW5nZVNjb3BlZFZhcnModGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpKSxcbiAgICB9O1xuICAgIGNvbnN0IGludGVycG9sYXRlZCA9IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZShxdWVyeSwgc2NvcGVkVmFycywgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gICAgY29uc3QgbWV0cmljRmluZFF1ZXJ5ID0gbmV3IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkodGhpcywgaW50ZXJwb2xhdGVkKTtcbiAgICByZXR1cm4gbWV0cmljRmluZFF1ZXJ5LnByb2Nlc3MoKTtcbiAgfVxuXG4gIGdldFJhbmdlU2NvcGVkVmFycyhyYW5nZTogVGltZVJhbmdlID0gdGhpcy50aW1lU3J2LnRpbWVSYW5nZSgpKSB7XG4gICAgY29uc3QgbXNSYW5nZSA9IHJhbmdlLnRvLmRpZmYocmFuZ2UuZnJvbSk7XG4gICAgY29uc3Qgc1JhbmdlID0gTWF0aC5yb3VuZChtc1JhbmdlIC8gMTAwMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fcmFuZ2VfbXM6IHsgdGV4dDogbXNSYW5nZSwgdmFsdWU6IG1zUmFuZ2UgfSxcbiAgICAgIF9fcmFuZ2VfczogeyB0ZXh0OiBzUmFuZ2UsIHZhbHVlOiBzUmFuZ2UgfSxcbiAgICAgIF9fcmFuZ2U6IHsgdGV4dDogc1JhbmdlICsgJ3MnLCB2YWx1ZTogc1JhbmdlICsgJ3MnIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGFubm90YXRpb25RdWVyeShvcHRpb25zOiBhbnkpOiBQcm9taXNlPEFubm90YXRpb25FdmVudFtdPiB7XG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IG9wdGlvbnMuYW5ub3RhdGlvbjtcbiAgICBjb25zdCB7IGV4cHIgPSAnJyB9ID0gYW5ub3RhdGlvbjtcblxuICAgIGlmICghZXhwcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RlcCA9IG9wdGlvbnMuYW5ub3RhdGlvbi5zdGVwIHx8IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxUO1xuICAgIGNvbnN0IHF1ZXJ5TW9kZWwgPSB7XG4gICAgICBleHByLFxuICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICBpbnN0YW50OiBmYWxzZSxcbiAgICAgIGV4ZW1wbGFyOiBmYWxzZSxcbiAgICAgIGludGVydmFsOiBzdGVwLFxuICAgICAgcXVlcnlUeXBlOiBQcm9tUXVlcnlUeXBlLnRpbWVTZXJpZXNRdWVyeSxcbiAgICAgIHJlZklkOiAnWCcsXG4gICAgICBkYXRhc291cmNlOiB0aGlzLmdldFJlZigpLFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgbGFzdFZhbHVlRnJvbShcbiAgICAgIGdldEJhY2tlbmRTcnYoKVxuICAgICAgICAuZmV0Y2g8QmFja2VuZERhdGFTb3VyY2VSZXNwb25zZT4oe1xuICAgICAgICAgIHVybDogJy9hcGkvZHMvcXVlcnknLFxuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGZyb206ICh0aGlzLmdldFByb21ldGhldXNUaW1lKG9wdGlvbnMucmFuZ2UuZnJvbSwgZmFsc2UpICogMTAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHRvOiAodGhpcy5nZXRQcm9tZXRoZXVzVGltZShvcHRpb25zLnJhbmdlLnRvLCB0cnVlKSAqIDEwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBxdWVyaWVzOiBbdGhpcy5hcHBseVRlbXBsYXRlVmFyaWFibGVzKHF1ZXJ5TW9kZWwsIHt9KV0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1ZXN0SWQ6IGBwcm9tLXF1ZXJ5LSR7YW5ub3RhdGlvbi5uYW1lfWAsXG4gICAgICAgIH0pXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIG1hcCgocnNwOiBGZXRjaFJlc3BvbnNlPEJhY2tlbmREYXRhU291cmNlUmVzcG9uc2U+KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQW5ub3RhdGlvblJlc3BvbnNlKG9wdGlvbnMsIHJzcC5kYXRhKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByb2Nlc3NBbm5vdGF0aW9uUmVzcG9uc2UgPSAob3B0aW9uczogYW55LCBkYXRhOiBCYWNrZW5kRGF0YVNvdXJjZVJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgZnJhbWVzOiBEYXRhRnJhbWVbXSA9IHRvRGF0YVF1ZXJ5UmVzcG9uc2UoeyBkYXRhOiBkYXRhIH0pLmRhdGE7XG4gICAgaWYgKCFmcmFtZXMgfHwgIWZyYW1lcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbm5vdGF0aW9uID0gb3B0aW9ucy5hbm5vdGF0aW9uO1xuICAgIGNvbnN0IHsgdGFnS2V5cyA9ICcnLCB0aXRsZUZvcm1hdCA9ICcnLCB0ZXh0Rm9ybWF0ID0gJycgfSA9IGFubm90YXRpb247XG5cbiAgICBjb25zdCBzdGVwID0gcmFuZ2VVdGlsLmludGVydmFsVG9TZWNvbmRzKGFubm90YXRpb24uc3RlcCB8fCBBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVCkgKiAxMDAwO1xuICAgIGNvbnN0IHRhZ0tleXNBcnJheSA9IHRhZ0tleXMuc3BsaXQoJywnKTtcblxuICAgIGNvbnN0IGV2ZW50TGlzdDogQW5ub3RhdGlvbkV2ZW50W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZnJhbWVzKSB7XG4gICAgICBjb25zdCB0aW1lRmllbGQgPSBmcmFtZS5maWVsZHNbMF07XG4gICAgICBjb25zdCB2YWx1ZUZpZWxkID0gZnJhbWUuZmllbGRzWzFdO1xuICAgICAgY29uc3QgbGFiZWxzID0gdmFsdWVGaWVsZD8ubGFiZWxzIHx8IHt9O1xuXG4gICAgICBjb25zdCB0YWdzID0gT2JqZWN0LmtleXMobGFiZWxzKVxuICAgICAgICAuZmlsdGVyKChsYWJlbCkgPT4gdGFnS2V5c0FycmF5LmluY2x1ZGVzKGxhYmVsKSlcbiAgICAgICAgLm1hcCgobGFiZWwpID0+IGxhYmVsc1tsYWJlbF0pO1xuXG4gICAgICBjb25zdCB0aW1lVmFsdWVUdXBsZTogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcblxuICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICB2YWx1ZUZpZWxkLnZhbHVlcy50b0FycmF5KCkuZm9yRWFjaCgodmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgdGltZVN0YW1wVmFsdWU6IG51bWJlcjtcbiAgICAgICAgbGV0IHZhbHVlVmFsdWU6IG51bWJlcjtcbiAgICAgICAgY29uc3QgdGltZSA9IHRpbWVGaWVsZC52YWx1ZXMuZ2V0KGlkeCk7XG5cbiAgICAgICAgLy8gSWYgd2Ugd2FudCB0byB1c2UgdmFsdWUgYXMgYSB0aW1lLCB3ZSB1c2UgdmFsdWUgYXMgdGltZVN0YW1wVmFsdWUgYW5kIHZhbHVlVmFsdWUgd2lsbCBiZSAxXG4gICAgICAgIGlmIChvcHRpb25zLmFubm90YXRpb24udXNlVmFsdWVGb3JUaW1lKSB7XG4gICAgICAgICAgdGltZVN0YW1wVmFsdWUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgICB2YWx1ZVZhbHVlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lU3RhbXBWYWx1ZSA9IE1hdGguZmxvb3IocGFyc2VGbG9hdCh0aW1lKSk7XG4gICAgICAgICAgdmFsdWVWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWR4Kys7XG4gICAgICAgIHRpbWVWYWx1ZVR1cGxlLnB1c2goW3RpbWVTdGFtcFZhbHVlLCB2YWx1ZVZhbHVlXSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWN0aXZlVmFsdWVzID0gdGltZVZhbHVlVHVwbGUuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWVbMV0gPj0gMSk7XG4gICAgICBjb25zdCBhY3RpdmVWYWx1ZXNUaW1lc3RhbXBzID0gYWN0aXZlVmFsdWVzLm1hcCgodmFsdWUpID0+IHZhbHVlWzBdKTtcblxuICAgICAgLy8gSW5zdGVhZCBvZiBjcmVhdGluZyBzaW5ndWxhciBhbm5vdGF0aW9uIGZvciBlYWNoIGFjdGl2ZSBldmVudCB3ZSBncm91cCBldmVudHMgaW50byByZWdpb24gaWYgdGhleSBhcmUgbGVzc1xuICAgICAgLy8gb3IgZXF1YWwgdG8gYHN0ZXBgIGFwYXJ0LlxuICAgICAgbGV0IGxhdGVzdEV2ZW50OiBBbm5vdGF0aW9uRXZlbnQgfCBudWxsID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCB0aW1lc3RhbXAgb2YgYWN0aXZlVmFsdWVzVGltZXN0YW1wcykge1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgZXZlbnQgYG9wZW5gIGFuZCB3ZSBoYXZlIG5ldyBldmVudCB0aGF0IGlzIGluc2lkZSB0aGUgYHN0ZXBgIHNvIHdlIGp1c3QgdXBkYXRlIHRoZSBlbmQuXG4gICAgICAgIGlmIChsYXRlc3RFdmVudCAmJiAobGF0ZXN0RXZlbnQudGltZUVuZCA/PyAwKSArIHN0ZXAgPj0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgbGF0ZXN0RXZlbnQudGltZUVuZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZW50IGV4aXN0cyBidXQgbmV3IG9uZSBpcyBvdXRzaWRlIG9mIHRoZSBgc3RlcGAgc28gd2UgYWRkIGl0IHRvIGV2ZW50TGlzdC5cbiAgICAgICAgaWYgKGxhdGVzdEV2ZW50KSB7XG4gICAgICAgICAgZXZlbnRMaXN0LnB1c2gobGF0ZXN0RXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugc3RhcnQgYSBuZXcgcmVnaW9uLlxuICAgICAgICBsYXRlc3RFdmVudCA9IHtcbiAgICAgICAgICB0aW1lOiB0aW1lc3RhbXAsXG4gICAgICAgICAgdGltZUVuZDogdGltZXN0YW1wLFxuICAgICAgICAgIGFubm90YXRpb24sXG4gICAgICAgICAgdGl0bGU6IHJlbmRlckxlZ2VuZEZvcm1hdCh0aXRsZUZvcm1hdCwgbGFiZWxzKSxcbiAgICAgICAgICB0YWdzLFxuICAgICAgICAgIHRleHQ6IHJlbmRlckxlZ2VuZEZvcm1hdCh0ZXh0Rm9ybWF0LCBsYWJlbHMpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobGF0ZXN0RXZlbnQpIHtcbiAgICAgICAgLy8gRmluaXNoIHVwIGxhc3QgcG9pbnQgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgbGF0ZXN0RXZlbnQudGltZUVuZCA9IGFjdGl2ZVZhbHVlc1RpbWVzdGFtcHNbYWN0aXZlVmFsdWVzVGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZXZlbnRMaXN0LnB1c2gobGF0ZXN0RXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudExpc3Q7XG4gIH07XG5cbiAgZ2V0RXhlbXBsYXJzKHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0KSB7XG4gICAgY29uc3QgdXJsID0gJy9hcGkvdjEvcXVlcnlfZXhlbXBsYXJzJztcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDxQcm9tRGF0YVN1Y2Nlc3NSZXNwb25zZTxQcm9tRXhlbXBsYXJEYXRhPj4oXG4gICAgICB1cmwsXG4gICAgICB7IHF1ZXJ5OiBxdWVyeS5leHByLCBzdGFydDogcXVlcnkuc3RhcnQudG9TdHJpbmcoKSwgZW5kOiBxdWVyeS5lbmQudG9TdHJpbmcoKSB9LFxuICAgICAgeyByZXF1ZXN0SWQ6IHF1ZXJ5LnJlcXVlc3RJZCwgaGVhZGVyczogcXVlcnkuaGVhZGVycyB9XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGdldFN1YnRpdGxlKCk6IFByb21pc2U8SlNYLkVsZW1lbnQgfCBudWxsPiB7XG4gICAgY29uc3QgYnVpbGRJbmZvID0gYXdhaXQgdGhpcy5nZXRCdWlsZEluZm8oKTtcbiAgICByZXR1cm4gYnVpbGRJbmZvID8gdGhpcy5nZXRCdWlsZEluZm9NZXNzYWdlKGJ1aWxkSW5mbykgOiBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0VGFnS2V5cyhvcHRpb25zPzogYW55KSB7XG4gICAgaWYgKG9wdGlvbnM/LnNlcmllcykge1xuICAgICAgLy8gR2V0IHRhZ3MgZm9yIHRoZSBwcm92aWRlZCBzZXJpZXMgb25seVxuICAgICAgY29uc3Qgc2VyaWVzTGFiZWxzOiBBcnJheTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+ID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIG9wdGlvbnMuc2VyaWVzLm1hcCgoc2VyaWVzOiBzdHJpbmcpID0+IHRoaXMubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhzZXJpZXMpKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHVuaXF1ZUxhYmVscyA9IFsuLi5uZXcgU2V0KC4uLnNlcmllc0xhYmVscy5tYXAoKHZhbHVlKSA9PiBPYmplY3Qua2V5cyh2YWx1ZSkpKV07XG4gICAgICByZXR1cm4gdW5pcXVlTGFiZWxzLm1hcCgodmFsdWU6IGFueSkgPT4gKHsgdGV4dDogdmFsdWUgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXQgYWxsIHRhZ3NcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KCcvYXBpL3YxL2xhYmVscycpO1xuICAgICAgcmV0dXJuIHJlc3VsdD8uZGF0YT8uZGF0YT8ubWFwKCh2YWx1ZTogYW55KSA9PiAoeyB0ZXh0OiB2YWx1ZSB9KSkgPz8gW107XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0VGFnVmFsdWVzKG9wdGlvbnM6IHsga2V5Pzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubWV0YWRhdGFSZXF1ZXN0KGAvYXBpL3YxL2xhYmVsLyR7b3B0aW9ucy5rZXl9L3ZhbHVlc2ApO1xuICAgIHJldHVybiByZXN1bHQ/LmRhdGE/LmRhdGE/Lm1hcCgodmFsdWU6IGFueSkgPT4gKHsgdGV4dDogdmFsdWUgfSkpID8/IFtdO1xuICB9XG5cbiAgYXN5bmMgZ2V0QnVpbGRJbmZvKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBidWlsZEluZm8gPSBhd2FpdCBmZXRjaERhdGFTb3VyY2VCdWlsZEluZm8odGhpcyk7XG4gICAgICByZXR1cm4gYnVpbGRJbmZvO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGJyZWFrIHRoZSByZXN0IG9mIGZ1bmN0aW9uYWxpdHkgaWYgYnVpbGQgaW5mbyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBnZXRCdWlsZEluZm9NZXNzYWdlKGJ1aWxkSW5mbzogUHJvbUJ1aWxkSW5mbykge1xuICAgIGNvbnN0IGVuYWJsZWQgPSA8QmFkZ2UgY29sb3I9XCJncmVlblwiIGljb249XCJjaGVja1wiIHRleHQ9XCJSdWxlciBBUEkgZW5hYmxlZFwiIC8+O1xuICAgIGNvbnN0IGRpc2FibGVkID0gPEJhZGdlIGNvbG9yPVwib3JhbmdlXCIgaWNvbj1cImV4Y2xhbWF0aW9uLXRyaWFuZ2xlXCIgdGV4dD1cIlJ1bGVyIEFQSSBub3QgZW5hYmxlZFwiIC8+O1xuICAgIGNvbnN0IHVuc3VwcG9ydGVkID0gKFxuICAgICAgPFRvb2x0aXBcbiAgICAgICAgcGxhY2VtZW50PVwidG9wXCJcbiAgICAgICAgY29udGVudD1cIlByb21ldGhldXMgZG9lcyBub3QgYWxsb3cgZWRpdGluZyBydWxlcywgY29ubmVjdCB0byBlaXRoZXIgYSBNaW1pciBvciBDb3J0ZXggZGF0YXNvdXJjZSB0byBtYW5hZ2UgYWxlcnRzIHZpYSBHcmFmYW5hLlwiXG4gICAgICA+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPEJhZGdlIGNvbG9yPVwicmVkXCIgaWNvbj1cImV4Y2xhbWF0aW9uLXRyaWFuZ2xlXCIgdGV4dD1cIlJ1bGVyIEFQSSBub3Qgc3VwcG9ydGVkXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L1Rvb2x0aXA+XG4gICAgKTtcblxuICAgIGNvbnN0IExPR09TID0ge1xuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Db3J0ZXhdOiAnL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvaW1nL2NvcnRleF9sb2dvLnN2ZycsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLk1pbWlyXTogJy9wdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9wcm9tZXRoZXVzL2ltZy9taW1pcl9sb2dvLnN2ZycsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXNdOiAnL3B1YmxpYy9hcHAvcGx1Z2lucy9kYXRhc291cmNlL3Byb21ldGhldXMvaW1nL3Byb21ldGhldXNfbG9nby5zdmcnLFxuICAgIH07XG5cbiAgICBjb25zdCBDT0xPUlM6IFJlY29yZDxQcm9tQXBwbGljYXRpb24sIEJhZGdlQ29sb3I+ID0ge1xuICAgICAgW1Byb21BcHBsaWNhdGlvbi5Db3J0ZXhdOiAnYmx1ZScsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLk1pbWlyXTogJ29yYW5nZScsXG4gICAgICBbUHJvbUFwcGxpY2F0aW9uLlByb21ldGhldXNdOiAncmVkJyxcbiAgICB9O1xuXG4gICAgLy8gdGhpcyB3aWxsIGluZm9ybSB0aGUgdXNlciBhYm91dCB3aGF0IFwic3VidHlwZVwiIHRoZSBkYXRhc291cmNlIGlzOyBNaW1pciwgQ29ydGV4IG9yIHZhbmlsbGEgUHJvbWV0aGV1c1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uU3ViVHlwZSA9IChcbiAgICAgIDxCYWRnZVxuICAgICAgICB0ZXh0PXtcbiAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IDE0LCBoZWlnaHQ6IDE0LCB2ZXJ0aWNhbEFsaWduOiAndGV4dC1ib3R0b20nIH19XG4gICAgICAgICAgICAgIHNyYz17TE9HT1NbYnVpbGRJbmZvLmFwcGxpY2F0aW9uID8/IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXX1cbiAgICAgICAgICAgIC8+eycgJ31cbiAgICAgICAgICAgIHtidWlsZEluZm8uYXBwbGljYXRpb259XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICB9XG4gICAgICAgIGNvbG9yPXtDT0xPUlNbYnVpbGRJbmZvLmFwcGxpY2F0aW9uID8/IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzXX1cbiAgICAgIC8+XG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICdtYXgtY29udGVudCBtYXgtY29udGVudCcsXG4gICAgICAgICAgcm93R2FwOiAnMC41cmVtJyxcbiAgICAgICAgICBjb2x1bW5HYXA6ICcycmVtJyxcbiAgICAgICAgICBtYXJnaW5Ub3A6ICcxcmVtJyxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPGRpdj5UeXBlPC9kaXY+XG4gICAgICAgIDxkaXY+e2FwcGxpY2F0aW9uU3ViVHlwZX08L2Rpdj5cbiAgICAgICAgPD5cbiAgICAgICAgICA8ZGl2PlJ1bGVyIEFQSTwvZGl2PlxuICAgICAgICAgIHsvKiBQcm9tZXRoZXVzIGRvZXMgbm90IGhhdmUgYSBSdWxlciBBUEkg4oCTIHNvIHNob3cgdGhhdCBpdCBpcyBub3Qgc3VwcG9ydGVkICovfVxuICAgICAgICAgIHtidWlsZEluZm8uYXBwbGljYXRpb24gPT09IFByb21BcHBsaWNhdGlvbi5Qcm9tZXRoZXVzICYmIDxkaXY+e3Vuc3VwcG9ydGVkfTwvZGl2Pn1cbiAgICAgICAgICB7YnVpbGRJbmZvLmFwcGxpY2F0aW9uICE9PSBQcm9tQXBwbGljYXRpb24uUHJvbWV0aGV1cyAmJiAoXG4gICAgICAgICAgICA8ZGl2PntidWlsZEluZm8uZmVhdHVyZXMucnVsZXJBcGlFbmFibGVkID8gZW5hYmxlZCA6IGRpc2FibGVkfTwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHRlc3REYXRhc291cmNlKCkge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5PiA9IHtcbiAgICAgIHRhcmdldHM6IFt7IHJlZklkOiAndGVzdCcsIGV4cHI6ICcxKzEnLCBpbnN0YW50OiB0cnVlIH1dLFxuICAgICAgcmVxdWVzdElkOiBgJHt0aGlzLmlkfS1oZWFsdGhgLFxuICAgICAgc2NvcGVkVmFyczoge30sXG4gICAgICBkYXNoYm9hcmRJZDogMCxcbiAgICAgIHBhbmVsSWQ6IDAsXG4gICAgICBpbnRlcnZhbDogJzFtJyxcbiAgICAgIGludGVydmFsTXM6IDYwMDAwLFxuICAgICAgbWF4RGF0YVBvaW50czogMSxcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIGZyb206IGRhdGVUaW1lKG5vdyAtIDEwMDApLFxuICAgICAgICB0bzogZGF0ZVRpbWUobm93KSxcbiAgICAgIH0sXG4gICAgfSBhcyBEYXRhUXVlcnlSZXF1ZXN0PFByb21RdWVyeT47XG5cbiAgICBjb25zdCBidWlsZEluZm8gPSBhd2FpdCB0aGlzLmdldEJ1aWxkSW5mbygpO1xuXG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20odGhpcy5xdWVyeShyZXF1ZXN0KSlcbiAgICAgIC50aGVuKChyZXM6IERhdGFRdWVyeVJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmICghcmVzIHx8ICFyZXMuZGF0YSB8fCByZXMuc3RhdGUgIT09IExvYWRpbmdTdGF0ZS5Eb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiBgRXJyb3IgcmVhZGluZyBQcm9tZXRoZXVzOiAke3Jlcz8uZXJyb3I/Lm1lc3NhZ2V9YCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdEYXRhIHNvdXJjZSBpcyB3b3JraW5nJyxcbiAgICAgICAgICAgIGRldGFpbHM6IGJ1aWxkSW5mbyAmJiB7XG4gICAgICAgICAgICAgIHZlcmJvc2VNZXNzYWdlOiB0aGlzLmdldEJ1aWxkSW5mb01lc3NhZ2UoYnVpbGRJbmZvKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUHJvbWV0aGV1cyBFcnJvcicsIGVycik7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogJ2Vycm9yJywgbWVzc2FnZTogZXJyLm1lc3NhZ2UgfTtcbiAgICAgIH0pO1xuICB9XG5cbiAgaW50ZXJwb2xhdGVWYXJpYWJsZXNJblF1ZXJpZXMocXVlcmllczogUHJvbVF1ZXJ5W10sIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnMpOiBQcm9tUXVlcnlbXSB7XG4gICAgbGV0IGV4cGFuZGVkUXVlcmllcyA9IHF1ZXJpZXM7XG4gICAgaWYgKHF1ZXJpZXMgJiYgcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgIGV4cGFuZGVkUXVlcmllcyA9IHF1ZXJpZXMubWFwKChxdWVyeSkgPT4ge1xuICAgICAgICBjb25zdCBleHBhbmRlZFF1ZXJ5ID0ge1xuICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgIGRhdGFzb3VyY2U6IHRoaXMuZ2V0UmVmKCksXG4gICAgICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHF1ZXJ5LmV4cHIsIHNjb3BlZFZhcnMsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpLFxuICAgICAgICAgIGludGVydmFsOiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UocXVlcnkuaW50ZXJ2YWwsIHNjb3BlZFZhcnMpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXhwYW5kZWRRdWVyeTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kZWRRdWVyaWVzO1xuICB9XG5cbiAgZ2V0UXVlcnlIaW50cyhxdWVyeTogUHJvbVF1ZXJ5LCByZXN1bHQ6IGFueVtdKSB7XG4gICAgcmV0dXJuIGdldFF1ZXJ5SGludHMocXVlcnkuZXhwciA/PyAnJywgcmVzdWx0LCB0aGlzKTtcbiAgfVxuXG4gIGdldEluaXRIaW50cygpIHtcbiAgICByZXR1cm4gZ2V0SW5pdEhpbnRzKHRoaXMpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFJ1bGVzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLm1ldGFkYXRhUmVxdWVzdCgnL2FwaS92MS9ydWxlcycpO1xuICAgICAgY29uc3QgZ3JvdXBzID0gcmVzLmRhdGE/LmRhdGE/Lmdyb3VwcztcblxuICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICB0aGlzLnJ1bGVNYXBwaW5ncyA9IGV4dHJhY3RSdWxlTWFwcGluZ0Zyb21Hcm91cHMoZ3JvdXBzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZygnUnVsZXMgQVBJIGlzIGV4cGVyaW1lbnRhbC4gSWdub3JlIG5leHQgZXJyb3IuJyk7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFyZUV4ZW1wbGFyc0F2YWlsYWJsZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5tZXRhZGF0YVJlcXVlc3QoJy9hcGkvdjEvcXVlcnlfZXhlbXBsYXJzJywgeyBxdWVyeTogJ3Rlc3QnIH0pO1xuICAgICAgaWYgKHJlcy5kYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG1vZGlmeVF1ZXJ5KHF1ZXJ5OiBQcm9tUXVlcnksIGFjdGlvbjogYW55KTogUHJvbVF1ZXJ5IHtcbiAgICBsZXQgZXhwcmVzc2lvbiA9IHF1ZXJ5LmV4cHIgPz8gJyc7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSAnQUREX0ZJTFRFUic6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGFkZExhYmVsVG9RdWVyeShleHByZXNzaW9uLCBhY3Rpb24ua2V5LCBhY3Rpb24udmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0FERF9GSUxURVJfT1VUJzoge1xuICAgICAgICBleHByZXNzaW9uID0gYWRkTGFiZWxUb1F1ZXJ5KGV4cHJlc3Npb24sIGFjdGlvbi5rZXksIGFjdGlvbi52YWx1ZSwgJyE9Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQUREX0hJU1RPR1JBTV9RVUFOVElMRSc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGBoaXN0b2dyYW1fcXVhbnRpbGUoMC45NSwgc3VtKHJhdGUoJHtleHByZXNzaW9ufVskX19yYXRlX2ludGVydmFsXSkpIGJ5IChsZSkpYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBRERfUkFURSc6IHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGByYXRlKCR7ZXhwcmVzc2lvbn1bJF9fcmF0ZV9pbnRlcnZhbF0pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBRERfU1VNJzoge1xuICAgICAgICBleHByZXNzaW9uID0gYHN1bSgke2V4cHJlc3Npb24udHJpbSgpfSkgYnkgKCQxKWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnRVhQQU5EX1JVTEVTJzoge1xuICAgICAgICBpZiAoYWN0aW9uLm1hcHBpbmcpIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gZXhwYW5kUmVjb3JkaW5nUnVsZXMoZXhwcmVzc2lvbiwgYWN0aW9uLm1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IC4uLnF1ZXJ5LCBleHByOiBleHByZXNzaW9uIH07XG4gIH1cblxuICBnZXRQcm9tZXRoZXVzVGltZShkYXRlOiBzdHJpbmcgfCBEYXRlVGltZSwgcm91bmRVcDogYm9vbGVhbikge1xuICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGUgPSBkYXRlTWF0aC5wYXJzZShkYXRlLCByb3VuZFVwKSE7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguY2VpbChkYXRlLnZhbHVlT2YoKSAvIDEwMDApO1xuICB9XG5cbiAgZ2V0VGltZVJhbmdlUGFyYW1zKCk6IHsgc3RhcnQ6IHN0cmluZzsgZW5kOiBzdHJpbmcgfSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLnRpbWVTcnYudGltZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFByb21ldGhldXNUaW1lKHJhbmdlLmZyb20sIGZhbHNlKS50b1N0cmluZygpLFxuICAgICAgZW5kOiB0aGlzLmdldFByb21ldGhldXNUaW1lKHJhbmdlLnRvLCB0cnVlKS50b1N0cmluZygpLFxuICAgIH07XG4gIH1cblxuICBnZXRPcmlnaW5hbE1ldHJpY05hbWUobGFiZWxEYXRhOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gICAgcmV0dXJuIGdldE9yaWdpbmFsTWV0cmljTmFtZShsYWJlbERhdGEpO1xuICB9XG5cbiAgZW5oYW5jZUV4cHJXaXRoQWRIb2NGaWx0ZXJzKGV4cHI6IHN0cmluZykge1xuICAgIGNvbnN0IGFkaG9jRmlsdGVycyA9IHRoaXMudGVtcGxhdGVTcnYuZ2V0QWRob2NGaWx0ZXJzKHRoaXMubmFtZSk7XG5cbiAgICBjb25zdCBmaW5hbFF1ZXJ5ID0gYWRob2NGaWx0ZXJzLnJlZHVjZSgoYWNjOiBzdHJpbmcsIGZpbHRlcjogeyBrZXk/OiBhbnk7IG9wZXJhdG9yPzogYW55OyB2YWx1ZT86IGFueSB9KSA9PiB7XG4gICAgICBjb25zdCB7IGtleSwgb3BlcmF0b3IgfSA9IGZpbHRlcjtcbiAgICAgIGxldCB7IHZhbHVlIH0gPSBmaWx0ZXI7XG4gICAgICBpZiAob3BlcmF0b3IgPT09ICc9ficgfHwgb3BlcmF0b3IgPT09ICchficpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9tZXRoZXVzUmVndWxhckVzY2FwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkTGFiZWxUb1F1ZXJ5KGFjYywga2V5LCB2YWx1ZSwgb3BlcmF0b3IpO1xuICAgIH0sIGV4cHIpO1xuICAgIHJldHVybiBmaW5hbFF1ZXJ5O1xuICB9XG5cbiAgLy8gVXNlZCB3aGVuIHJ1bm5pbmcgcXVlcmllcyB0cm91Z2ggYmFja2VuZFxuICBmaWx0ZXJRdWVyeShxdWVyeTogUHJvbVF1ZXJ5KTogYm9vbGVhbiB7XG4gICAgaWYgKHF1ZXJ5LmhpZGUgfHwgIXF1ZXJ5LmV4cHIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gcnVubmluZyBxdWVyaWVzIHRyb3VnaCBiYWNrZW5kXG4gIGFwcGx5VGVtcGxhdGVWYXJpYWJsZXModGFyZ2V0OiBQcm9tUXVlcnksIHNjb3BlZFZhcnM6IFNjb3BlZFZhcnMpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBjbG9uZURlZXAoc2NvcGVkVmFycyk7XG5cbiAgICAvLyBXZSB3YW50IHRvIGludGVycG9sYXRlIHRoZXNlIHZhcmlhYmxlcyBvbiBiYWNrZW5kXG4gICAgZGVsZXRlIHZhcmlhYmxlcy5fX2ludGVydmFsO1xuICAgIGRlbGV0ZSB2YXJpYWJsZXMuX19pbnRlcnZhbF9tcztcblxuICAgIC8vQWRkIGFkIGhvYyBmaWx0ZXJzXG4gICAgY29uc3QgZXhwciA9IHRoaXMuZW5oYW5jZUV4cHJXaXRoQWRIb2NGaWx0ZXJzKHRhcmdldC5leHByKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBsZWdlbmRGb3JtYXQ6IHRoaXMudGVtcGxhdGVTcnYucmVwbGFjZSh0YXJnZXQubGVnZW5kRm9ybWF0LCB2YXJpYWJsZXMpLFxuICAgICAgZXhwcjogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKGV4cHIsIHZhcmlhYmxlcywgdGhpcy5pbnRlcnBvbGF0ZVF1ZXJ5RXhwciksXG4gICAgICBpbnRlcnZhbDogdGhpcy50ZW1wbGF0ZVNydi5yZXBsYWNlKHRhcmdldC5pbnRlcnZhbCwgdmFyaWFibGVzKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0VmFyaWFibGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNydi5nZXRWYXJpYWJsZXMoKS5tYXAoKHYpID0+IGAkJHt2Lm5hbWV9YCk7XG4gIH1cblxuICBpbnRlcnBvbGF0ZVN0cmluZyhzdHJpbmc6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2Uoc3RyaW5nLCB1bmRlZmluZWQsIHRoaXMuaW50ZXJwb2xhdGVRdWVyeUV4cHIpO1xuICB9XG59XG5cbi8qKlxuICogQWxpZ24gcXVlcnkgcmFuZ2UgdG8gc3RlcC5cbiAqIFJvdW5kcyBzdGFydCBhbmQgZW5kIGRvd24gdG8gYSBtdWx0aXBsZSBvZiBzdGVwLlxuICogQHBhcmFtIHN0YXJ0IFRpbWVzdGFtcCBtYXJraW5nIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIGVuZCBUaW1lc3RhbXAgbWFya2luZyB0aGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSBzdGVwIEludGVydmFsIHRvIGFsaWduIHN0YXJ0IGFuZCBlbmQgd2l0aC5cbiAqIEBwYXJhbSB1dGNPZmZzZXRTZWMgTnVtYmVyIG9mIHNlY29uZHMgY3VycmVudCB0aW1lem9uZSBpcyBvZmZzZXQgZnJvbSBVVENcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduUmFuZ2UoXG4gIHN0YXJ0OiBudW1iZXIsXG4gIGVuZDogbnVtYmVyLFxuICBzdGVwOiBudW1iZXIsXG4gIHV0Y09mZnNldFNlYzogbnVtYmVyXG4pOiB7IGVuZDogbnVtYmVyOyBzdGFydDogbnVtYmVyIH0ge1xuICBjb25zdCBhbGlnbmVkRW5kID0gTWF0aC5mbG9vcigoZW5kICsgdXRjT2Zmc2V0U2VjKSAvIHN0ZXApICogc3RlcCAtIHV0Y09mZnNldFNlYztcbiAgY29uc3QgYWxpZ25lZFN0YXJ0ID0gTWF0aC5mbG9vcigoc3RhcnQgKyB1dGNPZmZzZXRTZWMpIC8gc3RlcCkgKiBzdGVwIC0gdXRjT2Zmc2V0U2VjO1xuICByZXR1cm4ge1xuICAgIGVuZDogYWxpZ25lZEVuZCxcbiAgICBzdGFydDogYWxpZ25lZFN0YXJ0LFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFJ1bGVNYXBwaW5nRnJvbUdyb3Vwcyhncm91cHM6IGFueVtdKSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKFxuICAgIChtYXBwaW5nLCBncm91cCkgPT5cbiAgICAgIGdyb3VwLnJ1bGVzXG4gICAgICAgIC5maWx0ZXIoKHJ1bGU6IGFueSkgPT4gcnVsZS50eXBlID09PSAncmVjb3JkaW5nJylcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAoYWNjOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LCBydWxlOiBhbnkpID0+ICh7XG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICBbcnVsZS5uYW1lXTogcnVsZS5xdWVyeSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtYXBwaW5nXG4gICAgICAgICksXG4gICAge31cbiAgKTtcbn1cblxuLy8gTk9URTogdGhlc2UgdHdvIGZ1bmN0aW9ucyBhcmUgdmVyeSBzaW1pbGFyIHRvIHRoZSBlc2NhcGVMYWJlbFZhbHVlSW4qIGZ1bmN0aW9uc1xuLy8gaW4gbGFuZ3VhZ2VfdXRpbHMudHMsIGJ1dCB0aGV5IGFyZSBub3QgZXhhY3RseSB0aGUgc2FtZSBhbGdvcml0aG0sIGFuZCB3ZSBmb3VuZFxuLy8gbm8gd2F5IHRvIHJldXNlIG9uZSBpbiB0aGUgYW5vdGhlciBvciB2aWNlIHZlcnNhLlxuZXhwb3J0IGZ1bmN0aW9uIHByb21ldGhldXNSZWd1bGFyRXNjYXBlKHZhbHVlOiBhbnkpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoLycvZywgXCJcXFxcXFxcXCdcIikgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUodmFsdWU6IGFueSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcXFxcXFxcXFwnKS5yZXBsYWNlKC9bJF4qe31cXFtcXF1cXCcrPy4oKXxdL2csICdcXFxcXFxcXCQmJykgOiB2YWx1ZTtcbn1cbiIsImltcG9ydCB7IG9uY2UsIGNoYWluLCBkaWZmZXJlbmNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnc2xhdGUnO1xuaW1wb3J0IFByaXNtIGZyb20gJ3ByaXNtanMnO1xuXG5pbXBvcnQge1xuICBBYnN0cmFjdExhYmVsTWF0Y2hlcixcbiAgQWJzdHJhY3RMYWJlbE9wZXJhdG9yLFxuICBBYnN0cmFjdFF1ZXJ5LFxuICBkYXRlVGltZSxcbiAgSGlzdG9yeUl0ZW0sXG4gIExhbmd1YWdlUHJvdmlkZXIsXG59IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgQ29tcGxldGlvbkl0ZW0sIENvbXBsZXRpb25JdGVtR3JvdXAsIFNlYXJjaEZ1bmN0aW9uVHlwZSwgVHlwZWFoZWFkSW5wdXQsIFR5cGVhaGVhZE91dHB1dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcblxuaW1wb3J0IHtcbiAgYWRkTGltaXRJbmZvLFxuICBleHRyYWN0TGFiZWxNYXRjaGVycyxcbiAgZml4U3VtbWFyaWVzTWV0YWRhdGEsXG4gIHBhcnNlU2VsZWN0b3IsXG4gIHByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzLFxuICBwcm9jZXNzTGFiZWxzLFxuICByb3VuZFNlY1RvTWluLFxuICB0b1Byb21MaWtlUXVlcnksXG59IGZyb20gJy4vbGFuZ3VhZ2VfdXRpbHMnO1xuaW1wb3J0IFByb21xbFN5bnRheCwgeyBGVU5DVElPTlMsIFJBVEVfUkFOR0VTIH0gZnJvbSAnLi9wcm9tcWwnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tTWV0cmljc01ldGFkYXRhLCBQcm9tUXVlcnkgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgREVGQVVMVF9LRVlTID0gWydqb2InLCAnaW5zdGFuY2UnXTtcbmNvbnN0IEVNUFRZX1NFTEVDVE9SID0gJ3t9JztcbmNvbnN0IEhJU1RPUllfSVRFTV9DT1VOVCA9IDU7XG5jb25zdCBISVNUT1JZX0NPVU5UX0NVVE9GRiA9IDEwMDAgKiA2MCAqIDYwICogMjQ7IC8vIDI0aFxuLy8gTWF4IG51bWJlciBvZiBpdGVtcyAobWV0cmljcywgbGFiZWxzLCB2YWx1ZXMpIHRoYXQgd2UgZGlzcGxheSBhcyBzdWdnZXN0aW9ucy4gUHJldmVudHMgZnJvbSBydW5uaW5nIG91dCBvZiBtZW1vcnkuXG5leHBvcnQgY29uc3QgU1VHR0VTVElPTlNfTElNSVQgPSAxMDAwMDtcblxuY29uc3Qgd3JhcExhYmVsID0gKGxhYmVsOiBzdHJpbmcpOiBDb21wbGV0aW9uSXRlbSA9PiAoeyBsYWJlbCB9KTtcblxuY29uc3Qgc2V0RnVuY3Rpb25LaW5kID0gKHN1Z2dlc3Rpb246IENvbXBsZXRpb25JdGVtKTogQ29tcGxldGlvbkl0ZW0gPT4ge1xuICBzdWdnZXN0aW9uLmtpbmQgPSAnZnVuY3Rpb24nO1xuICByZXR1cm4gc3VnZ2VzdGlvbjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRIaXN0b3J5TWV0YWRhdGEoaXRlbTogQ29tcGxldGlvbkl0ZW0sIGhpc3Rvcnk6IGFueVtdKTogQ29tcGxldGlvbkl0ZW0ge1xuICBjb25zdCBjdXRvZmZUcyA9IERhdGUubm93KCkgLSBISVNUT1JZX0NPVU5UX0NVVE9GRjtcbiAgY29uc3QgaGlzdG9yeUZvckl0ZW0gPSBoaXN0b3J5LmZpbHRlcigoaCkgPT4gaC50cyA+IGN1dG9mZlRzICYmIGgucXVlcnkgPT09IGl0ZW0ubGFiZWwpO1xuICBjb25zdCBjb3VudCA9IGhpc3RvcnlGb3JJdGVtLmxlbmd0aDtcbiAgY29uc3QgcmVjZW50ID0gaGlzdG9yeUZvckl0ZW1bMF07XG4gIGxldCBoaW50ID0gYFF1ZXJpZWQgJHtjb3VudH0gdGltZXMgaW4gdGhlIGxhc3QgMjRoLmA7XG5cbiAgaWYgKHJlY2VudCkge1xuICAgIGNvbnN0IGxhc3RRdWVyaWVkID0gZGF0ZVRpbWUocmVjZW50LnRzKS5mcm9tTm93KCk7XG4gICAgaGludCA9IGAke2hpbnR9IExhc3QgcXVlcmllZCAke2xhc3RRdWVyaWVkfS5gO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5pdGVtLFxuICAgIGRvY3VtZW50YXRpb246IGhpbnQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE1ldHJpY3NNZXRhZGF0YShtZXRyaWM6IHN0cmluZywgbWV0YWRhdGE/OiBQcm9tTWV0cmljc01ldGFkYXRhKTogQ29tcGxldGlvbkl0ZW0ge1xuICBjb25zdCBpdGVtOiBDb21wbGV0aW9uSXRlbSA9IHsgbGFiZWw6IG1ldHJpYyB9O1xuICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGFbbWV0cmljXSkge1xuICAgIGl0ZW0uZG9jdW1lbnRhdGlvbiA9IGdldE1ldGFkYXRhU3RyaW5nKG1ldHJpYywgbWV0YWRhdGEpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0YWRhdGFTdHJpbmcobWV0cmljOiBzdHJpbmcsIG1ldGFkYXRhOiBQcm9tTWV0cmljc01ldGFkYXRhKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFtZXRhZGF0YVttZXRyaWNdKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCB7IHR5cGUsIGhlbHAgfSA9IG1ldGFkYXRhW21ldHJpY107XG4gIHJldHVybiBgJHt0eXBlLnRvVXBwZXJDYXNlKCl9OiAke2hlbHB9YDtcbn1cblxuY29uc3QgUFJFRklYX0RFTElNSVRFUl9SRUdFWCA9XG4gIC8oPVwifCE9XCJ8PX5cInwhflwifFxce3xcXFt8XFwofFxcK3wtfFxcL3xcXCp8JXxcXF58XFxiYW5kXFxifFxcYm9yXFxifFxcYnVubGVzc1xcYnw9PXw+PXwhPXw8PXw+fDx8PXx+fCwpLztcblxuaW50ZXJmYWNlIEF1dG9jb21wbGV0ZUNvbnRleHQge1xuICBoaXN0b3J5PzogQXJyYXk8SGlzdG9yeUl0ZW08UHJvbVF1ZXJ5Pj47XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9tUWxMYW5ndWFnZVByb3ZpZGVyIGV4dGVuZHMgTGFuZ3VhZ2VQcm92aWRlciB7XG4gIGhpc3RvZ3JhbU1ldHJpY3M6IHN0cmluZ1tdO1xuICB0aW1lUmFuZ2U/OiB7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyIH07XG4gIG1ldHJpY3M6IHN0cmluZ1tdO1xuICBtZXRyaWNzTWV0YWRhdGE/OiBQcm9tTWV0cmljc01ldGFkYXRhO1xuICBkZWNsYXJlIHN0YXJ0VGFzazogUHJvbWlzZTxhbnk+O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgbGFiZWxLZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBkZWNsYXJlIGxhYmVsRmV0Y2hUczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiAgQ2FjaGUgZm9yIGxhYmVscyBvZiBzZXJpZXMuIFRoaXMgaXMgYml0IHNpbXBsaXN0aWMgaW4gdGhlIHNlbnNlIHRoYXQgaXQganVzdCBjb3VudHMgcmVzcG9uc2VzIGVhY2ggYXMgYSAxIGFuZCBkb2VzXG4gICAqICBub3QgYWNjb3VudCBmb3IgZGlmZmVyZW50IHNpemUgb2YgYSByZXNwb25zZS4gSWYgdGhhdCBpcyBuZWVkZWQgYSBgbGVuZ3RoYCBmdW5jdGlvbiBjYW4gYmUgYWRkZWQgaW4gdGhlIG9wdGlvbnMuXG4gICAqICAxMCBhcyBhIG1heCBzaXplIGlzIHRvdGFsbHkgYXJiaXRyYXJ5IHJpZ2h0IG5vdy5cbiAgICovXG4gIHByaXZhdGUgbGFiZWxzQ2FjaGUgPSBuZXcgTFJVPHN0cmluZywgUmVjb3JkPHN0cmluZywgc3RyaW5nW10+Pih7IG1heDogMTAgfSk7XG5cbiAgY29uc3RydWN0b3IoZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2UsIGluaXRpYWxWYWx1ZXM/OiBQYXJ0aWFsPFByb21RbExhbmd1YWdlUHJvdmlkZXI+KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZGF0YXNvdXJjZSA9IGRhdGFzb3VyY2U7XG4gICAgdGhpcy5oaXN0b2dyYW1NZXRyaWNzID0gW107XG4gICAgdGhpcy50aW1lUmFuZ2UgPSB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgICB0aGlzLm1ldHJpY3MgPSBbXTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgaW5pdGlhbFZhbHVlcyk7XG4gIH1cblxuICAvLyBTdHJpcCBzeW50YXggY2hhcnMgc28gdGhhdCB0eXBlYWhlYWQgc3VnZ2VzdGlvbnMgY2FuIHdvcmsgb24gY2xlYW4gaW5wdXRzXG4gIGNsZWFuVGV4dChzOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHMuc3BsaXQoUFJFRklYX0RFTElNSVRFUl9SRUdFWCk7XG4gICAgY29uc3QgbGFzdCA9IHBhcnRzLnBvcCgpITtcbiAgICByZXR1cm4gbGFzdC50cmltTGVmdCgpLnJlcGxhY2UoL1wiJC8sICcnKS5yZXBsYWNlKC9eXCIvLCAnJyk7XG4gIH1cblxuICBnZXQgc3ludGF4KCkge1xuICAgIHJldHVybiBQcm9tcWxTeW50YXg7XG4gIH1cblxuICByZXF1ZXN0ID0gYXN5bmMgKHVybDogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IGFueSwgcGFyYW1zID0ge30pOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKTtcbiAgICAgIHJldHVybiByZXMuZGF0YS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9O1xuXG4gIHN0YXJ0ID0gYXN5bmMgKCk6IFByb21pc2U8YW55W10+ID0+IHtcbiAgICBpZiAodGhpcy5kYXRhc291cmNlLmxvb2t1cHNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIFRPRE8gIzMzOTc2OiBtYWtlIHRob3NlIHJlcXVlc3RzIHBhcmFsbGVsXG4gICAgYXdhaXQgdGhpcy5mZXRjaExhYmVscygpO1xuICAgIHRoaXMubWV0cmljcyA9IChhd2FpdCB0aGlzLmZldGNoTGFiZWxWYWx1ZXMoJ19fbmFtZV9fJykpIHx8IFtdO1xuICAgIGF3YWl0IHRoaXMubG9hZE1ldHJpY3NNZXRhZGF0YSgpO1xuICAgIHRoaXMuaGlzdG9ncmFtTWV0cmljcyA9IHByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzKHRoaXMubWV0cmljcykuc29ydCgpO1xuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICBhc3luYyBsb2FkTWV0cmljc01ldGFkYXRhKCkge1xuICAgIHRoaXMubWV0cmljc01ldGFkYXRhID0gZml4U3VtbWFyaWVzTWV0YWRhdGEoYXdhaXQgdGhpcy5yZXF1ZXN0KCcvYXBpL3YxL21ldGFkYXRhJywge30pKTtcbiAgfVxuXG4gIGdldExhYmVsS2V5cygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMubGFiZWxLZXlzO1xuICB9XG5cbiAgcHJvdmlkZUNvbXBsZXRpb25JdGVtcyA9IGFzeW5jIChcbiAgICB7IHByZWZpeCwgdGV4dCwgdmFsdWUsIGxhYmVsS2V5LCB3cmFwcGVyQ2xhc3NlcyB9OiBUeXBlYWhlYWRJbnB1dCxcbiAgICBjb250ZXh0OiBBdXRvY29tcGxldGVDb250ZXh0ID0ge31cbiAgKTogUHJvbWlzZTxUeXBlYWhlYWRPdXRwdXQ+ID0+IHtcbiAgICBjb25zdCBlbXB0eVJlc3VsdDogVHlwZWFoZWFkT3V0cHV0ID0geyBzdWdnZXN0aW9uczogW10gfTtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBlbXB0eVJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBMb2NhbCB0ZXh0IHByb3BlcnRpZXNcbiAgICBjb25zdCBlbXB0eSA9IHZhbHVlLmRvY3VtZW50LnRleHQubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IHNlbGVjdGVkTGluZXMgPSB2YWx1ZS5kb2N1bWVudC5nZXRUZXh0c0F0UmFuZ2UodmFsdWUuc2VsZWN0aW9uKTtcbiAgICBjb25zdCBjdXJyZW50TGluZSA9IHNlbGVjdGVkTGluZXMuc2l6ZSA9PT0gMSA/IHNlbGVjdGVkTGluZXMuZmlyc3QoKS5nZXRUZXh0KCkgOiBudWxsO1xuXG4gICAgY29uc3QgbmV4dENoYXJhY3RlciA9IGN1cnJlbnRMaW5lID8gY3VycmVudExpbmVbdmFsdWUuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXRdIDogbnVsbDtcblxuICAgIC8vIFN5bnRheCBzcGFucyBoYXZlIDMgY2xhc3NlcyBieSBkZWZhdWx0LiBNb3JlIGluZGljYXRlIGEgcmVjb2duaXplZCB0b2tlblxuICAgIGNvbnN0IHRva2VuUmVjb2duaXplZCA9IHdyYXBwZXJDbGFzc2VzLmxlbmd0aCA+IDM7XG4gICAgLy8gTm9uLWVtcHR5IHByZWZpeCwgYnV0IG5vdCBpbnNpZGUga25vd24gdG9rZW5cbiAgICBjb25zdCBwcmVmaXhVbnJlY29nbml6ZWQgPSBwcmVmaXggJiYgIXRva2VuUmVjb2duaXplZDtcblxuICAgIC8vIFByZXZlbnQgc3VnZ2VzdGlvbnMgaW4gYGZ1bmN0aW9uKHxzdWZmaXgpYFxuICAgIGNvbnN0IG5vU3VmZml4ID0gIW5leHRDaGFyYWN0ZXIgfHwgbmV4dENoYXJhY3RlciA9PT0gJyknO1xuXG4gICAgLy8gUHJlZml4IGlzIHNhZmUgaWYgaXQgZG9lcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93IGEgY29tcGxldGUgZXhwcmVzc2lvbiBhbmQgaGFzIG5vIHRleHQgYWZ0ZXIgaXRcbiAgICBjb25zdCBzYWZlUHJlZml4ID0gcHJlZml4ICYmICF0ZXh0Lm1hdGNoKC9eW1xcXX0pXFxzXSskLykgJiYgbm9TdWZmaXg7XG5cbiAgICAvLyBBYm91dCB0byB0eXBlIG5leHQgb3BlcmFuZCBpZiBwcmVjZWRlZCBieSBiaW5hcnkgb3BlcmF0b3JcbiAgICBjb25zdCBvcGVyYXRvcnNQYXR0ZXJuID0gL1srXFwtKi9eJV0vO1xuICAgIGNvbnN0IGlzTmV4dE9wZXJhbmQgPSB0ZXh0Lm1hdGNoKG9wZXJhdG9yc1BhdHRlcm4pO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGNhbmRpZGF0ZXMgYnkgQ1NTIGNvbnRleHRcbiAgICBpZiAod3JhcHBlckNsYXNzZXMuaW5jbHVkZXMoJ2NvbnRleHQtcmFuZ2UnKSkge1xuICAgICAgLy8gU3VnZ2VzdGlvbnMgZm9yIG1ldHJpY1t8XVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VDb21wbGV0aW9uSXRlbXMoKTtcbiAgICB9IGVsc2UgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LWxhYmVscycpKSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3IgbWV0cmlje3x9IGFuZCBtZXRyaWN7Zm9vPXx9LCBhcyB3ZWxsIGFzIG1ldHJpYy1pbmRlcGVuZGVudCBsYWJlbCBxdWVyaWVzIGxpa2Uge3x9XG4gICAgICByZXR1cm4gdGhpcy5nZXRMYWJlbENvbXBsZXRpb25JdGVtcyh7IHByZWZpeCwgdGV4dCwgdmFsdWUsIGxhYmVsS2V5LCB3cmFwcGVyQ2xhc3NlcyB9KTtcbiAgICB9IGVsc2UgaWYgKHdyYXBwZXJDbGFzc2VzLmluY2x1ZGVzKCdjb250ZXh0LWFnZ3JlZ2F0aW9uJykpIHtcbiAgICAgIC8vIFN1Z2dlc3Rpb25zIGZvciBzdW0obWV0cmljKSBieSAofClcbiAgICAgIHJldHVybiB0aGlzLmdldEFnZ3JlZ2F0aW9uQ29tcGxldGlvbkl0ZW1zKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGVtcHR5KSB7XG4gICAgICAvLyBTdWdnZXN0aW9ucyBmb3IgZW1wdHkgcXVlcnkgZmllbGRcbiAgICAgIHJldHVybiB0aGlzLmdldEVtcHR5Q29tcGxldGlvbkl0ZW1zKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocHJlZml4VW5yZWNvZ25pemVkICYmIG5vU3VmZml4ICYmICFpc05leHRPcGVyYW5kKSB7XG4gICAgICAvLyBTaG93IHRlcm0gc3VnZ2VzdGlvbnMgaW4gYSBjb3VwbGUgb2Ygc2NlbmFyaW9zXG4gICAgICByZXR1cm4gdGhpcy5nZXRCZWdpbm5pbmdDb21wbGV0aW9uSXRlbXMoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXhVbnJlY29nbml6ZWQgJiYgc2FmZVByZWZpeCkge1xuICAgICAgLy8gU2hvdyB0ZXJtIHN1Z2dlc3Rpb25zIGluIGEgY291cGxlIG9mIHNjZW5hcmlvc1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGVybUNvbXBsZXRpb25JdGVtcygpO1xuICAgIH1cblxuICAgIHJldHVybiBlbXB0eVJlc3VsdDtcbiAgfTtcblxuICBnZXRCZWdpbm5pbmdDb21wbGV0aW9uSXRlbXMgPSAoY29udGV4dDogQXV0b2NvbXBsZXRlQ29udGV4dCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Z2dlc3Rpb25zOiBbLi4udGhpcy5nZXRFbXB0eUNvbXBsZXRpb25JdGVtcyhjb250ZXh0KS5zdWdnZXN0aW9ucywgLi4udGhpcy5nZXRUZXJtQ29tcGxldGlvbkl0ZW1zKCkuc3VnZ2VzdGlvbnNdLFxuICAgIH07XG4gIH07XG5cbiAgZ2V0RW1wdHlDb21wbGV0aW9uSXRlbXMgPSAoY29udGV4dDogQXV0b2NvbXBsZXRlQ29udGV4dCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgY29uc3QgeyBoaXN0b3J5IH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcblxuICAgIGlmIChoaXN0b3J5ICYmIGhpc3RvcnkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoaXN0b3J5SXRlbXMgPSBjaGFpbihoaXN0b3J5KVxuICAgICAgICAubWFwKChoKSA9PiBoLnF1ZXJ5LmV4cHIpXG4gICAgICAgIC5maWx0ZXIoKVxuICAgICAgICAudW5pcSgpXG4gICAgICAgIC50YWtlKEhJU1RPUllfSVRFTV9DT1VOVClcbiAgICAgICAgLm1hcCh3cmFwTGFiZWwpXG4gICAgICAgIC5tYXAoKGl0ZW0pID0+IGFkZEhpc3RvcnlNZXRhZGF0YShpdGVtLCBoaXN0b3J5KSlcbiAgICAgICAgLnZhbHVlKCk7XG5cbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5QcmVmaXgsXG4gICAgICAgIHNraXBTb3J0OiB0cnVlLFxuICAgICAgICBsYWJlbDogJ0hpc3RvcnknLFxuICAgICAgICBpdGVtczogaGlzdG9yeUl0ZW1zLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBnZXRUZXJtQ29tcGxldGlvbkl0ZW1zID0gKCk6IFR5cGVhaGVhZE91dHB1dCA9PiB7XG4gICAgY29uc3QgeyBtZXRyaWNzLCBtZXRyaWNzTWV0YWRhdGEgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IENvbXBsZXRpb25JdGVtR3JvdXBbXSA9IFtdO1xuXG4gICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5QcmVmaXgsXG4gICAgICBsYWJlbDogJ0Z1bmN0aW9ucycsXG4gICAgICBpdGVtczogRlVOQ1RJT05TLm1hcChzZXRGdW5jdGlvbktpbmQpLFxuICAgIH0pO1xuXG4gICAgaWYgKG1ldHJpY3MgJiYgbWV0cmljcy5sZW5ndGgpIHtcbiAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICBsYWJlbDogJ01ldHJpY3MnLFxuICAgICAgICBpdGVtczogbWV0cmljcy5tYXAoKG0pID0+IGFkZE1ldHJpY3NNZXRhZGF0YShtLCBtZXRyaWNzTWV0YWRhdGEpKSxcbiAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuRnV6enksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICB9O1xuXG4gIGdldFJhbmdlQ29tcGxldGlvbkl0ZW1zKCk6IFR5cGVhaGVhZE91dHB1dCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQ6ICdjb250ZXh0LXJhbmdlJyxcbiAgICAgIHN1Z2dlc3Rpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogJ1JhbmdlIHZlY3RvcicsXG4gICAgICAgICAgaXRlbXM6IFsuLi5SQVRFX1JBTkdFU10sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cblxuICBnZXRBZ2dyZWdhdGlvbkNvbXBsZXRpb25JdGVtcyA9IGFzeW5jICh2YWx1ZTogVmFsdWUpOiBQcm9taXNlPFR5cGVhaGVhZE91dHB1dD4gPT4ge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBDb21wbGV0aW9uSXRlbUdyb3VwW10gPSBbXTtcblxuICAgIC8vIFN0aXRjaCBhbGwgcXVlcnkgbGluZXMgdG9nZXRoZXIgdG8gc3VwcG9ydCBtdWx0aS1saW5lIHF1ZXJpZXNcbiAgICBsZXQgcXVlcnlPZmZzZXQ7XG4gICAgY29uc3QgcXVlcnlUZXh0ID0gdmFsdWUuZG9jdW1lbnQuZ2V0QmxvY2tzKCkucmVkdWNlKCh0ZXh0LCBibG9jaykgPT4ge1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9ja1RleHQgPSBibG9jaz8uZ2V0VGV4dCgpO1xuXG4gICAgICBpZiAodmFsdWUuYW5jaG9yQmxvY2sua2V5ID09PSBibG9jay5rZXkpIHtcbiAgICAgICAgLy8gTmV3bGluZSBjaGFyYWN0ZXJzIGFyZSBub3QgYWNjb3VudGVkIGZvciBidXQgdGhpcyBpcyBpcnJlbGV2YW50XG4gICAgICAgIC8vIGZvciB0aGUgcHVycG9zZSBvZiBleHRyYWN0aW5nIHRoZSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgcXVlcnlPZmZzZXQgPSB2YWx1ZS5zZWxlY3Rpb24uYW5jaG9yLm9mZnNldCArIHRleHQubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dCArIGJsb2NrVGV4dDtcbiAgICB9LCAnJyk7XG5cbiAgICAvLyBUcnkgc2VhcmNoIGZvciBzZWxlY3RvciBwYXJ0IG9uIHRoZSBsZWZ0LWhhbmQgc2lkZSwgc3VjaCBhcyBgc3VtIChtKSBieSAobClgXG4gICAgY29uc3Qgb3BlblBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggPSBxdWVyeVRleHQubGFzdEluZGV4T2YoJygnLCBxdWVyeU9mZnNldCk7XG4gICAgbGV0IG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ID0gcXVlcnlUZXh0Lmxhc3RJbmRleE9mKCcoJywgb3BlblBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggLSAxKTtcbiAgICBsZXQgY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4ID0gcXVlcnlUZXh0LmluZGV4T2YoJyknLCBvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCk7XG5cbiAgICAvLyBUcnkgc2VhcmNoIGZvciBzZWxlY3RvciBwYXJ0IG9mIGFuIGFsdGVybmF0ZSBhZ2dyZWdhdGlvbiBjbGF1c2UsIHN1Y2ggYXMgYHN1bSBieSAobCkgKG0pYFxuICAgIGlmIChvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IGNsb3NlUGFyZW5zQWdncmVnYXRpb25JbmRleCA9IHF1ZXJ5VGV4dC5pbmRleE9mKCcpJywgcXVlcnlPZmZzZXQpO1xuICAgICAgY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4ID0gcXVlcnlUZXh0LmluZGV4T2YoJyknLCBjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXggKyAxKTtcbiAgICAgIG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ID0gcXVlcnlUZXh0Lmxhc3RJbmRleE9mKCcoJywgY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBzdWdnZXN0aW9ucyxcbiAgICAgIGNvbnRleHQ6ICdjb250ZXh0LWFnZ3JlZ2F0aW9uJyxcbiAgICB9O1xuXG4gICAgLy8gU3VnZ2VzdGlvbnMgYXJlIHVzZWxlc3MgZm9yIGFsdGVybmF0aXZlIGFnZ3JlZ2F0aW9uIGNsYXVzZXMgd2l0aG91dCBhIHNlbGVjdG9yIGluIGNvbnRleHRcbiAgICBpZiAob3BlblBhcmVuc1NlbGVjdG9ySW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFJhbmdlIHZlY3RvciBzeW50YXggbm90IGFjY291bnRlZCBmb3IgYnkgc3Vic2VxdWVudCBwYXJzZSBzbyBkaXNjYXJkIGl0IGlmIHByZXNlbnRcbiAgICBjb25zdCBzZWxlY3RvclN0cmluZyA9IHF1ZXJ5VGV4dFxuICAgICAgLnNsaWNlKG9wZW5QYXJlbnNTZWxlY3RvckluZGV4ICsgMSwgY2xvc2VQYXJlbnNTZWxlY3RvckluZGV4KVxuICAgICAgLnJlcGxhY2UoL1xcW1teXFxdXStcXF0kLywgJycpO1xuXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBwYXJzZVNlbGVjdG9yKHNlbGVjdG9yU3RyaW5nLCBzZWxlY3RvclN0cmluZy5sZW5ndGggLSAyKS5zZWxlY3RvcjtcblxuICAgIGNvbnN0IHNlcmllcyA9IGF3YWl0IHRoaXMuZ2V0U2VyaWVzKHNlbGVjdG9yKTtcbiAgICBjb25zdCBsYWJlbEtleXMgPSBPYmplY3Qua2V5cyhzZXJpZXMpO1xuICAgIGlmIChsYWJlbEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGltaXRJbmZvID0gYWRkTGltaXRJbmZvKGxhYmVsS2V5cyk7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgbGFiZWw6IGBMYWJlbHMke2xpbWl0SW5mb31gLFxuICAgICAgICBpdGVtczogbGFiZWxLZXlzLm1hcCh3cmFwTGFiZWwpLFxuICAgICAgICBzZWFyY2hGdW5jdGlvblR5cGU6IFNlYXJjaEZ1bmN0aW9uVHlwZS5GdXp6eSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGdldExhYmVsQ29tcGxldGlvbkl0ZW1zID0gYXN5bmMgKHtcbiAgICB0ZXh0LFxuICAgIHdyYXBwZXJDbGFzc2VzLFxuICAgIGxhYmVsS2V5LFxuICAgIHZhbHVlLFxuICB9OiBUeXBlYWhlYWRJbnB1dCk6IFByb21pc2U8VHlwZWFoZWFkT3V0cHV0PiA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3VnZ2VzdGlvbnM6IFtdIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IENvbXBsZXRpb25JdGVtR3JvdXBbXSA9IFtdO1xuICAgIGNvbnN0IGxpbmUgPSB2YWx1ZS5hbmNob3JCbG9jay5nZXRUZXh0KCk7XG4gICAgY29uc3QgY3Vyc29yT2Zmc2V0ID0gdmFsdWUuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3Qgc3VmZml4ID0gbGluZS5zdWJzdHIoY3Vyc29yT2Zmc2V0KTtcbiAgICBjb25zdCBwcmVmaXggPSBsaW5lLnN1YnN0cigwLCBjdXJzb3JPZmZzZXQpO1xuICAgIGNvbnN0IGlzVmFsdWVTdGFydCA9IHRleHQubWF0Y2goL14oPXw9fnwhPXwhfikvKTtcbiAgICBjb25zdCBpc1ZhbHVlRW5kID0gc3VmZml4Lm1hdGNoKC9eXCI/Wyx9XXwkLyk7XG4gICAgLy8gRGV0ZWN0IGN1cnNvciBpbiBmcm9udCBvZiB2YWx1ZSwgZS5nLiwge2tleT18XCJ9XG4gICAgY29uc3QgaXNQcmVWYWx1ZSA9IHByZWZpeC5tYXRjaCgvKD18PX58IT18IX4pJC8pICYmIHN1ZmZpeC5tYXRjaCgvXlwiLyk7XG5cbiAgICAvLyBEb24ndCBzdWdnZXN0IGFueXRoaW5nIGF0IHRoZSBiZWdpbm5pbmcgb3IgaW5zaWRlIGEgdmFsdWVcbiAgICBjb25zdCBpc1ZhbHVlRW1wdHkgPSBpc1ZhbHVlU3RhcnQgJiYgaXNWYWx1ZUVuZDtcbiAgICBjb25zdCBoYXNWYWx1ZVByZWZpeCA9IGlzVmFsdWVFbmQgJiYgIWlzVmFsdWVTdGFydDtcbiAgICBpZiAoKCFpc1ZhbHVlRW1wdHkgJiYgIWhhc1ZhbHVlUHJlZml4KSB8fCBpc1ByZVZhbHVlKSB7XG4gICAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICAgIH1cblxuICAgIC8vIEdldCBub3JtYWxpemVkIHNlbGVjdG9yXG4gICAgbGV0IHNlbGVjdG9yO1xuICAgIGxldCBwYXJzZWRTZWxlY3RvcjtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkU2VsZWN0b3IgPSBwYXJzZVNlbGVjdG9yKGxpbmUsIGN1cnNvck9mZnNldCk7XG4gICAgICBzZWxlY3RvciA9IHBhcnNlZFNlbGVjdG9yLnNlbGVjdG9yO1xuICAgIH0gY2F0Y2gge1xuICAgICAgc2VsZWN0b3IgPSBFTVBUWV9TRUxFQ1RPUjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250YWluc01ldHJpYyA9IHNlbGVjdG9yLmluY2x1ZGVzKCdfX25hbWVfXz0nKTtcbiAgICBjb25zdCBleGlzdGluZ0tleXMgPSBwYXJzZWRTZWxlY3RvciA/IHBhcnNlZFNlbGVjdG9yLmxhYmVsS2V5cyA6IFtdO1xuXG4gICAgbGV0IHNlcmllczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge307XG4gICAgLy8gUXVlcnkgbGFiZWxzIGZvciBzZWxlY3RvclxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgc2VyaWVzID0gYXdhaXQgdGhpcy5nZXRTZXJpZXMoc2VsZWN0b3IsICFjb250YWluc01ldHJpYyk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHNlcmllcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFNlcnZlciBkaWQgbm90IHJldHVybiBhbnkgdmFsdWVzIGZvciBzZWxlY3RvciA9ICR7c2VsZWN0b3J9YCk7XG4gICAgICByZXR1cm4geyBzdWdnZXN0aW9ucyB9O1xuICAgIH1cblxuICAgIGxldCBjb250ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoKHRleHQgJiYgaXNWYWx1ZVN0YXJ0KSB8fCB3cmFwcGVyQ2xhc3Nlcy5pbmNsdWRlcygnYXR0ci12YWx1ZScpKSB7XG4gICAgICAvLyBMYWJlbCB2YWx1ZXNcbiAgICAgIGlmIChsYWJlbEtleSAmJiBzZXJpZXNbbGFiZWxLZXldKSB7XG4gICAgICAgIGNvbnRleHQgPSAnY29udGV4dC1sYWJlbC12YWx1ZXMnO1xuICAgICAgICBjb25zdCBsaW1pdEluZm8gPSBhZGRMaW1pdEluZm8oc2VyaWVzW2xhYmVsS2V5XSk7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgIGxhYmVsOiBgTGFiZWwgdmFsdWVzIGZvciBcIiR7bGFiZWxLZXl9XCIke2xpbWl0SW5mb31gLFxuICAgICAgICAgIGl0ZW1zOiBzZXJpZXNbbGFiZWxLZXldLm1hcCh3cmFwTGFiZWwpLFxuICAgICAgICAgIHNlYXJjaEZ1bmN0aW9uVHlwZTogU2VhcmNoRnVuY3Rpb25UeXBlLkZ1enp5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGFiZWwga2V5c1xuICAgICAgY29uc3QgbGFiZWxLZXlzID0gc2VyaWVzID8gT2JqZWN0LmtleXMoc2VyaWVzKSA6IGNvbnRhaW5zTWV0cmljID8gbnVsbCA6IERFRkFVTFRfS0VZUztcblxuICAgICAgaWYgKGxhYmVsS2V5cykge1xuICAgICAgICBjb25zdCBwb3NzaWJsZUtleXMgPSBkaWZmZXJlbmNlKGxhYmVsS2V5cywgZXhpc3RpbmdLZXlzKTtcbiAgICAgICAgaWYgKHBvc3NpYmxlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0ID0gJ2NvbnRleHQtbGFiZWxzJztcbiAgICAgICAgICBjb25zdCBuZXdJdGVtcyA9IHBvc3NpYmxlS2V5cy5tYXAoKGtleSkgPT4gKHsgbGFiZWw6IGtleSB9KSk7XG4gICAgICAgICAgY29uc3QgbGltaXRJbmZvID0gYWRkTGltaXRJbmZvKG5ld0l0ZW1zKTtcbiAgICAgICAgICBjb25zdCBuZXdTdWdnZXN0aW9uOiBDb21wbGV0aW9uSXRlbUdyb3VwID0ge1xuICAgICAgICAgICAgbGFiZWw6IGBMYWJlbHMke2xpbWl0SW5mb31gLFxuICAgICAgICAgICAgaXRlbXM6IG5ld0l0ZW1zLFxuICAgICAgICAgICAgc2VhcmNoRnVuY3Rpb25UeXBlOiBTZWFyY2hGdW5jdGlvblR5cGUuRnV6enksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKG5ld1N1Z2dlc3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29udGV4dCwgc3VnZ2VzdGlvbnMgfTtcbiAgfTtcblxuICBpbXBvcnRGcm9tQWJzdHJhY3RRdWVyeShsYWJlbEJhc2VkUXVlcnk6IEFic3RyYWN0UXVlcnkpOiBQcm9tUXVlcnkge1xuICAgIHJldHVybiB0b1Byb21MaWtlUXVlcnkobGFiZWxCYXNlZFF1ZXJ5KTtcbiAgfVxuXG4gIGV4cG9ydFRvQWJzdHJhY3RRdWVyeShxdWVyeTogUHJvbVF1ZXJ5KTogQWJzdHJhY3RRdWVyeSB7XG4gICAgY29uc3QgcHJvbVF1ZXJ5ID0gcXVlcnkuZXhwcjtcbiAgICBpZiAoIXByb21RdWVyeSB8fCBwcm9tUXVlcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyByZWZJZDogcXVlcnkucmVmSWQsIGxhYmVsTWF0Y2hlcnM6IFtdIH07XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IFByaXNtLnRva2VuaXplKHByb21RdWVyeSwgUHJvbXFsU3ludGF4KTtcbiAgICBjb25zdCBsYWJlbE1hdGNoZXJzOiBBYnN0cmFjdExhYmVsTWF0Y2hlcltdID0gZXh0cmFjdExhYmVsTWF0Y2hlcnModG9rZW5zKTtcbiAgICBjb25zdCBuYW1lTGFiZWxWYWx1ZSA9IGdldE5hbWVMYWJlbFZhbHVlKHByb21RdWVyeSwgdG9rZW5zKTtcbiAgICBpZiAobmFtZUxhYmVsVmFsdWUgJiYgbmFtZUxhYmVsVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgbGFiZWxNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ19fbmFtZV9fJyxcbiAgICAgICAgb3BlcmF0b3I6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5FcXVhbCxcbiAgICAgICAgdmFsdWU6IG5hbWVMYWJlbFZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkOiBxdWVyeS5yZWZJZCxcbiAgICAgIGxhYmVsTWF0Y2hlcnMsXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFNlcmllcyhzZWxlY3Rvcjogc3RyaW5nLCB3aXRoTmFtZT86IGJvb2xlYW4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPj4ge1xuICAgIGlmICh0aGlzLmRhdGFzb3VyY2UubG9va3Vwc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IEVNUFRZX1NFTEVDVE9SKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoRGVmYXVsdFNlcmllcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hTZXJpZXNMYWJlbHMoc2VsZWN0b3IsIHdpdGhOYW1lKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVE9ETzogYmV0dGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICBmZXRjaExhYmVsVmFsdWVzID0gYXN5bmMgKGtleTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4gPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCB1cmwgPSBgL2FwaS92MS9sYWJlbC8ke3RoaXMuZGF0YXNvdXJjZS5pbnRlcnBvbGF0ZVN0cmluZyhrZXkpfS92YWx1ZXNgO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCBbXSwgcGFyYW1zKTtcbiAgfTtcblxuICBhc3luYyBnZXRMYWJlbFZhbHVlcyhrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaExhYmVsVmFsdWVzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgbGFiZWwga2V5c1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hMYWJlbHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHVybCA9ICcvYXBpL3YxL2xhYmVscyc7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIHRoaXMubGFiZWxGZXRjaFRzID0gRGF0ZS5ub3coKS52YWx1ZU9mKCk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcXVlc3QodXJsLCBbXSwgcGFyYW1zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICB0aGlzLmxhYmVsS2V5cyA9IHJlcy5zbGljZSgpLnNvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGFiZWxzIGZvciBhIHNlcmllcy4gVGhpcyBpcyBjYWNoZWQgYnkgaXQncyBhcmdzIGJ1dCBhbHNvIGJ5IHRoZSBnbG9iYWwgdGltZVJhbmdlIGN1cnJlbnRseSBzZWxlY3RlZCBhc1xuICAgKiB0aGV5IGNhbiBjaGFuZ2Ugb3ZlciByZXF1ZXN0ZWQgdGltZS5cbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHBhcmFtIHdpdGhOYW1lXG4gICAqL1xuICBmZXRjaFNlcmllc0xhYmVscyA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIHdpdGhOYW1lPzogYm9vbGVhbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nW10+PiA9PiB7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkTmFtZSA9IHRoaXMuZGF0YXNvdXJjZS5pbnRlcnBvbGF0ZVN0cmluZyhuYW1lKTtcbiAgICBjb25zdCByYW5nZSA9IHRoaXMuZGF0YXNvdXJjZS5nZXRUaW1lUmFuZ2VQYXJhbXMoKTtcbiAgICBjb25zdCB1cmxQYXJhbXMgPSB7XG4gICAgICAuLi5yYW5nZSxcbiAgICAgICdtYXRjaFtdJzogaW50ZXJwb2xhdGVkTmFtZSxcbiAgICB9O1xuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL3Nlcmllc2A7XG4gICAgLy8gQ2FjaGUga2V5IGlzIGEgYml0IGRpZmZlcmVudCBoZXJlLiBXZSBhZGQgdGhlIGB3aXRoTmFtZWAgcGFyYW0gYW5kIGFsc28gcm91bmQgdXAgdG8gYSBtaW51dGUgdGhlIGludGVydmFscy5cbiAgICAvLyBUaGUgcm91bmRpbmcgbWF5IHNlZW0gc3RyYW5nZSBidXQgbWFrZXMgcmVsYXRpdmUgaW50ZXJ2YWxzIGxpa2Ugbm93LTFoIGxlc3MgcHJvbmUgdG8gbmVlZCBzZXBhcmF0ZSByZXF1ZXN0IGV2ZXJ5XG4gICAgLy8gbWlsbGlzZWNvbmQgd2hpbGUgc3RpbGwgYWN0dWFsbHkgZ2V0dGluZyBhbGwgdGhlIGtleXMgZm9yIHRoZSBjb3JyZWN0IGludGVydmFsLiBUaGlzIHN0aWxsIGNhbiBjcmVhdGUgcHJvYmxlbXNcbiAgICAvLyB3aGVuIHVzZXIgZG9lcyBub3QgdGhlIG5ld2VzdCB2YWx1ZXMgZm9yIGEgbWludXRlIGlmIGFscmVhZHkgY2FjaGVkLlxuICAgIGNvbnN0IGNhY2hlUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAnbWF0Y2hbXSc6IGludGVycG9sYXRlZE5hbWUsXG4gICAgICBzdGFydDogcm91bmRTZWNUb01pbihwYXJzZUludChyYW5nZS5zdGFydCwgMTApKS50b1N0cmluZygpLFxuICAgICAgZW5kOiByb3VuZFNlY1RvTWluKHBhcnNlSW50KHJhbmdlLmVuZCwgMTApKS50b1N0cmluZygpLFxuICAgICAgd2l0aE5hbWU6IHdpdGhOYW1lID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNhY2hlS2V5ID0gYC9hcGkvdjEvc2VyaWVzPyR7Y2FjaGVQYXJhbXMudG9TdHJpbmcoKX1gO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubGFiZWxzQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwgW10sIHVybFBhcmFtcyk7XG4gICAgICBjb25zdCB7IHZhbHVlcyB9ID0gcHJvY2Vzc0xhYmVscyhkYXRhLCB3aXRoTmFtZSk7XG4gICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgIHRoaXMubGFiZWxzQ2FjaGUuc2V0KGNhY2hlS2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogRmV0Y2ggc2VyaWVzIGZvciBhIHNlbGVjdG9yLiBVc2UgdGhpcyBmb3IgcmF3IHJlc3VsdHMuIFVzZSBmZXRjaFNlcmllc0xhYmVscygpIHRvIGdldCBsYWJlbHMuXG4gICAqIEBwYXJhbSBtYXRjaFxuICAgKi9cbiAgZmV0Y2hTZXJpZXMgPSBhc3luYyAobWF0Y2g6IHN0cmluZyk6IFByb21pc2U8QXJyYXk8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4+ID0+IHtcbiAgICBjb25zdCB1cmwgPSAnL2FwaS92MS9zZXJpZXMnO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5kYXRhc291cmNlLmdldFRpbWVSYW5nZVBhcmFtcygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgLi4ucmFuZ2UsICdtYXRjaFtdJzogbWF0Y2ggfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0KHVybCwge30sIHBhcmFtcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoaXMgb25seSBvbmUgYXMgd2UgYXNzdW1lIHRoaXMgd29uJ3QgY2hhbmdlIG92ZXIgdGltZS4gVGhpcyBpcyBjYWNoZWQgZGlmZmVyZW50bHkgZnJvbSBmZXRjaFNlcmllc0xhYmVsc1xuICAgKiBiZWNhdXNlIHdlIGNhbiBjYWNoZSBtb3JlIGFnZ3Jlc3NpdmVseSBoZXJlIGFuZCBhbHNvIHdlIGRvIG5vdCB3YW50IHRvIGludmFsaWRhdGUgdGhpcyBjYWNoZSB0aGUgc2FtZSB3YXkgYXMgaW5cbiAgICogZmV0Y2hTZXJpZXNMYWJlbHMuXG4gICAqL1xuICBmZXRjaERlZmF1bHRTZXJpZXMgPSBvbmNlKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChERUZBVUxUX0tFWVMubWFwKChrZXkpID0+IHRoaXMuZmV0Y2hMYWJlbFZhbHVlcyhrZXkpKSk7XG4gICAgcmV0dXJuIERFRkFVTFRfS0VZUy5yZWR1Y2UoKGFjYywga2V5LCBpKSA9PiAoeyAuLi5hY2MsIFtrZXldOiB2YWx1ZXNbaV0gfSksIHt9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE5hbWVMYWJlbFZhbHVlKHByb21RdWVyeTogc3RyaW5nLCB0b2tlbnM6IGFueSk6IHN0cmluZyB7XG4gIGxldCBuYW1lTGFiZWxWYWx1ZSA9ICcnO1xuICBmb3IgKGxldCBwcm9wIGluIHRva2Vucykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW3Byb3BdID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZUxhYmVsVmFsdWUgPSB0b2tlbnNbcHJvcF0gYXMgc3RyaW5nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lTGFiZWxWYWx1ZTtcbn1cbiIsImltcG9ydCB7IFByb21NZXRyaWNzTWV0YWRhdGEsIFByb21NZXRyaWNzTWV0YWRhdGFJdGVtIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBhZGRMYWJlbFRvUXVlcnkgfSBmcm9tICcuL2FkZF9sYWJlbF90b19xdWVyeSc7XG5pbXBvcnQgeyBTVUdHRVNUSU9OU19MSU1JVCB9IGZyb20gJy4vbGFuZ3VhZ2VfcHJvdmlkZXInO1xuaW1wb3J0IHsgRGF0YVF1ZXJ5LCBBYnN0cmFjdFF1ZXJ5LCBBYnN0cmFjdExhYmVsT3BlcmF0b3IsIEFic3RyYWN0TGFiZWxNYXRjaGVyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IHsgaW52ZXJ0IH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGNvbnN0IHByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzID0gKG1ldHJpY3M6IHN0cmluZ1tdKSA9PiB7XG4gIGNvbnN0IHJlc3VsdFNldDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ19idWNrZXQoJHw6KScpO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWV0cmljcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBtZXRyaWMgPSBtZXRyaWNzW2luZGV4XTtcbiAgICBjb25zdCBpc0hpc3RvZ3JhbVZhbHVlID0gcmVnZXhwLnRlc3QobWV0cmljKTtcbiAgICBpZiAoaXNIaXN0b2dyYW1WYWx1ZSkge1xuICAgICAgcmVzdWx0U2V0LmFkZChtZXRyaWMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnJlc3VsdFNldF07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0xhYmVscyhsYWJlbHM6IEFycmF5PHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0+LCB3aXRoTmFtZSA9IGZhbHNlKSB7XG4gIC8vIEZvciBwcm9jZXNzaW5nIHdlIGFyZSBnb2luZyB0byB1c2Ugc2V0cyBhcyB0aGV5IGhhdmUgc2lnbmlmaWNhbnRseSBiZXR0ZXIgcGVyZm9ybWFuY2UgdGhhbiBhcnJheXNcbiAgLy8gQWZ0ZXIgd2UgcHJvY2VzcyBsYWJlbHMsIHdlIHdpbGwgY29udmVydCBzZXRzIHRvIGFycmF5cyBhbmQgcmV0dXJuIG9iamVjdCB3aXRoIGxhYmVsIHZhbHVlcyBpbiBhcnJheXNcbiAgY29uc3QgdmFsdWVTZXQ6IHsgW2tleTogc3RyaW5nXTogU2V0PHN0cmluZz4gfSA9IHt9O1xuICBsYWJlbHMuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICBjb25zdCB7IF9fbmFtZV9fLCAuLi5yZXN0IH0gPSBsYWJlbDtcbiAgICBpZiAod2l0aE5hbWUpIHtcbiAgICAgIHZhbHVlU2V0WydfX25hbWVfXyddID0gdmFsdWVTZXRbJ19fbmFtZV9fJ10gfHwgbmV3IFNldCgpO1xuICAgICAgaWYgKCF2YWx1ZVNldFsnX19uYW1lX18nXS5oYXMoX19uYW1lX18pKSB7XG4gICAgICAgIHZhbHVlU2V0WydfX25hbWVfXyddLmFkZChfX25hbWVfXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMocmVzdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIXZhbHVlU2V0W2tleV0pIHtcbiAgICAgICAgdmFsdWVTZXRba2V5XSA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWVTZXRba2V5XS5oYXMocmVzdFtrZXldKSkge1xuICAgICAgICB2YWx1ZVNldFtrZXldLmFkZChyZXN0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyB2YWx1ZUFycmF5IHRoYXQgd2UgYXJlIGdvaW5nIHRvIHJldHVybiBpbiB0aGUgb2JqZWN0XG4gIGNvbnN0IHZhbHVlQXJyYXk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nW10gfSA9IHt9O1xuICBsaW1pdFN1Z2dlc3Rpb25zKE9iamVjdC5rZXlzKHZhbHVlU2V0KSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgdmFsdWVBcnJheVtrZXldID0gbGltaXRTdWdnZXN0aW9ucyhBcnJheS5mcm9tKHZhbHVlU2V0W2tleV0pKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgdmFsdWVzOiB2YWx1ZUFycmF5LCBrZXlzOiBPYmplY3Qua2V5cyh2YWx1ZUFycmF5KSB9O1xufVxuXG4vLyBjb25zdCBjbGVhblNlbGVjdG9yUmVnZXhwID0gL1xceyhcXHcrPVwiW15cIlxcbl0qP1wiKSgsXFx3Kz1cIlteXCJcXG5dKj9cIikqXFx9LztcbmV4cG9ydCBjb25zdCBzZWxlY3RvclJlZ2V4cCA9IC9cXHtbXn1dKj8oXFx9fCQpLztcbmV4cG9ydCBjb25zdCBsYWJlbFJlZ2V4cCA9IC9cXGIoXFx3KykoIT89fj8pKFwiW15cIlxcbl0qP1wiKS9nO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2VsZWN0b3IocXVlcnk6IHN0cmluZywgY3Vyc29yT2Zmc2V0ID0gMSk6IHsgbGFiZWxLZXlzOiBhbnlbXTsgc2VsZWN0b3I6IHN0cmluZyB9IHtcbiAgaWYgKCFxdWVyeS5tYXRjaChzZWxlY3RvclJlZ2V4cCkpIHtcbiAgICAvLyBTcGVjaWFsIG1hdGNoZXIgZm9yIG1ldHJpY3NcbiAgICBpZiAocXVlcnkubWF0Y2goL15bQS1aYS16Ol1bXFx3Ol0qJC8pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvcjogYHtfX25hbWVfXz1cIiR7cXVlcnl9XCJ9YCxcbiAgICAgICAgbGFiZWxLZXlzOiBbJ19fbmFtZV9fJ10sXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5IG11c3QgY29udGFpbiBhIHNlbGVjdG9yOiAnICsgcXVlcnkpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgaW5zaWRlIGEgc2VsZWN0b3JcbiAgY29uc3QgcHJlZml4ID0gcXVlcnkuc2xpY2UoMCwgY3Vyc29yT2Zmc2V0KTtcbiAgY29uc3QgcHJlZml4T3BlbiA9IHByZWZpeC5sYXN0SW5kZXhPZigneycpO1xuICBjb25zdCBwcmVmaXhDbG9zZSA9IHByZWZpeC5sYXN0SW5kZXhPZignfScpO1xuICBpZiAocHJlZml4T3BlbiA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbnNpZGUgc2VsZWN0b3IsIG1pc3Npbmcgb3BlbiBicmFjZTogJyArIHByZWZpeCk7XG4gIH1cbiAgaWYgKHByZWZpeENsb3NlID4gLTEgJiYgcHJlZml4Q2xvc2UgPiBwcmVmaXhPcGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW5zaWRlIHNlbGVjdG9yLCBwcmV2aW91cyBzZWxlY3RvciBhbHJlYWR5IGNsb3NlZDogJyArIHByZWZpeCk7XG4gIH1cbiAgY29uc3Qgc3VmZml4ID0gcXVlcnkuc2xpY2UoY3Vyc29yT2Zmc2V0KTtcbiAgY29uc3Qgc3VmZml4Q2xvc2VJbmRleCA9IHN1ZmZpeC5pbmRleE9mKCd9Jyk7XG4gIGNvbnN0IHN1ZmZpeENsb3NlID0gc3VmZml4Q2xvc2VJbmRleCArIGN1cnNvck9mZnNldDtcbiAgY29uc3Qgc3VmZml4T3BlbkluZGV4ID0gc3VmZml4LmluZGV4T2YoJ3snKTtcbiAgY29uc3Qgc3VmZml4T3BlbiA9IHN1ZmZpeE9wZW5JbmRleCArIGN1cnNvck9mZnNldDtcbiAgaWYgKHN1ZmZpeENsb3NlID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGluc2lkZSBzZWxlY3RvciwgbWlzc2luZyBjbG9zaW5nIGJyYWNlIGluIHN1ZmZpeDogJyArIHN1ZmZpeCk7XG4gIH1cbiAgaWYgKHN1ZmZpeE9wZW5JbmRleCA+IC0xICYmIHN1ZmZpeE9wZW4gPCBzdWZmaXhDbG9zZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGluc2lkZSBzZWxlY3RvciwgbmV4dCBzZWxlY3RvciBvcGVucyBiZWZvcmUgdGhpcyBvbmUgY2xvc2VkOiAnICsgc3VmZml4KTtcbiAgfVxuXG4gIC8vIEV4dHJhY3QgY2xlYW4gbGFiZWxzIHRvIGZvcm0gY2xlYW4gc2VsZWN0b3IsIGluY29tcGxldGUgbGFiZWxzIGFyZSBkcm9wcGVkXG4gIGNvbnN0IHNlbGVjdG9yID0gcXVlcnkuc2xpY2UocHJlZml4T3Blbiwgc3VmZml4Q2xvc2UpO1xuICBjb25zdCBsYWJlbHM6IHsgW2tleTogc3RyaW5nXTogeyB2YWx1ZTogc3RyaW5nOyBvcGVyYXRvcjogc3RyaW5nIH0gfSA9IHt9O1xuICBzZWxlY3Rvci5yZXBsYWNlKGxhYmVsUmVnZXhwLCAobGFiZWwsIGtleSwgb3BlcmF0b3IsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbGFiZWxPZmZzZXQgPSBxdWVyeS5pbmRleE9mKGxhYmVsKTtcbiAgICBjb25zdCB2YWx1ZVN0YXJ0ID0gbGFiZWxPZmZzZXQgKyBrZXkubGVuZ3RoICsgb3BlcmF0b3IubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZUVuZCA9IGxhYmVsT2Zmc2V0ICsga2V5Lmxlbmd0aCArIG9wZXJhdG9yLmxlbmd0aCArIHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgLy8gU2tpcCBsYWJlbCBpZiBjdXJzb3IgaXMgaW4gdmFsdWVcbiAgICBpZiAoY3Vyc29yT2Zmc2V0IDwgdmFsdWVTdGFydCB8fCBjdXJzb3JPZmZzZXQgPiB2YWx1ZUVuZCkge1xuICAgICAgbGFiZWxzW2tleV0gPSB7IHZhbHVlLCBvcGVyYXRvciB9O1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuXG4gIC8vIEFkZCBtZXRyaWMgaWYgdGhlcmUgaXMgb25lIGJlZm9yZSB0aGUgc2VsZWN0b3JcbiAgY29uc3QgbWV0cmljUHJlZml4ID0gcXVlcnkuc2xpY2UoMCwgcHJlZml4T3Blbik7XG4gIGNvbnN0IG1ldHJpY01hdGNoID0gbWV0cmljUHJlZml4Lm1hdGNoKC9bQS1aYS16Ol1bXFx3Ol0qJC8pO1xuICBpZiAobWV0cmljTWF0Y2gpIHtcbiAgICBsYWJlbHNbJ19fbmFtZV9fJ10gPSB7IHZhbHVlOiBgXCIke21ldHJpY01hdGNoWzBdfVwiYCwgb3BlcmF0b3I6ICc9JyB9O1xuICB9XG5cbiAgLy8gQnVpbGQgc29ydGVkIHNlbGVjdG9yXG4gIGNvbnN0IGxhYmVsS2V5cyA9IE9iamVjdC5rZXlzKGxhYmVscykuc29ydCgpO1xuICBjb25zdCBjbGVhblNlbGVjdG9yID0gbGFiZWxLZXlzLm1hcCgoa2V5KSA9PiBgJHtrZXl9JHtsYWJlbHNba2V5XS5vcGVyYXRvcn0ke2xhYmVsc1trZXldLnZhbHVlfWApLmpvaW4oJywnKTtcblxuICBjb25zdCBzZWxlY3RvclN0cmluZyA9IFsneycsIGNsZWFuU2VsZWN0b3IsICd9J10uam9pbignJyk7XG5cbiAgcmV0dXJuIHsgbGFiZWxLZXlzLCBzZWxlY3Rvcjogc2VsZWN0b3JTdHJpbmcgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFJlY29yZGluZ1J1bGVzKHF1ZXJ5OiBzdHJpbmcsIG1hcHBpbmc6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9KTogc3RyaW5nIHtcbiAgY29uc3QgcnVsZU5hbWVzID0gT2JqZWN0LmtleXMobWFwcGluZyk7XG4gIGNvbnN0IHJ1bGVzUmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXHN8XikoJHtydWxlTmFtZXMuam9pbignfCcpfSkoXFxcXHN8JHxcXFxcKHxcXFxcW3xcXFxceylgLCAnaWcnKTtcbiAgY29uc3QgZXhwYW5kZWRRdWVyeSA9IHF1ZXJ5LnJlcGxhY2UocnVsZXNSZWdleCwgKG1hdGNoLCBwcmUsIG5hbWUsIHBvc3QpID0+IGAke3ByZX0ke21hcHBpbmdbbmFtZV19JHtwb3N0fWApO1xuXG4gIC8vIFNwbGl0IHF1ZXJ5IGludG8gYXJyYXksIHNvIGlmIHF1ZXJ5IHVzZXMgb3BlcmF0b3JzLCB3ZSBjYW4gY29ycmVjdGx5IGFkZCBsYWJlbHMgdG8gZWFjaCBpbmRpdmlkdWFsIHBhcnQuXG4gIGNvbnN0IHF1ZXJ5QXJyYXkgPSBleHBhbmRlZFF1ZXJ5LnNwbGl0KC8oXFwrfFxcLXxcXCp8XFwvfFxcJXxcXF4pLyk7XG5cbiAgLy8gUmVnZXggdGhhdCBtYXRjaGVzIG9jY3VycmVuY2VzIG9mICl7IG9yIH17IG9yIF17IHdoaWNoIGlzIGEgc2lnbiBvZiBpbmNvcnJlY2x5IGFkZGVkIGxhYmVscy5cbiAgY29uc3QgaW52YWxpZExhYmVsc1JlZ2V4ID0gLyhcXClcXHt8XFx9XFx7fFxcXVxceykvO1xuICBjb25zdCBjb3JyZWN0bHlFeHBhbmRlZFF1ZXJ5QXJyYXkgPSBxdWVyeUFycmF5Lm1hcCgocXVlcnkpID0+IHtcbiAgICByZXR1cm4gYWRkTGFiZWxzVG9FeHByZXNzaW9uKHF1ZXJ5LCBpbnZhbGlkTGFiZWxzUmVnZXgpO1xuICB9KTtcblxuICByZXR1cm4gY29ycmVjdGx5RXhwYW5kZWRRdWVyeUFycmF5LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBhZGRMYWJlbHNUb0V4cHJlc3Npb24oZXhwcjogc3RyaW5nLCBpbnZhbGlkTGFiZWxzUmVnZXhwOiBSZWdFeHApIHtcbiAgY29uc3QgbWF0Y2ggPSBleHByLm1hdGNoKGludmFsaWRMYWJlbHNSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyBTcGxpdCBxdWVyeSBpbnRvIDIgcGFydHMgLSBiZWZvcmUgdGhlIGludmFsaWRMYWJlbHNSZWdleCBtYXRjaCBhbmQgYWZ0ZXIuXG4gIGNvbnN0IGluZGV4T2ZSZWdleE1hdGNoID0gbWF0Y2guaW5kZXggPz8gMDtcbiAgY29uc3QgZXhwckJlZm9yZVJlZ2V4TWF0Y2ggPSBleHByLnNsaWNlKDAsIGluZGV4T2ZSZWdleE1hdGNoICsgMSk7XG4gIGNvbnN0IGV4cHJBZnRlclJlZ2V4TWF0Y2ggPSBleHByLnNsaWNlKGluZGV4T2ZSZWdleE1hdGNoICsgMSk7XG5cbiAgLy8gQ3JlYXRlIGFycmF5T2ZMYWJlbE9iamVjdHMgd2l0aCBsYWJlbCBvYmplY3RzIHRoYXQgaGF2ZSBrZXksIG9wZXJhdG9yIGFuZCB2YWx1ZS5cbiAgY29uc3QgYXJyYXlPZkxhYmVsT2JqZWN0czogQXJyYXk8eyBrZXk6IHN0cmluZzsgb3BlcmF0b3I6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9PiA9IFtdO1xuICBleHByQWZ0ZXJSZWdleE1hdGNoLnJlcGxhY2UobGFiZWxSZWdleHAsIChsYWJlbCwga2V5LCBvcGVyYXRvciwgdmFsdWUpID0+IHtcbiAgICBhcnJheU9mTGFiZWxPYmplY3RzLnB1c2goeyBrZXksIG9wZXJhdG9yLCB2YWx1ZSB9KTtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuXG4gIC8vIExvb3AgdGhyb3VnaCBhbGwgbGFiZWwgb2JqZWN0cyBhbmQgYWRkIHRoZW0gdG8gcXVlcnkuXG4gIC8vIEFzIGEgc3RhcnRpbmcgcG9pbnQgd2UgaGF2ZSB2YWxpZCBxdWVyeSB3aXRob3V0IHRoZSBsYWJlbHMuXG4gIGxldCByZXN1bHQgPSBleHByQmVmb3JlUmVnZXhNYXRjaDtcbiAgYXJyYXlPZkxhYmVsT2JqZWN0cy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgob2JqKSA9PiB7XG4gICAgLy8gUmVtb3ZlIGV4dHJhIHNldCBvZiBxdW90ZXMgZnJvbSBvYmoudmFsdWVcbiAgICBjb25zdCB2YWx1ZSA9IG9iai52YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgcmVzdWx0ID0gYWRkTGFiZWxUb1F1ZXJ5KHJlc3VsdCwgb2JqLmtleSwgdmFsdWUsIG9iai5vcGVyYXRvcik7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQWRkcyBtZXRhZGF0YSBmb3Igc3ludGhldGljIG1ldHJpY3MgZm9yIHdoaWNoIHRoZSBBUEkgZG9lcyBub3QgcHJvdmlkZSBtZXRhZGF0YS5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JhZmFuYS9ncmFmYW5hL2lzc3Vlcy8yMjMzNyBmb3IgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0gbWV0YWRhdGEgSEVMUCBhbmQgVFlQRSBtZXRhZGF0YSBmcm9tIC9hcGkvdjEvbWV0YWRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeFN1bW1hcmllc01ldGFkYXRhKG1ldGFkYXRhOiB7IFttZXRyaWM6IHN0cmluZ106IFByb21NZXRyaWNzTWV0YWRhdGFJdGVtW10gfSk6IFByb21NZXRyaWNzTWV0YWRhdGEge1xuICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9XG4gIGNvbnN0IGJhc2VNZXRhZGF0YTogUHJvbU1ldHJpY3NNZXRhZGF0YSA9IHt9O1xuICBjb25zdCBzdW1tYXJ5TWV0YWRhdGE6IFByb21NZXRyaWNzTWV0YWRhdGEgPSB7fTtcbiAgZm9yIChjb25zdCBtZXRyaWMgaW4gbWV0YWRhdGEpIHtcbiAgICAvLyBOT1RFOiBiYXNlZCBvbiBwcm9tZXRoZXVzLWRvY3VtZW50YXRpb24sIHdlIGNhbiByZWNlaXZlXG4gICAgLy8gbXVsdGlwbGUgbWV0YWRhdGEtZW50cmllcyBmb3IgdGhlIGdpdmVuIG1ldHJpYywgaXQgc2VlbXNcbiAgICAvLyBpdCBoYXBwZW5zIHdoZW4gdGhlIHNhbWUgbWV0cmljIGlzIG9uIG11bHRpcGxlIHRhcmdldHNcbiAgICAvLyBhbmQgdGhlaXIgaGVscC10ZXh0IGRpZmZlcnNcbiAgICAvLyAoaHR0cHM6Ly9wcm9tZXRoZXVzLmlvL2RvY3MvcHJvbWV0aGV1cy9sYXRlc3QvcXVlcnlpbmcvYXBpLyNxdWVyeWluZy1tZXRyaWMtbWV0YWRhdGEpXG4gICAgLy8gZm9yIG5vdyB3ZSBqdXN0IHVzZSB0aGUgZmlyc3QgZW50cnkuXG4gICAgY29uc3QgaXRlbSA9IG1ldGFkYXRhW21ldHJpY11bMF07XG4gICAgYmFzZU1ldGFkYXRhW21ldHJpY10gPSBpdGVtO1xuXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2hpc3RvZ3JhbScpIHtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X2J1Y2tldGBdID0ge1xuICAgICAgICB0eXBlOiAnY291bnRlcicsXG4gICAgICAgIGhlbHA6IGBDdW11bGF0aXZlIGNvdW50ZXJzIGZvciB0aGUgb2JzZXJ2YXRpb24gYnVja2V0cyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fY291bnRgXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgQ291bnQgb2YgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIG9ic2VydmVkIGZvciB0aGUgaGlzdG9ncmFtIG1ldHJpYyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgICAgc3VtbWFyeU1ldGFkYXRhW2Ake21ldHJpY31fc3VtYF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYFRvdGFsIHN1bSBvZiBhbGwgb2JzZXJ2ZWQgdmFsdWVzIGZvciB0aGUgaGlzdG9ncmFtIG1ldHJpYyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXRlbS50eXBlID09PSAnc3VtbWFyeScpIHtcbiAgICAgIHN1bW1hcnlNZXRhZGF0YVtgJHttZXRyaWN9X2NvdW50YF0gPSB7XG4gICAgICAgIHR5cGU6ICdjb3VudGVyJyxcbiAgICAgICAgaGVscDogYENvdW50IG9mIGV2ZW50cyB0aGF0IGhhdmUgYmVlbiBvYnNlcnZlZCBmb3IgdGhlIGJhc2UgbWV0cmljICgke2l0ZW0uaGVscH0pYCxcbiAgICAgIH07XG4gICAgICBzdW1tYXJ5TWV0YWRhdGFbYCR7bWV0cmljfV9zdW1gXSA9IHtcbiAgICAgICAgdHlwZTogJ2NvdW50ZXInLFxuICAgICAgICBoZWxwOiBgVG90YWwgc3VtIG9mIGFsbCBvYnNlcnZlZCB2YWx1ZXMgZm9yIHRoZSBiYXNlIG1ldHJpYyAoJHtpdGVtLmhlbHB9KWAsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvLyBTeW50aGV0aWMgc2VyaWVzXG4gIGNvbnN0IHN5bnRoZXRpY01ldGFkYXRhOiBQcm9tTWV0cmljc01ldGFkYXRhID0ge307XG4gIHN5bnRoZXRpY01ldGFkYXRhWydBTEVSVFMnXSA9IHtcbiAgICB0eXBlOiAnY291bnRlcicsXG4gICAgaGVscDogJ1RpbWUgc2VyaWVzIHNob3dpbmcgcGVuZGluZyBhbmQgZmlyaW5nIGFsZXJ0cy4gVGhlIHNhbXBsZSB2YWx1ZSBpcyBzZXQgdG8gMSBhcyBsb25nIGFzIHRoZSBhbGVydCBpcyBpbiB0aGUgaW5kaWNhdGVkIGFjdGl2ZSAocGVuZGluZyBvciBmaXJpbmcpIHN0YXRlLicsXG4gIH07XG5cbiAgcmV0dXJuIHsgLi4uYmFzZU1ldGFkYXRhLCAuLi5zdW1tYXJ5TWV0YWRhdGEsIC4uLnN5bnRoZXRpY01ldGFkYXRhIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZE1zVG9NaW4obWlsbGlzZWNvbmRzOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gcm91bmRTZWNUb01pbihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kU2VjVG9NaW4oc2Vjb25kczogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbWl0U3VnZ2VzdGlvbnMoaXRlbXM6IHN0cmluZ1tdKSB7XG4gIHJldHVybiBpdGVtcy5zbGljZSgwLCBTVUdHRVNUSU9OU19MSU1JVCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMaW1pdEluZm8oaXRlbXM6IGFueVtdIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgcmV0dXJuIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+PSBTVUdHRVNUSU9OU19MSU1JVCA/IGAsIGxpbWl0ZWQgdG8gdGhlIGZpcnN0ICR7U1VHR0VTVElPTlNfTElNSVR9IHJlY2VpdmVkIGl0ZW1zYCA6ICcnO1xufVxuXG4vLyBOT1RFOiB0aGUgZm9sbG93aW5nIDIgZXhwb3J0ZWQgZnVuY3Rpb25zIGFyZSB2ZXJ5IHNpbWlsYXIgdG8gdGhlIHByb21ldGhldXMqRXNjYXBlXG4vLyBmdW5jdGlvbnMgaW4gZGF0YXNvdXJjZS50cywgYnV0IHRoZXkgYXJlIG5vdCBleGFjdGx5IHRoZSBzYW1lIGFsZ29yaXRobSwgYW5kIHdlIGZvdW5kXG4vLyBubyB3YXkgdG8gcmV1c2Ugb25lIGluIHRoZSBhbm90aGVyIG9yIHZpY2UgdmVyc2EuXG5cbi8vIFByb21ldGhldXMgcmVndWxhci1leHByZXNzaW9ucyB1c2UgdGhlIFJFMiBzeW50YXggKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvcmUyL3dpa2kvU3ludGF4KSxcbi8vIHNvIGV2ZXJ5IGNoYXJhY3RlciB0aGF0IG1hdGNoZXMgc29tZXRoaW5nIGluIHRoYXQgbGlzdCBoYXMgdG8gYmUgZXNjYXBlZC5cbi8vIHRoZSBsaXN0IG9mIG1ldGFjaGFyYWN0ZXJzIGlzOiAqKz8oKXxcXC5bXXt9XiRcbi8vIHdlIG1ha2UgYSBqYXZhc2NyaXB0IHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgdGhvc2UgY2hhcmFjdGVyczpcbmNvbnN0IFJFMl9NRVRBQ0hBUkFDVEVSUyA9IC9bKis/KCl8XFxcXC5cXFtcXF17fV4kXS9nO1xuZnVuY3Rpb24gZXNjYXBlUHJvbWV0aGV1c1JlZ2V4cCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoUkUyX01FVEFDSEFSQUNURVJTLCAnXFxcXCQmJyk7XG59XG5cbi8vIGJhc2VkIG9uIHRoZSBvcGVubWV0cmljcy1kb2N1bWVudGF0aW9uLCB0aGUgMyBzeW1ib2xzIHdlIGhhdmUgdG8gaGFuZGxlIGFyZTpcbi8vIC0gXFxuIC4uLiB0aGUgbmV3bGluZSBjaGFyYWN0ZXJcbi8vIC0gXFwgIC4uLiB0aGUgYmFja3NsYXNoIGNoYXJhY3RlclxuLy8gLSBcIiAgLi4uIHRoZSBkb3VibGUtcXVvdGUgY2hhcmFjdGVyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvcihsYWJlbFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gbGFiZWxWYWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVMYWJlbFZhbHVlSW5SZWdleFNlbGVjdG9yKGxhYmVsVmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBlc2NhcGVMYWJlbFZhbHVlSW5FeGFjdFNlbGVjdG9yKGVzY2FwZVByb21ldGhldXNSZWdleHAobGFiZWxWYWx1ZSkpO1xufVxuXG5jb25zdCBGcm9tUHJvbUxpa2VNYXA6IFJlY29yZDxzdHJpbmcsIEFic3RyYWN0TGFiZWxPcGVyYXRvcj4gPSB7XG4gICc9JzogQWJzdHJhY3RMYWJlbE9wZXJhdG9yLkVxdWFsLFxuICAnIT0nOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuTm90RXF1YWwsXG4gICc9fic6IEFic3RyYWN0TGFiZWxPcGVyYXRvci5FcXVhbFJlZ0V4LFxuICAnIX4nOiBBYnN0cmFjdExhYmVsT3BlcmF0b3IuTm90RXF1YWxSZWdFeCxcbn07XG5jb25zdCBUb1Byb21MaWtlTWFwOiBSZWNvcmQ8QWJzdHJhY3RMYWJlbE9wZXJhdG9yLCBzdHJpbmc+ID0gaW52ZXJ0KEZyb21Qcm9tTGlrZU1hcCkgYXMgUmVjb3JkPFxuICBBYnN0cmFjdExhYmVsT3BlcmF0b3IsXG4gIHN0cmluZ1xuPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvbUxpa2VFeHByKGxhYmVsQmFzZWRRdWVyeTogQWJzdHJhY3RRdWVyeSk6IHN0cmluZyB7XG4gIGNvbnN0IGV4cHIgPSBsYWJlbEJhc2VkUXVlcnkubGFiZWxNYXRjaGVyc1xuICAgIC5tYXAoKHNlbGVjdG9yOiBBYnN0cmFjdExhYmVsTWF0Y2hlcikgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBUb1Byb21MaWtlTWFwW3NlbGVjdG9yLm9wZXJhdG9yXTtcbiAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICByZXR1cm4gYCR7c2VsZWN0b3IubmFtZX0ke29wZXJhdG9yfVwiJHtzZWxlY3Rvci52YWx1ZX1cImA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKChlOiBzdHJpbmcpID0+IGUgIT09ICcnKVxuICAgIC5qb2luKCcsICcpO1xuXG4gIHJldHVybiBleHByID8gYHske2V4cHJ9fWAgOiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvbUxpa2VRdWVyeShsYWJlbEJhc2VkUXVlcnk6IEFic3RyYWN0UXVlcnkpOiBQcm9tTGlrZVF1ZXJ5IHtcbiAgcmV0dXJuIHtcbiAgICByZWZJZDogbGFiZWxCYXNlZFF1ZXJ5LnJlZklkLFxuICAgIGV4cHI6IHRvUHJvbUxpa2VFeHByKGxhYmVsQmFzZWRRdWVyeSksXG4gICAgcmFuZ2U6IHRydWUsXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUxpa2VRdWVyeSBleHRlbmRzIERhdGFRdWVyeSB7XG4gIGV4cHI6IHN0cmluZztcbiAgcmFuZ2U6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0TGFiZWxNYXRjaGVycyh0b2tlbnM6IEFycmF5PHN0cmluZyB8IFRva2VuPik6IEFic3RyYWN0TGFiZWxNYXRjaGVyW10ge1xuICBjb25zdCBsYWJlbE1hdGNoZXJzOiBBYnN0cmFjdExhYmVsTWF0Y2hlcltdID0gW107XG5cbiAgZm9yIChsZXQgcHJvcCBpbiB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zW3Byb3BdIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgIGxldCB0b2tlbjogVG9rZW4gPSB0b2tlbnNbcHJvcF0gYXMgVG9rZW47XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvbnRleHQtbGFiZWxzJykge1xuICAgICAgICBsZXQgbGFiZWxLZXkgPSAnJztcbiAgICAgICAgbGV0IGxhYmVsVmFsdWUgPSAnJztcbiAgICAgICAgbGV0IGxhYmVsT3BlcmF0b3IgPSAnJztcbiAgICAgICAgbGV0IGNvbnRlbnRUb2tlbnM6IGFueVtdID0gdG9rZW4uY29udGVudCBhcyBhbnlbXTtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudFRva2VuIGluIGNvbnRlbnRUb2tlbnMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3RyOiBzdHJpbmc7XG4gICAgICAgICAgICBjdXJyZW50U3RyID0gY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dIGFzIHN0cmluZztcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RyID09PSAnPScgfHwgY3VycmVudFN0ciA9PT0gJyE9JyB8fCBjdXJyZW50U3RyID09PSAnPX4nIHx8IGN1cnJlbnRTdHIgPT09ICchficpIHtcbiAgICAgICAgICAgICAgbGFiZWxPcGVyYXRvciA9IGN1cnJlbnRTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0gaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgc3dpdGNoIChjb250ZW50VG9rZW5zW2N1cnJlbnRUb2tlbl0udHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdsYWJlbC1rZXknOlxuICAgICAgICAgICAgICAgIGxhYmVsS2V5ID0gY29udGVudFRva2Vuc1tjdXJyZW50VG9rZW5dLmNvbnRlbnQgYXMgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdsYWJlbC12YWx1ZSc6XG4gICAgICAgICAgICAgICAgbGFiZWxWYWx1ZSA9IGNvbnRlbnRUb2tlbnNbY3VycmVudFRva2VuXS5jb250ZW50IGFzIHN0cmluZztcbiAgICAgICAgICAgICAgICBsYWJlbFZhbHVlID0gbGFiZWxWYWx1ZS5zdWJzdHJpbmcoMSwgbGFiZWxWYWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbENvbXBhcmF0b3IgPSBGcm9tUHJvbUxpa2VNYXBbbGFiZWxPcGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgICAgbGFiZWxNYXRjaGVycy5wdXNoKHsgbmFtZTogbGFiZWxLZXksIG9wZXJhdG9yOiBsYWJlbENvbXBhcmF0b3IsIHZhbHVlOiBsYWJlbFZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWxNYXRjaGVycztcbn1cbiIsImltcG9ydCB7IGNoYWluLCBtYXAgYXMgX21hcCwgdW5pcSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBsYXN0VmFsdWVGcm9tIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBNZXRyaWNGaW5kVmFsdWUsIFRpbWVSYW5nZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBQcm9tUXVlcnlSZXF1ZXN0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRUaW1lU3J2IH0gZnJvbSAnYXBwL2ZlYXR1cmVzL2Rhc2hib2FyZC9zZXJ2aWNlcy9UaW1lU3J2JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSB7XG4gIHJhbmdlOiBUaW1lUmFuZ2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZSwgcHJpdmF0ZSBxdWVyeTogc3RyaW5nKSB7XG4gICAgdGhpcy5kYXRhc291cmNlID0gZGF0YXNvdXJjZTtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy5yYW5nZSA9IGdldFRpbWVTcnYoKS50aW1lUmFuZ2UoKTtcbiAgfVxuXG4gIHByb2Nlc3MoKTogUHJvbWlzZTxNZXRyaWNGaW5kVmFsdWVbXT4ge1xuICAgIGNvbnN0IGxhYmVsTmFtZXNSZWdleCA9IC9ebGFiZWxfbmFtZXNcXChcXClcXHMqJC87XG4gICAgY29uc3QgbGFiZWxWYWx1ZXNSZWdleCA9IC9ebGFiZWxfdmFsdWVzXFwoKD86KC4rKSxcXHMqKT8oW2EtekEtWl9dW2EtekEtWjAtOV9dKilcXClcXHMqJC87XG4gICAgY29uc3QgbWV0cmljTmFtZXNSZWdleCA9IC9ebWV0cmljc1xcKCguKylcXClcXHMqJC87XG4gICAgY29uc3QgcXVlcnlSZXN1bHRSZWdleCA9IC9ecXVlcnlfcmVzdWx0XFwoKC4rKVxcKVxccyokLztcbiAgICBjb25zdCBsYWJlbE5hbWVzUXVlcnkgPSB0aGlzLnF1ZXJ5Lm1hdGNoKGxhYmVsTmFtZXNSZWdleCk7XG4gICAgaWYgKGxhYmVsTmFtZXNRdWVyeSkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWxOYW1lc1F1ZXJ5KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxWYWx1ZXNRdWVyeSA9IHRoaXMucXVlcnkubWF0Y2gobGFiZWxWYWx1ZXNSZWdleCk7XG4gICAgaWYgKGxhYmVsVmFsdWVzUXVlcnkpIHtcbiAgICAgIGlmIChsYWJlbFZhbHVlc1F1ZXJ5WzFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsVmFsdWVzUXVlcnkobGFiZWxWYWx1ZXNRdWVyeVsyXSwgbGFiZWxWYWx1ZXNRdWVyeVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFZhbHVlc1F1ZXJ5KGxhYmVsVmFsdWVzUXVlcnlbMl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1ldHJpY05hbWVzUXVlcnkgPSB0aGlzLnF1ZXJ5Lm1hdGNoKG1ldHJpY05hbWVzUmVnZXgpO1xuICAgIGlmIChtZXRyaWNOYW1lc1F1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXRyaWNOYW1lUXVlcnkobWV0cmljTmFtZXNRdWVyeVsxXSk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlSZXN1bHRRdWVyeSA9IHRoaXMucXVlcnkubWF0Y2gocXVlcnlSZXN1bHRSZWdleCk7XG4gICAgaWYgKHF1ZXJ5UmVzdWx0UXVlcnkpIHtcbiAgICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKHRoaXMucXVlcnlSZXN1bHRRdWVyeShxdWVyeVJlc3VsdFF1ZXJ5WzFdKSk7XG4gICAgfVxuXG4gICAgLy8gaWYgcXVlcnkgY29udGFpbnMgZnVsbCBtZXRyaWMgbmFtZSwgcmV0dXJuIG1ldHJpYyBuYW1lIGFuZCBsYWJlbCBsaXN0XG4gICAgcmV0dXJuIHRoaXMubWV0cmljTmFtZUFuZExhYmVsc1F1ZXJ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgbGFiZWxOYW1lc1F1ZXJ5KCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLnRvLCB0cnVlKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgIGVuZDogZW5kLnRvU3RyaW5nKCksXG4gICAgfTtcblxuICAgIGNvbnN0IHVybCA9IGAvYXBpL3YxL2xhYmVsc2A7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBfbWFwKHJlc3VsdC5kYXRhLmRhdGEsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiB2YWx1ZSB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBsYWJlbFZhbHVlc1F1ZXJ5KGxhYmVsOiBzdHJpbmcsIG1ldHJpYz86IHN0cmluZykge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRhc291cmNlLmdldFByb21ldGhldXNUaW1lKHRoaXMucmFuZ2UuZnJvbSwgZmFsc2UpO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLnRvLCB0cnVlKTtcblxuICAgIGxldCB1cmw6IHN0cmluZztcblxuICAgIGlmICghbWV0cmljKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydC50b1N0cmluZygpLFxuICAgICAgICBlbmQ6IGVuZC50b1N0cmluZygpLFxuICAgICAgfTtcbiAgICAgIC8vIHJldHVybiBsYWJlbCB2YWx1ZXMgZ2xvYmFsbHlcbiAgICAgIHVybCA9IGAvYXBpL3YxL2xhYmVsLyR7bGFiZWx9L3ZhbHVlc2A7XG5cbiAgICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gX21hcChyZXN1bHQuZGF0YS5kYXRhLCAodmFsdWUpID0+IHtcbiAgICAgICAgICByZXR1cm4geyB0ZXh0OiB2YWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICdtYXRjaFtdJzogbWV0cmljLFxuICAgICAgICBzdGFydDogc3RhcnQudG9TdHJpbmcoKSxcbiAgICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICB1cmwgPSBgL2FwaS92MS9zZXJpZXNgO1xuXG4gICAgICByZXR1cm4gdGhpcy5kYXRhc291cmNlLm1ldGFkYXRhUmVxdWVzdCh1cmwsIHBhcmFtcykudGhlbigocmVzdWx0OiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgX2xhYmVscyA9IF9tYXAocmVzdWx0LmRhdGEuZGF0YSwgKG1ldHJpYykgPT4ge1xuICAgICAgICAgIHJldHVybiBtZXRyaWNbbGFiZWxdIHx8ICcnO1xuICAgICAgICB9KS5maWx0ZXIoKGxhYmVsKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsICE9PSAnJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHVuaXEoX2xhYmVscykubWFwKChtZXRyaWMpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogbWV0cmljLFxuICAgICAgICAgICAgZXhwYW5kYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG1ldHJpY05hbWVRdWVyeShtZXRyaWNGaWx0ZXJQYXR0ZXJuOiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LnRvU3RyaW5nKCksXG4gICAgICBlbmQ6IGVuZC50b1N0cmluZygpLFxuICAgIH07XG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvbGFiZWwvX19uYW1lX18vdmFsdWVzYDtcblxuICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIGNoYWluKHJlc3VsdC5kYXRhLmRhdGEpXG4gICAgICAgIC5maWx0ZXIoKG1ldHJpY05hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gbmV3IFJlZ0V4cChtZXRyaWNGaWx0ZXJQYXR0ZXJuKTtcbiAgICAgICAgICByZXR1cm4gci50ZXN0KG1ldHJpY05hbWUpO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKChtYXRjaGVkTWV0cmljTmFtZSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaGVkTWV0cmljTmFtZSxcbiAgICAgICAgICAgIGV4cGFuZGFibGU6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLnZhbHVlKCk7XG4gICAgfSk7XG4gIH1cblxuICBxdWVyeVJlc3VsdFF1ZXJ5KHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgaW5zdGFudFF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0ID0geyBleHByOiBxdWVyeSB9IGFzIFByb21RdWVyeVJlcXVlc3Q7XG4gICAgcmV0dXJuIHRoaXMuZGF0YXNvdXJjZS5wZXJmb3JtSW5zdGFudFF1ZXJ5KGluc3RhbnRRdWVyeSwgZW5kKS5waXBlKFxuICAgICAgbWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmV0dXJuIF9tYXAocmVzdWx0LmRhdGEuZGF0YS5yZXN1bHQsIChtZXRyaWNEYXRhKSA9PiB7XG4gICAgICAgICAgbGV0IHRleHQgPSBtZXRyaWNEYXRhLm1ldHJpYy5fX25hbWVfXyB8fCAnJztcbiAgICAgICAgICBkZWxldGUgbWV0cmljRGF0YS5tZXRyaWMuX19uYW1lX187XG4gICAgICAgICAgdGV4dCArPVxuICAgICAgICAgICAgJ3snICtcbiAgICAgICAgICAgIF9tYXAobWV0cmljRGF0YS5tZXRyaWMsICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBrICsgJz1cIicgKyB2ICsgJ1wiJztcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKSArXG4gICAgICAgICAgICAnfSc7XG4gICAgICAgICAgdGV4dCArPSAnICcgKyBtZXRyaWNEYXRhLnZhbHVlWzFdICsgJyAnICsgbWV0cmljRGF0YS52YWx1ZVswXSAqIDEwMDA7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGV4cGFuZGFibGU6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBtZXRyaWNOYW1lQW5kTGFiZWxzUXVlcnkocXVlcnk6IHN0cmluZyk6IFByb21pc2U8TWV0cmljRmluZFZhbHVlW10+IHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZGF0YXNvdXJjZS5nZXRQcm9tZXRoZXVzVGltZSh0aGlzLnJhbmdlLmZyb20sIGZhbHNlKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmRhdGFzb3VyY2UuZ2V0UHJvbWV0aGV1c1RpbWUodGhpcy5yYW5nZS50bywgdHJ1ZSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgJ21hdGNoW10nOiBxdWVyeSxcbiAgICAgIHN0YXJ0OiBzdGFydC50b1N0cmluZygpLFxuICAgICAgZW5kOiBlbmQudG9TdHJpbmcoKSxcbiAgICB9O1xuXG4gICAgY29uc3QgdXJsID0gYC9hcGkvdjEvc2VyaWVzYDtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLmRhdGFzb3VyY2UubWV0YWRhdGFSZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIF9tYXAocmVzdWx0LmRhdGEuZGF0YSwgKG1ldHJpYzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRleHQ6IHNlbGYuZGF0YXNvdXJjZS5nZXRPcmlnaW5hbE1ldHJpY05hbWUobWV0cmljKSxcbiAgICAgICAgICBleHBhbmRhYmxlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGFTb3VyY2VQbHVnaW4gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEFOTk9UQVRJT05fUVVFUllfU1RFUF9ERUZBVUxULCBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5cbmltcG9ydCBQcm9tUXVlcnlFZGl0b3JCeUFwcCBmcm9tICcuL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RWRpdG9yQnlBcHAnO1xuaW1wb3J0IFByb21DaGVhdFNoZWV0IGZyb20gJy4vY29tcG9uZW50cy9Qcm9tQ2hlYXRTaGVldCc7XG5cbmltcG9ydCB7IENvbmZpZ0VkaXRvciB9IGZyb20gJy4vY29uZmlndXJhdGlvbi9Db25maWdFZGl0b3InO1xuXG5jbGFzcyBQcm9tZXRoZXVzQW5ub3RhdGlvbnNRdWVyeUN0cmwge1xuICBzdGF0aWMgdGVtcGxhdGVVcmwgPSAncGFydGlhbHMvYW5ub3RhdGlvbnMuZWRpdG9yLmh0bWwnO1xuICBzdGVwRGVmYXVsdFZhbHVlUGxhY2Vob2xkZXIgPSBBTk5PVEFUSU9OX1FVRVJZX1NURVBfREVGQVVMVDtcbn1cblxuZXhwb3J0IGNvbnN0IHBsdWdpbiA9IG5ldyBEYXRhU291cmNlUGx1Z2luKFByb21ldGhldXNEYXRhc291cmNlKVxuICAuc2V0UXVlcnlFZGl0b3IoUHJvbVF1ZXJ5RWRpdG9yQnlBcHApXG4gIC5zZXRDb25maWdFZGl0b3IoQ29uZmlnRWRpdG9yKVxuICAuc2V0QW5ub3RhdGlvblF1ZXJ5Q3RybChQcm9tZXRoZXVzQW5ub3RhdGlvbnNRdWVyeUN0cmwpXG4gIC5zZXRRdWVyeUVkaXRvckhlbHAoUHJvbUNoZWF0U2hlZXQpO1xuIiwiaW1wb3J0IHsgR3JhbW1hciB9IGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0IHsgQ29tcGxldGlvbkl0ZW0gfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5cbi8vIFdoZW4gY2hhbmdpbmcgUkFURV9SQU5HRVMsIGNoZWNrIGlmIExva2kvTG9nUUwgcmFuZ2VzIHNob3VsZCBiZSBjaGFuZ2VkIHRvb1xuLy8gQHNlZSBwdWJsaWMvYXBwL3BsdWdpbnMvZGF0YXNvdXJjZS9sb2tpL2xhbmd1YWdlX3Byb3ZpZGVyLnRzXG5leHBvcnQgY29uc3QgUkFURV9SQU5HRVM6IENvbXBsZXRpb25JdGVtW10gPSBbXG4gIHsgbGFiZWw6ICckX19pbnRlcnZhbCcsIHNvcnRWYWx1ZTogJyRfX2ludGVydmFsJyB9LFxuICB7IGxhYmVsOiAnJF9fcmF0ZV9pbnRlcnZhbCcsIHNvcnRWYWx1ZTogJyRfX3JhdGVfaW50ZXJ2YWwnIH0sXG4gIHsgbGFiZWw6ICckX19yYW5nZScsIHNvcnRWYWx1ZTogJyRfX3JhbmdlJyB9LFxuICB7IGxhYmVsOiAnMW0nLCBzb3J0VmFsdWU6ICcwMDowMTowMCcgfSxcbiAgeyBsYWJlbDogJzVtJywgc29ydFZhbHVlOiAnMDA6MDU6MDAnIH0sXG4gIHsgbGFiZWw6ICcxMG0nLCBzb3J0VmFsdWU6ICcwMDoxMDowMCcgfSxcbiAgeyBsYWJlbDogJzMwbScsIHNvcnRWYWx1ZTogJzAwOjMwOjAwJyB9LFxuICB7IGxhYmVsOiAnMWgnLCBzb3J0VmFsdWU6ICcwMTowMDowMCcgfSxcbiAgeyBsYWJlbDogJzFkJywgc29ydFZhbHVlOiAnMjQ6MDA6MDAnIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgT1BFUkFUT1JTID0gWydieScsICdncm91cF9sZWZ0JywgJ2dyb3VwX3JpZ2h0JywgJ2lnbm9yaW5nJywgJ29uJywgJ29mZnNldCcsICd3aXRob3V0J107XG5leHBvcnQgY29uc3QgTE9HSUNBTF9PUEVSQVRPUlMgPSBbJ29yJywgJ2FuZCcsICd1bmxlc3MnXTtcblxuY29uc3QgVFJJR09OT01FVFJJQ19GVU5DVElPTlM6IENvbXBsZXRpb25JdGVtW10gPSBbXG4gIHtcbiAgICBsYWJlbDogJ2Fjb3MnLFxuICAgIGluc2VydFRleHQ6ICdhY29zJyxcbiAgICBkZXRhaWw6ICdhY29zKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgYXJjY29zaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYWNvc2gnLFxuICAgIGluc2VydFRleHQ6ICdhY29zaCcsXG4gICAgZGV0YWlsOiAnYWNvc2godiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBpbnZlcnNlIGh5cGVyYm9saWMgY29zaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXNpbicsXG4gICAgaW5zZXJ0VGV4dDogJ2FzaW4nLFxuICAgIGRldGFpbDogJ2FzaW4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBhcmNzaW5lIG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnYXNpbmgnLFxuICAgIGluc2VydFRleHQ6ICdhc2luaCcsXG4gICAgZGV0YWlsOiAnYXNpbmgodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdjYWxjdWxhdGVzIHRoZSBpbnZlcnNlIGh5cGVyYm9saWMgc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2F0YW4nLFxuICAgIGluc2VydFRleHQ6ICdhdGFuJyxcbiAgICBkZXRhaWw6ICdhdGFuKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgYXJjdGFuZ2VudCBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2F0YW5oJyxcbiAgICBpbnNlcnRUZXh0OiAnYXRhbmgnLFxuICAgIGRldGFpbDogJ2F0YW5oKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdjb3MnLFxuICAgIGluc2VydFRleHQ6ICdjb3MnLFxuICAgIGRldGFpbDogJ2Nvcyh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGNvc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ2Nvc2gnLFxuICAgIGluc2VydFRleHQ6ICdjb3NoJyxcbiAgICBkZXRhaWw6ICdjb3NoKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzaW4nLFxuICAgIGluc2VydFRleHQ6ICdzaW4nLFxuICAgIGRldGFpbDogJ3Npbih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIHNpbmUgb2YgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzaW5oJyxcbiAgICBpbnNlcnRUZXh0OiAnc2luaCcsXG4gICAgZGV0YWlsOiAnc2luaCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ2NhbGN1bGF0ZXMgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3RhbicsXG4gICAgaW5zZXJ0VGV4dDogJ3RhbicsXG4gICAgZGV0YWlsOiAndGFuKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgdGFuZ2VudCBvZiBhbGwgZWxlbWVudHMgaW4gdicsXG4gIH0sXG4gIHtcbiAgICBsYWJlbDogJ3RhbmgnLFxuICAgIGluc2VydFRleHQ6ICd0YW5oJyxcbiAgICBkZXRhaWw6ICd0YW5oKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnY2FsY3VsYXRlcyB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGFsbCBlbGVtZW50cyBpbiB2JyxcbiAgfSxcbl07XG5cbmNvbnN0IEFHR1JFR0FUSU9OX09QRVJBVE9SUzogQ29tcGxldGlvbkl0ZW1bXSA9IFtcbiAge1xuICAgIGxhYmVsOiAnc3VtJyxcbiAgICBpbnNlcnRUZXh0OiAnc3VtJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIHN1bSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdtaW4nLFxuICAgIGluc2VydFRleHQ6ICdtaW4nLFxuICAgIGRvY3VtZW50YXRpb246ICdTZWxlY3QgbWluaW11bSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdtYXgnLFxuICAgIGluc2VydFRleHQ6ICdtYXgnLFxuICAgIGRvY3VtZW50YXRpb246ICdTZWxlY3QgbWF4aW11bSBvdmVyIGRpbWVuc2lvbnMnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdhdmcnLFxuICAgIGluc2VydFRleHQ6ICdhdmcnLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgdGhlIGF2ZXJhZ2Ugb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnZ3JvdXAnLFxuICAgIGluc2VydFRleHQ6ICdncm91cCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0FsbCB2YWx1ZXMgaW4gdGhlIHJlc3VsdGluZyB2ZWN0b3IgYXJlIDEnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdzdGRkZXYnLFxuICAgIGluc2VydFRleHQ6ICdzdGRkZXYnLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGUgcG9wdWxhdGlvbiBzdGFuZGFyZCBkZXZpYXRpb24gb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnc3RkdmFyJyxcbiAgICBpbnNlcnRUZXh0OiAnc3RkdmFyJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2FsY3VsYXRlIHBvcHVsYXRpb24gc3RhbmRhcmQgdmFyaWFuY2Ugb3ZlciBkaW1lbnNpb25zJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY291bnQnLFxuICAgIGluc2VydFRleHQ6ICdjb3VudCcsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NvdW50IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdmVjdG9yJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAnY291bnRfdmFsdWVzJyxcbiAgICBpbnNlcnRUZXh0OiAnY291bnRfdmFsdWVzJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ291bnQgbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgdmFsdWUnLFxuICB9LFxuICB7XG4gICAgbGFiZWw6ICdib3R0b21rJyxcbiAgICBpbnNlcnRUZXh0OiAnYm90dG9taycsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1NtYWxsZXN0IGsgZWxlbWVudHMgYnkgc2FtcGxlIHZhbHVlJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAndG9waycsXG4gICAgaW5zZXJ0VGV4dDogJ3RvcGsnLFxuICAgIGRvY3VtZW50YXRpb246ICdMYXJnZXN0IGsgZWxlbWVudHMgYnkgc2FtcGxlIHZhbHVlJyxcbiAgfSxcbiAge1xuICAgIGxhYmVsOiAncXVhbnRpbGUnLFxuICAgIGluc2VydFRleHQ6ICdxdWFudGlsZScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NhbGN1bGF0ZSDPhi1xdWFudGlsZSAoMCDiiaQgz4Yg4omkIDEpIG92ZXIgZGltZW5zaW9ucycsXG4gIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgRlVOQ1RJT05TID0gW1xuICAuLi5BR0dSRUdBVElPTl9PUEVSQVRPUlMsXG4gIC4uLlRSSUdPTk9NRVRSSUNfRlVOQ1RJT05TLFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2FicycsXG4gICAgbGFiZWw6ICdhYnMnLFxuICAgIGRldGFpbDogJ2Ficyh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdGhlIGlucHV0IHZlY3RvciB3aXRoIGFsbCBzYW1wbGUgdmFsdWVzIGNvbnZlcnRlZCB0byB0aGVpciBhYnNvbHV0ZSB2YWx1ZS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2Fic2VudCcsXG4gICAgbGFiZWw6ICdhYnNlbnQnLFxuICAgIGRldGFpbDogJ2Fic2VudCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIGFuIGVtcHR5IHZlY3RvciBpZiB0aGUgdmVjdG9yIHBhc3NlZCB0byBpdCBoYXMgYW55IGVsZW1lbnRzIGFuZCBhIDEtZWxlbWVudCB2ZWN0b3Igd2l0aCB0aGUgdmFsdWUgMSBpZiB0aGUgdmVjdG9yIHBhc3NlZCB0byBpdCBoYXMgbm8gZWxlbWVudHMuIFRoaXMgaXMgdXNlZnVsIGZvciBhbGVydGluZyBvbiB3aGVuIG5vIHRpbWUgc2VyaWVzIGV4aXN0IGZvciBhIGdpdmVuIG1ldHJpYyBuYW1lIGFuZCBsYWJlbCBjb21iaW5hdGlvbi4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2Fic2VudF9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnYWJzZW50X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnYWJzZW50KHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIGFuIGVtcHR5IHZlY3RvciBpZiB0aGUgcmFuZ2UgdmVjdG9yIHBhc3NlZCB0byBpdCBoYXMgYW55IGVsZW1lbnRzIGFuZCBhIDEtZWxlbWVudCB2ZWN0b3Igd2l0aCB0aGUgdmFsdWUgMSBpZiB0aGUgcmFuZ2UgdmVjdG9yIHBhc3NlZCB0byBpdCBoYXMgbm8gZWxlbWVudHMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdjZWlsJyxcbiAgICBsYWJlbDogJ2NlaWwnLFxuICAgIGRldGFpbDogJ2NlaWwodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSb3VuZHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCB1cCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2hhbmdlcycsXG4gICAgbGFiZWw6ICdjaGFuZ2VzJyxcbiAgICBkZXRhaWw6ICdjaGFuZ2VzKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdGb3IgZWFjaCBpbnB1dCB0aW1lIHNlcmllcywgYGNoYW5nZXModiByYW5nZS12ZWN0b3IpYCByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGltZXMgaXRzIHZhbHVlIGhhcyBjaGFuZ2VkIHdpdGhpbiB0aGUgcHJvdmlkZWQgdGltZSByYW5nZSBhcyBhbiBpbnN0YW50IHZlY3Rvci4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NsYW1wJyxcbiAgICBsYWJlbDogJ2NsYW1wJyxcbiAgICBkZXRhaWw6ICdjbGFtcCh2IGluc3RhbnQtdmVjdG9yLCBtaW4gc2NhbGFyLCBtYXggc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDbGFtcHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCB0byBoYXZlIGEgbG93ZXIgbGltaXQgb2YgYG1pbmAgYW5kIGFuIHVwcGVyIGxpbWl0IG9mIGBtYXhgLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnY2xhbXBfbWF4JyxcbiAgICBsYWJlbDogJ2NsYW1wX21heCcsXG4gICAgZGV0YWlsOiAnY2xhbXBfbWF4KHYgaW5zdGFudC12ZWN0b3IsIG1heCBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnQ2xhbXBzIHRoZSBzYW1wbGUgdmFsdWVzIG9mIGFsbCBlbGVtZW50cyBpbiBgdmAgdG8gaGF2ZSBhbiB1cHBlciBsaW1pdCBvZiBgbWF4YC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NsYW1wX21pbicsXG4gICAgbGFiZWw6ICdjbGFtcF9taW4nLFxuICAgIGRldGFpbDogJ2NsYW1wX21pbih2IGluc3RhbnQtdmVjdG9yLCBtaW4gc2NhbGFyKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NsYW1wcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHRvIGhhdmUgYSBsb3dlciBsaW1pdCBvZiBgbWluYC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50X3NjYWxhcicsXG4gICAgbGFiZWw6ICdjb3VudF9zY2FsYXInLFxuICAgIGRldGFpbDogJ2NvdW50X3NjYWxhcih2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSB0aW1lIHNlcmllcyB2ZWN0b3IgYXMgYSBzY2FsYXIuIFRoaXMgaXMgaW4gY29udHJhc3QgdG8gdGhlIGBjb3VudCgpYCBhZ2dyZWdhdGlvbiBvcGVyYXRvciwgd2hpY2ggYWx3YXlzIHJldHVybnMgYSB2ZWN0b3IgKGFuIGVtcHR5IG9uZSBpZiB0aGUgaW5wdXQgdmVjdG9yIGlzIGVtcHR5KSBhbmQgYWxsb3dzIGdyb3VwaW5nIGJ5IGxhYmVscyB2aWEgYSBgYnlgIGNsYXVzZS4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RlZycsXG4gICAgbGFiZWw6ICdkZWcnLFxuICAgIGRldGFpbDogJ2RlZyh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NvbnZlcnRzIHJhZGlhbnMgdG8gZGVncmVlcyBmb3IgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RheV9vZl9tb250aCcsXG4gICAgbGFiZWw6ICdkYXlfb2ZfbW9udGgnLFxuICAgIGRldGFpbDogJ2RheV9vZl9tb250aCh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgdGhlIGRheSBvZiB0aGUgbW9udGggZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDEgdG8gMzEuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkYXlfb2Zfd2VlaycsXG4gICAgbGFiZWw6ICdkYXlfb2Zfd2VlaycsXG4gICAgZGV0YWlsOiAnZGF5X29mX3dlZWsodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyB0aGUgZGF5IG9mIHRoZSB3ZWVrIGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAwIHRvIDYsIHdoZXJlIDAgbWVhbnMgU3VuZGF5IGV0Yy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2RheXNfaW5fbW9udGgnLFxuICAgIGxhYmVsOiAnZGF5c19pbl9tb250aCcsXG4gICAgZGV0YWlsOiAnZGF5c19pbl9tb250aCh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aCBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLiBSZXR1cm5lZCB2YWx1ZXMgYXJlIGZyb20gMjggdG8gMzEuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdkZWx0YScsXG4gICAgbGFiZWw6ICdkZWx0YScsXG4gICAgZGV0YWlsOiAnZGVsdGEodiByYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3QgdmFsdWUgb2YgZWFjaCB0aW1lIHNlcmllcyBlbGVtZW50IGluIGEgcmFuZ2UgdmVjdG9yIGB2YCwgcmV0dXJuaW5nIGFuIGluc3RhbnQgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGRlbHRhcyBhbmQgZXF1aXZhbGVudCBsYWJlbHMuIFRoZSBkZWx0YSBpcyBleHRyYXBvbGF0ZWQgdG8gY292ZXIgdGhlIGZ1bGwgdGltZSByYW5nZSBhcyBzcGVjaWZpZWQgaW4gdGhlIHJhbmdlIHZlY3RvciBzZWxlY3Rvciwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBnZXQgYSBub24taW50ZWdlciByZXN1bHQgZXZlbiBpZiB0aGUgc2FtcGxlIHZhbHVlcyBhcmUgYWxsIGludGVnZXJzLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZGVyaXYnLFxuICAgIGxhYmVsOiAnZGVyaXYnLFxuICAgIGRldGFpbDogJ2Rlcml2KHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBwZXItc2Vjb25kIGRlcml2YXRpdmUgb2YgdGhlIHRpbWUgc2VyaWVzIGluIGEgcmFuZ2UgdmVjdG9yIGB2YCwgdXNpbmcgc2ltcGxlIGxpbmVhciByZWdyZXNzaW9uLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnZHJvcF9jb21tb25fbGFiZWxzJyxcbiAgICBsYWJlbDogJ2Ryb3BfY29tbW9uX2xhYmVscycsXG4gICAgZGV0YWlsOiAnZHJvcF9jb21tb25fbGFiZWxzKGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0Ryb3BzIGFsbCBsYWJlbHMgdGhhdCBoYXZlIHRoZSBzYW1lIG5hbWUgYW5kIHZhbHVlIGFjcm9zcyBhbGwgc2VyaWVzIGluIHRoZSBpbnB1dCB2ZWN0b3IuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdleHAnLFxuICAgIGxhYmVsOiAnZXhwJyxcbiAgICBkZXRhaWw6ICdleHAodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgZXhwb25lbnRpYWwgZnVuY3Rpb24gZm9yIGFsbCBlbGVtZW50cyBpbiBgdmAuXFxuU3BlY2lhbCBjYXNlcyBhcmU6XFxuKiBgRXhwKCtJbmYpID0gK0luZmAgXFxuKiBgRXhwKE5hTikgPSBOYU5gJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdmbG9vcicsXG4gICAgbGFiZWw6ICdmbG9vcicsXG4gICAgZGV0YWlsOiAnZmxvb3IodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSb3VuZHMgdGhlIHNhbXBsZSB2YWx1ZXMgb2YgYWxsIGVsZW1lbnRzIGluIGB2YCBkb3duIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLFxuICAgIGxhYmVsOiAnaGlzdG9ncmFtX3F1YW50aWxlJyxcbiAgICBkZXRhaWw6ICdoaXN0b2dyYW1fcXVhbnRpbGUoz4YgZmxvYXQsIGIgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ0NhbGN1bGF0ZXMgdGhlIM+GLXF1YW50aWxlICgwIOKJpCDPhiDiiaQgMSkgZnJvbSB0aGUgYnVja2V0cyBgYmAgb2YgYSBoaXN0b2dyYW0uIFRoZSBzYW1wbGVzIGluIGBiYCBhcmUgdGhlIGNvdW50cyBvZiBvYnNlcnZhdGlvbnMgaW4gZWFjaCBidWNrZXQuIEVhY2ggc2FtcGxlIG11c3QgaGF2ZSBhIGxhYmVsIGBsZWAgd2hlcmUgdGhlIGxhYmVsIHZhbHVlIGRlbm90ZXMgdGhlIGluY2x1c2l2ZSB1cHBlciBib3VuZCBvZiB0aGUgYnVja2V0LiAoU2FtcGxlcyB3aXRob3V0IHN1Y2ggYSBsYWJlbCBhcmUgc2lsZW50bHkgaWdub3JlZC4pIFRoZSBoaXN0b2dyYW0gbWV0cmljIHR5cGUgYXV0b21hdGljYWxseSBwcm92aWRlcyB0aW1lIHNlcmllcyB3aXRoIHRoZSBgX2J1Y2tldGAgc3VmZml4IGFuZCB0aGUgYXBwcm9wcmlhdGUgbGFiZWxzLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnaG9sdF93aW50ZXJzJyxcbiAgICBsYWJlbDogJ2hvbHRfd2ludGVycycsXG4gICAgZGV0YWlsOiAnaG9sdF93aW50ZXJzKHYgcmFuZ2UtdmVjdG9yLCBzZiBzY2FsYXIsIHRmIHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUHJvZHVjZXMgYSBzbW9vdGhlZCB2YWx1ZSBmb3IgdGltZSBzZXJpZXMgYmFzZWQgb24gdGhlIHJhbmdlIGluIGB2YC4gVGhlIGxvd2VyIHRoZSBzbW9vdGhpbmcgZmFjdG9yIGBzZmAsIHRoZSBtb3JlIGltcG9ydGFuY2UgaXMgZ2l2ZW4gdG8gb2xkIGRhdGEuIFRoZSBoaWdoZXIgdGhlIHRyZW5kIGZhY3RvciBgdGZgLCB0aGUgbW9yZSB0cmVuZHMgaW4gdGhlIGRhdGEgaXMgY29uc2lkZXJlZC4gQm90aCBgc2ZgIGFuZCBgdGZgIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnaG91cicsXG4gICAgbGFiZWw6ICdob3VyJyxcbiAgICBkZXRhaWw6ICdob3VyKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgaG91ciBvZiB0aGUgZGF5IGZvciBlYWNoIG9mIHRoZSBnaXZlbiB0aW1lcyBpbiBVVEMuIFJldHVybmVkIHZhbHVlcyBhcmUgZnJvbSAwIHRvIDIzLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnaWRlbHRhJyxcbiAgICBsYWJlbDogJ2lkZWx0YScsXG4gICAgZGV0YWlsOiAnaWRlbHRhKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGxhc3QgdHdvIHNhbXBsZXMgaW4gdGhlIHJhbmdlIHZlY3RvciBgdmAsIHJldHVybmluZyBhbiBpbnN0YW50IHZlY3RvciB3aXRoIHRoZSBnaXZlbiBkZWx0YXMgYW5kIGVxdWl2YWxlbnQgbGFiZWxzLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnaW5jcmVhc2UnLFxuICAgIGxhYmVsOiAnaW5jcmVhc2UnLFxuICAgIGRldGFpbDogJ2luY3JlYXNlKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBpbmNyZWFzZSBpbiB0aGUgdGltZSBzZXJpZXMgaW4gdGhlIHJhbmdlIHZlY3Rvci4gQnJlYWtzIGluIG1vbm90b25pY2l0eSAoc3VjaCBhcyBjb3VudGVyIHJlc2V0cyBkdWUgdG8gdGFyZ2V0IHJlc3RhcnRzKSBhcmUgYXV0b21hdGljYWxseSBhZGp1c3RlZCBmb3IuIFRoZSBpbmNyZWFzZSBpcyBleHRyYXBvbGF0ZWQgdG8gY292ZXIgdGhlIGZ1bGwgdGltZSByYW5nZSBhcyBzcGVjaWZpZWQgaW4gdGhlIHJhbmdlIHZlY3RvciBzZWxlY3Rvciwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBnZXQgYSBub24taW50ZWdlciByZXN1bHQgZXZlbiBpZiBhIGNvdW50ZXIgaW5jcmVhc2VzIG9ubHkgYnkgaW50ZWdlciBpbmNyZW1lbnRzLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnaXJhdGUnLFxuICAgIGxhYmVsOiAnaXJhdGUnLFxuICAgIGRldGFpbDogJ2lyYXRlKHYgcmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBwZXItc2Vjb25kIGluc3RhbnQgcmF0ZSBvZiBpbmNyZWFzZSBvZiB0aGUgdGltZSBzZXJpZXMgaW4gdGhlIHJhbmdlIHZlY3Rvci4gVGhpcyBpcyBiYXNlZCBvbiB0aGUgbGFzdCB0d28gZGF0YSBwb2ludHMuIEJyZWFrcyBpbiBtb25vdG9uaWNpdHkgKHN1Y2ggYXMgY291bnRlciByZXNldHMgZHVlIHRvIHRhcmdldCByZXN0YXJ0cykgYXJlIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgZm9yLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnbGFiZWxfam9pbicsXG4gICAgbGFiZWw6ICdsYWJlbF9qb2luJyxcbiAgICBkZXRhaWw6XG4gICAgICAnbGFiZWxfam9pbih2IGluc3RhbnQtdmVjdG9yLCBkc3RfbGFiZWwgc3RyaW5nLCBzZXBhcmF0b3Igc3RyaW5nLCBzcmNfbGFiZWxfMSBzdHJpbmcsIHNyY19sYWJlbF8yIHN0cmluZywgLi4uKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdGb3IgZWFjaCB0aW1lc2VyaWVzIGluIGB2YCwgam9pbnMgYWxsIHRoZSB2YWx1ZXMgb2YgYWxsIHRoZSBgc3JjX2xhYmVsc2AgdXNpbmcgYHNlcGFyYXRvcmAgYW5kIHJldHVybnMgdGhlIHRpbWVzZXJpZXMgd2l0aCB0aGUgbGFiZWwgYGRzdF9sYWJlbGAgY29udGFpbmluZyB0aGUgam9pbmVkIHZhbHVlLiBUaGVyZSBjYW4gYmUgYW55IG51bWJlciBvZiBgc3JjX2xhYmVsc2AgaW4gdGhpcyBmdW5jdGlvbi4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xhYmVsX3JlcGxhY2UnLFxuICAgIGxhYmVsOiAnbGFiZWxfcmVwbGFjZScsXG4gICAgZGV0YWlsOiAnbGFiZWxfcmVwbGFjZSh2IGluc3RhbnQtdmVjdG9yLCBkc3RfbGFiZWwgc3RyaW5nLCByZXBsYWNlbWVudCBzdHJpbmcsIHNyY19sYWJlbCBzdHJpbmcsIHJlZ2V4IHN0cmluZyknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICBcIkZvciBlYWNoIHRpbWVzZXJpZXMgaW4gYHZgLCBgbGFiZWxfcmVwbGFjZSh2IGluc3RhbnQtdmVjdG9yLCBkc3RfbGFiZWwgc3RyaW5nLCByZXBsYWNlbWVudCBzdHJpbmcsIHNyY19sYWJlbCBzdHJpbmcsIHJlZ2V4IHN0cmluZylgICBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4YCBhZ2FpbnN0IHRoZSBsYWJlbCBgc3JjX2xhYmVsYC4gIElmIGl0IG1hdGNoZXMsIHRoZW4gdGhlIHRpbWVzZXJpZXMgaXMgcmV0dXJuZWQgd2l0aCB0aGUgbGFiZWwgYGRzdF9sYWJlbGAgcmVwbGFjZWQgYnkgdGhlIGV4cGFuc2lvbiBvZiBgcmVwbGFjZW1lbnRgLiBgJDFgIGlzIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0IG1hdGNoaW5nIHN1Ymdyb3VwLCBgJDJgIHdpdGggdGhlIHNlY29uZCBldGMuIElmIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZG9lc24ndCBtYXRjaCB0aGVuIHRoZSB0aW1lc2VyaWVzIGlzIHJldHVybmVkIHVuY2hhbmdlZC5cIixcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsbicsXG4gICAgbGFiZWw6ICdsbicsXG4gICAgZGV0YWlsOiAnbG4odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gZm9yIGFsbCBlbGVtZW50cyBpbiBgdmAuXFxuU3BlY2lhbCBjYXNlcyBhcmU6XFxuICogYGxuKCtJbmYpID0gK0luZmBcXG4gKiBgbG4oMCkgPSAtSW5mYFxcbiAqIGBsbih4IDwgMCkgPSBOYU5gXFxuICogYGxuKE5hTikgPSBOYU5gJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdsb2cyJyxcbiAgICBsYWJlbDogJ2xvZzInLFxuICAgIGRldGFpbDogJ2xvZzIodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnQ2FsY3VsYXRlcyB0aGUgYmluYXJ5IGxvZ2FyaXRobSBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC4gVGhlIHNwZWNpYWwgY2FzZXMgYXJlIGVxdWl2YWxlbnQgdG8gdGhvc2UgaW4gYGxuYC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xvZzEwJyxcbiAgICBsYWJlbDogJ2xvZzEwJyxcbiAgICBkZXRhaWw6ICdsb2cxMCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDYWxjdWxhdGVzIHRoZSBkZWNpbWFsIGxvZ2FyaXRobSBmb3IgYWxsIGVsZW1lbnRzIGluIGB2YC4gVGhlIHNwZWNpYWwgY2FzZXMgYXJlIGVxdWl2YWxlbnQgdG8gdGhvc2UgaW4gYGxuYC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21pbnV0ZScsXG4gICAgbGFiZWw6ICdtaW51dGUnLFxuICAgIGRldGFpbDogJ21pbnV0ZSh2PXZlY3Rvcih0aW1lKCkpIGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdSZXR1cm5zIHRoZSBtaW51dGUgb2YgdGhlIGhvdXIgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDAgdG8gNTkuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdtb250aCcsXG4gICAgbGFiZWw6ICdtb250aCcsXG4gICAgZGV0YWlsOiAnbW9udGgodj12ZWN0b3IodGltZSgpKSBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyB0aGUgbW9udGggb2YgdGhlIHllYXIgZm9yIGVhY2ggb2YgdGhlIGdpdmVuIHRpbWVzIGluIFVUQy4gUmV0dXJuZWQgdmFsdWVzIGFyZSBmcm9tIDEgdG8gMTIsIHdoZXJlIDEgbWVhbnMgSmFudWFyeSBldGMuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdwaScsXG4gICAgbGFiZWw6ICdwaScsXG4gICAgZGV0YWlsOiAncGkoKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1JldHVybnMgcGknLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3ByZWRpY3RfbGluZWFyJyxcbiAgICBsYWJlbDogJ3ByZWRpY3RfbGluZWFyJyxcbiAgICBkZXRhaWw6ICdwcmVkaWN0X2xpbmVhcih2IHJhbmdlLXZlY3RvciwgdCBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1ByZWRpY3RzIHRoZSB2YWx1ZSBvZiB0aW1lIHNlcmllcyBgdGAgc2Vjb25kcyBmcm9tIG5vdywgYmFzZWQgb24gdGhlIHJhbmdlIHZlY3RvciBgdmAsIHVzaW5nIHNpbXBsZSBsaW5lYXIgcmVncmVzc2lvbi4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3JhZCcsXG4gICAgbGFiZWw6ICdyYWQnLFxuICAgIGRldGFpbDogJ3JhZCh2IGluc3RhbnQtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ0NvbnZlcnRzIGRlZ3JlZXMgdG8gcmFkaWFucyBmb3IgYWxsIGVsZW1lbnRzIGluIHYnLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3JhdGUnLFxuICAgIGxhYmVsOiAncmF0ZScsXG4gICAgZGV0YWlsOiAncmF0ZSh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICBcIkNhbGN1bGF0ZXMgdGhlIHBlci1zZWNvbmQgYXZlcmFnZSByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSB0aW1lIHNlcmllcyBpbiB0aGUgcmFuZ2UgdmVjdG9yLiBCcmVha3MgaW4gbW9ub3RvbmljaXR5IChzdWNoIGFzIGNvdW50ZXIgcmVzZXRzIGR1ZSB0byB0YXJnZXQgcmVzdGFydHMpIGFyZSBhdXRvbWF0aWNhbGx5IGFkanVzdGVkIGZvci4gQWxzbywgdGhlIGNhbGN1bGF0aW9uIGV4dHJhcG9sYXRlcyB0byB0aGUgZW5kcyBvZiB0aGUgdGltZSByYW5nZSwgYWxsb3dpbmcgZm9yIG1pc3NlZCBzY3JhcGVzIG9yIGltcGVyZmVjdCBhbGlnbm1lbnQgb2Ygc2NyYXBlIGN5Y2xlcyB3aXRoIHRoZSByYW5nZSdzIHRpbWUgcGVyaW9kLlwiLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3Jlc2V0cycsXG4gICAgbGFiZWw6ICdyZXNldHMnLFxuICAgIGRldGFpbDogJ3Jlc2V0cyh2IHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnRm9yIGVhY2ggaW5wdXQgdGltZSBzZXJpZXMsIGByZXNldHModiByYW5nZS12ZWN0b3IpYCByZXR1cm5zIHRoZSBudW1iZXIgb2YgY291bnRlciByZXNldHMgd2l0aGluIHRoZSBwcm92aWRlZCB0aW1lIHJhbmdlIGFzIGFuIGluc3RhbnQgdmVjdG9yLiBBbnkgZGVjcmVhc2UgaW4gdGhlIHZhbHVlIGJldHdlZW4gdHdvIGNvbnNlY3V0aXZlIHNhbXBsZXMgaXMgaW50ZXJwcmV0ZWQgYXMgYSBjb3VudGVyIHJlc2V0LicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAncm91bmQnLFxuICAgIGxhYmVsOiAncm91bmQnLFxuICAgIGRldGFpbDogJ3JvdW5kKHYgaW5zdGFudC12ZWN0b3IsIHRvX25lYXJlc3Q9MSBzY2FsYXIpJyxcbiAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgJ1JvdW5kcyB0aGUgc2FtcGxlIHZhbHVlcyBvZiBhbGwgZWxlbWVudHMgaW4gYHZgIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuIFRpZXMgYXJlIHJlc29sdmVkIGJ5IHJvdW5kaW5nIHVwLiBUaGUgb3B0aW9uYWwgYHRvX25lYXJlc3RgIGFyZ3VtZW50IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBuZWFyZXN0IG11bHRpcGxlIHRvIHdoaWNoIHRoZSBzYW1wbGUgdmFsdWVzIHNob3VsZCBiZSByb3VuZGVkLiBUaGlzIG11bHRpcGxlIG1heSBhbHNvIGJlIGEgZnJhY3Rpb24uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzY2FsYXInLFxuICAgIGxhYmVsOiAnc2NhbGFyJyxcbiAgICBkZXRhaWw6ICdzY2FsYXIodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnR2l2ZW4gYSBzaW5nbGUtZWxlbWVudCBpbnB1dCB2ZWN0b3IsIGBzY2FsYXIodiBpbnN0YW50LXZlY3RvcilgIHJldHVybnMgdGhlIHNhbXBsZSB2YWx1ZSBvZiB0aGF0IHNpbmdsZSBlbGVtZW50IGFzIGEgc2NhbGFyLiBJZiB0aGUgaW5wdXQgdmVjdG9yIGRvZXMgbm90IGhhdmUgZXhhY3RseSBvbmUgZWxlbWVudCwgYHNjYWxhcmAgd2lsbCByZXR1cm4gYE5hTmAuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzZ24nLFxuICAgIGxhYmVsOiAnc2duJyxcbiAgICBkZXRhaWw6ICdzZ24odiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyBhIHZlY3RvciB3aXRoIGFsbCBzYW1wbGUgdmFsdWVzIGNvbnZlcnRlZCB0byB0aGVpciBzaWduLCBkZWZpbmVkIGFzIHRoaXM6IDEgaWYgdiBpcyBwb3NpdGl2ZSwgLTEgaWYgdiBpcyBuZWdhdGl2ZSBhbmQgMCBpZiB2IGlzIGVxdWFsIHRvIHplcm8uJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzb3J0JyxcbiAgICBsYWJlbDogJ3NvcnQnLFxuICAgIGRldGFpbDogJ3NvcnQodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHZlY3RvciBlbGVtZW50cyBzb3J0ZWQgYnkgdGhlaXIgc2FtcGxlIHZhbHVlcywgaW4gYXNjZW5kaW5nIG9yZGVyLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc29ydF9kZXNjJyxcbiAgICBsYWJlbDogJ3NvcnRfZGVzYycsXG4gICAgZGV0YWlsOiAnc29ydF9kZXNjKHYgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB2ZWN0b3IgZWxlbWVudHMgc29ydGVkIGJ5IHRoZWlyIHNhbXBsZSB2YWx1ZXMsIGluIGRlc2NlbmRpbmcgb3JkZXIuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzcXJ0JyxcbiAgICBsYWJlbDogJ3NxcnQnLFxuICAgIGRldGFpbDogJ3NxcnQodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdDYWxjdWxhdGVzIHRoZSBzcXVhcmUgcm9vdCBvZiBhbGwgZWxlbWVudHMgaW4gYHZgLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAndGltZScsXG4gICAgbGFiZWw6ICd0aW1lJyxcbiAgICBkZXRhaWw6ICd0aW1lKCknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgSmFudWFyeSAxLCAxOTcwIFVUQy4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWN0dWFsbHkgcmV0dXJuIHRoZSBjdXJyZW50IHRpbWUsIGJ1dCB0aGUgdGltZSBhdCB3aGljaCB0aGUgZXhwcmVzc2lvbiBpcyB0byBiZSBldmFsdWF0ZWQuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICd0aW1lc3RhbXAnLFxuICAgIGxhYmVsOiAndGltZXN0YW1wJyxcbiAgICBkZXRhaWw6ICd0aW1lc3RhbXAodiBpbnN0YW50LXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246XG4gICAgICAnUmV0dXJucyB0aGUgdGltZXN0YW1wIG9mIGVhY2ggb2YgdGhlIHNhbXBsZXMgb2YgdGhlIGdpdmVuIHZlY3RvciBhcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgSmFudWFyeSAxLCAxOTcwIFVUQy4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3ZlY3RvcicsXG4gICAgbGFiZWw6ICd2ZWN0b3InLFxuICAgIGRldGFpbDogJ3ZlY3RvcihzIHNjYWxhciknLFxuICAgIGRvY3VtZW50YXRpb246ICdSZXR1cm5zIHRoZSBzY2FsYXIgYHNgIGFzIGEgdmVjdG9yIHdpdGggbm8gbGFiZWxzLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAneWVhcicsXG4gICAgbGFiZWw6ICd5ZWFyJyxcbiAgICBkZXRhaWw6ICd5ZWFyKHY9dmVjdG9yKHRpbWUoKSkgaW5zdGFudC12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnUmV0dXJucyB0aGUgeWVhciBmb3IgZWFjaCBvZiB0aGUgZ2l2ZW4gdGltZXMgaW4gVVRDLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnYXZnX292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdhdmdfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdhdmdfb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgYXZlcmFnZSB2YWx1ZSBvZiBhbGwgcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdtaW5fb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ21pbl9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ21pbl9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBtaW5pbXVtIHZhbHVlIG9mIGFsbCBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ21heF9vdmVyX3RpbWUnLFxuICAgIGxhYmVsOiAnbWF4X292ZXJfdGltZScsXG4gICAgZGV0YWlsOiAnbWF4X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIG1heGltdW0gdmFsdWUgb2YgYWxsIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFsLicsXG4gIH0sXG4gIHtcbiAgICBpbnNlcnRUZXh0OiAnc3VtX292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdzdW1fb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdzdW1fb3Zlcl90aW1lKHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgc3VtIG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2NvdW50X292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdjb3VudF9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ2NvdW50X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGNvdW50IG9mIGFsbCB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ3F1YW50aWxlX292ZXJfdGltZScsXG4gICAgbGFiZWw6ICdxdWFudGlsZV9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ3F1YW50aWxlX292ZXJfdGltZShzY2FsYXIsIHJhbmdlLXZlY3RvciknLFxuICAgIGRvY3VtZW50YXRpb246ICdUaGUgz4YtcXVhbnRpbGUgKDAg4omkIM+GIOKJpCAxKSBvZiB0aGUgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzdGRkZXZfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ3N0ZGRldl9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBwb3B1bGF0aW9uIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuJyxcbiAgfSxcbiAge1xuICAgIGluc2VydFRleHQ6ICdzdGR2YXJfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ3N0ZHZhcl9vdmVyX3RpbWUnLFxuICAgIGRldGFpbDogJ3N0ZHZhcl9vdmVyX3RpbWUocmFuZ2UtdmVjdG9yKScsXG4gICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBwb3B1bGF0aW9uIHN0YW5kYXJkIHZhcmlhbmNlIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuICB7XG4gICAgaW5zZXJ0VGV4dDogJ2xhc3Rfb3Zlcl90aW1lJyxcbiAgICBsYWJlbDogJ2xhc3Rfb3Zlcl90aW1lJyxcbiAgICBkZXRhaWw6ICdsYXN0X292ZXJfdGltZShyYW5nZS12ZWN0b3IpJyxcbiAgICBkb2N1bWVudGF0aW9uOiAnVGhlIG1vc3QgcmVjZW50IHBvaW50IHZhbHVlIGluIHNwZWNpZmllZCBpbnRlcnZhbC4nLFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IFBST01fS0VZV09SRFMgPSBGVU5DVElPTlMubWFwKChrZXl3b3JkKSA9PiBrZXl3b3JkLmxhYmVsKTtcblxuZXhwb3J0IGNvbnN0IHByb21xbEdyYW1tYXI6IEdyYW1tYXIgPSB7XG4gIGNvbW1lbnQ6IHtcbiAgICBwYXR0ZXJuOiAvIy4qLyxcbiAgfSxcbiAgJ2NvbnRleHQtYWdncmVnYXRpb24nOiB7XG4gICAgcGF0dGVybjogLygoYnl8d2l0aG91dClcXHMqKVxcKFteKV0qXFwpLywgLy8gYnkgKClcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2xhYmVsLWtleSc6IHtcbiAgICAgICAgcGF0dGVybjogL1teKCksXFxzXVteLCldKlteKSxcXHNdKi8sXG4gICAgICAgIGFsaWFzOiAnYXR0ci1uYW1lJyxcbiAgICAgIH0sXG4gICAgICBwdW5jdHVhdGlvbjogL1soKV0vLFxuICAgIH0sXG4gIH0sXG4gICdjb250ZXh0LWxhYmVscyc6IHtcbiAgICBwYXR0ZXJuOiAvXFx7W159XSooPz19PykvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgcGF0dGVybjogLyMuKi8sXG4gICAgICB9LFxuICAgICAgJ2xhYmVsLWtleSc6IHtcbiAgICAgICAgcGF0dGVybjogL1thLXpfXVxcdyooPz1cXHMqKD18IT18PX58IX4pKS8sXG4gICAgICAgIGFsaWFzOiAnYXR0ci1uYW1lJyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgfSxcbiAgICAgICdsYWJlbC12YWx1ZSc6IHtcbiAgICAgICAgcGF0dGVybjogL1wiKD86XFxcXC58W15cXFxcXCJdKSpcIi8sXG4gICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdhdHRyLXZhbHVlJyxcbiAgICAgIH0sXG4gICAgICBwdW5jdHVhdGlvbjogL1t7XS8sXG4gICAgfSxcbiAgfSxcbiAgZnVuY3Rpb246IG5ldyBSZWdFeHAoYFxcXFxiKD86JHtGVU5DVElPTlMubWFwKChmKSA9PiBmLmxhYmVsKS5qb2luKCd8Jyl9KSg/PVxcXFxzKlxcXFwoKWAsICdpJyksXG4gICdjb250ZXh0LXJhbmdlJzogW1xuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXFtbXlxcXV0qKD89XSkvLCAvLyBbMW1dXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3JhbmdlLWR1cmF0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9cXGJcXGQrW3NtaGR3eV1cXGIvaSxcbiAgICAgICAgICBhbGlhczogJ251bWJlcicsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgcGF0dGVybjogLyhvZmZzZXRcXHMrKVxcdysvLCAvLyBvZmZzZXQgMW1cbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3JhbmdlLWR1cmF0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9cXGJcXGQrW3NtaGR3eV1cXGIvaSxcbiAgICAgICAgICBhbGlhczogJ251bWJlcicsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIF0sXG4gIGlkTGlzdDoge1xuICAgIHBhdHRlcm46IC9cXGQrKFxcfFxcZCspKy8sXG4gICAgYWxpYXM6ICdudW1iZXInLFxuICB9LFxuICBudW1iZXI6IC9cXGItP1xcZCsoKFxcLlxcZCopPyhbZUVdWystXT9cXGQrKT8pP1xcYi8sXG4gIG9wZXJhdG9yOiBuZXcgUmVnRXhwKGAvWy0rKi89JV5+XXwmJj98XFxcXHw/XFxcXHx8IT0/fDwoPzo9Pj98PHw+KT98Pls+PV0/fFxcXFxiKD86JHtPUEVSQVRPUlMuam9pbignfCcpfSlcXFxcYmAsICdpJyksXG4gIHB1bmN0dWF0aW9uOiAvW3t9OygpYCwuXS8sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwcm9tcWxHcmFtbWFyO1xuIiwiaW1wb3J0IHsgc2l6ZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBRdWVyeUhpbnQsIFF1ZXJ5Rml4IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4vZGF0YXNvdXJjZSc7XG5cbi8qKlxuICogTnVtYmVyIG9mIHRpbWUgc2VyaWVzIHJlc3VsdHMgbmVlZGVkIGJlZm9yZSBzdGFydGluZyB0byBzdWdnZXN0IHN1bSBhZ2dyZWdhdGlvbiBoaW50c1xuICovXG5leHBvcnQgY29uc3QgU1VNX0hJTlRfVEhSRVNIT0xEX0NPVU5UID0gMjA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeUhpbnRzKHF1ZXJ5OiBzdHJpbmcsIHNlcmllcz86IGFueVtdLCBkYXRhc291cmNlPzogUHJvbWV0aGV1c0RhdGFzb3VyY2UpOiBRdWVyeUhpbnRbXSB7XG4gIGNvbnN0IGhpbnRzID0gW107XG5cbiAgLy8gLi4uX2J1Y2tldCBtZXRyaWMgbmVlZHMgYSBoaXN0b2dyYW1fcXVhbnRpbGUoKVxuICBjb25zdCBoaXN0b2dyYW1NZXRyaWMgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrX2J1Y2tldCR8XlxcdytfYnVja2V0ey4qfSQvKTtcbiAgaWYgKGhpc3RvZ3JhbU1ldHJpYykge1xuICAgIGNvbnN0IGxhYmVsID0gJ1NlbGVjdGVkIG1ldHJpYyBoYXMgYnVja2V0cy4nO1xuICAgIGhpbnRzLnB1c2goe1xuICAgICAgdHlwZTogJ0hJU1RPR1JBTV9RVUFOVElMRScsXG4gICAgICBsYWJlbCxcbiAgICAgIGZpeDoge1xuICAgICAgICBsYWJlbDogJ0NvbnNpZGVyIGNhbGN1bGF0aW5nIGFnZ3JlZ2F0ZWQgcXVhbnRpbGUgYnkgYWRkaW5nIGhpc3RvZ3JhbV9xdWFudGlsZSgpLicsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIHR5cGU6ICdBRERfSElTVE9HUkFNX1FVQU5USUxFJyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgUXVlcnlGaXgsXG4gICAgfSk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgbmVlZCBvZiByYXRlKClcbiAgaWYgKHF1ZXJ5LmluZGV4T2YoJ3JhdGUoJykgPT09IC0xICYmIHF1ZXJ5LmluZGV4T2YoJ2luY3JlYXNlKCcpID09PSAtMSkge1xuICAgIC8vIFVzZSBtZXRyaWMgbWV0YWRhdGEgZm9yIGV4YWN0IHR5cGVzXG4gICAgY29uc3QgbmFtZU1hdGNoID0gcXVlcnkubWF0Y2goL1xcYihcXHcrXyh0b3RhbHxzdW18Y291bnQpKVxcYi8pO1xuICAgIGxldCBjb3VudGVyTmFtZU1ldHJpYyA9IG5hbWVNYXRjaCA/IG5hbWVNYXRjaFsxXSA6ICcnO1xuICAgIGNvbnN0IG1ldHJpY3NNZXRhZGF0YSA9IGRhdGFzb3VyY2U/Lmxhbmd1YWdlUHJvdmlkZXI/Lm1ldHJpY3NNZXRhZGF0YSA/PyB7fTtcbiAgICBjb25zdCBtZXRyaWNNZXRhZGF0YUtleXMgPSBPYmplY3Qua2V5cyhtZXRyaWNzTWV0YWRhdGEpO1xuICAgIGxldCBjZXJ0YWluID0gZmFsc2U7XG5cbiAgICBpZiAobWV0cmljTWV0YWRhdGFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvdW50ZXJOYW1lTWV0cmljID1cbiAgICAgICAgbWV0cmljTWV0YWRhdGFLZXlzLmZpbmQoKG1ldHJpY05hbWUpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyaW5nIGZpcnN0IHR5cGUgaW5mb3JtYXRpb24sIGNvdWxkIGJlIG5vbi1kZXRlcm1pbmlzdGljXG4gICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBtZXRyaWNzTWV0YWRhdGFbbWV0cmljTmFtZV07XG4gICAgICAgICAgaWYgKG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2NvdW50ZXInKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxiJHttZXRyaWNOYW1lfVxcXFxiYCk7XG4gICAgICAgICAgICBpZiAocXVlcnkubWF0Y2gobWV0cmljUmVnZXgpKSB7XG4gICAgICAgICAgICAgIGNlcnRhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSA/PyAnJztcbiAgICB9XG5cbiAgICBpZiAoY291bnRlck5hbWVNZXRyaWMpIHtcbiAgICAgIC8vIEZpeGFibGVRdWVyeSBjb25zaXN0cyBvZiBtZXRyaWMgbmFtZSBhbmQgb3B0aW9uYWxseSBsYWJlbC12YWx1ZSBwYWlycy4gV2UgYXJlIG5vdCBvZmZlcmluZyBmaXggZm9yIGNvbXBsZXggcXVlcmllcyB5ZXQuXG4gICAgICBjb25zdCBmaXhhYmxlUXVlcnkgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrJHxeXFx3K3suKn0kLyk7XG4gICAgICBjb25zdCB2ZXJiID0gY2VydGFpbiA/ICdpcycgOiAnbG9va3MgbGlrZSc7XG4gICAgICBsZXQgbGFiZWwgPSBgU2VsZWN0ZWQgbWV0cmljICR7dmVyYn0gYSBjb3VudGVyLmA7XG4gICAgICBsZXQgZml4OiBRdWVyeUZpeCB8IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGZpeGFibGVRdWVyeSkge1xuICAgICAgICBmaXggPSB7XG4gICAgICAgICAgbGFiZWw6ICdDb25zaWRlciBjYWxjdWxhdGluZyByYXRlIG9mIGNvdW50ZXIgYnkgYWRkaW5nIHJhdGUoKS4nLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0FERF9SQVRFJyxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbCA9IGAke2xhYmVsfSBDb25zaWRlciBjYWxjdWxhdGluZyByYXRlIG9mIGNvdW50ZXIgYnkgYWRkaW5nIHJhdGUoKS5gO1xuICAgICAgfVxuXG4gICAgICBoaW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0FQUExZX1JBVEUnLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZml4LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHJlY29yZGluZyBydWxlcyBleHBhbnNpb25cbiAgaWYgKGRhdGFzb3VyY2UgJiYgZGF0YXNvdXJjZS5ydWxlTWFwcGluZ3MpIHtcbiAgICBjb25zdCBtYXBwaW5nID0gZGF0YXNvdXJjZS5ydWxlTWFwcGluZ3M7XG4gICAgY29uc3QgbWFwcGluZ0ZvclF1ZXJ5ID0gT2JqZWN0LmtleXMobWFwcGluZykucmVkdWNlKChhY2MsIHJ1bGVOYW1lKSA9PiB7XG4gICAgICBpZiAocXVlcnkuc2VhcmNoKHJ1bGVOYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIFtydWxlTmFtZV06IG1hcHBpbmdbcnVsZU5hbWVdLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKHNpemUobWFwcGluZ0ZvclF1ZXJ5KSA+IDApIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gJ1F1ZXJ5IGNvbnRhaW5zIHJlY29yZGluZyBydWxlcy4nO1xuICAgICAgaGludHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdFWFBBTkRfUlVMRVMnLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZml4OiB7XG4gICAgICAgICAgbGFiZWw6ICdFeHBhbmQgcnVsZXMnLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0VYUEFORF9SVUxFUycsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIG1hcHBpbmc6IG1hcHBpbmdGb3JRdWVyeSxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIGFueSBhcyBRdWVyeUZpeCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZXJpZXMgJiYgc2VyaWVzLmxlbmd0aCA+PSBTVU1fSElOVF9USFJFU0hPTERfQ09VTlQpIHtcbiAgICBjb25zdCBzaW1wbGVNZXRyaWMgPSBxdWVyeS50cmltKCkubWF0Y2goL15cXHcrJC8pO1xuICAgIGlmIChzaW1wbGVNZXRyaWMpIHtcbiAgICAgIGhpbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQUREX1NVTScsXG4gICAgICAgIGxhYmVsOiAnTWFueSB0aW1lIHNlcmllcyByZXN1bHRzIHJldHVybmVkLicsXG4gICAgICAgIGZpeDoge1xuICAgICAgICAgIGxhYmVsOiAnQ29uc2lkZXIgYWdncmVnYXRpbmcgd2l0aCBzdW0oKS4nLFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogJ0FERF9TVU0nLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgcHJldmVudFN1Ym1pdDogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9IGFzIFF1ZXJ5Rml4LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdEhpbnRzKGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlKTogUXVlcnlIaW50W10ge1xuICBjb25zdCBoaW50cyA9IFtdO1xuICAvLyBIaW50IGlmIHVzaW5nIExva2kgYXMgUHJvbWV0aGV1cyBkYXRhIHNvdXJjZVxuICBpZiAoZGF0YXNvdXJjZS5kaXJlY3RVcmwuaW5jbHVkZXMoJy9sb2tpJykgJiYgIWRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5tZXRyaWNzLmxlbmd0aCkge1xuICAgIGhpbnRzLnB1c2goe1xuICAgICAgbGFiZWw6IGBVc2luZyBMb2tpIGFzIGEgUHJvbWV0aGV1cyBkYXRhIHNvdXJjZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBZb3UgbXVzdCB1c2UgdGhlIExva2kgZGF0YSBzb3VyY2UgZm9yIHlvdXIgTG9raSBpbnN0YW5jZS5gLFxuICAgICAgdHlwZTogJ0lORk8nLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gSGludCBmb3IgYmlnIGRpc2FibGVkIGxvb2t1cHNcbiAgaWYgKGRhdGFzb3VyY2UubG9va3Vwc0Rpc2FibGVkKSB7XG4gICAgaGludHMucHVzaCh7XG4gICAgICBsYWJlbDogYExhYmVscyBhbmQgbWV0cmljcyBsb29rdXAgd2FzIGRpc2FibGVkIGluIGRhdGEgc291cmNlIHNldHRpbmdzLmAsXG4gICAgICB0eXBlOiAnSU5GTycsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaGludHM7XG59XG4iLCJpbXBvcnQgeyBGVU5DVElPTlMgfSBmcm9tICcuLi9wcm9tcWwnO1xuaW1wb3J0IHsgZ2V0QWdncmVnYXRpb25PcGVyYXRpb25zIH0gZnJvbSAnLi9hZ2dyZWdhdGlvbnMnO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbnMgfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuaW1wb3J0IHsgTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSB9IGZyb20gJy4vc2hhcmVkL0xva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5UGF0dGVybiwgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFByb21RdWVyeU1vZGVsbGVyIGV4dGVuZHMgTG9raUFuZFByb21RdWVyeU1vZGVsbGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCgpID0+IHtcbiAgICAgIGNvbnN0IGFsbE9wZXJhdGlvbnMgPSBbLi4uZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbnMoKSwgLi4uZ2V0QWdncmVnYXRpb25PcGVyYXRpb25zKCldO1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBhbGxPcGVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBGVU5DVElPTlMuZmluZCgoeCkgPT4geC5pbnNlcnRUZXh0ID09PSBvcC5pZCk7XG4gICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgb3AuZG9jdW1lbnRhdGlvbiA9IGZ1bmMuZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbE9wZXJhdGlvbnM7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNldE9wZXJhdGlvbkNhdGVnb3JpZXMoW1xuICAgICAgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQWdncmVnYXRpb25zLFxuICAgICAgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5CaW5hcnlPcHMsXG4gICAgICBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgICAgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFF1ZXJ5UGF0dGVybnMoKTogUHJvbVF1ZXJ5UGF0dGVybltdIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnUmF0ZSB0aGVuIHN1bScsXG4gICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICB7IGlkOiAncmF0ZScsIHBhcmFtczogWyckX19yYXRlX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiAnc3VtJywgcGFyYW1zOiBbXSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1JhdGUgdGhlbiBzdW0gYnkobGFiZWwpIHRoZW4gYXZnJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6ICdyYXRlJywgcGFyYW1zOiBbJyRfX3JhdGVfaW50ZXJ2YWwnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdfX3N1bV9ieScsIHBhcmFtczogWycnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdhdmcnLCBwYXJhbXM6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnSGlzdG9ncmFtIHF1YW50aWxlIG9uIHJhdGUnLFxuICAgICAgICBvcGVyYXRpb25zOiBbXG4gICAgICAgICAgeyBpZDogJ3JhdGUnLCBwYXJhbXM6IFsnJF9fcmF0ZV9pbnRlcnZhbCddIH0sXG4gICAgICAgICAgeyBpZDogJ19fc3VtX2J5JywgcGFyYW1zOiBbJ2xlJ10gfSxcbiAgICAgICAgICB7IGlkOiAnaGlzdG9ncmFtX3F1YW50aWxlJywgcGFyYW1zOiBbMC45NV0gfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdIaXN0b2dyYW0gcXVhbnRpbGUgb24gaW5jcmVhc2UgJyxcbiAgICAgICAgb3BlcmF0aW9uczogW1xuICAgICAgICAgIHsgaWQ6ICdpbmNyZWFzZScsIHBhcmFtczogWyckX19yYXRlX2ludGVydmFsJ10gfSxcbiAgICAgICAgICB7IGlkOiAnX19tYXhfYnknLCBwYXJhbXM6IFsnbGUnXSB9LFxuICAgICAgICAgIHsgaWQ6ICdoaXN0b2dyYW1fcXVhbnRpbGUnLCBwYXJhbXM6IFswLjk1XSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICBdO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBwcm9tUXVlcnlNb2RlbGxlciA9IG5ldyBQcm9tUXVlcnlNb2RlbGxlcigpO1xuIiwiaW1wb3J0IHsgYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yIH0gZnJvbSAnLi9vcGVyYXRpb25zJztcbmltcG9ydCB7XG4gIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uLFxuICBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbSxcbiAgZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZSxcbiAgZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZixcbn0gZnJvbSAnLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSwgUHJvbU9wZXJhdGlvbklkIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMoKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10ge1xuICByZXR1cm4gW1xuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKFByb21PcGVyYXRpb25JZC5TdW0pLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKFByb21PcGVyYXRpb25JZC5BdmcpLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKFByb21PcGVyYXRpb25JZC5NaW4pLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKFByb21PcGVyYXRpb25JZC5NYXgpLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uKFByb21PcGVyYXRpb25JZC5Db3VudCksXG4gICAgLi4uY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0oUHJvbU9wZXJhdGlvbklkLlRvcEssIHtcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ0stdmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFs1XSxcbiAgICB9KSxcbiAgICAuLi5jcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbldpdGhQYXJhbShQcm9tT3BlcmF0aW9uSWQuQm90dG9tSywge1xuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnSy12YWx1ZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzVdLFxuICAgIH0pLFxuICAgIC4uLmNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFByb21PcGVyYXRpb25JZC5Db3VudFZhbHVlcywge1xuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnSWRlbnRpZmllcicsIHR5cGU6ICdzdHJpbmcnIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWydjb3VudCddLFxuICAgIH0pLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLlN1bU92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5BdmdPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuTWluT3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLk1heE92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5Db3VudE92ZXJUaW1lKSxcbiAgICBjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lKFByb21PcGVyYXRpb25JZC5MYXN0T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLlByZXNlbnRPdmVyVGltZSksXG4gICAgY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShQcm9tT3BlcmF0aW9uSWQuQWJzZW50T3ZlclRpbWUpLFxuICAgIGNyZWF0ZUFnZ3JlZ2F0aW9uT3ZlclRpbWUoUHJvbU9wZXJhdGlvbklkLlN0ZGRldk92ZXJUaW1lKSxcbiAgXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRpb25PdmVyVGltZShuYW1lOiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYge1xuICByZXR1cm4ge1xuICAgIGlkOiBuYW1lLFxuICAgIG5hbWU6IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUobmFtZSksXG4gICAgcGFyYW1zOiBbZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpXSxcbiAgICBkZWZhdWx0UGFyYW1zOiBbJyRfX2ludGVydmFsJ10sXG4gICAgYWx0ZXJuYXRpdmVzS2V5OiAnb3ZlcnRpbWUgZnVuY3Rpb24nLFxuICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICByZW5kZXJlcjogb3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIsXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICB9O1xufVxuXG5mdW5jdGlvbiBvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlcihcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pIHtcbiAgbGV0IHJhbmdlVmVjdG9yID0gKG1vZGVsLnBhcmFtcyA/PyBbXSlbMF0gPz8gJyRfX2ludGVydmFsJztcbiAgcmV0dXJuIGAke2RlZi5pZH0oJHtpbm5lckV4cHJ9WyR7cmFuZ2VWZWN0b3J9XSlgO1xufVxuIiwiaW1wb3J0IHsgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIH0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbU9wZXJhdGlvbklkLCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIgfSBmcm9tICcuL3NoYXJlZC9vcGVyYXRpb25VdGlscyc7XG5cbmV4cG9ydCBjb25zdCBiaW5hcnlTY2FsYXJEZWZzID0gW1xuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5BZGRpdGlvbixcbiAgICBuYW1lOiAnQWRkIHNjYWxhcicsXG4gICAgc2lnbjogJysnLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5TdWJ0cmFjdGlvbixcbiAgICBuYW1lOiAnU3VidHJhY3Qgc2NhbGFyJyxcbiAgICBzaWduOiAnLScsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLk11bHRpcGx5QnksXG4gICAgbmFtZTogJ011bHRpcGx5IGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJyonLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5EaXZpZGVCeSxcbiAgICBuYW1lOiAnRGl2aWRlIGJ5IHNjYWxhcicsXG4gICAgc2lnbjogJy8nLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5Nb2R1bG8sXG4gICAgbmFtZTogJ01vZHVsbyBieSBzY2FsYXInLFxuICAgIHNpZ246ICclJyxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRXhwb25lbnQsXG4gICAgbmFtZTogJ0V4cG9uZW50JyxcbiAgICBzaWduOiAnXicsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkVxdWFsVG8sXG4gICAgbmFtZTogJ0VxdWFsIHRvJyxcbiAgICBzaWduOiAnPT0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLk5vdEVxdWFsVG8sXG4gICAgbmFtZTogJ05vdCBlcXVhbCB0bycsXG4gICAgc2lnbjogJyE9JyxcbiAgICBjb21wYXJpc29uOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6IFByb21PcGVyYXRpb25JZC5HcmVhdGVyVGhhbixcbiAgICBuYW1lOiAnR3JlYXRlciB0aGFuJyxcbiAgICBzaWduOiAnPicsXG4gICAgY29tcGFyaXNvbjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGVzc1RoYW4sXG4gICAgbmFtZTogJ0xlc3MgdGhhbicsXG4gICAgc2lnbjogJzwnLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkdyZWF0ZXJPckVxdWFsLFxuICAgIG5hbWU6ICdHcmVhdGVyIG9yIGVxdWFsIHRvJyxcbiAgICBzaWduOiAnPj0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxlc3NPckVxdWFsLFxuICAgIG5hbWU6ICdMZXNzIG9yIGVxdWFsIHRvJyxcbiAgICBzaWduOiAnPD0nLFxuICAgIGNvbXBhcmlzb246IHRydWUsXG4gIH0sXG5dO1xuXG4vLyBOb3Qgc3VyZSBhYm91dCB0aGlzIG9uZS4gSXQgY291bGQgYWxzbyBiZSBhIG1vcmUgZ2VuZXJpYyAnU2ltcGxlIG1hdGggb3BlcmF0aW9uJyB3aGVyZSB1c2VyIHNwZWNpZmllc1xuLy8gYm90aCB0aGUgb3BlcmF0b3IgYW5kIHRoZSBvcGVyYW5kIGluIGEgc2luZ2xlIGlucHV0XG5leHBvcnQgY29uc3QgYmluYXJ5U2NhbGFyT3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBiaW5hcnlTY2FsYXJEZWZzLm1hcCgob3BEZWYpID0+IHtcbiAgY29uc3QgcGFyYW1zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZltdID0gW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV07XG4gIGNvbnN0IGRlZmF1bHRQYXJhbXM6IGFueVtdID0gWzJdO1xuICBpZiAob3BEZWYuY29tcGFyaXNvbikge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIG5hbWU6ICdCb29sJyxcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnSWYgY2hlY2tlZCBjb21wYXJpc29uIHdpbGwgcmV0dXJuIDAgb3IgMSBmb3IgdGhlIHZhbHVlIHJhdGhlciB0aGFuIGZpbHRlcmluZy4nLFxuICAgIH0pO1xuICAgIGRlZmF1bHRQYXJhbXMucHVzaChmYWxzZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBvcERlZi5pZCxcbiAgICBuYW1lOiBvcERlZi5uYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkZWZhdWx0UGFyYW1zLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ2JpbmFyeSBzY2FsYXIgb3BlcmF0aW9ucycsXG4gICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcyxcbiAgICByZW5kZXJlcjogZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BEZWYuc2lnbiksXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIH07XG59KTtcblxuZnVuY3Rpb24gZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIob3BlcmF0b3I6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYmluYXJ5UmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgbGV0IHBhcmFtID0gbW9kZWwucGFyYW1zWzBdO1xuICAgIGxldCBib29sID0gJyc7XG4gICAgaWYgKG1vZGVsLnBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGJvb2wgPSBtb2RlbC5wYXJhbXNbMV0gPyAnIGJvb2wnIDogJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2lubmVyRXhwcn0gJHtvcGVyYXRvcn0ke2Jvb2x9ICR7cGFyYW19YDtcbiAgfTtcbn1cbiIsImltcG9ydCB7IERhdGFTb3VyY2VBcGksIFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBwcm9tUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL1Byb21RdWVyeU1vZGVsbGVyJztcbmltcG9ydCB7IGdldE9wZXJhdGlvblBhcmFtSWQgfSBmcm9tICcuLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIsIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gTGFiZWxQYXJhbUVkaXRvcih7XG4gIG9uQ2hhbmdlLFxuICBpbmRleCxcbiAgb3BlcmF0aW9uSW5kZXgsXG4gIHZhbHVlLFxuICBxdWVyeSxcbiAgZGF0YXNvdXJjZSxcbn06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRWRpdG9yUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTx7XG4gICAgb3B0aW9ucz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBpc0xvYWRpbmc/OiBib29sZWFuO1xuICB9Pih7fSk7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VsZWN0XG4gICAgICBpbnB1dElkPXtnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4LCBpbmRleCl9XG4gICAgICBtZW51U2hvdWxkUG9ydGFsXG4gICAgICBhdXRvRm9jdXM9e3ZhbHVlID09PSAnJyA/IHRydWUgOiB1bmRlZmluZWR9XG4gICAgICBvcGVuTWVudU9uRm9jdXNcbiAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgc2V0U3RhdGUoeyBpc0xvYWRpbmc6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBsb2FkR3JvdXBCeUxhYmVscyhxdWVyeSwgZGF0YXNvdXJjZSk7XG4gICAgICAgIHNldFN0YXRlKHsgb3B0aW9ucywgaXNMb2FkaW5nOiB1bmRlZmluZWQgfSk7XG4gICAgICB9fVxuICAgICAgaXNMb2FkaW5nPXtzdGF0ZS5pc0xvYWRpbmd9XG4gICAgICBhbGxvd0N1c3RvbVZhbHVlXG4gICAgICBub09wdGlvbnNNZXNzYWdlPVwiTm8gbGFiZWxzIGZvdW5kXCJcbiAgICAgIGxvYWRpbmdNZXNzYWdlPVwiTG9hZGluZyBsYWJlbHNcIlxuICAgICAgb3B0aW9ucz17c3RhdGUub3B0aW9uc31cbiAgICAgIHZhbHVlPXt0b09wdGlvbih2YWx1ZSBhcyBzdHJpbmcpfVxuICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gb25DaGFuZ2UoaW5kZXgsIHZhbHVlLnZhbHVlISl9XG4gICAgLz5cbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZEdyb3VwQnlMYWJlbHMoXG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnksXG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGlcbik6IFByb21pc2U8QXJyYXk8U2VsZWN0YWJsZVZhbHVlPGFueT4+PiB7XG4gIGxldCBsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10gPSBxdWVyeS5sYWJlbHM7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IGJvdGggUHJvbWV0aGV1cyBhbmQgTG9raSBhbmQgdGhpcyB0aGUgb25seSBkaWZmZXJlbmNlXG4gIGlmIChkYXRhc291cmNlIGluc3RhbmNlb2YgUHJvbWV0aGV1c0RhdGFzb3VyY2UpIHtcbiAgICBsYWJlbHMgPSBbeyBsYWJlbDogJ19fbmFtZV9fJywgb3A6ICc9JywgdmFsdWU6IHF1ZXJ5Lm1ldHJpYyB9LCAuLi5xdWVyeS5sYWJlbHNdO1xuICB9XG5cbiAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHMpO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoZXhwcik7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3VsdCkubWFwKCh4KSA9PiAoe1xuICAgIGxhYmVsOiB4LFxuICAgIHZhbHVlOiB4LFxuICB9KSk7XG59XG4iLCJpbXBvcnQgeyBTZWxlY3QsIEZvcm1hdE9wdGlvbkxhYmVsTWV0YSwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUsIHRvT3B0aW9uLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBFZGl0b3JGaWVsZCwgRWRpdG9yRmllbGRHcm91cCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IEhpZ2hsaWdodGVyIGZyb20gJ3JlYWN0LWhpZ2hsaWdodC13b3Jkcyc7XG5cbi8vIFdlIGFyZSBtYXRjaGluZyB3b3JkcyBzcGxpdCB3aXRoIHNwYWNlXG5jb25zdCBzcGxpdFNlcGFyYXRvciA9ICcgJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnk7XG4gIG9uQ2hhbmdlOiAocXVlcnk6IFByb21WaXN1YWxRdWVyeSkgPT4gdm9pZDtcbiAgb25HZXRNZXRyaWNzOiAoKSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE1ldHJpY1NlbGVjdCh7IHF1ZXJ5LCBvbkNoYW5nZSwgb25HZXRNZXRyaWNzIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTx7XG4gICAgbWV0cmljcz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBpc0xvYWRpbmc/OiBib29sZWFuO1xuICB9Pih7fSk7XG5cbiAgY29uc3QgY3VzdG9tRmlsdGVyT3B0aW9uID0gdXNlQ2FsbGJhY2soKG9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPGFueT4sIHNlYXJjaFF1ZXJ5OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBsYWJlbCA9IG9wdGlvbi5sYWJlbCA/PyBvcHRpb24udmFsdWU7XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWFyY2hXb3JkcyA9IHNlYXJjaFF1ZXJ5LnNwbGl0KHNwbGl0U2VwYXJhdG9yKTtcbiAgICByZXR1cm4gc2VhcmNoV29yZHMucmVkdWNlKChhY2MsIGN1cikgPT4gYWNjICYmIGxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoY3VyLnRvTG93ZXJDYXNlKCkpLCB0cnVlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGZvcm1hdE9wdGlvbkxhYmVsID0gdXNlQ2FsbGJhY2soXG4gICAgKG9wdGlvbjogU2VsZWN0YWJsZVZhbHVlPGFueT4sIG1ldGE6IEZvcm1hdE9wdGlvbkxhYmVsTWV0YTxhbnk+KSA9PiB7XG4gICAgICAvLyBGb3IgbmV3bHkgY3JlYXRlZCBjdXN0b20gdmFsdWUgd2UgZG9uJ3Qgd2FudCB0byBhZGQgaGlnaGxpZ2h0XG4gICAgICBpZiAob3B0aW9uWydfX2lzTmV3X18nXSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uLmxhYmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8SGlnaGxpZ2h0ZXJcbiAgICAgICAgICBzZWFyY2hXb3Jkcz17bWV0YS5pbnB1dFZhbHVlLnNwbGl0KHNwbGl0U2VwYXJhdG9yKX1cbiAgICAgICAgICB0ZXh0VG9IaWdobGlnaHQ9e29wdGlvbi5sYWJlbCA/PyAnJ31cbiAgICAgICAgICBoaWdobGlnaHRDbGFzc05hbWU9e3N0eWxlcy5oaWdobGlnaHR9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH0sXG4gICAgW3N0eWxlcy5oaWdobGlnaHRdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIk1ldHJpY1wiPlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtbWV0cmljLXNlbGVjdFwiXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuc2VsZWN0fVxuICAgICAgICAgIHZhbHVlPXtxdWVyeS5tZXRyaWMgPyB0b09wdGlvbihxdWVyeS5tZXRyaWMpIDogdW5kZWZpbmVkfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VsZWN0IG1ldHJpY1wiXG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIGZvcm1hdE9wdGlvbkxhYmVsPXtmb3JtYXRPcHRpb25MYWJlbH1cbiAgICAgICAgICBmaWx0ZXJPcHRpb249e2N1c3RvbUZpbHRlck9wdGlvbn1cbiAgICAgICAgICBvbk9wZW5NZW51PXthc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBhd2FpdCBvbkdldE1ldHJpY3MoKTtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgbWV0cmljcywgaXNMb2FkaW5nOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBpc0xvYWRpbmc9e3N0YXRlLmlzTG9hZGluZ31cbiAgICAgICAgICBvcHRpb25zPXtzdGF0ZS5tZXRyaWNzfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgbWV0cmljOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICA8L0VkaXRvckZpZWxkR3JvdXA+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4gKHtcbiAgc2VsZWN0OiBjc3NgXG4gICAgbWluLXdpZHRoOiAxMjVweDtcbiAgYCxcbiAgaGlnaGxpZ2h0OiBjc3NgXG4gICAgbGFiZWw6IHNlbGVjdF9fbWF0Y2gtaGlnaGxpZ2h0O1xuICAgIGJhY2tncm91bmQ6IGluaGVyaXQ7XG4gICAgcGFkZGluZzogaW5oZXJpdDtcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMud2FybmluZy5tYWlufTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKCR7dGhlbWUuY29sb3JzLndhcm5pbmcubWFpbn0sIDAuMSk7XG4gIGAsXG59KTtcbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCB0b09wdGlvbiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yUm93cywgRmxleEl0ZW0gfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgSWNvbkJ1dHRvbiwgU2VsZWN0LCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByb21ldGhldXNEYXRhc291cmNlIH0gZnJvbSAnLi4vLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBBdXRvU2l6ZUlucHV0IH0gZnJvbSAnLi4vc2hhcmVkL0F1dG9TaXplSW5wdXQnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5QnVpbGRlciB9IGZyb20gJy4vUHJvbVF1ZXJ5QnVpbGRlcic7XG5pbXBvcnQgeyBiaW5hcnlTY2FsYXJEZWZzIH0gZnJvbSAnLi4vYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBuZXN0ZWRRdWVyeTogUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgaW5kZXg6IG51bWJlcjtcbiAgb25DaGFuZ2U6IChpbmRleDogbnVtYmVyLCB1cGRhdGU6IFByb21WaXN1YWxRdWVyeUJpbmFyeSkgPT4gdm9pZDtcbiAgb25SZW1vdmU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgTmVzdGVkUXVlcnkgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBuZXN0ZWRRdWVyeSwgaW5kZXgsIGRhdGFzb3VyY2UsIG9uQ2hhbmdlLCBvblJlbW92ZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2FyZH0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmFtZX0+T3BlcmF0b3I8L2Rpdj5cbiAgICAgICAgPFNlbGVjdFxuICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgb3B0aW9ucz17b3BlcmF0b3JzfVxuICAgICAgICAgIHZhbHVlPXt0b09wdGlvbihuZXN0ZWRRdWVyeS5vcGVyYXRvcil9XG4gICAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIHtcbiAgICAgICAgICAgICAgLi4ubmVzdGVkUXVlcnksXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiB2YWx1ZS52YWx1ZSEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm5hbWV9PlZlY3RvciBtYXRjaGVzPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudmVjdG9yTWF0Y2hXcmFwcGVyfT5cbiAgICAgICAgICA8U2VsZWN0PFByb21WaXN1YWxRdWVyeUJpbmFyeVsndmVjdG9yTWF0Y2hlc1R5cGUnXT5cbiAgICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgICB2YWx1ZT17bmVzdGVkUXVlcnkudmVjdG9yTWF0Y2hlc1R5cGUgfHwgJ29uJ31cbiAgICAgICAgICAgIGFsbG93Q3VzdG9tVmFsdWVcbiAgICAgICAgICAgIG9wdGlvbnM9e1tcbiAgICAgICAgICAgICAgeyB2YWx1ZTogJ29uJywgbGFiZWw6ICdvbicgfSxcbiAgICAgICAgICAgICAgeyB2YWx1ZTogJ2lnbm9yaW5nJywgbGFiZWw6ICdpZ25vcmluZycgfSxcbiAgICAgICAgICAgIF19XG4gICAgICAgICAgICBvbkNoYW5nZT17KHZhbCkgPT4ge1xuICAgICAgICAgICAgICBvbkNoYW5nZShpbmRleCwge1xuICAgICAgICAgICAgICAgIC4uLm5lc3RlZFF1ZXJ5LFxuICAgICAgICAgICAgICAgIHZlY3Rvck1hdGNoZXNUeXBlOiB2YWwudmFsdWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy52ZWN0b3JNYXRjaElucHV0fVxuICAgICAgICAgICAgbWluV2lkdGg9ezIwfVxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlPXtuZXN0ZWRRdWVyeS52ZWN0b3JNYXRjaGVzfVxuICAgICAgICAgICAgb25Db21taXRDaGFuZ2U9eyhldnQpID0+IHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAuLi5uZXN0ZWRRdWVyeSxcbiAgICAgICAgICAgICAgICB2ZWN0b3JNYXRjaGVzOiBldnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICB2ZWN0b3JNYXRjaGVzVHlwZTogbmVzdGVkUXVlcnkudmVjdG9yTWF0Y2hlc1R5cGUgfHwgJ29uJyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8RmxleEl0ZW0gZ3Jvdz17MX0gLz5cbiAgICAgICAgPEljb25CdXR0b24gbmFtZT1cInRpbWVzXCIgc2l6ZT1cInNtXCIgb25DbGljaz17KCkgPT4gb25SZW1vdmUoaW5kZXgpfSAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PlxuICAgICAgICA8RWRpdG9yUm93cz5cbiAgICAgICAgICA8UHJvbVF1ZXJ5QnVpbGRlclxuICAgICAgICAgICAgcXVlcnk9e25lc3RlZFF1ZXJ5LnF1ZXJ5fVxuICAgICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICAgIG5lc3RlZD17dHJ1ZX1cbiAgICAgICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgICAgICBvbkNoYW5nZT17KHVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBvbkNoYW5nZShpbmRleCwgeyAuLi5uZXN0ZWRRdWVyeSwgcXVlcnk6IHVwZGF0ZSB9KTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JSb3dzPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59KTtcblxuY29uc3Qgb3BlcmF0b3JzID0gYmluYXJ5U2NhbGFyRGVmcy5tYXAoKGRlZikgPT4gKHsgbGFiZWw6IGRlZi5zaWduLCB2YWx1ZTogZGVmLnNpZ24gfSkpO1xuXG5OZXN0ZWRRdWVyeS5kaXNwbGF5TmFtZSA9ICdOZXN0ZWRRdWVyeSc7XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGNhcmQ6IGNzcyh7XG4gICAgICBsYWJlbDogJ2NhcmQnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMC41KSxcbiAgICB9KSxcbiAgICBoZWFkZXI6IGNzcyh7XG4gICAgICBsYWJlbDogJ2hlYWRlcicsXG4gICAgICBwYWRkaW5nOiB0aGVtZS5zcGFjaW5nKDAuNSwgMC41LCAwLjUsIDEpLFxuICAgICAgZ2FwOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgfSksXG4gICAgbmFtZTogY3NzKHtcbiAgICAgIGxhYmVsOiAnbmFtZScsXG4gICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgbGFiZWw6ICdib2R5JyxcbiAgICAgIHBhZGRpbmdMZWZ0OiB0aGVtZS5zcGFjaW5nKDIpLFxuICAgIH0pLFxuICAgIHZlY3Rvck1hdGNoSW5wdXQ6IGNzcyh7XG4gICAgICBsYWJlbDogJ3ZlY3Rvck1hdGNoSW5wdXQnLFxuICAgICAgbWFyZ2luTGVmdDogLTEsXG4gICAgfSksXG4gICAgdmVjdG9yTWF0Y2hXcmFwcGVyOiBjc3Moe1xuICAgICAgbGFiZWw6ICd2ZWN0b3JNYXRjaFdyYXBwZXInLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5LCBQcm9tVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBOZXN0ZWRRdWVyeSB9IGZyb20gJy4vTmVzdGVkUXVlcnknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeTtcbiAgZGF0YXNvdXJjZTogUHJvbWV0aGV1c0RhdGFzb3VyY2U7XG4gIG9uQ2hhbmdlOiAocXVlcnk6IFByb21WaXN1YWxRdWVyeSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE5lc3RlZFF1ZXJ5TGlzdCh7IHF1ZXJ5LCBkYXRhc291cmNlLCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9OiBQcm9wcykge1xuICBjb25zdCBuZXN0ZWRRdWVyaWVzID0gcXVlcnkuYmluYXJ5UXVlcmllcyA/PyBbXTtcblxuICBjb25zdCBvbk5lc3RlZFF1ZXJ5VXBkYXRlID0gKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5KSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ubmVzdGVkUXVlcmllc107XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKGluZGV4LCAxLCB1cGRhdGUpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGJpbmFyeVF1ZXJpZXM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5uZXN0ZWRRdWVyaWVzLnNsaWNlKDAsIGluZGV4KSwgLi4ubmVzdGVkUXVlcmllcy5zbGljZShpbmRleCArIDEpXTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBiaW5hcnlRdWVyaWVzOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBkaXJlY3Rpb249XCJjb2x1bW5cIiBnYXA9ezF9PlxuICAgICAge25lc3RlZFF1ZXJpZXMubWFwKChuZXN0ZWRRdWVyeSwgaW5kZXgpID0+IChcbiAgICAgICAgPE5lc3RlZFF1ZXJ5XG4gICAgICAgICAga2V5PXtpbmRleC50b1N0cmluZygpfVxuICAgICAgICAgIG5lc3RlZFF1ZXJ5PXtuZXN0ZWRRdWVyeX1cbiAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgb25DaGFuZ2U9e29uTmVzdGVkUXVlcnlVcGRhdGV9XG4gICAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgICBvblJlbW92ZT17b25SZW1vdmV9XG4gICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgLz5cbiAgICAgICkpfVxuICAgIDwvU3RhY2s+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNZXRyaWNTZWxlY3QgfSBmcm9tICcuL01ldHJpY1NlbGVjdCc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMYWJlbEZpbHRlcnMgfSBmcm9tICcuLi9zaGFyZWQvTGFiZWxGaWx0ZXJzJztcbmltcG9ydCB7IE9wZXJhdGlvbkxpc3QgfSBmcm9tICcuLi9zaGFyZWQvT3BlcmF0aW9uTGlzdCc7XG5pbXBvcnQgeyBFZGl0b3JSb3cgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuLi8uLi9kYXRhc291cmNlJztcbmltcG9ydCB7IE5lc3RlZFF1ZXJ5TGlzdCB9IGZyb20gJy4vTmVzdGVkUXVlcnlMaXN0JztcbmltcG9ydCB7IHByb21RdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vUHJvbVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgUGFuZWxEYXRhLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IE9wZXJhdGlvbnNFZGl0b3JSb3cgfSBmcm9tICcuLi9zaGFyZWQvT3BlcmF0aW9uc0VkaXRvclJvdyc7XG5pbXBvcnQgeyBQcm9tUXVlcnlCdWlsZGVySGludHMgfSBmcm9tICcuL1Byb21RdWVyeUJ1aWxkZXJIaW50cyc7XG5pbXBvcnQgeyBnZXRNZXRhZGF0YVN0cmluZyB9IGZyb20gJy4uLy4uL2xhbmd1YWdlX3Byb3ZpZGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnk7XG4gIGRhdGFzb3VyY2U6IFByb21ldGhldXNEYXRhc291cmNlO1xuICBvbkNoYW5nZTogKHVwZGF0ZTogUHJvbVZpc3VhbFF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xuICBuZXN0ZWQ/OiBib29sZWFuO1xuICBkYXRhPzogUGFuZWxEYXRhO1xufVxuXG5leHBvcnQgY29uc3QgUHJvbVF1ZXJ5QnVpbGRlciA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IGRhdGFzb3VyY2UsIHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSwgZGF0YSB9KSA9PiB7XG4gIGNvbnN0IG9uQ2hhbmdlTGFiZWxzID0gKGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXSkgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGxhYmVscyB9KTtcbiAgfTtcblxuICAvKipcbiAgICogTWFwIG1ldHJpYyBtZXRhZGF0YSB0byBTZWxlY3RhYmxlVmFsdWUgZm9yIFNlbGVjdCBjb21wb25lbnQgYW5kIGFsc28gYWRkcyBkZWZpbmVkIHRlbXBsYXRlIHZhcmlhYmxlcyB0byB0aGUgbGlzdC5cbiAgICovXG4gIGNvbnN0IHdpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChvcHRpb25zUHJvbWlzZTogUHJvbWlzZTxBcnJheTx7IHZhbHVlOiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH0+Pik6IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+ID0+IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IGRhdGFzb3VyY2UuZ2V0VmFyaWFibGVzKCk7XG4gICAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgb3B0aW9uc1Byb21pc2U7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi52YXJpYWJsZXMubWFwKCh2YWx1ZSkgPT4gKHsgbGFiZWw6IHZhbHVlLCB2YWx1ZSB9KSksXG4gICAgICAgIC4uLm9wdGlvbnMubWFwKChvcHRpb24pID0+ICh7IGxhYmVsOiBvcHRpb24udmFsdWUsIHZhbHVlOiBvcHRpb24udmFsdWUsIHRpdGxlOiBvcHRpb24uZGVzY3JpcHRpb24gfSkpLFxuICAgICAgXTtcbiAgICB9LFxuICAgIFtkYXRhc291cmNlXVxuICApO1xuXG4gIGNvbnN0IG9uR2V0TGFiZWxOYW1lcyA9IGFzeW5jIChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pOiBQcm9taXNlPEFycmF5PHsgdmFsdWU6IHN0cmluZyB9Pj4gPT4ge1xuICAgIC8vIElmIG5vIG1ldHJpYyB3ZSBuZWVkIHRvIHVzZSBhIGRpZmZlcmVudCBtZXRob2RcbiAgICBpZiAoIXF1ZXJ5Lm1ldHJpYykge1xuICAgICAgLy8gVG9kbyBhZGQgY2FjaGluZyBidXQgaW5zaWRlIGxhbmd1YWdlIHByb3ZpZGVyIVxuICAgICAgYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmZldGNoTGFiZWxzKCk7XG4gICAgICByZXR1cm4gZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsS2V5cygpLm1hcCgoaykgPT4gKHsgdmFsdWU6IGsgfSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsc1RvQ29uc2lkZXIgPSBxdWVyeS5sYWJlbHMuZmlsdGVyKCh4KSA9PiB4ICE9PSBmb3JMYWJlbCk7XG4gICAgbGFiZWxzVG9Db25zaWRlci5wdXNoKHsgbGFiZWw6ICdfX25hbWVfXycsIG9wOiAnPScsIHZhbHVlOiBxdWVyeS5tZXRyaWMgfSk7XG4gICAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHNUb0NvbnNpZGVyKTtcbiAgICBjb25zdCBsYWJlbHNJbmRleCA9IGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5mZXRjaFNlcmllc0xhYmVscyhleHByKTtcblxuICAgIC8vIGZpbHRlciBvdXQgYWxyZWFkeSB1c2VkIGxhYmVsc1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsYWJlbHNJbmRleClcbiAgICAgIC5maWx0ZXIoKGxhYmVsTmFtZSkgPT4gIWxhYmVsc1RvQ29uc2lkZXIuZmluZCgoZmlsdGVyKSA9PiBmaWx0ZXIubGFiZWwgPT09IGxhYmVsTmFtZSkpXG4gICAgICAubWFwKChrKSA9PiAoeyB2YWx1ZTogayB9KSk7XG4gIH07XG5cbiAgY29uc3Qgb25HZXRMYWJlbFZhbHVlcyA9IGFzeW5jIChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IHtcbiAgICBpZiAoIWZvckxhYmVsLmxhYmVsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gbWV0cmljIHdlIG5lZWQgdG8gdXNlIGEgZGlmZmVyZW50IG1ldGhvZFxuICAgIGlmICghcXVlcnkubWV0cmljKSB7XG4gICAgICByZXR1cm4gKGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5nZXRMYWJlbFZhbHVlcyhmb3JMYWJlbC5sYWJlbCkpLm1hcCgodikgPT4gKHsgdmFsdWU6IHYgfSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsc1RvQ29uc2lkZXIgPSBxdWVyeS5sYWJlbHMuZmlsdGVyKCh4KSA9PiB4ICE9PSBmb3JMYWJlbCk7XG4gICAgbGFiZWxzVG9Db25zaWRlci5wdXNoKHsgbGFiZWw6ICdfX25hbWVfXycsIG9wOiAnPScsIHZhbHVlOiBxdWVyeS5tZXRyaWMgfSk7XG4gICAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlckxhYmVscyhsYWJlbHNUb0NvbnNpZGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIuZmV0Y2hTZXJpZXNMYWJlbHMoZXhwcik7XG4gICAgY29uc3QgZm9yTGFiZWxJbnRlcnBvbGF0ZWQgPSBkYXRhc291cmNlLmludGVycG9sYXRlU3RyaW5nKGZvckxhYmVsLmxhYmVsKTtcbiAgICByZXR1cm4gcmVzdWx0W2ZvckxhYmVsSW50ZXJwb2xhdGVkXS5tYXAoKHYpID0+ICh7IHZhbHVlOiB2IH0pKSA/PyBbXTtcbiAgfTtcblxuICBjb25zdCBvbkdldE1ldHJpY3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIHdpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyhnZXRNZXRyaWNzKGRhdGFzb3VyY2UsIHF1ZXJ5KSk7XG4gIH0sIFtkYXRhc291cmNlLCBxdWVyeSwgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEVkaXRvclJvdz5cbiAgICAgICAgPE1ldHJpY1NlbGVjdCBxdWVyeT17cXVlcnl9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gb25HZXRNZXRyaWNzPXtvbkdldE1ldHJpY3N9IC8+XG4gICAgICAgIDxMYWJlbEZpbHRlcnNcbiAgICAgICAgICBsYWJlbHNGaWx0ZXJzPXtxdWVyeS5sYWJlbHN9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlTGFiZWxzfVxuICAgICAgICAgIG9uR2V0TGFiZWxOYW1lcz17KGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT5cbiAgICAgICAgICAgIHdpdGhUZW1wbGF0ZVZhcmlhYmxlT3B0aW9ucyhvbkdldExhYmVsTmFtZXMoZm9yTGFiZWwpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBvbkdldExhYmVsVmFsdWVzPXsoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PlxuICAgICAgICAgICAgd2l0aFRlbXBsYXRlVmFyaWFibGVPcHRpb25zKG9uR2V0TGFiZWxWYWx1ZXMoZm9yTGFiZWwpKVxuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgIDwvRWRpdG9yUm93PlxuICAgICAgPE9wZXJhdGlvbnNFZGl0b3JSb3c+XG4gICAgICAgIDxPcGVyYXRpb25MaXN0PFByb21WaXN1YWxRdWVyeT5cbiAgICAgICAgICBxdWVyeU1vZGVsbGVyPXtwcm9tUXVlcnlNb2RlbGxlcn1cbiAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlIGFzIERhdGFTb3VyY2VBcGl9XG4gICAgICAgICAgcXVlcnk9e3F1ZXJ5fVxuICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAvPlxuICAgICAgICA8UHJvbVF1ZXJ5QnVpbGRlckhpbnRzIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9IHF1ZXJ5PXtxdWVyeX0gb25DaGFuZ2U9e29uQ2hhbmdlfSBkYXRhPXtkYXRhfSAvPlxuICAgICAgPC9PcGVyYXRpb25zRWRpdG9yUm93PlxuICAgICAge3F1ZXJ5LmJpbmFyeVF1ZXJpZXMgJiYgcXVlcnkuYmluYXJ5UXVlcmllcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPE5lc3RlZFF1ZXJ5TGlzdCBxdWVyeT17cXVlcnl9IGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gb25SdW5RdWVyeT17b25SdW5RdWVyeX0gLz5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgbWV0cmljcywgZWl0aGVyIGFsbCBvciBmaWx0ZXJlZCBieSBxdWVyeSBwYXJhbS4gSXQgYWxzbyBhZGRzIGRlc2NyaXB0aW9uIHN0cmluZyB0byBlYWNoIG1ldHJpYyBpZiBpdFxuICogZXhpc3RzLlxuICogQHBhcmFtIGRhdGFzb3VyY2VcbiAqIEBwYXJhbSBxdWVyeVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRNZXRyaWNzKFxuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZSxcbiAgcXVlcnk6IFByb21WaXN1YWxRdWVyeVxuKTogUHJvbWlzZTxBcnJheTx7IHZhbHVlOiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH0+PiB7XG4gIC8vIE1ha2VzIHN1cmUgd2UgbG9hZGVkIHRoZSBtZXRhZGF0YSBmb3IgbWV0cmljcy4gVXN1YWxseSB0aGlzIGlzIGRvbmUgaW4gdGhlIHN0YXJ0KCkgbWV0aG9kIG9mIHRoZSBwcm92aWRlciBidXQgd2VcbiAgLy8gZG9uJ3QgdXNlIGl0IHdpdGggdGhlIHZpc3VhbCBidWlsZGVyIGFuZCB0aGVyZSBpcyBubyBuZWVkIHRvIHJ1biBhbGwgdGhlIHN0YXJ0KCkgc2V0dXAgYW55d2F5LlxuICBpZiAoIWRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5tZXRyaWNzTWV0YWRhdGEpIHtcbiAgICBhd2FpdCBkYXRhc291cmNlLmxhbmd1YWdlUHJvdmlkZXIubG9hZE1ldHJpY3NNZXRhZGF0YSgpO1xuICB9XG5cbiAgbGV0IG1ldHJpY3M7XG4gIGlmIChxdWVyeS5sYWJlbHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGV4cHIgPSBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJMYWJlbHMocXVlcnkubGFiZWxzKTtcbiAgICBtZXRyaWNzID0gKGF3YWl0IGRhdGFzb3VyY2UubGFuZ3VhZ2VQcm92aWRlci5nZXRTZXJpZXMoZXhwciwgdHJ1ZSkpWydfX25hbWVfXyddID8/IFtdO1xuICB9IGVsc2Uge1xuICAgIG1ldHJpY3MgPSAoYXdhaXQgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLmdldExhYmVsVmFsdWVzKCdfX25hbWVfXycpKSA/PyBbXTtcbiAgfVxuXG4gIHJldHVybiBtZXRyaWNzLm1hcCgobSkgPT4gKHtcbiAgICB2YWx1ZTogbSxcbiAgICBkZXNjcmlwdGlvbjogZ2V0TWV0YWRhdGFTdHJpbmcobSwgZGF0YXNvdXJjZS5sYW5ndWFnZVByb3ZpZGVyLm1ldHJpY3NNZXRhZGF0YSEpLFxuICB9KSk7XG59XG5cblByb21RdWVyeUJ1aWxkZXIuZGlzcGxheU5hbWUgPSAnUHJvbVF1ZXJ5QnVpbGRlcic7XG4iLCJpbXBvcnQgeyBQYW5lbERhdGEgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGNyZWF0ZVNsaWNlLCBQYXlsb2FkQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcgfSBmcm9tICcuLi9wYXJzaW5nJztcbmltcG9ydCB7IHByb21RdWVyeU1vZGVsbGVyIH0gZnJvbSAnLi4vUHJvbVF1ZXJ5TW9kZWxsZXInO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5QnVpbGRlciB9IGZyb20gJy4vUHJvbVF1ZXJ5QnVpbGRlcic7XG5pbXBvcnQgeyBRdWVyeVByZXZpZXcgfSBmcm9tICcuL1F1ZXJ5UHJldmlldyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgb25DaGFuZ2U6ICh1cGRhdGU6IFByb21RdWVyeSkgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgZGF0YT86IFBhbmVsRGF0YTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZSB7XG4gIHZpc1F1ZXJ5PzogUHJvbVZpc3VhbFF1ZXJ5O1xuICBleHByOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaXMgaGVyZSBqdXN0IHRvIGNvbnRhaW4gdGhlIHRyYW5zbGF0aW9uIGxvZ2ljIGJldHdlZW4gc3RyaW5nIHF1ZXJ5IGFuZCB0aGUgdmlzdWFsIHF1ZXJ5IGJ1aWxkZXIgbW9kZWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQcm9tUXVlcnlCdWlsZGVyQ29udGFpbmVyKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IHF1ZXJ5LCBvbkNoYW5nZSwgb25SdW5RdWVyeSwgZGF0YXNvdXJjZSwgZGF0YSB9ID0gcHJvcHM7XG4gIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcihzdGF0ZVNsaWNlLnJlZHVjZXIsIHsgZXhwcjogcXVlcnkuZXhwciB9KTtcblxuICAvLyBPbmx5IHJlYnVpbGQgdmlzdWFsIHF1ZXJ5IGlmIGV4cHIgY2hhbmdlcyBmcm9tIG91dHNpZGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkaXNwYXRjaChleHByQ2hhbmdlZChxdWVyeS5leHByKSk7XG4gIH0sIFtxdWVyeS5leHByXSk7XG5cbiAgY29uc3Qgb25WaXNRdWVyeUNoYW5nZSA9ICh2aXNRdWVyeTogUHJvbVZpc3VhbFF1ZXJ5KSA9PiB7XG4gICAgY29uc3QgZXhwciA9IHByb21RdWVyeU1vZGVsbGVyLnJlbmRlclF1ZXJ5KHZpc1F1ZXJ5KTtcbiAgICBkaXNwYXRjaCh2aXN1YWxRdWVyeUNoYW5nZSh7IHZpc1F1ZXJ5LCBleHByIH0pKTtcbiAgICBvbkNoYW5nZSh7IC4uLnByb3BzLnF1ZXJ5LCBleHByOiBleHByIH0pO1xuICB9O1xuXG4gIGlmICghc3RhdGUudmlzUXVlcnkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxQcm9tUXVlcnlCdWlsZGVyXG4gICAgICAgIHF1ZXJ5PXtzdGF0ZS52aXNRdWVyeX1cbiAgICAgICAgZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX1cbiAgICAgICAgb25DaGFuZ2U9e29uVmlzUXVlcnlDaGFuZ2V9XG4gICAgICAgIG9uUnVuUXVlcnk9e29uUnVuUXVlcnl9XG4gICAgICAgIGRhdGE9e2RhdGF9XG4gICAgICAvPlxuICAgICAge3F1ZXJ5LnJhd1F1ZXJ5ICYmIDxRdWVyeVByZXZpZXcgcXVlcnk9e3F1ZXJ5LmV4cHJ9IC8+fVxuICAgIDwvPlxuICApO1xufVxuXG5jb25zdCBzdGF0ZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lOiAncHJvbS1idWlsZGVyLWNvbnRhaW5lcicsXG4gIGluaXRpYWxTdGF0ZTogeyBleHByOiAnJyB9IGFzIFN0YXRlLFxuICByZWR1Y2Vyczoge1xuICAgIHZpc3VhbFF1ZXJ5Q2hhbmdlOiAoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjx7IHZpc1F1ZXJ5OiBQcm9tVmlzdWFsUXVlcnk7IGV4cHI6IHN0cmluZyB9PikgPT4ge1xuICAgICAgc3RhdGUuZXhwciA9IGFjdGlvbi5wYXlsb2FkLmV4cHI7XG4gICAgICBzdGF0ZS52aXNRdWVyeSA9IGFjdGlvbi5wYXlsb2FkLnZpc1F1ZXJ5O1xuICAgIH0sXG4gICAgZXhwckNoYW5nZWQ6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHN0cmluZz4pID0+IHtcbiAgICAgIGlmICghc3RhdGUudmlzUXVlcnkgfHwgc3RhdGUuZXhwciAhPT0gYWN0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgc3RhdGUuZXhwciA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgc3RhdGUudmlzUXVlcnkgPSBwYXJzZVJlc3VsdC5xdWVyeTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufSk7XG5cbmNvbnN0IHsgdmlzdWFsUXVlcnlDaGFuZ2UsIGV4cHJDaGFuZ2VkIH0gPSBzdGF0ZVNsaWNlLmFjdGlvbnM7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgcHJvbVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Qcm9tUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBPcGVyYXRpb25MaXN0RXhwbGFpbmVkIH0gZnJvbSAnLi4vc2hhcmVkL09wZXJhdGlvbkxpc3RFeHBsYWluZWQnO1xuaW1wb3J0IHsgT3BlcmF0aW9uRXhwbGFpbmVkQm94IH0gZnJvbSAnLi4vc2hhcmVkL09wZXJhdGlvbkV4cGxhaW5lZEJveCc7XG5pbXBvcnQgeyBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyB9IGZyb20gJy4uL3BhcnNpbmcnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgcXVlcnk6IHN0cmluZztcbiAgbmVzdGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IFByb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBxdWVyeSwgbmVzdGVkIH0pID0+IHtcbiAgY29uc3QgdmlzUXVlcnkgPSBidWlsZFZpc3VhbFF1ZXJ5RnJvbVN0cmluZyhxdWVyeSB8fCAnJykucXVlcnk7XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXswfSBkaXJlY3Rpb249XCJjb2x1bW5cIj5cbiAgICAgIDxPcGVyYXRpb25FeHBsYWluZWRCb3hcbiAgICAgICAgc3RlcE51bWJlcj17MX1cbiAgICAgICAgdGl0bGU9e2Ake3Zpc1F1ZXJ5Lm1ldHJpY30gJHtwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJMYWJlbHModmlzUXVlcnkubGFiZWxzKX1gfVxuICAgICAgPlxuICAgICAgICBGZXRjaCBhbGwgc2VyaWVzIG1hdGNoaW5nIG1ldHJpYyBuYW1lIGFuZCBsYWJlbCBmaWx0ZXJzLlxuICAgICAgPC9PcGVyYXRpb25FeHBsYWluZWRCb3g+XG4gICAgICA8T3BlcmF0aW9uTGlzdEV4cGxhaW5lZDxQcm9tVmlzdWFsUXVlcnk+IHN0ZXBOdW1iZXI9ezJ9IHF1ZXJ5TW9kZWxsZXI9e3Byb21RdWVyeU1vZGVsbGVyfSBxdWVyeT17dmlzUXVlcnl9IC8+XG4gICAgPC9TdGFjaz5cbiAgKTtcbn0pO1xuXG5Qcm9tUXVlcnlCdWlsZGVyRXhwbGFpbmVkLmRpc3BsYXlOYW1lID0gJ1Byb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQnO1xuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBQcm9tZXRoZXVzRGF0YXNvdXJjZSB9IGZyb20gJy4uLy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgcHJvbVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Qcm9tUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyLCBQYW5lbERhdGEsIFF1ZXJ5SGludCB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcgfSBmcm9tICcuLi9wYXJzaW5nJztcbmltcG9ydCB7IEJ1dHRvbiwgVG9vbHRpcCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZTtcbiAgb25DaGFuZ2U6ICh1cGRhdGU6IFByb21WaXN1YWxRdWVyeSkgPT4gdm9pZDtcbiAgZGF0YT86IFBhbmVsRGF0YTtcbn1cblxuZXhwb3J0IGNvbnN0IFByb21RdWVyeUJ1aWxkZXJIaW50cyA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IGRhdGFzb3VyY2UsIHF1ZXJ5LCBvbkNoYW5nZSwgZGF0YSB9KSA9PiB7XG4gIGNvbnN0IFtoaW50cywgc2V0SGludHNdID0gdXNlU3RhdGU8UXVlcnlIaW50W10+KFtdKTtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcHJvbVF1ZXJ5ID0geyBleHByOiBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJRdWVyeShxdWVyeSksIHJlZklkOiAnJyB9O1xuICAgIC8vIEZvciBub3cgc2hvdyBvbmx5IGFjdGlvbmFibGUgaGludHNcbiAgICBjb25zdCBoaW50cyA9IGRhdGFzb3VyY2UuZ2V0UXVlcnlIaW50cyhwcm9tUXVlcnksIGRhdGE/LnNlcmllcyB8fCBbXSkuZmlsdGVyKChoaW50KSA9PiBoaW50LmZpeD8uYWN0aW9uKTtcbiAgICBzZXRIaW50cyhoaW50cyk7XG4gIH0sIFtkYXRhc291cmNlLCBxdWVyeSwgb25DaGFuZ2UsIGRhdGEsIHN0eWxlcy5oaW50XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2hpbnRzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICAgICAge2hpbnRzLm1hcCgoaGludCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPFRvb2x0aXAgY29udGVudD17YCR7aGludC5sYWJlbH0gJHtoaW50LmZpeD8ubGFiZWx9YH0ga2V5PXtoaW50LnR5cGV9PlxuICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbVF1ZXJ5ID0geyBleHByOiBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJRdWVyeShxdWVyeSksIHJlZklkOiAnJyB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9tUXVlcnkgPSBkYXRhc291cmNlLm1vZGlmeVF1ZXJ5KHByb21RdWVyeSwgaGludCEuZml4IS5hY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXN1YWxRdWVyeSA9IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKG5ld1Byb21RdWVyeS5leHByKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uQ2hhbmdlKHZpc3VhbFF1ZXJ5LnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICBmaWxsPVwib3V0bGluZVwiXG4gICAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaGludH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7J2hpbnQ6ICcgKyBoaW50LmZpeD8uYWN0aW9uPy50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICcgJykgKyAnKCknfVxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59KTtcblxuUHJvbVF1ZXJ5QnVpbGRlckhpbnRzLmRpc3BsYXlOYW1lID0gJ1Byb21RdWVyeUJ1aWxkZXJIaW50cyc7XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbnRhaW5lcjogY3NzYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIG1hcmdpbi1ib3R0b206ICR7dGhlbWUuc3BhY2luZygxKX07XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGAsXG4gICAgaGludDogY3NzYFxuICAgICAgbWFyZ2luLXJpZ2h0OiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICAgIGAsXG4gIH07XG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN5bnRoZXRpY0V2ZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRWRpdG9yUm93LCBFZGl0b3JGaWVsZCB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBDb3JlQXBwLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFJhZGlvQnV0dG9uR3JvdXAsIFNlbGVjdCwgU3dpdGNoIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgUXVlcnlPcHRpb25Hcm91cCB9IGZyb20gJy4uL3NoYXJlZC9RdWVyeU9wdGlvbkdyb3VwJztcbmltcG9ydCB7IFByb21RdWVyeSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IEZPUk1BVF9PUFRJT05TLCBJTlRFUlZBTF9GQUNUT1JfT1BUSU9OUyB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvUHJvbVF1ZXJ5RWRpdG9yJztcbmltcG9ydCB7IGdldFF1ZXJ5VHlwZUNoYW5nZUhhbmRsZXIsIGdldFF1ZXJ5VHlwZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL1Byb21FeHBsb3JlRXh0cmFGaWVsZCc7XG5pbXBvcnQgeyBnZXRMZWdlbmRNb2RlTGFiZWwsIFByb21RdWVyeUxlZ2VuZEVkaXRvciB9IGZyb20gJy4vUHJvbVF1ZXJ5TGVnZW5kRWRpdG9yJztcbmltcG9ydCB7IEF1dG9TaXplSW5wdXQgfSBmcm9tICcuLi9zaGFyZWQvQXV0b1NpemVJbnB1dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBxdWVyeTogUHJvbVF1ZXJ5O1xuICBhcHA/OiBDb3JlQXBwO1xuICBvbkNoYW5nZTogKHVwZGF0ZTogUHJvbVF1ZXJ5KSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMgPSBSZWFjdC5tZW1vPFByb3BzPigoeyBxdWVyeSwgYXBwLCBvbkNoYW5nZSwgb25SdW5RdWVyeSB9KSA9PiB7XG4gIGNvbnN0IG9uQ2hhbmdlRm9ybWF0ID0gKHZhbHVlOiBTZWxlY3RhYmxlVmFsdWU8c3RyaW5nPikgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGZvcm1hdDogdmFsdWUudmFsdWUgfSk7XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2hhbmdlU3RlcCA9IChldnQ6IFJlYWN0LkZvcm1FdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGludGVydmFsOiBldnQuY3VycmVudFRhcmdldC52YWx1ZSB9KTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgY29uc3QgcXVlcnlUeXBlT3B0aW9ucyA9IGdldFF1ZXJ5VHlwZU9wdGlvbnMoYXBwID09PSBDb3JlQXBwLkV4cGxvcmUpO1xuICBjb25zdCBvblF1ZXJ5VHlwZUNoYW5nZSA9IGdldFF1ZXJ5VHlwZUNoYW5nZUhhbmRsZXIocXVlcnksIG9uQ2hhbmdlKTtcblxuICBjb25zdCBvbkV4ZW1wbGFyQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuY2hlY2tlZDtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBleGVtcGxhcjogaXNFbmFibGVkIH0pO1xuICAgIG9uUnVuUXVlcnkoKTtcbiAgfTtcblxuICBjb25zdCBvbkludGVydmFsRmFjdG9yQ2hhbmdlID0gKHZhbHVlOiBTZWxlY3RhYmxlVmFsdWU8bnVtYmVyPikgPT4ge1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIGludGVydmFsRmFjdG9yOiB2YWx1ZS52YWx1ZSB9KTtcbiAgICBvblJ1blF1ZXJ5KCk7XG4gIH07XG5cbiAgY29uc3QgZm9ybWF0T3B0aW9uID0gRk9STUFUX09QVElPTlMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUgPT09IHF1ZXJ5LmZvcm1hdCkgfHwgRk9STUFUX09QVElPTlNbMF07XG4gIGNvbnN0IHF1ZXJ5VHlwZVZhbHVlID0gZ2V0UXVlcnlUeXBlVmFsdWUocXVlcnkpO1xuICBjb25zdCBxdWVyeVR5cGVMYWJlbCA9IHF1ZXJ5VHlwZU9wdGlvbnMuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gcXVlcnlUeXBlVmFsdWUpIS5sYWJlbDtcblxuICByZXR1cm4gKFxuICAgIDxFZGl0b3JSb3c+XG4gICAgICA8UXVlcnlPcHRpb25Hcm91cCB0aXRsZT1cIk9wdGlvbnNcIiBjb2xsYXBzZWRJbmZvPXtnZXRDb2xsYXBzZWRJbmZvKHF1ZXJ5LCBmb3JtYXRPcHRpb24ubGFiZWwhLCBxdWVyeVR5cGVMYWJlbCl9PlxuICAgICAgICA8UHJvbVF1ZXJ5TGVnZW5kRWRpdG9yXG4gICAgICAgICAgbGVnZW5kRm9ybWF0PXtxdWVyeS5sZWdlbmRGb3JtYXR9XG4gICAgICAgICAgb25DaGFuZ2U9eyhsZWdlbmRGb3JtYXQpID0+IG9uQ2hhbmdlKHsgLi4ucXVlcnksIGxlZ2VuZEZvcm1hdCB9KX1cbiAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAvPlxuICAgICAgICA8RWRpdG9yRmllbGRcbiAgICAgICAgICBsYWJlbD1cIk1pbiBzdGVwXCJcbiAgICAgICAgICB0b29sdGlwPXtcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgIEFuIGFkZGl0aW9uYWwgbG93ZXIgbGltaXQgZm9yIHRoZSBzdGVwIHBhcmFtZXRlciBvZiB0aGUgUHJvbWV0aGV1cyBxdWVyeSBhbmQgZm9yIHRoZXsnICd9XG4gICAgICAgICAgICAgIDxjb2RlPiRfX2ludGVydmFsPC9jb2RlPiBhbmQgPGNvZGU+JF9fcmF0ZV9pbnRlcnZhbDwvY29kZT4gdmFyaWFibGVzLlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgfVxuICAgICAgICA+XG4gICAgICAgICAgPEF1dG9TaXplSW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJTZXQgbG93ZXIgbGltaXQgZm9yIHRoZSBzdGVwIHBhcmFtZXRlclwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17J2F1dG8nfVxuICAgICAgICAgICAgbWluV2lkdGg9ezEwfVxuICAgICAgICAgICAgb25Db21taXRDaGFuZ2U9e29uQ2hhbmdlU3RlcH1cbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17cXVlcnkuaW50ZXJ2YWx9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiRm9ybWF0XCI+XG4gICAgICAgICAgPFNlbGVjdCB2YWx1ZT17Zm9ybWF0T3B0aW9ufSBhbGxvd0N1c3RvbVZhbHVlIG9uQ2hhbmdlPXtvbkNoYW5nZUZvcm1hdH0gb3B0aW9ucz17Rk9STUFUX09QVElPTlN9IC8+XG4gICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIlR5cGVcIj5cbiAgICAgICAgICA8UmFkaW9CdXR0b25Hcm91cCBvcHRpb25zPXtxdWVyeVR5cGVPcHRpb25zfSB2YWx1ZT17cXVlcnlUeXBlVmFsdWV9IG9uQ2hhbmdlPXtvblF1ZXJ5VHlwZUNoYW5nZX0gLz5cbiAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAge3Nob3VsZFNob3dFeGVtcGxhclN3aXRjaChxdWVyeSwgYXBwKSAmJiAoXG4gICAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiRXhlbXBsYXJzXCI+XG4gICAgICAgICAgICA8U3dpdGNoIHZhbHVlPXtxdWVyeS5leGVtcGxhcn0gb25DaGFuZ2U9e29uRXhlbXBsYXJDaGFuZ2V9IC8+XG4gICAgICAgICAgPC9FZGl0b3JGaWVsZD5cbiAgICAgICAgKX1cbiAgICAgICAge3F1ZXJ5LmludGVydmFsRmFjdG9yICYmIHF1ZXJ5LmludGVydmFsRmFjdG9yID4gMSAmJiAoXG4gICAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiUmVzb2x1dGlvblwiPlxuICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiU2VsZWN0IHJlc29sdXRpb25cIlxuICAgICAgICAgICAgICBtZW51U2hvdWxkUG9ydGFsXG4gICAgICAgICAgICAgIGlzU2VhcmNoYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICAgIG9wdGlvbnM9e0lOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17b25JbnRlcnZhbEZhY3RvckNoYW5nZX1cbiAgICAgICAgICAgICAgdmFsdWU9e0lOVEVSVkFMX0ZBQ1RPUl9PUFRJT05TLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlID09PSBxdWVyeS5pbnRlcnZhbEZhY3Rvcil9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvRWRpdG9yRmllbGQ+XG4gICAgICAgICl9XG4gICAgICA8L1F1ZXJ5T3B0aW9uR3JvdXA+XG4gICAgPC9FZGl0b3JSb3c+XG4gICk7XG59KTtcblxuZnVuY3Rpb24gc2hvdWxkU2hvd0V4ZW1wbGFyU3dpdGNoKHF1ZXJ5OiBQcm9tUXVlcnksIGFwcD86IENvcmVBcHApIHtcbiAgaWYgKGFwcCA9PT0gQ29yZUFwcC5VbmlmaWVkQWxlcnRpbmcgfHwgIXF1ZXJ5LnJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldFF1ZXJ5VHlwZVZhbHVlKHF1ZXJ5OiBQcm9tUXVlcnkpIHtcbiAgcmV0dXJuIHF1ZXJ5LnJhbmdlICYmIHF1ZXJ5Lmluc3RhbnQgPyAnYm90aCcgOiBxdWVyeS5pbnN0YW50ID8gJ2luc3RhbnQnIDogJ3JhbmdlJztcbn1cblxuZnVuY3Rpb24gZ2V0Q29sbGFwc2VkSW5mbyhxdWVyeTogUHJvbVF1ZXJ5LCBmb3JtYXRPcHRpb246IHN0cmluZywgcXVlcnlUeXBlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGl0ZW1zLnB1c2goYExlZ2VuZDogJHtnZXRMZWdlbmRNb2RlTGFiZWwocXVlcnkubGVnZW5kRm9ybWF0KX1gKTtcbiAgaXRlbXMucHVzaChgRm9ybWF0OiAke2Zvcm1hdE9wdGlvbn1gKTtcblxuICBpZiAocXVlcnkuaW50ZXJ2YWwpIHtcbiAgICBpdGVtcy5wdXNoKGBTdGVwICR7cXVlcnkuaW50ZXJ2YWx9YCk7XG4gIH1cblxuICBpdGVtcy5wdXNoKGBUeXBlOiAke3F1ZXJ5VHlwZX1gKTtcblxuICBpZiAocXVlcnkuZXhlbXBsYXIpIHtcbiAgICBpdGVtcy5wdXNoKGBFeGVtcGxhcnM6IHRydWVgKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtcztcbn1cblxuUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMuZGlzcGxheU5hbWUgPSAnUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMnO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByb21RdWVyeUVkaXRvclByb3BzIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy90eXBlcyc7XG5pbXBvcnQgUHJvbVF1ZXJ5RmllbGQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Qcm9tUXVlcnlGaWVsZCc7XG5pbXBvcnQgeyB0ZXN0SWRzIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9Qcm9tUXVlcnlFZGl0b3InO1xuaW1wb3J0IHsgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm9tUXVlcnlDb2RlRWRpdG9yKHtcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIHJhbmdlLFxuICBvblJ1blF1ZXJ5LFxuICBvbkNoYW5nZSxcbiAgZGF0YSxcbiAgYXBwLFxufTogUHJvbVF1ZXJ5RWRpdG9yUHJvcHMpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgIDxQcm9tUXVlcnlGaWVsZFxuICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgIHJhbmdlPXtyYW5nZX1cbiAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICBoaXN0b3J5PXtbXX1cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgZGF0YS10ZXN0aWQ9e3Rlc3RJZHMuZWRpdG9yfVxuICAgICAgICBhcHA9e2FwcH1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgd3JhcHBlciBzdHlsaW5nIGNhbiBiZSByZW1vdmVkIGFmdGVyIHRoZSBvbGQgUHJvbVF1ZXJ5RWRpdG9yIGlzIHJlbW92ZWQuXG4gICAgLy8gVGhpcyBpcyByZW1vdmluZyBtYXJnaW4gYm90dG9tIG9uIHRoZSBvbGQgbGVnYWN5IGlubGluZSBmb3JtIHN0eWxlc1xuICAgIHdyYXBwZXI6IGNzc2BcbiAgICAgIC5nZi1mb3JtIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgIH1cbiAgICBgLFxuICB9O1xufTtcbiIsImltcG9ydCBSZWFjdCwgeyBTeW50aGV0aWNFdmVudCwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBMb2FkaW5nU3RhdGUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEVkaXRvckhlYWRlciwgRWRpdG9yUm93cywgRmxleEl0ZW0sIElubGluZVNlbGVjdCwgU3BhY2UgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgQnV0dG9uLCBDb25maXJtTW9kYWwgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBQcm9tUXVlcnlFZGl0b3JQcm9wcyB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdHlwZXMnO1xuaW1wb3J0IHsgcHJvbVF1ZXJ5TW9kZWxsZXIgfSBmcm9tICcuLi9Qcm9tUXVlcnlNb2RlbGxlcic7XG5pbXBvcnQgeyBRdWVyeUVkaXRvck1vZGVUb2dnbGUgfSBmcm9tICcuLi9zaGFyZWQvUXVlcnlFZGl0b3JNb2RlVG9nZ2xlJztcbmltcG9ydCB7IFF1ZXJ5SGVhZGVyU3dpdGNoIH0gZnJvbSAnLi4vc2hhcmVkL1F1ZXJ5SGVhZGVyU3dpdGNoJztcbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZSB9IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tUXVlcnlCdWlsZGVyRXhwbGFpbmVkIH0gZnJvbSAnLi9Qcm9tUXVlcnlCdWlsZGVyRXhwbGFpbmVkJztcbmltcG9ydCB7IGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nIH0gZnJvbSAnLi4vcGFyc2luZyc7XG5pbXBvcnQgeyBQcm9tUXVlcnlDb2RlRWRpdG9yIH0gZnJvbSAnLi9Qcm9tUXVlcnlDb2RlRWRpdG9yJztcbmltcG9ydCB7IFByb21RdWVyeUJ1aWxkZXJDb250YWluZXIgfSBmcm9tICcuL1Byb21RdWVyeUJ1aWxkZXJDb250YWluZXInO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5QnVpbGRlck9wdGlvbnMgfSBmcm9tICcuL1Byb21RdWVyeUJ1aWxkZXJPcHRpb25zJztcbmltcG9ydCB7IGNoYW5nZUVkaXRvck1vZGUsIGdldFF1ZXJ5V2l0aERlZmF1bHRzIH0gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgRmVlZGJhY2tMaW5rIH0gZnJvbSAnLi4vc2hhcmVkL0ZlZWRiYWNrTGluayc7XG5cbmV4cG9ydCBjb25zdCBQcm9tUXVlcnlFZGl0b3JTZWxlY3RvciA9IFJlYWN0Lm1lbW88UHJvbVF1ZXJ5RWRpdG9yUHJvcHM+KChwcm9wcykgPT4ge1xuICBjb25zdCB7IG9uQ2hhbmdlLCBvblJ1blF1ZXJ5LCBkYXRhIH0gPSBwcm9wcztcbiAgY29uc3QgW3BhcnNlTW9kYWxPcGVuLCBzZXRQYXJzZU1vZGFsT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtkYXRhSXNTdGFsZSwgc2V0RGF0YUlzU3RhbGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IHF1ZXJ5ID0gZ2V0UXVlcnlXaXRoRGVmYXVsdHMocHJvcHMucXVlcnksIHByb3BzLmFwcCk7XG4gIGNvbnN0IGVkaXRvck1vZGUgPSBxdWVyeS5lZGl0b3JNb2RlITtcblxuICBjb25zdCBvbkVkaXRvck1vZGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAobmV3TWV0cmljRWRpdG9yTW9kZTogUXVlcnlFZGl0b3JNb2RlKSA9PiB7XG4gICAgICBpZiAobmV3TWV0cmljRWRpdG9yTW9kZSA9PT0gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcocXVlcnkuZXhwciB8fCAnJyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBlcnJvcnMsIGdpdmUgdXNlciBhIGNoYW5jZSB0byBkZWNpZGUgaWYgdGhleSB3YW50IHRvIGdvIHRvIGJ1aWxkZXIgYXMgdGhhdCBjYW4gbG9vc2Ugc29tZSBkYXRhLlxuICAgICAgICBpZiAocmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBzZXRQYXJzZU1vZGFsT3Blbih0cnVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoYW5nZUVkaXRvck1vZGUocXVlcnksIG5ld01ldHJpY0VkaXRvck1vZGUsIG9uQ2hhbmdlKTtcbiAgICB9LFxuICAgIFtvbkNoYW5nZSwgcXVlcnldXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXREYXRhSXNTdGFsZShmYWxzZSk7XG4gIH0sIFtkYXRhXSk7XG5cbiAgY29uc3Qgb25RdWVyeVByZXZpZXdDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgaXNFbmFibGVkID0gZXZlbnQuY3VycmVudFRhcmdldC5jaGVja2VkO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIHJhd1F1ZXJ5OiBpc0VuYWJsZWQgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25DaGFuZ2VJbnRlcm5hbCA9IChxdWVyeTogUHJvbVF1ZXJ5KSA9PiB7XG4gICAgc2V0RGF0YUlzU3RhbGUodHJ1ZSk7XG4gICAgb25DaGFuZ2UocXVlcnkpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxDb25maXJtTW9kYWxcbiAgICAgICAgaXNPcGVuPXtwYXJzZU1vZGFsT3Blbn1cbiAgICAgICAgdGl0bGU9XCJRdWVyeSBwYXJzaW5nXCJcbiAgICAgICAgYm9keT1cIlRoZXJlIHdlcmUgZXJyb3JzIHdoaWxlIHRyeWluZyB0byBwYXJzZSB0aGUgcXVlcnkuIENvbnRpbnVpbmcgdG8gdmlzdWFsIGJ1aWxkZXIgbWF5IGxvb3NlIHNvbWUgcGFydHMgb2YgdGhlIHF1ZXJ5LlwiXG4gICAgICAgIGNvbmZpcm1UZXh0PVwiQ29udGludWVcIlxuICAgICAgICBvbkNvbmZpcm09eygpID0+IHtcbiAgICAgICAgICBjaGFuZ2VFZGl0b3JNb2RlKHF1ZXJ5LCBRdWVyeUVkaXRvck1vZGUuQnVpbGRlciwgb25DaGFuZ2UpO1xuICAgICAgICAgIHNldFBhcnNlTW9kYWxPcGVuKGZhbHNlKTtcbiAgICAgICAgfX1cbiAgICAgICAgb25EaXNtaXNzPXsoKSA9PiBzZXRQYXJzZU1vZGFsT3BlbihmYWxzZSl9XG4gICAgICAvPlxuICAgICAgPEVkaXRvckhlYWRlcj5cbiAgICAgICAge2VkaXRvck1vZGUgPT09IFF1ZXJ5RWRpdG9yTW9kZS5CdWlsZGVyICYmIChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPElubGluZVNlbGVjdFxuICAgICAgICAgICAgICB2YWx1ZT17bnVsbH1cbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJRdWVyeSBwYXR0ZXJuc1wiXG4gICAgICAgICAgICAgIGFsbG93Q3VzdG9tVmFsdWVcbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBCaXQgY29udm9sdXRlZCBhcyB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB2aXN1YWxRdWVyeSBtb2RlbCBoZXJlLiBNYXliZSB3b3VsZCBtYWtlIHNlbnNlIHRvXG4gICAgICAgICAgICAgICAgLy8gIG1vdmUgaXQgaW5zaWRlIHRoZSBlZGl0b3I/XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmcocXVlcnkuZXhwciB8fCAnJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5Lm9wZXJhdGlvbnMgPSB2YWx1ZT8ub3BlcmF0aW9ucyE7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICBleHByOiBwcm9tUXVlcnlNb2RlbGxlci5yZW5kZXJRdWVyeShyZXN1bHQucXVlcnkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBvcHRpb25zPXtwcm9tUXVlcnlNb2RlbGxlci5nZXRRdWVyeVBhdHRlcm5zKCkubWFwKCh4KSA9PiAoeyBsYWJlbDogeC5uYW1lLCB2YWx1ZTogeCB9KSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPFF1ZXJ5SGVhZGVyU3dpdGNoIGxhYmVsPVwiUmF3IHF1ZXJ5XCIgdmFsdWU9e3F1ZXJ5LnJhd1F1ZXJ5fSBvbkNoYW5nZT17b25RdWVyeVByZXZpZXdDaGFuZ2V9IC8+XG4gICAgICAgICAgPC8+XG4gICAgICAgICl9XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlciAmJiAoXG4gICAgICAgICAgPEZlZWRiYWNrTGluayBmZWVkYmFja1VybD1cImh0dHBzOi8vZ2l0aHViLmNvbS9ncmFmYW5hL2dyYWZhbmEvZGlzY3Vzc2lvbnMvNDc2OTNcIiAvPlxuICAgICAgICApfVxuICAgICAgICA8RmxleEl0ZW0gZ3Jvdz17MX0gLz5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIHZhcmlhbnQ9e2RhdGFJc1N0YWxlID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSd9XG4gICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICBvbkNsaWNrPXtvblJ1blF1ZXJ5fVxuICAgICAgICAgIGljb249e2RhdGE/LnN0YXRlID09PSBMb2FkaW5nU3RhdGUuTG9hZGluZyA/ICdmYSBmYS1zcGlubmVyJyA6IHVuZGVmaW5lZH1cbiAgICAgICAgICBkaXNhYmxlZD17ZGF0YT8uc3RhdGUgPT09IExvYWRpbmdTdGF0ZS5Mb2FkaW5nfVxuICAgICAgICA+XG4gICAgICAgICAgUnVuIHF1ZXJ5XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8UXVlcnlFZGl0b3JNb2RlVG9nZ2xlIG1vZGU9e2VkaXRvck1vZGV9IG9uQ2hhbmdlPXtvbkVkaXRvck1vZGVDaGFuZ2V9IC8+XG4gICAgICA8L0VkaXRvckhlYWRlcj5cbiAgICAgIDxTcGFjZSB2PXswLjV9IC8+XG4gICAgICA8RWRpdG9yUm93cz5cbiAgICAgICAge2VkaXRvck1vZGUgPT09IFF1ZXJ5RWRpdG9yTW9kZS5Db2RlICYmIDxQcm9tUXVlcnlDb2RlRWRpdG9yIHsuLi5wcm9wc30gLz59XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuQnVpbGRlciAmJiAoXG4gICAgICAgICAgPFByb21RdWVyeUJ1aWxkZXJDb250YWluZXJcbiAgICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICAgIGRhdGFzb3VyY2U9e3Byb3BzLmRhdGFzb3VyY2V9XG4gICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2VJbnRlcm5hbH1cbiAgICAgICAgICAgIG9uUnVuUXVlcnk9e3Byb3BzLm9uUnVuUXVlcnl9XG4gICAgICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIHtlZGl0b3JNb2RlID09PSBRdWVyeUVkaXRvck1vZGUuRXhwbGFpbiAmJiA8UHJvbVF1ZXJ5QnVpbGRlckV4cGxhaW5lZCBxdWVyeT17cXVlcnkuZXhwcn0gLz59XG4gICAgICAgIHtlZGl0b3JNb2RlICE9PSBRdWVyeUVkaXRvck1vZGUuRXhwbGFpbiAmJiAoXG4gICAgICAgICAgPFByb21RdWVyeUJ1aWxkZXJPcHRpb25zIHF1ZXJ5PXtxdWVyeX0gYXBwPXtwcm9wcy5hcHB9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gb25SdW5RdWVyeT17b25SdW5RdWVyeX0gLz5cbiAgICAgICAgKX1cbiAgICAgIDwvRWRpdG9yUm93cz5cbiAgICA8Lz5cbiAgKTtcbn0pO1xuXG5Qcm9tUXVlcnlFZGl0b3JTZWxlY3Rvci5kaXNwbGF5TmFtZSA9ICdQcm9tUXVlcnlFZGl0b3JTZWxlY3Rvcic7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRWRpdG9yRmllbGQgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBMZWdlbmRGb3JtYXRNb2RlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgQXV0b1NpemVJbnB1dCB9IGZyb20gJy4uL3NoYXJlZC9BdXRvU2l6ZUlucHV0JztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIGxlZ2VuZEZvcm1hdDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBvbkNoYW5nZTogKGxlZ2VuZEZvcm1hdDogc3RyaW5nKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5jb25zdCBsZWdlbmRNb2RlT3B0aW9ucyA9IFtcbiAge1xuICAgIGxhYmVsOiAnQXV0bycsXG4gICAgdmFsdWU6IExlZ2VuZEZvcm1hdE1vZGUuQXV0byxcbiAgICBkZXNjcmlwdGlvbjogJ09ubHkgaW5jbHVkZXMgdW5pcXVlIGxhYmVscycsXG4gIH0sXG4gIHsgbGFiZWw6ICdWZXJib3NlJywgdmFsdWU6IExlZ2VuZEZvcm1hdE1vZGUuVmVyYm9zZSwgZGVzY3JpcHRpb246ICdBbGwgbGFiZWwgbmFtZXMgYW5kIHZhbHVlcycgfSxcbiAgeyBsYWJlbDogJ0N1c3RvbScsIHZhbHVlOiBMZWdlbmRGb3JtYXRNb2RlLkN1c3RvbSwgZGVzY3JpcHRpb246ICdQcm92aWRlIGEgbmFtaW5nIHRlbXBsYXRlJyB9LFxuXTtcblxuLyoqXG4gKiBUZXN0cyBmb3IgdGhpcyBjb21wb25lbnQgYXJlIG9uIHRoZSBwYXJlbnQgbGV2ZWwgKFByb21RdWVyeUJ1aWxkZXJPcHRpb25zKS5cbiAqL1xuZXhwb3J0IGNvbnN0IFByb21RdWVyeUxlZ2VuZEVkaXRvciA9IFJlYWN0Lm1lbW88UHJvcHM+KCh7IGxlZ2VuZEZvcm1hdCwgb25DaGFuZ2UsIG9uUnVuUXVlcnkgfSkgPT4ge1xuICBjb25zdCBtb2RlID0gZ2V0TGVnZW5kTW9kZShsZWdlbmRGb3JtYXQpO1xuICBjb25zdCBpbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3Qgb25MZWdlbmRGb3JtYXRDaGFuZ2VkID0gKGV2dDogUmVhY3QuRm9ybUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgbGV0IG5ld0Zvcm1hdCA9IGV2dC5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuICAgIGlmIChuZXdGb3JtYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXdGb3JtYXQgPSBMZWdlbmRGb3JtYXRNb2RlLkF1dG87XG4gICAgfVxuXG4gICAgaWYgKG5ld0Zvcm1hdCAhPT0gbGVnZW5kRm9ybWF0KSB7XG4gICAgICBvbkNoYW5nZShuZXdGb3JtYXQpO1xuICAgICAgb25SdW5RdWVyeSgpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbkxlZ2VuZE1vZGVDaGFuZ2VkID0gKHZhbHVlOiBTZWxlY3RhYmxlVmFsdWU8TGVnZW5kRm9ybWF0TW9kZT4pID0+IHtcbiAgICBzd2l0Y2ggKHZhbHVlLnZhbHVlISkge1xuICAgICAgY2FzZSBMZWdlbmRGb3JtYXRNb2RlLkF1dG86XG4gICAgICAgIG9uQ2hhbmdlKExlZ2VuZEZvcm1hdE1vZGUuQXV0byk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZWdlbmRGb3JtYXRNb2RlLkN1c3RvbTpcbiAgICAgICAgb25DaGFuZ2UoJ3t7bGFiZWxfbmFtZX19Jyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgICAgaW5wdXRSZWYuY3VycmVudD8uc2V0U2VsZWN0aW9uUmFuZ2UoMiwgMTIsICdmb3J3YXJkJyk7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlZ2VuZEZvcm1hdE1vZGUuVmVyYm9zZTpcbiAgICAgICAgb25DaGFuZ2UoJycpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgb25SdW5RdWVyeSgpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEVkaXRvckZpZWxkXG4gICAgICBsYWJlbD1cIkxlZ2VuZFwiXG4gICAgICB0b29sdGlwPVwiU2VyaWVzIG5hbWUgb3ZlcnJpZGUgb3IgdGVtcGxhdGUuIEV4LiB7e2hvc3RuYW1lfX0gd2lsbCBiZSByZXBsYWNlZCB3aXRoIGxhYmVsIHZhbHVlIGZvciBob3N0bmFtZS5cIlxuICAgID5cbiAgICAgIDw+XG4gICAgICAgIHttb2RlID09PSBMZWdlbmRGb3JtYXRNb2RlLkN1c3RvbSAmJiAoXG4gICAgICAgICAgPEF1dG9TaXplSW5wdXRcbiAgICAgICAgICAgIGlkPVwibGVnZW5kRm9ybWF0XCJcbiAgICAgICAgICAgIG1pbldpZHRoPXsyMn1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiYXV0b1wiXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU9e2xlZ2VuZEZvcm1hdH1cbiAgICAgICAgICAgIG9uQ29tbWl0Q2hhbmdlPXtvbkxlZ2VuZEZvcm1hdENoYW5nZWR9XG4gICAgICAgICAgICByZWY9e2lucHV0UmVmfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIHttb2RlICE9PSBMZWdlbmRGb3JtYXRNb2RlLkN1c3RvbSAmJiAoXG4gICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgaW5wdXRJZD1cImxlZ2VuZC5tb2RlXCJcbiAgICAgICAgICAgIGlzU2VhcmNoYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlbGVjdCBsZWdlbmQgbW9kZVwiXG4gICAgICAgICAgICBvcHRpb25zPXtsZWdlbmRNb2RlT3B0aW9uc31cbiAgICAgICAgICAgIHdpZHRoPXsyMn1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkxlZ2VuZE1vZGVDaGFuZ2VkfVxuICAgICAgICAgICAgdmFsdWU9e2xlZ2VuZE1vZGVPcHRpb25zLmZpbmQoKHgpID0+IHgudmFsdWUgPT09IG1vZGUpfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8Lz5cbiAgICA8L0VkaXRvckZpZWxkPlxuICApO1xufSk7XG5cblByb21RdWVyeUxlZ2VuZEVkaXRvci5kaXNwbGF5TmFtZSA9ICdQcm9tUXVlcnlMZWdlbmRFZGl0b3InO1xuXG5mdW5jdGlvbiBnZXRMZWdlbmRNb2RlKGxlZ2VuZEZvcm1hdDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gIC8vIFRoaXMgc3BlY2lhbCB2YWx1ZSBtZWFucyB0aGUgbmV3IHNtYXJ0IG1pbmltYWwgc2VyaWVzIG5hbWluZ1xuICBpZiAobGVnZW5kRm9ybWF0ID09PSBMZWdlbmRGb3JtYXRNb2RlLkF1dG8pIHtcbiAgICByZXR1cm4gTGVnZW5kRm9ybWF0TW9kZS5BdXRvO1xuICB9XG5cbiAgLy8gTWlzc2luZyBvciBlbXB0eSBsZWdlbmQgZm9ybWF0IGlzIHRoZSBvbGQgdmVyYm9zZSBiZWhhdmlvclxuICBpZiAobGVnZW5kRm9ybWF0ID09IG51bGwgfHwgbGVnZW5kRm9ybWF0ID09PSAnJykge1xuICAgIHJldHVybiBMZWdlbmRGb3JtYXRNb2RlLlZlcmJvc2U7XG4gIH1cblxuICByZXR1cm4gTGVnZW5kRm9ybWF0TW9kZS5DdXN0b207XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWdlbmRNb2RlTGFiZWwobGVnZW5kRm9ybWF0OiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgY29uc3QgbW9kZSA9IGdldExlZ2VuZE1vZGUobGVnZW5kRm9ybWF0KTtcbiAgaWYgKG1vZGUgIT09IExlZ2VuZEZvcm1hdE1vZGUuQ3VzdG9tKSB7XG4gICAgcmV0dXJuIGxlZ2VuZE1vZGVPcHRpb25zLmZpbmQoKHgpID0+IHgudmFsdWUgPT09IG1vZGUpPy5sYWJlbDtcbiAgfVxuICByZXR1cm4gbGVnZW5kRm9ybWF0O1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IGNzcywgY3ggfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgRWRpdG9yRmllbGQsIEVkaXRvckZpZWxkR3JvdXAsIEVkaXRvclJvdyB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgUHJpc20gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgeyBwcm9tcWxHcmFtbWFyIH0gZnJvbSAnLi4vLi4vcHJvbXFsJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHF1ZXJ5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeVByZXZpZXcoeyBxdWVyeSB9OiBQcm9wcykge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lMigpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhlbWUpO1xuICBjb25zdCBoaWdodGxpZ2h0ZWQgPSBQcmlzbS5oaWdobGlnaHQocXVlcnksIHByb21xbEdyYW1tYXIsICdwcm9tcWwnKTtcblxuICByZXR1cm4gKFxuICAgIDxFZGl0b3JSb3c+XG4gICAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgICAgPEVkaXRvckZpZWxkIGxhYmVsPVwiUmF3IHF1ZXJ5XCI+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjeChzdHlsZXMuZWRpdG9yRmllbGQsICdwcmlzbS1zeW50YXgtaGlnaGxpZ2h0Jyl9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwic2VsZWN0b3JcIlxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBoaWdodGxpZ2h0ZWQgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRvckZpZWxkPlxuICAgICAgPC9FZGl0b3JGaWVsZEdyb3VwPlxuICAgIDwvRWRpdG9yUm93PlxuICApO1xufVxuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlZGl0b3JGaWVsZDogY3NzKHtcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZSxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBMYWJlbFBhcmFtRWRpdG9yIH0gZnJvbSAnLi9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3InO1xuaW1wb3J0IHtcbiAgZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gIGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICBmdW5jdGlvblJlbmRlcmVyUmlnaHQsXG4gIGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUsXG4gIGdldFJhbmdlVmVjdG9yUGFyYW1EZWYsXG4gIHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyxcbiAgcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyxcbn0gZnJvbSAnLi9zaGFyZWQvb3BlcmF0aW9uVXRpbHMnO1xuaW1wb3J0IHtcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5V2l0aE9wZXJhdGlvbnMsXG4gIFZpc3VhbFF1ZXJ5TW9kZWxsZXIsXG59IGZyb20gJy4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IFByb21PcGVyYXRpb25JZCwgUHJvbVZpc3VhbFF1ZXJ5LCBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyB9IGZyb20gJy4vYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25EZWZpbml0aW9ucygpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIGNvbnN0IGxpc3Q6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdID0gW1xuICAgIHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuSGlzdG9ncmFtUXVhbnRpbGUsXG4gICAgICBuYW1lOiAnSGlzdG9ncmFtIHF1YW50aWxlJyxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1F1YW50aWxlJywgdHlwZTogJ251bWJlcicsIG9wdGlvbnM6IFswLjk5LCAwLjk1LCAwLjksIDAuNzUsIDAuNSwgMC4yNV0gfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMC45XSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuTGFiZWxSZXBsYWNlLFxuICAgICAgbmFtZTogJ0xhYmVsIHJlcGxhY2UnLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHsgbmFtZTogJ0Rlc3RpbmF0aW9uIGxhYmVsJywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgeyBuYW1lOiAnUmVwbGFjZW1lbnQnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdTb3VyY2UgbGFiZWwnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICB7IG5hbWU6ICdSZWdleCcsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICBdLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJywgJyQxJywgJycsICcoLiopJ10sXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlclJpZ2h0LFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxuLFxuICAgICAgbmFtZTogJ0xuJyxcbiAgICAgIHBhcmFtczogW10sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5GdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICB9LFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLkNoYW5nZXMpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLlJhdGUsIHRydWUpLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLklyYXRlKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5JbmNyZWFzZSwgdHJ1ZSksXG4gICAgY3JlYXRlUmFuZ2VGdW5jdGlvbihQcm9tT3BlcmF0aW9uSWQuSWRlbHRhKSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5EZWx0YSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Ib2x0V2ludGVycyxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICBnZXRSYW5nZVZlY3RvclBhcmFtRGVmKCksXG4gICAgICAgIHsgbmFtZTogJ1Ntb290aGluZyBGYWN0b3InLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IG5hbWU6ICdUcmVuZCBGYWN0b3InLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgXSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsnJF9faW50ZXJ2YWwnLCAwLjUsIDAuNV0sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdyYW5nZSBmdW5jdGlvbicsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogcmFuZ2VSZW5kZXJlclJpZ2h0V2l0aFBhcmFtcyxcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICAgIGNoYW5nZVR5cGVIYW5kbGVyOiBvcGVyYXRpb25UeXBlQ2hhbmdlZEhhbmRsZXJGb3JSYW5nZUZ1bmN0aW9uLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUHJlZGljdExpbmVhcixcbiAgICAgIHBhcmFtczogW2dldFJhbmdlVmVjdG9yUGFyYW1EZWYoKSwgeyBuYW1lOiAnU2Vjb25kcyBmcm9tIG5vdycsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWyckX19pbnRlcnZhbCcsIDYwXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3JhbmdlIGZ1bmN0aW9uJyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5SYW5nZUZ1bmN0aW9ucyxcbiAgICAgIHJlbmRlcmVyOiByYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICAgICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5RdWFudGlsZU92ZXJUaW1lLFxuICAgICAgcGFyYW1zOiBbZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZigpLCB7IG5hbWU6ICdRdWFudGlsZScsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWyckX19pbnRlcnZhbCcsIDAuNV0sXG4gICAgICBhbHRlcm5hdGl2ZXNLZXk6ICdvdmVydGltZSBmdW5jdGlvbicsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgICByZW5kZXJlcjogcmFuZ2VSZW5kZXJlckxlZnRXaXRoUGFyYW1zLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yLFxuICAgICAgY2hhbmdlVHlwZUhhbmRsZXI6IG9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24sXG4gICAgfSksXG4gICAgLi4uYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyxcbiAgICB7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLk5lc3RlZFF1ZXJ5LFxuICAgICAgbmFtZTogJ0JpbmFyeSBvcGVyYXRpb24gd2l0aCBxdWVyeScsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgZGVmYXVsdFBhcmFtczogW10sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQmluYXJ5T3BzLFxuICAgICAgcmVuZGVyZXI6IChtb2RlbCwgZGVmLCBpbm5lckV4cHIpID0+IGlubmVyRXhwcixcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE5lc3RlZFF1ZXJ5SGFuZGxlcixcbiAgICB9LFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5BYnNlbnQgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BY29zLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5BY29zaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQXNpbixcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuQXNpbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkF0YW4sXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkF0YW5oLFxuICAgICAgY2F0ZWdvcnk6IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LlRyaWdvbm9tZXRyaWMsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkNlaWwgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcCxcbiAgICAgIG5hbWU6ICdDbGFtcCcsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAgeyBuYW1lOiAnTWluaW11bSBTY2FsYXInLCB0eXBlOiAnbnVtYmVyJyB9LFxuICAgICAgICB7IG5hbWU6ICdNYXhpbXVtIFNjYWxhcicsIHR5cGU6ICdudW1iZXInIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzEsIDFdLFxuICAgIH0pLFxuXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcE1heCxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ01heGltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5DbGFtcE1pbixcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ01pbmltdW0gU2NhbGFyJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5Db3MsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkNvc2gsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRheU9mTW9udGgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkRheU9mV2VlayxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5UaW1lLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuRGF5c0luTW9udGgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVGltZSxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuRGVnIH0pLFxuICAgIGNyZWF0ZVJhbmdlRnVuY3Rpb24oUHJvbU9wZXJhdGlvbklkLkRlcml2KSxcbiAgICAvL1xuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5FeHAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkZsb29yIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Hcm91cCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuSG91ciB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLkxhYmVsSm9pbixcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ0Rlc3RpbmF0aW9uIExhYmVsJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlZGl0b3I6IExhYmVsUGFyYW1FZGl0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnU2VwYXJhdG9yJyxcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdTb3VyY2UgTGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlc3RQYXJhbTogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICBlZGl0b3I6IExhYmVsUGFyYW1FZGl0b3IsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGVmYXVsdFBhcmFtczogWycnLCAnLCcsICcnXSxcbiAgICAgIHJlbmRlcmVyOiBsYWJlbEpvaW5SZW5kZXJlcixcbiAgICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGxhYmVsSm9pbkFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLkxvZzEwIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5Mb2cyIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5NaW51dGUgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLk1vbnRoIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUGksXG4gICAgICByZW5kZXJlcjogKG1vZGVsKSA9PiBgJHttb2RlbC5pZH0oKWAsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oe1xuICAgICAgaWQ6IFByb21PcGVyYXRpb25JZC5RdWFudGlsZSxcbiAgICAgIHBhcmFtczogW3sgbmFtZTogJ1ZhbHVlJywgdHlwZTogJ251bWJlcicgfV0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbMV0sXG4gICAgICByZW5kZXJlcjogZnVuY3Rpb25SZW5kZXJlckxlZnQsXG4gICAgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlJhZCB9KSxcbiAgICBjcmVhdGVSYW5nZUZ1bmN0aW9uKFByb21PcGVyYXRpb25JZC5SZXNldHMpLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuUm91bmQsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuRnVuY3Rpb25zLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnVG8gTmVhcmVzdCcsIHR5cGU6ICdudW1iZXInIH1dLFxuICAgICAgZGVmYXVsdFBhcmFtczogWzFdLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHsgaWQ6IFByb21PcGVyYXRpb25JZC5TY2FsYXIgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNnbiB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU2luLCBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlNpbmgsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuVHJpZ29ub21ldHJpYyxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU29ydCB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuU29ydERlc2MgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlNxcnQgfSksXG4gICAgY3JlYXRlRnVuY3Rpb24oeyBpZDogUHJvbU9wZXJhdGlvbklkLlN0ZGRldiB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7XG4gICAgICBpZDogUHJvbU9wZXJhdGlvbklkLlRhbixcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVGFuaCxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5Ucmlnb25vbWV0cmljLFxuICAgIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVGltZSxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwpID0+IGAke21vZGVsLmlkfSgpYCxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuVGltZXN0YW1wIH0pLFxuICAgIGNyZWF0ZUZ1bmN0aW9uKHtcbiAgICAgIGlkOiBQcm9tT3BlcmF0aW9uSWQuVmVjdG9yLFxuICAgICAgcGFyYW1zOiBbeyBuYW1lOiAnVmFsdWUnLCB0eXBlOiAnbnVtYmVyJyB9XSxcbiAgICAgIGRlZmF1bHRQYXJhbXM6IFsxXSxcbiAgICAgIHJlbmRlcmVyOiAobW9kZWwpID0+IGAke21vZGVsLmlkfSgke21vZGVsLnBhcmFtc1swXX0pYCxcbiAgICB9KSxcbiAgICBjcmVhdGVGdW5jdGlvbih7IGlkOiBQcm9tT3BlcmF0aW9uSWQuWWVhciB9KSxcbiAgXTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKGRlZmluaXRpb246IFBhcnRpYWw8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgLi4uZGVmaW5pdGlvbixcbiAgICBpZDogZGVmaW5pdGlvbi5pZCEsXG4gICAgbmFtZTogZGVmaW5pdGlvbi5uYW1lID8/IGdldFByb21BbmRMb2tpT3BlcmF0aW9uRGlzcGxheU5hbWUoZGVmaW5pdGlvbi5pZCEpLFxuICAgIHBhcmFtczogZGVmaW5pdGlvbi5wYXJhbXMgPz8gW10sXG4gICAgZGVmYXVsdFBhcmFtczogZGVmaW5pdGlvbi5kZWZhdWx0UGFyYW1zID8/IFtdLFxuICAgIGNhdGVnb3J5OiBkZWZpbml0aW9uLmNhdGVnb3J5ID8/IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkZ1bmN0aW9ucyxcbiAgICByZW5kZXJlcjogZGVmaW5pdGlvbi5yZW5kZXJlciA/PyAoZGVmaW5pdGlvbi5wYXJhbXMgPyBmdW5jdGlvblJlbmRlcmVyUmlnaHQgOiBmdW5jdGlvblJlbmRlcmVyTGVmdCksXG4gICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmaW5pdGlvbi5hZGRPcGVyYXRpb25IYW5kbGVyID8/IGRlZmF1bHRBZGRPcGVyYXRpb25IYW5kbGVyLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmFuZ2VGdW5jdGlvbihuYW1lOiBzdHJpbmcsIHdpdGhSYXRlSW50ZXJ2YWwgPSBmYWxzZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IG5hbWUsXG4gICAgbmFtZTogZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKSxcbiAgICBwYXJhbXM6IFtnZXRSYW5nZVZlY3RvclBhcmFtRGVmKHdpdGhSYXRlSW50ZXJ2YWwpXSxcbiAgICBkZWZhdWx0UGFyYW1zOiBbd2l0aFJhdGVJbnRlcnZhbCA/ICckX19yYXRlX2ludGVydmFsJyA6ICckX19pbnRlcnZhbCddLFxuICAgIGFsdGVybmF0aXZlc0tleTogJ3JhbmdlIGZ1bmN0aW9uJyxcbiAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuUmFuZ2VGdW5jdGlvbnMsXG4gICAgcmVuZGVyZXI6IG9wZXJhdGlvbldpdGhSYW5nZVZlY3RvclJlbmRlcmVyLFxuICAgIGFkZE9wZXJhdGlvbkhhbmRsZXI6IGFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvcixcbiAgICBjaGFuZ2VUeXBlSGFuZGxlcjogb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbixcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3BlcmF0aW9uVHlwZUNoYW5nZWRIYW5kbGVyRm9yUmFuZ2VGdW5jdGlvbihcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIG5ld0RlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmXG4pIHtcbiAgLy8gdmFsaWRhdGUgY3VycmVudCBwYXJhbWV0ZXJcbiAgaWYgKG9wZXJhdGlvbi5wYXJhbXNbMF0gPT09ICckX19yYXRlX2ludGVydmFsJyAmJiBuZXdEZWYuZGVmYXVsdFBhcmFtc1swXSAhPT0gJyRfX3JhdGVfaW50ZXJ2YWwnKSB7XG4gICAgb3BlcmF0aW9uLnBhcmFtcyA9IG5ld0RlZi5kZWZhdWx0UGFyYW1zO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXJhbXNbMF0gPT09ICckX19pbnRlcnZhbCcgJiYgbmV3RGVmLmRlZmF1bHRQYXJhbXNbMF0gIT09ICckX19pbnRlcnZhbCcpIHtcbiAgICBvcGVyYXRpb24ucGFyYW1zID0gbmV3RGVmLmRlZmF1bHRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gb3BlcmF0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yUmVuZGVyZXIoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIGxldCByYW5nZVZlY3RvciA9IChtb2RlbC5wYXJhbXMgPz8gW10pWzBdID8/ICc1bSc7XG4gIHJldHVybiBgJHtkZWYuaWR9KCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV0pYDtcbn1cblxuLyoqXG4gKiBTaW5jZSB0aGVyZSBjYW4gb25seSBiZSBvbmUgb3BlcmF0aW9uIHdpdGggcmFuZ2UgdmVjdG9yIHRoaXMgd2lsbCByZXBsYWNlIHRoZSBjdXJyZW50IG9uZSAoaWYgb25lIHdhcyBhZGRlZCApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRPcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3IoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5LFxuICBtb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlclxuKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICBpZiAocXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgLy8gSWYgb3BlcmF0aW9uIGV4aXN0cyBpdCBoYXMgdG8gYmUgaW4gdGhlIHJlZ2lzdHJ5IHNvIG5vIHBvaW50IHRvIGNoZWNrIGlmIGl0IHdhcyBmb3VuZFxuICAgIGNvbnN0IGZpcnN0T3AgPSBtb2RlbGxlci5nZXRPcGVyYXRpb25EZWYocXVlcnkub3BlcmF0aW9uc1swXS5pZCkhO1xuXG4gICAgaWYgKGZpcnN0T3AuYWRkT3BlcmF0aW9uSGFuZGxlciA9PT0gYWRkT3BlcmF0aW9uV2l0aFJhbmdlVmVjdG9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgb3BlcmF0aW9uczogW25ld09wZXJhdGlvbiwgLi4ucXVlcnkub3BlcmF0aW9ucy5zbGljZSgxKV0sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgb3BlcmF0aW9uczogW25ld09wZXJhdGlvbiwgLi4ucXVlcnkub3BlcmF0aW9uc10sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE5lc3RlZFF1ZXJ5SGFuZGxlcihkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgcXVlcnk6IFByb21WaXN1YWxRdWVyeSk6IFByb21WaXN1YWxRdWVyeSB7XG4gIHJldHVybiB7XG4gICAgLi4ucXVlcnksXG4gICAgYmluYXJ5UXVlcmllczogW1xuICAgICAgLi4uKHF1ZXJ5LmJpbmFyeVF1ZXJpZXMgPz8gW10pLFxuICAgICAge1xuICAgICAgICBvcGVyYXRvcjogJy8nLFxuICAgICAgICBxdWVyeSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGFiZWxKb2luUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwucGFyYW1zWzFdICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93ICdUaGUgc2VwYXJhdG9yIG11c3QgYmUgYSBzdHJpbmcnO1xuICB9XG4gIGNvbnN0IHNlcGFyYXRvciA9IGBcIiR7bW9kZWwucGFyYW1zWzFdfVwiYDtcbiAgcmV0dXJuIGAke21vZGVsLmlkfSgke2lubmVyRXhwcn0sIFwiJHttb2RlbC5wYXJhbXNbMF19XCIsICR7c2VwYXJhdG9yfSwgXCIke21vZGVsLnBhcmFtcy5zbGljZSgyKS5qb2luKHNlcGFyYXRvcil9XCIpYDtcbn1cblxuZnVuY3Rpb24gbGFiZWxKb2luQWRkT3BlcmF0aW9uSGFuZGxlcjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBUKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFsuLi5xdWVyeS5vcGVyYXRpb25zLCBuZXdPcGVyYXRpb25dLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnbGV6ZXItcHJvbXFsJztcbmltcG9ydCB7IFN5bnRheE5vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnksIFByb21WaXN1YWxRdWVyeUJpbmFyeSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgYmluYXJ5U2NhbGFyRGVmcyB9IGZyb20gJy4vYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyc7XG5pbXBvcnQge1xuICBFcnJvck5hbWUsXG4gIGdldEFsbEJ5VHlwZSxcbiAgZ2V0TGVmdE1vc3RDaGlsZCxcbiAgZ2V0U3RyaW5nLFxuICBtYWtlQmluT3AsXG4gIG1ha2VFcnJvcixcbiAgcmVwbGFjZVZhcmlhYmxlcyxcbn0gZnJvbSAnLi9zaGFyZWQvcGFyc2luZ1V0aWxzJztcblxuLyoqXG4gKiBQYXJzZXMgYSBQcm9tUUwgcXVlcnkgaW50byBhIHZpc3VhbCBxdWVyeSBtb2RlbC5cbiAqXG4gKiBJdCB0cmF2ZXJzZXMgdGhlIHRyZWUgYW5kIHVzZXMgc29ydCBvZiBzdGF0ZSBtYWNoaW5lIHRvIHVwZGF0ZSB0aGUgcXVlcnkgbW9kZWwuIFRoZSBxdWVyeSBtb2RlbCBpcyBtb2RpZmllZFxuICogZHVyaW5nIHRoZSB0cmF2ZXJzYWwgYW5kIHNlbnQgdG8gZWFjaCBoYW5kbGVyIGFzIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGV4cHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVmlzdWFsUXVlcnlGcm9tU3RyaW5nKGV4cHI6IHN0cmluZyk6IENvbnRleHQge1xuICBjb25zdCByZXBsYWNlZEV4cHIgPSByZXBsYWNlVmFyaWFibGVzKGV4cHIpO1xuICBjb25zdCB0cmVlID0gcGFyc2VyLnBhcnNlKHJlcGxhY2VkRXhwcik7XG4gIGNvbnN0IG5vZGUgPSB0cmVlLnRvcE5vZGU7XG5cbiAgLy8gVGhpcyB3aWxsIGJlIG1vZGlmaWVkIGluIHRoZSBoYW5kbGVycy5cbiAgY29uc3QgdmlzUXVlcnk6IFByb21WaXN1YWxRdWVyeSA9IHtcbiAgICBtZXRyaWM6ICcnLFxuICAgIGxhYmVsczogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gIH07XG4gIGNvbnN0IGNvbnRleHQ6IENvbnRleHQgPSB7XG4gICAgcXVlcnk6IHZpc1F1ZXJ5LFxuICAgIGVycm9yczogW10sXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBoYW5kbGVFeHByZXNzaW9uKHJlcGxhY2VkRXhwciwgbm9kZSwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIE5vdCBpZGVhbCB0byBsb2cgaXQgaGVyZSwgYnV0IG90aGVyd2lzZSB3ZSB3b3VsZCBsb3NlIHRoZSBzdGFjayB0cmFjZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgY29udGV4dC5lcnJvcnMucHVzaCh7XG4gICAgICB0ZXh0OiBlcnIubWVzc2FnZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgZW1wdHkgcXVlcnksIHdlIHdhbnQgdG8gcmVzZXQgZXJyb3JzXG4gIGlmIChpc0VtcHR5UXVlcnkoY29udGV4dC5xdWVyeSkpIHtcbiAgICBjb250ZXh0LmVycm9ycyA9IFtdO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5pbnRlcmZhY2UgUGFyc2luZ0Vycm9yIHtcbiAgdGV4dDogc3RyaW5nO1xuICBmcm9tPzogbnVtYmVyO1xuICB0bz86IG51bWJlcjtcbiAgcGFyZW50VHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENvbnRleHQge1xuICBxdWVyeTogUHJvbVZpc3VhbFF1ZXJ5O1xuICBlcnJvcnM6IFBhcnNpbmdFcnJvcltdO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGRlZmF1bHQgc3RhdGUuIEl0IHdpbGwgdHJhdmVyc2UgdGhlIHRyZWUgYW5kIGNhbGwgdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIGVhY2ggbm9kZS4gVGhlIG5vZGVcbiAqIGhhbmRsZWQgaGVyZSBkb2VzIG5vdCBuZWNlc3NhcmlseSBuZWVkIHRvIGJlIG9mIHR5cGUgPT0gRXhwci5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV4cHJlc3Npb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgc3dpdGNoIChub2RlLm5hbWUpIHtcbiAgICBjYXNlICdNZXRyaWNJZGVudGlmaWVyJzoge1xuICAgICAgLy8gRXhwZWN0YXRpb24gaXMgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBvZiB0aG9zZSBwZXIgcXVlcnkuXG4gICAgICB2aXNRdWVyeS5tZXRyaWMgPSBnZXRTdHJpbmcoZXhwciwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMYWJlbE1hdGNoZXInOiB7XG4gICAgICAvLyBTYW1lIGFzIE1ldHJpY0lkZW50aWZpZXIgc2hvdWxkIGJlIGp1c3Qgb25lIHBlciBxdWVyeS5cbiAgICAgIHZpc1F1ZXJ5LmxhYmVscy5wdXNoKGdldExhYmVsKGV4cHIsIG5vZGUpKTtcbiAgICAgIGNvbnN0IGVyciA9IG5vZGUuZ2V0Q2hpbGQoRXJyb3JOYW1lKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgZXJyKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGwnOiB7XG4gICAgICBoYW5kbGVGdW5jdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0FnZ3JlZ2F0ZUV4cHInOiB7XG4gICAgICBoYW5kbGVBZ2dyZWdhdGlvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0JpbmFyeUV4cHInOiB7XG4gICAgICBoYW5kbGVCaW5hcnkoZXhwciwgbm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIEVycm9yTmFtZToge1xuICAgICAgaWYgKGlzSW50ZXJ2YWxWYXJpYWJsZUVycm9yKG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGV4dC5lcnJvcnMucHVzaChtYWtlRXJyb3IoZXhwciwgbm9kZSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ1BhcmVuRXhwcicpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBwYXJlbnRoZXNpcyBpbiB0aGUgcXVlcnkgdG8gZ3JvdXAgZXhwcmVzc2lvbnMuIFdlIGp1c3QgcmVwb3J0IGVycm9yIGJ1dCBnbyBvbiB3aXRoIHRoZVxuICAgICAgICAvLyBwYXJzaW5nLlxuICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG1ha2VFcnJvcihleHByLCBub2RlKSk7XG4gICAgICB9XG4gICAgICAvLyBBbnkgb3RoZXIgbm9kZXMgd2UganVzdCBpZ25vcmUgYW5kIGdvIHRvIGl0J3MgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIGZpbmUgYXMgdGhlcmUgYXJlIGxvdCdzIG9mIHdyYXBwZXJcbiAgICAgIC8vIG5vZGVzIHRoYXQgY2FuIGJlIHNraXBwZWQuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBhcmUgcHJvYmFibHkgY2FzZXMgd2hlcmUgd2Ugd2lsbCBqdXN0IHNraXAgbm9kZXMgd2UgZG9uJ3Qgc3VwcG9ydCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgIC8vICBkZXRlY3QgdGhvc2UgYW5kIHJlcG9ydCBiYWNrLlxuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVydmFsVmFyaWFibGVFcnJvcihub2RlOiBTeW50YXhOb2RlKSB7XG4gIHJldHVybiBub2RlLnByZXZTaWJsaW5nPy5uYW1lID09PSAnRXhwcicgJiYgbm9kZS5wcmV2U2libGluZz8uZmlyc3RDaGlsZD8ubmFtZSA9PT0gJ1ZlY3RvclNlbGVjdG9yJztcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWwoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlKTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBjb25zdCBsYWJlbCA9IGdldFN0cmluZyhleHByLCBub2RlLmdldENoaWxkKCdMYWJlbE5hbWUnKSk7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ01hdGNoT3AnKSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3RyaW5nKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ1N0cmluZ0xpdGVyYWwnKSkucmVwbGFjZSgvXCIvZywgJycpO1xuICByZXR1cm4ge1xuICAgIGxhYmVsLFxuICAgIG9wLFxuICAgIHZhbHVlLFxuICB9O1xufVxuXG5jb25zdCByYW5nZUZ1bmN0aW9ucyA9IFsnY2hhbmdlcycsICdyYXRlJywgJ2lyYXRlJywgJ2luY3JlYXNlJywgJ2RlbHRhJ107XG4vKipcbiAqIEhhbmRsZSBmdW5jdGlvbiBjYWxsIHdoaWNoIGlzIHVzdWFsbHkgYW5kIGlkZW50aWZpZXIgYW5kIGl0cyBib2R5ID4gYXJndW1lbnRzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVGdW5jdGlvbihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUsIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgY29uc3QgdmlzUXVlcnkgPSBjb250ZXh0LnF1ZXJ5O1xuICBjb25zdCBuYW1lTm9kZSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uSWRlbnRpZmllcicpO1xuICBjb25zdCBmdW5jTmFtZSA9IGdldFN0cmluZyhleHByLCBuYW1lTm9kZSk7XG5cbiAgY29uc3QgYm9keSA9IG5vZGUuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEJvZHknKTtcbiAgY29uc3QgY2FsbEFyZ3MgPSBib2R5IS5nZXRDaGlsZCgnRnVuY3Rpb25DYWxsQXJncycpO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgbGV0IGludGVydmFsID0gJyc7XG5cbiAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIHNob3J0Y3V0IHRvIGdldCB0aGUgaW50ZXJ2YWwgYXJndW1lbnQuIFJlYXNvbnMgYXJlXG4gIC8vIC0gaW50ZXJ2YWwgaXMgbm90IHBhcnQgb2YgdGhlIGZ1bmN0aW9uIGFyZ3MgcGVyIHByb21RTCBncmFtbWFyIGJ1dCB3ZSBtb2RlbCBpdCBhcyBhcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGluXG4gIC8vICAgdGhlIHF1ZXJ5IG1vZGVsLlxuICAvLyAtIGl0IGlzIGVhc2llciB0byBoYW5kbGUgdGVtcGxhdGUgdmFyaWFibGVzIHRoaXMgd2F5IGFzIHRlbXBsYXRlIHZhcmlhYmxlIGlzIGFuIGVycm9yIGZvciB0aGUgcGFyc2VyXG4gIGlmIChyYW5nZUZ1bmN0aW9ucy5pbmNsdWRlcyhmdW5jTmFtZSkgfHwgZnVuY05hbWUuZW5kc1dpdGgoJ19vdmVyX3RpbWUnKSkge1xuICAgIGxldCBtYXRjaCA9IGdldFN0cmluZyhleHByLCBub2RlKS5tYXRjaCgvXFxbKC4rKVxcXS8pO1xuICAgIGlmIChtYXRjaD8uWzFdKSB7XG4gICAgICBpbnRlcnZhbCA9IG1hdGNoWzFdO1xuICAgICAgcGFyYW1zLnB1c2gobWF0Y2hbMV0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wID0geyBpZDogZnVuY05hbWUsIHBhcmFtcyB9O1xuICAvLyBXZSB1bnNoaWZ0IG9wZXJhdGlvbnMgdG8ga2VlcCB0aGUgbW9yZSBuYXR1cmFsIG9yZGVyIHRoYXQgd2Ugd2FudCB0byBoYXZlIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICB2aXNRdWVyeS5vcGVyYXRpb25zLnVuc2hpZnQob3ApO1xuXG4gIGlmIChjYWxsQXJncykge1xuICAgIGlmIChnZXRTdHJpbmcoZXhwciwgY2FsbEFyZ3MpID09PSBpbnRlcnZhbCArICddJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgZnVuY3Rpb24gd2l0aCBhIHNpbmdsZSBhcmd1bWVudCBhbmQgaXQgaXMgdGhlIGludGVydmFsLlxuICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4geW91IHN0YXJ0IGFkZGluZyBvcGVyYXRpb25zIGluIHF1ZXJ5IGJ1aWxkZXIgYW5kIGRpZCBub3Qgc2V0IGEgbWV0cmljIHlldC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgYWdncmVnYXRpb24gYXMgdGhleSBhcmUgZGlzdGluY3QgdHlwZSBmcm9tIG90aGVyIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQWdncmVnYXRpb24oZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbmFtZU5vZGUgPSBub2RlLmdldENoaWxkKCdBZ2dyZWdhdGVPcCcpO1xuICBsZXQgZnVuY05hbWUgPSBnZXRTdHJpbmcoZXhwciwgbmFtZU5vZGUpO1xuXG4gIGNvbnN0IG1vZGlmaWVyID0gbm9kZS5nZXRDaGlsZCgnQWdncmVnYXRlTW9kaWZpZXInKTtcbiAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgaWYgKG1vZGlmaWVyKSB7XG4gICAgY29uc3QgYnlNb2RpZmllciA9IG1vZGlmaWVyLmdldENoaWxkKGBCeWApO1xuICAgIGlmIChieU1vZGlmaWVyICYmIGZ1bmNOYW1lKSB7XG4gICAgICBmdW5jTmFtZSA9IGBfXyR7ZnVuY05hbWV9X2J5YDtcbiAgICB9XG5cbiAgICBjb25zdCB3aXRob3V0TW9kaWZpZXIgPSBtb2RpZmllci5nZXRDaGlsZChgV2l0aG91dGApO1xuICAgIGlmICh3aXRob3V0TW9kaWZpZXIpIHtcbiAgICAgIGZ1bmNOYW1lID0gYF9fJHtmdW5jTmFtZX1fd2l0aG91dGA7XG4gICAgfVxuXG4gICAgbGFiZWxzLnB1c2goLi4uZ2V0QWxsQnlUeXBlKGV4cHIsIG1vZGlmaWVyLCAnR3JvdXBpbmdMYWJlbCcpKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHkgPSBub2RlLmdldENoaWxkKCdGdW5jdGlvbkNhbGxCb2R5Jyk7XG4gIGNvbnN0IGNhbGxBcmdzID0gYm9keSEuZ2V0Q2hpbGQoJ0Z1bmN0aW9uQ2FsbEFyZ3MnKTtcblxuICBjb25zdCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyBpZDogZnVuY05hbWUsIHBhcmFtczogW10gfTtcbiAgdmlzUXVlcnkub3BlcmF0aW9ucy51bnNoaWZ0KG9wKTtcbiAgdXBkYXRlRnVuY3Rpb25BcmdzKGV4cHIsIGNhbGxBcmdzLCBjb250ZXh0LCBvcCk7XG4gIC8vIFdlIGFkZCBsYWJlbHMgYWZ0ZXIgcGFyYW1zIGluIHRoZSB2aXN1YWwgcXVlcnkgZWRpdG9yLlxuICBvcC5wYXJhbXMucHVzaCguLi5sYWJlbHMpO1xufVxuXG4vKipcbiAqIEhhbmRsZSAocHJvYmFibHkpIGFsbCB0eXBlcyBvZiBhcmd1bWVudHMgdGhhdCBmdW5jdGlvbiBvciBhZ2dyZWdhdGlvbiBjYW4gaGF2ZS5cbiAqXG4gKiAgRnVuY3Rpb25DYWxsQXJncyBhcmUgbmVzdGVkIGJpdCB3ZWlyZGx5IGJhc2ljYWxseSBpdHMgW2ZpcnN0QXJnLCAuLi5yZXN0XSB3aGVyZSByZXN0IGlzIGFnYWluIEZ1bmN0aW9uQ2FsbEFyZ3Mgc29cbiAqICB3ZSBjYW5ub3QganVzdCBnZXQgYWxsIHRoZSBjaGlsZHJlbiBhbmQgaXRlcmF0ZSB0aGVtIGFzIGFyZ3VtZW50cyB3ZSBoYXZlIHRvIGFnYWluIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRocm91Z2hcbiAqICB0aGVtLlxuICpcbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBvcCAtIFdlIG5lZWQgdGhlIG9wZXJhdGlvbiB0byBhZGQgdGhlIHBhcmFtcyB0byBhcyBhbiBhZGRpdGlvbmFsIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUgfCBudWxsLCBjb250ZXh0OiBDb250ZXh0LCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzd2l0Y2ggKG5vZGUubmFtZSkge1xuICAgIC8vIEluIGNhc2Ugd2UgaGF2ZSBhbiBleHByZXNzaW9uIHdlIGRvbid0IGtub3cgd2hhdCBraW5kIHNvIHdlIGhhdmUgdG8gbG9vayBhdCB0aGUgY2hpbGQgYXMgaXQgY2FuIGJlIGFueXRoaW5nLlxuICAgIGNhc2UgJ0V4cHInOlxuICAgIC8vIEZ1bmN0aW9uQ2FsbEFyZ3MgYXJlIG5lc3RlZCBiaXQgd2VpcmRseSBhcyBtZW50aW9uZWQgc28gd2UgaGF2ZSB0byBnbyBvbmUgZGVlcGVyIGluIHRoaXMgY2FzZS5cbiAgICBjYXNlICdGdW5jdGlvbkNhbGxBcmdzJzoge1xuICAgICAgbGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHVwZGF0ZUZ1bmN0aW9uQXJncyhleHByLCBjaGlsZCwgY29udGV4dCwgb3ApO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6IHtcbiAgICAgIG9wLnBhcmFtcy5wdXNoKHBhcnNlRmxvYXQoZ2V0U3RyaW5nKGV4cHIsIG5vZGUpKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzoge1xuICAgICAgb3AucGFyYW1zLnB1c2goZ2V0U3RyaW5nKGV4cHIsIG5vZGUpLnJlcGxhY2UoL1wiL2csICcnKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICAvLyBNZWFucyB3ZSBnZXQgdG8gc29tZXRoaW5nIHRoYXQgZG9lcyBub3Qgc2VlbSBsaWtlIHNpbXBsZSBmdW5jdGlvbiBhcmcgYW5kIGlzIHByb2JhYmx5IG5lc3RlZCBxdWVyeSBzbyBqdW1wXG4gICAgICAvLyBiYWNrIHRvIG1haW4gY29udGV4dFxuICAgICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCBub2RlLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgb3BlcmF0b3JUb09wTmFtZSA9IGJpbmFyeVNjYWxhckRlZnMucmVkdWNlKChhY2MsIGRlZikgPT4ge1xuICBhY2NbZGVmLnNpZ25dID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgY29tcGFyaXNvbjogZGVmLmNvbXBhcmlzb24sXG4gIH07XG4gIHJldHVybiBhY2M7XG59LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCB7IGlkOiBzdHJpbmc7IGNvbXBhcmlzb24/OiBib29sZWFuIH0+KTtcblxuLyoqXG4gKiBSaWdodCBub3cgYmluYXJ5IGV4cHJlc3Npb25zIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheSBpbiB2aXN1YWwgcXVlcnkuIEFzIGFkZGl0aW9uYWwgb3BlcmF0aW9uIGluIGNhc2UgaXQgaXNcbiAqIGp1c3Qgb3BlcmF0aW9uIHdpdGggc2NhbGFyIG9yIGl0IGNyZWF0ZXMgYSBiaW5hcnlRdWVyeSB3aGVuIGl0J3MgMiBxdWVyaWVzLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBoYW5kbGVCaW5hcnkoZXhwcjogc3RyaW5nLCBub2RlOiBTeW50YXhOb2RlLCBjb250ZXh0OiBDb250ZXh0KSB7XG4gIGNvbnN0IHZpc1F1ZXJ5ID0gY29udGV4dC5xdWVyeTtcbiAgY29uc3QgbGVmdCA9IG5vZGUuZmlyc3RDaGlsZCE7XG4gIGNvbnN0IG9wID0gZ2V0U3RyaW5nKGV4cHIsIGxlZnQubmV4dFNpYmxpbmcpO1xuICBjb25zdCBiaW5Nb2RpZmllciA9IGdldEJpbmFyeU1vZGlmaWVyKGV4cHIsIG5vZGUuZ2V0Q2hpbGQoJ0Jpbk1vZGlmaWVycycpKTtcblxuICBjb25zdCByaWdodCA9IG5vZGUubGFzdENoaWxkITtcblxuICBjb25zdCBvcERlZiA9IG9wZXJhdG9yVG9PcE5hbWVbb3BdO1xuXG4gIGNvbnN0IGxlZnROdW1iZXIgPSBsZWZ0LmdldENoaWxkKCdOdW1iZXJMaXRlcmFsJyk7XG4gIGNvbnN0IHJpZ2h0TnVtYmVyID0gcmlnaHQuZ2V0Q2hpbGQoJ051bWJlckxpdGVyYWwnKTtcblxuICBjb25zdCByaWdodEJpbmFyeSA9IHJpZ2h0LmdldENoaWxkKCdCaW5hcnlFeHByJyk7XG5cbiAgaWYgKGxlZnROdW1iZXIpIHtcbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBhbHJlYWR5IGhhbmRsZWQgaW4gY2FzZSBwYXJlbnQgaXMgYmluYXJ5IGV4cHJlc3Npb24gYXMgaXQgaGFzIHRvIGJlIGFkZGVkIHRvIHBhcmVudFxuICAgIC8vICBpZiBxdWVyeSBzdGFydHMgd2l0aCBhIG51bWJlciB0aGF0IGlzbid0IGhhbmRsZWQgbm93LlxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoaXMgaXMgYmluYXJ5IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIHRoZXJlIGlzIGEgcXVlcnkgb3IganVzdCBjaGFpbmVkIHNjYWxhcnMuIFNvXG4gICAgLy8gd2UgaGF2ZSB0byB0cmF2ZXJzZSBhIGJpdCBkZWVwZXIgdG8ga25vd1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgbGVmdCwgY29udGV4dCk7XG4gIH1cblxuICBpZiAocmlnaHROdW1iZXIpIHtcbiAgICB2aXNRdWVyeS5vcGVyYXRpb25zLnB1c2gobWFrZUJpbk9wKG9wRGVmLCBleHByLCByaWdodCwgISFiaW5Nb2RpZmllcj8uaXNCb29sKSk7XG4gIH0gZWxzZSBpZiAocmlnaHRCaW5hcnkpIHtcbiAgICAvLyBEdWUgdG8gdGhlIHdheSBiaW5hcnkgb3BzIGFyZSBwYXJzZWQgd2UgY2FuIGdldCBhIGJpbmFyeSBvcGVyYXRpb24gb24gdGhlIHJpZ2h0IHRoYXQgc3RhcnRzIHdpdGggYSBudW1iZXIgd2hpY2hcbiAgICAvLyBpcyBhIGZhY3RvciBmb3IgYSBjdXJyZW50IGJpbmFyeSBvcGVyYXRpb24uIFNvIHdlIGhhdmUgdG8gYWRkIGl0IGFzIGFuIG9wZXJhdGlvbiBub3cuXG4gICAgY29uc3QgbGVmdE1vc3RDaGlsZCA9IGdldExlZnRNb3N0Q2hpbGQocmlnaHQpO1xuICAgIGlmIChsZWZ0TW9zdENoaWxkPy5uYW1lID09PSAnTnVtYmVyTGl0ZXJhbCcpIHtcbiAgICAgIHZpc1F1ZXJ5Lm9wZXJhdGlvbnMucHVzaChtYWtlQmluT3Aob3BEZWYsIGV4cHIsIGxlZnRNb3N0Q2hpbGQsICEhYmluTW9kaWZpZXI/LmlzQm9vbCkpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFkZGVkIHRoZSBmaXJzdCBudW1iZXIgbGl0ZXJhbCBhcyBvcGVyYXRpb24gaGVyZSB3ZSBzdGlsbCBjYW4gY29udGludWUgYW5kIGhhbmRsZSB0aGUgcmVzdCBhcyB0aGUgZmlyc3RcbiAgICAvLyBudW1iZXIgd2lsbCBiZSBqdXN0IHNraXBwZWQuXG4gICAgaGFuZGxlRXhwcmVzc2lvbihleHByLCByaWdodCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmlzUXVlcnkuYmluYXJ5UXVlcmllcyA9IHZpc1F1ZXJ5LmJpbmFyeVF1ZXJpZXMgfHwgW107XG4gICAgY29uc3QgYmluUXVlcnk6IFByb21WaXN1YWxRdWVyeUJpbmFyeSA9IHtcbiAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIG1ldHJpYzogJycsXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChiaW5Nb2RpZmllcj8uaXNNYXRjaGVyKSB7XG4gICAgICBiaW5RdWVyeS52ZWN0b3JNYXRjaGVzVHlwZSA9IGJpbk1vZGlmaWVyLm1hdGNoVHlwZTtcbiAgICAgIGJpblF1ZXJ5LnZlY3Rvck1hdGNoZXMgPSBiaW5Nb2RpZmllci5tYXRjaGVzO1xuICAgIH1cbiAgICB2aXNRdWVyeS5iaW5hcnlRdWVyaWVzLnB1c2goYmluUXVlcnkpO1xuICAgIGhhbmRsZUV4cHJlc3Npb24oZXhwciwgcmlnaHQsIHtcbiAgICAgIHF1ZXJ5OiBiaW5RdWVyeS5xdWVyeSxcbiAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TW9kaWZpZXIoXG4gIGV4cHI6IHN0cmluZyxcbiAgbm9kZTogU3ludGF4Tm9kZSB8IG51bGxcbik6XG4gIHwgeyBpc0Jvb2w6IHRydWU7IGlzTWF0Y2hlcjogZmFsc2UgfVxuICB8IHsgaXNCb29sOiBmYWxzZTsgaXNNYXRjaGVyOiB0cnVlOyBtYXRjaGVzOiBzdHJpbmc7IG1hdGNoVHlwZTogJ2lnbm9yaW5nJyB8ICdvbicgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoJ0Jvb2wnKSkge1xuICAgIHJldHVybiB7IGlzQm9vbDogdHJ1ZSwgaXNNYXRjaGVyOiBmYWxzZSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoZXIgPSBub2RlLmdldENoaWxkKCdPbk9ySWdub3JpbmcnKTtcbiAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgdGhpcyBjb3VsZCBiZSwgbWF5YmUgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gZ2V0U3RyaW5nKGV4cHIsIG1hdGNoZXIuZ2V0Q2hpbGQoJ0dyb3VwaW5nTGFiZWxzJyk/LmdldENoaWxkKCdHcm91cGluZ0xhYmVsTGlzdCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaGVyOiB0cnVlLFxuICAgICAgaXNCb29sOiBmYWxzZSxcbiAgICAgIG1hdGNoZXM6IGxhYmVscyxcbiAgICAgIG1hdGNoVHlwZTogbWF0Y2hlci5nZXRDaGlsZCgnT24nKSA/ICdvbicgOiAnaWdub3JpbmcnLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eVF1ZXJ5KHF1ZXJ5OiBQcm9tVmlzdWFsUXVlcnkpIHtcbiAgaWYgKHF1ZXJ5LmxhYmVscy5sZW5ndGggPT09IDAgJiYgcXVlcnkub3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgIXF1ZXJ5Lm1ldHJpYykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IElucHV0LCBtZWFzdXJlVGV4dCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IFByb3BzIGFzIElucHV0UHJvcHMgfSBmcm9tICdAZ3JhZmFuYS91aS9zcmMvY29tcG9uZW50cy9JbnB1dC9JbnB1dCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGludGVyZmFjZSBQcm9wcyBleHRlbmRzIElucHV0UHJvcHMge1xuICAvKiogU2V0cyB0aGUgbWluLXdpZHRoIHRvIGEgbXVsdGlwbGUgb2YgOHB4LiBEZWZhdWx0IHZhbHVlIGlzIDEwKi9cbiAgbWluV2lkdGg/OiBudW1iZXI7XG4gIC8qKiBTZXRzIHRoZSBtYXgtd2lkdGggdG8gYSBtdWx0aXBsZSBvZiA4cHguKi9cbiAgbWF4V2lkdGg/OiBudW1iZXI7XG4gIC8qKiBvbkNoYW5nZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcnVuIG9uIG9uQmx1ciBhbmQgb25LZXlQcmVzcyB3aXRoIGVudGVyKi9cbiAgb25Db21taXRDaGFuZ2U/OiAoZXZlbnQ6IFJlYWN0LkZvcm1FdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IEF1dG9TaXplSW5wdXQgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxJbnB1dEVsZW1lbnQsIFByb3BzPigocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCB7IGRlZmF1bHRWYWx1ZSA9ICcnLCBtaW5XaWR0aCA9IDEwLCBtYXhXaWR0aCwgb25Db21taXRDaGFuZ2UsIG9uS2V5RG93biwgb25CbHVyLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKGRlZmF1bHRWYWx1ZSk7XG4gIGNvbnN0IFtpbnB1dFdpZHRoLCBzZXRJbnB1dFdpZHRoXSA9IFJlYWN0LnVzZVN0YXRlKG1pbldpZHRoKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElucHV0V2lkdGgoZ2V0V2lkdGhGb3IodmFsdWUudG9TdHJpbmcoKSwgbWluV2lkdGgsIG1heFdpZHRoKSk7XG4gIH0sIFt2YWx1ZSwgbWF4V2lkdGgsIG1pbldpZHRoXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8SW5wdXRcbiAgICAgIHsuLi5yZXN0UHJvcHN9XG4gICAgICByZWY9e3JlZn1cbiAgICAgIHZhbHVlPXt2YWx1ZS50b1N0cmluZygpfVxuICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT4ge1xuICAgICAgICBzZXRWYWx1ZShldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgICAgIH19XG4gICAgICB3aWR0aD17aW5wdXRXaWR0aH1cbiAgICAgIG9uQmx1cj17KGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChvbkNvbW1pdENoYW5nZSkge1xuICAgICAgICAgIG9uQ29tbWl0Q2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25CbHVyKSB7XG4gICAgICAgICAgb25CbHVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIG9uS2V5RG93bj17KGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicgJiYgb25Db21taXRDaGFuZ2UpIHtcbiAgICAgICAgICBvbkNvbW1pdENoYW5nZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgICAgIG9uS2V5RG93bihldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH19XG4gICAgICBkYXRhLXRlc3RpZD17J2F1dG9zaXplLWlucHV0J31cbiAgICAvPlxuICApO1xufSk7XG5cbmZ1bmN0aW9uIGdldFdpZHRoRm9yKHZhbHVlOiBzdHJpbmcsIG1pbldpZHRoOiBudW1iZXIsIG1heFdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIG1pbldpZHRoO1xuICB9XG5cbiAgY29uc3QgZXh0cmFTcGFjZSA9IDM7XG4gIGNvbnN0IHJlYWxXaWR0aCA9IG1lYXN1cmVUZXh0KHZhbHVlLnRvU3RyaW5nKCksIDE0KS53aWR0aCAvIDggKyBleHRyYVNwYWNlO1xuXG4gIGlmIChtaW5XaWR0aCAmJiByZWFsV2lkdGggPCBtaW5XaWR0aCkge1xuICAgIHJldHVybiBtaW5XaWR0aDtcbiAgfVxuXG4gIGlmIChtYXhXaWR0aCAmJiByZWFsV2lkdGggPiBtYXhXaWR0aCkge1xuICAgIHJldHVybiByZWFsV2lkdGg7XG4gIH1cblxuICByZXR1cm4gcmVhbFdpZHRoO1xufVxuXG5BdXRvU2l6ZUlucHV0LmRpc3BsYXlOYW1lID0gJ0F1dG9TaXplSW5wdXQnO1xuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgSWNvbiwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBmZWVkYmFja1VybD86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZlZWRiYWNrTGluayh7IGZlZWRiYWNrVXJsIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICBpZiAoIWNvbmZpZy5mZWVkYmFja0xpbmtzRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgZ2FwPXsxfT5cbiAgICAgIDxhXG4gICAgICAgIGhyZWY9e2ZlZWRiYWNrVXJsfVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5saW5rfVxuICAgICAgICB0aXRsZT1cIlRoaXMgcXVlcnkgYnVpbGRlciBpcyBuZXcsIHBsZWFzZSBsZXQgdXMga25vdyBob3cgd2UgY2FuIGltcHJvdmUgaXRcIlxuICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICByZWw9XCJub3JlZmVycmVyIG5vb3BlbmVyXCJcbiAgICAgID5cbiAgICAgICAgPEljb24gbmFtZT1cImNvbW1lbnQtYWx0LW1lc3NhZ2VcIiAvPiBHaXZlIGZlZWRiYWNrXG4gICAgICA8L2E+XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGVzKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSB7XG4gIHJldHVybiB7XG4gICAgbGluazogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICAnOmhvdmVyJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQubGluayxcbiAgICAgIH0sXG4gICAgfSksXG4gIH07XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyBTZWxlY3RhYmxlVmFsdWUsIHRvT3B0aW9uIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlciB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQWNjZXNzb3J5QnV0dG9uLCBJbnB1dEdyb3VwIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIGRlZmF1bHRPcDogc3RyaW5nO1xuICBpdGVtOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPjtcbiAgb25DaGFuZ2U6ICh2YWx1ZTogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIpID0+IHZvaWQ7XG4gIG9uR2V0TGFiZWxOYW1lczogKGZvckxhYmVsOiBQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPikgPT4gUHJvbWlzZTxTZWxlY3RhYmxlVmFsdWVbXT47XG4gIG9uR2V0TGFiZWxWYWx1ZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBvbkRlbGV0ZTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYmVsRmlsdGVySXRlbSh7IGl0ZW0sIGRlZmF1bHRPcCwgb25DaGFuZ2UsIG9uRGVsZXRlLCBvbkdldExhYmVsTmFtZXMsIG9uR2V0TGFiZWxWYWx1ZXMgfTogUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTx7XG4gICAgbGFiZWxOYW1lcz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBsYWJlbFZhbHVlcz86IEFycmF5PFNlbGVjdGFibGVWYWx1ZTxhbnk+PjtcbiAgICBpc0xvYWRpbmdMYWJlbE5hbWVzPzogYm9vbGVhbjtcbiAgICBpc0xvYWRpbmdMYWJlbFZhbHVlcz86IGJvb2xlYW47XG4gIH0+KHt9KTtcblxuICBjb25zdCBpc011bHRpU2VsZWN0ID0gKCkgPT4ge1xuICAgIHJldHVybiBpdGVtLm9wID09PSBvcGVyYXRvcnNbMF0ubGFiZWw7XG4gIH07XG5cbiAgY29uc3QgZ2V0VmFsdWUgPSAoaXRlbTogYW55KSA9PiB7XG4gICAgaWYgKGl0ZW0gJiYgaXRlbS52YWx1ZSkge1xuICAgICAgaWYgKGl0ZW0udmFsdWUuaW5kZXhPZignfCcpID4gMCkge1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZS5zcGxpdCgnfCcpLm1hcCgoeDogYW55KSA9PiAoeyBsYWJlbDogeCwgdmFsdWU6IHggfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvT3B0aW9uKGl0ZW0udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBjb25zdCBnZXRPcHRpb25zID0gKCkgPT4ge1xuICAgIGlmICghc3RhdGUubGFiZWxWYWx1ZXMgJiYgaXRlbSAmJiBpdGVtLnZhbHVlICYmIGl0ZW0udmFsdWUuaW5kZXhPZignfCcpID4gMCkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlKGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5sYWJlbFZhbHVlcztcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJwcm9tZXRoZXVzLWRpbWVuc2lvbnMtZmlsdGVyLWl0ZW1cIj5cbiAgICAgIDxJbnB1dEdyb3VwPlxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbS1rZXlcIlxuICAgICAgICAgIHdpZHRoPVwiYXV0b1wiXG4gICAgICAgICAgdmFsdWU9e2l0ZW0ubGFiZWwgPyB0b09wdGlvbihpdGVtLmxhYmVsKSA6IG51bGx9XG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgaXNMb2FkaW5nTGFiZWxOYW1lczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsTmFtZXMgPSBhd2FpdCBvbkdldExhYmVsTmFtZXMoaXRlbSk7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGxhYmVsTmFtZXMsIGlzTG9hZGluZ0xhYmVsTmFtZXM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICB9fVxuICAgICAgICAgIGlzTG9hZGluZz17c3RhdGUuaXNMb2FkaW5nTGFiZWxOYW1lc31cbiAgICAgICAgICBvcHRpb25zPXtzdGF0ZS5sYWJlbE5hbWVzfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmxhYmVsKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCxcbiAgICAgICAgICAgICAgICBsYWJlbDogY2hhbmdlLmxhYmVsLFxuICAgICAgICAgICAgICB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgdmFsdWU9e3RvT3B0aW9uKGl0ZW0ub3AgPz8gZGVmYXVsdE9wKX1cbiAgICAgICAgICBvcHRpb25zPXtvcGVyYXRvcnN9XG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICBvbkNoYW5nZT17KGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgb3A6IGNoYW5nZS52YWx1ZSB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cblxuICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgaW5wdXRJZD1cInByb21ldGhldXMtZGltZW5zaW9ucy1maWx0ZXItaXRlbS12YWx1ZVwiXG4gICAgICAgICAgd2lkdGg9XCJhdXRvXCJcbiAgICAgICAgICB2YWx1ZT17Z2V0VmFsdWUoaXRlbSl9XG4gICAgICAgICAgYWxsb3dDdXN0b21WYWx1ZVxuICAgICAgICAgIG9uT3Blbk1lbnU9e2FzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXRlKHsgaXNMb2FkaW5nTGFiZWxWYWx1ZXM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbFZhbHVlcyA9IGF3YWl0IG9uR2V0TGFiZWxWYWx1ZXMoaXRlbSk7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBsYWJlbFZhbHVlcyxcbiAgICAgICAgICAgICAgaXNMb2FkaW5nTGFiZWxWYWx1ZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH19XG4gICAgICAgICAgaXNNdWx0aT17aXNNdWx0aVNlbGVjdCgpfVxuICAgICAgICAgIGlzTG9hZGluZz17c3RhdGUuaXNMb2FkaW5nTGFiZWxWYWx1ZXN9XG4gICAgICAgICAgb3B0aW9ucz17Z2V0T3B0aW9ucygpfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgdmFsdWU6IGNoYW5nZS52YWx1ZSwgb3A6IGl0ZW0ub3AgPz8gZGVmYXVsdE9wIH0gYXMgYW55IGFzIFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAubWFwKChjaGFuZ2U6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZS5sYWJlbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlKHsgLi4uaXRlbSwgdmFsdWU6IGNoYW5nZXMsIG9wOiBpdGVtLm9wID8/IGRlZmF1bHRPcCB9IGFzIGFueSBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICAgPEFjY2Vzc29yeUJ1dHRvbiBhcmlhLWxhYmVsPVwicmVtb3ZlXCIgaWNvbj1cInRpbWVzXCIgdmFyaWFudD1cInNlY29uZGFyeVwiIG9uQ2xpY2s9e29uRGVsZXRlfSAvPlxuICAgICAgPC9JbnB1dEdyb3VwPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5jb25zdCBvcGVyYXRvcnMgPSBbXG4gIHsgbGFiZWw6ICc9ficsIHZhbHVlOiAnPX4nIH0sXG4gIHsgbGFiZWw6ICc9JywgdmFsdWU6ICc9JyB9LFxuICB7IGxhYmVsOiAnIT0nLCB2YWx1ZTogJyE9JyB9LFxuICB7IGxhYmVsOiAnIX4nLCB2YWx1ZTogJyF+JyB9LFxuXTtcbiIsImltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgRWRpdG9yRmllbGQsIEVkaXRvckZpZWxkR3JvdXAsIEVkaXRvckxpc3QgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgaXNFcXVhbCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IExhYmVsRmlsdGVySXRlbSB9IGZyb20gJy4vTGFiZWxGaWx0ZXJJdGVtJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIGxhYmVsc0ZpbHRlcnM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW107XG4gIG9uQ2hhbmdlOiAobGFiZWxGaWx0ZXJzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKSA9PiB2b2lkO1xuICBvbkdldExhYmVsTmFtZXM6IChmb3JMYWJlbDogUGFydGlhbDxRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcj4pID0+IFByb21pc2U8U2VsZWN0YWJsZVZhbHVlW10+O1xuICBvbkdldExhYmVsVmFsdWVzOiAoZm9yTGFiZWw6IFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+KSA9PiBQcm9taXNlPFNlbGVjdGFibGVWYWx1ZVtdPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYmVsRmlsdGVycyh7IGxhYmVsc0ZpbHRlcnMsIG9uQ2hhbmdlLCBvbkdldExhYmVsTmFtZXMsIG9uR2V0TGFiZWxWYWx1ZXMgfTogUHJvcHMpIHtcbiAgY29uc3QgZGVmYXVsdE9wID0gJz0nO1xuICBjb25zdCBbaXRlbXMsIHNldEl0ZW1zXSA9IHVzZVN0YXRlPEFycmF5PFBhcnRpYWw8UXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXI+Pj4oW3sgb3A6IGRlZmF1bHRPcCB9XSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobGFiZWxzRmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXRJdGVtcyhsYWJlbHNGaWx0ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXRlbXMoW3sgb3A6IGRlZmF1bHRPcCB9XSk7XG4gICAgfVxuICB9LCBbbGFiZWxzRmlsdGVyc10pO1xuXG4gIGNvbnN0IG9uTGFiZWxzQ2hhbmdlID0gKG5ld0l0ZW1zOiBBcnJheTxQYXJ0aWFsPFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyPj4pID0+IHtcbiAgICBzZXRJdGVtcyhuZXdJdGVtcyk7XG5cbiAgICAvLyBFeHRyYWN0IGZ1bGwgbGFiZWwgZmlsdGVycyB3aXRoIGJvdGggbGFiZWwgJiB2YWx1ZVxuICAgIGNvbnN0IG5ld0xhYmVscyA9IG5ld0l0ZW1zLmZpbHRlcigoeCkgPT4geC5sYWJlbCAhPSBudWxsICYmIHgudmFsdWUgIT0gbnVsbCk7XG4gICAgaWYgKCFpc0VxdWFsKG5ld0xhYmVscywgbGFiZWxzRmlsdGVycykpIHtcbiAgICAgIG9uQ2hhbmdlKG5ld0xhYmVscyBhcyBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8RWRpdG9yRmllbGRHcm91cD5cbiAgICAgIDxFZGl0b3JGaWVsZCBsYWJlbD1cIkxhYmVsc1wiPlxuICAgICAgICA8RWRpdG9yTGlzdFxuICAgICAgICAgIGl0ZW1zPXtpdGVtc31cbiAgICAgICAgICBvbkNoYW5nZT17b25MYWJlbHNDaGFuZ2V9XG4gICAgICAgICAgcmVuZGVySXRlbT17KGl0ZW0sIG9uQ2hhbmdlSXRlbSwgb25EZWxldGUpID0+IChcbiAgICAgICAgICAgIDxMYWJlbEZpbHRlckl0ZW1cbiAgICAgICAgICAgICAgaXRlbT17aXRlbX1cbiAgICAgICAgICAgICAgZGVmYXVsdE9wPXtkZWZhdWx0T3B9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZUl0ZW19XG4gICAgICAgICAgICAgIG9uRGVsZXRlPXtvbkRlbGV0ZX1cbiAgICAgICAgICAgICAgb25HZXRMYWJlbE5hbWVzPXtvbkdldExhYmVsTmFtZXN9XG4gICAgICAgICAgICAgIG9uR2V0TGFiZWxWYWx1ZXM9e29uR2V0TGFiZWxWYWx1ZXN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIC8+XG4gICAgICA8L0VkaXRvckZpZWxkPlxuICAgIDwvRWRpdG9yRmllbGRHcm91cD5cbiAgKTtcbn1cbiIsImltcG9ydCB7IFJlZ2lzdHJ5IH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZpc3VhbFF1ZXJ5QmluYXJ5PFQ+IHtcbiAgb3BlcmF0b3I6IHN0cmluZztcbiAgdmVjdG9yTWF0Y2hlc1R5cGU/OiAnb24nIHwgJ2lnbm9yaW5nJztcbiAgdmVjdG9yTWF0Y2hlcz86IHN0cmluZztcbiAgcXVlcnk6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUxva2lWaXN1YWxRdWVyeSB7XG4gIG1ldHJpYz86IHN0cmluZztcbiAgbGFiZWxzOiBRdWVyeUJ1aWxkZXJMYWJlbEZpbHRlcltdO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbiAgYmluYXJ5UXVlcmllcz86IEFycmF5PFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+Pjtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UgaW1wbGVtZW50cyBWaXN1YWxRdWVyeU1vZGVsbGVyIHtcbiAgcHJvdGVjdGVkIG9wZXJhdGlvbnNSZWdpc3R5OiBSZWdpc3RyeTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+O1xuICBwcml2YXRlIGNhdGVnb3JpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZ2V0T3BlcmF0aW9uczogKCkgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10pIHtcbiAgICB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5ID0gbmV3IFJlZ2lzdHJ5PFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4oZ2V0T3BlcmF0aW9ucyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0T3BlcmF0aW9uQ2F0ZWdvcmllcyhjYXRlZ29yaWVzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XG4gIH1cblxuICBnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5Lmxpc3QoKS5maWx0ZXIoKG9wKSA9PiBvcC5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkgJiYgIW9wLmhpZGVGcm9tTGlzdCk7XG4gIH1cblxuICBnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoa2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zUmVnaXN0eS5saXN0KCkuZmlsdGVyKChvcCkgPT4gb3AuYWx0ZXJuYXRpdmVzS2V5ID09PSBrZXkpO1xuICB9XG5cbiAgZ2V0Q2F0ZWdvcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5jYXRlZ29yaWVzO1xuICB9XG5cbiAgZ2V0T3BlcmF0aW9uRGVmKGlkOiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5LmdldElmRXhpc3RzKGlkKTtcbiAgfVxuXG4gIHJlbmRlck9wZXJhdGlvbnMocXVlcnlTdHJpbmc6IHN0cmluZywgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW10pIHtcbiAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7XG4gICAgICBjb25zdCBkZWYgPSB0aGlzLm9wZXJhdGlvbnNSZWdpc3R5LmdldElmRXhpc3RzKG9wZXJhdGlvbi5pZCk7XG4gICAgICBpZiAoIWRlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG9wZXJhdGlvbiAke29wZXJhdGlvbi5pZH0gaW4gdGhlIHJlZ2lzdHJ5YCk7XG4gICAgICB9XG4gICAgICBxdWVyeVN0cmluZyA9IGRlZi5yZW5kZXJlcihvcGVyYXRpb24sIGRlZiwgcXVlcnlTdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgfVxuXG4gIHJlbmRlckJpbmFyeVF1ZXJpZXMocXVlcnlTdHJpbmc6IHN0cmluZywgYmluYXJ5UXVlcmllcz86IEFycmF5PFZpc3VhbFF1ZXJ5QmluYXJ5PFByb21Mb2tpVmlzdWFsUXVlcnk+Pikge1xuICAgIGlmIChiaW5hcnlRdWVyaWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGJpblF1ZXJ5IG9mIGJpbmFyeVF1ZXJpZXMpIHtcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBgJHt0aGlzLnJlbmRlckJpbmFyeVF1ZXJ5KHF1ZXJ5U3RyaW5nLCBiaW5RdWVyeSl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJCaW5hcnlRdWVyeShsZWZ0T3BlcmFuZDogc3RyaW5nLCBiaW5hcnlRdWVyeTogVmlzdWFsUXVlcnlCaW5hcnk8UHJvbUxva2lWaXN1YWxRdWVyeT4pIHtcbiAgICBsZXQgcmVzdWx0ID0gbGVmdE9wZXJhbmQgKyBgICR7YmluYXJ5UXVlcnkub3BlcmF0b3J9IGA7XG5cbiAgICBpZiAoYmluYXJ5UXVlcnkudmVjdG9yTWF0Y2hlcykge1xuICAgICAgcmVzdWx0ICs9IGAke2JpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXNUeXBlfSgke2JpbmFyeVF1ZXJ5LnZlY3Rvck1hdGNoZXN9KSBgO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgKyB0aGlzLnJlbmRlclF1ZXJ5KGJpbmFyeVF1ZXJ5LnF1ZXJ5LCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlckxhYmVscyhsYWJlbHM6IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyW10pIHtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGxldCBleHByID0gJ3snO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGxhYmVscykge1xuICAgICAgaWYgKGV4cHIgIT09ICd7Jykge1xuICAgICAgICBleHByICs9ICcsICc7XG4gICAgICB9XG5cbiAgICAgIGV4cHIgKz0gYCR7ZmlsdGVyLmxhYmVsfSR7ZmlsdGVyLm9wfVwiJHtmaWx0ZXIudmFsdWV9XCJgO1xuICAgIH1cblxuICAgIHJldHVybiBleHByICsgYH1gO1xuICB9XG5cbiAgcmVuZGVyUXVlcnkocXVlcnk6IFByb21Mb2tpVmlzdWFsUXVlcnksIG5lc3RlZD86IGJvb2xlYW4pIHtcbiAgICBsZXQgcXVlcnlTdHJpbmcgPSBgJHtxdWVyeS5tZXRyaWMgPz8gJyd9JHt0aGlzLnJlbmRlckxhYmVscyhxdWVyeS5sYWJlbHMpfWA7XG4gICAgcXVlcnlTdHJpbmcgPSB0aGlzLnJlbmRlck9wZXJhdGlvbnMocXVlcnlTdHJpbmcsIHF1ZXJ5Lm9wZXJhdGlvbnMpO1xuXG4gICAgaWYgKCFuZXN0ZWQgJiYgdGhpcy5oYXNCaW5hcnlPcChxdWVyeSkgJiYgQm9vbGVhbihxdWVyeS5iaW5hcnlRdWVyaWVzPy5sZW5ndGgpKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGAoJHtxdWVyeVN0cmluZ30pYDtcbiAgICB9XG5cbiAgICBxdWVyeVN0cmluZyA9IHRoaXMucmVuZGVyQmluYXJ5UXVlcmllcyhxdWVyeVN0cmluZywgcXVlcnkuYmluYXJ5UXVlcmllcyk7XG5cbiAgICBpZiAobmVzdGVkICYmICh0aGlzLmhhc0JpbmFyeU9wKHF1ZXJ5KSB8fCBCb29sZWFuKHF1ZXJ5LmJpbmFyeVF1ZXJpZXM/Lmxlbmd0aCkpKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IGAoJHtxdWVyeVN0cmluZ30pYDtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnlTdHJpbmc7XG4gIH1cblxuICBoYXNCaW5hcnlPcChxdWVyeTogUHJvbUxva2lWaXN1YWxRdWVyeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBxdWVyeS5vcGVyYXRpb25zLmZpbmQoKG9wKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuZ2V0T3BlcmF0aW9uRGVmKG9wLmlkKTtcbiAgICAgICAgcmV0dXJuIGRlZj8uY2F0ZWdvcnkgPT09IFByb21WaXN1YWxRdWVyeU9wZXJhdGlvbkNhdGVnb3J5LkJpbmFyeU9wcztcbiAgICAgIH0pICE9PSB1bmRlZmluZWRcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjc3MsIGN4IH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IERhdGFTb3VyY2VBcGksIEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgSWNvbiwgVG9vbHRpcCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlIH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5pbXBvcnQge1xuICBWaXN1YWxRdWVyeU1vZGVsbGVyLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWUsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBPcGVyYXRpb25IZWFkZXIgfSBmcm9tICcuL09wZXJhdGlvbkhlYWRlcic7XG5pbXBvcnQgeyBnZXRPcGVyYXRpb25QYXJhbUVkaXRvciB9IGZyb20gJy4vT3BlcmF0aW9uUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4vb3BlcmF0aW9uVXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgb3BlcmF0aW9uOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG4gIGluZGV4OiBudW1iZXI7XG4gIHF1ZXJ5OiBhbnk7XG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGk7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgb25SdW5RdWVyeTogKCkgPT4gdm9pZDtcbiAgaGlnaGxpZ2h0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkVkaXRvcih7XG4gIG9wZXJhdGlvbixcbiAgaW5kZXgsXG4gIG9uUmVtb3ZlLFxuICBvbkNoYW5nZSxcbiAgb25SdW5RdWVyeSxcbiAgcXVlcnlNb2RlbGxlcixcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIGhpZ2hsaWdodCxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgY29uc3QgZGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYob3BlcmF0aW9uLmlkKTtcbiAgY29uc3Qgc2hvdWxkSGlnaGxpZ2h0ID0gdXNlSGlnaGxpZ2h0KGhpZ2hsaWdodCk7XG5cbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm4gPHNwYW4+T3BlcmF0aW9uIHtvcGVyYXRpb24uaWR9IG5vdCBmb3VuZDwvc3Bhbj47XG4gIH1cblxuICBjb25zdCBvblBhcmFtVmFsdWVDaGFuZ2VkID0gKHBhcmFtSWR4OiBudW1iZXIsIHZhbHVlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gPSB7IC4uLm9wZXJhdGlvbiwgcGFyYW1zOiBbLi4ub3BlcmF0aW9uLnBhcmFtc10gfTtcbiAgICB1cGRhdGUucGFyYW1zW3BhcmFtSWR4XSA9IHZhbHVlO1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBwYXJhbUlkeCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uQWRkUmVzdFBhcmFtID0gKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0geyAuLi5vcGVyYXRpb24sIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXMsICcnXSB9O1xuICAgIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoZGVmLCB1cGRhdGUsIGluZGV4LCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aCwgb25DaGFuZ2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlUmVzdFBhcmFtID0gKHBhcmFtSWR4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGU6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiA9IHtcbiAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgIHBhcmFtczogWy4uLm9wZXJhdGlvbi5wYXJhbXMuc2xpY2UoMCwgcGFyYW1JZHgpLCAuLi5vcGVyYXRpb24ucGFyYW1zLnNsaWNlKHBhcmFtSWR4ICsgMSldLFxuICAgIH07XG4gICAgY2FsbFBhcmFtQ2hhbmdlZFRoZW5PbkNoYW5nZShkZWYsIHVwZGF0ZSwgaW5kZXgsIHBhcmFtSWR4LCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgY29uc3Qgb3BlcmF0aW9uRWxlbWVudHM6IFJlYWN0LlJlYWN0Tm9kZVtdID0gW107XG5cbiAgZm9yIChsZXQgcGFyYW1JbmRleCA9IDA7IHBhcmFtSW5kZXggPCBvcGVyYXRpb24ucGFyYW1zLmxlbmd0aDsgcGFyYW1JbmRleCsrKSB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW01hdGgubWluKGRlZi5wYXJhbXMubGVuZ3RoIC0gMSwgcGFyYW1JbmRleCldO1xuICAgIGNvbnN0IEVkaXRvciA9IGdldE9wZXJhdGlvblBhcmFtRWRpdG9yKHBhcmFtRGVmKTtcblxuICAgIG9wZXJhdGlvbkVsZW1lbnRzLnB1c2goXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtUm93fSBrZXk9e2Ake3BhcmFtSW5kZXh9LTFgfT5cbiAgICAgICAgeyFwYXJhbURlZi5oaWRlTmFtZSAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5wYXJhbU5hbWV9PlxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9e2dldE9wZXJhdGlvblBhcmFtSWQoaW5kZXgsIHBhcmFtSW5kZXgpfT57cGFyYW1EZWYubmFtZX08L2xhYmVsPlxuICAgICAgICAgICAge3BhcmFtRGVmLmRlc2NyaXB0aW9uICYmIChcbiAgICAgICAgICAgICAgPFRvb2x0aXAgcGxhY2VtZW50PVwidG9wXCIgY29udGVudD17cGFyYW1EZWYuZGVzY3JpcHRpb259IHRoZW1lPVwiaW5mb1wiPlxuICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJpbmZvLWNpcmNsZVwiIHNpemU9XCJzbVwiIGNsYXNzTmFtZT17c3R5bGVzLmluZm9JY29ufSAvPlxuICAgICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBhcmFtVmFsdWV9PlxuICAgICAgICAgIDxTdGFjayBnYXA9ezAuNX0gZGlyZWN0aW9uPVwicm93XCIgYWxpZ25JdGVtcz1cImNlbnRlclwiIHdyYXA9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxFZGl0b3JcbiAgICAgICAgICAgICAgaW5kZXg9e3BhcmFtSW5kZXh9XG4gICAgICAgICAgICAgIHBhcmFtRGVmPXtwYXJhbURlZn1cbiAgICAgICAgICAgICAgdmFsdWU9e29wZXJhdGlvbi5wYXJhbXNbcGFyYW1JbmRleF19XG4gICAgICAgICAgICAgIG9wZXJhdGlvbj17b3BlcmF0aW9ufVxuICAgICAgICAgICAgICBvcGVyYXRpb25JbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXtvblBhcmFtVmFsdWVDaGFuZ2VkfVxuICAgICAgICAgICAgICBvblJ1blF1ZXJ5PXtvblJ1blF1ZXJ5fVxuICAgICAgICAgICAgICBxdWVyeT17cXVlcnl9XG4gICAgICAgICAgICAgIGRhdGFzb3VyY2U9e2RhdGFzb3VyY2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge3BhcmFtRGVmLnJlc3RQYXJhbSAmJiAob3BlcmF0aW9uLnBhcmFtcy5sZW5ndGggPiBkZWYucGFyYW1zLmxlbmd0aCB8fCBwYXJhbURlZi5vcHRpb25hbCkgJiYgKFxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9e2BvcGVyYXRpb25zLiR7aW5kZXh9LnJlbW92ZS1yZXN0LXBhcmFtYH1cbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIGZpbGw9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBpY29uPVwidGltZXNcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPXtgUmVtb3ZlICR7cGFyYW1EZWYubmFtZX1gfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlUmVzdFBhcmFtKHBhcmFtSW5kZXgpfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L1N0YWNrPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICAvLyBIYW5kbGUgYWRkaW5nIGJ1dHRvbiBmb3IgcmVzdCBwYXJhbXNcbiAgbGV0IHJlc3RQYXJhbTogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkO1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGFzdFBhcmFtRGVmID0gZGVmLnBhcmFtc1tkZWYucGFyYW1zLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0UGFyYW1EZWYucmVzdFBhcmFtKSB7XG4gICAgICByZXN0UGFyYW0gPSByZW5kZXJBZGRSZXN0UGFyYW1CdXR0b24obGFzdFBhcmFtRGVmLCBvbkFkZFJlc3RQYXJhbSwgaW5kZXgsIG9wZXJhdGlvbi5wYXJhbXMubGVuZ3RoLCBzdHlsZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPERyYWdnYWJsZSBkcmFnZ2FibGVJZD17YG9wZXJhdGlvbi0ke2luZGV4fWB9IGluZGV4PXtpbmRleH0+XG4gICAgICB7KHByb3ZpZGVkKSA9PiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2N4KHN0eWxlcy5jYXJkLCBzaG91bGRIaWdobGlnaHQgJiYgc3R5bGVzLmNhcmRIaWdobGlnaHQpfVxuICAgICAgICAgIHJlZj17cHJvdmlkZWQuaW5uZXJSZWZ9XG4gICAgICAgICAgey4uLnByb3ZpZGVkLmRyYWdnYWJsZVByb3BzfVxuICAgICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke2luZGV4fS53cmFwcGVyYH1cbiAgICAgICAgPlxuICAgICAgICAgIDxPcGVyYXRpb25IZWFkZXJcbiAgICAgICAgICAgIG9wZXJhdGlvbj17b3BlcmF0aW9ufVxuICAgICAgICAgICAgZHJhZ0hhbmRsZVByb3BzPXtwcm92aWRlZC5kcmFnSGFuZGxlUHJvcHN9XG4gICAgICAgICAgICBkZWY9e2RlZn1cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIG9uUmVtb3ZlPXtvblJlbW92ZX1cbiAgICAgICAgICAgIHF1ZXJ5TW9kZWxsZXI9e3F1ZXJ5TW9kZWxsZXJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PntvcGVyYXRpb25FbGVtZW50c308L2Rpdj5cbiAgICAgICAgICB7cmVzdFBhcmFtfVxuICAgICAgICAgIHtpbmRleCA8IHF1ZXJ5Lm9wZXJhdGlvbnMubGVuZ3RoIC0gMSAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFycm93fT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5hcnJvd0xpbmV9IC8+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYXJyb3dBcnJvd30gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L0RyYWdnYWJsZT5cbiAgKTtcbn1cblxuLyoqXG4gKiBXaGVuIGhpZ2hsaWdodCBpcyBzd2l0Y2hlZCBvbiBtYWtlcyBzdXJlIGl0IGlzIHN3aXRjaGVkIG9mIHJpZ2h0IGF3YXksIHNvIHdlIGp1c3QgZmxhc2ggdGhlIGhpZ2hsaWdodCBhbmQgdGhlbiBmYWRlXG4gKiBvdXQuXG4gKiBAcGFyYW0gaGlnaGxpZ2h0XG4gKi9cbmZ1bmN0aW9uIHVzZUhpZ2hsaWdodChoaWdobGlnaHQ/OiBib29sZWFuKSB7XG4gIGNvbnN0IFtrZWVwSGlnaGxpZ2h0LCBzZXRLZWVwSGlnaGxpZ2h0XSA9IHVzZVN0YXRlKHRydWUpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0OiBhbnk7XG4gICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRLZWVwSGlnaGxpZ2h0KGZhbHNlKTtcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRLZWVwSGlnaGxpZ2h0KHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodCk7XG4gIH0sIFtoaWdobGlnaHRdKTtcblxuICByZXR1cm4ga2VlcEhpZ2hsaWdodCAmJiBoaWdobGlnaHQ7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFkZFJlc3RQYXJhbUJ1dHRvbihcbiAgcGFyYW1EZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxuICBvbkFkZFJlc3RQYXJhbTogKCkgPT4gdm9pZCxcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcixcbiAgcGFyYW1JbmRleDogbnVtYmVyLFxuICBzdHlsZXM6IE9wZXJhdGlvbkVkaXRvclN0eWxlc1xuKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5yZXN0UGFyYW19IGtleT17YCR7cGFyYW1JbmRleH0tMmB9PlxuICAgICAgPEJ1dHRvblxuICAgICAgICBzaXplPVwic21cIlxuICAgICAgICBpY29uPVwicGx1c1wiXG4gICAgICAgIHRpdGxlPXtgQWRkICR7cGFyYW1EZWYubmFtZX1gfVxuICAgICAgICB2YXJpYW50PVwic2Vjb25kYXJ5XCJcbiAgICAgICAgb25DbGljaz17b25BZGRSZXN0UGFyYW19XG4gICAgICAgIGRhdGEtdGVzdGlkPXtgb3BlcmF0aW9ucy4ke29wZXJhdGlvbkluZGV4fS5hZGQtcmVzdC1wYXJhbWB9XG4gICAgICA+XG4gICAgICAgIHtwYXJhbURlZi5uYW1lfVxuICAgICAgPC9CdXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgb3BlcmF0aW9uSW5kZXg6IG51bWJlcixcbiAgcGFyYW1JbmRleDogbnVtYmVyLFxuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkXG4pIHtcbiAgaWYgKGRlZi5wYXJhbUNoYW5nZWRIYW5kbGVyKSB7XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uSW5kZXgsIGRlZi5wYXJhbUNoYW5nZWRIYW5kbGVyKHBhcmFtSW5kZXgsIG9wZXJhdGlvbiwgZGVmKSk7XG4gIH0gZWxzZSB7XG4gICAgb25DaGFuZ2Uob3BlcmF0aW9uSW5kZXgsIG9wZXJhdGlvbik7XG4gIH1cbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY2FyZDogY3NzKHtcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnksXG4gICAgICBib3JkZXI6IGAxcHggc29saWQgJHt0aGVtZS5jb2xvcnMuYm9yZGVyLm1lZGl1bX1gLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICBjdXJzb3I6ICdncmFiJyxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgICAgbWFyZ2luQm90dG9tOiB0aGVtZS5zcGFjaW5nKDEpLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDFzIGVhc2UtaW4gMHMnLFxuICAgIH0pLFxuICAgIGNhcmRIaWdobGlnaHQ6IGNzcyh7XG4gICAgICBib3hTaGFkb3c6IGAwcHggMHB4IDRweCAwcHggJHt0aGVtZS5jb2xvcnMucHJpbWFyeS5ib3JkZXJ9YCxcbiAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5wcmltYXJ5LmJvcmRlcn1gLFxuICAgIH0pLFxuICAgIGluZm9JY29uOiBjc3Moe1xuICAgICAgbWFyZ2luTGVmdDogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgICc6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgICBib2R5OiBjc3Moe1xuICAgICAgbWFyZ2luOiB0aGVtZS5zcGFjaW5nKDEsIDEsIDAuNSwgMSksXG4gICAgICBkaXNwbGF5OiAndGFibGUnLFxuICAgIH0pLFxuICAgIHBhcmFtUm93OiBjc3Moe1xuICAgICAgbGFiZWw6ICdwYXJhbVJvdycsXG4gICAgICBkaXNwbGF5OiAndGFibGUtcm93JyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgIH0pLFxuICAgIHBhcmFtTmFtZTogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICd0YWJsZS1jZWxsJyxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMCwgMSwgMCwgMCksXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgIGhlaWdodDogJzMycHgnLFxuICAgIH0pLFxuICAgIHBhcmFtVmFsdWU6IGNzcyh7XG4gICAgICBsYWJlbDogJ3BhcmFtVmFsdWUnLFxuICAgICAgZGlzcGxheTogJ3RhYmxlLWNlbGwnLFxuICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgfSksXG4gICAgcmVzdFBhcmFtOiBjc3Moe1xuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygwLCAxLCAxLCAxKSxcbiAgICB9KSxcbiAgICBhcnJvdzogY3NzKHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICByaWdodDogJy0xOHB4JyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9KSxcbiAgICBhcnJvd0xpbmU6IGNzcyh7XG4gICAgICBoZWlnaHQ6ICcycHgnLFxuICAgICAgd2lkdGg6ICc4cHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5jb2xvcnMuYm9yZGVyLnN0cm9uZyxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAnMTRweCcsXG4gICAgfSksXG4gICAgYXJyb3dBcnJvdzogY3NzKHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgYm9yZGVyVG9wOiBgNXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgIGJvcmRlckJvdHRvbTogYDVweCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICBib3JkZXJMZWZ0OiBgN3B4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5zdHJvbmd9YCxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgdG9wOiAnMTBweCcsXG4gICAgfSksXG4gIH07XG59O1xuXG50eXBlIE9wZXJhdGlvbkVkaXRvclN0eWxlcyA9IFJldHVyblR5cGU8dHlwZW9mIGdldFN0eWxlcz47XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgcmVuZGVyTWFya2Rvd24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1hcmtkb3duPzogc3RyaW5nO1xuICBzdGVwTnVtYmVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPcGVyYXRpb25FeHBsYWluZWRCb3goeyB0aXRsZSwgc3RlcE51bWJlciwgbWFya2Rvd24sIGNoaWxkcmVuIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm94fT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3RlcE51bWJlcn0+e3N0ZXBOdW1iZXJ9PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJveElubmVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICAgIDxzcGFuPnt0aXRsZX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PlxuICAgICAgICAgIHttYXJrZG93biAmJiA8ZGl2IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogcmVuZGVyTWFya2Rvd24obWFya2Rvd24pIH19PjwvZGl2Pn1cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGJveDogY3NzKHtcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeSxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSksXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cygpLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBtYXJnaW5Cb3R0b206IHRoZW1lLnNwYWNpbmcoMC41KSxcbiAgICB9KSxcbiAgICBib3hJbm5lcjogY3NzKHtcbiAgICAgIG1hcmdpbkxlZnQ6IHRoZW1lLnNwYWNpbmcoNCksXG4gICAgfSksXG4gICAgc3RlcE51bWJlcjogY3NzKHtcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5zZWNvbmRhcnkubWFpbixcbiAgICAgIHdpZHRoOiAnMjBweCcsXG4gICAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnMTBweCcsXG4gICAgICBsZWZ0OiAnMTFweCcsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgfSksXG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygwLjUpLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBmb250RmFtaWx5OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHlNb25vc3BhY2UsXG4gICAgfSksXG4gICAgYm9keTogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICAncDpsYXN0LWNoaWxkJzoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICB9LFxuICAgICAgYToge1xuICAgICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQubGluayxcbiAgICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnLFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgU2VsZWN0YWJsZVZhbHVlIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBGbGV4SXRlbSB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIFNlbGVjdCwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE9wZXJhdGlvbkluZm9CdXR0b24gfSBmcm9tICcuL09wZXJhdGlvbkluZm9CdXR0b24nO1xuaW1wb3J0IHsgVmlzdWFsUXVlcnlNb2RlbGxlciwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcXVlcnlNb2RlbGxlcjogVmlzdWFsUXVlcnlNb2RlbGxlcjtcbiAgZHJhZ0hhbmRsZVByb3BzOiBhbnk7XG4gIG9uQ2hhbmdlOiAoaW5kZXg6IG51bWJlciwgdXBkYXRlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFN0YXRlIHtcbiAgaXNPcGVuPzogYm9vbGVhbjtcbiAgYWx0ZXJuYXRpdmVzPzogQXJyYXk8U2VsZWN0YWJsZVZhbHVlPFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZj4+O1xufVxuXG5leHBvcnQgY29uc3QgT3BlcmF0aW9uSGVhZGVyID0gUmVhY3QubWVtbzxQcm9wcz4oXG4gICh7IG9wZXJhdGlvbiwgZGVmLCBpbmRleCwgb25DaGFuZ2UsIG9uUmVtb3ZlLCBxdWVyeU1vZGVsbGVyLCBkcmFnSGFuZGxlUHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFN0YXRlPih7fSk7XG5cbiAgICBjb25zdCBvblRvZ2dsZVN3aXRjaGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlLmlzT3Blbikge1xuICAgICAgICBzZXRTdGF0ZSh7IC4uLnN0YXRlLCBpc09wZW46IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWx0ZXJuYXRpdmVzID0gcXVlcnlNb2RlbGxlclxuICAgICAgICAgIC5nZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoZGVmLmFsdGVybmF0aXZlc0tleSEpXG4gICAgICAgICAgLm1hcCgoYWx0KSA9PiAoeyBsYWJlbDogYWx0Lm5hbWUsIHZhbHVlOiBhbHQgfSkpO1xuICAgICAgICBzZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSwgYWx0ZXJuYXRpdmVzIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5oZWFkZXJ9PlxuICAgICAgICB7IXN0YXRlLmlzT3BlbiAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxkaXYgey4uLmRyYWdIYW5kbGVQcm9wc30+e2RlZi5uYW1lID8/IGRlZi5pZH08L2Rpdj5cbiAgICAgICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3N0eWxlcy5vcGVyYXRpb25IZWFkZXJCdXR0b25zfSBvcGVyYXRpb24taGVhZGVyLXNob3ctb24taG92ZXJgfT5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGljb249XCJhbmdsZS1kb3duXCJcbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uVG9nZ2xlU3dpdGNoZXJ9XG4gICAgICAgICAgICAgICAgZmlsbD1cInRleHRcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiQ2xpY2sgdG8gdmlldyBhbHRlcm5hdGl2ZSBvcGVyYXRpb25zXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPE9wZXJhdGlvbkluZm9CdXR0b24gZGVmPXtkZWZ9IG9wZXJhdGlvbj17b3BlcmF0aW9ufSAvPlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlKGluZGV4KX1cbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJSZW1vdmUgb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgICB7c3RhdGUuaXNPcGVuICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNlbGVjdFdyYXBwZXJ9PlxuICAgICAgICAgICAgPFNlbGVjdFxuICAgICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgICAgICAgb3Blbk1lbnVPbkZvY3VzXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUmVwbGFjZSB3aXRoXCJcbiAgICAgICAgICAgICAgb3B0aW9ucz17c3RhdGUuYWx0ZXJuYXRpdmVzfVxuICAgICAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgICAgIG9uQ2xvc2VNZW51PXtvblRvZ2dsZVN3aXRjaGVyfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBPcGVyYXRpb24gc2hvdWxkIGV4aXN0IGlmIGl0IGlzIHNlbGVjdGFibGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RlZiA9IHF1ZXJ5TW9kZWxsZXIuZ2V0T3BlcmF0aW9uRGVmKHZhbHVlLnZhbHVlLmlkKSE7XG4gICAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZE9wID0geyAuLi5vcGVyYXRpb24sIGlkOiB2YWx1ZS52YWx1ZS5pZCB9O1xuICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoaW5kZXgsIGRlZi5jaGFuZ2VUeXBlSGFuZGxlciA/IGRlZi5jaGFuZ2VUeXBlSGFuZGxlcihjaGFuZ2VkT3AsIG5ld0RlZikgOiBjaGFuZ2VkT3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4pO1xuXG5PcGVyYXRpb25IZWFkZXIuZGlzcGxheU5hbWUgPSAnT3BlcmF0aW9uSGVhZGVyJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyOiBjc3Moe1xuICAgICAgYm9yZGVyQm90dG9tOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5tZWRpdW19YCxcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMC41LCAwLjUsIDAuNSwgMSksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICcmOmhvdmVyIC5vcGVyYXRpb24taGVhZGVyLXNob3ctb24taG92ZXInOiBjc3Moe1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgfSksXG4gICAgfSksXG4gICAgb3BlcmF0aW9uSGVhZGVyQnV0dG9uczogY3NzKHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoWydvcGFjaXR5J10sIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0LFxuICAgICAgfSksXG4gICAgfSksXG4gICAgc2VsZWN0V3JhcHBlcjogY3NzKHtcbiAgICAgIHBhZGRpbmdSaWdodDogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiwgcmVuZGVyTWFya2Rvd24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IEZsZXhJdGVtIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEJ1dHRvbiwgUG9ydGFsLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUG9wcGVyVG9vbHRpcCB9IGZyb20gJ3JlYWN0LXBvcHBlci10b29sdGlwJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbjtcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY7XG59XG5cbmV4cG9ydCBjb25zdCBPcGVyYXRpb25JbmZvQnV0dG9uID0gUmVhY3QubWVtbzxQcm9wcz4oKHsgZGVmLCBvcGVyYXRpb24gfSkgPT4ge1xuICBjb25zdCBzdHlsZXMgPSB1c2VTdHlsZXMyKGdldFN0eWxlcyk7XG4gIGNvbnN0IFtzaG93LCBzZXRTaG93XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBnZXRUb29sdGlwUHJvcHMsIHNldFRvb2x0aXBSZWYsIHNldFRyaWdnZXJSZWYsIHZpc2libGUgfSA9IHVzZVBvcHBlclRvb2x0aXAoe1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgdmlzaWJsZTogc2hvdyxcbiAgICBvZmZzZXQ6IFswLCAxNl0sXG4gICAgb25WaXNpYmxlQ2hhbmdlOiBzZXRTaG93LFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHRyaWdnZXI6IFsnY2xpY2snXSxcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEJ1dHRvblxuICAgICAgICB0aXRsZT1cIkNsaWNrIHRvIHNob3cgZGVzY3JpcHRpb25cIlxuICAgICAgICByZWY9e3NldFRyaWdnZXJSZWZ9XG4gICAgICAgIGljb249XCJpbmZvLWNpcmNsZVwiXG4gICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAvPlxuICAgICAge3Zpc2libGUgJiYgKFxuICAgICAgICA8UG9ydGFsPlxuICAgICAgICAgIDxkaXYgcmVmPXtzZXRUb29sdGlwUmVmfSB7Li4uZ2V0VG9vbHRpcFByb3BzKCl9IGNsYXNzTmFtZT17c3R5bGVzLmRvY0JveH0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRvY0JveEhlYWRlcn0+XG4gICAgICAgICAgICAgIDxzcGFuPntkZWYucmVuZGVyZXIob3BlcmF0aW9uLCBkZWYsICc8ZXhwcj4nKX08L3NwYW4+XG4gICAgICAgICAgICAgIDxGbGV4SXRlbSBncm93PXsxfSAvPlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaWNvbj1cInRpbWVzXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaG93KGZhbHNlKX1cbiAgICAgICAgICAgICAgICBmaWxsPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJSZW1vdmUgb3BlcmF0aW9uXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5kb2NCb3hCb2R5fVxuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IGdldE9wZXJhdGlvbkRvY3MoZGVmLCBvcGVyYXRpb24pIH19XG4gICAgICAgICAgICA+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvUG9ydGFsPlxuICAgICAgKX1cbiAgICA8Lz5cbiAgKTtcbn0pO1xuXG5PcGVyYXRpb25JbmZvQnV0dG9uLmRpc3BsYXlOYW1lID0gJ09wZXJhdGlvbkRvY3MnO1xuXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBkb2NCb3g6IGNzcyh7XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5LFxuICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7dGhlbWUuY29sb3JzLmJvcmRlci5zdHJvbmd9YCxcbiAgICAgIGJveFNoYWRvdzogdGhlbWUuc2hhZG93cy56MyxcbiAgICAgIG1heFdpZHRoOiAnNjAwcHgnLFxuICAgICAgcGFkZGluZzogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKCksXG4gICAgICB6SW5kZXg6IHRoZW1lLnpJbmRleC50b29sdGlwLFxuICAgIH0pLFxuICAgIGRvY0JveEhlYWRlcjogY3NzKHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5Lmg1LmZvbnRTaXplLFxuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5TW9ub3NwYWNlLFxuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygxKSxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIH0pLFxuICAgIGRvY0JveEJvZHk6IGNzcyh7XG4gICAgICAvLyBUaGUgbWFya2Rvd24gcGFyYWdyYXBoIGhhcyBhIG1hcmdpbkJvdHRvbSB0aGlzIHJlbW92ZXMgaXRcbiAgICAgIG1hcmdpbkJvdHRvbTogdGhlbWUuc3BhY2luZygtMSksXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgIH0pLFxuICAgIHNpZ25hdHVyZTogY3NzKHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmJvZHlTbWFsbC5mb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseU1vbm9zcGFjZSxcbiAgICB9KSxcbiAgICBkcm9wZG93bjogY3NzKHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgIH0pLFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE9wZXJhdGlvbkRvY3MoZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24pOiBzdHJpbmcge1xuICByZXR1cm4gcmVuZGVyTWFya2Rvd24oZGVmLmV4cGxhaW5IYW5kbGVyID8gZGVmLmV4cGxhaW5IYW5kbGVyKG9wLCBkZWYpIDogZGVmLmRvY3VtZW50YXRpb24gPz8gJ25vIGRvY3MnKTtcbn1cbiIsImltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBEYXRhU291cmNlQXBpLCBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJ0BncmFmYW5hL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBCdXR0b24sIENhc2NhZGVyLCBDYXNjYWRlck9wdGlvbiwgdXNlU3R5bGVzMiB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERyYWdEcm9wQ29udGV4dCwgRHJvcHBhYmxlLCBEcm9wUmVzdWx0IH0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5pbXBvcnQgeyB1c2VNb3VudGVkU3RhdGUsIHVzZVByZXZpb3VzIH0gZnJvbSAncmVhY3QtdXNlJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgUXVlcnlXaXRoT3BlcmF0aW9ucywgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBPcGVyYXRpb25FZGl0b3IgfSBmcm9tICcuL09wZXJhdGlvbkVkaXRvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHM8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+IHtcbiAgcXVlcnk6IFQ7XG4gIGRhdGFzb3VyY2U6IERhdGFTb3VyY2VBcGk7XG4gIG9uQ2hhbmdlOiAocXVlcnk6IFQpID0+IHZvaWQ7XG4gIG9uUnVuUXVlcnk6ICgpID0+IHZvaWQ7XG4gIHF1ZXJ5TW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXI7XG4gIGV4cGxhaW5Nb2RlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkxpc3Q8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KHtcbiAgcXVlcnksXG4gIGRhdGFzb3VyY2UsXG4gIHF1ZXJ5TW9kZWxsZXIsXG4gIG9uQ2hhbmdlLFxuICBvblJ1blF1ZXJ5LFxufTogUHJvcHM8VD4pIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuICBjb25zdCB7IG9wZXJhdGlvbnMgfSA9IHF1ZXJ5O1xuXG4gIGNvbnN0IG9wc1RvSGlnaGxpZ2h0ID0gdXNlT3BlcmF0aW9uc0hpZ2hsaWdodChvcGVyYXRpb25zKTtcblxuICBjb25zdCBbY2FzY2FkZXJPcGVuLCBzZXRDYXNjYWRlck9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IG9uT3BlcmF0aW9uQ2hhbmdlID0gKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZExpc3QgPSBbLi4ub3BlcmF0aW9uc107XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKGluZGV4LCAxLCB1cGRhdGUpO1xuICAgIG9uQ2hhbmdlKHsgLi4ucXVlcnksIG9wZXJhdGlvbnM6IHVwZGF0ZWRMaXN0IH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVtb3ZlID0gKGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkTGlzdCA9IFsuLi5vcGVyYXRpb25zLnNsaWNlKDAsIGluZGV4KSwgLi4ub3BlcmF0aW9ucy5zbGljZShpbmRleCArIDEpXTtcbiAgICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBvcGVyYXRpb25zOiB1cGRhdGVkTGlzdCB9KTtcbiAgfTtcblxuICBjb25zdCBhZGRPcHRpb25zOiBDYXNjYWRlck9wdGlvbltdID0gcXVlcnlNb2RlbGxlci5nZXRDYXRlZ29yaWVzKCkubWFwKChjYXRlZ29yeSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogY2F0ZWdvcnksXG4gICAgICBsYWJlbDogY2F0ZWdvcnksXG4gICAgICBpdGVtczogcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnkpLm1hcCgob3BlcmF0aW9uKSA9PiAoe1xuICAgICAgICB2YWx1ZTogb3BlcmF0aW9uLmlkLFxuICAgICAgICBsYWJlbDogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgIGlzTGVhZjogdHJ1ZSxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBvbkFkZE9wZXJhdGlvbiA9ICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgb3BlcmF0aW9uRGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYodmFsdWUpO1xuICAgIGlmICghb3BlcmF0aW9uRGVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uQ2hhbmdlKG9wZXJhdGlvbkRlZi5hZGRPcGVyYXRpb25IYW5kbGVyKG9wZXJhdGlvbkRlZiwgcXVlcnksIHF1ZXJ5TW9kZWxsZXIpKTtcbiAgICBzZXRDYXNjYWRlck9wZW4oZmFsc2UpO1xuICB9O1xuXG4gIGNvbnN0IG9uRHJhZ0VuZCA9IChyZXN1bHQ6IERyb3BSZXN1bHQpID0+IHtcbiAgICBpZiAoIXJlc3VsdC5kZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWRMaXN0ID0gWy4uLm9wZXJhdGlvbnNdO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1cGRhdGVkTGlzdFtyZXN1bHQuc291cmNlLmluZGV4XTtcbiAgICB1cGRhdGVkTGlzdC5zcGxpY2UocmVzdWx0LnNvdXJjZS5pbmRleCwgMSk7XG4gICAgdXBkYXRlZExpc3Quc3BsaWNlKHJlc3VsdC5kZXN0aW5hdGlvbi5pbmRleCwgMCwgZWxlbWVudCk7XG4gICAgb25DaGFuZ2UoeyAuLi5xdWVyeSwgb3BlcmF0aW9uczogdXBkYXRlZExpc3QgfSk7XG4gIH07XG5cbiAgY29uc3Qgb25DYXNjYWRlckJsdXIgPSAoKSA9PiB7XG4gICAgc2V0Q2FzY2FkZXJPcGVuKGZhbHNlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBnYXA9ezF9IGRpcmVjdGlvbj1cImNvbHVtblwiPlxuICAgICAgPFN0YWNrIGdhcD17MX0+XG4gICAgICAgIHtvcGVyYXRpb25zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgIDxEcmFnRHJvcENvbnRleHQgb25EcmFnRW5kPXtvbkRyYWdFbmR9PlxuICAgICAgICAgICAgPERyb3BwYWJsZSBkcm9wcGFibGVJZD1cInNvcnRhYmxlLWZpZWxkLW1hcHBpbmdzXCIgZGlyZWN0aW9uPVwiaG9yaXpvbnRhbFwiPlxuICAgICAgICAgICAgICB7KHByb3ZpZGVkKSA9PiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5vcGVyYXRpb25MaXN0fSByZWY9e3Byb3ZpZGVkLmlubmVyUmVmfSB7Li4ucHJvdmlkZWQuZHJvcHBhYmxlUHJvcHN9PlxuICAgICAgICAgICAgICAgICAge29wZXJhdGlvbnMubWFwKChvcCwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPE9wZXJhdGlvbkVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgIGtleT17b3AuaWQgKyBpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICBxdWVyeU1vZGVsbGVyPXtxdWVyeU1vZGVsbGVyfVxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb249e29wfVxuICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5PXtxdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgICBkYXRhc291cmNlPXtkYXRhc291cmNlfVxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbk9wZXJhdGlvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICBvblJlbW92ZT17b25SZW1vdmV9XG4gICAgICAgICAgICAgICAgICAgICAgb25SdW5RdWVyeT17b25SdW5RdWVyeX1cbiAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQ9e29wc1RvSGlnaGxpZ2h0W2luZGV4XX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgICAge3Byb3ZpZGVkLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9Ecm9wcGFibGU+XG4gICAgICAgICAgPC9EcmFnRHJvcENvbnRleHQ+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYWRkQnV0dG9ufT5cbiAgICAgICAgICB7Y2FzY2FkZXJPcGVuID8gKFxuICAgICAgICAgICAgPENhc2NhZGVyXG4gICAgICAgICAgICAgIG9wdGlvbnM9e2FkZE9wdGlvbnN9XG4gICAgICAgICAgICAgIG9uU2VsZWN0PXtvbkFkZE9wZXJhdGlvbn1cbiAgICAgICAgICAgICAgb25CbHVyPXtvbkNhc2NhZGVyQmx1cn1cbiAgICAgICAgICAgICAgYXV0b0ZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgICBhbHdheXNPcGVuPXt0cnVlfVxuICAgICAgICAgICAgICBoaWRlQWN0aXZlTGV2ZWxMYWJlbD17dHJ1ZX1cbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9eydTZWFyY2gnfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgPEJ1dHRvbiBpY29uPXsncGx1cyd9IHZhcmlhbnQ9eydzZWNvbmRhcnknfSBvbkNsaWNrPXsoKSA9PiBzZXRDYXNjYWRlck9wZW4odHJ1ZSl9IHRpdGxlPXsnQWRkIG9wZXJhdGlvbid9PlxuICAgICAgICAgICAgICBPcGVyYXRpb25zXG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvU3RhY2s+XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGluZGV4ZXMgb2Ygb3BlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSBoaWdobGlnaHRlZC4gV2UgY2hlY2sgdGhlIGRpZmYgb2Ygb3BlcmF0aW9ucyBhZGRlZCBidXQgYXQgdGhlIHNhbWUgdGltZVxuICogd2Ugd2FudCB0byBoaWdobGlnaHQgb3BlcmF0aW9ucyBvbmx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlciwgc28gd2UgY2hlY2sgZm9yIG1vdW50ZWQgc3RhdGUgYW5kIGNhbGN1bGF0ZSB0aGUgZGlmZlxuICogb25seSBhZnRlci5cbiAqIEBwYXJhbSBvcGVyYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZU9wZXJhdGlvbnNIaWdobGlnaHQob3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW10pIHtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlTW91bnRlZFN0YXRlKCk7XG4gIGNvbnN0IHByZXZPcGVyYXRpb25zID0gdXNlUHJldmlvdXMob3BlcmF0aW9ucyk7XG5cbiAgaWYgKCFpc01vdW50ZWQoKSkge1xuICAgIHJldHVybiBvcGVyYXRpb25zLm1hcCgoKSA9PiBmYWxzZSk7XG4gIH1cblxuICBpZiAoIXByZXZPcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG9wZXJhdGlvbnMubWFwKCgpID0+IHRydWUpO1xuICB9XG5cbiAgbGV0IG5ld09wczogYm9vbGVhbltdID0gW107XG5cbiAgaWYgKHByZXZPcGVyYXRpb25zLmxlbmd0aCAtIDEgPT09IG9wZXJhdGlvbnMubGVuZ3RoICYmIG9wZXJhdGlvbnMuZXZlcnkoKG9wKSA9PiBwcmV2T3BlcmF0aW9ucy5pbmNsdWRlcyhvcCkpKSB7XG4gICAgLy8gSW4gY2FzZSB3ZSByZW1vdmUgb25lIG9wIGFuZCBkb2VzIG5vdCBjaGFuZ2UgYW55IG9wcyB0aGVuIGRvbid0IGhpZ2hsaWdodCBhbnl0aGluZy5cbiAgICByZXR1cm4gb3BlcmF0aW9ucy5tYXAoKCkgPT4gZmFsc2UpO1xuICB9XG4gIGlmIChwcmV2T3BlcmF0aW9ucy5sZW5ndGggKyAxID09PSBvcGVyYXRpb25zLmxlbmd0aCAmJiBwcmV2T3BlcmF0aW9ucy5ldmVyeSgob3ApID0+IG9wZXJhdGlvbnMuaW5jbHVkZXMob3ApKSkge1xuICAgIC8vIElmIHdlIGFkZCBhIHNpbmdsZSBvcCBqdXN0IGZpbmQgaXQgYW5kIGhpZ2hsaWdodCBqdXN0IHRoYXQuXG4gICAgY29uc3QgbmV3T3AgPSBvcGVyYXRpb25zLmZpbmQoKG9wKSA9PiAhcHJldk9wZXJhdGlvbnMuaW5jbHVkZXMob3ApKTtcbiAgICBuZXdPcHMgPSBvcGVyYXRpb25zLm1hcCgob3ApID0+IHtcbiAgICAgIHJldHVybiBvcCA9PT0gbmV3T3A7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBkaWZmIG9mIGFsbCBvcHMuXG4gICAgbmV3T3BzID0gb3BlcmF0aW9ucy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuICFpc1NhbWVPcChvcC5pZCwgcHJldk9wZXJhdGlvbnNbaW5kZXhdPy5pZCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ld09wcztcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3Aob3AxPzogc3RyaW5nLCBvcDI/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIG9wMSA9PT0gb3AyIHx8IGBfXyR7b3AxfV9ieWAgPT09IG9wMiB8fCBvcDEgPT09IGBfXyR7b3AyfV9ieWA7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIGhlYWRpbmc6IGNzcyh7XG4gICAgICBsYWJlbDogJ2hlYWRpbmcnLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgZm9udFdlaWdodDogdGhlbWUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFxuICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgIH0pLFxuICAgIG9wZXJhdGlvbkxpc3Q6IGNzcyh7XG4gICAgICBsYWJlbDogJ29wZXJhdGlvbkxpc3QnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleFdyYXA6ICd3cmFwJyxcbiAgICAgIGdhcDogdGhlbWUuc3BhY2luZygyKSxcbiAgICB9KSxcbiAgICBhZGRCdXR0b246IGNzcyh7XG4gICAgICBsYWJlbDogJ2FkZEJ1dHRvbicsXG4gICAgICB3aWR0aDogMTI2LFxuICAgICAgcGFkZGluZ0JvdHRvbTogdGhlbWUuc3BhY2luZygxKSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgT3BlcmF0aW9uRXhwbGFpbmVkQm94IH0gZnJvbSAnLi9PcGVyYXRpb25FeHBsYWluZWRCb3gnO1xuaW1wb3J0IHsgUXVlcnlXaXRoT3BlcmF0aW9ucywgVmlzdWFsUXVlcnlNb2RlbGxlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzPFQgZXh0ZW5kcyBRdWVyeVdpdGhPcGVyYXRpb25zPiB7XG4gIHF1ZXJ5OiBUO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBleHBsYWluTW9kZT86IGJvb2xlYW47XG4gIHN0ZXBOdW1iZXI6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9wZXJhdGlvbkxpc3RFeHBsYWluZWQ8VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KHsgcXVlcnksIHF1ZXJ5TW9kZWxsZXIsIHN0ZXBOdW1iZXIgfTogUHJvcHM8VD4pIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3F1ZXJ5Lm9wZXJhdGlvbnMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZGVmID0gcXVlcnlNb2RlbGxlci5nZXRPcGVyYXRpb25EZWYob3AuaWQpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgIHJldHVybiBgT3BlcmF0aW9uICR7b3AuaWR9IG5vdCBmb3VuZGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGl0bGUgPSBkZWYucmVuZGVyZXIob3AsIGRlZiwgJzxleHByPicpO1xuICAgICAgICBjb25zdCBib2R5ID0gZGVmLmV4cGxhaW5IYW5kbGVyID8gZGVmLmV4cGxhaW5IYW5kbGVyKG9wLCBkZWYpIDogZGVmLmRvY3VtZW50YXRpb24gPz8gJ25vIGRvY3MnO1xuXG4gICAgICAgIHJldHVybiA8T3BlcmF0aW9uRXhwbGFpbmVkQm94IHN0ZXBOdW1iZXI9e2luZGV4ICsgc3RlcE51bWJlcn0ga2V5PXtpbmRleH0gdGl0bGU9e3RpdGxlfSBtYXJrZG93bj17Ym9keX0gLz47XG4gICAgICB9KX1cbiAgICA8Lz5cbiAgKTtcbn1cbiIsImltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSwgdG9PcHRpb24gfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IENoZWNrYm94LCBTZWxlY3QgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IEF1dG9TaXplSW5wdXQgfSBmcm9tICcuL0F1dG9TaXplSW5wdXQnO1xuaW1wb3J0IHsgZ2V0T3BlcmF0aW9uUGFyYW1JZCB9IGZyb20gJy4vb3BlcmF0aW9uVXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1FZGl0b3IoXG4gIHBhcmFtRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbURlZlxuKTogQ29tcG9uZW50VHlwZTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzPiB7XG4gIGlmIChwYXJhbURlZi5lZGl0b3IpIHtcbiAgICByZXR1cm4gcGFyYW1EZWYuZWRpdG9yO1xuICB9XG5cbiAgaWYgKHBhcmFtRGVmLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gU2VsZWN0SW5wdXRQYXJhbUVkaXRvcjtcbiAgfVxuXG4gIHN3aXRjaCAocGFyYW1EZWYudHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEJvb2xJbnB1dFBhcmFtRWRpdG9yO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFNpbXBsZUlucHV0UGFyYW1FZGl0b3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gU2ltcGxlSW5wdXRQYXJhbUVkaXRvcihwcm9wczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxBdXRvU2l6ZUlucHV0XG4gICAgICBpZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChwcm9wcy5vcGVyYXRpb25JbmRleCwgcHJvcHMuaW5kZXgpfVxuICAgICAgZGVmYXVsdFZhbHVlPXtwcm9wcy52YWx1ZT8udG9TdHJpbmcoKX1cbiAgICAgIG1pbldpZHRoPXtwcm9wcy5wYXJhbURlZi5taW5XaWR0aH1cbiAgICAgIHBsYWNlaG9sZGVyPXtwcm9wcy5wYXJhbURlZi5wbGFjZWhvbGRlcn1cbiAgICAgIHRpdGxlPXtwcm9wcy5wYXJhbURlZi5kZXNjcmlwdGlvbn1cbiAgICAgIG9uQ29tbWl0Q2hhbmdlPXsoZXZ0KSA9PiB7XG4gICAgICAgIHByb3BzLm9uQ2hhbmdlKHByb3BzLmluZGV4LCBldnQuY3VycmVudFRhcmdldC52YWx1ZSk7XG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG5cbmZ1bmN0aW9uIEJvb2xJbnB1dFBhcmFtRWRpdG9yKHByb3BzOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPENoZWNrYm94XG4gICAgICBpZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChwcm9wcy5vcGVyYXRpb25JbmRleCwgcHJvcHMuaW5kZXgpfVxuICAgICAgdmFsdWU9e3Byb3BzLnZhbHVlIGFzIGJvb2xlYW59XG4gICAgICBvbkNoYW5nZT17KGV2dCkgPT4gcHJvcHMub25DaGFuZ2UocHJvcHMuaW5kZXgsIGV2dC5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfVxuICAgIC8+XG4gICk7XG59XG5cbmZ1bmN0aW9uIFNlbGVjdElucHV0UGFyYW1FZGl0b3Ioe1xuICBwYXJhbURlZixcbiAgdmFsdWUsXG4gIGluZGV4LFxuICBvcGVyYXRpb25JbmRleCxcbiAgb25DaGFuZ2UsXG59OiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzKSB7XG4gIGxldCBzZWxlY3RPcHRpb25zID0gcGFyYW1EZWYub3B0aW9ucyBhcyBBcnJheTxTZWxlY3RhYmxlVmFsdWU8YW55Pj47XG5cbiAgaWYgKCFzZWxlY3RPcHRpb25zWzBdPy5sYWJlbCkge1xuICAgIHNlbGVjdE9wdGlvbnMgPSBwYXJhbURlZi5vcHRpb25zIS5tYXAoKG9wdGlvbikgPT4gKHtcbiAgICAgIGxhYmVsOiBvcHRpb24udG9TdHJpbmcoKSxcbiAgICAgIHZhbHVlOiBvcHRpb24gYXMgc3RyaW5nLFxuICAgIH0pKTtcbiAgfVxuXG4gIGxldCB2YWx1ZU9wdGlvbiA9IHNlbGVjdE9wdGlvbnMuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gdmFsdWUpID8/IHRvT3B0aW9uKHZhbHVlIGFzIHN0cmluZyk7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VsZWN0XG4gICAgICBpZD17Z2V0T3BlcmF0aW9uUGFyYW1JZChvcGVyYXRpb25JbmRleCwgaW5kZXgpfVxuICAgICAgbWVudVNob3VsZFBvcnRhbFxuICAgICAgdmFsdWU9e3ZhbHVlT3B0aW9ufVxuICAgICAgb3B0aW9ucz17c2VsZWN0T3B0aW9uc31cbiAgICAgIHBsYWNlaG9sZGVyPXtwYXJhbURlZi5wbGFjZWhvbGRlcn1cbiAgICAgIGFsbG93Q3VzdG9tVmFsdWU9e3RydWV9XG4gICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiBvbkNoYW5nZShpbmRleCwgdmFsdWUudmFsdWUhKX1cbiAgICAvPlxuICApO1xufVxuIiwiaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlcmF0aW9uc0VkaXRvclJvdyh7IGNoaWxkcmVuIH06IFByb3BzKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucm9vdH0+XG4gICAgICA8U3RhY2sgZ2FwPXsxfT57Y2hpbGRyZW59PC9TdGFjaz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcm9vdDogY3NzKHtcbiAgICAgIHBhZGRpbmc6IHRoZW1lLnNwYWNpbmcoMSwgMSwgMCwgMSksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlY29uZGFyeSxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzKDEpLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IFJhZGlvQnV0dG9uR3JvdXAsIFRhZyB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBtb2RlOiBRdWVyeUVkaXRvck1vZGU7XG4gIG9uQ2hhbmdlOiAobW9kZTogUXVlcnlFZGl0b3JNb2RlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBlZGl0b3JNb2RlcyA9IFtcbiAgeyBsYWJlbDogJ0V4cGxhaW4nLCB2YWx1ZTogUXVlcnlFZGl0b3JNb2RlLkV4cGxhaW4gfSxcbiAge1xuICAgIGxhYmVsOiAnQnVpbGRlcicsXG4gICAgdmFsdWU6IFF1ZXJ5RWRpdG9yTW9kZS5CdWlsZGVyLFxuICAgIGNvbXBvbmVudDogKCkgPT4gKFxuICAgICAgPFRhZ1xuICAgICAgICBjbGFzc05hbWU9e2Nzcyh7XG4gICAgICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgICAgIHBhZGRpbmc6ICcxcHggNXB4JyxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndGV4dC1ib3R0b20nLFxuICAgICAgICB9KX1cbiAgICAgICAgbmFtZT17J0JldGEnfVxuICAgICAgICBjb2xvckluZGV4PXsxfVxuICAgICAgLz5cbiAgICApLFxuICB9LFxuICB7IGxhYmVsOiAnQ29kZScsIHZhbHVlOiBRdWVyeUVkaXRvck1vZGUuQ29kZSB9LFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIFF1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSh7IG1vZGUsIG9uQ2hhbmdlIH06IFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBkYXRhLXRlc3RpZD17J1F1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSd9PlxuICAgICAgPFJhZGlvQnV0dG9uR3JvdXAgb3B0aW9ucz17ZWRpdG9yTW9kZXN9IHNpemU9XCJzbVwiIHZhbHVlPXttb2RlfSBvbkNoYW5nZT17b25DaGFuZ2V9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tICdAZ3JhZmFuYS9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgU3dpdGNoLCB1c2VTdHlsZXMyIH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgdW5pcXVlSWQgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0LCB7IEhUTUxQcm9wcywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIGV4dGVuZHMgT21pdDxIVE1MUHJvcHM8SFRNTElucHV0RWxlbWVudD4sICd2YWx1ZScgfCAncmVmJz4ge1xuICB2YWx1ZT86IGJvb2xlYW47XG4gIGxhYmVsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeUhlYWRlclN3aXRjaCh7IGxhYmVsLCAuLi5pbnB1dFByb3BzIH06IFByb3BzKSB7XG4gIGNvbnN0IHN3aXRjaElkUmVmID0gdXNlUmVmKHVuaXF1ZUlkKGBzd2l0Y2gtJHtsYWJlbH1gKSk7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICByZXR1cm4gKFxuICAgIDxTdGFjayBnYXA9ezF9PlxuICAgICAgPGxhYmVsIGh0bWxGb3I9e3N3aXRjaElkUmVmLmN1cnJlbnR9IGNsYXNzTmFtZT17c3R5bGVzLnN3aXRjaExhYmVsfT5cbiAgICAgICAge2xhYmVsfVxuICAgICAgPC9sYWJlbD5cbiAgICAgIDxTd2l0Y2ggey4uLmlucHV0UHJvcHN9IGlkPXtzd2l0Y2hJZFJlZi5jdXJyZW50fSAvPlxuICAgIDwvU3RhY2s+XG4gICk7XG59XG5cbmNvbnN0IGdldFN0eWxlcyA9ICh0aGVtZTogR3JhZmFuYVRoZW1lMikgPT4ge1xuICByZXR1cm4ge1xuICAgIHN3aXRjaExhYmVsOiBjc3Moe1xuICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeSxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgfTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCB7IEdyYWZhbmFUaGVtZTIgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnQGdyYWZhbmEvZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IEljb24sIHVzZVN0eWxlczIgfSBmcm9tICdAZ3JhZmFuYS91aSc7XG5pbXBvcnQgeyB1c2VUb2dnbGUgfSBmcm9tICdyZWFjdC11c2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgY29sbGFwc2VkSW5mbzogc3RyaW5nW107XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBRdWVyeU9wdGlvbkdyb3VwKHsgdGl0bGUsIGNoaWxkcmVuLCBjb2xsYXBzZWRJbmZvIH06IFByb3BzKSB7XG4gIGNvbnN0IFtpc09wZW4sIHRvZ2dsZU9wZW5dID0gdXNlVG9nZ2xlKGZhbHNlKTtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWNrIGdhcD17MH0gZGlyZWN0aW9uPVwiY29sdW1uXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlYWRlcn0gb25DbGljaz17dG9nZ2xlT3Blbn0gdGl0bGU9XCJDbGljayB0byBlZGl0IG9wdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50b2dnbGV9PlxuICAgICAgICAgIDxJY29uIG5hbWU9e2lzT3BlbiA/ICdhbmdsZS1kb3duJyA6ICdhbmdsZS1yaWdodCd9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aDYgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9Pnt0aXRsZX08L2g2PlxuICAgICAgICB7IWlzT3BlbiAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kZXNjcmlwdGlvbn0+XG4gICAgICAgICAgICB7Y29sbGFwc2VkSW5mby5tYXAoKHgsIGkpID0+IChcbiAgICAgICAgICAgICAgPHNwYW4ga2V5PXtpfT57eH08L3NwYW4+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICAge2lzT3BlbiAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvZHl9PntjaGlsZHJlbn08L2Rpdj59XG4gICAgPC9TdGFjaz5cbiAgKTtcbn1cblxuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgc3dpdGNoTGFiZWw6IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnksXG4gICAgICB9LFxuICAgIH0pLFxuICAgIGhlYWRlcjogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgYWxpZ25JdGVtczogJ2Jhc2VsaW5lJyxcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5wcmltYXJ5LFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmNvbG9ycy5lbXBoYXNpemUodGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeSwgMC4wMyksXG4gICAgICB9LFxuICAgIH0pLFxuICAgIHRpdGxlOiBjc3Moe1xuICAgICAgZmxleEdyb3c6IDEsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5ib2R5U21hbGwuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGVtZS50eXBvZ3JhcGh5LmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICBtYXJnaW46IDAsXG4gICAgfSksXG4gICAgZGVzY3JpcHRpb246IGNzcyh7XG4gICAgICBjb2xvcjogdGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkuYm9keVNtYWxsLmZvbnRTaXplLFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgfSksXG4gICAgYm9keTogY3NzKHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIHBhZGRpbmdUb3A6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBnYXA6IHRoZW1lLnNwYWNpbmcoMiksXG4gICAgICBmbGV4V3JhcDogJ3dyYXAnLFxuICAgIH0pLFxuICAgIHRvZ2dsZTogY3NzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnksXG4gICAgICBtYXJnaW5SaWdodDogYCR7dGhlbWUuc3BhY2luZygxKX1gLFxuICAgIH0pLFxuICB9O1xufTtcbiIsImltcG9ydCB7IGNhcGl0YWxpemUgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmLFxuICBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlLFxuICBRdWVyeVdpdGhPcGVyYXRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFNlbGVjdGFibGVWYWx1ZSB9IGZyb20gJ0BncmFmYW5hL2RhdGEvc3JjJztcbmltcG9ydCB7IExhYmVsUGFyYW1FZGl0b3IgfSBmcm9tICcuLi9jb21wb25lbnRzL0xhYmVsUGFyYW1FZGl0b3InO1xuaW1wb3J0IHsgUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgcGx1cmFsaXplIGZyb20gJ3BsdXJhbGl6ZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvblJlbmRlcmVyTGVmdChtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgY29uc3QgcGFyYW1zID0gcmVuZGVyUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwcik7XG4gIGNvbnN0IHN0ciA9IG1vZGVsLmlkICsgJygnO1xuXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICBwYXJhbXMucHVzaChpbm5lckV4cHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ciArIHBhcmFtcy5qb2luKCcsICcpICsgJyknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25SZW5kZXJlclJpZ2h0KG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICBjb25zdCBwYXJhbXMgPSByZW5kZXJQYXJhbXMobW9kZWwsIGRlZiwgaW5uZXJFeHByKTtcbiAgY29uc3Qgc3RyID0gbW9kZWwuaWQgKyAnKCc7XG5cbiAgaWYgKGlubmVyRXhwcikge1xuICAgIHBhcmFtcy51bnNoaWZ0KGlubmVyRXhwcik7XG4gIH1cblxuICByZXR1cm4gc3RyICsgcGFyYW1zLmpvaW4oJywgJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKFxuICBtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLFxuICBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZixcbiAgaW5uZXJFeHByOiBzdHJpbmcsXG4gIHJlbmRlckxlZnQ6IGJvb2xlYW5cbikge1xuICBpZiAoZGVmLnBhcmFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgYENhbm5vdCByZW5kZXIgYSBmdW5jdGlvbiB3aXRoIHBhcmFtcyBvZiBsZW5ndGggWyR7ZGVmLnBhcmFtcy5sZW5ndGh9XWA7XG4gIH1cblxuICBsZXQgcmFuZ2VWZWN0b3IgPSAobW9kZWwucGFyYW1zID8/IFtdKVswXSA/PyAnNW0nO1xuXG4gIC8vIE5leHQgZnJhbWUgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLCBidXQgZ2V0IHJpZCBvZiB0aGUgZmlyc3Qgb25lIGJlY2F1c2UgaXQncyB1c2VkIHRvIG1vdmUgdGhlXG4gIC8vIGluc3RhbnQgdmVjdG9yIGludG8gYSByYW5nZSB2ZWN0b3IuXG4gIGNvbnN0IHBhcmFtcyA9IHJlbmRlclBhcmFtcyhcbiAgICB7XG4gICAgICAuLi5tb2RlbCxcbiAgICAgIHBhcmFtczogbW9kZWwucGFyYW1zLnNsaWNlKDEpLFxuICAgIH0sXG4gICAge1xuICAgICAgLi4uZGVmLFxuICAgICAgcGFyYW1zOiBkZWYucGFyYW1zLnNsaWNlKDEpLFxuICAgICAgZGVmYXVsdFBhcmFtczogZGVmLmRlZmF1bHRQYXJhbXMuc2xpY2UoMSksXG4gICAgfSxcbiAgICBpbm5lckV4cHJcbiAgKTtcblxuICBjb25zdCBzdHIgPSBtb2RlbC5pZCArICcoJztcblxuICAvLyBEZXBlbmRpbmcgb24gdGhlIHJlbmRlckxlZnQgdmFyaWFibGUsIHJlbmRlciBwYXJhbWV0ZXJzIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gIC8vIHJlbmRlckxlZnQgPT09IHRydWUgKHJlbmRlckxlZnQpID0+IChwYXJhbTEsIHBhcmFtMiwgcmFuZ2VWZWN0b3JbLi4uXSlcbiAgLy8gcmVuZGVyTGVmdCA9PT0gZmFsc2UgKHJlbmRlclJpZ2h0KSA9PiAocmFuZ2VWZWN0b3JbLi4uXSwgcGFyYW0xLCBwYXJhbTIpXG4gIGlmIChpbm5lckV4cHIpIHtcbiAgICByZW5kZXJMZWZ0ID8gcGFyYW1zLnB1c2goYCR7aW5uZXJFeHByfVske3JhbmdlVmVjdG9yfV1gKSA6IHBhcmFtcy51bnNoaWZ0KGAke2lubmVyRXhwcn1bJHtyYW5nZVZlY3Rvcn1dYCk7XG4gIH1cblxuICAvLyBzdGljayBldmVyeXRoaW5nIHRvZ2V0aGVyXG4gIHJldHVybiBzdHIgKyBwYXJhbXMuam9pbignLCAnKSArICcpJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJSaWdodFdpdGhQYXJhbXMoXG4gIG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBpbm5lckV4cHI6IHN0cmluZ1xuKSB7XG4gIHJldHVybiByYW5nZVJlbmRlcmVyV2l0aFBhcmFtcyhtb2RlbCwgZGVmLCBpbm5lckV4cHIsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlUmVuZGVyZXJMZWZ0V2l0aFBhcmFtcyhcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pIHtcbiAgcmV0dXJuIHJhbmdlUmVuZGVyZXJXaXRoUGFyYW1zKG1vZGVsLCBkZWYsIGlubmVyRXhwciwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBhcmFtcyhtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChtb2RlbC5wYXJhbXMgPz8gW10pLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFyYW1EZWYgPSBkZWYucGFyYW1zW2luZGV4XTtcbiAgICBpZiAocGFyYW1EZWYudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcjxUIGV4dGVuZHMgUXVlcnlXaXRoT3BlcmF0aW9ucz4oZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIHF1ZXJ5OiBUKSB7XG4gIGNvbnN0IG5ld09wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uID0ge1xuICAgIGlkOiBkZWYuaWQsXG4gICAgcGFyYW1zOiBkZWYuZGVmYXVsdFBhcmFtcyxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIG9wZXJhdGlvbnM6IFsuLi5xdWVyeS5vcGVyYXRpb25zLCBuZXdPcGVyYXRpb25dLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShmdW5jTmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBjYXBpdGFsaXplKGZ1bmNOYW1lLnJlcGxhY2UoL18vZywgJyAnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbUlkKG9wZXJhdGlvbkluZGV4OiBudW1iZXIsIHBhcmFtSW5kZXg6IG51bWJlcikge1xuICByZXR1cm4gYG9wZXJhdGlvbnMuJHtvcGVyYXRpb25JbmRleH0ucGFyYW0uJHtwYXJhbUluZGV4fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZVZlY3RvclBhcmFtRGVmKHdpdGhSYXRlSW50ZXJ2YWwgPSBmYWxzZSk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmIHtcbiAgY29uc3QgcGFyYW06IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmID0ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uczogW1xuICAgICAge1xuICAgICAgICBsYWJlbDogJyRfX2ludGVydmFsJyxcbiAgICAgICAgdmFsdWU6ICckX19pbnRlcnZhbCcsXG4gICAgICAgIC8vIHRvb2x0aXA6ICdEeW5hbWljIGludGVydmFsIGJhc2VkIG9uIG1heCBkYXRhIHBvaW50cywgc2NyYXBlIGFuZCBtaW4gaW50ZXJ2YWwnLFxuICAgICAgfSxcbiAgICAgIHsgbGFiZWw6ICcxbScsIHZhbHVlOiAnMW0nIH0sXG4gICAgICB7IGxhYmVsOiAnNW0nLCB2YWx1ZTogJzVtJyB9LFxuICAgICAgeyBsYWJlbDogJzEwbScsIHZhbHVlOiAnMTBtJyB9LFxuICAgICAgeyBsYWJlbDogJzFoJywgdmFsdWU6ICcxaCcgfSxcbiAgICAgIHsgbGFiZWw6ICcyNGgnLCB2YWx1ZTogJzI0aCcgfSxcbiAgICBdLFxuICB9O1xuXG4gIGlmICh3aXRoUmF0ZUludGVydmFsKSB7XG4gICAgKHBhcmFtLm9wdGlvbnMgYXMgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+KS51bnNoaWZ0KHtcbiAgICAgIGxhYmVsOiAnJF9fcmF0ZV9pbnRlcnZhbCcsXG4gICAgICB2YWx1ZTogJyRfX3JhdGVfaW50ZXJ2YWwnLFxuICAgICAgLy8gdG9vbHRpcDogJ0Fsd2F5cyBhYm92ZSA0eCBzY3JhcGUgaW50ZXJ2YWwnLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2hhcmVkIGJldHdlZW4gUHJvbWV0aGV1cyBhbmQgTG9raSB2YXJpYW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb248VCBleHRlbmRzIFF1ZXJ5V2l0aE9wZXJhdGlvbnM+KFxuICBuYW1lOiBzdHJpbmcsXG4gIG92ZXJyaWRlczogUGFydGlhbDxRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY+ID0ge31cbik6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdIHtcbiAgY29uc3Qgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmW10gPSBbXG4gICAge1xuICAgICAgaWQ6IG5hbWUsXG4gICAgICBuYW1lOiBnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnQnkgbGFiZWwnLFxuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIHJlc3RQYXJhbTogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbXSxcbiAgICAgIGFsdGVybmF0aXZlc0tleTogJ3BsYWluIGFnZ3JlZ2F0aW9ucycsXG4gICAgICBjYXRlZ29yeTogUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkuQWdncmVnYXRpb25zLFxuICAgICAgcmVuZGVyZXI6IGZ1bmN0aW9uUmVuZGVyZXJMZWZ0LFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0T25MYWJlbEFkZGVkSGFuZGxlcihgX18ke25hbWV9X2J5YCksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJycpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogYF9fJHtuYW1lfV9ieWAsXG4gICAgICBuYW1lOiBgJHtnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lKG5hbWUpfSBieWAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyKG5hbWUpLFxuICAgICAgcGFyYW1DaGFuZ2VkSGFuZGxlcjogZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIobmFtZSksXG4gICAgICBleHBsYWluSGFuZGxlcjogZ2V0QWdncmVnYXRpb25FeHBsYWluZXIobmFtZSwgJ2J5JyksXG4gICAgICBhZGRPcGVyYXRpb25IYW5kbGVyOiBkZWZhdWx0QWRkT3BlcmF0aW9uSGFuZGxlcixcbiAgICAgIGhpZGVGcm9tTGlzdDogdHJ1ZSxcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiBgX18ke25hbWV9X3dpdGhvdXRgLFxuICAgICAgbmFtZTogYCR7Z2V0UHJvbUFuZExva2lPcGVyYXRpb25EaXNwbGF5TmFtZShuYW1lKX0gd2l0aG91dGAsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdMYWJlbCcsXG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgcmVzdFBhcmFtOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGVkaXRvcjogTGFiZWxQYXJhbUVkaXRvcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkZWZhdWx0UGFyYW1zOiBbJyddLFxuICAgICAgYWx0ZXJuYXRpdmVzS2V5OiAnYWdncmVnYXRpb25zIGJ5JyxcbiAgICAgIGNhdGVnb3J5OiBQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeS5BZ2dyZWdhdGlvbnMsXG4gICAgICByZW5kZXJlcjogZ2V0QWdncmVnYXRpb25XaXRob3V0UmVuZGVyZXIobmFtZSksXG4gICAgICBwYXJhbUNoYW5nZWRIYW5kbGVyOiBnZXRMYXN0TGFiZWxSZW1vdmVkSGFuZGxlcihuYW1lKSxcbiAgICAgIGV4cGxhaW5IYW5kbGVyOiBnZXRBZ2dyZWdhdGlvbkV4cGxhaW5lcihuYW1lLCAnd2l0aG91dCcpLFxuICAgICAgYWRkT3BlcmF0aW9uSGFuZGxlcjogZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIsXG4gICAgICBoaWRlRnJvbUxpc3Q6IHRydWUsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfSxcbiAgXTtcblxuICByZXR1cm4gb3BlcmF0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uV2l0aFBhcmFtKFxuICBuYW1lOiBzdHJpbmcsXG4gIHBhcmFtc0RlZjogeyBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW107IGRlZmF1bHRQYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXSB9LFxuICBvdmVycmlkZXM6IFBhcnRpYWw8UXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPiA9IHt9XG4pOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXSB7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBjcmVhdGVBZ2dyZWdhdGlvbk9wZXJhdGlvbihuYW1lLCBvdmVycmlkZXMpO1xuICBvcGVyYXRpb25zWzBdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzFdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzJdLnBhcmFtcy51bnNoaWZ0KC4uLnBhcmFtc0RlZi5wYXJhbXMpO1xuICBvcGVyYXRpb25zWzBdLmRlZmF1bHRQYXJhbXMgPSBwYXJhbXNEZWYuZGVmYXVsdFBhcmFtcztcbiAgb3BlcmF0aW9uc1sxXS5kZWZhdWx0UGFyYW1zID0gWy4uLnBhcmFtc0RlZi5kZWZhdWx0UGFyYW1zLCAnJ107XG4gIG9wZXJhdGlvbnNbMl0uZGVmYXVsdFBhcmFtcyA9IFsuLi5wYXJhbXNEZWYuZGVmYXVsdFBhcmFtcywgJyddO1xuICBvcGVyYXRpb25zWzFdLnJlbmRlcmVyID0gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihuYW1lKTtcbiAgb3BlcmF0aW9uc1syXS5yZW5kZXJlciA9IGdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIobmFtZSk7XG4gIHJldHVybiBvcGVyYXRpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRBZ2dyZWdhdGlvbkJ5UmVuZGVyZXIoYWdncmVnYXRpb246IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25SZW5kZXJlcihtb2RlbDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZiwgaW5uZXJFeHByOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7YWdncmVnYXRpb259IGJ5KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFnZ3JlZ2F0aW9uV2l0aG91dFJlbmRlcmVyKGFnZ3JlZ2F0aW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFnZ3JlZ2F0aW9uUmVuZGVyZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsIGlubmVyRXhwcjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke2FnZ3JlZ2F0aW9ufSB3aXRob3V0KCR7bW9kZWwucGFyYW1zLmpvaW4oJywgJyl9KSAoJHtpbm5lckV4cHJ9KWA7XG4gIH07XG59XG5cbi8qKlxuICogVmVyeSBzaW1wbGUgcG9jIGltcGxlbWVudGF0aW9uLCBuZWVkcyB0byBiZSBtb2RpZmllZCB0byBzdXBwb3J0IGFsbCBhZ2dyZWdhdGlvbiBvcGVyYXRvcnNcbiAqL1xuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25FeHBsYWluZXIoYWdncmVnYXRpb25OYW1lOiBzdHJpbmcsIG1vZGU6ICdieScgfCAnd2l0aG91dCcgfCAnJykge1xuICByZXR1cm4gZnVuY3Rpb24gYWdncmVnYXRpb25FeHBsYWluZXIobW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbikge1xuICAgIGNvbnN0IGxhYmVscyA9IG1vZGVsLnBhcmFtcy5tYXAoKGxhYmVsKSA9PiBgXFxgJHtsYWJlbH1cXGBgKS5qb2luKCcgYW5kICcpO1xuICAgIGNvbnN0IGxhYmVsV29yZCA9IHBsdXJhbGl6ZSgnbGFiZWwnLCBtb2RlbC5wYXJhbXMubGVuZ3RoKTtcblxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnYnknOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgZGltZW5zaW9ucyB3aGlsZSBwcmVzZXJ2aW5nICR7bGFiZWxXb3JkfSAke2xhYmVsc30uYDtcbiAgICAgIGNhc2UgJ3dpdGhvdXQnOlxuICAgICAgICByZXR1cm4gYENhbGN1bGF0ZXMgJHthZ2dyZWdhdGlvbk5hbWV9IG92ZXIgdGhlIGRpbWVuc2lvbnMgJHtsYWJlbHN9LiBBbGwgb3RoZXIgbGFiZWxzIGFyZSBwcmVzZXJ2ZWQuYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgQ2FsY3VsYXRlcyAke2FnZ3JlZ2F0aW9uTmFtZX0gb3ZlciB0aGUgZGltZW5zaW9ucy5gO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyV2l0aFBhcmFtZXRlcihhZ2dyZWdhdGlvbjogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZ2dyZWdhdGlvblJlbmRlcmVyKG1vZGVsOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLCBpbm5lckV4cHI6IHN0cmluZykge1xuICAgIGZ1bmN0aW9uIG1hcFR5cGUocDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYFxcXCIke3B9XFxcImA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDAsIC0xKTtcbiAgICBjb25zdCByZXN0UGFyYW1zID0gbW9kZWwucGFyYW1zLnNsaWNlKDEpO1xuICAgIHJldHVybiBgJHthZ2dyZWdhdGlvbn0gYnkoJHtyZXN0UGFyYW1zLmpvaW4oJywgJyl9KSAoJHtwYXJhbXMubWFwKG1hcFR5cGUpLmpvaW4oJywgJyl9LCAke2lubmVyRXhwcn0pYDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdHJhbnNmb3JtIG9wZXJhdGlvbnMgd2l0aG91dCBsYWJlbHMgdG8gdGhlaXIgcGxhbiBhZ2dyZWdhdGlvbiBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIoY2hhbmdlVG9PcGVyYXRpb25JZDogc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvblBhcmFtQ2hhbmdlZChpbmRleDogbnVtYmVyLCBvcDogUXVlcnlCdWlsZGVyT3BlcmF0aW9uLCBkZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZikge1xuICAgIC8vIElmIGRlZmluaXRpb24gaGFzIG1vcmUgcGFyYW1zIHRoZW4gaXMgZGVmaW5lZCB0aGVyZSBhcmUgbm8gb3B0aW9uYWwgcmVzdCBwYXJhbXMgYW55bW9yZS5cbiAgICAvLyBXZSB0aGVuIHRyYW5zZm9ybSB0aGlzIG9wZXJhdGlvbiBpbnRvIGEgZGlmZmVyZW50IG9uZVxuICAgIGlmIChvcC5wYXJhbXMubGVuZ3RoIDwgZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPbkxhYmVsQWRkZWRIYW5kbGVyKGNoYW5nZVRvT3BlcmF0aW9uSWQ6IHN0cmluZykge1xuICByZXR1cm4gZnVuY3Rpb24gb25QYXJhbUNoYW5nZWQoaW5kZXg6IG51bWJlciwgb3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIHRoZSBsYWJlbCBwYXJhbS4gQXMgaXQncyBvcHRpb25hbCB0aGUgYWdncmVnYXRpb24gY2FuIGhhdmUgb25lIGxlc3MsIHdoaWNoIGlzIHRoZVxuICAgIC8vIGNhc2Ugb2YganVzdCBzaW1wbGUgYWdncmVnYXRpb24gd2l0aG91dCBsYWJlbC4gV2hlbiB1c2VyIGFkZHMgdGhlIGxhYmVsIGl0IG5vdyBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIHBhcmFtc1xuICAgIC8vIGFzIGl0J3MgZGVmaW5pdGlvbiwgYW5kIG5vdyB3ZSBjYW4gY2hhbmdlIGl0IHRvIGl0J3MgYF9ieWAgdmFyaWFudC5cbiAgICBpZiAob3AucGFyYW1zLmxlbmd0aCA9PT0gZGVmLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wLFxuICAgICAgICBpZDogY2hhbmdlVG9PcGVyYXRpb25JZCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcDtcbiAgfTtcbn1cbiIsImltcG9ydCB7IFN5bnRheE5vZGUsIFRyZWVDdXJzb3IgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBUaGlzIGlzIHVzZWQgZm9yIGVycm9yIHR5cGUgZm9yIHNvbWUgcmVhc29uXG5leHBvcnQgY29uc3QgRXJyb3JOYW1lID0gJ+KaoCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWZ0TW9zdENoaWxkKGN1cjogU3ludGF4Tm9kZSk6IFN5bnRheE5vZGUge1xuICByZXR1cm4gY3VyLmZpcnN0Q2hpbGQgPyBnZXRMZWZ0TW9zdENoaWxkKGN1ci5maXJzdENoaWxkKSA6IGN1cjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcihleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiBnZXRTdHJpbmcoZXhwciwgbm9kZSksXG4gICAgLy8gVE9ETzogdGhpcyBhcmUgcG9zaXRpb25zIGluIHRoZSBzdHJpbmcgd2l0aCB0aGUgcmVwbGFjZWQgdmFyaWFibGVzLiBNZWFucyBpdCBjYW5ub3QgYmUgdXNlZCB0byBzaG93IGV4YWN0XG4gICAgLy8gIHBsYWNlbWVudCBvZiB0aGUgZXJyb3IgZm9yIHRoZSB1c2VyLiBXZSBuZWVkIHNvbWUgdHJhbnNsYXRpb24gdGFibGUgdG8gcG9zaXRpb25zIGJlZm9yZSB0aGUgdmFyaWFibGVcbiAgICAvLyAgcmVwbGFjZS5cbiAgICBmcm9tOiBub2RlLmZyb20sXG4gICAgdG86IG5vZGUudG8sXG4gICAgcGFyZW50VHlwZTogbm9kZS5wYXJlbnQ/Lm5hbWUsXG4gIH07XG59XG5cbi8vIFRha2VuIGZyb20gdGVtcGxhdGVfc3J2LCBidXQgY29waWVkIHNvIHRvIG5vdCBtZXNzIHdpdGggdGhlIHJlZ2V4LmluZGV4IHdoaWNoIGlzIG1hbmlwdWxhdGVkIGluIHRoZSBzZXJ2aWNlXG4vKlxuICogVGhpcyByZWdleCBtYXRjaGVzIDMgdHlwZXMgb2YgdmFyaWFibGUgcmVmZXJlbmNlIHdpdGggYW4gb3B0aW9uYWwgZm9ybWF0IHNwZWNpZmllclxuICogXFwkKFxcdyspICAgICAgICAgICAgICAgICAgICAgICAgICAkdmFyMVxuICogXFxbXFxbKFtcXHNcXFNdKz8pKD86OihcXHcrKSk/XFxdXFxdICAgIFtbdmFyMl1dIG9yIFtbdmFyMjpmbXQyXV1cbiAqIFxcJHsoXFx3KykoPzo6KFxcdyspKT99ICAgICAgICAgICAgICR7dmFyM30gb3IgJHt2YXIzOmZtdDN9XG4gKi9cbmNvbnN0IHZhcmlhYmxlUmVnZXggPSAvXFwkKFxcdyspfFxcW1xcWyhbXFxzXFxTXSs/KSg/OjooXFx3KykpP1xcXVxcXXxcXCR7KFxcdyspKD86XFwuKFteOl5cXH1dKykpPyg/OjooW15cXH1dKykpP30vZztcblxuLyoqXG4gKiBBcyB2YXJpYWJsZXMgd2l0aCAkIGFyZSBjcmVhdGluZyBwYXJzaW5nIGVycm9ycywgd2UgZmlyc3QgcmVwbGFjZSB0aGVtIHdpdGggbWFnaWMgc3RyaW5nIHRoYXQgaXMgcGFyc2FibGUgYW5kIGF0XG4gKiB0aGUgc2FtZSB0aW1lIHdlIGNhbiBnZXQgdGhlIHZhcmlhYmxlIGFuZCBpdCdzIGZvcm1hdCBiYWNrIGZyb20gaXQuXG4gKiBAcGFyYW0gZXhwclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVZhcmlhYmxlcyhleHByOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGV4cHIucmVwbGFjZSh2YXJpYWJsZVJlZ2V4LCAobWF0Y2gsIHZhcjEsIHZhcjIsIGZtdDIsIHZhcjMsIGZpZWxkUGF0aCwgZm10MykgPT4ge1xuICAgIGNvbnN0IGZtdCA9IGZtdDIgfHwgZm10MztcbiAgICBsZXQgdmFyaWFibGUgPSB2YXIxO1xuICAgIGxldCB2YXJUeXBlID0gJzAnO1xuXG4gICAgaWYgKHZhcjIpIHtcbiAgICAgIHZhcmlhYmxlID0gdmFyMjtcbiAgICAgIHZhclR5cGUgPSAnMSc7XG4gICAgfVxuXG4gICAgaWYgKHZhcjMpIHtcbiAgICAgIHZhcmlhYmxlID0gdmFyMztcbiAgICAgIHZhclR5cGUgPSAnMic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBfX1ZfJHt2YXJUeXBlfV9fYCArIHZhcmlhYmxlICsgJ19fVl9fJyArIChmbXQgPyAnX19GX18nICsgZm10ICsgJ19fRl9fJyA6ICcnKTtcbiAgfSk7XG59XG5cbmNvbnN0IHZhclR5cGVGdW5jID0gW1xuICAodjogc3RyaW5nLCBmPzogc3RyaW5nKSA9PiBgXFwkJHt2fWAsXG4gICh2OiBzdHJpbmcsIGY/OiBzdHJpbmcpID0+IGBbWyR7dn0ke2YgPyBgOiR7Zn1gIDogJyd9XV1gLFxuICAodjogc3RyaW5nLCBmPzogc3RyaW5nKSA9PiBgXFwkXFx7JHt2fSR7ZiA/IGA6JHtmfWAgOiAnJ31cXH1gLFxuXTtcblxuLyoqXG4gKiBHZXQgYmFjayB0aGUgdGV4dCB3aXRoIHZhcmlhYmxlcyBpbiB0aGVpciBvcmlnaW5hbCBmb3JtYXQuXG4gKiBAcGFyYW0gZXhwclxuICovXG5mdW5jdGlvbiByZXR1cm5WYXJpYWJsZXMoZXhwcjogc3RyaW5nKSB7XG4gIHJldHVybiBleHByLnJlcGxhY2UoL19fVl8oXFxkKV9fKC4rPylfX1ZfXyg/Ol9fRl9fKFxcdyspX19GX18pPy9nLCAobWF0Y2gsIHR5cGUsIHYsIGYpID0+IHtcbiAgICByZXR1cm4gdmFyVHlwZUZ1bmNbcGFyc2VJbnQodHlwZSwgMTApXSh2LCBmKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhY3R1YWwgc3RyaW5nIG9mIHRoZSBleHByZXNzaW9uLiBUaGF0IGlzIG5vdCBzdG9yZWQgaW4gdGhlIHRyZWUgc28gd2UgaGF2ZSB0byBnZXQgdGhlIGluZGV4ZXMgZnJvbSB0aGUgbm9kZVxuICogYW5kIHRoZW4gYmFzZWQgb24gdGhhdCBnZXQgaXQgZnJvbSB0aGUgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSBleHByXG4gKiBAcGFyYW0gbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaW5nKGV4cHI6IHN0cmluZywgbm9kZTogU3ludGF4Tm9kZSB8IFRyZWVDdXJzb3IgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcmV0dXJuVmFyaWFibGVzKGV4cHIuc3Vic3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50bykpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBzaW1wbGUgc2NhbGFyIGJpbmFyeSBvcCBvYmplY3QuXG4gKiBAcGFyYW0gb3BEZWYgLSBkZWZpbml0aW9uIG9mIHRoZSBvcCB0byBiZSBjcmVhdGVkXG4gKiBAcGFyYW0gZXhwclxuICogQHBhcmFtIG51bWJlck5vZGUgLSB0aGUgbm9kZSBmb3IgdGhlIHNjYWxhclxuICogQHBhcmFtIGhhc0Jvb2wgLSB3aGV0aGVyIG9wZXJhdGlvbiBoYXMgYSBib29sIG1vZGlmaWVyLiBJcyB1c2VkIG9ubHkgZm9yIG9wcyBmb3Igd2hpY2ggaXQgbWFrZXMgc2Vuc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQmluT3AoXG4gIG9wRGVmOiB7IGlkOiBzdHJpbmc7IGNvbXBhcmlzb24/OiBib29sZWFuIH0sXG4gIGV4cHI6IHN0cmluZyxcbiAgbnVtYmVyTm9kZTogU3ludGF4Tm9kZSxcbiAgaGFzQm9vbDogYm9vbGVhblxuKTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uIHtcbiAgY29uc3QgcGFyYW1zOiBhbnlbXSA9IFtwYXJzZUZsb2F0KGdldFN0cmluZyhleHByLCBudW1iZXJOb2RlKSldO1xuICBpZiAob3BEZWYuY29tcGFyaXNvbikge1xuICAgIHBhcmFtcy5wdXNoKGhhc0Jvb2wpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IG9wRGVmLmlkLFxuICAgIHBhcmFtcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgYWxsIG5vZGVzIHdpdGggdHlwZSBpbiB0aGUgdHJlZS4gVGhpcyB0cmF2ZXJzZXMgdGhlIHRyZWUgc28gaXQgaXMgc2FmZSBvbmx5IHdoZW4geW91IGtub3cgdGhlcmUgc2hvdWxkbid0IGJlXG4gKiB0b28gbXVjaCBuZXN0aW5nIGJ1dCB5b3UganVzdCB3YW50IHRvIHNraXAgc29tZSBvZiB0aGUgd3JhcHBlcnMuIEZvciBleGFtcGxlIGdldHRpbmcgZnVuY3Rpb24gYXJncyB0aGlzIHdheSB3b3VsZFxuICogbm90IGJlIHNhZmUgaXMgaXQgd291bGQgYWxzbyBmaW5kIGFyZ3VtZW50cyBvZiBuZXN0ZWQgZnVuY3Rpb25zLlxuICogQHBhcmFtIGV4cHJcbiAqIEBwYXJhbSBjdXJcbiAqIEBwYXJhbSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxCeVR5cGUoZXhwcjogc3RyaW5nLCBjdXI6IFN5bnRheE5vZGUsIHR5cGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgaWYgKGN1ci5uYW1lID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIFtnZXRTdHJpbmcoZXhwciwgY3VyKV07XG4gIH1cbiAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgcG9zID0gMDtcbiAgbGV0IGNoaWxkID0gY3VyLmNoaWxkQWZ0ZXIocG9zKTtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgdmFsdWVzLnB1c2goLi4uZ2V0QWxsQnlUeXBlKGV4cHIsIGNoaWxkLCB0eXBlKSk7XG4gICAgcG9zID0gY2hpbGQudG87XG4gICAgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8vIERlYnVnZ2luZyBmdW5jdGlvbiBmb3IgY29udmVuaWVuY2UuIEdpdmVzIHlvdSBuaWNlIG91dHB1dCBzaW1pbGFyIHRvIGxpbnV4IHRyZWUgdXRpbC5cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBmdW5jdGlvbiBsb2coZXhwcjogc3RyaW5nLCBjdXI/OiBTeW50YXhOb2RlKSB7XG4gIGlmICghY3VyKSB7XG4gICAgY29uc29sZS5sb2coJzxlbXB0eT4nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QganNvbiA9IHRvSnNvbihleHByLCBjdXIpO1xuICBjb25zdCB0ZXh0ID0ganNvblRvVGV4dChqc29uKTtcblxuICBpZiAoIXRleHQpIHtcbiAgICBjb25zb2xlLmxvZygnPGVtcHR5PicpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmxvZyh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gdG9Kc29uKGV4cHI6IHN0cmluZywgY3VyOiBTeW50YXhOb2RlKSB7XG4gIGNvbnN0IHRyZWVKc29uOiBhbnkgPSB7fTtcbiAgY29uc3QgbmFtZSA9IG5vZGVUb1N0cmluZyhleHByLCBjdXIpO1xuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuXG4gIGxldCBwb3MgPSAwO1xuICBsZXQgY2hpbGQgPSBjdXIuY2hpbGRBZnRlcihwb3MpO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBjaGlsZHJlbi5wdXNoKHRvSnNvbihleHByLCBjaGlsZCkpO1xuICAgIHBvcyA9IGNoaWxkLnRvO1xuICAgIGNoaWxkID0gY3VyLmNoaWxkQWZ0ZXIocG9zKTtcbiAgfVxuXG4gIHRyZWVKc29uLm5hbWUgPSBuYW1lO1xuICB0cmVlSnNvbi5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICByZXR1cm4gdHJlZUpzb247XG59XG5cbnR5cGUgSnNvbk5vZGUgPSB7XG4gIG5hbWU6IHN0cmluZztcbiAgY2hpbGRyZW46IEpzb25Ob2RlW107XG59O1xuXG5mdW5jdGlvbiBqc29uVG9UZXh0KFxuICBub2RlOiBKc29uTm9kZSxcbiAgY29udGV4dDogeyBsYXN0Q2hpbGQ6IGJvb2xlYW47IGluZGVudDogc3RyaW5nIH0gPSB7XG4gICAgbGFzdENoaWxkOiB0cnVlLFxuICAgIGluZGVudDogJycsXG4gIH1cbikge1xuICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICBjb25zdCB7IGxhc3RDaGlsZCwgaW5kZW50IH0gPSBjb250ZXh0O1xuICBjb25zdCBuZXdJbmRlbnQgPSBpbmRlbnQgIT09ICcnID8gaW5kZW50ICsgKGxhc3RDaGlsZCA/ICfilJTilIAnIDogJ+KUnOKUgCcpIDogJyc7XG4gIGxldCB0ZXh0ID0gbmV3SW5kZW50ICsgbmFtZTtcblxuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBpc0xhc3RDaGlsZCA9IGluZGV4ID09PSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIHRleHQgKz1cbiAgICAgICdcXG4nICtcbiAgICAgIGpzb25Ub1RleHQoY2hpbGQsIHtcbiAgICAgICAgbGFzdENoaWxkOiBpc0xhc3RDaGlsZCxcbiAgICAgICAgaW5kZW50OiBpbmRlbnQgKyAobGFzdENoaWxkID8gJyAgJyA6ICfilIIgJyksXG4gICAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRleHQ7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb1N0cmluZyhleHByOiBzdHJpbmcsIG5vZGU6IFN5bnRheE5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmFtZSArICc6ICcgKyBnZXRTdHJpbmcoZXhwciwgbm9kZSk7XG59XG4iLCIvKipcbiAqIFNoYXJlZCB0eXBlcyB0aGF0IGNhbiBiZSByZXVzZWQgYnkgTG9raSBhbmQgb3RoZXIgZGF0YSBzb3VyY2VzXG4gKi9cblxuaW1wb3J0IHsgRGF0YVNvdXJjZUFwaSwgUmVnaXN0cnlJdGVtLCBTZWxlY3RhYmxlVmFsdWUgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXIge1xuICBsYWJlbDogc3RyaW5nO1xuICBvcDogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHBhcmFtczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5V2l0aE9wZXJhdGlvbnMge1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWY8VCA9IGFueT4gZXh0ZW5kcyBSZWdpc3RyeUl0ZW0ge1xuICBkb2N1bWVudGF0aW9uPzogc3RyaW5nO1xuICBwYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmW107XG4gIGRlZmF1bHRQYXJhbXM6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtVmFsdWVbXTtcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgaGlkZUZyb21MaXN0PzogYm9vbGVhbjtcbiAgYWx0ZXJuYXRpdmVzS2V5Pzogc3RyaW5nO1xuICAvKiogQ2FuIGJlIHVzZWQgdG8gY29udHJvbCBvcGVyYXRpb24gcGxhY2VtZW50IHdoZW4gYWRkaW5nIGEgbmV3IG9wZXJhdGlvbnMsIGxvd2VyIGFyZSBwbGFjZWQgZmlyc3QgKi9cbiAgb3JkZXJSYW5rPzogbnVtYmVyO1xuICByZW5kZXJlcjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUmVuZGVyZXI7XG4gIGFkZE9wZXJhdGlvbkhhbmRsZXI6IFF1ZXJ5QnVpbGRlckFkZE9wZXJhdGlvbkhhbmRsZXI8VD47XG4gIHBhcmFtQ2hhbmdlZEhhbmRsZXI/OiBRdWVyeUJ1aWxkZXJPblBhcmFtQ2hhbmdlZEhhbmRsZXI7XG4gIGV4cGxhaW5IYW5kbGVyPzogUXVlcnlCdWlsZGVyRXhwbGFpbk9wZXJhdGlvbkhhbmRsZXI7XG4gIGNoYW5nZVR5cGVIYW5kbGVyPzogKG9wOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb24sIG5ld0RlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmPFQ+KSA9PiBRdWVyeUJ1aWxkZXJPcGVyYXRpb247XG59XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5QnVpbGRlckFkZE9wZXJhdGlvbkhhbmRsZXI8VD4gPSAoXG4gIGRlZjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uRGVmLFxuICBxdWVyeTogVCxcbiAgbW9kZWxsZXI6IFZpc3VhbFF1ZXJ5TW9kZWxsZXJcbikgPT4gVDtcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyRXhwbGFpbk9wZXJhdGlvbkhhbmRsZXIgPSAob3A6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbiwgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYpID0+IHN0cmluZztcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT25QYXJhbUNoYW5nZWRIYW5kbGVyID0gKFxuICBpbmRleDogbnVtYmVyLFxuICBvcGVyYXRpb246IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgb3BlcmF0aW9uRGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZcbikgPT4gUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuXG5leHBvcnQgdHlwZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25SZW5kZXJlciA9IChcbiAgbW9kZWw6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbixcbiAgZGVmOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYsXG4gIGlubmVyRXhwcjogc3RyaW5nXG4pID0+IHN0cmluZztcblxuZXhwb3J0IHR5cGUgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZSA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW47XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1EZWYge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6ICdzdHJpbmcnIHwgJ251bWJlcicgfCAnYm9vbGVhbic7XG4gIG9wdGlvbnM/OiBzdHJpbmdbXSB8IG51bWJlcltdIHwgQXJyYXk8U2VsZWN0YWJsZVZhbHVlPHN0cmluZz4+O1xuICBoaWRlTmFtZT86IGJvb2xlYW47XG4gIHJlc3RQYXJhbT86IGJvb2xlYW47XG4gIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBtaW5XaWR0aD86IG51bWJlcjtcbiAgZWRpdG9yPzogQ29tcG9uZW50VHlwZTxRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbUVkaXRvclByb3BzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJ1aWxkZXJPcGVyYXRpb25FZGl0b3JQcm9wcyB7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBpbmRleDogbnVtYmVyO1xuICBxdWVyeTogYW55O1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBxdWVyeU1vZGVsbGVyOiBWaXN1YWxRdWVyeU1vZGVsbGVyO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHVwZGF0ZTogUXVlcnlCdWlsZGVyT3BlcmF0aW9uKSA9PiB2b2lkO1xuICBvblJlbW92ZTogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1FZGl0b3JQcm9wcyB7XG4gIHZhbHVlPzogUXVlcnlCdWlsZGVyT3BlcmF0aW9uUGFyYW1WYWx1ZTtcbiAgcGFyYW1EZWY6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvblBhcmFtRGVmO1xuICAvKiogUGFyYW1ldGVyIGluZGV4ICovXG4gIGluZGV4OiBudW1iZXI7XG4gIG9wZXJhdGlvbjogUXVlcnlCdWlsZGVyT3BlcmF0aW9uO1xuICBvcGVyYXRpb25JbmRleDogbnVtYmVyO1xuICBxdWVyeTogYW55O1xuICBkYXRhc291cmNlOiBEYXRhU291cmNlQXBpO1xuICBvbkNoYW5nZTogKGluZGV4OiBudW1iZXIsIHZhbHVlOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25QYXJhbVZhbHVlKSA9PiB2b2lkO1xuICBvblJ1blF1ZXJ5OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZW51bSBRdWVyeUVkaXRvck1vZGUge1xuICBDb2RlID0gJ2NvZGUnLFxuICBCdWlsZGVyID0gJ2J1aWxkZXInLFxuICBFeHBsYWluID0gJ2V4cGxhaW4nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpc3VhbFF1ZXJ5TW9kZWxsZXIge1xuICBnZXRPcGVyYXRpb25zRm9yQ2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZyk6IFF1ZXJ5QnVpbGRlck9wZXJhdGlvbkRlZltdO1xuICBnZXRBbHRlcm5hdGl2ZU9wZXJhdGlvbnMoa2V5OiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWZbXTtcbiAgZ2V0Q2F0ZWdvcmllcygpOiBzdHJpbmdbXTtcbiAgZ2V0T3BlcmF0aW9uRGVmKGlkOiBzdHJpbmcpOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25EZWYgfCB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBDb3JlQXBwIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgc3RvcmUgZnJvbSAnYXBwL2NvcmUvc3RvcmUnO1xuaW1wb3J0IHsgTGVnZW5kRm9ybWF0TW9kZSwgUHJvbVF1ZXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgUXVlcnlFZGl0b3JNb2RlIH0gZnJvbSAnLi9zaGFyZWQvdHlwZXMnO1xuXG5jb25zdCBxdWVyeUVkaXRvck1vZGVEZWZhdWx0TG9jYWxTdG9yYWdlS2V5ID0gJ1Byb21ldGhldXNRdWVyeUVkaXRvck1vZGVEZWZhdWx0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZUVkaXRvck1vZGUocXVlcnk6IFByb21RdWVyeSwgZWRpdG9yTW9kZTogUXVlcnlFZGl0b3JNb2RlLCBvbkNoYW5nZTogKHF1ZXJ5OiBQcm9tUXVlcnkpID0+IHZvaWQpIHtcbiAgLy8gSWYgZW1wdHkgcXVlcnkgc3RvcmUgbmV3IG1vZGUgYXMgZGVmYXVsdFxuICBpZiAocXVlcnkuZXhwciA9PT0gJycpIHtcbiAgICBzdG9yZS5zZXQocXVlcnlFZGl0b3JNb2RlRGVmYXVsdExvY2FsU3RvcmFnZUtleSwgZWRpdG9yTW9kZSk7XG4gIH1cblxuICBvbkNoYW5nZSh7IC4uLnF1ZXJ5LCBlZGl0b3JNb2RlIH0pO1xufVxuXG4vLyBAdHMtaWdub3JlIFdpbGwgYmUgdXNlZCBhZnRlciBidWlsZGVyIGlzIG91dCBvZiBiZXRhXG5mdW5jdGlvbiBnZXREZWZhdWx0RWRpdG9yTW9kZShleHByOiBzdHJpbmcpIHtcbiAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGFuIGV4cHJlc3Npb24gZGVmYXVsdCB0byBjb2RlIHZpZXdcbiAgaWYgKGV4cHIgIT0gbnVsbCAmJiBleHByICE9PSAnJykge1xuICAgIHJldHVybiBRdWVyeUVkaXRvck1vZGUuQ29kZTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gc3RvcmUuZ2V0KHF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXkpIGFzIFF1ZXJ5RWRpdG9yTW9kZTtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXI6XG4gICAgY2FzZSBRdWVyeUVkaXRvck1vZGUuQ29kZTpcbiAgICBjYXNlIFF1ZXJ5RWRpdG9yTW9kZS5FeHBsYWluOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUXVlcnlFZGl0b3JNb2RlLkJ1aWxkZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHF1ZXJ5IHdpdGggZGVmYXVsdHMsIGFuZCBib29sZWFuIHRydWUvZmFsc2UgZGVwZW5kaW5nIG9uIGNoYW5nZSB3YXMgcmVxdWlyZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFF1ZXJ5V2l0aERlZmF1bHRzKHF1ZXJ5OiBQcm9tUXVlcnksIGFwcDogQ29yZUFwcCB8IHVuZGVmaW5lZCk6IFByb21RdWVyeSB7XG4gIGxldCByZXN1bHQgPSBxdWVyeTtcblxuICBpZiAoIXF1ZXJ5LmVkaXRvck1vZGUpIHtcbiAgICAvLyBEZWZhdWx0IHRvIENvZGUgbW9kZSB1bnRpbCB3ZSBhcmUgb3V0IG9mIGJldGEgd2l0aCB0aGUgYnVpbGRlciwgdGhlbiB1c2UgZ2V0RGVmYXVsdEVkaXRvck1vZGUuXG4gICAgcmVzdWx0ID0geyAuLi5xdWVyeSwgZWRpdG9yTW9kZTogUXVlcnlFZGl0b3JNb2RlLkNvZGUgfTtcbiAgfVxuXG4gIGlmIChxdWVyeS5leHByID09IG51bGwpIHtcbiAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCwgZXhwcjogJycsIGxlZ2VuZEZvcm1hdDogTGVnZW5kRm9ybWF0TW9kZS5BdXRvIH07XG4gIH1cblxuICBpZiAocXVlcnkucmFuZ2UgPT0gbnVsbCAmJiBxdWVyeS5pbnN0YW50ID09IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHRvIHJhbmdlIHF1ZXJ5XG4gICAgcmVzdWx0ID0geyAuLi5yZXN1bHQsIHJhbmdlOiB0cnVlIH07XG5cbiAgICAvLyBJbiBleHBsb3JlIHdlIGRlZmF1bHQgdG8gYm90aCBpbnN0YW50ICYgcmFuZ2VcbiAgICBpZiAoYXBwID09PSBDb3JlQXBwLkV4cGxvcmUpIHtcbiAgICAgIHJlc3VsdC5pbnN0YW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgVmlzdWFsUXVlcnlCaW5hcnkgfSBmcm9tICcuL3NoYXJlZC9Mb2tpQW5kUHJvbVF1ZXJ5TW9kZWxsZXJCYXNlJztcbmltcG9ydCB7IFF1ZXJ5QnVpbGRlckxhYmVsRmlsdGVyLCBRdWVyeUJ1aWxkZXJPcGVyYXRpb24gfSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5cbi8qKlxuICogVmlzdWFsIHF1ZXJ5IG1vZGVsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVZpc3VhbFF1ZXJ5IHtcbiAgbWV0cmljOiBzdHJpbmc7XG4gIGxhYmVsczogUXVlcnlCdWlsZGVyTGFiZWxGaWx0ZXJbXTtcbiAgb3BlcmF0aW9uczogUXVlcnlCdWlsZGVyT3BlcmF0aW9uW107XG4gIGJpbmFyeVF1ZXJpZXM/OiBQcm9tVmlzdWFsUXVlcnlCaW5hcnlbXTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvbVZpc3VhbFF1ZXJ5QmluYXJ5ID0gVmlzdWFsUXVlcnlCaW5hcnk8UHJvbVZpc3VhbFF1ZXJ5PjtcblxuZXhwb3J0IGVudW0gUHJvbVZpc3VhbFF1ZXJ5T3BlcmF0aW9uQ2F0ZWdvcnkge1xuICBBZ2dyZWdhdGlvbnMgPSAnQWdncmVnYXRpb25zJyxcbiAgUmFuZ2VGdW5jdGlvbnMgPSAnUmFuZ2UgZnVuY3Rpb25zJyxcbiAgRnVuY3Rpb25zID0gJ0Z1bmN0aW9ucycsXG4gIEJpbmFyeU9wcyA9ICdCaW5hcnkgb3BlcmF0aW9ucycsXG4gIFRyaWdvbm9tZXRyaWMgPSAnVHJpZ29ub21ldHJpYycsXG4gIFRpbWUgPSAnVGltZSBGdW5jdGlvbnMnLFxufVxuXG5leHBvcnQgZW51bSBQcm9tT3BlcmF0aW9uSWQge1xuICBBYnMgPSAnYWJzJyxcbiAgQWJzZW50ID0gJ2Fic2VudCcsXG4gIEFic2VudE92ZXJUaW1lID0gJ2Fic2VudF9vdmVyX3RpbWUnLFxuICBBY29zID0gJ2Fjb3MnLFxuICBBY29zaCA9ICdhY29zaCcsXG4gIEFzaW4gPSAnYXNpbicsXG4gIEFzaW5oID0gJ2FzaW5oJyxcbiAgQXRhbiA9ICdhdGFuJyxcbiAgQXRhbmggPSAnYXRhbmgnLFxuICBBdmcgPSAnYXZnJyxcbiAgQXZnT3ZlclRpbWUgPSAnYXZnX292ZXJfdGltZScsXG4gIEJvdHRvbUsgPSAnYm90dG9taycsXG4gIENlaWwgPSAnY2VpbCcsXG4gIENoYW5nZXMgPSAnY2hhbmdlcycsXG4gIENsYW1wID0gJ2NsYW1wJyxcbiAgQ2xhbXBNYXggPSAnY2xhbXBfbWF4JyxcbiAgQ2xhbXBNaW4gPSAnY2xhbXBfbWluJyxcbiAgQ29zID0gJ2NvcycsXG4gIENvc2ggPSAnY29zaCcsXG4gIENvdW50ID0gJ2NvdW50JyxcbiAgQ291bnRPdmVyVGltZSA9ICdjb3VudF9vdmVyX3RpbWUnLFxuICBDb3VudFNjYWxhciA9ICdjb3VudF9zY2FsYXInLFxuICBDb3VudFZhbHVlcyA9ICdjb3VudF92YWx1ZXMnLFxuICBEYXlPZk1vbnRoID0gJ2RheV9vZl9tb250aCcsXG4gIERheU9mV2VlayA9ICdkYXlfb2Zfd2VlaycsXG4gIERheXNJbk1vbnRoID0gJ2RheXNfaW5fbW9udGgnLFxuICBEZWcgPSAnZGVnJyxcbiAgRGVsdGEgPSAnZGVsdGEnLFxuICBEZXJpdiA9ICdkZXJpdicsXG4gIERyb3BDb21tb25MYWJlbHMgPSAnZHJvcF9jb21tb25fbGFiZWxzJyxcbiAgRXhwID0gJ2V4cCcsXG4gIEZsb29yID0gJ2Zsb29yJyxcbiAgR3JvdXAgPSAnZ3JvdXAnLFxuICBIaXN0b2dyYW1RdWFudGlsZSA9ICdoaXN0b2dyYW1fcXVhbnRpbGUnLFxuICBIb2x0V2ludGVycyA9ICdob2x0X3dpbnRlcnMnLFxuICBIb3VyID0gJ2hvdXInLFxuICBJZGVsdGEgPSAnaWRlbHRhJyxcbiAgSW5jcmVhc2UgPSAnaW5jcmVhc2UnLFxuICBJcmF0ZSA9ICdpcmF0ZScsXG4gIExhYmVsSm9pbiA9ICdsYWJlbF9qb2luJyxcbiAgTGFiZWxSZXBsYWNlID0gJ2xhYmVsX3JlcGxhY2UnLFxuICBMYXN0ID0gJ2xhc3QnLFxuICBMYXN0T3ZlclRpbWUgPSAnbGFzdF9vdmVyX3RpbWUnLFxuICBMbiA9ICdsbicsXG4gIExvZzEwID0gJ2xvZzEwJyxcbiAgTG9nMiA9ICdsb2cyJyxcbiAgTWF4ID0gJ21heCcsXG4gIE1heE92ZXJUaW1lID0gJ21heF9vdmVyX3RpbWUnLFxuICBNaW4gPSAnbWluJyxcbiAgTWluT3ZlclRpbWUgPSAnbWluX292ZXJfdGltZScsXG4gIE1pbnV0ZSA9ICdtaW51dGUnLFxuICBNb250aCA9ICdtb250aCcsXG4gIFBpID0gJ3BpJyxcbiAgUHJlZGljdExpbmVhciA9ICdwcmVkaWN0X2xpbmVhcicsXG4gIFByZXNlbnQgPSAncHJlc2VudCcsXG4gIFByZXNlbnRPdmVyVGltZSA9ICdwcmVzZW50X292ZXJfdGltZScsXG4gIFF1YW50aWxlID0gJ3F1YW50aWxlJyxcbiAgUXVhbnRpbGVPdmVyVGltZSA9ICdxdWFudGlsZV9vdmVyX3RpbWUnLFxuICBSYWQgPSAncmFkJyxcbiAgUmF0ZSA9ICdyYXRlJyxcbiAgUmVzZXRzID0gJ3Jlc2V0cycsXG4gIFJvdW5kID0gJ3JvdW5kJyxcbiAgU2NhbGFyID0gJ3NjYWxhcicsXG4gIFNnbiA9ICdzZ24nLFxuICBTaW4gPSAnc2luJyxcbiAgU2luaCA9ICdzaW5oJyxcbiAgU29ydCA9ICdzb3J0JyxcbiAgU29ydERlc2MgPSAnc29ydF9kZXNjJyxcbiAgU3FydCA9ICdzcXJ0JyxcbiAgU3RkZGV2ID0gJ3N0ZGRldicsXG4gIFN0ZGRldk92ZXJUaW1lID0gJ3N0ZGRldl9vdmVyX3RpbWUnLFxuICBTdW0gPSAnc3VtJyxcbiAgU3VtT3ZlclRpbWUgPSAnc3VtX292ZXJfdGltZScsXG4gIFRhbiA9ICd0YW4nLFxuICBUYW5oID0gJ3RhbmgnLFxuICBUaW1lID0gJ3RpbWUnLFxuICBUaW1lc3RhbXAgPSAndGltZXN0YW1wJyxcbiAgVG9wSyA9ICd0b3BrJyxcbiAgVmVjdG9yID0gJ3ZlY3RvcicsXG4gIFllYXIgPSAneWVhcicsXG4gIC8vIEJpbmFyeSBvcHNcbiAgQWRkaXRpb24gPSAnX19hZGRpdGlvbicsXG4gIFN1YnRyYWN0aW9uID0gJ19fc3VidHJhY3Rpb24nLFxuICBNdWx0aXBseUJ5ID0gJ19fbXVsdGlwbHlfYnknLFxuICBEaXZpZGVCeSA9ICdfX2RpdmlkZV9ieScsXG4gIE1vZHVsbyA9ICdfX21vZHVsbycsXG4gIEV4cG9uZW50ID0gJ19fZXhwb25lbnQnLFxuICBOZXN0ZWRRdWVyeSA9ICdfX25lc3RlZF9xdWVyeScsXG4gIEVxdWFsVG8gPSAnX19lcXVhbF90bycsXG4gIE5vdEVxdWFsVG8gPSAnX19ub3RfZXF1YWxfdG8nLFxuICBHcmVhdGVyVGhhbiA9ICdfX2dyZWF0ZXJfdGhhbicsXG4gIExlc3NUaGFuID0gJ19fbGVzc190aGFuJyxcbiAgR3JlYXRlck9yRXF1YWwgPSAnX19ncmVhdGVyX29yX2VxdWFsJyxcbiAgTGVzc09yRXF1YWwgPSAnX19sZXNzX29yX2VxdWFsJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tUXVlcnlQYXR0ZXJuIHtcbiAgbmFtZTogc3RyaW5nO1xuICBvcGVyYXRpb25zOiBRdWVyeUJ1aWxkZXJPcGVyYXRpb25bXTtcbn1cbiIsImltcG9ydCB7XG4gIEFycmF5RGF0YUZyYW1lLFxuICBBcnJheVZlY3RvcixcbiAgRGF0YUZyYW1lLFxuICBEYXRhTGluayxcbiAgRGF0YVRvcGljLFxuICBGaWVsZCxcbiAgRmllbGRUeXBlLFxuICBmb3JtYXRMYWJlbHMsXG4gIGdldERpc3BsYXlQcm9jZXNzb3IsXG4gIExhYmVscyxcbiAgTXV0YWJsZUZpZWxkLFxuICBTY29wZWRWYXJzLFxuICBUSU1FX1NFUklFU19USU1FX0ZJRUxEX05BTUUsXG4gIFRJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUUsXG4gIERhdGFRdWVyeVJlc3BvbnNlLFxuICBEYXRhUXVlcnlSZXF1ZXN0LFxuICBQcmVmZXJyZWRWaXN1YWxpc2F0aW9uVHlwZSxcbiAgQ29yZUFwcCxcbiAgRGF0YUZyYW1lVHlwZSxcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBGZXRjaFJlc3BvbnNlLCBnZXREYXRhU291cmNlU3J2LCBnZXRUZW1wbGF0ZVNydiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgcGFydGl0aW9uLCBncm91cEJ5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGRlc2NlbmRpbmcsIGRldmlhdGlvbiB9IGZyb20gJ2QzJztcbmltcG9ydCB7XG4gIEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uLFxuICBpc0V4ZW1wbGFyRGF0YSxcbiAgaXNNYXRyaXhEYXRhLFxuICBNYXRyaXhPclZlY3RvclJlc3VsdCxcbiAgUHJvbURhdGFTdWNjZXNzUmVzcG9uc2UsXG4gIFByb21NZXRyaWMsXG4gIFByb21RdWVyeSxcbiAgUHJvbVF1ZXJ5UmVxdWVzdCxcbiAgUHJvbVZhbHVlLFxuICBUcmFuc2Zvcm1PcHRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHJlbmRlckxlZ2VuZEZvcm1hdCB9IGZyb20gJy4vbGVnZW5kJztcblxuY29uc3QgUE9TSVRJVkVfSU5GSU5JVFlfU0FNUExFX1ZBTFVFID0gJytJbmYnO1xuY29uc3QgTkVHQVRJVkVfSU5GSU5JVFlfU0FNUExFX1ZBTFVFID0gJy1JbmYnO1xuXG5pbnRlcmZhY2UgVGltZUFuZFZhbHVlIHtcbiAgW1RJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRV06IG51bWJlcjtcbiAgW1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdOiBudW1iZXI7XG59XG5cbmNvbnN0IGlzVGFibGVSZXN1bHQgPSAoZGF0YUZyYW1lOiBEYXRhRnJhbWUsIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IGJvb2xlYW4gPT4ge1xuICAvLyBXZSB3YW50IHRvIHByb2Nlc3MgdmVjdG9yIGFuZCBzY2FsYXIgcmVzdWx0cyBpbiBFeHBsb3JlIGFzIHRhYmxlXG4gIGlmIChcbiAgICBvcHRpb25zLmFwcCA9PT0gQ29yZUFwcC5FeHBsb3JlICYmXG4gICAgKGRhdGFGcmFtZS5tZXRhPy5jdXN0b20/LnJlc3VsdFR5cGUgPT09ICd2ZWN0b3InIHx8IGRhdGFGcmFtZS5tZXRhPy5jdXN0b20/LnJlc3VsdFR5cGUgPT09ICdzY2FsYXInKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFdlIHdhbnQgdG8gcHJvY2VzcyBhbGwgZGF0YUZyYW1lcyB3aXRoIHRhcmdldC5mb3JtYXQgPT09ICd0YWJsZScgYXMgdGFibGVcbiAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXRzLmZpbmQoKHRhcmdldCkgPT4gdGFyZ2V0LnJlZklkID09PSBkYXRhRnJhbWUucmVmSWQpO1xuICByZXR1cm4gdGFyZ2V0Py5mb3JtYXQgPT09ICd0YWJsZSc7XG59O1xuXG5jb25zdCBpc0hlYXRtYXBSZXN1bHQgPSAoZGF0YUZyYW1lOiBEYXRhRnJhbWUsIG9wdGlvbnM6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldHMuZmluZCgodGFyZ2V0KSA9PiB0YXJnZXQucmVmSWQgPT09IGRhdGFGcmFtZS5yZWZJZCk7XG4gIHJldHVybiB0YXJnZXQ/LmZvcm1hdCA9PT0gJ2hlYXRtYXAnO1xufTtcblxuLy8gVjIgcmVzdWx0IHRyYXNuZm9ybWVyIHVzZWQgdG8gdHJhbnNmb3JtIHF1ZXJ5IHJlc3VsdHMgZnJvbSBxdWVyaWVzIHRoYXQgd2VyZSBydW4gdHJvdWdoIHByb21ldGhldXMgYmFja2VuZFxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVYyKFxuICByZXNwb25zZTogRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5PixcbiAgb3B0aW9uczogeyBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM/OiBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbltdIH1cbikge1xuICBjb25zdCBbdGFibGVGcmFtZXMsIGZyYW1lc1dpdGhvdXRUYWJsZV0gPSBwYXJ0aXRpb248RGF0YUZyYW1lPihyZXNwb25zZS5kYXRhLCAoZGYpID0+IGlzVGFibGVSZXN1bHQoZGYsIHJlcXVlc3QpKTtcbiAgY29uc3QgcHJvY2Vzc2VkVGFibGVGcmFtZXMgPSB0cmFuc2Zvcm1ERlRvVGFibGUodGFibGVGcmFtZXMpO1xuXG4gIGNvbnN0IFtleGVtcGxhckZyYW1lcywgZnJhbWVzV2l0aG91dFRhYmxlQW5kRXhlbXBsYXJzXSA9IHBhcnRpdGlvbjxEYXRhRnJhbWU+KFxuICAgIGZyYW1lc1dpdGhvdXRUYWJsZSxcbiAgICAoZGYpID0+IGRmLm1ldGE/LmN1c3RvbT8ucmVzdWx0VHlwZSA9PT0gJ2V4ZW1wbGFyJ1xuICApO1xuXG4gIC8vIEVYRU1QTEFSIEZSQU1FUzogV2UgZW5yaWNoIGV4ZW1wbGFyIGZyYW1lcyB3aXRoIGRhdGEgbGlua3MgYW5kIGFkZCBkYXRhVG9waWMgbWV0YSBpbmZvXG4gIGNvbnN0IHsgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zOiBkZXN0aW5hdGlvbnMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByb2Nlc3NlZEV4ZW1wbGFyRnJhbWVzID0gZXhlbXBsYXJGcmFtZXMubWFwKChkYXRhRnJhbWUpID0+IHtcbiAgICBpZiAoZGVzdGluYXRpb25zPy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24gb2YgZGVzdGluYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRyYWNlSURGaWVsZCA9IGRhdGFGcmFtZS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uLm5hbWUpO1xuICAgICAgICBpZiAodHJhY2VJREZpZWxkKSB7XG4gICAgICAgICAgY29uc3QgbGlua3MgPSBnZXREYXRhTGlua3MoZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb24pO1xuICAgICAgICAgIHRyYWNlSURGaWVsZC5jb25maWcubGlua3MgPSB0cmFjZUlERmllbGQuY29uZmlnLmxpbmtzPy5sZW5ndGhcbiAgICAgICAgICAgID8gWy4uLnRyYWNlSURGaWVsZC5jb25maWcubGlua3MsIC4uLmxpbmtzXVxuICAgICAgICAgICAgOiBsaW5rcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IC4uLmRhdGFGcmFtZSwgbWV0YTogeyAuLi5kYXRhRnJhbWUubWV0YSwgZGF0YVRvcGljOiBEYXRhVG9waWMuQW5ub3RhdGlvbnMgfSB9O1xuICB9KTtcblxuICBjb25zdCBbaGVhdG1hcFJlc3VsdHMsIGZyYW1lc1dpdGhvdXRUYWJsZUhlYXRtYXBzQW5kRXhlbXBsYXJzXSA9IHBhcnRpdGlvbjxEYXRhRnJhbWU+KFxuICAgIGZyYW1lc1dpdGhvdXRUYWJsZUFuZEV4ZW1wbGFycyxcbiAgICAoZGYpID0+IGlzSGVhdG1hcFJlc3VsdChkZiwgcmVxdWVzdClcbiAgKTtcblxuICBjb25zdCBwcm9jZXNzZWRIZWF0bWFwRnJhbWVzID0gbWVyZ2VIZWF0bWFwRnJhbWVzKFxuICAgIHRyYW5zZm9ybVRvSGlzdG9ncmFtT3ZlclRpbWUoaGVhdG1hcFJlc3VsdHMuc29ydChzb3J0U2VyaWVzQnlMYWJlbCkpXG4gICk7XG5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIHByb2Nlc3NlZCBhcyB0aW1lX3NlcmllcyByZXN1bHQgYW5kIGdyYXBoIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlXG4gIGNvbnN0IG90aGVyRnJhbWVzID0gZnJhbWVzV2l0aG91dFRhYmxlSGVhdG1hcHNBbmRFeGVtcGxhcnMubWFwKChkYXRhRnJhbWUpID0+IHtcbiAgICBjb25zdCBkZiA9IHtcbiAgICAgIC4uLmRhdGFGcmFtZSxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4uZGF0YUZyYW1lLm1ldGEsXG4gICAgICAgIHByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlOiAnZ3JhcGgnLFxuICAgICAgfSxcbiAgICB9IGFzIERhdGFGcmFtZTtcbiAgICByZXR1cm4gZGY7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzcG9uc2UsXG4gICAgZGF0YTogWy4uLm90aGVyRnJhbWVzLCAuLi5wcm9jZXNzZWRUYWJsZUZyYW1lcywgLi4ucHJvY2Vzc2VkSGVhdG1hcEZyYW1lcywgLi4ucHJvY2Vzc2VkRXhlbXBsYXJGcmFtZXNdLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtREZUb1RhYmxlKGRmczogRGF0YUZyYW1lW10pOiBEYXRhRnJhbWVbXSB7XG4gIC8vIElmIG5vIGRhdGFGcmFtZXMgb3IgaWYgMSBkYXRhRnJhbWVzIHdpdGggbm8gdmFsdWVzLCByZXR1cm4gb3JpZ2luYWwgZGF0YUZyYW1lXG4gIGlmIChkZnMubGVuZ3RoID09PSAwIHx8IChkZnMubGVuZ3RoID09PSAxICYmIGRmc1swXS5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuIGRmcztcbiAgfVxuXG4gIC8vIEdyb3VwIHJlc3VsdHMgYnkgcmVmSWQgYW5kIHByb2Nlc3MgZGF0YUZyYW1lcyB3aXRoIHRoZSBzYW1lIHJlZklkIGFzIDEgZGF0YUZyYW1lXG4gIGNvbnN0IGRhdGFGcmFtZXNCeVJlZklkID0gZ3JvdXBCeShkZnMsICdyZWZJZCcpO1xuICBjb25zdCByZWZJZHMgPSBPYmplY3Qua2V5cyhkYXRhRnJhbWVzQnlSZWZJZCk7XG5cbiAgY29uc3QgZnJhbWVzID0gcmVmSWRzLm1hcCgocmVmSWQpID0+IHtcbiAgICAvLyBDcmVhdGUgdGltZUZpZWxkLCB2YWx1ZUZpZWxkIGFuZCBsYWJlbEZpZWxkc1xuICAgIGNvbnN0IHZhbHVlVGV4dCA9IGdldFZhbHVlVGV4dChyZWZJZHMubGVuZ3RoLCByZWZJZCk7XG4gICAgY29uc3QgdmFsdWVGaWVsZCA9IGdldFZhbHVlRmllbGQoeyBkYXRhOiBbXSwgdmFsdWVOYW1lOiB2YWx1ZVRleHQgfSk7XG4gICAgY29uc3QgdGltZUZpZWxkID0gZ2V0VGltZUZpZWxkKFtdKTtcbiAgICBjb25zdCBsYWJlbEZpZWxkczogTXV0YWJsZUZpZWxkW10gPSBbXTtcblxuICAgIC8vIEZpbGwgbGFiZWxzRmllbGRzIHdpdGggbGFiZWxzIGZyb20gZGF0YUZyYW1lc1xuICAgIGRhdGFGcmFtZXNCeVJlZklkW3JlZklkXS5mb3JFYWNoKChkZikgPT4ge1xuICAgICAgY29uc3QgZnJhbWVWYWx1ZUZpZWxkID0gZGYuZmllbGRzWzFdO1xuICAgICAgY29uc3QgcHJvbUxhYmVscyA9IGZyYW1lVmFsdWVGaWVsZC5sYWJlbHMgPz8ge307XG5cbiAgICAgIE9iamVjdC5rZXlzKHByb21MYWJlbHMpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBsYWJlbCBpbiBsYWJlbEZpZWxkcywgYWRkIGl0XG4gICAgICAgICAgaWYgKCFsYWJlbEZpZWxkcy5zb21lKChsKSA9PiBsLm5hbWUgPT09IGxhYmVsKSkge1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyRmllbGQgPSBsYWJlbCA9PT0gJ2xlJztcbiAgICAgICAgICAgIGxhYmVsRmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICAgICAgY29uZmlnOiB7IGZpbHRlcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgICAgdHlwZTogbnVtYmVyRmllbGQgPyBGaWVsZFR5cGUubnVtYmVyIDogRmllbGRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBGaWxsIHZhbHVlRmllbGQsIHRpbWVGaWVsZCBhbmQgbGFiZWxGaWVsZHMgd2l0aCB2YWx1ZXNcbiAgICBkYXRhRnJhbWVzQnlSZWZJZFtyZWZJZF0uZm9yRWFjaCgoZGYpID0+IHtcbiAgICAgIGRmLmZpZWxkc1swXS52YWx1ZXMudG9BcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiB0aW1lRmllbGQudmFsdWVzLmFkZCh2YWx1ZSkpO1xuICAgICAgZGYuZmllbGRzWzFdLnZhbHVlcy50b0FycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgdmFsdWVGaWVsZC52YWx1ZXMuYWRkKHBhcnNlU2FtcGxlVmFsdWUodmFsdWUpKTtcbiAgICAgICAgY29uc3QgbGFiZWxzRm9yRmllbGQgPSBkZi5maWVsZHNbMV0ubGFiZWxzID8/IHt9O1xuICAgICAgICBsYWJlbEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4gZmllbGQudmFsdWVzLmFkZChnZXRMYWJlbFZhbHVlKGxhYmVsc0ZvckZpZWxkLCBmaWVsZC5uYW1lKSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaWVsZHMgPSBbdGltZUZpZWxkLCAuLi5sYWJlbEZpZWxkcywgdmFsdWVGaWVsZF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkLFxuICAgICAgZmllbGRzLFxuICAgICAgbWV0YTogeyAuLi5kZnNbMF0ubWV0YSwgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6ICd0YWJsZScgYXMgUHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGUgfSxcbiAgICAgIGxlbmd0aDogdGltZUZpZWxkLnZhbHVlcy5sZW5ndGgsXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBmcmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlVGV4dChyZXNwb25zZUxlbmd0aDogbnVtYmVyLCByZWZJZCA9ICcnKSB7XG4gIHJldHVybiByZXNwb25zZUxlbmd0aCA+IDEgPyBgVmFsdWUgIyR7cmVmSWR9YCA6ICdWYWx1ZSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oXG4gIHJlc3BvbnNlOiBGZXRjaFJlc3BvbnNlPFByb21EYXRhU3VjY2Vzc1Jlc3BvbnNlPixcbiAgdHJhbnNmb3JtT3B0aW9uczoge1xuICAgIHF1ZXJ5OiBQcm9tUXVlcnlSZXF1ZXN0O1xuICAgIGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucz86IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uW107XG4gICAgdGFyZ2V0OiBQcm9tUXVlcnk7XG4gICAgcmVzcG9uc2VMaXN0TGVuZ3RoOiBudW1iZXI7XG4gICAgc2NvcGVkVmFycz86IFNjb3BlZFZhcnM7XG4gIH1cbikge1xuICAvLyBDcmVhdGUgb3B0aW9ucyBvYmplY3QgZnJvbSB0cmFuc2Zvcm1PcHRpb25zXG4gIGNvbnN0IG9wdGlvbnM6IFRyYW5zZm9ybU9wdGlvbnMgPSB7XG4gICAgZm9ybWF0OiB0cmFuc2Zvcm1PcHRpb25zLnRhcmdldC5mb3JtYXQsXG4gICAgc3RlcDogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5zdGVwLFxuICAgIGxlZ2VuZEZvcm1hdDogdHJhbnNmb3JtT3B0aW9ucy50YXJnZXQubGVnZW5kRm9ybWF0LFxuICAgIHN0YXJ0OiB0cmFuc2Zvcm1PcHRpb25zLnF1ZXJ5LnN0YXJ0LFxuICAgIGVuZDogdHJhbnNmb3JtT3B0aW9ucy5xdWVyeS5lbmQsXG4gICAgcXVlcnk6IHRyYW5zZm9ybU9wdGlvbnMucXVlcnkuZXhwcixcbiAgICByZXNwb25zZUxpc3RMZW5ndGg6IHRyYW5zZm9ybU9wdGlvbnMucmVzcG9uc2VMaXN0TGVuZ3RoLFxuICAgIHNjb3BlZFZhcnM6IHRyYW5zZm9ybU9wdGlvbnMuc2NvcGVkVmFycyxcbiAgICByZWZJZDogdHJhbnNmb3JtT3B0aW9ucy50YXJnZXQucmVmSWQsXG4gICAgdmFsdWVXaXRoUmVmSWQ6IHRyYW5zZm9ybU9wdGlvbnMudGFyZ2V0LnZhbHVlV2l0aFJlZklkLFxuICAgIG1ldGE6IHtcbiAgICAgIC8vIEZpeCBmb3Igc2hvd2luZyBvZiBQcm9tZXRoZXVzIHJlc3VsdHMgaW4gRXhwbG9yZSB0YWJsZVxuICAgICAgcHJlZmVycmVkVmlzdWFsaXNhdGlvblR5cGU6IHRyYW5zZm9ybU9wdGlvbnMucXVlcnkuaW5zdGFudCA/ICd0YWJsZScgOiAnZ3JhcGgnLFxuICAgIH0sXG4gIH07XG4gIGNvbnN0IHByb21ldGhldXNSZXN1bHQgPSByZXNwb25zZS5kYXRhLmRhdGE7XG5cbiAgaWYgKGlzRXhlbXBsYXJEYXRhKHByb21ldGhldXNSZXN1bHQpKSB7XG4gICAgY29uc3QgZXZlbnRzOiBUaW1lQW5kVmFsdWVbXSA9IFtdO1xuICAgIHByb21ldGhldXNSZXN1bHQuZm9yRWFjaCgoZXhlbXBsYXJEYXRhKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZXhlbXBsYXJEYXRhLmV4ZW1wbGFycy5tYXAoKGV4ZW1wbGFyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW1RJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRV06IGV4ZW1wbGFyLnRpbWVzdGFtcCAqIDEwMDAsXG4gICAgICAgICAgW1RJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUVdOiBleGVtcGxhci52YWx1ZSxcbiAgICAgICAgICAuLi5leGVtcGxhci5sYWJlbHMsXG4gICAgICAgICAgLi4uZXhlbXBsYXJEYXRhLnNlcmllc0xhYmVscyxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgZXZlbnRzLnB1c2goLi4uZGF0YSk7XG4gICAgfSk7XG5cbiAgICAvLyBHcm91cGluZyBleGVtcGxhcnMgYnkgc3RlcFxuICAgIGNvbnN0IHNhbXBsZWRFeGVtcGxhcnMgPSBzYW1wbGVFeGVtcGxhcnMoZXZlbnRzLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGRhdGFGcmFtZSA9IG5ldyBBcnJheURhdGFGcmFtZShzYW1wbGVkRXhlbXBsYXJzKTtcbiAgICBkYXRhRnJhbWUubWV0YSA9IHsgZGF0YVRvcGljOiBEYXRhVG9waWMuQW5ub3RhdGlvbnMgfTtcblxuICAgIC8vIEFkZCBkYXRhIGxpbmtzIGlmIGNvbmZpZ3VyZWRcbiAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5leGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiBvZiB0cmFuc2Zvcm1PcHRpb25zLmV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9ucykge1xuICAgICAgICBjb25zdCB0cmFjZUlERmllbGQgPSBkYXRhRnJhbWUuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lID09PSBleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbi5uYW1lKTtcbiAgICAgICAgaWYgKHRyYWNlSURGaWVsZCkge1xuICAgICAgICAgIGNvbnN0IGxpbmtzID0gZ2V0RGF0YUxpbmtzKGV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uKTtcbiAgICAgICAgICB0cmFjZUlERmllbGQuY29uZmlnLmxpbmtzID0gdHJhY2VJREZpZWxkLmNvbmZpZy5saW5rcz8ubGVuZ3RoXG4gICAgICAgICAgICA/IFsuLi50cmFjZUlERmllbGQuY29uZmlnLmxpbmtzLCAuLi5saW5rc11cbiAgICAgICAgICAgIDogbGlua3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtkYXRhRnJhbWVdO1xuICB9XG5cbiAgaWYgKCFwcm9tZXRoZXVzUmVzdWx0Py5yZXN1bHQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBSZXR1cm4gZWFybHkgaWYgcmVzdWx0IHR5cGUgaXMgc2NhbGFyXG4gIGlmIChwcm9tZXRoZXVzUmVzdWx0LnJlc3VsdFR5cGUgPT09ICdzY2FsYXInKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbWV0YTogb3B0aW9ucy5tZXRhLFxuICAgICAgICByZWZJZDogb3B0aW9ucy5yZWZJZCxcbiAgICAgICAgbGVuZ3RoOiAxLFxuICAgICAgICBmaWVsZHM6IFtnZXRUaW1lRmllbGQoW3Byb21ldGhldXNSZXN1bHQucmVzdWx0XSksIGdldFZhbHVlRmllbGQoeyBkYXRhOiBbcHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHRdIH0pXSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIC8vIFJldHVybiBlYXJseSBhZ2FpbiBpZiB0aGUgZm9ybWF0IGlzIHRhYmxlLCB0aGlzIG5lZWRzIHNwZWNpYWwgdHJhbnNmb3JtYXRpb24uXG4gIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ3RhYmxlJykge1xuICAgIGNvbnN0IHRhYmxlRGF0YSA9IHRyYW5zZm9ybU1ldHJpY0RhdGFUb1RhYmxlKHByb21ldGhldXNSZXN1bHQucmVzdWx0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gW3RhYmxlRGF0YV07XG4gIH1cblxuICAvLyBQcm9jZXNzIG1hdHJpeCBhbmQgdmVjdG9yIHJlc3VsdHMgdG8gRGF0YUZyYW1lXG4gIGNvbnN0IGRhdGFGcmFtZTogRGF0YUZyYW1lW10gPSBbXTtcbiAgcHJvbWV0aGV1c1Jlc3VsdC5yZXN1bHQuZm9yRWFjaCgoZGF0YTogTWF0cml4T3JWZWN0b3JSZXN1bHQpID0+IGRhdGFGcmFtZS5wdXNoKHRyYW5zZm9ybVRvRGF0YUZyYW1lKGRhdGEsIG9wdGlvbnMpKSk7XG5cbiAgLy8gV2hlbiBmb3JtYXQgaXMgaGVhdG1hcCB1c2UgdGhlIGFscmVhZHkgY3JlYXRlZCBkYXRhIGZyYW1lcyBhbmQgdHJhbnNmb3JtIGl0IG1vcmVcbiAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnaGVhdG1hcCcpIHtcbiAgICByZXR1cm4gbWVyZ2VIZWF0bWFwRnJhbWVzKHRyYW5zZm9ybVRvSGlzdG9ncmFtT3ZlclRpbWUoZGF0YUZyYW1lLnNvcnQoc29ydFNlcmllc0J5TGFiZWwpKSk7XG4gIH1cblxuICAvLyBSZXR1cm4gbWF0cml4IG9yIHZlY3RvciByZXN1bHQgYXMgRGF0YUZyYW1lW11cbiAgcmV0dXJuIGRhdGFGcmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YUxpbmtzKG9wdGlvbnM6IEV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uKTogRGF0YUxpbmtbXSB7XG4gIGNvbnN0IGRhdGFMaW5rczogRGF0YUxpbmtbXSA9IFtdO1xuXG4gIGlmIChvcHRpb25zLmRhdGFzb3VyY2VVaWQpIHtcbiAgICBjb25zdCBkYXRhU291cmNlU3J2ID0gZ2V0RGF0YVNvdXJjZVNydigpO1xuICAgIGNvbnN0IGRzU2V0dGluZ3MgPSBkYXRhU291cmNlU3J2LmdldEluc3RhbmNlU2V0dGluZ3Mob3B0aW9ucy5kYXRhc291cmNlVWlkKTtcblxuICAgIGRhdGFMaW5rcy5wdXNoKHtcbiAgICAgIHRpdGxlOiBvcHRpb25zLnVybERpc3BsYXlMYWJlbCB8fCBgUXVlcnkgd2l0aCAke2RzU2V0dGluZ3M/Lm5hbWV9YCxcbiAgICAgIHVybDogJycsXG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICBxdWVyeTogeyBxdWVyeTogJyR7X192YWx1ZS5yYXd9JywgcXVlcnlUeXBlOiAndHJhY2VJZCcgfSxcbiAgICAgICAgZGF0YXNvdXJjZVVpZDogb3B0aW9ucy5kYXRhc291cmNlVWlkLFxuICAgICAgICBkYXRhc291cmNlTmFtZTogZHNTZXR0aW5ncz8ubmFtZSA/PyAnRGF0YSBzb3VyY2Ugbm90IGZvdW5kJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy51cmwpIHtcbiAgICBkYXRhTGlua3MucHVzaCh7XG4gICAgICB0aXRsZTogb3B0aW9ucy51cmxEaXNwbGF5TGFiZWwgfHwgYEdvIHRvICR7b3B0aW9ucy51cmx9YCxcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICB0YXJnZXRCbGFuazogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGF0YUxpbmtzO1xufVxuXG4vKipcbiAqIFJlZHVjZSB0aGUgZGVuc2l0eSBvZiB0aGUgZXhlbXBsYXJzIGJ5IG1ha2luZyBzdXJlIHRoYXQgdGhlIGhpZ2hlc3QgdmFsdWUgZXhlbXBsYXIgaXMgaW5jbHVkZWRcbiAqIGFuZCB0aGVuIG9ubHkgdGhlIG9uZXMgdGhhdCBhcmUgMiB0aW1lcyB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBhbGwgdGhlIHZhbHVlcy5cbiAqIFRoaXMgbWFrZXMgc3VyZSBub3QgdG8gc2hvdyB0b28gbWFueSBkb3RzIG5lYXIgZWFjaCBvdGhlci5cbiAqL1xuZnVuY3Rpb24gc2FtcGxlRXhlbXBsYXJzKGV2ZW50czogVGltZUFuZFZhbHVlW10sIG9wdGlvbnM6IFRyYW5zZm9ybU9wdGlvbnMpIHtcbiAgY29uc3Qgc3RlcCA9IG9wdGlvbnMuc3RlcCB8fCAxNTtcbiAgY29uc3QgYnVja2V0ZWRFeGVtcGxhcnM6IHsgW3RzOiBzdHJpbmddOiBUaW1lQW5kVmFsdWVbXSB9ID0ge307XG4gIGNvbnN0IHZhbHVlczogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChjb25zdCBleGVtcGxhciBvZiBldmVudHMpIHtcbiAgICAvLyBBbGlnbiBleGVtcGxhciB0aW1lc3RhbXAgdG8gbmVhcmVzdCBzdGVwIHNlY29uZFxuICAgIGNvbnN0IGFsaWduZWRUcyA9IFN0cmluZyhNYXRoLmZsb29yKGV4ZW1wbGFyW1RJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRV0gLyAxMDAwIC8gc3RlcCkgKiBzdGVwICogMTAwMCk7XG4gICAgaWYgKCFidWNrZXRlZEV4ZW1wbGFyc1thbGlnbmVkVHNdKSB7XG4gICAgICAvLyBOZXcgYnVja2V0IGZvdW5kXG4gICAgICBidWNrZXRlZEV4ZW1wbGFyc1thbGlnbmVkVHNdID0gW107XG4gICAgfVxuICAgIGJ1Y2tldGVkRXhlbXBsYXJzW2FsaWduZWRUc10ucHVzaChleGVtcGxhcik7XG4gICAgdmFsdWVzLnB1c2goZXhlbXBsYXJbVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRV0pO1xuICB9XG5cbiAgLy8gR2V0dGluZyBleGVtcGxhcnMgZnJvbSBlYWNoIGJ1Y2tldFxuICBjb25zdCBzdGFuZGFyZERldmlhdGlvbiA9IGRldmlhdGlvbih2YWx1ZXMpO1xuICBjb25zdCBzYW1wbGVkQnVja2V0cyA9IE9iamVjdC5rZXlzKGJ1Y2tldGVkRXhlbXBsYXJzKS5zb3J0KCk7XG4gIGNvbnN0IHNhbXBsZWRFeGVtcGxhcnMgPSBbXTtcbiAgZm9yIChjb25zdCB0cyBvZiBzYW1wbGVkQnVja2V0cykge1xuICAgIGNvbnN0IGV4ZW1wbGFyc0luQnVja2V0ID0gYnVja2V0ZWRFeGVtcGxhcnNbdHNdO1xuICAgIGlmIChleGVtcGxhcnNJbkJ1Y2tldC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNhbXBsZWRFeGVtcGxhcnMucHVzaChleGVtcGxhcnNJbkJ1Y2tldFswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENob29zZSB3aGljaCB2YWx1ZXMgdG8gc2FtcGxlXG4gICAgICBjb25zdCBidWNrZXRWYWx1ZXMgPSBleGVtcGxhcnNJbkJ1Y2tldC5tYXAoKGV4KSA9PiBleFtUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FXSkuc29ydChkZXNjZW5kaW5nKTtcbiAgICAgIGNvbnN0IHNhbXBsZWRCdWNrZXRWYWx1ZXMgPSBidWNrZXRWYWx1ZXMucmVkdWNlKChhY2M6IG51bWJlcltdLCBjdXJyKSA9PiB7XG4gICAgICAgIGlmIChhY2MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gRmlyc3QgdmFsdWUgaXMgbWF4IGFuZCBpcyBhbHdheXMgYWRkZWRcbiAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVuIHRha2UgdmFsdWVzIG9ubHkgd2hlbiBhdCBsZWFzdCAyIHN0YW5kYXJkIGRldmlhdGlvbiBkaXN0YW5jZSB0byBwcmV2aW91c2x5IHRha2VuIHZhbHVlXG4gICAgICAgICAgY29uc3QgcHJldiA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKHN0YW5kYXJkRGV2aWF0aW9uICYmIHByZXYgLSBjdXJyID49IDIgKiBzdGFuZGFyZERldmlhdGlvbikge1xuICAgICAgICAgICAgYWNjLnB1c2goY3Vycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBbXSk7XG4gICAgICAvLyBGaW5kIHRoZSBleGVtcGxhcnMgZm9yIHRoZSBzYW1wbGVkIHZhbHVlc1xuICAgICAgc2FtcGxlZEV4ZW1wbGFycy5wdXNoKFxuICAgICAgICAuLi5zYW1wbGVkQnVja2V0VmFsdWVzLm1hcChcbiAgICAgICAgICAodmFsdWUpID0+IGV4ZW1wbGFyc0luQnVja2V0LmZpbmQoKGV4KSA9PiBleFtUSU1FX1NFUklFU19WQUxVRV9GSUVMRF9OQU1FXSA9PT0gdmFsdWUpIVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2FtcGxlZEV4ZW1wbGFycztcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIG1hdHJpeCBhbmQgdmVjdG9yIHJlc3VsdCBmcm9tIFByb21ldGhldXMgcmVzdWx0IHRvIERhdGFGcmFtZVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ub0RhdGFGcmFtZShkYXRhOiBNYXRyaXhPclZlY3RvclJlc3VsdCwgb3B0aW9uczogVHJhbnNmb3JtT3B0aW9ucyk6IERhdGFGcmFtZSB7XG4gIGNvbnN0IHsgbmFtZSwgbGFiZWxzIH0gPSBjcmVhdGVMYWJlbEluZm8oZGF0YS5tZXRyaWMsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IGZpZWxkczogRmllbGRbXSA9IFtdO1xuXG4gIGlmIChpc01hdHJpeERhdGEoZGF0YSkpIHtcbiAgICBjb25zdCBzdGVwTXMgPSBvcHRpb25zLnN0ZXAgPyBvcHRpb25zLnN0ZXAgKiAxMDAwIDogTmFOO1xuICAgIGxldCBiYXNlVGltZXN0YW1wID0gb3B0aW9ucy5zdGFydCAqIDEwMDA7XG4gICAgY29uc3QgZHBzOiBQcm9tVmFsdWVbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkYXRhLnZhbHVlcykge1xuICAgICAgbGV0IGRwVmFsdWU6IG51bWJlciB8IG51bGwgPSBwYXJzZVNhbXBsZVZhbHVlKHZhbHVlWzFdKTtcblxuICAgICAgaWYgKGlzTmFOKGRwVmFsdWUpKSB7XG4gICAgICAgIGRwVmFsdWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSB2YWx1ZVswXSAqIDEwMDA7XG4gICAgICBmb3IgKGxldCB0ID0gYmFzZVRpbWVzdGFtcDsgdCA8IHRpbWVzdGFtcDsgdCArPSBzdGVwTXMpIHtcbiAgICAgICAgZHBzLnB1c2goW3QsIG51bGxdKTtcbiAgICAgIH1cbiAgICAgIGJhc2VUaW1lc3RhbXAgPSB0aW1lc3RhbXAgKyBzdGVwTXM7XG4gICAgICBkcHMucHVzaChbdGltZXN0YW1wLCBkcFZhbHVlXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kVGltZXN0YW1wID0gb3B0aW9ucy5lbmQgKiAxMDAwO1xuICAgIGZvciAobGV0IHQgPSBiYXNlVGltZXN0YW1wOyB0IDw9IGVuZFRpbWVzdGFtcDsgdCArPSBzdGVwTXMpIHtcbiAgICAgIGRwcy5wdXNoKFt0LCBudWxsXSk7XG4gICAgfVxuICAgIGZpZWxkcy5wdXNoKGdldFRpbWVGaWVsZChkcHMsIHRydWUpKTtcbiAgICBmaWVsZHMucHVzaChnZXRWYWx1ZUZpZWxkKHsgZGF0YTogZHBzLCBwYXJzZVZhbHVlOiBmYWxzZSwgbGFiZWxzLCBkaXNwbGF5TmFtZUZyb21EUzogbmFtZSB9KSk7XG4gIH0gZWxzZSB7XG4gICAgZmllbGRzLnB1c2goZ2V0VGltZUZpZWxkKFtkYXRhLnZhbHVlXSkpO1xuICAgIGZpZWxkcy5wdXNoKGdldFZhbHVlRmllbGQoeyBkYXRhOiBbZGF0YS52YWx1ZV0sIGxhYmVscywgZGlzcGxheU5hbWVGcm9tRFM6IG5hbWUgfSkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRhOiBvcHRpb25zLm1ldGEsXG4gICAgcmVmSWQ6IG9wdGlvbnMucmVmSWQsXG4gICAgbGVuZ3RoOiBmaWVsZHNbMF0udmFsdWVzLmxlbmd0aCxcbiAgICBmaWVsZHMsXG4gICAgbmFtZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWV0cmljRGF0YVRvVGFibGUobWQ6IE1hdHJpeE9yVmVjdG9yUmVzdWx0W10sIG9wdGlvbnM6IFRyYW5zZm9ybU9wdGlvbnMpOiBEYXRhRnJhbWUge1xuICBpZiAoIW1kIHx8IG1kLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRhOiBvcHRpb25zLm1ldGEsXG4gICAgICByZWZJZDogb3B0aW9ucy5yZWZJZCxcbiAgICAgIGxlbmd0aDogMCxcbiAgICAgIGZpZWxkczogW10sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlVGV4dCA9IG9wdGlvbnMucmVzcG9uc2VMaXN0TGVuZ3RoID4gMSB8fCBvcHRpb25zLnZhbHVlV2l0aFJlZklkID8gYFZhbHVlICMke29wdGlvbnMucmVmSWR9YCA6ICdWYWx1ZSc7XG5cbiAgY29uc3QgdGltZUZpZWxkID0gZ2V0VGltZUZpZWxkKFtdKTtcbiAgY29uc3QgbWV0cmljRmllbGRzID0gT2JqZWN0LmtleXMobWQucmVkdWNlKChhY2MsIHNlcmllcykgPT4gKHsgLi4uYWNjLCAuLi5zZXJpZXMubWV0cmljIH0pLCB7fSkpXG4gICAgLnNvcnQoKVxuICAgIC5tYXAoKGxhYmVsKSA9PiB7XG4gICAgICAvLyBMYWJlbHMgaGF2ZSBzdHJpbmcgZmllbGQgdHlwZSwgb3RoZXJ3aXNlIHRhYmxlIHRyaWVzIHRvIGZpZ3VyZSBvdXQgdGhlIHR5cGUgd2hpY2ggY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIHJlc3VsdHNcbiAgICAgIC8vIE9ubHkgXCJsZVwiIGxhYmVsIGhhcyBhIG51bWJlciBmaWVsZCB0eXBlXG4gICAgICBjb25zdCBudW1iZXJGaWVsZCA9IGxhYmVsID09PSAnbGUnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbGFiZWwsXG4gICAgICAgIGNvbmZpZzogeyBmaWx0ZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHR5cGU6IG51bWJlckZpZWxkID8gRmllbGRUeXBlLm51bWJlciA6IEZpZWxkVHlwZS5zdHJpbmcsXG4gICAgICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yKCksXG4gICAgICB9O1xuICAgIH0pO1xuICBjb25zdCB2YWx1ZUZpZWxkID0gZ2V0VmFsdWVGaWVsZCh7IGRhdGE6IFtdLCB2YWx1ZU5hbWU6IHZhbHVlVGV4dCB9KTtcblxuICBtZC5mb3JFYWNoKChkKSA9PiB7XG4gICAgaWYgKGlzTWF0cml4RGF0YShkKSkge1xuICAgICAgZC52YWx1ZXMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgIHRpbWVGaWVsZC52YWx1ZXMuYWRkKHZhbFswXSAqIDEwMDApO1xuICAgICAgICBtZXRyaWNGaWVsZHMuZm9yRWFjaCgobWV0cmljRmllbGQpID0+IG1ldHJpY0ZpZWxkLnZhbHVlcy5hZGQoZ2V0TGFiZWxWYWx1ZShkLm1ldHJpYywgbWV0cmljRmllbGQubmFtZSkpKTtcbiAgICAgICAgdmFsdWVGaWVsZC52YWx1ZXMuYWRkKHBhcnNlU2FtcGxlVmFsdWUodmFsWzFdKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZUZpZWxkLnZhbHVlcy5hZGQoZC52YWx1ZVswXSAqIDEwMDApO1xuICAgICAgbWV0cmljRmllbGRzLmZvckVhY2goKG1ldHJpY0ZpZWxkKSA9PiBtZXRyaWNGaWVsZC52YWx1ZXMuYWRkKGdldExhYmVsVmFsdWUoZC5tZXRyaWMsIG1ldHJpY0ZpZWxkLm5hbWUpKSk7XG4gICAgICB2YWx1ZUZpZWxkLnZhbHVlcy5hZGQocGFyc2VTYW1wbGVWYWx1ZShkLnZhbHVlWzFdKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG1ldGE6IG9wdGlvbnMubWV0YSxcbiAgICByZWZJZDogb3B0aW9ucy5yZWZJZCxcbiAgICBsZW5ndGg6IHRpbWVGaWVsZC52YWx1ZXMubGVuZ3RoLFxuICAgIGZpZWxkczogW3RpbWVGaWVsZCwgLi4ubWV0cmljRmllbGRzLCB2YWx1ZUZpZWxkXSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFiZWxWYWx1ZShtZXRyaWM6IFByb21NZXRyaWMsIGxhYmVsOiBzdHJpbmcpOiBzdHJpbmcgfCBudW1iZXIge1xuICBpZiAobWV0cmljLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgIGlmIChsYWJlbCA9PT0gJ2xlJykge1xuICAgICAgcmV0dXJuIHBhcnNlU2FtcGxlVmFsdWUobWV0cmljW2xhYmVsXSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRyaWNbbGFiZWxdO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0VGltZUZpZWxkKGRhdGE6IFByb21WYWx1ZVtdLCBpc01zID0gZmFsc2UpOiBNdXRhYmxlRmllbGQge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFRJTUVfU0VSSUVTX1RJTUVfRklFTERfTkFNRSxcbiAgICB0eXBlOiBGaWVsZFR5cGUudGltZSxcbiAgICBjb25maWc6IHt9LFxuICAgIHZhbHVlczogbmV3IEFycmF5VmVjdG9yPG51bWJlcj4oZGF0YS5tYXAoKHZhbCkgPT4gKGlzTXMgPyB2YWxbMF0gOiB2YWxbMF0gKiAxMDAwKSkpLFxuICB9O1xufVxudHlwZSBWYWx1ZUZpZWxkT3B0aW9ucyA9IHtcbiAgZGF0YTogUHJvbVZhbHVlW107XG4gIHZhbHVlTmFtZT86IHN0cmluZztcbiAgcGFyc2VWYWx1ZT86IGJvb2xlYW47XG4gIGxhYmVscz86IExhYmVscztcbiAgZGlzcGxheU5hbWVGcm9tRFM/OiBzdHJpbmc7XG59O1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUZpZWxkKHtcbiAgZGF0YSxcbiAgdmFsdWVOYW1lID0gVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSxcbiAgcGFyc2VWYWx1ZSA9IHRydWUsXG4gIGxhYmVscyxcbiAgZGlzcGxheU5hbWVGcm9tRFMsXG59OiBWYWx1ZUZpZWxkT3B0aW9ucyk6IE11dGFibGVGaWVsZCB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogdmFsdWVOYW1lLFxuICAgIHR5cGU6IEZpZWxkVHlwZS5udW1iZXIsXG4gICAgZGlzcGxheTogZ2V0RGlzcGxheVByb2Nlc3NvcigpLFxuICAgIGNvbmZpZzoge1xuICAgICAgZGlzcGxheU5hbWVGcm9tRFMsXG4gICAgfSxcbiAgICBsYWJlbHMsXG4gICAgdmFsdWVzOiBuZXcgQXJyYXlWZWN0b3I8bnVtYmVyIHwgbnVsbD4oZGF0YS5tYXAoKHZhbCkgPT4gKHBhcnNlVmFsdWUgPyBwYXJzZVNhbXBsZVZhbHVlKHZhbFsxXSkgOiB2YWxbMV0pKSksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxhYmVsSW5mbyhsYWJlbHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sIG9wdGlvbnM6IFRyYW5zZm9ybU9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnM/LmxlZ2VuZEZvcm1hdCkge1xuICAgIGNvbnN0IHRpdGxlID0gcmVuZGVyTGVnZW5kRm9ybWF0KGdldFRlbXBsYXRlU3J2KCkucmVwbGFjZShvcHRpb25zLmxlZ2VuZEZvcm1hdCwgb3B0aW9ucz8uc2NvcGVkVmFycyksIGxhYmVscyk7XG4gICAgcmV0dXJuIHsgbmFtZTogdGl0bGUsIGxhYmVscyB9O1xuICB9XG5cbiAgY29uc3QgeyBfX25hbWVfXywgLi4ubGFiZWxzV2l0aG91dE5hbWUgfSA9IGxhYmVscztcbiAgY29uc3QgbGFiZWxQYXJ0ID0gZm9ybWF0TGFiZWxzKGxhYmVsc1dpdGhvdXROYW1lKTtcbiAgbGV0IHRpdGxlID0gYCR7X19uYW1lX18gPz8gJyd9JHtsYWJlbFBhcnR9YDtcblxuICBpZiAoIXRpdGxlKSB7XG4gICAgdGl0bGUgPSBvcHRpb25zLnF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHsgbmFtZTogdGl0bGUsIGxhYmVsczogbGFiZWxzV2l0aG91dE5hbWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9yaWdpbmFsTWV0cmljTmFtZShsYWJlbERhdGE6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0pIHtcbiAgY29uc3QgbWV0cmljTmFtZSA9IGxhYmVsRGF0YS5fX25hbWVfXyB8fCAnJztcbiAgZGVsZXRlIGxhYmVsRGF0YS5fX25hbWVfXztcbiAgY29uc3QgbGFiZWxQYXJ0ID0gT2JqZWN0LmVudHJpZXMobGFiZWxEYXRhKVxuICAgIC5tYXAoKGxhYmVsKSA9PiBgJHtsYWJlbFswXX09XCIke2xhYmVsWzFdfVwiYClcbiAgICAuam9pbignLCcpO1xuICByZXR1cm4gYCR7bWV0cmljTmFtZX17JHtsYWJlbFBhcnR9fWA7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSGVhdG1hcEZyYW1lcyhmcmFtZXM6IERhdGFGcmFtZVtdKTogRGF0YUZyYW1lW10ge1xuICBpZiAoZnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHRpbWVGaWVsZCA9IGZyYW1lc1swXS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLnR5cGUgPT09IEZpZWxkVHlwZS50aW1lKSE7XG4gIGNvbnN0IGNvdW50RmllbGRzID0gZnJhbWVzLm1hcCgoZnJhbWUpID0+IHtcbiAgICBsZXQgZmllbGQgPSBmcmFtZS5maWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLnR5cGUgPT09IEZpZWxkVHlwZS5udW1iZXIpITtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5maWVsZCxcbiAgICAgIG5hbWU6IGZpZWxkLmNvbmZpZy5kaXNwbGF5TmFtZUZyb21EUyEsXG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICAuLi5mcmFtZXNbMF0sXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLmZyYW1lc1swXS5tZXRhLFxuICAgICAgICB0eXBlOiBEYXRhRnJhbWVUeXBlLkhlYXRtYXBCdWNrZXRzLFxuICAgICAgfSxcbiAgICAgIGZpZWxkczogW3RpbWVGaWVsZCEsIC4uLmNvdW50RmllbGRzXSxcbiAgICB9LFxuICBdO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ub0hpc3RvZ3JhbU92ZXJUaW1lKHNlcmllc0xpc3Q6IERhdGFGcmFtZVtdKSB7XG4gIC8qICAgICAgdDEgPSB0aW1lc3RhbXAxLCB0MiA9IHRpbWVzdGFtcDIgZXRjLlxuICAgICAgICAgICAgdDEgIHQyICB0MyAgICAgICAgICB0MSAgdDIgIHQzXG4gICAgbGUxMCAgICAxMCAgMTAgIDAgICAgID0+ICAgIDEwICAxMCAgMFxuICAgIGxlMjAgICAgMjAgIDEwICAzMCAgICA9PiAgICAxMCAgMCAgIDMwXG4gICAgbGUzMCAgICAzMCAgMTAgIDM1ICAgID0+ICAgIDEwICAwICAgNVxuICAgICovXG4gIGZvciAobGV0IGkgPSBzZXJpZXNMaXN0Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICBjb25zdCB0b3BTZXJpZXMgPSBzZXJpZXNMaXN0W2ldLmZpZWxkcy5maW5kKChzKSA9PiBzLm5hbWUgPT09IFRJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUUpO1xuICAgIGNvbnN0IGJvdHRvbVNlcmllcyA9IHNlcmllc0xpc3RbaSAtIDFdLmZpZWxkcy5maW5kKChzKSA9PiBzLm5hbWUgPT09IFRJTUVfU0VSSUVTX1ZBTFVFX0ZJRUxEX05BTUUpO1xuICAgIGlmICghdG9wU2VyaWVzIHx8ICFib3R0b21TZXJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvbWV0aGV1cyBoZWF0bWFwIHRyYW5zZm9ybSBlcnJvcjogZGF0YSBzaG91bGQgYmUgYSB0aW1lIHNlcmllcycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9wU2VyaWVzLnZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgYm90dG9tUG9pbnQgPSBib3R0b21TZXJpZXMudmFsdWVzLmdldChqKSB8fCBbMF07XG4gICAgICB0b3BTZXJpZXMudmFsdWVzLnRvQXJyYXkoKVtqXSAtPSBib3R0b21Qb2ludDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VyaWVzTGlzdDtcbn1cblxuZnVuY3Rpb24gc29ydFNlcmllc0J5TGFiZWwoczE6IERhdGFGcmFtZSwgczI6IERhdGFGcmFtZSk6IG51bWJlciB7XG4gIGxldCBsZTEsIGxlMjtcblxuICB0cnkge1xuICAgIC8vIGZhaWwgaWYgbm90IGludGVnZXIuIG1pZ2h0IGhhcHBlbiB3aXRoIGJhZCBxdWVyaWVzXG4gICAgbGUxID0gcGFyc2VTYW1wbGVWYWx1ZShzMS5uYW1lID8/ICcnKTtcbiAgICBsZTIgPSBwYXJzZVNhbXBsZVZhbHVlKHMyLm5hbWUgPz8gJycpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAobGUxID4gbGUyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAobGUxIDwgbGUyKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2FtcGxlVmFsdWUodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFBPU0lUSVZFX0lORklOSVRZX1NBTVBMRV9WQUxVRTpcbiAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY2FzZSBORUdBVElWRV9JTkZJTklUWV9TQU1QTEVfVkFMVUU6XG4gICAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGFRdWVyeSwgRGF0YVNvdXJjZUpzb25EYXRhLCBRdWVyeVJlc3VsdE1ldGEsIFNjb3BlZFZhcnMgfSBmcm9tICdAZ3JhZmFuYS9kYXRhJztcbmltcG9ydCB7IFF1ZXJ5RWRpdG9yTW9kZSB9IGZyb20gJy4vcXVlcnlidWlsZGVyL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVF1ZXJ5IGV4dGVuZHMgRGF0YVF1ZXJ5IHtcbiAgZXhwcjogc3RyaW5nO1xuICBmb3JtYXQ/OiBzdHJpbmc7XG4gIGluc3RhbnQ/OiBib29sZWFuO1xuICByYW5nZT86IGJvb2xlYW47XG4gIGV4ZW1wbGFyPzogYm9vbGVhbjtcbiAgaGludGluZz86IGJvb2xlYW47XG4gIGludGVydmFsPzogc3RyaW5nO1xuICBpbnRlcnZhbEZhY3Rvcj86IG51bWJlcjtcbiAgLy8gVGltZXpvbmUgb2Zmc2V0IHRvIGFsaWduIHN0YXJ0ICYgZW5kIHRpbWUgb24gYmFja2VuZFxuICB1dGNPZmZzZXRTZWM/OiBudW1iZXI7XG4gIGxlZ2VuZEZvcm1hdD86IHN0cmluZztcbiAgdmFsdWVXaXRoUmVmSWQ/OiBib29sZWFuO1xuICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG4gIHNob3dpbmdHcmFwaD86IGJvb2xlYW47XG4gIHNob3dpbmdUYWJsZT86IGJvb2xlYW47XG4gIC8qKiBDb2RlLCBCdWlsZGVyIG9yIEV4cGxhaW4gKi9cbiAgZWRpdG9yTW9kZT86IFF1ZXJ5RWRpdG9yTW9kZTtcbiAgLyoqIENvbnRyb2xzIGlmIHRoZSByYXcgcXVlcnkgdGV4dCBpcyBzaG93biAqL1xuICByYXdRdWVyeT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbU9wdGlvbnMgZXh0ZW5kcyBEYXRhU291cmNlSnNvbkRhdGEge1xuICB0aW1lSW50ZXJ2YWw/OiBzdHJpbmc7XG4gIHF1ZXJ5VGltZW91dD86IHN0cmluZztcbiAgaHR0cE1ldGhvZD86IHN0cmluZztcbiAgZGlyZWN0VXJsPzogc3RyaW5nO1xuICBjdXN0b21RdWVyeVBhcmFtZXRlcnM/OiBzdHJpbmc7XG4gIGRpc2FibGVNZXRyaWNzTG9va3VwPzogYm9vbGVhbjtcbiAgZXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25zPzogRXhlbXBsYXJUcmFjZUlkRGVzdGluYXRpb25bXTtcbn1cblxuZXhwb3J0IGVudW0gUHJvbVF1ZXJ5VHlwZSB7XG4gIHRpbWVTZXJpZXNRdWVyeSA9ICd0aW1lU2VyaWVzUXVlcnknLFxufVxuXG5leHBvcnQgdHlwZSBFeGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbiA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIHVybERpc3BsYXlMYWJlbD86IHN0cmluZztcbiAgZGF0YXNvdXJjZVVpZD86IHN0cmluZztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVF1ZXJ5UmVxdWVzdCBleHRlbmRzIFByb21RdWVyeSB7XG4gIHN0ZXA/OiBudW1iZXI7XG4gIHJlcXVlc3RJZD86IHN0cmluZztcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG4gIGhlYWRlcnM/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbU1ldHJpY3NNZXRhZGF0YUl0ZW0ge1xuICB0eXBlOiBzdHJpbmc7XG4gIGhlbHA6IHN0cmluZztcbiAgdW5pdD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTWV0cmljc01ldGFkYXRhIHtcbiAgW21ldHJpYzogc3RyaW5nXTogUHJvbU1ldHJpY3NNZXRhZGF0YUl0ZW07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbURhdGFTdWNjZXNzUmVzcG9uc2U8VCA9IFByb21EYXRhPiB7XG4gIHN0YXR1czogJ3N1Y2Nlc3MnO1xuICBkYXRhOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21EYXRhRXJyb3JSZXNwb25zZTxUID0gUHJvbURhdGE+IHtcbiAgc3RhdHVzOiAnZXJyb3InO1xuICBlcnJvclR5cGU6IHN0cmluZztcbiAgZXJyb3I6IHN0cmluZztcbiAgZGF0YTogVDtcbn1cblxuZXhwb3J0IHR5cGUgUHJvbURhdGEgPSBQcm9tTWF0cml4RGF0YSB8IFByb21WZWN0b3JEYXRhIHwgUHJvbVNjYWxhckRhdGEgfCBQcm9tRXhlbXBsYXJEYXRhW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGFiZWxzIHtcbiAgW2luZGV4OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlbXBsYXIge1xuICBsYWJlbHM6IExhYmVscztcbiAgdmFsdWU6IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUV4ZW1wbGFyRGF0YSB7XG4gIHNlcmllc0xhYmVsczogUHJvbU1ldHJpYztcbiAgZXhlbXBsYXJzOiBFeGVtcGxhcltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21WZWN0b3JEYXRhIHtcbiAgcmVzdWx0VHlwZTogJ3ZlY3Rvcic7XG4gIHJlc3VsdDogQXJyYXk8e1xuICAgIG1ldHJpYzogUHJvbU1ldHJpYztcbiAgICB2YWx1ZTogUHJvbVZhbHVlO1xuICB9Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tTWF0cml4RGF0YSB7XG4gIHJlc3VsdFR5cGU6ICdtYXRyaXgnO1xuICByZXN1bHQ6IEFycmF5PHtcbiAgICBtZXRyaWM6IFByb21NZXRyaWM7XG4gICAgdmFsdWVzOiBQcm9tVmFsdWVbXTtcbiAgfT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbVNjYWxhckRhdGEge1xuICByZXN1bHRUeXBlOiAnc2NhbGFyJztcbiAgcmVzdWx0OiBQcm9tVmFsdWU7XG59XG5cbmV4cG9ydCB0eXBlIFByb21WYWx1ZSA9IFtudW1iZXIsIGFueV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbU1ldHJpYyB7XG4gIF9fbmFtZV9fPzogc3RyaW5nO1xuICBbaW5kZXg6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTWF0cml4RGF0YShyZXN1bHQ6IE1hdHJpeE9yVmVjdG9yUmVzdWx0KTogcmVzdWx0IGlzIFByb21NYXRyaXhEYXRhWydyZXN1bHQnXVswXSB7XG4gIHJldHVybiAndmFsdWVzJyBpbiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0V4ZW1wbGFyRGF0YShyZXN1bHQ6IFByb21EYXRhKTogcmVzdWx0IGlzIFByb21FeGVtcGxhckRhdGFbXSB7XG4gIGlmIChyZXN1bHQgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID8gJ2V4ZW1wbGFycycgaW4gcmVzdWx0WzBdIDogZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIE1hdHJpeE9yVmVjdG9yUmVzdWx0ID0gUHJvbU1hdHJpeERhdGFbJ3Jlc3VsdCddWzBdIHwgUHJvbVZlY3RvckRhdGFbJ3Jlc3VsdCddWzBdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZm9ybU9wdGlvbnMge1xuICBmb3JtYXQ/OiBzdHJpbmc7XG4gIHN0ZXA/OiBudW1iZXI7XG4gIGxlZ2VuZEZvcm1hdD86IHN0cmluZztcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIHJlc3BvbnNlTGlzdExlbmd0aDogbnVtYmVyO1xuICBzY29wZWRWYXJzPzogU2NvcGVkVmFycztcbiAgcmVmSWQ6IHN0cmluZztcbiAgdmFsdWVXaXRoUmVmSWQ/OiBib29sZWFuO1xuICBtZXRhOiBRdWVyeVJlc3VsdE1ldGE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbUxhYmVsUXVlcnlSZXNwb25zZSB7XG4gIGRhdGE6IHtcbiAgICBzdGF0dXM6IHN0cmluZztcbiAgICBkYXRhOiBzdHJpbmdbXTtcbiAgfTtcbiAgY2FuY2VsbGVkPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBdXRvID0gcXVlcnkubGVnZW5kRm9ybWF0ID09ICdfX2F1dG8nXG4gKiBWZXJib3NlID0gcXVlcnkubGVnZW5kRm9ybWF0ID09IG51bGwvdW5kZWZpbmVkLycnXG4gKiBDdXN0b20gcXVlcnkubGVnZW5kRm9ybWF0Lmxlbmd0aCA+IDAgJiYgcXVlcnkubGVnZW5kRm9ybWF0ICE9PSAnX19hdXRvJ1xuICovXG5leHBvcnQgZW51bSBMZWdlbmRGb3JtYXRNb2RlIHtcbiAgQXV0byA9ICdfX2F1dG8nLFxuICBWZXJib3NlID0gJ19fdmVyYm9zZScsXG4gIEN1c3RvbSA9ICdfX2N1c3RvbScsXG59XG4iLCJpbXBvcnQgeyBmcm9tLCBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRGF0YVF1ZXJ5UmVxdWVzdCxcbiAgRGF0YVF1ZXJ5UmVzcG9uc2UsXG4gIHJhbmdlVXRpbCxcbiAgU3RhbmRhcmRWYXJpYWJsZVF1ZXJ5LFxuICBTdGFuZGFyZFZhcmlhYmxlU3VwcG9ydCxcbn0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQgeyBnZXRUZW1wbGF0ZVNydiwgVGVtcGxhdGVTcnYgfSBmcm9tICdAZ3JhZmFuYS9ydW50aW1lJztcblxuaW1wb3J0IHsgUHJvbWV0aGV1c0RhdGFzb3VyY2UgfSBmcm9tICcuL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHsgUHJvbVF1ZXJ5IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSBmcm9tICcuL21ldHJpY19maW5kX3F1ZXJ5JztcbmltcG9ydCB7IGdldFRpbWVTcnYsIFRpbWVTcnYgfSBmcm9tICcuLi8uLi8uLi9mZWF0dXJlcy9kYXNoYm9hcmQvc2VydmljZXMvVGltZVNydic7XG5cbmV4cG9ydCBjbGFzcyBQcm9tZXRoZXVzVmFyaWFibGVTdXBwb3J0IGV4dGVuZHMgU3RhbmRhcmRWYXJpYWJsZVN1cHBvcnQ8UHJvbWV0aGV1c0RhdGFzb3VyY2U+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBkYXRhc291cmNlOiBQcm9tZXRoZXVzRGF0YXNvdXJjZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRlbXBsYXRlU3J2OiBUZW1wbGF0ZVNydiA9IGdldFRlbXBsYXRlU3J2KCksXG4gICAgcHJpdmF0ZSByZWFkb25seSB0aW1lU3J2OiBUaW1lU3J2ID0gZ2V0VGltZVNydigpXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHF1ZXJ5KHJlcXVlc3Q6IERhdGFRdWVyeVJlcXVlc3Q8UHJvbVF1ZXJ5Pik6IE9ic2VydmFibGU8RGF0YVF1ZXJ5UmVzcG9uc2U+IHtcbiAgICBjb25zdCBxdWVyeSA9IHJlcXVlc3QudGFyZ2V0c1swXS5leHByO1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiBvZih7IGRhdGE6IFtdIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlZFZhcnMgPSB7XG4gICAgICAuLi5yZXF1ZXN0LnNjb3BlZFZhcnMsXG4gICAgICBfX2ludGVydmFsOiB7IHRleHQ6IHRoaXMuZGF0YXNvdXJjZS5pbnRlcnZhbCwgdmFsdWU6IHRoaXMuZGF0YXNvdXJjZS5pbnRlcnZhbCB9LFxuICAgICAgX19pbnRlcnZhbF9tczoge1xuICAgICAgICB0ZXh0OiByYW5nZVV0aWwuaW50ZXJ2YWxUb01zKHRoaXMuZGF0YXNvdXJjZS5pbnRlcnZhbCksXG4gICAgICAgIHZhbHVlOiByYW5nZVV0aWwuaW50ZXJ2YWxUb01zKHRoaXMuZGF0YXNvdXJjZS5pbnRlcnZhbCksXG4gICAgICB9LFxuICAgICAgLi4udGhpcy5kYXRhc291cmNlLmdldFJhbmdlU2NvcGVkVmFycyh0aGlzLnRpbWVTcnYudGltZVJhbmdlKCkpLFxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSB0aGlzLnRlbXBsYXRlU3J2LnJlcGxhY2UocXVlcnksIHNjb3BlZFZhcnMsIHRoaXMuZGF0YXNvdXJjZS5pbnRlcnBvbGF0ZVF1ZXJ5RXhwcik7XG4gICAgY29uc3QgbWV0cmljRmluZFF1ZXJ5ID0gbmV3IFByb21ldGhldXNNZXRyaWNGaW5kUXVlcnkodGhpcy5kYXRhc291cmNlLCBpbnRlcnBvbGF0ZWQpO1xuICAgIGNvbnN0IG1ldHJpY0ZpbmRTdHJlYW0gPSBmcm9tKG1ldHJpY0ZpbmRRdWVyeS5wcm9jZXNzKCkpO1xuXG4gICAgcmV0dXJuIG1ldHJpY0ZpbmRTdHJlYW0ucGlwZShtYXAoKHJlc3VsdHMpID0+ICh7IGRhdGE6IHJlc3VsdHMgfSkpKTtcbiAgfVxuXG4gIHRvRGF0YVF1ZXJ5KHF1ZXJ5OiBTdGFuZGFyZFZhcmlhYmxlUXVlcnkpOiBQcm9tUXVlcnkge1xuICAgIHJldHVybiB7XG4gICAgICByZWZJZDogJ1Byb21ldGhldXNEYXRhc291cmNlLVZhcmlhYmxlUXVlcnknLFxuICAgICAgZXhwcjogcXVlcnkucXVlcnksXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VQcmV2aW91cyhzdGF0ZSkge1xuICAgIHZhciByZWYgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHN0YXRlO1xuICAgIH0pO1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbiIsImltcG9ydCB7IHVzZVJlZHVjZXIgfSBmcm9tICdyZWFjdCc7XG52YXIgdG9nZ2xlUmVkdWNlciA9IGZ1bmN0aW9uIChzdGF0ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuZXh0VmFsdWUgPT09ICdib29sZWFuJyA/IG5leHRWYWx1ZSA6ICFzdGF0ZTtcbn07XG52YXIgdXNlVG9nZ2xlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiB1c2VSZWR1Y2VyKHRvZ2dsZVJlZHVjZXIsIGluaXRpYWxWYWx1ZSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgdXNlVG9nZ2xlO1xuIiwiY29uc3QgcGVyZiA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgcGVyZm9ybWFuY2UgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlIDogRGF0ZVxuXG5jb25zdCBoYXNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJ1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIG1pbmltYWwgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcG9seWZpbGwgKi9cbmNvbnN0IEFDID0gaGFzQWJvcnRDb250cm9sbGVyID8gQWJvcnRDb250cm9sbGVyIDogT2JqZWN0LmFzc2lnbihcbiAgY2xhc3MgQWJvcnRDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7IHRoaXMuc2lnbmFsID0gbmV3IEFDLkFib3J0U2lnbmFsIH1cbiAgICBhYm9ydCAoKSB7IHRoaXMuc2lnbmFsLmFib3J0ZWQgPSB0cnVlIH1cbiAgfSxcbiAgeyBBYm9ydFNpZ25hbDogY2xhc3MgQWJvcnRTaWduYWwgeyBjb25zdHJ1Y3RvciAoKSB7IHRoaXMuYWJvcnRlZCA9IGZhbHNlIH19fVxuKVxuXG5jb25zdCB3YXJuZWQgPSBuZXcgU2V0KClcbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb24gPSAob3B0LCBpbnN0ZWFkKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBgTFJVX0NBQ0hFX09QVElPTl8ke29wdH1gXG4gIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgd2Fybihjb2RlLCBgJHtvcHR9IG9wdGlvbmAsIGBvcHRpb25zLiR7aW5zdGVhZH1gLCBMUlVDYWNoZSlcbiAgfVxufVxuY29uc3QgZGVwcmVjYXRlZE1ldGhvZCA9IChtZXRob2QsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfTUVUSE9EXyR7bWV0aG9kfWBcbiAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICBjb25zdCB7IHByb3RvdHlwZSB9ID0gTFJVQ2FjaGVcbiAgICBjb25zdCB7IGdldCB9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIG1ldGhvZClcbiAgICB3YXJuKGNvZGUsIGAke21ldGhvZH0gbWV0aG9kYCwgYGNhY2hlLiR7aW5zdGVhZH0oKWAsIGdldClcbiAgfVxufVxuY29uc3QgZGVwcmVjYXRlZFByb3BlcnR5ID0gKGZpZWxkLCBpbnN0ZWFkKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBgTFJVX0NBQ0hFX1BST1BFUlRZXyR7ZmllbGR9YFxuICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgIGNvbnN0IHsgcHJvdG90eXBlIH0gPSBMUlVDYWNoZVxuICAgIGNvbnN0IHsgZ2V0IH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgZmllbGQpXG4gICAgd2Fybihjb2RlLCBgJHtmaWVsZH0gcHJvcGVydHlgLCBgY2FjaGUuJHtpbnN0ZWFkfWAsIGdldClcbiAgfVxufVxuXG5jb25zdCBzaG91bGRXYXJuID0gY29kZSA9PiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2VzcyAmJlxuICAhd2FybmVkLmhhcyhjb2RlKVxuXG5jb25zdCB3YXJuID0gKGNvZGUsIHdoYXQsIGluc3RlYWQsIGZuKSA9PiB7XG4gIHdhcm5lZC5hZGQoY29kZSlcbiAgY29uc3QgbXNnID0gYFRoZSAke3doYXR9IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJHtpbnN0ZWFkfSBpbnN0ZWFkLmBcbiAgcHJvY2Vzcy5lbWl0V2FybmluZyhtc2csICdEZXByZWNhdGlvbldhcm5pbmcnLCBjb2RlLCBmbilcbn1cblxuY29uc3QgaXNQb3NJbnQgPSBuID0+IG4gJiYgbiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID4gMCAmJiBpc0Zpbml0ZShuKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFRoaXMgaXMgYSBsaXR0bGUgYml0IHJpZGljdWxvdXMsIHRiaC5cbiAqIFRoZSBtYXhpbXVtIGFycmF5IGxlbmd0aCBpcyAyXjMyLTEgb3IgdGhlcmVhYm91dHMgb24gbW9zdCBKUyBpbXBscy5cbiAqIEFuZCB3ZWxsIGJlZm9yZSB0aGF0IHBvaW50LCB5b3UncmUgY2FjaGluZyB0aGUgZW50aXJlIHdvcmxkLCBJIG1lYW4sXG4gKiB0aGF0J3MgfjMyR0Igb2YganVzdCBpbnRlZ2VycyBmb3IgdGhlIG5leHQvcHJldiBsaW5rcywgcGx1cyB3aGF0ZXZlclxuICogZWxzZSB0byBob2xkIHRoYXQgbWFueSBrZXlzIGFuZCB2YWx1ZXMuICBKdXN0IGZpbGxpbmcgdGhlIG1lbW9yeSB3aXRoXG4gKiB6ZXJvZXMgYXQgaW5pdCB0aW1lIGlzIGJydXRhbCB3aGVuIHlvdSBnZXQgdGhhdCBiaWcuXG4gKiBCdXQgd2h5IG5vdCBiZSBjb21wbGV0ZT9cbiAqIE1heWJlIGluIHRoZSBmdXR1cmUsIHRoZXNlIGxpbWl0cyB3aWxsIGhhdmUgZXhwYW5kZWQuICovXG5jb25zdCBnZXRVaW50QXJyYXkgPSBtYXggPT4gIWlzUG9zSW50KG1heCkgPyBudWxsXG46IG1heCA8PSBNYXRoLnBvdygyLCA4KSA/IFVpbnQ4QXJyYXlcbjogbWF4IDw9IE1hdGgucG93KDIsIDE2KSA/IFVpbnQxNkFycmF5XG46IG1heCA8PSBNYXRoLnBvdygyLCAzMikgPyBVaW50MzJBcnJheVxuOiBtYXggPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPyBaZXJvQXJyYXlcbjogbnVsbFxuXG5jbGFzcyBaZXJvQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yIChzaXplKSB7XG4gICAgc3VwZXIoc2l6ZSlcbiAgICB0aGlzLmZpbGwoMClcbiAgfVxufVxuXG5jbGFzcyBTdGFjayB7XG4gIGNvbnN0cnVjdG9yIChtYXgpIHtcbiAgICBjb25zdCBVaW50QXJyYXkgPSBtYXggPyBnZXRVaW50QXJyYXkobWF4KSA6IEFycmF5XG4gICAgdGhpcy5oZWFwID0gbmV3IFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbiAgcHVzaCAobikge1xuICAgIHRoaXMuaGVhcFt0aGlzLmxlbmd0aCsrXSA9IG5cbiAgfVxuICBwb3AgKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXBbLS10aGlzLmxlbmd0aF1cbiAgfVxufVxuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXggPSAwLFxuICAgICAgdHRsLFxuICAgICAgdHRsUmVzb2x1dGlvbiA9IDEsXG4gICAgICB0dGxBdXRvcHVyZ2UsXG4gICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgIGFsbG93U3RhbGUsXG4gICAgICBkaXNwb3NlLFxuICAgICAgZGlzcG9zZUFmdGVyLFxuICAgICAgbm9EaXNwb3NlT25TZXQsXG4gICAgICBub1VwZGF0ZVRUTCxcbiAgICAgIG1heFNpemUgPSAwLFxuICAgICAgc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgZmV0Y2hNZXRob2QsXG4gICAgfSA9IG9wdGlvbnNcblxuICAgIC8vIGRlcHJlY2F0ZWQgb3B0aW9ucywgZG9uJ3QgdHJpZ2dlciBhIHdhcm5pbmcgZm9yIGdldHRpbmcgdGhlbSBpZlxuICAgIC8vIHRoZSB0aGluZyBiZWluZyBwYXNzZWQgaW4gaXMgYW5vdGhlciBMUlVDYWNoZSB3ZSdyZSBjb3B5aW5nLlxuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aCxcbiAgICAgIG1heEFnZSxcbiAgICAgIHN0YWxlLFxuICAgIH0gPSBvcHRpb25zIGluc3RhbmNlb2YgTFJVQ2FjaGUgPyB7fSA6IG9wdGlvbnNcblxuICAgIGlmIChtYXggIT09IDAgJiYgIWlzUG9zSW50KG1heCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBvcHRpb24gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKVxuICAgIH1cblxuICAgIGNvbnN0IFVpbnRBcnJheSA9IG1heCA/IGdldFVpbnRBcnJheShtYXgpIDogQXJyYXlcbiAgICBpZiAoIVVpbnRBcnJheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heCB2YWx1ZTogJyArIG1heClcbiAgICB9XG5cbiAgICB0aGlzLm1heCA9IG1heFxuICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemVcbiAgICB0aGlzLnNpemVDYWxjdWxhdGlvbiA9IHNpemVDYWxjdWxhdGlvbiB8fCBsZW5ndGhcbiAgICBpZiAodGhpcy5zaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgIGlmICghdGhpcy5tYXhTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZUNhbGN1bGF0aW9uIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplJylcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW5nIHNldCB0byBub24tZnVuY3Rpb24nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmV0Y2hNZXRob2QgPSBmZXRjaE1ldGhvZCB8fCBudWxsXG4gICAgaWYgKHRoaXMuZmV0Y2hNZXRob2QgJiYgdHlwZW9mIHRoaXMuZmV0Y2hNZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZldGNoTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbiBpZiBzcGVjaWZpZWQnKVxuICAgIH1cblxuXG4gICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKClcbiAgICB0aGlzLmtleUxpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKG51bGwpXG4gICAgdGhpcy52YWxMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbChudWxsKVxuICAgIHRoaXMubmV4dCA9IG5ldyBVaW50QXJyYXkobWF4KVxuICAgIHRoaXMucHJldiA9IG5ldyBVaW50QXJyYXkobWF4KVxuICAgIHRoaXMuaGVhZCA9IDBcbiAgICB0aGlzLnRhaWwgPSAwXG4gICAgdGhpcy5mcmVlID0gbmV3IFN0YWNrKG1heClcbiAgICB0aGlzLmluaXRpYWxGaWxsID0gMVxuICAgIHRoaXMuc2l6ZSA9IDBcblxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5kaXNwb3NlID0gZGlzcG9zZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2VBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIgPSBkaXNwb3NlQWZ0ZXJcbiAgICAgIHRoaXMuZGlzcG9zZWQgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3Bvc2VBZnRlciA9IG51bGxcbiAgICAgIHRoaXMuZGlzcG9zZWQgPSBudWxsXG4gICAgfVxuICAgIHRoaXMubm9EaXNwb3NlT25TZXQgPSAhIW5vRGlzcG9zZU9uU2V0XG4gICAgdGhpcy5ub1VwZGF0ZVRUTCA9ICEhbm9VcGRhdGVUVExcblxuICAgIGlmICh0aGlzLm1heFNpemUgIT09IDApIHtcbiAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhTaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpXG4gICAgICB9XG4gICAgICB0aGlzLmluaXRpYWxpemVTaXplVHJhY2tpbmcoKVxuICAgIH1cblxuICAgIHRoaXMuYWxsb3dTdGFsZSA9ICEhYWxsb3dTdGFsZSB8fCAhIXN0YWxlXG4gICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXRcbiAgICB0aGlzLnR0bFJlc29sdXRpb24gPSBpc1Bvc0ludCh0dGxSZXNvbHV0aW9uKSB8fCB0dGxSZXNvbHV0aW9uID09PSAwXG4gICAgICA/IHR0bFJlc29sdXRpb24gOiAxXG4gICAgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIXR0bEF1dG9wdXJnZVxuICAgIHRoaXMudHRsID0gdHRsIHx8IG1heEFnZSB8fCAwXG4gICAgaWYgKHRoaXMudHRsKSB7XG4gICAgICBpZiAoIWlzUG9zSW50KHRoaXMudHRsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0dGwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJylcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVRUTFRyYWNraW5nKClcbiAgICB9XG5cbiAgICAvLyBkbyBub3QgYWxsb3cgY29tcGxldGVseSB1bmJvdW5kZWQgY2FjaGVzXG4gICAgaWYgKHRoaXMubWF4ID09PSAwICYmIHRoaXMudHRsID09PSAwICYmIHRoaXMubWF4U2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXQgbGVhc3Qgb25lIG9mIG1heCwgbWF4U2l6ZSwgb3IgdHRsIGlzIHJlcXVpcmVkJylcbiAgICB9XG4gICAgaWYgKCF0aGlzLnR0bEF1dG9wdXJnZSAmJiAhdGhpcy5tYXggJiYgIXRoaXMubWF4U2l6ZSkge1xuICAgICAgY29uc3QgY29kZSA9ICdMUlVfQ0FDSEVfVU5CT1VOREVEJ1xuICAgICAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICAgICAgd2FybmVkLmFkZChjb2RlKVxuICAgICAgICBjb25zdCBtc2cgPSAnVFRMIGNhY2hpbmcgd2l0aG91dCB0dGxBdXRvcHVyZ2UsIG1heCwgb3IgbWF4U2l6ZSBjYW4gJyArXG4gICAgICAgICAgJ3Jlc3VsdCBpbiB1bmJvdW5kZWQgbWVtb3J5IGNvbnN1bXB0aW9uLidcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhtc2csICdVbmJvdW5kZWRDYWNoZVdhcm5pbmcnLCBjb2RlLCBMUlVDYWNoZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhbGUpIHtcbiAgICAgIGRlcHJlY2F0ZWRPcHRpb24oJ3N0YWxlJywgJ2FsbG93U3RhbGUnKVxuICAgIH1cbiAgICBpZiAobWF4QWdlKSB7XG4gICAgICBkZXByZWNhdGVkT3B0aW9uKCdtYXhBZ2UnLCAndHRsJylcbiAgICB9XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgZGVwcmVjYXRlZE9wdGlvbignbGVuZ3RoJywgJ3NpemVDYWxjdWxhdGlvbicpXG4gICAgfVxuICB9XG5cbiAgZ2V0UmVtYWluaW5nVFRMIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoa2V5KSA/IEluZmluaXR5IDogMFxuICB9XG5cbiAgaW5pdGlhbGl6ZVRUTFRyYWNraW5nICgpIHtcbiAgICB0aGlzLnR0bHMgPSBuZXcgWmVyb0FycmF5KHRoaXMubWF4KVxuICAgIHRoaXMuc3RhcnRzID0gbmV3IFplcm9BcnJheSh0aGlzLm1heClcblxuICAgIHRoaXMuc2V0SXRlbVRUTCA9IChpbmRleCwgdHRsKSA9PiB7XG4gICAgICB0aGlzLnN0YXJ0c1tpbmRleF0gPSB0dGwgIT09IDAgPyBwZXJmLm5vdygpIDogMFxuICAgICAgdGhpcy50dGxzW2luZGV4XSA9IHR0bFxuICAgICAgaWYgKHR0bCAhPT0gMCAmJiB0aGlzLnR0bEF1dG9wdXJnZSkge1xuICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHRoaXMua2V5TGlzdFtpbmRleF0pXG4gICAgICAgICAgfVxuICAgICAgICB9LCB0dGwgKyAxKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIHVucmVmKCkgbm90IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zICovXG4gICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgdC51bnJlZigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UgPSAoaW5kZXgpID0+IHtcbiAgICAgIHRoaXMuc3RhcnRzW2luZGV4XSA9IHRoaXMudHRsc1tpbmRleF0gIT09IDAgPyBwZXJmLm5vdygpIDogMFxuICAgIH1cblxuICAgIC8vIGRlYm91bmNlIGNhbGxzIHRvIHBlcmYubm93KCkgdG8gMXMgc28gd2UncmUgbm90IGhpdHRpbmdcbiAgICAvLyB0aGF0IGNvc3RseSBjYWxsIHJlcGVhdGVkbHkuXG4gICAgbGV0IGNhY2hlZE5vdyA9IDBcbiAgICBjb25zdCBnZXROb3cgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuID0gcGVyZi5ub3coKVxuICAgICAgaWYgKHRoaXMudHRsUmVzb2x1dGlvbiA+IDApIHtcbiAgICAgICAgY2FjaGVkTm93ID0gblxuICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiBjYWNoZWROb3cgPSAwLCB0aGlzLnR0bFJlc29sdXRpb24pXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gbm90IGF2YWlsYWJsZSBvbiBhbGwgcGxhdGZvcm1zICovXG4gICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgdC51bnJlZigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuXG4gICAgfVxuXG4gICAgdGhpcy5nZXRSZW1haW5pbmdUVEwgPSAoa2V5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrZXkpXG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHRsc1tpbmRleF0gPT09IDAgfHwgdGhpcy5zdGFydHNbaW5kZXhdID09PSAwID8gSW5maW5pdHlcbiAgICAgICAgOiAoKHRoaXMuc3RhcnRzW2luZGV4XSArIHRoaXMudHRsc1tpbmRleF0pIC0gKGNhY2hlZE5vdyB8fCBnZXROb3coKSkpXG4gICAgfVxuXG4gICAgdGhpcy5pc1N0YWxlID0gKGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50dGxzW2luZGV4XSAhPT0gMCAmJiB0aGlzLnN0YXJ0c1tpbmRleF0gIT09IDAgJiZcbiAgICAgICAgKChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpIC0gdGhpcy5zdGFydHNbaW5kZXhdID4gdGhpcy50dGxzW2luZGV4XSlcbiAgICB9XG4gIH1cbiAgdXBkYXRlSXRlbUFnZSAoaW5kZXgpIHt9XG4gIHNldEl0ZW1UVEwgKGluZGV4LCB0dGwpIHt9XG4gIGlzU3RhbGUgKGluZGV4KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaW5pdGlhbGl6ZVNpemVUcmFja2luZyAoKSB7XG4gICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSA9IDBcbiAgICB0aGlzLnNpemVzID0gbmV3IFplcm9BcnJheSh0aGlzLm1heClcbiAgICB0aGlzLnJlbW92ZUl0ZW1TaXplID0gaW5kZXggPT4gdGhpcy5jYWxjdWxhdGVkU2l6ZSAtPSB0aGlzLnNpemVzW2luZGV4XVxuICAgIHRoaXMucmVxdWlyZVNpemUgPSAoaywgdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICBpZiAoc2l6ZUNhbGN1bGF0aW9uICYmICFzaXplKSB7XG4gICAgICAgIHNpemUgPSBzaXplQ2FsY3VsYXRpb24odiwgaylcbiAgICAgIH1cbiAgICAgIGlmICghaXNQb3NJbnQoc2l6ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXInKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemVcbiAgICB9XG4gICAgdGhpcy5hZGRJdGVtU2l6ZSA9IChpbmRleCwgdiwgaywgc2l6ZSkgPT4ge1xuICAgICAgdGhpcy5zaXplc1tpbmRleF0gPSBzaXplXG4gICAgICBjb25zdCBtYXhTaXplID0gdGhpcy5tYXhTaXplIC0gdGhpcy5zaXplc1tpbmRleF1cbiAgICAgIHdoaWxlICh0aGlzLmNhbGN1bGF0ZWRTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICB0aGlzLmV2aWN0KClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgKz0gdGhpcy5zaXplc1tpbmRleF1cbiAgICB9XG4gICAgdGhpcy5kZWxldGUgPSBrID0+IHtcbiAgICAgIGlmICh0aGlzLnNpemUgIT09IDApIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNhbGN1bGF0ZWRTaXplIC09IHRoaXMuc2l6ZXNbaW5kZXhdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBMUlVDYWNoZS5wcm90b3R5cGUuZGVsZXRlLmNhbGwodGhpcywgaylcbiAgICB9XG4gIH1cbiAgcmVtb3ZlSXRlbVNpemUgKGluZGV4KSB7fVxuICBhZGRJdGVtU2l6ZSAoaW5kZXgsIHYsIGssIHNpemUpIHt9XG4gIHJlcXVpcmVTaXplIChrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pIHtcbiAgICBpZiAoc2l6ZSB8fCBzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZSB3aXRob3V0IHNldHRpbmcgbWF4U2l6ZSBvbiBjYWNoZScpXG4gICAgfVxuICB9XG5cbiAgKmluZGV4ZXMgKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy50YWlsOyB0cnVlOyApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICAgIHlpZWxkIGlcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gdGhpcy5wcmV2W2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAqcmluZGV4ZXMgKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFkOyB0cnVlOyApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93U3RhbGUgfHwgIXRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICAgIHlpZWxkIGlcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpID0gdGhpcy5uZXh0W2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkSW5kZXggKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldCh0aGlzLmtleUxpc3RbaW5kZXhdKSA9PT0gaW5kZXhcbiAgfVxuXG4gICplbnRyaWVzICgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIFt0aGlzLmtleUxpc3RbaV0sIHRoaXMudmFsTGlzdFtpXV1cbiAgICB9XG4gIH1cbiAgKnJlbnRyaWVzICgpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCBbdGhpcy5rZXlMaXN0W2ldLCB0aGlzLnZhbExpc3RbaV1dXG4gICAgfVxuICB9XG5cbiAgKmtleXMgKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy5rZXlMaXN0W2ldXG4gICAgfVxuICB9XG4gICpya2V5cyAoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgeWllbGQgdGhpcy5rZXlMaXN0W2ldXG4gICAgfVxuICB9XG5cbiAgKnZhbHVlcyAoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICB5aWVsZCB0aGlzLnZhbExpc3RbaV1cbiAgICB9XG4gIH1cbiAgKnJ2YWx1ZXMgKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIHlpZWxkIHRoaXMudmFsTGlzdFtpXVxuICAgIH1cbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKClcbiAgfVxuXG4gIGZpbmQgKGZuLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGlmIChmbih0aGlzLnZhbExpc3RbaV0sIHRoaXMua2V5TGlzdFtpXSwgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMua2V5TGlzdFtpXSwgZ2V0T3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3JFYWNoIChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuaW5kZXhlcygpKSB7XG4gICAgICBmbi5jYWxsKHRoaXNwLCB0aGlzLnZhbExpc3RbaV0sIHRoaXMua2V5TGlzdFtpXSwgdGhpcylcbiAgICB9XG4gIH1cblxuICByZm9yRWFjaCAoZm4sIHRoaXNwID0gdGhpcykge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIGZuLmNhbGwodGhpc3AsIHRoaXMudmFsTGlzdFtpXSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGdldCBwcnVuZSAoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgncHJ1bmUnLCAncHVyZ2VTdGFsZScpXG4gICAgcmV0dXJuIHRoaXMucHVyZ2VTdGFsZVxuICB9XG5cbiAgcHVyZ2VTdGFsZSAoKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZVxuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgaWYgKHRoaXMuaXNTdGFsZShpKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZSh0aGlzLmtleUxpc3RbaV0pXG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWxldGVkXG4gIH1cblxuICBkdW1wICgpIHtcbiAgICBjb25zdCBhcnIgPSBbXVxuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlMaXN0W2ldXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsTGlzdFtpXVxuICAgICAgY29uc3QgZW50cnkgPSB7IHZhbHVlIH1cbiAgICAgIGlmICh0aGlzLnR0bHMpIHtcbiAgICAgICAgZW50cnkudHRsID0gdGhpcy50dGxzW2ldXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplcykge1xuICAgICAgICBlbnRyeS5zaXplID0gdGhpcy5zaXplc1tpXVxuICAgICAgfVxuICAgICAgYXJyLnVuc2hpZnQoW2tleSwgZW50cnldKVxuICAgIH1cbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBsb2FkIChhcnIpIHtcbiAgICB0aGlzLmNsZWFyKClcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBhcnIpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZW50cnkudmFsdWUsIGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UgKHYsIGssIHJlYXNvbikge31cblxuICBzZXQgKGssIHYsIHtcbiAgICB0dGwgPSB0aGlzLnR0bCxcbiAgICBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsXG4gICAgc2l6ZSA9IDAsXG4gICAgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sXG4gICAgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMLFxuICB9ID0ge30pIHtcbiAgICBzaXplID0gdGhpcy5yZXF1aXJlU2l6ZShrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pXG4gICAgbGV0IGluZGV4ID0gdGhpcy5zaXplID09PSAwID8gdW5kZWZpbmVkIDogdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGFkZGl0aW9uXG4gICAgICBpbmRleCA9IHRoaXMubmV3SW5kZXgoKVxuICAgICAgdGhpcy5rZXlMaXN0W2luZGV4XSA9IGtcbiAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSB2XG4gICAgICB0aGlzLmtleU1hcC5zZXQoaywgaW5kZXgpXG4gICAgICB0aGlzLm5leHRbdGhpcy50YWlsXSA9IGluZGV4XG4gICAgICB0aGlzLnByZXZbaW5kZXhdID0gdGhpcy50YWlsXG4gICAgICB0aGlzLnRhaWwgPSBpbmRleFxuICAgICAgdGhpcy5zaXplICsrXG4gICAgICB0aGlzLmFkZEl0ZW1TaXplKGluZGV4LCB2LCBrLCBzaXplKVxuICAgICAgbm9VcGRhdGVUVEwgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVcbiAgICAgIGNvbnN0IG9sZFZhbCA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh2ICE9PSBvbGRWYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2gob2xkVmFsKSkge1xuICAgICAgICAgIG9sZFZhbC5fX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKG9sZFZhbCwgaywgJ3NldCcpXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlZC5wdXNoKFtvbGRWYWwsIGssICdzZXQnXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShpbmRleClcbiAgICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHZcbiAgICAgICAgdGhpcy5hZGRJdGVtU2l6ZShpbmRleCwgdiwgaywgc2l6ZSlcbiAgICAgIH1cbiAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICB9XG4gICAgaWYgKHR0bCAhPT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiAhdGhpcy50dGxzKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVUVExUcmFja2luZygpXG4gICAgfVxuICAgIGlmICghbm9VcGRhdGVUVEwpIHtcbiAgICAgIHRoaXMuc2V0SXRlbVRUTChpbmRleCwgdHRsKVxuICAgIH1cbiAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgIHdoaWxlICh0aGlzLmRpc3Bvc2VkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VBZnRlciguLi50aGlzLmRpc3Bvc2VkLnNoaWZ0KCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBuZXdJbmRleCAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFpbFxuICAgIH1cbiAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLm1heCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZpY3QoKVxuICAgIH1cbiAgICBpZiAodGhpcy5mcmVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJlZS5wb3AoKVxuICAgIH1cbiAgICAvLyBpbml0aWFsIGZpbGwsIGp1c3Qga2VlcCB3cml0aW5nIGRvd24gdGhlIGxpc3RcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsRmlsbCsrXG4gIH1cblxuICBwb3AgKCkge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsTGlzdFt0aGlzLmhlYWRdXG4gICAgICB0aGlzLmV2aWN0KClcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gIH1cblxuICBldmljdCAoKSB7XG4gICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZFxuICAgIGNvbnN0IGsgPSB0aGlzLmtleUxpc3RbaGVhZF1cbiAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2hlYWRdXG4gICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3Bvc2UodiwgaywgJ2V2aWN0JylcbiAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdldmljdCddKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbW92ZUl0ZW1TaXplKGhlYWQpXG4gICAgdGhpcy5oZWFkID0gdGhpcy5uZXh0W2hlYWRdXG4gICAgdGhpcy5rZXlNYXAuZGVsZXRlKGspXG4gICAgdGhpcy5zaXplIC0tXG4gICAgcmV0dXJuIGhlYWRcbiAgfVxuXG4gIGhhcyAoaykge1xuICAgIHJldHVybiB0aGlzLmtleU1hcC5oYXMoaykgJiYgIXRoaXMuaXNTdGFsZSh0aGlzLmtleU1hcC5nZXQoaykpXG4gIH1cblxuICAvLyBsaWtlIGdldCgpLCBidXQgd2l0aG91dCBhbnkgTFJVIHVwZGF0aW5nIG9yIFRUTCBleHBpcmF0aW9uXG4gIHBlZWsgKGssIHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIChhbGxvd1N0YWxlIHx8ICF0aGlzLmlzU3RhbGUoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICB9XG4gIH1cblxuICBiYWNrZ3JvdW5kRmV0Y2ggKGssIGluZGV4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdiA9IGluZGV4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgIHJldHVybiB2XG4gICAgfVxuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgY29uc3QgZmV0Y2hPcHRzID0ge1xuICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICBvcHRpb25zLFxuICAgIH1cbiAgICBjb25zdCBwID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZmV0Y2hNZXRob2QoaywgdiwgZmV0Y2hPcHRzKSkudGhlbih2ID0+IHtcbiAgICAgIGlmICghYWMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdiwgZmV0Y2hPcHRzLm9wdGlvbnMpXG4gICAgICB9XG4gICAgICByZXR1cm4gdlxuICAgIH0pXG4gICAgcC5fX2Fib3J0Q29udHJvbGxlciA9IGFjXG4gICAgcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA9IHZcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXQoaywgcCwgZmV0Y2hPcHRzLm9wdGlvbnMpXG4gICAgICBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gcFxuICAgIH1cbiAgICByZXR1cm4gcFxuICB9XG5cbiAgaXNCYWNrZ3JvdW5kRmV0Y2ggKHApIHtcbiAgICByZXR1cm4gcCAmJiB0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHAudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsICdfX3N0YWxlV2hpbGVGZXRjaGluZycpXG4gIH1cblxuICAvLyB0aGlzIHRha2VzIHRoZSB1bmlvbiBvZiBnZXQoKSBhbmQgc2V0KCkgb3B0cywgYmVjYXVzZSBpdCBkb2VzIGJvdGhcbiAgYXN5bmMgZmV0Y2ggKGssIHtcbiAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLFxuICAgIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCxcbiAgICB0dGwgPSB0aGlzLnR0bCxcbiAgICBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsXG4gICAgc2l6ZSA9IDAsXG4gICAgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sXG4gICAgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuZmV0Y2hNZXRob2QpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChrLCB7YWxsb3dTdGFsZSwgdXBkYXRlQWdlT25HZXR9KVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N0YWxlLFxuICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICB0dGwsXG4gICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgIHNpemUsXG4gICAgICBzaXplQ2FsY3VsYXRpb24sXG4gICAgICBub1VwZGF0ZVRUTCxcbiAgICB9XG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBjYWNoZSwgbWF5YmUgYWxyZWFkeSBmZXRjaGluZ1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgIHJldHVybiBhbGxvd1N0YWxlICYmIHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHZcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICAgICAgaWYgKHVwZGF0ZUFnZU9uR2V0KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVJdGVtQWdlKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2XG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBpdCBpcyBzdGFsZSwgYW5kIG5vdCBhbHJlYWR5IGZldGNoaW5nXG4gICAgICAvLyByZWZyZXNoIHRoZSBjYWNoZS5cbiAgICAgIGNvbnN0IHAgPSB0aGlzLmJhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucylcbiAgICAgIHJldHVybiBhbGxvd1N0YWxlICYmIHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiBwXG4gICAgfVxuICB9XG5cbiAgZ2V0IChrLCB7XG4gICAgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSxcbiAgICB1cGRhdGVBZ2VPbkdldCA9IHRoaXMudXBkYXRlQWdlT25HZXQsXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgY29uc3QgZmV0Y2hpbmcgPSB0aGlzLmlzQmFja2dyb3VuZEZldGNoKHZhbHVlKVxuICAgICAgaWYgKHRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgLy8gZGVsZXRlIG9ubHkgaWYgbm90IGFuIGluLWZsaWdodCBiYWNrZ3JvdW5kIGZldGNoXG4gICAgICAgIGlmICghZmV0Y2hpbmcpIHtcbiAgICAgICAgICB0aGlzLmRlbGV0ZShrKVxuICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUgOiB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGN1cnJlbnRseSBmZXRjaGluZyBpdCwgd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBpdCB5ZXRcbiAgICAgICAgLy8gaXQncyBub3Qgc3RhbGUsIHdoaWNoIG1lYW5zIHRoaXMgaXNuJ3QgYSBzdGFsZVdoaWxlUmVmZXRjaGluZyxcbiAgICAgICAgLy8gc28gd2UganVzdCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmIChmZXRjaGluZykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVUb1RhaWwoaW5kZXgpXG4gICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlSXRlbUFnZShpbmRleClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25uZWN0IChwLCBuKSB7XG4gICAgdGhpcy5wcmV2W25dID0gcFxuICAgIHRoaXMubmV4dFtwXSA9IG5cbiAgfVxuXG4gIG1vdmVUb1RhaWwgKGluZGV4KSB7XG4gICAgLy8gaWYgdGFpbCBhbHJlYWR5LCBub3RoaW5nIHRvIGRvXG4gICAgLy8gaWYgaGVhZCwgbW92ZSBoZWFkIHRvIG5leHRbaW5kZXhdXG4gICAgLy8gZWxzZVxuICAgIC8vICAgbW92ZSBuZXh0W3ByZXZbaW5kZXhdXSB0byBuZXh0W2luZGV4XSAoaGVhZCBoYXMgbm8gcHJldilcbiAgICAvLyAgIG1vdmUgcHJldltuZXh0W2luZGV4XV0gdG8gcHJldltpbmRleF1cbiAgICAvLyBwcmV2W2luZGV4XSA9IHRhaWxcbiAgICAvLyBuZXh0W3RhaWxdID0gaW5kZXhcbiAgICAvLyB0YWlsID0gaW5kZXhcbiAgICBpZiAoaW5kZXggIT09IHRoaXMudGFpbCkge1xuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5uZXh0W2luZGV4XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMucHJldltpbmRleF0sIHRoaXMubmV4dFtpbmRleF0pXG4gICAgICB9XG4gICAgICB0aGlzLmNvbm5lY3QodGhpcy50YWlsLCBpbmRleClcbiAgICAgIHRoaXMudGFpbCA9IGluZGV4XG4gICAgfVxuICB9XG5cbiAgZ2V0IGRlbCAoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgnZGVsJywgJ2RlbGV0ZScpXG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlXG4gIH1cbiAgZGVsZXRlIChrKSB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZVxuICAgIGlmICh0aGlzLnNpemUgIT09IDApIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGVkID0gdHJ1ZVxuICAgICAgICBpZiAodGhpcy5zaXplID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5jbGVhcigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVJdGVtU2l6ZShpbmRleClcbiAgICAgICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdkZWxldGUnKVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2RlbGV0ZSddKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmtleU1hcC5kZWxldGUoaylcbiAgICAgICAgICB0aGlzLmtleUxpc3RbaW5kZXhdID0gbnVsbFxuICAgICAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSBudWxsXG4gICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMucHJldltpbmRleF1cbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0W3RoaXMucHJldltpbmRleF1dID0gdGhpcy5uZXh0W2luZGV4XVxuICAgICAgICAgICAgdGhpcy5wcmV2W3RoaXMubmV4dFtpbmRleF1dID0gdGhpcy5wcmV2W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNpemUgLS1cbiAgICAgICAgICB0aGlzLmZyZWUucHVzaChpbmRleClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWRcbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRoaXMucmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrID0gdGhpcy5rZXlMaXN0W2luZGV4XVxuICAgICAgICB0aGlzLmRpc3Bvc2UodiwgaywgJ2RlbGV0ZScpXG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2RlbGV0ZSddKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5rZXlNYXAuY2xlYXIoKVxuICAgIHRoaXMudmFsTGlzdC5maWxsKG51bGwpXG4gICAgdGhpcy5rZXlMaXN0LmZpbGwobnVsbClcbiAgICBpZiAodGhpcy50dGxzKSB7XG4gICAgICB0aGlzLnR0bHMuZmlsbCgwKVxuICAgICAgdGhpcy5zdGFydHMuZmlsbCgwKVxuICAgIH1cbiAgICBpZiAodGhpcy5zaXplcykge1xuICAgICAgdGhpcy5zaXplcy5maWxsKDApXG4gICAgfVxuICAgIHRoaXMuaGVhZCA9IDBcbiAgICB0aGlzLnRhaWwgPSAwXG4gICAgdGhpcy5pbml0aWFsRmlsbCA9IDFcbiAgICB0aGlzLmZyZWUubGVuZ3RoID0gMFxuICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgPSAwXG4gICAgdGhpcy5zaXplID0gMFxuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICB3aGlsZSAodGhpcy5kaXNwb3NlZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIoLi4udGhpcy5kaXNwb3NlZC5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcmVzZXQgKCkge1xuICAgIGRlcHJlY2F0ZWRNZXRob2QoJ3Jlc2V0JywgJ2NsZWFyJylcbiAgICByZXR1cm4gdGhpcy5jbGVhclxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgZGVwcmVjYXRlZFByb3BlcnR5KCdsZW5ndGgnLCAnc2l6ZScpXG4gICAgcmV0dXJuIHRoaXMuc2l6ZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsImltcG9ydCB7IExSUGFyc2VyIH0gZnJvbSAnQGxlemVyL2xyJztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBcbiAgaW5mID0gMTQ2LFxuICBuYW4gPSAxNDcsXG4gIEJvb2wgPSAxLFxuICBJZ25vcmluZyA9IDIsXG4gIE9uID0gMyxcbiAgR3JvdXBMZWZ0ID0gNCxcbiAgR3JvdXBSaWdodCA9IDUsXG4gIE9mZnNldCA9IDYsXG4gIEF0YW4yID0gNyxcbiAgQXZnID0gOCxcbiAgQm90dG9tayA9IDksXG4gIENvdW50ID0gMTAsXG4gIENvdW50VmFsdWVzID0gMTEsXG4gIEdyb3VwID0gMTIsXG4gIE1heCA9IDEzLFxuICBNaW4gPSAxNCxcbiAgUXVhbnRpbGUgPSAxNSxcbiAgU3RkZGV2ID0gMTYsXG4gIFN0ZHZhciA9IDE3LFxuICBTdW0gPSAxOCxcbiAgVG9wayA9IDE5LFxuICBCeSA9IDIwLFxuICBXaXRob3V0ID0gMjEsXG4gIEFuZCA9IDIyLFxuICBPciA9IDIzLFxuICBVbmxlc3MgPSAyNCxcbiAgU3RhcnQgPSAyNSxcbiAgRW5kID0gMjY7XG5cbi8vIENvcHlyaWdodCAyMDIxIFRoZSBQcm9tZXRoZXVzIEF1dGhvcnNcblxuY29uc3Qga2V5d29yZFRva2VucyA9IHtcbiAgICBpbmY6IGluZixcbiAgICBuYW46IG5hbixcbiAgICBib29sOiBCb29sLFxuICAgIGlnbm9yaW5nOiBJZ25vcmluZyxcbiAgICBvbjogT24sXG4gICAgZ3JvdXBfbGVmdDogR3JvdXBMZWZ0LFxuICAgIGdyb3VwX3JpZ2h0OiBHcm91cFJpZ2h0LFxuICAgIG9mZnNldDogT2Zmc2V0LFxufTtcblxuY29uc3Qgc3BlY2lhbGl6ZUlkZW50aWZpZXIgPSAodmFsdWUsIHN0YWNrKSA9PiB7XG4gICAgcmV0dXJuIGtleXdvcmRUb2tlbnNbdmFsdWUudG9Mb3dlckNhc2UoKV0gfHwgLTE7XG59O1xuXG5jb25zdCBjb250ZXh0dWFsS2V5d29yZFRva2VucyA9IHtcbiAgICBhdmc6IEF2ZyxcbiAgICBhdGFuMjogQXRhbjIsXG4gICAgYm90dG9tazogQm90dG9tayxcbiAgICBjb3VudDogQ291bnQsXG4gICAgY291bnRfdmFsdWVzOiBDb3VudFZhbHVlcyxcbiAgICBncm91cDogR3JvdXAsXG4gICAgbWF4OiBNYXgsXG4gICAgbWluOiBNaW4sXG4gICAgcXVhbnRpbGU6IFF1YW50aWxlLFxuICAgIHN0ZGRldjogU3RkZGV2LFxuICAgIHN0ZHZhcjogU3RkdmFyLFxuICAgIHN1bTogU3VtLFxuICAgIHRvcGs6IFRvcGssXG4gICAgYnk6IEJ5LFxuICAgIHdpdGhvdXQ6IFdpdGhvdXQsXG4gICAgYW5kOiBBbmQsXG4gICAgb3I6IE9yLFxuICAgIHVubGVzczogVW5sZXNzLFxuICAgIHN0YXJ0OiBTdGFydCxcbiAgICBlbmQ6IEVuZCxcbn07XG5cbmNvbnN0IGV4dGVuZElkZW50aWZpZXIgPSAodmFsdWUsIHN0YWNrKSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHR1YWxLZXl3b3JkVG9rZW5zW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IC0xO1xufTtcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBzcGVjX0lkZW50aWZpZXIgPSB7X19wcm90b19fOm51bGwsYWJzZW50X292ZXJfdGltZTozMDcsIGFic2VudDozMDksIGFiczozMTEsIGFjb3M6MzEzLCBhY29zaDozMTUsIGFzaW46MzE3LCBhc2luaDozMTksIGF0YW46MzIxLCBhdGFuaDozMjMsIGF2Z19vdmVyX3RpbWU6MzI1LCBjZWlsOjMyNywgY2hhbmdlczozMjksIGNsYW1wOjMzMSwgY2xhbXBfbWF4OjMzMywgY2xhbXBfbWluOjMzNSwgY29zOjMzNywgY29zaDozMzksIGNvdW50X292ZXJfdGltZTozNDEsIGRheXNfaW5fbW9udGg6MzQzLCBkYXlfb2ZfbW9udGg6MzQ1LCBkYXlfb2Zfd2VlazozNDcsIGRlZzozNDksIGRlbHRhOjM1MSwgZGVyaXY6MzUzLCBleHA6MzU1LCBmbG9vcjozNTcsIGhpc3RvZ3JhbV9xdWFudGlsZTozNTksIGhvbHRfd2ludGVyczozNjEsIGhvdXI6MzYzLCBpZGVsdGE6MzY1LCBpbmNyZWFzZTozNjcsIGlyYXRlOjM2OSwgbGFiZWxfcmVwbGFjZTozNzEsIGxhYmVsX2pvaW46MzczLCBsYXN0X292ZXJfdGltZTozNzUsIGxuOjM3NywgbG9nMTA6Mzc5LCBsb2cyOjM4MSwgbWF4X292ZXJfdGltZTozODMsIG1pbl9vdmVyX3RpbWU6Mzg1LCBtaW51dGU6Mzg3LCBtb250aDozODksIHBpOjM5MSwgcHJlZGljdF9saW5lYXI6MzkzLCBwcmVzZW50X292ZXJfdGltZTozOTUsIHF1YW50aWxlX292ZXJfdGltZTozOTcsIHJhZDozOTksIHJhdGU6NDAxLCByZXNldHM6NDAzLCByb3VuZDo0MDUsIHNjYWxhcjo0MDcsIHNnbjo0MDksIHNpbjo0MTEsIHNpbmg6NDEzLCBzb3J0OjQxNSwgc29ydF9kZXNjOjQxNywgc3FydDo0MTksIHN0ZGRldl9vdmVyX3RpbWU6NDIxLCBzdGR2YXJfb3Zlcl90aW1lOjQyMywgc3VtX292ZXJfdGltZTo0MjUsIHRhbjo0MjcsIHRhbmg6NDI5LCB0aW1lc3RhbXA6NDMxLCB0aW1lOjQzMywgdmVjdG9yOjQzNSwgeWVhcjo0Mzd9O1xuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxMyxcbiAgc3RhdGVzOiBcIjZbT1lRUE9PTyZ7UVBPT09PUU8nI0N7JyNDe08nUVFQTycjQ3pRJ11RUU9PT09RTycjRGUnI0RlTydXUVBPJyNEZE9PUU8nI0V9JyNFfU8oalFQTycjRlRPWVFQTycjRlBPWVFQTycjRlNPT1FPJyNGVicjRlZPLmZRU08nI0ZXTy5uUVFPJyNGVU9PUU8nI0ZVJyNGVU9PUU8nI0N5JyNDeU9PUU8nI0RmJyNEZk9PUU8nI0RoJyNEaE9PUU8nI0RpJyNEaU9PUU8nI0RqJyNEak9PUU8nI0RrJyNEa09PUU8nI0RsJyNEbE9PUU8nI0RtJyNEbU9PUU8nI0RuJyNEbk9PUU8nI0RvJyNEb09PUU8nI0RwJyNEcE9PUU8nI0RxJyNEcU9PUU8nI0RyJyNEck9PUU8nI0RzJyNEc09PUU8nI0R0JyNEdE9PUU8nI0R1JyNEdU9PUU8nI0R2JyNEdk9PUU8nI0R3JyNEd09PUU8nI0R4JyNEeE9PUU8nI0R5JyNEeU9PUU8nI0R6JyNEek9PUU8nI0R7JyNEe09PUU8nI0R8JyNEfE9PUU8nI0R9JyNEfU9PUU8nI0VPJyNFT09PUU8nI0VQJyNFUE9PUU8nI0VRJyNFUU9PUU8nI0VSJyNFUk9PUU8nI0VTJyNFU09PUU8nI0VUJyNFVE9PUU8nI0VVJyNFVU9PUU8nI0VWJyNFVk9PUU8nI0VXJyNFV09PUU8nI0VYJyNFWE9PUU8nI0VZJyNFWU9PUU8nI0VaJyNFWk9PUU8nI0VbJyNFW09PUU8nI0VdJyNFXU9PUU8nI0VeJyNFXk9PUU8nI0VfJyNFX09PUU8nI0VgJyNFYE9PUU8nI0VhJyNFYU9PUU8nI0ViJyNFYk9PUU8nI0VjJyNFY09PUU8nI0VkJyNFZE9PUU8nI0VlJyNFZU9PUU8nI0VmJyNFZk9PUU8nI0VnJyNFZ09PUU8nI0VoJyNFaE9PUU8nI0VpJyNFaU9PUU8nI0VqJyNFak9PUU8nI0VrJyNFa09PUU8nI0VsJyNFbE9PUU8nI0VtJyNFbU9PUU8nI0VuJyNFbk9PUU8nI0VvJyNFb09PUU8nI0VwJyNFcE9PUU8nI0VxJyNFcU9PUU8nI0VyJyNFck9PUU8nI0VzJyNFc09PUU8nI0V0JyNFdE9PUU8nI0V1JyNFdU9PUU8nI0V2JyNFdk9PUU8nI0V3JyNFd09PUU8nI0V4JyNFeE9PUU8nI0V5JyNFeU9PUU8nI0V6JyNFelFPUVBPT08wWFFQTycjQ3xPMF5RUE8nI0RSTydXUVBPLDU5Zk8wZVFRTyw1OWZPMlJRUE8sNTlvTzJSUVBPLDU5b08yUlFQTyw1OW9PMlJRUE8sNTlvTzJSUVBPLDU5b083fVFRTyw1O2dPOFNRUU8sNTtqTzhbUVBPLDU7eU9PUU8sNTpPLDU6T09PUU8sNTtpLDU7aU84c1FRTyw1O2tPOHpRUU8sNTtuTzpiUVBPJyNGWU86cFFQTyw1O3JPT1FPJyNGWCcjRlhPT1FPLDU7ciw1O3JPT1FPLDU7cCw1O3BPOnhRU08nI0N9T09RTyw1OWgsNTloTztRUVBPLDU5bU87WVFRTycjRFNPT1FPLDU5bSw1OW1PT1FPMUcvUTFHL1FPMFhRUE8nI0RXT0FWUVBPJyNEVk9BYVFQTycjRFZPWVFQTzFHL1pPWVFQTzFHL1pPWVFQTzFHL1pPWVFQTzFHL1pPWVFQTzFHL1pPQWtRU08xRzFST09RTzFHMVUxRzFVT0FzUVFPMUcxVU9BeFFQTycjRX1PT1FPJyNGYScjRmFPT1FPMUcxZTFHMWVPQlRRUE8xRzFlT09RTzFHMVYxRzFWT09RTycjRlonI0ZaT0JZUVBPLDU7dE9CX1FTTzFHMV5PT1FPMUcxXjFHMV5PT1FPJyNEUCcjRFBPQmdRUE8sNTlpT09RTycjRE8nI0RPT09RTyw1OWksNTlpT1lRUE8sNTluT09RTzFHL1gxRy9YT09RTyw1OXIsNTlyT0hfUVBPLDU5cU9IZlFQTyw1OXFPSX1RUU83KyR1T0pfUVFPNyskdU9Lc1FRTzcrJHVPTFpRUU83KyR1T01yUVFPNyskdU9PUU83KyZtNysmbU9OXVFRTzcrJnNPT1FPNysmcDcrJnBPTmVRUE83KydQT09RTzFHMWAxRzFgT09RTzFHMV8xRzFfT09RTzcrJng3KyZ4T05qUVNPMUcvVE9PUU8xRy9UMUcvVE9OclFRTzFHL1lPT1FPMUcvXTFHL11PTnxRUE8xRy9dT09RTzw8Sl88PEpfTyEmb1FQTzw8Sl9PT1FPPDxKazw8SmtPT1FPMUcvVTFHL1VPT1FPNyskbzcrJG9PT1FPNyskdzcrJHdPT1FPQU4/eUFOP3lcIixcbiAgc3RhdGVEYXRhOiBcIiEmdH5PJFpPU2tPU35PV1FPWFFPWVFPWlFPW1FPXVFPXlFPX1FPYFFPYVFPYlFPY1FPIVpaTyN0X08kV1ZPJFhWTyRbWE8kX2BPJGBhTyRhYk8kYmNPJGNkTyRkZU8kZWZPJGZnTyRnaE8kaGlPJGlqTyRqa08ka2xPJGxtTyRtbk8kbm9PJG9wTyRwcU8kcXJPJHJzTyRzdE8kdHVPJHV2TyR2d08kd3hPJHh5TyR5ek8kentPJHt8TyR8fU8kfSFPTyVPIVBPJVAhUU8lUSFSTyVSIVNPJVMhVE8lVCFVTyVVIVZPJVYhV08lVyFYTyVYIVlPJVkhWk8lWiFbTyVbIV1PJV0hXk8lXiFfTyVfIWBPJWAhYU8lYSFiTyViIWNPJWMhZE8lZCFlTyVlIWZPJWYhZ08lZyFoTyVoIWlPJWkhak8laiFrTyVrIWxPJWwhbU8lbSFuTyVuIW9PJW8hcE8lcCFxTyVxIXJPJXIhc08ldVdPJXZXTyV3Vk8leVtPfk8hWlpPfk9kIXVPZSF1TyRbIXZPfk9VI1BPViF5T2YhfE9nIX1PaCF8T3gheU97IXlPfCF5T30heU8hTyF6TyFQIXpPIVEhe08hUiF7TyFTIXtPIVQhe08hVSF7TyFWIXtPJFMjUU8lcyNPT35PJFcjU08kWCNTTyV3I1NPVyN3WFgjd1hZI3dYWiN3WFsjd1hdI3dYXiN3WF8jd1hgI3dYYSN3WGIjd1hjI3dYIVojd1gjdCN3WCRXI3dYJFgjd1gkWyN3WCRfI3dYJGAjd1gkYSN3WCRiI3dYJGMjd1gkZCN3WCRlI3dYJGYjd1gkZyN3WCRoI3dYJGkjd1gkaiN3WCRrI3dYJGwjd1gkbSN3WCRuI3dYJG8jd1gkcCN3WCRxI3dYJHIjd1gkcyN3WCR0I3dYJHUjd1gkdiN3WCR3I3dYJHgjd1gkeSN3WCR6I3dYJHsjd1gkfCN3WCR9I3dYJU8jd1glUCN3WCVRI3dYJVIjd1glUyN3WCVUI3dYJVUjd1glViN3WCVXI3dYJVgjd1glWSN3WCVaI3dYJVsjd1glXSN3WCVeI3dYJV8jd1glYCN3WCVhI3dYJWIjd1glYyN3WCVkI3dYJWUjd1glZiN3WCVnI3dYJWgjd1glaSN3WCVqI3dYJWsjd1glbCN3WCVtI3dYJW4jd1glbyN3WCVwI3dYJXEjd1glciN3WCV1I3dYJXYjd1gldyN3WCV5I3dYfk90I1ZPJXojWU9+TyV5W09VI3hYViN4WGYjeFhnI3hYaCN4WHgjeFh7I3hYfCN4WH0jeFghTyN4WCFQI3hYIVEjeFghUiN4WCFTI3hYIVQjeFghVSN4WCFWI3hYJFMjeFgkViN4WCVzI3hYJF4jeFgkXSN4WH5PJFsjW09+TyReI2BPflBZT2QhdU9lIXVPVW5hVm5hZm5hZ25haG5heG5he25hfG5hfW5hIU9uYSFQbmEhUW5hIVJuYSFTbmEhVG5hIVVuYSFWbmEkU25hJFZuYSVzbmEkXm5hJF1uYX5PUCNkT1EjYk9SI2JPV3lQWHlQWXlQWnlQW3lQXXlQXnlQX3lQYHlQYXlQYnlQY3lQIVp5UCN0eVAkV3lQJFh5UCRbeVAkX3lQJGB5UCRheVAkYnlQJGN5UCRkeVAkZXlQJGZ5UCRneVAkaHlQJGl5UCRqeVAka3lQJGx5UCRteVAkbnlQJG95UCRweVAkcXlQJHJ5UCRzeVAkdHlQJHV5UCR2eVAkd3lQJHh5UCR5eVAkenlQJHt5UCR8eVAkfXlQJU95UCVQeVAlUXlQJVJ5UCVTeVAlVHlQJVV5UCVWeVAlV3lQJVh5UCVZeVAlWnlQJVt5UCVdeVAlXnlQJV95UCVgeVAlYXlQJWJ5UCVjeVAlZHlQJWV5UCVmeVAlZ3lQJWh5UCVpeVAlanlQJWt5UCVseVAlbXlQJW55UCVveVAlcHlQJXF5UCVyeVAldXlQJXZ5UCV3eVAleXlQfk8jcCNqT35PIVAjbE8jcCNrT35PaSNuT2ojbk8kV1ZPJFhWTyV1I21PJXYjbU8ld1ZPfk8kXiNxT35QJ11PeCF5T1UjdmFWI3ZhZiN2YWcjdmFoI3ZheyN2YXwjdmF9I3ZhIU8jdmEhUCN2YSFRI3ZhIVIjdmEhUyN2YSFUI3ZhIVUjdmEhViN2YSRTI3ZhJFYjdmElcyN2YSReI3ZhJF0jdmF+TyFWI3JPJE8jck8kUCNyTyRRI3JPfk8kXSN0TyV6I3VPfk90I3ZPJF4jeU9+TyRdI3pPJF4je09+TyRddlgkXnZYflAnXU9XeVhYeVhZeVhaeVhbeVhdeVheeVhfeVhgeVhheVhieVhjeVghWnlYI3R5WCRXeVgkWHlYJFt5WCRfeVgkYHlYJGF5WCRieVgkY3lYJGR5WCRleVgkZnlYJGd5WCRoeVgkaXlYJGp5WCRreVgkbHlYJG15WCRueVgkb3lYJHB5WCRxeVgkcnlYJHN5WCR0eVgkdXlYJHZ5WCR3eVgkeHlYJHl5WCR6eVgke3lYJHx5WCR9eVglT3lYJVB5WCVReVglUnlYJVN5WCVUeVglVXlYJVZ5WCVXeVglWHlYJVl5WCVaeVglW3lYJV15WCVeeVglX3lYJWB5WCVheVglYnlYJWN5WCVkeVglZXlYJWZ5WCVneVglaHlYJWl5WCVqeVgla3lYJWx5WCVteVglbnlYJW95WCVweVglcXlYJXJ5WCV1eVgldnlYJXd5WCV5eVh+T1MjfU9UI31PflA7ZE9RI2JPUiNiT35QO2RPJXQkVU8leCRWT35PI3AkV09+TyRXI1NPJFgjU08ldyNTT35PJFskWE9+TyN0JFlPfk90I1ZPJXokW09+TyRdJF1PJF4kXk9+T1d5YVh5YVl5YVp5YVt5YV15YV55YV95YWB5YWF5YWJ5YWN5YSFaeWEjdHlhJFd5YSRYeWEkX3lhJGB5YSRheWEkYnlhJGN5YSRkeWEkZXlhJGZ5YSRneWEkaHlhJGl5YSRqeWEka3lhJGx5YSRteWEkbnlhJG95YSRweWEkcXlhJHJ5YSRzeWEkdHlhJHV5YSR2eWEkd3lhJHh5YSR5eWEkenlhJHt5YSR8eWEkfXlhJU95YSVQeWElUXlhJVJ5YSVTeWElVHlhJVV5YSVWeWElV3lhJVh5YSVZeWElWnlhJVt5YSVdeWElXnlhJV95YSVgeWElYXlhJWJ5YSVjeWElZHlhJWV5YSVmeWElZ3lhJWh5YSVpeWElanlhJWt5YSVseWElbXlhJW55YSVveWElcHlhJXF5YSVyeWEldXlhJXZ5YSV3eWEleXlhfk8kWyNbT35QQm9PUyRhT1QkYU8kW3lhflBCb094IXlPVXdxZndxZ3dxaHdxIU93cSFQd3EhUXdxIVJ3cSFTd3EhVHdxIVV3cSFWd3EkU3dxJFZ3cSVzd3EkXndxJF13cX5PVndxe3dxfHdxfXdxflBIc09WIXlPeyF5T3wheU99IXlPflBIc09WIXlPeCF5T3sheU98IXlPfSF5TyFPIXpPIVAhek9Vd3Fmd3Fnd3Fod3EkU3dxJFZ3cSVzd3EkXndxJF13cX5PIVF3cSFSd3EhU3dxIVR3cSFVd3EhVndxflBKb08hUSF7TyFSIXtPIVMhe08hVCF7TyFVIXtPIVYhe09+UEpvT1YheU9mIXxPaCF8T3gheU97IXlPfCF5T30heU8hTyF6TyFQIXpPIVEhe08hUiF7TyFTIXtPIVQhe08hVSF7TyFWIXtPfk9Vd3Fnd3EkU3dxJFZ3cSVzd3EkXndxJF13cX5QTHFPI3AkY08ldCRiT35PJF4kZE9+T3Qjdk8kXiRmT35PJF12aSRedml+UCddTyRbI1tPV3lpWHlpWXlpWnlpW3lpXXlpXnlpX3lpYHlpYXlpYnlpY3lpIVp5aSN0eWkkV3lpJFh5aSRfeWkkYHlpJGF5aSRieWkkY3lpJGR5aSRleWkkZnlpJGd5aSRoeWkkaXlpJGp5aSRreWkkbHlpJG15aSRueWkkb3lpJHB5aSRxeWkkcnlpJHN5aSR0eWkkdXlpJHZ5aSR3eWkkeHlpJHl5aSR6eWkke3lpJHx5aSR9eWklT3lpJVB5aSVReWklUnlpJVN5aSVUeWklVXlpJVZ5aSVXeWklWHlpJVl5aSVaeWklW3lpJV15aSVeeWklX3lpJWB5aSVheWklYnlpJWN5aSVkeWklZXlpJWZ5aSVneWklaHlpJWl5aSVqeWkla3lpJWx5aSVteWklbnlpJW95aSVweWklcXlpJXJ5aSV1eWkldnlpJXd5aSV5eWl+TyV0JGhPfk9cIixcbiAgZ290bzogXCIodSRVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAkViR1JVIlXyVlJXEldFAleiZUJHVQJlcmZ1BQUFBQUFBQUFBQJHUmcSZ9UCZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0mfSZ9Jn0kdVAnWiR1JHVQJHUkdSdqJHUndihWKGYoaShvUFBQJHVQKHJRU09RI1RYUSNVWVEjXyF2USRQI2VRJFEjZlEkUiNnUSRTI2hRJFQjaVIkXyN6ZV9PWFkhdiNlI2YjZyNoI2kjemVST1hZIXYjZSNmI2cjaCNpI3pRIXdSUiNhIXhRI10hdVEjfCNiUSRgI31SJGckYVIjdyNbUSN4I1tSJGUkXVEheFJRI1JVUiNhIXdSI14hdlEjZSF5USNmIXpRI2che1EjaCF8UiNpIX1ZI2MheSF6IXshfCF9UiRPI2RlVU9YWSF2I2UjZiNnI2gjaSN6ZVRPWFkhdiNlI2YjZyNoI2kjemRfT1hZIXYjZSNmI2cjaCNpI3pSI28jUWVZT1hZIXYjZSNmI2cjaCNpI3pkXU9YWSF2I2UjZiNnI2gjaSN6UiF0UGReT1hZIXYjZSNmI2cjaCNpI3pSI1pdUiNXW1EjWFtSJFojdFIjcyNWUiNwI1FcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBCb29sIElnbm9yaW5nIE9uIEdyb3VwTGVmdCBHcm91cFJpZ2h0IE9mZnNldCBBdGFuMiBBdmcgQm90dG9tayBDb3VudCBDb3VudFZhbHVlcyBHcm91cCBNYXggTWluIFF1YW50aWxlIFN0ZGRldiBTdGR2YXIgU3VtIFRvcGsgQnkgV2l0aG91dCBBbmQgT3IgVW5sZXNzIFN0YXJ0IEVuZCBMaW5lQ29tbWVudCBQcm9tUUwgRXhwciBBZ2dyZWdhdGVFeHByIEFnZ3JlZ2F0ZU9wIEFnZ3JlZ2F0ZU1vZGlmaWVyIEdyb3VwaW5nTGFiZWxzIEdyb3VwaW5nTGFiZWxMaXN0IEdyb3VwaW5nTGFiZWwgTGFiZWxOYW1lIEZ1bmN0aW9uQ2FsbEJvZHkgRnVuY3Rpb25DYWxsQXJncyBCaW5hcnlFeHByIFBvdyBCaW5Nb2RpZmllcnMgT25Pcklnbm9yaW5nIE11bCBEaXYgTW9kIEFkZCBTdWIgRXFsIEd0ZSBHdHIgTHRlIExzcyBOZXEgRnVuY3Rpb25DYWxsIEZ1bmN0aW9uSWRlbnRpZmllciBBYnNlbnRPdmVyVGltZSBJZGVudGlmaWVyIEFic2VudCBBYnMgQWNvcyBBY29zaCBBc2luIEFzaW5oIEF0YW4gQXRhbmggQXZnT3ZlclRpbWUgQ2VpbCBDaGFuZ2VzIENsYW1wIENsYW1wTWF4IENsYW1wTWluIENvcyBDb3NoIENvdW50T3ZlclRpbWUgRGF5c0luTW9udGggRGF5T2ZNb250aCBEYXlPZldlZWsgRGVnIERlbHRhIERlcml2IEV4cCBGbG9vciBIaXN0b2dyYW1RdWFudGlsZSBIb2x0V2ludGVycyBIb3VyIElkZWx0YSBJbmNyZWFzZSBJcmF0ZSBMYWJlbFJlcGxhY2UgTGFiZWxKb2luIExhc3RPdmVyVGltZSBMbiBMb2cxMCBMb2cyIE1heE92ZXJUaW1lIE1pbk92ZXJUaW1lIE1pbnV0ZSBNb250aCBQaSBQcmVkaWN0TGluZWFyIFByZXNlbnRPdmVyVGltZSBRdWFudGlsZU92ZXJUaW1lIFJhZCBSYXRlIFJlc2V0cyBSb3VuZCBTY2FsYXIgU2duIFNpbiBTaW5oIFNvcnQgU29ydERlc2MgU3FydCBTdGRkZXZPdmVyVGltZSBTdGR2YXJPdmVyVGltZSBTdW1PdmVyVGltZSBUYW4gVGFuaCBUaW1lc3RhbXAgVGltZSBWZWN0b3IgWWVhciBNYXRyaXhTZWxlY3RvciBEdXJhdGlvbiBOdW1iZXJMaXRlcmFsIE9mZnNldEV4cHIgUGFyZW5FeHByIFN0cmluZ0xpdGVyYWwgU3VicXVlcnlFeHByIFVuYXJ5RXhwciBVbmFyeU9wIFZlY3RvclNlbGVjdG9yIE1ldHJpY0lkZW50aWZpZXIgTGFiZWxNYXRjaGVycyBMYWJlbE1hdGNoTGlzdCBMYWJlbE1hdGNoZXIgTWF0Y2hPcCBFcWxTaW5nbGUgRXFsUmVnZXggTmVxUmVnZXggU3RlcEludmFyaWFudEV4cHIgQXQgQXRNb2RpZmllclByZXByb2Nlc3NvcnMgTWV0cmljTmFtZVwiLFxuICBtYXhUZXJtOiAyMjYsXG4gIHNraXBwZWROb2RlczogWzAsMjddLFxuICByZXBlYXROb2RlQ291bnQ6IDAsXG4gIHRva2VuRGF0YTogXCIxUn5Sd1heI2xwcSNscXIkYXJzJHRzdCVodXYlc3d4JXh4eSZneXombHp7JnF7fCZ2fH0mfX0hTydTIU8hUCdaIVAhUShaIVEhUihgIVIhWylXIVshXS1yIV4hXy5uIV8hYC57IWAhYS9iIWIhYy9vIWMhfS90IX0jTzBbI1AjUTBhI1EjUjBmI1IjUy90I1MjVDBrI1Qjby90I28jcDB3I3EjcjB8I3kjeiNsJGYkZyNsI0JZI0JaI2wkSVMkSV8jbCRJfCRKTyNsJEpUJEpVI2wkS1YkS1cjbCZGVSZGViNsfiNxWSRaflheI2xwcSNsI3kjeiNsJGYkZyNsI0JZI0JaI2wkSVMkSV8jbCRJfCRKTyNsJEpUJEpVI2wkS1YkS1cjbCZGVSZGViNsfiRkUSFfIWAkaiNyI3Mkb34kb08hVn5+JHRPJFF+fiR5VSN0fk9ZJHRaciR0cnMlXXMjTyR0I08jUCViI1B+JHR+JWJPI3R+fiVlUE9+JHR+JW1Ra35PWSVoWn4laH4leE99fn4lfVUjdH5PWSV4WncleHd4JV14I08leCNPI1AmYSNQfiV4fiZkUE9+JXh+JmxPJFt+fiZxTyRefn4mdk97flImfU8ldlAhT1F+J1NPJF1+UidaTyV1UCFQUVAnXlAhUSFbJ2FQJ2ZSJXdQIVEhWydhIWchaCdvI1gjWSdvUCdyUnt8J3t9IU8neyFRIVsoUlAoT1AhUSFbKFJQKFdQJXdQIVEhWyhSfihgT3x+UihlWiV3UCFPIVAnYSFRIVspVyFnIWgnbyNXI1gpeyNYI1knbyNbI10qZCNhI2IqeCNnI2grbCNrI2wrfSNsI20tVyNtI24saVIpXVkld1AhTyFQJ2EhUSFbKVchZyFoJ28jVyNYKXsjWCNZJ28jWyNdKmQjYSNiKngjZyNoK2wjayNsK30jbSNuLGlRKlFQI3BRIVEhWypUUSpXUyFRIVsqVCNbI10qZCNhI2IqeCNnI2grbFEqaVAjcFEhUSFbKmxRKm9SIVEhWypsI2EjYip4I2cjaCtsUSp9USNwUSFRIVsrVCNnI2grZ1ErV1IhUSFbK1QjYSNiK2EjZyNoK2xRK2RQI2cjaCtnUStsTyNwUVErcVAjcFEhUSFbK3RRK3dRIVEhWyt0I2EjYithUSxTUCNwUSFRIVssVlEsWVQhUSFbLFYjVyNYKXsjWyNdKmQjYSNiKngjZyNoK2xRLG5QI3BRIVEhWyxxUSx0VSFRIVsscSNXI1gpeyNbI10qZCNhI2IqeCNnI2grbCNrI2wrfVAtWlIhUSFbLWQhYyFpLWQjVCNaLWRQLWlSJXdQIVEhWy1kIWMhaS1kI1QjWi1kVi15VCV4UyFaUiFRIVsuWSFbIV0uWSFjIX0uWSNSI1MuWSNUI28uWVIuX1QhWlIhUSFbLlkhWyFdLlkhYyF9LlkjUiNTLlkjVCNvLll+LnNQIVV+IV8hYC52fi57TyFUfn4vUVEkT1AhXyFgL1cjciNzL11RL11PIVFRfi9iTyRQfn4vZ1AhU34hXyFgL2p+L29PIVJ+fi90TyRTflYve1QhWlJ0UyFRIVsvdCFbIV0uWSFjIX0vdCNSI1MvdCNUI28vdH4wYU8lc35+MGZPJXR+fjBrT3h+fjBuUk8jUzBrI1MjVCVdI1R+MGt+MHxPJXl+fjFSTyV6flwiLFxuICB0b2tlbml6ZXJzOiBbMCwgMSwgMl0sXG4gIHRvcFJ1bGVzOiB7XCJQcm9tUUxcIjpbMCwyOF0sXCJNZXRyaWNOYW1lXCI6WzEsMTQ0XX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDU3LCBnZXQ6ICh2YWx1ZSwgc3RhY2spID0+IChzcGVjaWFsaXplSWRlbnRpZmllcih2YWx1ZSkgPDwgMSl9LHt0ZXJtOiA1NywgZ2V0OiAodmFsdWUsIHN0YWNrKSA9PiAoZXh0ZW5kSWRlbnRpZmllcih2YWx1ZSkgPDwgMSkgfCAxfSx7dGVybTogNTcsIGdldDogdmFsdWUgPT4gc3BlY19JZGVudGlmaWVyW3ZhbHVlXSB8fCAtMX1dLFxuICB0b2tlblByZWM6IDBcbn0pO1xuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBcbiAgaW5mJDEgPSAxNDYsXG4gIG5hbiQxID0gMTQ3LFxuICBCb29sJDEgPSAxLFxuICBJZ25vcmluZyQxID0gMixcbiAgT24kMSA9IDMsXG4gIEdyb3VwTGVmdCQxID0gNCxcbiAgR3JvdXBSaWdodCQxID0gNSxcbiAgT2Zmc2V0JDEgPSA2LFxuICBBdGFuMiQxID0gNyxcbiAgQXZnJDEgPSA4LFxuICBCb3R0b21rJDEgPSA5LFxuICBDb3VudCQxID0gMTAsXG4gIENvdW50VmFsdWVzJDEgPSAxMSxcbiAgR3JvdXAkMSA9IDEyLFxuICBNYXgkMSA9IDEzLFxuICBNaW4kMSA9IDE0LFxuICBRdWFudGlsZSQxID0gMTUsXG4gIFN0ZGRldiQxID0gMTYsXG4gIFN0ZHZhciQxID0gMTcsXG4gIFN1bSQxID0gMTgsXG4gIFRvcGskMSA9IDE5LFxuICBCeSQxID0gMjAsXG4gIFdpdGhvdXQkMSA9IDIxLFxuICBBbmQkMSA9IDIyLFxuICBPciQxID0gMjMsXG4gIFVubGVzcyQxID0gMjQsXG4gIFN0YXJ0JDEgPSAyNSxcbiAgRW5kJDEgPSAyNixcbiAgTGluZUNvbW1lbnQgPSAyNyxcbiAgUHJvbVFMID0gMjgsXG4gIEV4cHIgPSAyOSxcbiAgQWdncmVnYXRlRXhwciA9IDMwLFxuICBBZ2dyZWdhdGVPcCA9IDMxLFxuICBBZ2dyZWdhdGVNb2RpZmllciA9IDMyLFxuICBHcm91cGluZ0xhYmVscyA9IDMzLFxuICBHcm91cGluZ0xhYmVsTGlzdCA9IDM0LFxuICBHcm91cGluZ0xhYmVsID0gMzUsXG4gIExhYmVsTmFtZSA9IDM2LFxuICBGdW5jdGlvbkNhbGxCb2R5ID0gMzcsXG4gIEZ1bmN0aW9uQ2FsbEFyZ3MgPSAzOCxcbiAgQmluYXJ5RXhwciA9IDM5LFxuICBQb3cgPSA0MCxcbiAgQmluTW9kaWZpZXJzID0gNDEsXG4gIE9uT3JJZ25vcmluZyA9IDQyLFxuICBNdWwgPSA0MyxcbiAgRGl2ID0gNDQsXG4gIE1vZCA9IDQ1LFxuICBBZGQgPSA0NixcbiAgU3ViID0gNDcsXG4gIEVxbCA9IDQ4LFxuICBHdGUgPSA0OSxcbiAgR3RyID0gNTAsXG4gIEx0ZSA9IDUxLFxuICBMc3MgPSA1MixcbiAgTmVxID0gNTMsXG4gIEZ1bmN0aW9uQ2FsbCA9IDU0LFxuICBGdW5jdGlvbklkZW50aWZpZXIgPSA1NSxcbiAgQWJzZW50T3ZlclRpbWUgPSA1NixcbiAgSWRlbnRpZmllciA9IDU3LFxuICBBYnNlbnQgPSA1OCxcbiAgQWJzID0gNTksXG4gIEFjb3MgPSA2MCxcbiAgQWNvc2ggPSA2MSxcbiAgQXNpbiA9IDYyLFxuICBBc2luaCA9IDYzLFxuICBBdGFuID0gNjQsXG4gIEF0YW5oID0gNjUsXG4gIEF2Z092ZXJUaW1lID0gNjYsXG4gIENlaWwgPSA2NyxcbiAgQ2hhbmdlcyA9IDY4LFxuICBDbGFtcCA9IDY5LFxuICBDbGFtcE1heCA9IDcwLFxuICBDbGFtcE1pbiA9IDcxLFxuICBDb3MgPSA3MixcbiAgQ29zaCA9IDczLFxuICBDb3VudE92ZXJUaW1lID0gNzQsXG4gIERheXNJbk1vbnRoID0gNzUsXG4gIERheU9mTW9udGggPSA3NixcbiAgRGF5T2ZXZWVrID0gNzcsXG4gIERlZyA9IDc4LFxuICBEZWx0YSA9IDc5LFxuICBEZXJpdiA9IDgwLFxuICBFeHAgPSA4MSxcbiAgRmxvb3IgPSA4MixcbiAgSGlzdG9ncmFtUXVhbnRpbGUgPSA4MyxcbiAgSG9sdFdpbnRlcnMgPSA4NCxcbiAgSG91ciA9IDg1LFxuICBJZGVsdGEgPSA4NixcbiAgSW5jcmVhc2UgPSA4NyxcbiAgSXJhdGUgPSA4OCxcbiAgTGFiZWxSZXBsYWNlID0gODksXG4gIExhYmVsSm9pbiA9IDkwLFxuICBMYXN0T3ZlclRpbWUgPSA5MSxcbiAgTG4gPSA5MixcbiAgTG9nMTAgPSA5MyxcbiAgTG9nMiA9IDk0LFxuICBNYXhPdmVyVGltZSA9IDk1LFxuICBNaW5PdmVyVGltZSA9IDk2LFxuICBNaW51dGUgPSA5NyxcbiAgTW9udGggPSA5OCxcbiAgUGkgPSA5OSxcbiAgUHJlZGljdExpbmVhciA9IDEwMCxcbiAgUHJlc2VudE92ZXJUaW1lID0gMTAxLFxuICBRdWFudGlsZU92ZXJUaW1lID0gMTAyLFxuICBSYWQgPSAxMDMsXG4gIFJhdGUgPSAxMDQsXG4gIFJlc2V0cyA9IDEwNSxcbiAgUm91bmQgPSAxMDYsXG4gIFNjYWxhciA9IDEwNyxcbiAgU2duID0gMTA4LFxuICBTaW4gPSAxMDksXG4gIFNpbmggPSAxMTAsXG4gIFNvcnQgPSAxMTEsXG4gIFNvcnREZXNjID0gMTEyLFxuICBTcXJ0ID0gMTEzLFxuICBTdGRkZXZPdmVyVGltZSA9IDExNCxcbiAgU3RkdmFyT3ZlclRpbWUgPSAxMTUsXG4gIFN1bU92ZXJUaW1lID0gMTE2LFxuICBUYW4gPSAxMTcsXG4gIFRhbmggPSAxMTgsXG4gIFRpbWVzdGFtcCA9IDExOSxcbiAgVGltZSA9IDEyMCxcbiAgVmVjdG9yID0gMTIxLFxuICBZZWFyID0gMTIyLFxuICBNYXRyaXhTZWxlY3RvciA9IDEyMyxcbiAgRHVyYXRpb24gPSAxMjQsXG4gIE51bWJlckxpdGVyYWwgPSAxMjUsXG4gIE9mZnNldEV4cHIgPSAxMjYsXG4gIFBhcmVuRXhwciA9IDEyNyxcbiAgU3RyaW5nTGl0ZXJhbCA9IDEyOCxcbiAgU3VicXVlcnlFeHByID0gMTI5LFxuICBVbmFyeUV4cHIgPSAxMzAsXG4gIFVuYXJ5T3AgPSAxMzEsXG4gIFZlY3RvclNlbGVjdG9yID0gMTMyLFxuICBNZXRyaWNJZGVudGlmaWVyID0gMTMzLFxuICBMYWJlbE1hdGNoZXJzID0gMTM0LFxuICBMYWJlbE1hdGNoTGlzdCA9IDEzNSxcbiAgTGFiZWxNYXRjaGVyID0gMTM2LFxuICBNYXRjaE9wID0gMTM3LFxuICBFcWxTaW5nbGUgPSAxMzgsXG4gIEVxbFJlZ2V4ID0gMTM5LFxuICBOZXFSZWdleCA9IDE0MCxcbiAgU3RlcEludmFyaWFudEV4cHIgPSAxNDEsXG4gIEF0ID0gMTQyLFxuICBBdE1vZGlmaWVyUHJlcHJvY2Vzc29ycyA9IDE0MyxcbiAgTWV0cmljTmFtZSA9IDE0NDtcblxuZXhwb3J0IHsgQWJzLCBBYnNlbnQsIEFic2VudE92ZXJUaW1lLCBBY29zLCBBY29zaCwgQWRkLCBBZ2dyZWdhdGVFeHByLCBBZ2dyZWdhdGVNb2RpZmllciwgQWdncmVnYXRlT3AsIEFuZCQxIGFzIEFuZCwgQXNpbiwgQXNpbmgsIEF0LCBBdE1vZGlmaWVyUHJlcHJvY2Vzc29ycywgQXRhbiwgQXRhbjIkMSBhcyBBdGFuMiwgQXRhbmgsIEF2ZyQxIGFzIEF2ZywgQXZnT3ZlclRpbWUsIEJpbk1vZGlmaWVycywgQmluYXJ5RXhwciwgQm9vbCQxIGFzIEJvb2wsIEJvdHRvbWskMSBhcyBCb3R0b21rLCBCeSQxIGFzIEJ5LCBDZWlsLCBDaGFuZ2VzLCBDbGFtcCwgQ2xhbXBNYXgsIENsYW1wTWluLCBDb3MsIENvc2gsIENvdW50JDEgYXMgQ291bnQsIENvdW50T3ZlclRpbWUsIENvdW50VmFsdWVzJDEgYXMgQ291bnRWYWx1ZXMsIERheU9mTW9udGgsIERheU9mV2VlaywgRGF5c0luTW9udGgsIERlZywgRGVsdGEsIERlcml2LCBEaXYsIER1cmF0aW9uLCBFbmQkMSBhcyBFbmQsIEVxbCwgRXFsUmVnZXgsIEVxbFNpbmdsZSwgRXhwLCBFeHByLCBGbG9vciwgRnVuY3Rpb25DYWxsLCBGdW5jdGlvbkNhbGxBcmdzLCBGdW5jdGlvbkNhbGxCb2R5LCBGdW5jdGlvbklkZW50aWZpZXIsIEdyb3VwJDEgYXMgR3JvdXAsIEdyb3VwTGVmdCQxIGFzIEdyb3VwTGVmdCwgR3JvdXBSaWdodCQxIGFzIEdyb3VwUmlnaHQsIEdyb3VwaW5nTGFiZWwsIEdyb3VwaW5nTGFiZWxMaXN0LCBHcm91cGluZ0xhYmVscywgR3RlLCBHdHIsIEhpc3RvZ3JhbVF1YW50aWxlLCBIb2x0V2ludGVycywgSG91ciwgSWRlbHRhLCBJZGVudGlmaWVyLCBJZ25vcmluZyQxIGFzIElnbm9yaW5nLCBJbmNyZWFzZSwgSXJhdGUsIExhYmVsSm9pbiwgTGFiZWxNYXRjaExpc3QsIExhYmVsTWF0Y2hlciwgTGFiZWxNYXRjaGVycywgTGFiZWxOYW1lLCBMYWJlbFJlcGxhY2UsIExhc3RPdmVyVGltZSwgTGluZUNvbW1lbnQsIExuLCBMb2cxMCwgTG9nMiwgTHNzLCBMdGUsIE1hdGNoT3AsIE1hdHJpeFNlbGVjdG9yLCBNYXgkMSBhcyBNYXgsIE1heE92ZXJUaW1lLCBNZXRyaWNJZGVudGlmaWVyLCBNZXRyaWNOYW1lLCBNaW4kMSBhcyBNaW4sIE1pbk92ZXJUaW1lLCBNaW51dGUsIE1vZCwgTW9udGgsIE11bCwgTmVxLCBOZXFSZWdleCwgTnVtYmVyTGl0ZXJhbCwgT2Zmc2V0JDEgYXMgT2Zmc2V0LCBPZmZzZXRFeHByLCBPbiQxIGFzIE9uLCBPbk9ySWdub3JpbmcsIE9yJDEgYXMgT3IsIFBhcmVuRXhwciwgUGksIFBvdywgUHJlZGljdExpbmVhciwgUHJlc2VudE92ZXJUaW1lLCBQcm9tUUwsIFF1YW50aWxlJDEgYXMgUXVhbnRpbGUsIFF1YW50aWxlT3ZlclRpbWUsIFJhZCwgUmF0ZSwgUmVzZXRzLCBSb3VuZCwgU2NhbGFyLCBTZ24sIFNpbiwgU2luaCwgU29ydCwgU29ydERlc2MsIFNxcnQsIFN0YXJ0JDEgYXMgU3RhcnQsIFN0ZGRldiQxIGFzIFN0ZGRldiwgU3RkZGV2T3ZlclRpbWUsIFN0ZHZhciQxIGFzIFN0ZHZhciwgU3RkdmFyT3ZlclRpbWUsIFN0ZXBJbnZhcmlhbnRFeHByLCBTdHJpbmdMaXRlcmFsLCBTdWIsIFN1YnF1ZXJ5RXhwciwgU3VtJDEgYXMgU3VtLCBTdW1PdmVyVGltZSwgVGFuLCBUYW5oLCBUaW1lLCBUaW1lc3RhbXAsIFRvcGskMSBhcyBUb3BrLCBVbmFyeUV4cHIsIFVuYXJ5T3AsIFVubGVzcyQxIGFzIFVubGVzcywgVmVjdG9yLCBWZWN0b3JTZWxlY3RvciwgV2l0aG91dCQxIGFzIFdpdGhvdXQsIFllYXIsIGluZiQxIGFzIGluZiwgbmFuJDEgYXMgbmFuLCBwYXJzZXIgfTtcbiIsIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZSAoMTAyNCkuXG5jb25zdCBEZWZhdWx0QnVmZmVyTGVuZ3RoID0gMTAyNDtcbmxldCBuZXh0UHJvcElEID0gMDtcbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuLy8vIEVhY2ggW25vZGUgdHlwZV0oI2NvbW1vbi5Ob2RlVHlwZSkgb3IgW2luZGl2aWR1YWwgdHJlZV0oI2NvbW1vbi5UcmVlKVxuLy8vIGNhbiBoYXZlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBpdCBpbiBwcm9wcy4gSW5zdGFuY2VzIG9mIHRoaXNcbi8vLyBjbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbmNsYXNzIE5vZGVQcm9wIHtcbiAgICAvLy8gQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0UHJvcElEKys7XG4gICAgICAgIHRoaXMucGVyTm9kZSA9ICEhY29uZmlnLnBlck5vZGU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBjb25maWcuZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8gVGhpcyBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGhcbiAgICAvLy8gW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgLy8vIFtgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLlBhcnNlckNvbmZpZy5wcm9wcykgdG8gY29tcHV0ZVxuICAgIC8vLyBwcm9wIHZhbHVlcyBmb3IgZWFjaCBub2RlIHR5cGUgaW4gdGhlIHNldC4gVGFrZXMgYSBbbWF0Y2hcbiAgICAvLy8gb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8vIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIC8vLyBpdCBkb2VzLlxuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIFByb3AgdGhhdCBpcyB1c2VkIHRvIGRlc2NyaWJlIG1hdGNoaW5nIGRlbGltaXRlcnMuIEZvciBvcGVuaW5nXG4vLy8gZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbi8vLyBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHdoZW4gZGVjbGFyaW5nIHRoaXMgcHJvcCBpbiBhIGdyYW1tYXIpXG4vLy8gZm9yIHRoZSBub2RlIHR5cGVzIG9mIGNsb3NpbmcgZGVsaW1pdGVycyB0aGF0IG1hdGNoIGl0LlxuTm9kZVByb3AuY2xvc2VkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG4vLy8gYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbi8vLyBvZiB0eXBlcyBvZiBtYXRjaGluZyBvcGVuaW5nIGRlbGltaXRlcnMuXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBVc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG4vLy8gdHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuLy8vIGBcIkV4cHJlc3Npb25cImAgZ3JvdXApLlxuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vLy8gVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG4vLy8gdGhhdCB0aGUgbm9kZSB3YXMgcGFyc2VkIGluLCBpZiBhbnkuIFVzZWQgdG8gbGltaXQgcmV1c2Ugb2Zcbi8vLyBjb250ZXh0dWFsIG5vZGVzLlxuTm9kZVByb3AuY29udGV4dEhhc2ggPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIFRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbi8vLyBsb29rZWQgYWhlYWQgZm9yIGFueSBvZiB0aGUgdG9rZW5zIGluc2lkZSB0aGUgbm9kZS4gKFRoZSBMUlxuLy8vIHBhcnNlciBvbmx5IHN0b3JlcyB0aGlzIHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gMjUsIGZvclxuLy8vIGVmZmljaWVuY3kgcmVhc29ucy4pXG5Ob2RlUHJvcC5sb29rQWhlYWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIFRoaXMgcGVyLW5vZGUgcHJvcCBpcyB1c2VkIHRvIHJlcGxhY2UgYSBnaXZlbiBub2RlLCBvciBwYXJ0IG9mIGFcbi8vLyBub2RlLCB3aXRoIGFub3RoZXIgdHJlZS4gVGhpcyBpcyB1c2VmdWwgdG8gaW5jbHVkZSB0cmVlcyBmcm9tXG4vLy8gZGlmZmVyZW50IGxhbmd1YWdlcy5cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLy8vIEEgbW91bnRlZCB0cmVlLCB3aGljaCBjYW4gYmUgW3N0b3JlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBvblxuLy8vIGEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG4vLy8gcmVwcmVzZW50ZWQgYnkgYW5vdGhlciB0cmVlLlxuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgaW5uZXIgdHJlZS5cbiAgICB0cmVlLCBcbiAgICAvLy8gSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgLy8vIGJlIGluY2x1ZGVkIGluIHRoZSByZWd1bGFyIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGl0cyBob3N0XG4gICAgLy8vIG5vZGUpLiBJZiBub3QsIG9ubHkgdGhlIGdpdmVuIHJhbmdlcyBhcmUgY29uc2lkZXJlZCB0byBiZVxuICAgIC8vLyBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIC8vLyBhIHdheSB0aGF0IGlzbid0IHN0cmljdGx5IGhpZXJhcmNoaWNhbC4gU3VjaCBtb3VudGVkIHRyZWVzIGFyZVxuICAgIC8vLyBvbmx5IGVudGVyZWQgYnkgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKVxuICAgIC8vLyBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgb3ZlcmxheSwgXG4gICAgLy8vIFRoZSBwYXJzZXIgdXNlZCB0byBjcmVhdGUgdGhpcyBzdWJ0cmVlLlxuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vLyBFYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5hbWUgb2YgdGhlIG5vZGUgdHlwZS4gTm90IG5lY2Vzc2FyaWx5IHVuaXF1ZSwgYnV0IGlmIHRoZVxuICAgIC8vLyBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIC8vLyBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICAvLy8gcm9sZS5cbiAgICBuYW1lLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcHJvcHMsIFxuICAgIC8vLyBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIC8vLyB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgaWQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBUb3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIFNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFRvcCAqLykgPiAwOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBTa2lwcGVkICovKSA+IDA7IH1cbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIEVycm9yICovKSA+IDA7IH1cbiAgICAvLy8gV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBBbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIC8vLyBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogQW5vbnltb3VzICovKTtcbi8vLyBBIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG4vLy8gZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbi8vLyB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8vLyBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICAvLy8gdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjcmVhdGVkIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuLy8vIFtgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbi8vLyBtb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWUge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcm9vdGVkIGF0IHRoaXMgdHJlZS4gV2hlblxuICAgIC8vLyBgcG9zYCBpcyBnaXZlbiwgdGhlIGN1cnNvciBpcyBbbW92ZWRdKCNjb21tb24uVHJlZUN1cnNvci5tb3ZlVG8pXG4gICAgLy8vIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS5cbiAgICBjdXJzb3IocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSAocG9zICE9IG51bGwgJiYgQ2FjaGVkTm9kZS5nZXQodGhpcykpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubW92ZVRvKHBvcywgc2lkZSk7XG4gICAgICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgdGhhdCwgdW5saWtlIHJlZ3VsYXJcbiAgICAvLy8gY3Vyc29ycywgZG9lc24ndCBza2lwIHRocm91Z2hcbiAgICAvLy8gW2Fub255bW91c10oI2NvbW1vbi5Ob2RlVHlwZS5pc0Fub255bW91cykgbm9kZXMgYW5kIGRvZXNuJ3RcbiAgICAvLy8gYXV0b21hdGljYWxseSBlbnRlciBtb3VudGVkIG5vZGVzLlxuICAgIGZ1bGxDdXJzb3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIDEgLyogRnVsbCAqLyk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIC8vLyB0cmVlLlxuICAgIGdldCB0b3BOb2RlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHRoaXMsIDAsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vLyBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgLy8vIHBvc2l0aW9uLiBJZiAxLCBpdCdsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBzdGFydCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIC8vLyBmcm9tIGJvdGggc2lkZXMuXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgLy8vIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgICAvLy8gcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgLy8vICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICAvLy8gdGhlIGhvc3QgdHJlZXMpLlxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvLy8gSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgLy8vIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICAvLy8gcnVubmluZyBvdmVyIHN1Y2ggYSBub2RlJ3MgY2hpbGRyZW4sIGFuZCBgbGVhdmVgIChpZiBnaXZlbikgd2hlblxuICAgIC8vLyBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIC8vLyBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgIGl0ZXJhdGUoc3BlYykge1xuICAgICAgICBsZXQgeyBlbnRlciwgbGVhdmUsIGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoIH0gPSBzcGVjO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IoKSwgZ2V0ID0gKCkgPT4gYy5ub2RlOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjLmZyb20gPD0gdG8gJiYgYy50byA+PSBmcm9tICYmIChjLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYy50eXBlLCBjLmZyb20sIGMudG8sIGdldCk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gYy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmIChjLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghYy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXG4gICAgLy8vIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5vZGUncyBbcGVyLW5vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3AucGVyTm9kZSkgaW4gYVxuICAgIC8vLyBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIGNvbnN0cnVjdG9yLlxuICAgIGdldCBwcm9wVmFsdWVzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbK2lkLCB0aGlzLnByb3BzW2lkXV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIC8vLyB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgLy8vIFtgTm9kZVR5cGUubm9uZWBdKCNjb21tb24uTm9kZVR5cGVebm9uZSkuXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vLyBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgICAvLy8gb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8vLyBUaGUgZW1wdHkgdHJlZVxuVHJlZS5lbXB0eSA9IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgMCk7XG5jbGFzcyBGbGF0QnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIGdldCBwb3MoKSB7IHJldHVybiB0aGlzLmluZGV4OyB9XG4gICAgbmV4dCgpIHsgdGhpcy5pbmRleCAtPSA0OyB9XG4gICAgZm9yaygpIHsgcmV0dXJuIG5ldyBGbGF0QnVmZmVyQ3Vyc29yKHRoaXMuYnVmZmVyLCB0aGlzLmluZGV4KTsgfVxufVxuLy8vIFRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbi8vLyBub2RlLiBJbiBzdWNoIGEgYnVmZmVyLCBub2RlcyBhcmUgc3RvcmVkIGluIHByZWZpeCBvcmRlciAocGFyZW50c1xuLy8vIGJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG4vLy8gY2hpbGRyZW4gYmVsb25nIHRvIGl0KVxuY2xhc3MgVHJlZUJ1ZmZlciB7XG4gICAgLy8vIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgYnVmZmVyJ3MgY29udGVudC5cbiAgICBidWZmZXIsIFxuICAgIC8vLyBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgIGxlbmd0aCwgXG4gICAgLy8vIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiLFwiKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCB0byAtIGZyb20sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIEJlZm9yZSAqLzogcmV0dXJuIGZyb20gPCBwb3M7XG4gICAgICAgIGNhc2UgLTEgLyogQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIEF0T3JBZnRlciAqLzogcmV0dXJuIGZyb20gPD0gcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDIgLyogQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIERvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgdHJ1ZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIF9mcm9tLCBcbiAgICAvLyBJbmRleCBpbiBwYXJlbnQgbm9kZSwgc2V0IHRvIC0xIGlmIHRoZSBub2RlIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBfcGFyZW50Lm5vZGUgKG92ZXJsYXkpXG4gICAgaW5kZXgsIF9wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5fZnJvbSA9IF9mcm9tO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgfVxuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5ub2RlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMubm9kZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuX2Zyb207IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLl9mcm9tICsgdGhpcy5ub2RlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5ub2RlLCBlID0gZGlyID4gMCA/IGNoaWxkcmVuLmxlbmd0aCA6IC0xOyBpICE9IGU7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltpXSwgc3RhcnQgPSBwb3NpdGlvbnNbaV0gKyBwYXJlbnQuX2Zyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIDIgLyogTm9FbnRlckJ1ZmZlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgMSAvKiBGdWxsICovKSAmJiBuZXh0LnByb3BzICYmIChtb3VudGVkID0gbmV4dC5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZShtb3VudGVkLnRyZWUsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBuZXcgVHJlZU5vZGUobmV4dCwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobW9kZSAmIDEgLyogRnVsbCAqLykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCAwLCA0IC8qIERvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLm5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBBZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMubm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyA9IHRydWUsIGJ1ZmZlcnMgPSB0cnVlKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAob3ZlcmxheXMgJiYgKG1vdW50ZWQgPSB0aGlzLm5vZGUucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBidWZmZXJzID8gMCA6IDIgLyogTm9FbnRlckJ1ZmZlciAqLyk7XG4gICAgfVxuICAgIG5leHRTaWduaWZpY2FudFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHZhbCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh2YWwudHlwZS5pc0Fub255bW91cyAmJiB2YWwuX3BhcmVudClcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fcGFyZW50O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCArIDEsIDEsIDAsIDQgLyogRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjdXJzb3IoKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcykgeyByZXR1cm4gZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUodGhpcywgcG9zKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5ub2RlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IsIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIHdoaWxlICghY3VyLnR5cGUuaXMoYmVmb3JlKSlcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChhZnRlciAhPSBudWxsICYmIGN1ci50eXBlLmlzKGFmdGVyKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChjdXIudHlwZS5pcyh0eXBlKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZnRlciA9PSBudWxsID8gcmVzdWx0IDogW107XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIEFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBCZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cywgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFidWZmZXJzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgc2lkZSA+IDAgPyAxIDogLTEsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICB9XG4gICAgZXh0ZXJuYWxTaWJsaW5nKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKHRoaXMuY29udGV4dC5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIERvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBEb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgY3Vyc29yKCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcyk7IH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXSwgdG8gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG59XG4vLy8gQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG4vLy8gYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNvbnN0cnVjdG9yKG5vZGUsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5ub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSwgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuYnVmZmVyLnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihpbmRleCk7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgLy8vIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgICBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIDAsIDQgLyogRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBEb250Q2FyZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdCBjaGlsZCB0aGF0IGVuZHMgYWZ0ZXIgYHBvc2AuXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIDIgLyogQWZ0ZXIgKi8pOyB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIGxhc3QgY2hpbGQgdGhhdCBzdGFydHMgYmVmb3JlIGBwb3NgLlxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCBwb3MsIC0yIC8qIEJlZm9yZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgLy8vIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgLy8vIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgLy8vIHNldCB0byBmYWxzZS5cbiAgICBlbnRlcihwb3MsIHNpZGUsIG92ZXJsYXlzID0gdHJ1ZSwgYnVmZmVycyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBvdmVybGF5cyAmJiAhKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLyksIGJ1ZmZlcnMpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnMgPyB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLl90cmVlLl9wYXJlbnQgOiB0aGlzLl90cmVlLnBhcmVudCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKHRoaXMuc3RhY2sucG9wKCkpO1xuICAgICAgICBsZXQgcGFyZW50ID0gKHRoaXMubW9kZSAmIDEgLyogRnVsbCAqLykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmluZGV4IDwgMCA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIERvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBEb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgbmV4dFNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoMSk7IH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5ub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQubm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1vZGUgJiAxIC8qIEZ1bGwgKi8pIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCAhY2hpbGQudHlwZS5pc0Fub255bW91cyB8fCBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogRG9udENhcmUgKi8pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpYmxpbmcoZGlyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0TGFzdE5vZGUoZGlyKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgLy8vIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcl8oTkxSKSlcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUubm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDAsIGxvb2tBaGVhZCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgbGV0IGxvb2tBaGVhZEF0U3RhcnQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHdoaWxlIChzaXplIDwgMCkge1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzaXplID09IC0xIC8qIFJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIExvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnJlY29nbml6ZWQgcmVjb3JkIHNpemU6ICR7c2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2lkXSwgbm9kZSwgYnVmZmVyO1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBzdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICBpZiAoZW5kIC0gc3RhcnQgPD0gbWF4QnVmZmVyTGVuZ3RoICYmIChidWZmZXIgPSBmaW5kQnVmZmVyU2l6ZShjdXJzb3IucG9zIC0gbWluUG9zLCBpblJlcGVhdCkpKSB7XG4gICAgICAgICAgICAvLyBTbWFsbCBlbm91Z2ggZm9yIGEgYnVmZmVyLCBhbmQgbm8gcmV1c2VkIG5vZGVzIGluc2lkZVxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNpemUgLSBidWZmZXIuc2tpcCk7XG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIGJ1ZmZlci5zaXplLCBpbmRleCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyLnN0YXJ0LCBkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICBub2RlID0gbmV3IFRyZWVCdWZmZXIoZGF0YSwgZW5kIC0gYnVmZmVyLnN0YXJ0LCBub2RlU2V0KTtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gYnVmZmVyLnN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE1ha2UgaXQgYSBub2RlXG4gICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIHNpemU7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBsb2NhbEluUmVwZWF0ID0gaWQgPj0gbWluUmVwZWF0VHlwZSA/IGlkIDogLTE7XG4gICAgICAgICAgICBsZXQgbGFzdEdyb3VwID0gMCwgbGFzdEVuZCA9IGVuZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBjdXJzb3IuaWQgPT0gbG9jYWxJblJlcGVhdCAmJiBjdXJzb3Iuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZW5kIDw9IGxhc3RFbmQgLSBtYXhCdWZmZXJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBjdXJzb3IuZW5kLCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSAwLCBsYXN0SSA9IGNoaWxkcmVuLmxlbmd0aCAtIDEsIGxhc3QsIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICBpZiAobGFzdEkgPj0gMCAmJiAobGFzdCA9IGNoaWxkcmVuW2xhc3RJXSkgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0SSAmJiBsYXN0LnR5cGUgPT0gdHlwZSAmJiBsYXN0Lmxlbmd0aCA9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsb29rQWhlYWRQcm9wID0gbGFzdC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHBvc2l0aW9uc1tsYXN0SV0gKyBsYXN0Lmxlbmd0aCArIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmVwZWF0TGVhZihjaGlsZHJlbiwgcG9zaXRpb25zLCBiYXNlLCBpLCBmcm9tLCB0bywgdHlwZSwgbG9va0FoZWFkKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bykpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkID0gMCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHRIYXNoKSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5jb250ZXh0SGFzaCwgY29udGV4dEhhc2hdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiAyNSkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AubG9va0FoZWFkLCBsb29rQWhlYWRdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1ZmZlclNpemUobWF4U2l6ZSwgaW5SZXBlYXQpIHtcbiAgICAgICAgLy8gU2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgdG8gZmluZCBwcmV2aW91cyBzaWJsaW5ncyB0aGF0IGZpdFxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGNhbid0IGJlIHN0b3JlZCBpbiBhIGJ1ZmZlcikuXG4gICAgICAgIC8vIElmIGBpblJlcGVhdGAgaXMgPiAtMSwgaWdub3JlIG5vZGUgYm91bmRhcmllcyBvZiB0aGF0IHR5cGUgZm9yXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIChgbWF4U2l6ZWApIG9yIGJlZm9yZSBzdWNoIGEgbm9kZS5cbiAgICAgICAgbGV0IGZvcmsgPSBjdXJzb3IuZm9yaygpO1xuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHNpemU6IDAsIHN0YXJ0OiAwLCBza2lwOiAwIH07XG4gICAgICAgIHNjYW46IGZvciAobGV0IG1pblBvcyA9IGZvcmsucG9zIC0gbWF4U2l6ZTsgZm9yay5wb3MgPiBtaW5Qb3M7KSB7XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemU7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIG5lc3RlZCByZXBlYXQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBkb24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKGZvcmsuaWQgPT0gaW5SZXBlYXQgJiYgbm9kZVNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBDb250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgZGF0YS5idWZmZXJTdGFydCB8fCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5jb25zdCBub2RlU2l6ZUNhY2hlID0gbmV3IFdlYWtNYXA7XG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xuICAgIGlmICghYmFsYW5jZVR5cGUuaXNBbm9ueW1vdXMgfHwgbm9kZSBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgbm9kZS50eXBlICE9IGJhbGFuY2VUeXBlKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9IGJhbGFuY2VUeXBlIHx8ICEoY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVTaXplQ2FjaGUuc2V0KG5vZGUsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShcbi8vIFRoZSB0eXBlIHRoZSBiYWxhbmNlZCB0cmVlJ3MgaW5uZXIgbm9kZXMuXG5iYWxhbmNlVHlwZSwgXG4vLyBUaGUgZGlyZWN0IGNoaWxkcmVuIGFuZCB0aGVpciBwb3NpdGlvbnNcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxuLy8gVGhlIGluZGV4IHJhbmdlIGluIGNoaWxkcmVuL3Bvc2l0aW9ucyB0byB1c2VcbmZyb20sIHRvLCBcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cbnN0YXJ0LCBcbi8vIExlbmd0aCBvZiB0aGUgb3V0ZXIgbm9kZVxubGVuZ3RoLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSB0b3Agbm9kZSBvZiB0aGUgYmFsYW5jZWQgdHJlZVxubWtUb3AsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RyZWUpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgdG90YWwgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICBsZXQgbWF4Q2hpbGQgPSBNYXRoLmNlaWwoKHRvdGFsICogMS41KSAvIDggLyogQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuXG4vLy8gVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxuLy8vIHBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xuLy8vIHRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbi8vLyB0byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbi8vLyBwYXJzZXMuIFVzZSB0aGUgc3RhdGljXG4vLy8gW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xuLy8vIHVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LlxuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vLyBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgLy8vIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgLy8vIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICBmcm9tLCBcbiAgICAvLy8gVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgIHRvLCBcbiAgICAvLy8gVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgIHRyZWUsIFxuICAgIC8vLyBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICAvLy8gdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICAvLy8gZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIC8vLyBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIFN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIC8vLyBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIC8vLyBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8vIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogU3RhcnQgKi8pID4gMDsgfVxuICAgIC8vLyBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgLy8vIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIEVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbi8vL1xuLy8vIFRoZSBuZXN0aW5nIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGN1cnNvciB0byBwcm92aWRlIGNvbnRleHQgZm9yIGFcbi8vLyBub2RlLCBidXQgX3Nob3VsZCBub3RfIG1vdmUgdGhhdCBjdXJzb3IsIG9ubHkgaW5zcGVjdCBpdHNcbi8vLyBwcm9wZXJ0aWVzIGFuZCBvcHRpb25hbGx5IGFjY2VzcyBpdHNcbi8vLyBbbm9kZSBvYmplY3RdKCNjb21tb24uVHJlZUN1cnNvci5ub2RlKS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCAxIC8qIEZ1bGwgKi8pO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgfHwgY3Vyc29yLmZyb20gPCB0aGlzLnN0b3BwZWRBdDspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50Q3Vyc29yLmhhc05vZGUoY3Vyc29yKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG92ZXJsYXkubW91bnRzLmZpbmQobSA9PiBtLmZyYWcuZnJvbSA8PSBjdXJzb3IuZnJvbSAmJiBtLmZyYWcudG8gPj0gY3Vyc29yLnRvICYmIG0ubW91bnQub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbWF0Y2gubW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gci5mcm9tICsgbWF0Y2gucG9zLCB0byA9IHIudG8gKyBtYXRjaC5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gY3Vyc29yLmZyb20gJiYgdG8gPD0gY3Vyc29yLnRvICYmICFvdmVybGF5LnJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDwgdG8gJiYgci50byA+IGZyb20pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3ZlcmVkICYmIChpc0NvdmVyZWQgPSBjaGVja0NvdmVyKGNvdmVyZWQucmFuZ2VzLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKSkpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGlzQ292ZXJlZCAhPSAyIC8qIEZ1bGwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLnR5cGUuaXNBbm9ueW1vdXMgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gJiYgKG5lc3QgPSB0aGlzLm5lc3QoY3Vyc29yLCB0aGlzLmlucHV0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRNb3VudHMgPSBmcmFnbWVudEN1cnNvci5maW5kTW91bnRzKGN1cnNvci5mcm9tLCBuZXN0LnBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0Lm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHwgW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIucHVzaChuZXcgSW5uZXJQYXJzZShuZXN0LnBhcnNlciwgbmVzdC5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvbGRNb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG5lc3Qub3ZlcmxheSA/IG5lc3Qub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gY3Vyc29yLmZyb20sIHIudG8gLSBjdXJzb3IuZnJvbSkpIDogbnVsbCwgY3Vyc29yLnRyZWUsIHJhbmdlcykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkudGFyZ2V0LCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIEZ1bGwgKi8gOiAxIC8qIFBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV0sIHRvID0gYnVmLmJ1ZmZlcltlbmRJIC0gMl07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSwgdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgd2hpbGUgKGJbaSArIDJdICsgb2ZmIDw9IG5vZGUuZnJvbSlcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgaSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xuICAgICAgICBsZXQgaXNUYXJnZXQgPSBmcm9tICsgb2ZmID09IG5vZGUuZnJvbSAmJiB0byArIG9mZiA9PSBub2RlLnRvICYmIGJbaV0gPT0gbm9kZS50eXBlLmlkO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGlzVGFyZ2V0ID8gbm9kZS50b1RyZWUoKSA6IHNwbGl0KGkgKyA0LCBiW2kgKyAzXSwgYnVmLnNldC50eXBlc1tiW2ldXSwgZnJvbSwgdG8gLSBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYltpICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcbiAgICAgICAgY3Vyc29yLmNoaWxkQWZ0ZXIobm9kZS5mcm9tKTtcbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmZ1bGxDdXJzb3IoKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBmYWxzZSwgZmFsc2UpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MsIGZyYWcudG8gPD0gZW5kKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IGNoYW5nZXNbaV0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KGZyb20sIHRvLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBzdGFydFBvcywgZnJhZy50byA8PSBlbmRQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBQYXJzZXIsIFRyZWUsIFRyZWVCdWZmZXIsIFRyZWVDdXJzb3IsIFRyZWVGcmFnbWVudCwgcGFyc2VNaXhlZCB9O1xuIiwiaW1wb3J0IHsgUGFyc2VyLCBOb2RlU2V0LCBOb2RlVHlwZSwgRGVmYXVsdEJ1ZmZlckxlbmd0aCwgTm9kZVByb3AsIFRyZWUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLy8vIEEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xuLy8vIHBhcnNpbmcgcHJvZ3Jlc3MuIFRoZXkgYWxzbyBwcm92aWRlIHNvbWUgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xuLy8vIHRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG4vLy8gYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuY2xhc3MgU3RhY2sge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHBhcnNlIHRoYXQgdGhpcyBzdGFjayBpcyBwYXJ0IG9mIEBpbnRlcm5hbFxuICAgIHAsIFxuICAgIC8vLyBIb2xkcyBzdGF0ZSwgaW5wdXQgcG9zLCBidWZmZXIgaW5kZXggdHJpcGxldHMgZm9yIGFsbCBidXQgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSBAaW50ZXJuYWxcbiAgICBzdGFjaywgXG4gICAgLy8vIFRoZSBjdXJyZW50IHBhcnNlIHN0YXRlIEBpbnRlcm5hbFxuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWR1Y2VQb3MsIFxuICAgIC8vLyBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgIHBvcywgXG4gICAgLy8vIFRoZSBkeW5hbWljIHNjb3JlIG9mIHRoZSBzdGFjaywgaW5jbHVkaW5nIGR5bmFtaWMgcHJlY2VkZW5jZVxuICAgIC8vLyBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNjb3JlLCBcbiAgICAvLyBUaGUgb3V0cHV0IGJ1ZmZlci4gSG9sZHMgKHR5cGUsIHN0YXJ0LCBlbmQsIHNpemUpIHF1YWRzXG4gICAgLy8gcmVwcmVzZW50aW5nIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciwgd2hlcmUgYHNpemVgIGlzXG4gICAgLy8gYW1vdW50IG9mIGJ1ZmZlciBhcnJheSBlbnRyaWVzIGNvdmVyZWQgYnkgdGhpcyBub2RlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvLy8gQGludGVybmFsXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGN1ckNvbnRleHQsIFxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBjdXJDb250ZXh0O1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YWNrLmZpbHRlcigoXywgaSkgPT4gaSAlIDMgPT0gMCkuY29uY2F0KHRoaXMuc3RhdGUpfV1AJHt0aGlzLnBvc30ke3RoaXMuc2NvcmUgPyBcIiFcIiArIHRoaXMuc2NvcmUgOiBcIlwifWA7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLy8gVGhlIHN0YWNrJ3MgY3VycmVudCBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyKSB2YWx1ZSwgaWZcbiAgICAvLy8gYW55LiBJdHMgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgY29udGV4dCB0cmFja2VyJ3MgdHlwZVxuICAgIC8vLyBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICAvLy8gdHJhY2tlci5cbiAgICBnZXQgY29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCA/IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0IDogbnVsbDsgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcHVzaFN0YXRlKHN0YXRlLCBzdGFydCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgc3RhcnQsIHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSByZWR1Y2UgYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFja1tiYXNlIC0gMl07XG4gICAgICAgIGxldCBidWZmZXJCYXNlID0gdGhpcy5zdGFja1tiYXNlIC0gMV0sIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIFJlcGVhdEZsYWcgKi8pKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gcGFyc2VyLnN0YXRlRmxhZyh0aGlzLnN0YXRlLCAxIC8qIFNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBTdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0b3JlTm9kZSh0ZXJtLCBzdGFydCwgZW5kLCBzaXplID0gNCwgaXNSZWR1Y2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGVybSA9PSAwIC8qIEVyciAqLykgeyAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBFcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDAgJiYgdGhpcy5idWZmZXJbaW5kZXggLSAyXSA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGhpcy5idWZmZXJbaW5kZXggLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAxXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gM107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gdGhpcy5idWZmZXJbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRlcm07XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDJdID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYSBzaGlmdCBhY3Rpb25cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAoYWN0aW9uICYgMTMxMDcyIC8qIEdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYWN0aW9uICYgMjYyMTQ0IC8qIFN0YXlGbGFnICovKSA9PSAwKSB7IC8vIFJlZ3VsYXIgc2hpZnRcbiAgICAgICAgICAgIGxldCBuZXh0U3RhdGUgPSBhY3Rpb24sIHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgICAgICBpZiAobmV4dEVuZCA+IHRoaXMucG9zIHx8IG5leHQgPD0gcGFyc2VyLm1heE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTa2lwcGVkICovKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSBuZXh0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5leHQsIHN0YXJ0LCBuZXh0RW5kLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gU2hpZnQtYW5kLXN0YXksIHdoaWNoIG1lYW5zIHRoaXMgaXMgYSBza2lwcGVkIHRva2VuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IG5leHRFbmQ7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dChuZXh0LCBzdGFydCk7XG4gICAgICAgICAgICBpZiAobmV4dCA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChuZXh0LCBzdGFydCwgbmV4dEVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGFwcGx5KGFjdGlvbiwgbmV4dCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLylcbiAgICAgICAgICAgIHRoaXMucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc2hpZnQoYWN0aW9uLCBuZXh0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHVzZU5vZGUodmFsdWUsIG5leHQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5wLnJldXNlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMucC5yZXVzZWRbaW5kZXhdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnAucmV1c2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IHN0YXJ0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShuZXh0LCBzdGFydCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5kZXgsIHN0YXJ0LCB0aGlzLnJlZHVjZVBvcywgLTEgLyogc2l6ZSA9PSAtMSBtZWFucyB0aGlzIGlzIGEgcmV1c2VkIHZhbHVlICovKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZXVzZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdmFsdWUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSB2YWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IHRoZSBzdGFjay4gRHVlIHRvIHRoZSBidWZmZXIgc2hhcmluZyBhbmQgdGhlIGZhY3RcbiAgICAvLyB0aGF0IGB0aGlzLnN0YWNrYCB0ZW5kcyB0byBzdGF5IHF1aXRlIHNoYWxsb3csIHRoaXMgaXNuJ3QgdmVyeVxuICAgIC8vIGV4cGVuc2l2ZS5cbiAgICAvLy8gQGludGVybmFsXG4gICAgc3BsaXQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBsZXQgb2ZmID0gcGFyZW50LmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIHRvcCBvZiB0aGUgYnVmZmVyIChhZnRlciB0aGlzLnBvcykgbWF5IGJlIG11dGF0ZWRcbiAgICAgICAgLy8gdG8gcmVvcmRlciByZWR1Y3Rpb25zIGFuZCBza2lwcGVkIHRva2VucywgYW5kIHNoYXJlZCBidWZmZXJzXG4gICAgICAgIC8vIHNob3VsZCBiZSBpbW11dGFibGUsIHRoaXMgY29waWVzIGFueSBvdXRzdGFuZGluZyBza2lwcGVkIHRva2Vuc1xuICAgICAgICAvLyB0byB0aGUgbmV3IGJ1ZmZlciwgYW5kIHB1dHMgdGhlIGJhc2UgcG9pbnRlciBiZWZvcmUgdGhlbS5cbiAgICAgICAgd2hpbGUgKG9mZiA+IDAgJiYgcGFyZW50LmJ1ZmZlcltvZmYgLSAyXSA+IHBhcmVudC5yZWR1Y2VQb3MpXG4gICAgICAgICAgICBvZmYgLT0gNDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHBhcmVudC5idWZmZXIuc2xpY2Uob2ZmKSwgYmFzZSA9IHBhcmVudC5idWZmZXJCYXNlICsgb2ZmO1xuICAgICAgICAvLyBNYWtlIHN1cmUgcGFyZW50IHBvaW50cyB0byBhbiBhY3R1YWwgcGFyZW50IHdpdGggY29udGVudCwgaWYgdGhlcmUgaXMgc3VjaCBhIHBhcmVudC5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBiYXNlID09IHBhcmVudC5idWZmZXJCYXNlKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFjayh0aGlzLnAsIHRoaXMuc3RhY2suc2xpY2UoKSwgdGhpcy5zdGF0ZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucG9zLCB0aGlzLnNjb3JlLCBidWZmZXIsIGJhc2UsIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIHBhcmVudCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgICAvLy8gQGludGVybmFsXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIG5leHRFbmQsIGlzTm9kZSA/IDggOiA0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJlZHVjZVBvcyA9IG5leHRFbmQ7XG4gICAgICAgIHRoaXMuc2NvcmUgLT0gMTkwIC8qIERlbGV0ZSAqLztcbiAgICB9XG4gICAgLy8vIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIC8vLyBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICAvLy8gZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgICAvLy8gZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgIGNhblNoaWZ0KHRlcm0pIHtcbiAgICAgICAgZm9yIChsZXQgc2ltID0gbmV3IFNpbXVsYXRlZFN0YWNrKHRoaXMpOzspIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLnAucGFyc2VyLnN0YXRlU2xvdChzaW0uc3RhdGUsIDQgLyogRGVmYXVsdFJlZHVjZSAqLykgfHwgdGhpcy5wLnBhcnNlci5oYXNBY3Rpb24oc2ltLnN0YXRlLCB0ZXJtKTtcbiAgICAgICAgICAgIGlmICgoYWN0aW9uICYgNjU1MzYgLyogUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzaW0ucmVkdWNlKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgdXAgdG8gUmVjb3Zlci5NYXhOZXh0IHJlY292ZXJ5IGFjdGlvbnMgdGhhdCBjb25jZXB0dWFsbHlcbiAgICAvLyBpbnNlcnRzIHNvbWUgbWlzc2luZyB0b2tlbiBvciBydWxlLlxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIE1heEluc2VydFN0YWNrRGVwdGggKi8pXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBuZXh0U3RhdGVzID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgICAgICBpZiAobmV4dFN0YXRlcy5sZW5ndGggPiA0IC8qIE1heE5leHQgKi8gPDwgMSB8fCB0aGlzLnN0YWNrLmxlbmd0aCA+PSAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgYmVzdC5sZW5ndGggPCA0IC8qIE1heE5leHQgKi8gPDwgMSAmJiBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IG5leHRTdGF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3Quc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdC5wdXNoKG5leHRTdGF0ZXNbaV0sIHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRTdGF0ZXMgPSBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgNCAvKiBNYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2suc3RvcmVOb2RlKDAgLyogRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoU3RhdGUocywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2suc2hpZnRDb250ZXh0KG5leHRTdGF0ZXNbaV0sIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnNjb3JlIC09IDIwMCAvKiBJbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlUmVkdWNlKCkge1xuICAgICAgICBsZXQgcmVkdWNlID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNSAvKiBGb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIFJlZHVjZUZsYWcgKi8pID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogUmVkdWNlRGVwdGhTaGlmdCAqLywgdGVybSA9IHJlZHVjZSAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLztcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIGRlcHRoICogMztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPCAwIHx8IHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgLT0gMTAwIC8qIFJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogQWNjZXB0aW5nICovKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIEVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIENoZWNrIHdoZXRoZXIgdGhpcyBzdGF0ZSBoYXMgbm8gZnVydGhlciBhY3Rpb25zIChhc3N1bWVkIHRvIGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlXG4gICAgLy8vIHRvcCBzdGF0ZSwgc2luY2UgYW55IG90aGVyIHN0YXRlcyBtdXN0IGJlIGFibGUgdG8gY29udGludWVcbiAgICAvLy8gc29tZWhvdykuIEBpbnRlcm5hbFxuICAgIGdldCBkZWFkRW5kKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGF0YVtwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDEgLyogQWN0aW9ucyAqLyldID09IDY1NTM1IC8qIEVuZCAqLyAmJlxuICAgICAgICAgICAgIXBhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKTtcbiAgICB9XG4gICAgLy8vIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICAvLy8gd2hlbiB0aGlzLnN0YWNrLmxlbmd0aCA9PSAzIChzdGF0ZSBpcyBkaXJlY3RseSBiZWxvdyB0aGUgdG9wXG4gICAgLy8vIHN0YXRlKS4gQGludGVybmFsXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNhbWVTdGF0ZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBvdGhlci5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBvdGhlci5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrW2ldICE9IG90aGVyLnN0YWNrW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgZ2V0IHBhcnNlcigpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXI7IH1cbiAgICAvLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gZGlhbGVjdCAoYnkgbnVtZXJpYyBJRCwgYXMgZXhwb3J0ZWQgZnJvbVxuICAgIC8vLyB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICBkaWFsZWN0RW5hYmxlZChkaWFsZWN0SUQpIHsgcmV0dXJuIHRoaXMucC5wYXJzZXIuZGlhbGVjdC5mbGFnc1tkaWFsZWN0SURdOyB9XG4gICAgc2hpZnRDb250ZXh0KHRlcm0sIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc2hpZnQodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIHJlZHVjZUNvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5yZWR1Y2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHRlcm0sIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQoc3RhcnQpKSk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5yZWR1Y2VQb3MsIC0zKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGVtaXRMb29rQWhlYWQoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwIHx8IHRoaXMuYnVmZmVyW2xhc3RdICE9IC00KVxuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmxvb2tBaGVhZCwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCAtNCk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCAhPSB0aGlzLmN1ckNvbnRleHQuY29udGV4dCkge1xuICAgICAgICAgICAgbGV0IG5ld0N4ID0gbmV3IFN0YWNrQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlciwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAobmV3Q3guaGFzaCAhPSB0aGlzLmN1ckNvbnRleHQuaGFzaClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBuZXdDeDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2V0TG9va0FoZWFkKGxvb2tBaGVhZCkge1xuICAgICAgICBpZiAobG9va0FoZWFkID4gdGhpcy5sb29rQWhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgICAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxudmFyIFJlY292ZXI7XG4oZnVuY3Rpb24gKFJlY292ZXIpIHtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJJbnNlcnRcIl0gPSAyMDBdID0gXCJJbnNlcnRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJEZWxldGVcIl0gPSAxOTBdID0gXCJEZWxldGVcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJSZWR1Y2VcIl0gPSAxMDBdID0gXCJSZWR1Y2VcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhOZXh0XCJdID0gNF0gPSBcIk1heE5leHRcIjtcbiAgICBSZWNvdmVyW1JlY292ZXJbXCJNYXhJbnNlcnRTdGFja0RlcHRoXCJdID0gMzAwXSA9IFwiTWF4SW5zZXJ0U3RhY2tEZXB0aFwiO1xuICAgIFJlY292ZXJbUmVjb3ZlcltcIkRhbXBlbkluc2VydFN0YWNrRGVwdGhcIl0gPSAxMjBdID0gXCJEYW1wZW5JbnNlcnRTdGFja0RlcHRoXCI7XG59KShSZWNvdmVyIHx8IChSZWNvdmVyID0ge30pKTtcbi8vIFVzZWQgdG8gY2hlYXBseSBydW4gc29tZSByZWR1Y3Rpb25zIHRvIHNjYW4gYWhlYWQgd2l0aG91dCBtdXRhdGluZ1xuLy8gYW4gZW50aXJlIHN0YWNrXG5jbGFzcyBTaW11bGF0ZWRTdGFjayB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFydC5zdGFjaztcbiAgICAgICAgdGhpcy5iYXNlID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgbGV0IHRlcm0gPSBhY3Rpb24gJiA2NTUzNSAvKiBWYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIFJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrLCBwb3MgPSBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBwb3MsIHBvcyAtIHN0YWNrLmJ1ZmZlckJhc2UpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG5jbGFzcyBDYWNoZWRUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IC0xO1xuICAgICAgICB0aGlzLmVuZCA9IC0xO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIHRoaXMubG9va0FoZWFkID0gMDtcbiAgICAgICAgdGhpcy5tYXNrID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gMDtcbiAgICB9XG59XG5jb25zdCBudWxsVG9rZW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4vLy8gW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbi8vLyB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlLiBJdCBwcmVzZW50cyB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2Zcbi8vLyBjaGFyYWN0ZXJzLCB0cmFja2luZyBsb29rYWhlYWQgYW5kIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZlxuLy8vIFtyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbmNsYXNzIElucHV0U3RyZWFtIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGlucHV0LCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIC8vLyBCYWNrdXAgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVuazIgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rMlBvcyA9IDA7XG4gICAgICAgIC8vLyBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5leHQgY29kZSB1bml0IGluIHRoZSBpbnB1dCwgb3IgLTFcbiAgICAgICAgLy8vIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8vLyBAaW50ZXJuYWxcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICByZXNvbHZlT2Zmc2V0KG9mZnNldCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yYW5nZSwgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWy0taW5kZXhdO1xuICAgICAgICAgICAgcG9zIC09IHJhbmdlLmZyb20gLSBuZXh0LnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhc3NvYyA8IDAgPyBwb3MgPiByYW5nZS50byA6IHBvcyA+PSByYW5nZS50bykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucmFuZ2VzWysraW5kZXhdO1xuICAgICAgICAgICAgcG9zICs9IG5leHQuZnJvbSAtIHJhbmdlLnRvO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8vLyBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgICAvLy8gYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIC8vLyBvbi5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IGxvb2tpbmcgYXJvdW5kIGR1cmluZyB0b2tlbml6aW5nIGNyZWF0ZXMgZGVwZW5kZW5jaWVzXG4gICAgLy8vIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgLy8vIGVmZmVjdGl2ZW5lc3MgaW5jcmVtZW50YWwgcGFyc2luZ+KAlHdoZW4gbG9va2luZyBmb3J3YXJk4oCUb3IgZXZlblxuICAgIC8vLyBjYXVzZSBpbnZhbGlkIHJlcGFyc2VzIHdoZW4gbG9va2luZyBiYWNrd2FyZCBtb3JlIHRoYW4gMjUgY29kZVxuICAgIC8vLyB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICBwZWVrKG9mZnNldCkge1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5jaHVua09mZiArIG9mZnNldCwgcG9zLCByZXN1bHQ7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZU9mZnNldChvZmZzZXQsIDEpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcG9zID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdChwb3MgLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHRoaXMucmFuZ2VJbmRleCwgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS50byA8PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZXNbKytpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5jaHVuazJQb3MgPSBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgKyB0aGlzLmNodW5rMi5sZW5ndGggPiByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rMi5zbGljZSgwLCByYW5nZS50byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLy8gQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgICAvLy8gY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIC8vLyB0aGUgc3RyZWFtIHBvc2l0aW9uKSB0byBjaGFuZ2UgdGhhdC5cbiAgICBhY2NlcHRUb2tlbih0b2tlbiwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZW5kID0gZW5kT2Zmc2V0ID8gdGhpcy5yZXNvbHZlT2Zmc2V0KGVuZE9mZnNldCwgLTEpIDogdGhpcy5wb3M7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPCB0aGlzLnRva2VuLnN0YXJ0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUb2tlbiBlbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgZ2V0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiB0aGlzLnBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBjaHVuaywgY2h1bmtQb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gdGhpcy5jaHVuazI7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5jaHVuazJQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSBjaHVua1BvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSB0aGlzLnBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICBsZXQgbmV4dENodW5rID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLnBvcyk7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgKyBuZXh0Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IGVuZCA+IHRoaXMucmFuZ2UudG8gPyBuZXh0Q2h1bmsuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IG5leHRDaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua09mZiA+PSB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgLy8vIHRoZSBuZXcgdmFsdWUgb2YgW2BuZXh0YF0oI2xyLklucHV0U3RyZWFtLm5leHQpLlxuICAgIGFkdmFuY2UobiA9IDEpIHtcbiAgICAgICAgdGhpcy5jaHVua09mZiArPSBuO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgKyBuID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlSW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICBuIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmFuZ2UuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgc2V0RG9uZSgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlc2V0KHBvcywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0b2tlbi5zdGFydCA9IHBvcztcbiAgICAgICAgICAgIHRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLmV4dGVuZGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMucmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbLS10aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA+PSB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICBpZiAocG9zID49IHRoaXMuY2h1bmtQb3MgJiYgcG9zIDwgdGhpcy5jaHVua1BvcyArIHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IHBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEBpbnRlcm5hbFxuY2xhc3MgVG9rZW5Hcm91cCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgaWQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB0b2tlbihpbnB1dCwgc3RhY2spIHsgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCB0aGlzLmlkKTsgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vLy8gYEBleHRlcm5hbCB0b2tlbnNgIGRlY2xhcmF0aW9ucyBpbiB0aGUgZ3JhbW1hciBzaG91bGQgcmVzb2x2ZSB0b1xuLy8vIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG5jbGFzcyBFeHRlcm5hbFRva2VuaXplciB7XG4gICAgLy8vIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIC8vLyBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgLy8vIHJlY29nbml6ZXMgYXQgdGhlIHN0cmVhbSdzIHBvc2l0aW9uLCBhbmQgY2FsbHNcbiAgICAvLy8gW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICAgIC8vLyBvbmUuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGB0b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCkge1xuICAgIGxldCBzdGF0ZSA9IDAsIGdyb3VwTWFzayA9IDEgPDwgZ3JvdXAsIHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IGRpYWxlY3QgfSA9IHBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fCBwYXJzZXIub3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuYWNjZXB0VG9rZW4odGVybSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAobGV0IG5leHQgPSBpbnB1dC5uZXh0LCBsb3cgPSAwLCBoaWdoID0gZGF0YVtzdGF0ZSArIDJdOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49IHRvKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8vIFNlZSBsZXplci1nZW5lcmF0b3Ivc3JjL2VuY29kZS50cyBmb3IgY29tbWVudHMgYWJvdXQgdGhlIGVuY29kaW5nXG4vLyB1c2VkIGhlcmVcbmZ1bmN0aW9uIGRlY29kZUFycmF5KGlucHV0LCBUeXBlID0gVWludDE2QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICBsZXQgYXJyYXkgPSBudWxsO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIG91dCA9IDA7IHBvcyA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKSwgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gMTI2IC8qIEJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEdhcDIgKi8pXG4gICAgICAgICAgICAgICAgbmV4dC0tO1xuICAgICAgICAgICAgaWYgKG5leHQgPj0gMzQgLyogR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogQmFzZSAqLykge1xuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDQ2IC8qIEJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLy8gRklYTUUgZmluZCBzb21lIHdheSB0byByZWR1Y2UgcmVjb3Zlcnkgd29yayBkb25lIHdoZW4gdGhlIGlucHV0XG4vLyBkb2Vzbid0IG1hdGNoIHRoZSBncmFtbWFyIGF0IGFsbC5cbi8vIEVudmlyb25tZW50IHZhcmlhYmxlIHVzZWQgdG8gY29udHJvbCBjb25zb2xlIG91dHB1dFxuY29uc3QgdmVyYm9zZSA9IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgL1xcYnBhcnNlXFxiLy50ZXN0KHByb2Nlc3MuZW52LkxPRyk7XG5sZXQgc3RhY2tJRHMgPSBudWxsO1xudmFyIFNhZmV0eTtcbihmdW5jdGlvbiAoU2FmZXR5KSB7XG4gICAgU2FmZXR5W1NhZmV0eVtcIk1hcmdpblwiXSA9IDI1XSA9IFwiTWFyZ2luXCI7XG59KShTYWZldHkgfHwgKFNhZmV0eSA9IHt9KSk7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5mdWxsQ3Vyc29yKCk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIE1hcmdpbiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRyZWUubGVuZ3RoLCBNYXRoLm1heChjdXJzb3IuZnJvbSArIDEsIHBvcyArIDI1IC8qIE1hcmdpbiAqLykpO1xuICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lkZSA8IDAgPyAwIDogdHJlZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cywgbm9kZVNldCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbm9kZVNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FmZUZyb20gPSAtMTtcbiAgICAgICAgdGhpcy5zYWZlVG8gPSAtMTtcbiAgICAgICAgdGhpcy50cmVlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICBsZXQgZnIgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5pID09IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA/IG51bGwgOiB0aGlzLmZyYWdtZW50c1t0aGlzLmkrK107XG4gICAgICAgIGlmIChmcikge1xuICAgICAgICAgICAgdGhpcy5zYWZlRnJvbSA9IGZyLm9wZW5TdGFydCA/IGN1dEF0KGZyLnRyZWUsIGZyLmZyb20gKyBmci5vZmZzZXQsIDEpIC0gZnIub2Zmc2V0IDogZnIuZnJvbTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvID0gZnIub3BlbkVuZCA/IGN1dEF0KGZyLnRyZWUsIGZyLnRvICsgZnIub2Zmc2V0LCAtMSkgLSBmci5vZmZzZXQgOiBmci50bztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRyZWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKGZyLnRyZWUpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKC1mci5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCB0aGlzLm5leHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLnNhZmVUbyA8PSBwb3MpXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnRyZWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAobGFzdCA8IDApIHsgLy8gRW5kIG9mIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudHJlZXNbbGFzdF0sIGluZGV4ID0gdGhpcy5pbmRleFtsYXN0XTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0b3AuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0YXJ0W2xhc3RdICsgdG9wLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCB0aGlzLnNhZmVGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kIDw9IHRoaXMuc2FmZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gbmV4dC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb2tBaGVhZCB8fCBlbmQgKyBsb29rQWhlYWQgPCB0aGlzLmZyYWdtZW50LnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBuZXh0Lmxlbmd0aCA+PSBNYXRoLm1heCh0aGlzLnNhZmVGcm9tLCBwb3MpKSB7IC8vIEVudGVyIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydCArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVG9rZW5DYWNoZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zID0gcGFyc2VyLnRva2VuaXplcnMubWFwKF8gPT4gbmV3IENhY2hlZFRva2VuKTtcbiAgICB9XG4gICAgZ2V0QWN0aW9ucyhzdGFjaykge1xuICAgICAgICBsZXQgYWN0aW9uSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyB0b2tlbml6ZXJzIH0gPSBwYXJzZXI7XG4gICAgICAgIGxldCBtYXNrID0gcGFyc2VyLnN0YXRlU2xvdChzdGFjay5zdGF0ZSwgMyAvKiBUb2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFjay5jdXJDb250ZXh0ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzayB8fCB0b2tlbi5jb250ZXh0ICE9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5sb29rQWhlYWQgPiB0b2tlbi5lbmQgKyAyNSAvKiBNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gTWF0aC5tYXgodG9rZW4ubG9va0FoZWFkLCBsb29rQWhlYWQpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlICE9IDAgLyogRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKGxvb2tBaGVhZClcbiAgICAgICAgICAgIHN0YWNrLnNldExvb2tBaGVhZChsb29rQWhlYWQpO1xuICAgICAgICBpZiAoIW1haW4gJiYgc3RhY2sucG9zID09IHRoaXMuc3RyZWFtLmVuZCkge1xuICAgICAgICAgICAgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbjtcbiAgICAgICAgICAgIG1haW4udmFsdWUgPSBzdGFjay5wLnBhcnNlci5lb2ZUZXJtO1xuICAgICAgICAgICAgbWFpbi5zdGFydCA9IG1haW4uZW5kID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIG1haW4udmFsdWUsIG1haW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICBnZXRNYWluVG9rZW4oc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWFpblRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpblRva2VuO1xuICAgICAgICBsZXQgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbiwgeyBwb3MsIHAgfSA9IHN0YWNrO1xuICAgICAgICBtYWluLnN0YXJ0ID0gcG9zO1xuICAgICAgICBtYWluLmVuZCA9IE1hdGgubWluKHBvcyArIDEsIHAuc3RyZWFtLmVuZCk7XG4gICAgICAgIG1haW4udmFsdWUgPSBwb3MgPT0gcC5zdHJlYW0uZW5kID8gcC5wYXJzZXIuZW9mVGVybSA6IDAgLyogRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgdG9rZW5pemVyLnRva2VuKHRoaXMuc3RyZWFtLnJlc2V0KHN0YWNrLnBvcywgdG9rZW4pLCBzdGFjayk7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKHRoaXMuc3RyZWFtLnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogRXJyICovO1xuICAgICAgICAgICAgdG9rZW4uZW5kID0gTWF0aC5taW4oc3RhY2sucC5zdHJlYW0uZW5kLCBzdGFjay5wb3MgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkYXRhIH0gPSBwYXJzZXI7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBTa2lwICovIDogMSAvKiBBY3Rpb25zICovKTs7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMCAmJiBkYXRhW2kgKyAxXSA9PSAyIC8qIE90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMiksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09IHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDEpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbnZhciBSZWM7XG4oZnVuY3Rpb24gKFJlYykge1xuICAgIFJlY1tSZWNbXCJEaXN0YW5jZVwiXSA9IDVdID0gXCJEaXN0YW5jZVwiO1xuICAgIFJlY1tSZWNbXCJNYXhSZW1haW5pbmdQZXJTdGVwXCJdID0gM10gPSBcIk1heFJlbWFpbmluZ1BlclN0ZXBcIjtcbiAgICAvLyBXaGVuIHR3byBzdGFja3MgaGF2ZSBiZWVuIHJ1bm5pbmcgaW5kZXBlbmRlbnRseSBsb25nIGVub3VnaCB0b1xuICAgIC8vIGFkZCB0aGlzIG1hbnkgZWxlbWVudHMgdG8gdGhlaXIgYnVmZmVycywgcHJ1bmUgb25lLlxuICAgIFJlY1tSZWNbXCJNaW5CdWZmZXJMZW5ndGhQcnVuZVwiXSA9IDUwMF0gPSBcIk1pbkJ1ZmZlckxlbmd0aFBydW5lXCI7XG4gICAgUmVjW1JlY1tcIkZvcmNlUmVkdWNlTGltaXRcIl0gPSAxMF0gPSBcIkZvcmNlUmVkdWNlTGltaXRcIjtcbiAgICAvLyBPbmNlIGEgc3RhY2sgcmVhY2hlcyB0aGlzIGRlcHRoIChpbiAuc3RhY2subGVuZ3RoKSBmb3JjZS1yZWR1Y2VcbiAgICAvLyBpdCBiYWNrIHRvIEN1dFRvIHRvIGF2b2lkIGNyZWF0aW5nIHRyZWVzIHRoYXQgb3ZlcmZsb3cgdGhlIHN0YWNrXG4gICAgLy8gb24gcmVjdXJzaXZlIHRyYXZlcnNhbC5cbiAgICBSZWNbUmVjW1wiQ3V0RGVwdGhcIl0gPSAxNTAwMF0gPSBcIkN1dERlcHRoXCI7XG4gICAgUmVjW1JlY1tcIkN1dFRvXCJdID0gOTAwMF0gPSBcIkN1dFRvXCI7XG59KShSZWMgfHwgKFJlYyA9IHt9KSk7XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFN0YWNrSUQgPSAweDI2NTQ7IC8vIOKZlCwg4pmVLCDimZYsIOKZlywg4pmYLCDimZksIOKZoCwg4pmhLCDimaIsIOKZoywg4pmkLCDimaUsIOKZpiwg4pmnXG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSAwO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBuZXdTdGFja3MsIHN0YWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbnMuZ2V0TWFpblRva2VuKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlICYmIHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3R1Y2sgd2l0aCB0b2tlbiBcIiArICh0aGlzLnRva2Vucy5tYWluVG9rZW4gPyB0aGlzLnBhcnNlci5nZXROYW1lKHRoaXMudG9rZW5zLm1haW5Ub2tlbi52YWx1ZSkgOiBcIm5vbmVcIikpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIk5vIHBhcnNlIGF0IFwiICsgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvdmVyaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDUgLyogRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tUb1RyZWUoZmluaXNoZWQuZm9yY2VBbGwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZykge1xuICAgICAgICAgICAgbGV0IG1heFJlbWFpbmluZyA9IHRoaXMucmVjb3ZlcmluZyA9PSAxID8gMSA6IHRoaXMucmVjb3ZlcmluZyAqIDMgLyogTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBNaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gNTAwIC8qIE1pbkJ1ZmZlckxlbmd0aFBydW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChzdGFjay5zY29yZSAtIG90aGVyLnNjb3JlKSB8fCAoc3RhY2suYnVmZmVyLmxlbmd0aCAtIG90aGVyLmJ1ZmZlci5sZW5ndGgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3Muc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1swXS5wb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5wb3MgPCB0aGlzLm1pblN0YWNrUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSBuZXdTdGFja3NbaV0ucG9zO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiB0aGlzLnN0b3BwZWRBdCA8IHBvcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBzdGFjaywgb3IgbnVsbCBpZiB0aGVcbiAgICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAgIC8vIGdpdmVuLCBzdGFja3Mgc3BsaXQgb2ZmIGJ5IGFtYmlndW91cyBvcGVyYXRpb25zIHdpbGwgYmUgcHVzaGVkIHRvXG4gICAgLy8gYHNwbGl0YCwgb3IgYWRkZWQgdG8gYHN0YWNrc2AgaWYgdGhleSBtb3ZlIGBwb3NgIGZvcndhcmQuXG4gICAgYWR2YW5jZVN0YWNrKHN0YWNrLCBzdGFja3MsIHNwbGl0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHN0YWNrLnBvcywgeyBwYXJzZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gdmVyYm9zZSA/IHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAtPiBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0YXJ0ID4gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suZm9yY2VSZWR1Y2UoKSA/IHN0YWNrIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RyaWN0Q3ggPSBzdGFjay5jdXJDb250ZXh0ICYmIHN0YWNrLmN1ckNvbnRleHQudHJhY2tlci5zdHJpY3QsIGN4SGFzaCA9IHN0cmljdEN4ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGNhY2hlZCA9IHRoaXMuZnJhZ21lbnRzLm5vZGVBdChzdGFydCk7IGNhY2hlZDspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2NhY2hlZC50eXBlLmlkXSA9PSBjYWNoZWQudHlwZSA/IHBhcnNlci5nZXRHb3RvKHN0YWNrLnN0YXRlLCBjYWNoZWQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPiAtMSAmJiBjYWNoZWQubGVuZ3RoICYmICghc3RyaWN0Q3ggfHwgKGNhY2hlZC5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSB8fCAwKSA9PSBjeEhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVzZU5vZGUoY2FjaGVkLCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmV1c2Ugb2YgJHtwYXJzZXIuZ2V0TmFtZShjYWNoZWQudHlwZS5pZCl9KWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVkIGluc3RhbmNlb2YgVHJlZSkgfHwgY2FjaGVkLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IGNhY2hlZC5wb3NpdGlvbnNbMF0gPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBjYWNoZWQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyIGluc3RhbmNlb2YgVHJlZSAmJiBjYWNoZWQucG9zaXRpb25zWzBdID09IDApXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRSZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCA0IC8qIERlZmF1bHRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoZGVmYXVsdFJlZHVjZSA+IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnJlZHVjZShkZWZhdWx0UmVkdWNlKTtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgYCAodmlhIGFsd2F5cy1yZWR1Y2UgJHtwYXJzZXIuZ2V0TmFtZShkZWZhdWx0UmVkdWNlICYgNjU1MzUgLyogVmFsdWVNYXNrICovKX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suc3RhY2subGVuZ3RoID49IDE1MDAwIC8qIEN1dERlcHRoICovKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2suc3RhY2subGVuZ3RoID4gOTAwMCAvKiBDdXRUbyAqLyAmJiBzdGFjay5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2spO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxvY2FsU3RhY2suYXBwbHkoYWN0aW9uLCB0ZXJtLCBlbmQpO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChsb2NhbFN0YWNrKSArIGAgKHZpYSAkeyhhY3Rpb24gJiA2NTUzNiAvKiBSZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIFZhbHVlTWFzayAqLyl9YH0gZm9yICR7cGFyc2VyLmdldE5hbWUodGVybSl9IEAgJHtzdGFydH0ke2xvY2FsU3RhY2sgPT0gc3RhY2sgPyBcIlwiIDogXCIsIHNwbGl0XCJ9KWApO1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChsb2NhbFN0YWNrLnBvcyA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNwbGl0LnB1c2gobG9jYWxTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIGEgZ2l2ZW4gc3RhY2sgZm9yd2FyZCBhcyBmYXIgYXMgaXQgd2lsbCBnby4gUmV0dXJucyB0aGVcbiAgICAvLyAocG9zc2libHkgdXBkYXRlZCkgc3RhY2sgaWYgaXQgZ290IHN0dWNrLCBvciBudWxsIGlmIGl0IG1vdmVkXG4gICAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gICAgYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHN0YWNrLnBvcztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbnVsbCwgbnVsbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgIHB1c2hTdGFja0RlZHVwKHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blJlY292ZXJ5KHN0YWNrcywgdG9rZW5zLCBuZXdTdGFja3MpIHtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gbnVsbCwgcmVzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhY2sgPSBzdGFja3NbaV0sIHRva2VuID0gdG9rZW5zW2kgPDwgMV0sIHRva2VuRW5kID0gdG9rZW5zWyhpIDw8IDEpICsgMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHZlcmJvc2UgPyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHN0YWNrLmRlYWRFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBcIiAocmVzdGFydGVkKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KHN0YWNrLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZSA9IHN0YWNrLnNwbGl0KCksIGZvcmNlQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgZm9yY2UuZm9yY2VSZWR1Y2UoKSAmJiBqIDwgMTAgLyogRm9yY2VSZWR1Y2VMaW1pdCAqLzsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZvcmNlQmFzZSArIHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAodmlhIGZvcmNlLXJlZHVjZSlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShmb3JjZSwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQmFzZSA9IHRoaXMuc3RhY2tJRChmb3JjZSkgKyBcIiAtPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGluc2VydCBvZiBzdGFjay5yZWNvdmVyQnlJbnNlcnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoaW5zZXJ0KSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUZ1bGx5KGluc2VydCwgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbS5lbmQgPiBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5FbmQgPT0gc3RhY2sucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuRW5kKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gMCAvKiBFcnIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnJlY292ZXJCeURlbGV0ZSh0b2tlbiwgdG9rZW5FbmQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUodG9rZW4pfSlgKTtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5pc2hlZCB8fCBmaW5pc2hlZC5zY29yZSA8IHN0YWNrLnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gICAgc3RhY2tUb1RyZWUoc3RhY2spIHtcbiAgICAgICAgc3RhY2suY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoeyBidWZmZXI6IFN0YWNrQnVmZmVyQ3Vyc29yLmNyZWF0ZShzdGFjayksXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLnBhcnNlci5ub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IHRoaXMudG9wVGVybSxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogdGhpcy5wYXJzZXIuYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLnJldXNlZCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbGVuZ3RoOiBzdGFjay5wb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgbWluUmVwZWF0VHlwZTogdGhpcy5wYXJzZXIubWluUmVwZWF0VGVybSB9KTtcbiAgICB9XG4gICAgc3RhY2tJRChzdGFjaykge1xuICAgICAgICBsZXQgaWQgPSAoc3RhY2tJRHMgfHwgKHN0YWNrSURzID0gbmV3IFdlYWtNYXApKS5nZXQoc3RhY2spO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgc3RhY2tJRHMuc2V0KHN0YWNrLCBpZCA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpO1xuICAgICAgICByZXR1cm4gaWQgKyBzdGFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICBpZiAob3RoZXIucG9zID09IHN0YWNrLnBvcyAmJiBvdGhlci5zYW1lU3RhdGUoc3RhY2spKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnNjb3JlIDwgc3RhY2suc2NvcmUpXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzW2ldID0gc3RhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xufVxuY2xhc3MgRGlhbGVjdCB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBmbGFncywgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBhbGxvd3ModGVybSkgeyByZXR1cm4gIXRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFt0ZXJtXSA9PSAwOyB9XG59XG5jb25zdCBpZCA9IHggPT4geDtcbi8vLyBDb250ZXh0IHRyYWNrZXJzIGFyZSB1c2VkIHRvIHRyYWNrIHN0YXRlZnVsIGNvbnRleHQgKHN1Y2ggYXNcbi8vLyBpbmRlbnRhdGlvbiBpbiB0aGUgUHl0aG9uIGdyYW1tYXIsIG9yIHBhcmVudCBlbGVtZW50cyBpbiB0aGUgWE1MXG4vLy8gZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuLy8vIGdyYW1tYXIgZmlsZSBhcyBgQGNvbnRleHQgZXhwb3J0TmFtZSBmcm9tIFwibW9kdWxlXCJgLlxuLy8vXG4vLy8gQ29udGV4dCB2YWx1ZXMgc2hvdWxkIGJlIGltbXV0YWJsZSwgYW5kIGNhbiBiZSB1cGRhdGVkIChyZXBsYWNlZClcbi8vLyBvbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cbi8vL1xuLy8vIFRoZSBleHBvcnQgdXNlZCBpbiBhIGBAY29udGV4dGAgZGVjbGFyYXRpb24gc2hvdWxkIGJlIG9mIHRoaXNcbi8vLyB0eXBlLlxuY2xhc3MgQ29udGV4dFRyYWNrZXIge1xuICAgIC8vLyBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vLy8gQSBwYXJzZXIgaG9sZHMgdGhlIHBhcnNlIHRhYmxlcyBmb3IgYSBnaXZlbiBncmFtbWFyLCBhcyBnZW5lcmF0ZWRcbi8vLyBieSBgbGV6ZXItZ2VuZXJhdG9yYC5cbmNsYXNzIExSUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSBbXTtcbiAgICAgICAgaWYgKHNwZWMudmVyc2lvbiAhPSAxMyAvKiBWZXJzaW9uICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBhcnNlciB2ZXJzaW9uICgke3NwZWMudmVyc2lvbn0pIGRvZXNuJ3QgbWF0Y2ggcnVudGltZSB2ZXJzaW9uICgkezEzIC8qIFZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgbm9kZU5hbWVzID0gc3BlYy5ub2RlTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLm1pblJlcGVhdFRlcm0gPSBub2RlTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMucmVwZWF0Tm9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICBub2RlTmFtZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BTcGVjLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwcm9wU3BlY1tpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG5leHQsIHByb3AsIHByb3BTcGVjW2krK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcFNwZWNbaSArIC1uZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtbmV4dDsgaiA+IDA7IGotLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKHByb3BTcGVjW2krK10sIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZU5hbWVzLm1hcCgobmFtZSwgaSkgPT4gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgIG5hbWU6IGkgPj0gdGhpcy5taW5SZXBlYXRUZXJtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcHJvcHM6IG5vZGVQcm9wc1tpXSxcbiAgICAgICAgICAgIHRvcDogdG9wVGVybXMuaW5kZXhPZihpKSA+IC0xLFxuICAgICAgICAgICAgZXJyb3I6IGkgPT0gMCxcbiAgICAgICAgICAgIHNraXBwZWQ6IHNwZWMuc2tpcHBlZE5vZGVzICYmIHNwZWMuc2tpcHBlZE5vZGVzLmluZGV4T2YoaSkgPiAtMVxuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLnN0cmljdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCB0b2tlbkFycmF5ID0gZGVjb2RlQXJyYXkoc3BlYy50b2tlbkRhdGEpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBzcGVjLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZWQgPSBuZXcgVWludDE2QXJyYXkoc3BlYy5zcGVjaWFsaXplZCA/IHNwZWMuc3BlY2lhbGl6ZWQubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gW107XG4gICAgICAgIGlmIChzcGVjLnNwZWNpYWxpemVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjLnNwZWNpYWxpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVjaWFsaXplZFtpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0udGVybTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxpemVyc1tpXSA9IHNwZWMuc3BlY2lhbGl6ZWRbaV0uZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlcyA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVzLCBVaW50MzJBcnJheSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRlY29kZUFycmF5KHNwZWMuc3RhdGVEYXRhKTtcbiAgICAgICAgdGhpcy5nb3RvID0gZGVjb2RlQXJyYXkoc3BlYy5nb3RvKTtcbiAgICAgICAgdGhpcy5tYXhUZXJtID0gc3BlYy5tYXhUZXJtO1xuICAgICAgICB0aGlzLnRva2VuaXplcnMgPSBzcGVjLnRva2VuaXplcnMubWFwKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbmV3IFRva2VuR3JvdXAodG9rZW5BcnJheSwgdmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB0aGlzLnRvcFJ1bGVzID0gc3BlYy50b3BSdWxlcztcbiAgICAgICAgdGhpcy5kaWFsZWN0cyA9IHNwZWMuZGlhbGVjdHMgfHwge307XG4gICAgICAgIHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzID0gc3BlYy5keW5hbWljUHJlY2VkZW5jZXMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50b2tlblByZWNUYWJsZSA9IHNwZWMudG9rZW5QcmVjO1xuICAgICAgICB0aGlzLnRlcm1OYW1lcyA9IHNwZWMudGVybU5hbWVzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubWF4Tm9kZSA9IHRoaXMubm9kZVNldC50eXBlcy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdCgpO1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wUnVsZXNbT2JqZWN0LmtleXModGhpcy50b3BSdWxlcylbMF1dO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IFBhcnNlKHRoaXMsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IHcgb2YgdGhpcy53cmFwcGVycylcbiAgICAgICAgICAgIHBhcnNlID0gdyhwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH1cbiAgICAvLy8gR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICBnZXRHb3RvKHN0YXRlLCB0ZXJtLCBsb29zZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMuZ290bztcbiAgICAgICAgaWYgKHRlcm0gPj0gdGFibGVbMF0pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRhYmxlW3Rlcm0gKyAxXTs7KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBUYWcgPSB0YWJsZVtwb3MrK10sIGxhc3QgPSBncm91cFRhZyAmIDE7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGFibGVbcG9zKytdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbG9vc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGZvciAobGV0IGVuZCA9IHBvcyArIChncm91cFRhZyA+PiAxKTsgcG9zIDwgZW5kOyBwb3MrKylcbiAgICAgICAgICAgICAgICBpZiAodGFibGVbcG9zXSA9PSBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gQ2hlY2sgaWYgdGhpcyBzdGF0ZSBoYXMgYW4gYWN0aW9uIGZvciBhIGdpdmVuIHRlcm1pbmFsIEBpbnRlcm5hbFxuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogU2tpcCAqLyA6IDEgLyogQWN0aW9ucyAqLyksIG5leHQ7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPSBkYXRhW2ldKSA9PSA2NTUzNSAvKiBFbmQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSB0ZXJtaW5hbCB8fCBuZXh0ID09IDAgLyogRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBzdGF0ZVNsb3Qoc3RhdGUsIHNsb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzWyhzdGF0ZSAqIDYgLyogU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHN0YXRlRmxhZyhzdGF0ZSwgZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGVTbG90KHN0YXRlLCAwIC8qIEZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHZhbGlkQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgNCAvKiBEZWZhdWx0UmVkdWNlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDEgLyogQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogRW5kICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVtpICsgMV0gPT0gMSAvKiBOZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gcGFpcih0aGlzLmRhdGEsIGkgKyAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIC8vLyBnb3RvIGp1bXBzLiBAaW50ZXJuYWxcbiAgICBuZXh0U3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIEFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIEVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIodGhpcy5kYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5kYXRhW2kgKyAyXSAmICg2NTUzNiAvKiBSZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIG92ZXJyaWRlcyh0b2tlbiwgcHJldikge1xuICAgICAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRoaXMuZGF0YSwgdGhpcy50b2tlblByZWNUYWJsZSwgcHJldik7XG4gICAgICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0aGlzLmRhdGEsIHRoaXMudG9rZW5QcmVjVGFibGUsIHRva2VuKSA8IGlQcmV2O1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIC8vLyBnaXZlbiBzZXR0aW5ncyBtb2RpZmllZC4gU2V0dGluZ3Mgbm90IHByb3ZpZGVkIGluIGBjb25maWdgIGFyZVxuICAgIC8vLyBrZXB0IGZyb20gdGhlIG9yaWdpbmFsIHBhcnNlci5cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLy8vIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgICAvLy8gd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgLy8vIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgICAvLy8gc3RvcmVkLlxuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLy8vIFRoZSBlb2YgdGVybSBpZCBpcyBhbHdheXMgYWxsb2NhdGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBub2RlXG4gICAgLy8vIHR5cGVzLiBAaW50ZXJuYWxcbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvLy8gVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgICBnZXQgdG9wTm9kZSgpIHsgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgZHluYW1pY1ByZWNlZGVuY2UodGVybSkge1xuICAgICAgICBsZXQgcHJlYyA9IHRoaXMuZHluYW1pY1ByZWNlZGVuY2VzO1xuICAgICAgICByZXR1cm4gcHJlYyA9PSBudWxsID8gMCA6IHByZWNbdGVybV0gfHwgMDtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogRW5kICovOylcbiAgICAgICAgICAgICAgICAgICAgKGRpc2FibGVkIHx8IChkaXNhYmxlZCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbaWRdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEaWFsZWN0KGRpYWxlY3QsIGZsYWdzLCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIC8vLyAodXNlZCBieSB0aGUgb3V0cHV0IG9mIHRoZSBwYXJzZXIgZ2VuZXJhdG9yKSBAaW50ZXJuYWxcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExSUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gc3RhY2sucC5zdG9wcGVkQXQ7XG4gICAgICAgIGlmICgoc3RhY2sucG9zID09IHN0YWNrLnAuc3RyZWFtLmVuZCB8fCBzdG9wcGVkICE9IG51bGwgJiYgc3RhY2sucG9zID4gc3RvcHBlZCkgJiZcbiAgICAgICAgICAgIHN0YWNrLnAucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBBY2NlcHRpbmcgKi8pICYmXG4gICAgICAgICAgICAoIWJlc3QgfHwgYmVzdC5zY29yZSA8IHN0YWNrLnNjb3JlKSlcbiAgICAgICAgICAgIGJlc3QgPSBzdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIGJlc3Q7XG59XG5cbmV4cG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgSW5wdXRTdHJlYW0sIExSUGFyc2VyLCBTdGFjayB9O1xuIl0sIm5hbWVzIjpbIm1ha2VQcm9taXNlQ2FuY2VsYWJsZSIsInByb21pc2UiLCJoYXNDYW5jZWxlZF8iLCJ3cmFwcGVkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsInZhbCIsImlzQ2FuY2VsZWQiLCJjYXRjaCIsImVycm9yIiwiY2FuY2VsIiwicGFyc2VyIiwiYnVpbGRWaXN1YWxRdWVyeUZyb21TdHJpbmciLCJQcm9tUXVlcnlNb2RlbGxlciIsImFkZExhYmVsVG9RdWVyeSIsInF1ZXJ5Iiwia2V5IiwidmFsdWUiLCJvcGVyYXRvciIsIkVycm9yIiwidmVjdG9yU2VsZWN0b3JQb3NpdGlvbnMiLCJnZXRWZWN0b3JTZWxlY3RvclBvc2l0aW9ucyIsImxlbmd0aCIsImZpbHRlciIsInRvTGFiZWxGaWx0ZXIiLCJhZGRGaWx0ZXIiLCJ0cmVlIiwicGFyc2UiLCJwb3NpdGlvbnMiLCJpdGVyYXRlIiwiZW50ZXIiLCJ0eXBlIiwiZnJvbSIsInRvIiwiZ2V0IiwibmFtZSIsInZpc1F1ZXJ5Iiwic3Vic3RyaW5nIiwicHVzaCIsInRyYW5zZm9ybWVkVmFsdWUiLCJJbmZpbml0eSIsInRvU3RyaW5nIiwibGFiZWwiLCJvcCIsIm1vZGVsbGVyIiwibmV3UXVlcnkiLCJwcmV2IiwiaSIsIm1hdGNoIiwiaXNMYXN0Iiwic3RhcnQiLCJlbmQiLCJsYWJlbEV4aXN0cyIsImxhYmVscyIsIm5ld0xhYmVscyIsInJlbmRlclF1ZXJ5IiwiZmluZCIsIlJlYWN0IiwiQ0hFQVRfU0hFRVRfSVRFTVMiLCJ0aXRsZSIsImV4cHJlc3Npb24iLCJQcm9tQ2hlYXRTaGVldCIsInByb3BzIiwibWFwIiwiaXRlbSIsImluZGV4IiwiZSIsIm9uQ2xpY2tFeGFtcGxlIiwicmVmSWQiLCJleHByIiwiSWNvbkJ1dHRvbiIsIklubGluZUxhYmVsIiwiVG9vbHRpcCIsInVzZVN0eWxlczIiLCJjc3MiLCJjeCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUHJldmlvdXMiLCJQcm9tRXhlbXBsYXJGaWVsZCIsImRhdGFzb3VyY2UiLCJvbkNoYW5nZSIsInJlc3QiLCJzZXRFcnJvciIsInN0eWxlcyIsImdldFN0eWxlcyIsInByZXZFcnJvciIsImV4ZW1wbGFyc0F2YWlsYWJsZSIsImluc3RhbnQiLCJyYW5nZSIsImljb25CdXR0b25TdHlsZXMiLCJhY3RpdmVJY29uIiwiZXhlbXBsYXIiLCJleWVJY29uIiwiaWNvbldyYXBwZXIiLCJ0aGVtZSIsInNwYWNpbmciLCJjb2xvcnMiLCJwcmltYXJ5IiwibWFpbiIsIm1lbW8iLCJ1c2VDYWxsYmFjayIsImlzRXF1YWwiLCJJbmxpbmVGb3JtTGFiZWwiLCJSYWRpb0J1dHRvbkdyb3VwIiwiUHJvbUV4cGxvcmVFeHRyYUZpZWxkIiwib25SdW5RdWVyeSIsInJhbmdlT3B0aW9ucyIsImdldFF1ZXJ5VHlwZU9wdGlvbnMiLCJwcmV2UXVlcnkiLCJvbkV4ZW1wbGFyQ2hhbmdlIiwib25DaGFuZ2VRdWVyeVN0ZXAiLCJpbnRlcnZhbCIsIm9uU3RlcENoYW5nZSIsImN1cnJlbnRUYXJnZXQiLCJvblJldHVybktleURvd24iLCJzaGlmdEtleSIsIm9uUXVlcnlUeXBlQ2hhbmdlIiwiZ2V0UXVlcnlUeXBlQ2hhbmdlSGFuZGxlciIsInRlc3RJZHMiLCJleHRyYUZpZWxkRWRpdG9yIiwicXVlcnlUeXBlRmllbGQiLCJzdGVwRmllbGQiLCJkaXNwbGF5TmFtZSIsImluY2x1ZGVCb3RoIiwiZGVzY3JpcHRpb24iLCJxdWVyeVR5cGUiLCJDb3JlQXBwIiwiUHJvbVF1ZXJ5RmllbGQiLCJQcm9tRXhwbG9yZVF1ZXJ5RWRpdG9yIiwiZGF0YSIsImhpc3RvcnkiLCJ1bmRlZmluZWQiLCJFeHBsb3JlIiwiZWRpdG9yIiwidGV4dFV0aWwiLCJyYW5nZVV0aWwiLCJQcm9tTGluayIsInBhbmVsRGF0YSIsImhyZWYiLCJzZXRIcmVmIiwiZ2V0RXh0ZXJuYWxMaW5rIiwicmVxdWVzdCIsInNjb3BlZFZhcnMiLCJnZXRQcm9tZXRoZXVzVGltZSIsInJhbmdlRGlmZiIsIk1hdGgiLCJjZWlsIiwiZW5kVGltZSIsInV0YyIsImZvcm1hdCIsImVucmljaGVkU2NvcGVkVmFycyIsImdldFJhdGVJbnRlcnZhbFNjb3BlZFZhcmlhYmxlIiwiaW50ZXJ2YWxUb1NlY29uZHMiLCJvcHRpb25zIiwiY3VzdG9tUXVlcnlQYXJhbWV0ZXJzIiwiayIsInYiLCJxdWVyeU9wdGlvbnMiLCJjcmVhdGVRdWVyeSIsInN0ZXAiLCJhcmdzIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsImRpcmVjdFVybCIsInNhbml0aXplVXJsIiwiUHVyZUNvbXBvbmVudCIsIkxlZ2FjeUZvcm1zIiwiU2VsZWN0IiwiU3dpdGNoIiwiRk9STUFUX09QVElPTlMiLCJJTlRFUlZBTF9GQUNUT1JfT1BUSU9OUyIsIlByb21RdWVyeUVkaXRvciIsImNvbnN0cnVjdG9yIiwib3ZlcnJpZGUiLCJvcHRpb24iLCJzZXRTdGF0ZSIsImZvcm1hdE9wdGlvbiIsInRhcmdldCIsImNoZWNrZWQiLCJpbnRlcnZhbEZhY3RvciIsImludGVydmFsRmFjdG9yT3B0aW9uIiwibGVnZW5kRm9ybWF0IiwiaXNFbmFibGVkIiwiaGlkZSIsImRlZmF1bHRRdWVyeSIsImFwcCIsIlVuaWZpZWRBbGVydGluZyIsIk9iamVjdCIsImFzc2lnbiIsInN0YXRlIiwiQm9vbGVhbiIsInJlbmRlciIsInNob3dFeGVtcGxhckZpZWxkIiwib25GaWVsZENoYW5nZSIsIm9uTGVnZW5kQ2hhbmdlIiwib25JbnRlcnZhbENoYW5nZSIsIm9uSW50ZXJ2YWxGYWN0b3JDaGFuZ2UiLCJvbkZvcm1hdENoYW5nZSIsIm9uSW5zdGFudENoYW5nZSIsIlByb21RdWVyeUVkaXRvckZvckFsZXJ0aW5nIiwiY29uZmlnIiwiUHJvbVF1ZXJ5RWRpdG9yU2VsZWN0b3IiLCJQcm9tUXVlcnlFZGl0b3JCeUFwcCIsIkNsb3VkQWxlcnRpbmciLCJmZWF0dXJlVG9nZ2xlcyIsInByb21RdWVyeUJ1aWxkZXIiLCJTbGF0ZVByaXNtIiwiQnJhY2VzUGx1Z2luIiwiRE9NVXRpbCIsIkljb24iLCJsYW5ndWFnZXMiLCJwcmlzbUxhbmd1YWdlcyIsInJvdW5kTXNUb01pbiIsImlzRGF0YUZyYW1lIiwidG9MZWdhY3lSZXNwb25zZURhdGEiLCJQcm9tZXRoZXVzTWV0cmljc0Jyb3dzZXIiLCJNb25hY29RdWVyeUZpZWxkV3JhcHBlciIsIkxvY2FsU3RvcmFnZVZhbHVlUHJvdmlkZXIiLCJSRUNPUkRJTkdfUlVMRVNfR1JPVVAiLCJMQVNUX1VTRURfTEFCRUxTX0tFWSIsImdldENob29zZXJUZXh0IiwibWV0cmljc0xvb2t1cERpc2FibGVkIiwiaGFzU3ludGF4IiwiaGFzTWV0cmljcyIsIndpbGxBcHBseVN1Z2dlc3Rpb24iLCJzdWdnZXN0aW9uIiwidHlwZWFoZWFkQ29udGV4dCIsInR5cGVhaGVhZFRleHQiLCJuZXh0Q2hhciIsImdldE5leHRDaGFyYWN0ZXIiLCJjb250ZXh0IiwiaW5pdEhpbnRzIiwiZ2V0SW5pdEhpbnRzIiwiaW5pdEhpbnQiLCJzZXJpZXMiLCJoaW50IiwicmVzdWx0IiwicXVlcnlIaW50cyIsImdldFF1ZXJ5SGludHMiLCJxdWVyeUhpbnQiLCJsYW5ndWFnZVByb3ZpZGVyIiwibGFuZ3VhZ2VQcm92aWRlckluaXRpYWxpemF0aW9uUHJvbWlzZSIsInJlbWFpbmluZ1Rhc2tzIiwiYWxsIiwib25VcGRhdGVMYW5ndWFnZSIsImVyciIsInNlbGVjdG9yIiwib25DaGFuZ2VRdWVyeSIsImxhYmVsQnJvd3NlclZpc2libGUiLCJuZXh0UXVlcnkiLCJtb2RpZnlRdWVyeSIsImZpeCIsImFjdGlvbiIsIm1ldHJpY3MiLCJzeW50YXhMb2FkZWQiLCJ0eXBlYWhlYWQiLCJzdWdnZXN0aW9ucyIsInByZWZpeCIsInRleHQiLCJ3cmFwcGVyQ2xhc3NlcyIsImxhYmVsS2V5IiwicHJvdmlkZUNvbXBsZXRpb25JdGVtcyIsInBsdWdpbnMiLCJvbmx5SW4iLCJub2RlIiwiZ2V0U3ludGF4IiwicHJvbXFsIiwic3ludGF4IiwiY29tcG9uZW50RGlkTW91bnQiLCJyZWZyZXNoTWV0cmljcyIsInJlZnJlc2hIaW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJjaGFuZ2VkUmFuZ2VUb1JlZnJlc2giLCJyYW5nZUNoYW5nZWRUb1JlZnJlc2giLCJwcmV2UmFuZ2UiLCJzYW1lTWludXRlRnJvbSIsInZhbHVlT2YiLCJzYW1lTWludXRlVG8iLCJFeHRyYUZpZWxkRWxlbWVudCIsImNob29zZXJUZXh0IiwibG9va3Vwc0Rpc2FibGVkIiwiYnV0dG9uRGlzYWJsZWQiLCJsYXN0VXNlZExhYmVscyIsIm9uTGFzdFVzZWRMYWJlbHNTYXZlIiwib25MYXN0VXNlZExhYmVsc0RlbGV0ZSIsIm9uQ2xpY2tDaG9vc2VyQnV0dG9uIiwib25DaGFuZ2VMYWJlbEJyb3dzZXIiLCJvbkNsaWNrSGludEZpeCIsIkJ1dHRvbiIsIkhvcml6b250YWxHcm91cCIsIklucHV0IiwiTGFiZWwiLCJMb2FkaW5nUGxhY2Vob2xkZXIiLCJzdHlsZXNGYWN0b3J5Iiwid2l0aFRoZW1lIiwiQnJvd3NlckxhYmVsIiwiUHJvbUxhYmVsIiwiZXNjYXBlTGFiZWxWYWx1ZUluRXhhY3RTZWxlY3RvciIsImVzY2FwZUxhYmVsVmFsdWVJblJlZ2V4U2VsZWN0b3IiLCJGaXhlZFNpemVMaXN0IiwiRU1QVFlfU0VMRUNUT1IiLCJNRVRSSUNfTEFCRUwiLCJMSVNUX0lURU1fU0laRSIsImJ1aWxkU2VsZWN0b3IiLCJzaW5nbGVNZXRyaWMiLCJzZWxlY3RlZExhYmVscyIsInNlbGVjdGVkIiwidmFsdWVzIiwic2VsZWN0ZWRWYWx1ZXMiLCJmYWNldExhYmVscyIsInBvc3NpYmxlTGFiZWxzIiwibGFzdEZhY2V0dGVkIiwicG9zc2libGVWYWx1ZXMiLCJleGlzdGluZ1ZhbHVlcyIsIlNldCIsImhhcyIsImxvYWRpbmciLCJoaWRkZW4iLCJmYWNldHMiLCJ3cmFwcGVyIiwiYmcyIiwic20iLCJsaXN0Iiwic2VjdGlvbiIsIm1kIiwidHlwb2dyYXBoeSIsImZvbnRGYW1pbHkiLCJtb25vc3BhY2UiLCJzdGF0dXMiLCJ4cyIsInRleHRTZW1pV2VhayIsInN0YXR1c1Nob3dpbmciLCJwYWxldHRlIiwiYnJhbmREYW5nZXIiLCJ2YWx1ZUxpc3QiLCJ2YWx1ZUxpc3RXcmFwcGVyIiwiYm9yZGVyMiIsInZhbHVlTGlzdEFyZWEiLCJ2YWx1ZVRpdGxlIiwidmFsaWRhdGlvblN0YXR1cyIsInRleHRTdHJvbmciLCJVbnRoZW1lZFByb21ldGhldXNNZXRyaWNzQnJvd3NlciIsIkNvbXBvbmVudCIsImNyZWF0ZVJlZiIsImxhYmVsU2VhcmNoVGVybSIsIm1ldHJpY1NlYXJjaFRlcm0iLCJ2YWx1ZVNlYXJjaFRlcm0iLCJldmVudCIsImRlbGV0ZUxhc3RVc2VkTGFiZWxzIiwiZmV0Y2hWYWx1ZXMiLCJsIiwibmV4dFZhbHVlIiwidXBkYXRlTGFiZWxTdGF0ZSIsImRvRmFjZXR0aW5nRm9yTGFiZWwiLCJkb0ZhY2V0dGluZyIsInNvbWUiLCJ2YWxpZGF0ZVNlbGVjdG9yIiwiZm9yRWFjaCIsImZldGNoU2VyaWVzIiwidXBkYXRlZEZpZWxkcyIsImNiIiwicmF3TGFiZWxzIiwiZ2V0TGFiZWxLZXlzIiwiYXJyIiwiaW5jbHVkZXMiLCJzdG9yZUxhc3RVc2VkTGFiZWxzIiwicmF3VmFsdWVzIiwiZ2V0TGFiZWxWYWx1ZXMiLCJtZXRyaWNzTWV0YWRhdGEiLCJsYWJlbFZhbHVlIiwibWV0YSIsImRldGFpbHMiLCJoZWxwIiwiY29uc29sZSIsImZldGNoU2VyaWVzTGFiZWxzIiwia2V5cyIsInN0cmVhbXMiLCJub25NZXRyaWNMYWJlbHMiLCJlbXB0eSIsIm1ldHJpY0NvdW50Iiwib25DaGFuZ2VNZXRyaWNTZWFyY2giLCJtaW4iLCJzdHlsZSIsIm9uQ2xpY2tNZXRyaWMiLCJvbkNoYW5nZUxhYmVsU2VhcmNoIiwiaGVpZ2h0Iiwib25DbGlja0xhYmVsIiwib25DaGFuZ2VWYWx1ZVNlYXJjaCIsInZhbHVlTGlzdHNSZWYiLCJvbkNsaWNrVmFsdWUiLCJvbkNsaWNrUnVuUXVlcnkiLCJvbkNsaWNrUnVuUmF0ZVF1ZXJ5Iiwib25DbGlja1ZhbGlkYXRlIiwib25DbGlja0NsZWFyIiwiU3VzcGVuc2UiLCJGaWVsZCIsImxhenkiLCJNb25hY29RdWVyeUZpZWxkTGF6eSIsInVzZVJlZiIsImxhc3RSdW5WYWx1ZVJlZiIsInJ1blF1ZXJ5T25CbHVyIiwiaGFuZGxlUnVuUXVlcnkiLCJjdXJyZW50IiwiaGFuZGxlQmx1ciIsInVzZU1lbW8iLCJLbm93bkF6dXJlQ2xvdWRzIiwiZ2V0Q3JlZGVudGlhbHMiLCJ1cGRhdGVDcmVkZW50aWFscyIsIkF6dXJlQ3JlZGVudGlhbHNGb3JtIiwiQXp1cmVBdXRoU2V0dGluZ3MiLCJkYXRhU291cmNlQ29uZmlnIiwiY3JlZGVudGlhbHMiLCJvbkNyZWRlbnRpYWxzQ2hhbmdlIiwiYXp1cmUiLCJtYW5hZ2VkSWRlbnRpdHlFbmFibGVkIiwianNvbkRhdGEiLCJhenVyZUVuZHBvaW50UmVzb3VyY2VJZCIsIkF6dXJlQ2xvdWQiLCJQdWJsaWMiLCJDaGluYSIsIlVTR292ZXJubWVudCIsIkdlcm1hbnkiLCJpc0NyZWRlbnRpYWxzQ29tcGxldGUiLCJhdXRoVHlwZSIsImF6dXJlQ2xvdWQiLCJ0ZW5hbnRJZCIsImNsaWVudElkIiwiY2xpZW50U2VjcmV0IiwiY29uY2VhbGVkIiwiU3ltYm9sIiwiZ2V0RGVmYXVsdEF6dXJlQ2xvdWQiLCJjbG91ZCIsImdldFNlY3JldCIsInNlY3VyZUpzb25GaWVsZHMiLCJhenVyZUNsaWVudFNlY3JldCIsInNlY3JldCIsInNlY3VyZUpzb25EYXRhIiwiaGFzQ3JlZGVudGlhbHMiLCJhenVyZUNyZWRlbnRpYWxzIiwiZ2V0RGVmYXVsdENyZWRlbnRpYWxzIiwic2V0RGVmYXVsdENyZWRlbnRpYWxzIiwicmVzZXRDcmVkZW50aWFscyIsImF6dXJlQXV0aCIsInVzZVJlZHVjZXIiLCJhdXRoVHlwZU9wdGlvbnMiLCJhenVyZUNsb3VkT3B0aW9ucyIsImdldFN1YnNjcmlwdGlvbnMiLCJoYXNSZXF1aXJlZEZpZWxkcyIsInN1YnNjcmlwdGlvbnMiLCJzZXRTdWJzY3JpcHRpb25zIiwibG9hZFN1YnNjcmlwdGlvbnNDbGlja2VkIiwib25Mb2FkU3Vic2NyaXB0aW9ucyIsInVwZGF0ZVN1YnNjcmlwdGlvbnMiLCJjYW5jZWxlZCIsInJlY2VpdmVkIiwiYXV0b1NlbGVjdCIsImRlZmF1bHRTdWJzY3JpcHRpb25JZCIsIm9uU3Vic2NyaXB0aW9uQ2hhbmdlIiwiZm91bmQiLCJvcHQiLCJvbkF1dGhUeXBlQ2hhbmdlIiwidXBkYXRlZCIsIm9uQXp1cmVDbG91ZENoYW5nZSIsIm9uVGVuYW50SWRDaGFuZ2UiLCJvbkNsaWVudElkQ2hhbmdlIiwib25DbGllbnRTZWNyZXRDaGFuZ2UiLCJvbkNsaWVudFNlY3JldFJlc2V0IiwiQWxlcnRpbmdTZXR0aW5ncyIsIkRhdGFTb3VyY2VIdHRwU2V0dGluZ3MiLCJBbGVydCIsIlByb21TZXR0aW5ncyIsImdldEFsbEFsZXJ0bWFuYWdlckRhdGFTb3VyY2VzIiwiQ29uZmlnRWRpdG9yIiwib25PcHRpb25zQ2hhbmdlIiwiYWxlcnRtYW5hZ2VycyIsImF6dXJlQXV0aFNldHRpbmdzIiwiYXp1cmVBdXRoU3VwcG9ydGVkIiwiZ2V0QXp1cmVBdXRoRW5hYmxlZCIsInNldEF6dXJlQXV0aEVuYWJsZWQiLCJlbmFibGVkIiwiYXp1cmVTZXR0aW5nc1VJIiwiYWNjZXNzIiwic2lnVjRBdXRoRW5hYmxlZCIsInNlbGVjdG9ycyIsIkRhdGFTb3VyY2VQaWNrZXIiLCJJbmxpbmVGaWVsZCIsIklubGluZVN3aXRjaCIsIkV4ZW1wbGFyU2V0dGluZyIsIm9uRGVsZXRlIiwiaXNJbnRlcm5hbExpbmsiLCJzZXRJc0ludGVybmFsTGluayIsImRhdGFzb3VyY2VVaWQiLCJjb21wb25lbnRzIiwiRGF0YVNvdXJjZSIsIlByb21ldGhldXMiLCJjb25maWdQYWdlIiwiaW50ZXJuYWxMaW5rU3dpdGNoIiwiZXYiLCJwcmV2ZW50RGVmYXVsdCIsImRzIiwidWlkIiwidXJsIiwidXJsRGlzcGxheUxhYmVsIiwiRXhlbXBsYXJzU2V0dGluZ3MiLCJuZXdGaWVsZCIsIm5ld09wdGlvbnMiLCJzcGxpY2UiLCJleGVtcGxhcnNBZGRCdXR0b24iLCJvblVwZGF0ZURhdGFzb3VyY2VKc29uRGF0YU9wdGlvbkNoZWNrZWQiLCJ1cGRhdGVEYXRhc291cmNlUGx1Z2luSnNvbkRhdGFPcHRpb24iLCJFdmVudHNXaXRoVmFsaWRhdGlvbiIsInJlZ2V4VmFsaWRhdGlvbiIsIkZvcm1GaWVsZCIsImh0dHBPcHRpb25zIiwiaHR0cE1ldGhvZCIsInRpbWVJbnRlcnZhbCIsIm9uQ2hhbmdlSGFuZGxlciIsInByb21TZXR0aW5nc1ZhbGlkYXRpb25FdmVudHMiLCJxdWVyeVRpbWVvdXQiLCJvIiwiZGlzYWJsZU1ldHJpY3NMb29rdXAiLCJleGVtcGxhclRyYWNlSWREZXN0aW5hdGlvbnMiLCJleGVtcGxhck9wdGlvbnMiLCJvbkJsdXIiLCJnZXRWYWx1ZUZyb21FdmVudEl0ZW0iLCJldmVudEl0ZW0iLCJoYXNPd25Qcm9wZXJ0eSIsImNsb25lRGVlcCIsImRlZmF1bHRzIiwiZm9ya0pvaW4iLCJsYXN0VmFsdWVGcm9tIiwibWVyZ2UiLCJvZiIsInBpcGUiLCJ0aHJvd0Vycm9yIiwiY2F0Y2hFcnJvciIsInRhcCIsIkxSVSIsImRhdGVNYXRoIiwiTG9hZGluZ1N0YXRlIiwiZGF0ZVRpbWUiLCJnZXRCYWNrZW5kU3J2IiwiRGF0YVNvdXJjZVdpdGhCYWNrZW5kIiwidG9EYXRhUXVlcnlSZXNwb25zZSIsInNhZmVTdHJpbmdpZnlWYWx1ZSIsImdldFRpbWVTcnYiLCJnZXRUZW1wbGF0ZVNydiIsIlByb21ldGhldXNMYW5ndWFnZVByb3ZpZGVyIiwiZXhwYW5kUmVjb3JkaW5nUnVsZXMiLCJnZXRPcmlnaW5hbE1ldHJpY05hbWUiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm1WMiIsIlByb21RdWVyeVR5cGUiLCJQcm9tZXRoZXVzVmFyaWFibGVTdXBwb3J0IiwiUHJvbWV0aGV1c01ldHJpY0ZpbmRRdWVyeSIsInJlbmRlckxlZ2VuZEZvcm1hdCIsImZldGNoRGF0YVNvdXJjZUJ1aWxkSW5mbyIsIlByb21BcHBsaWNhdGlvbiIsIkJhZGdlIiwiQU5OT1RBVElPTl9RVUVSWV9TVEVQX0RFRkFVTFQiLCJHRVRfQU5EX1BPU1RfTUVUQURBVEFfRU5EUE9JTlRTIiwiUHJvbWV0aGV1c0RhdGFzb3VyY2UiLCJpbnN0YW5jZVNldHRpbmdzIiwidGVtcGxhdGVTcnYiLCJ0aW1lU3J2IiwibWF4IiwibG9hZFJ1bGVzIiwiYXJlRXhlbXBsYXJzQXZhaWxhYmxlIiwicXVlcmllcyIsImFjdGl2ZVRhcmdldHMiLCJjbG9uZWRUYXJnZXRzIiwidGFyZ2V0cyIsInJlcXVlc3RJZCIsInBhbmVsSWQiLCJtZXRyaWNOYW1lIiwiaGlzdG9ncmFtTWV0cmljcyIsIm0iLCJpbnN0YW50VGFyZ2V0IiwidmFsdWVXaXRoUmVmSWQiLCJtYXhEYXRhUG9pbnRzIiwicmFuZ2VUYXJnZXQiLCJhY3RpdmVUYXJnZXQiLCJleGVtcGxhclRhcmdldCIsIm1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiZnJhbWVzIiwiYW5ub3RhdGlvbiIsInRhZ0tleXMiLCJ0aXRsZUZvcm1hdCIsInRleHRGb3JtYXQiLCJ0YWdLZXlzQXJyYXkiLCJzcGxpdCIsImV2ZW50TGlzdCIsImZyYW1lIiwidGltZUZpZWxkIiwiZmllbGRzIiwidmFsdWVGaWVsZCIsInRhZ3MiLCJ0aW1lVmFsdWVUdXBsZSIsImlkeCIsInRvQXJyYXkiLCJ0aW1lU3RhbXBWYWx1ZSIsInZhbHVlVmFsdWUiLCJ0aW1lIiwidXNlVmFsdWVGb3JUaW1lIiwiZmxvb3IiLCJwYXJzZUZsb2F0IiwiYWN0aXZlVmFsdWVzIiwiYWN0aXZlVmFsdWVzVGltZXN0YW1wcyIsImxhdGVzdEV2ZW50IiwidGltZXN0YW1wIiwidGltZUVuZCIsInN1YlR5cGUiLCJydWxlckVuYWJsZWQiLCJlZGl0b3JTcmMiLCJpZCIsImJhc2ljQXV0aCIsIndpdGhDcmVkZW50aWFscyIsInJ1bGVNYXBwaW5ncyIsIlVSTFNlYXJjaFBhcmFtcyIsInZhcmlhYmxlcyIsImdldFF1ZXJ5RGlzcGxheVRleHQiLCJfYWRkVHJhY2luZ0hlYWRlcnMiLCJoZWFkZXJzIiwicHJveHlNb2RlIiwiZGFzaGJvYXJkSWQiLCJfcmVxdWVzdCIsIm92ZXJyaWRlcyIsIm1ldGhvZCIsInNlYXJjaCIsImVudHJpZXMiLCJBdXRob3JpemF0aW9uIiwiZmV0Y2giLCJpbXBvcnRGcm9tQWJzdHJhY3RRdWVyaWVzIiwiYWJzdHJhY3RRdWVyaWVzIiwiYWJzdHJhY3RRdWVyeSIsImltcG9ydEZyb21BYnN0cmFjdFF1ZXJ5IiwiZXhwb3J0VG9BYnN0cmFjdFF1ZXJpZXMiLCJleHBvcnRUb0Fic3RyYWN0UXVlcnkiLCJtZXRhZGF0YVJlcXVlc3QiLCJwYXJhbXMiLCJlbmRwb2ludCIsImhpZGVGcm9tSW5zcGVjdG9yIiwid2FybiIsImludGVycG9sYXRlUXVlcnlFeHByIiwidmFyaWFibGUiLCJtdWx0aSIsImluY2x1ZGVBbGwiLCJwcm9tZXRoZXVzUmVndWxhckVzY2FwZSIsInByb21ldGhldXNTcGVjaWFsUmVnZXhFc2NhcGUiLCJlc2NhcGVkVmFsdWVzIiwidGFyZ2V0Q29udGFpbnNUZW1wbGF0ZSIsImNvbnRhaW5zVGVtcGxhdGUiLCJzaG91bGRSdW5FeGVtcGxhclF1ZXJ5IiwiY3VycmVudFRhcmdldElkeCIsImZpbmRJbmRleCIsInQiLCJzbGljZSIsInByb2Nlc3NUYXJnZXRWMiIsInByb2Nlc3NlZFRhcmdldCIsInRpbWVTZXJpZXNRdWVyeSIsInV0Y09mZnNldFNlYyIsInRpbWVSYW5nZSIsInV0Y09mZnNldCIsInJlc3BvbnNlIiwicHJlcGFyZVRhcmdldHMiLCJEb25lIiwiZXhwbG9yZVF1ZXJ5IiwicGFuZWxzUXVlcnkiLCJydW5uaW5nUXVlcmllc0NvdW50Iiwic3ViUXVlcmllcyIsImZpbHRlckFuZE1hcFJlc3BvbnNlIiwiY2FuY2VsbGVkIiwicmVzcG9uc2VMaXN0TGVuZ3RoIiwiTG9hZGluZyIsInJ1blF1ZXJ5Iiwib2JzZXJ2YWJsZXMiLCJyZXN1bHRzIiwicmVkdWNlIiwicGVyZm9ybUluc3RhbnRRdWVyeSIsImdldEV4ZW1wbGFycyIsInBlcmZvcm1UaW1lU2VyaWVzUXVlcnkiLCJoaW50aW5nIiwibWluSW50ZXJ2YWwiLCJyZXBsYWNlIiwic2NyYXBlSW50ZXJ2YWwiLCJhZGp1c3RlZEludGVydmFsIiwiYWRqdXN0SW50ZXJ2YWwiLCJnZXRSYW5nZVNjb3BlZFZhcnMiLCJfX2ludGVydmFsIiwiX19pbnRlcnZhbF9tcyIsImVuaGFuY2VFeHByV2l0aEFkSG9jRmlsdGVycyIsImFkanVzdGVkIiwiYWxpZ25SYW5nZSIsInJhdGVJbnRlcnZhbCIsIl9fcmF0ZV9pbnRlcnZhbCIsInNhZmVJbnRlcnZhbCIsImhhbmRsZUVycm9ycyIsIm1ldHJpY0ZpbmRRdWVyeSIsImludGVydmFsVG9NcyIsImludGVycG9sYXRlZCIsInByb2Nlc3MiLCJtc1JhbmdlIiwiZGlmZiIsInNSYW5nZSIsInJvdW5kIiwiX19yYW5nZV9tcyIsIl9fcmFuZ2VfcyIsIl9fcmFuZ2UiLCJhbm5vdGF0aW9uUXVlcnkiLCJxdWVyeU1vZGVsIiwiZ2V0UmVmIiwiYXBwbHlUZW1wbGF0ZVZhcmlhYmxlcyIsInJzcCIsInByb2Nlc3NBbm5vdGF0aW9uUmVzcG9uc2UiLCJnZXRTdWJ0aXRsZSIsImJ1aWxkSW5mbyIsImdldEJ1aWxkSW5mbyIsImdldEJ1aWxkSW5mb01lc3NhZ2UiLCJnZXRUYWdLZXlzIiwic2VyaWVzTGFiZWxzIiwidW5pcXVlTGFiZWxzIiwiZ2V0VGFnVmFsdWVzIiwiZGlzYWJsZWQiLCJ1bnN1cHBvcnRlZCIsIkxPR09TIiwiQ29ydGV4IiwiTWltaXIiLCJDT0xPUlMiLCJhcHBsaWNhdGlvblN1YlR5cGUiLCJ3aWR0aCIsInZlcnRpY2FsQWxpZ24iLCJhcHBsaWNhdGlvbiIsImRpc3BsYXkiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwicm93R2FwIiwiY29sdW1uR2FwIiwibWFyZ2luVG9wIiwiZmVhdHVyZXMiLCJydWxlckFwaUVuYWJsZWQiLCJ0ZXN0RGF0YXNvdXJjZSIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwiaW50ZXJ2YWxNcyIsInJlcyIsInZlcmJvc2VNZXNzYWdlIiwiaW50ZXJwb2xhdGVWYXJpYWJsZXNJblF1ZXJpZXMiLCJleHBhbmRlZFF1ZXJpZXMiLCJleHBhbmRlZFF1ZXJ5IiwiZ3JvdXBzIiwiZXh0cmFjdFJ1bGVNYXBwaW5nRnJvbUdyb3VwcyIsImxvZyIsInRyaW0iLCJtYXBwaW5nIiwiZGF0ZSIsInJvdW5kVXAiLCJnZXRUaW1lUmFuZ2VQYXJhbXMiLCJsYWJlbERhdGEiLCJhZGhvY0ZpbHRlcnMiLCJnZXRBZGhvY0ZpbHRlcnMiLCJmaW5hbFF1ZXJ5IiwiYWNjIiwiZmlsdGVyUXVlcnkiLCJnZXRWYXJpYWJsZXMiLCJpbnRlcnBvbGF0ZVN0cmluZyIsInN0cmluZyIsImFsaWduZWRFbmQiLCJhbGlnbmVkU3RhcnQiLCJncm91cCIsInJ1bGVzIiwicnVsZSIsIm9uY2UiLCJjaGFpbiIsImRpZmZlcmVuY2UiLCJQcmlzbSIsIkFic3RyYWN0TGFiZWxPcGVyYXRvciIsIkxhbmd1YWdlUHJvdmlkZXIiLCJTZWFyY2hGdW5jdGlvblR5cGUiLCJhZGRMaW1pdEluZm8iLCJleHRyYWN0TGFiZWxNYXRjaGVycyIsImZpeFN1bW1hcmllc01ldGFkYXRhIiwicGFyc2VTZWxlY3RvciIsInByb2Nlc3NIaXN0b2dyYW1NZXRyaWNzIiwicHJvY2Vzc0xhYmVscyIsInJvdW5kU2VjVG9NaW4iLCJ0b1Byb21MaWtlUXVlcnkiLCJQcm9tcWxTeW50YXgiLCJGVU5DVElPTlMiLCJSQVRFX1JBTkdFUyIsIkRFRkFVTFRfS0VZUyIsIkhJU1RPUllfSVRFTV9DT1VOVCIsIkhJU1RPUllfQ09VTlRfQ1VUT0ZGIiwiU1VHR0VTVElPTlNfTElNSVQiLCJ3cmFwTGFiZWwiLCJzZXRGdW5jdGlvbktpbmQiLCJraW5kIiwiYWRkSGlzdG9yeU1ldGFkYXRhIiwiY3V0b2ZmVHMiLCJoaXN0b3J5Rm9ySXRlbSIsImgiLCJ0cyIsImNvdW50IiwicmVjZW50IiwibGFzdFF1ZXJpZWQiLCJmcm9tTm93IiwiZG9jdW1lbnRhdGlvbiIsImFkZE1ldHJpY3NNZXRhZGF0YSIsIm1ldHJpYyIsIm1ldGFkYXRhIiwiZ2V0TWV0YWRhdGFTdHJpbmciLCJ0b1VwcGVyQ2FzZSIsIlBSRUZJWF9ERUxJTUlURVJfUkVHRVgiLCJQcm9tUWxMYW5ndWFnZVByb3ZpZGVyIiwiaW5pdGlhbFZhbHVlcyIsImRlZmF1bHRWYWx1ZSIsImZldGNoTGFiZWxzIiwiZmV0Y2hMYWJlbFZhbHVlcyIsImxvYWRNZXRyaWNzTWV0YWRhdGEiLCJzb3J0IiwiZW1wdHlSZXN1bHQiLCJkb2N1bWVudCIsInNlbGVjdGVkTGluZXMiLCJnZXRUZXh0c0F0UmFuZ2UiLCJzZWxlY3Rpb24iLCJjdXJyZW50TGluZSIsInNpemUiLCJmaXJzdCIsImdldFRleHQiLCJuZXh0Q2hhcmFjdGVyIiwiYW5jaG9yIiwib2Zmc2V0IiwidG9rZW5SZWNvZ25pemVkIiwicHJlZml4VW5yZWNvZ25pemVkIiwibm9TdWZmaXgiLCJzYWZlUHJlZml4Iiwib3BlcmF0b3JzUGF0dGVybiIsImlzTmV4dE9wZXJhbmQiLCJnZXRSYW5nZUNvbXBsZXRpb25JdGVtcyIsImdldExhYmVsQ29tcGxldGlvbkl0ZW1zIiwiZ2V0QWdncmVnYXRpb25Db21wbGV0aW9uSXRlbXMiLCJnZXRFbXB0eUNvbXBsZXRpb25JdGVtcyIsImdldEJlZ2lubmluZ0NvbXBsZXRpb25JdGVtcyIsImdldFRlcm1Db21wbGV0aW9uSXRlbXMiLCJoaXN0b3J5SXRlbXMiLCJ1bmlxIiwidGFrZSIsInNlYXJjaEZ1bmN0aW9uVHlwZSIsIlByZWZpeCIsInNraXBTb3J0IiwiaXRlbXMiLCJGdXp6eSIsInF1ZXJ5T2Zmc2V0IiwicXVlcnlUZXh0IiwiZ2V0QmxvY2tzIiwiYmxvY2siLCJibG9ja1RleHQiLCJhbmNob3JCbG9jayIsIm9wZW5QYXJlbnNBZ2dyZWdhdGlvbkluZGV4IiwibGFzdEluZGV4T2YiLCJvcGVuUGFyZW5zU2VsZWN0b3JJbmRleCIsImNsb3NlUGFyZW5zU2VsZWN0b3JJbmRleCIsImluZGV4T2YiLCJjbG9zZVBhcmVuc0FnZ3JlZ2F0aW9uSW5kZXgiLCJzZWxlY3RvclN0cmluZyIsImdldFNlcmllcyIsImxhYmVsS2V5cyIsImxpbWl0SW5mbyIsImxpbmUiLCJjdXJzb3JPZmZzZXQiLCJzdWZmaXgiLCJzdWJzdHIiLCJpc1ZhbHVlU3RhcnQiLCJpc1ZhbHVlRW5kIiwiaXNQcmVWYWx1ZSIsImlzVmFsdWVFbXB0eSIsImhhc1ZhbHVlUHJlZml4IiwicGFyc2VkU2VsZWN0b3IiLCJjb250YWluc01ldHJpYyIsImV4aXN0aW5nS2V5cyIsInBvc3NpYmxlS2V5cyIsIm5ld0l0ZW1zIiwibmV3U3VnZ2VzdGlvbiIsIndpdGhOYW1lIiwiaW50ZXJwb2xhdGVkTmFtZSIsInVybFBhcmFtcyIsImNhY2hlUGFyYW1zIiwicGFyc2VJbnQiLCJjYWNoZUtleSIsImxhYmVsc0NhY2hlIiwic2V0IiwiY2xlYW5UZXh0IiwicyIsInBhcnRzIiwibGFzdCIsInBvcCIsInRyaW1MZWZ0IiwibGFiZWxCYXNlZFF1ZXJ5IiwicHJvbVF1ZXJ5IiwibGFiZWxNYXRjaGVycyIsInRva2VucyIsInRva2VuaXplIiwibmFtZUxhYmVsVmFsdWUiLCJnZXROYW1lTGFiZWxWYWx1ZSIsIkVxdWFsIiwiZmV0Y2hEZWZhdWx0U2VyaWVzIiwibGFiZWxGZXRjaFRzIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvcCIsIlRva2VuIiwiaW52ZXJ0IiwicmVzdWx0U2V0IiwicmVnZXhwIiwiUmVnRXhwIiwiaXNIaXN0b2dyYW1WYWx1ZSIsInRlc3QiLCJhZGQiLCJ2YWx1ZVNldCIsIl9fbmFtZV9fIiwidmFsdWVBcnJheSIsImxpbWl0U3VnZ2VzdGlvbnMiLCJzZWxlY3RvclJlZ2V4cCIsImxhYmVsUmVnZXhwIiwicHJlZml4T3BlbiIsInByZWZpeENsb3NlIiwic3VmZml4Q2xvc2VJbmRleCIsInN1ZmZpeENsb3NlIiwic3VmZml4T3BlbkluZGV4Iiwic3VmZml4T3BlbiIsImxhYmVsT2Zmc2V0IiwidmFsdWVTdGFydCIsInZhbHVlRW5kIiwibWV0cmljUHJlZml4IiwibWV0cmljTWF0Y2giLCJjbGVhblNlbGVjdG9yIiwicnVsZU5hbWVzIiwicnVsZXNSZWdleCIsInByZSIsInBvc3QiLCJxdWVyeUFycmF5IiwiaW52YWxpZExhYmVsc1JlZ2V4IiwiY29ycmVjdGx5RXhwYW5kZWRRdWVyeUFycmF5IiwiYWRkTGFiZWxzVG9FeHByZXNzaW9uIiwiaW52YWxpZExhYmVsc1JlZ2V4cCIsImluZGV4T2ZSZWdleE1hdGNoIiwiZXhwckJlZm9yZVJlZ2V4TWF0Y2giLCJleHByQWZ0ZXJSZWdleE1hdGNoIiwiYXJyYXlPZkxhYmVsT2JqZWN0cyIsIm9iaiIsImJhc2VNZXRhZGF0YSIsInN1bW1hcnlNZXRhZGF0YSIsInN5bnRoZXRpY01ldGFkYXRhIiwibWlsbGlzZWNvbmRzIiwic2Vjb25kcyIsIlJFMl9NRVRBQ0hBUkFDVEVSUyIsImVzY2FwZVByb21ldGhldXNSZWdleHAiLCJGcm9tUHJvbUxpa2VNYXAiLCJOb3RFcXVhbCIsIkVxdWFsUmVnRXgiLCJOb3RFcXVhbFJlZ0V4IiwiVG9Qcm9tTGlrZU1hcCIsInRvUHJvbUxpa2VFeHByIiwidG9rZW4iLCJsYWJlbE9wZXJhdG9yIiwiY29udGVudFRva2VucyIsImNvbnRlbnQiLCJjdXJyZW50VG9rZW4iLCJjdXJyZW50U3RyIiwibGFiZWxDb21wYXJhdG9yIiwiX21hcCIsImxhYmVsTmFtZXNSZWdleCIsImxhYmVsVmFsdWVzUmVnZXgiLCJtZXRyaWNOYW1lc1JlZ2V4IiwicXVlcnlSZXN1bHRSZWdleCIsImxhYmVsTmFtZXNRdWVyeSIsImxhYmVsVmFsdWVzUXVlcnkiLCJtZXRyaWNOYW1lc1F1ZXJ5IiwibWV0cmljTmFtZVF1ZXJ5IiwicXVlcnlSZXN1bHRRdWVyeSIsIm1ldHJpY05hbWVBbmRMYWJlbHNRdWVyeSIsIl9sYWJlbHMiLCJleHBhbmRhYmxlIiwibWV0cmljRmlsdGVyUGF0dGVybiIsInIiLCJtYXRjaGVkTWV0cmljTmFtZSIsImluc3RhbnRRdWVyeSIsIm1ldHJpY0RhdGEiLCJzZWxmIiwiRGF0YVNvdXJjZVBsdWdpbiIsIlByb21ldGhldXNBbm5vdGF0aW9uc1F1ZXJ5Q3RybCIsInBsdWdpbiIsInNldFF1ZXJ5RWRpdG9yIiwic2V0Q29uZmlnRWRpdG9yIiwic2V0QW5ub3RhdGlvblF1ZXJ5Q3RybCIsInNldFF1ZXJ5RWRpdG9ySGVscCIsInNvcnRWYWx1ZSIsIk9QRVJBVE9SUyIsIkxPR0lDQUxfT1BFUkFUT1JTIiwiVFJJR09OT01FVFJJQ19GVU5DVElPTlMiLCJpbnNlcnRUZXh0IiwiZGV0YWlsIiwiQUdHUkVHQVRJT05fT1BFUkFUT1JTIiwiUFJPTV9LRVlXT1JEUyIsImtleXdvcmQiLCJwcm9tcWxHcmFtbWFyIiwiY29tbWVudCIsInBhdHRlcm4iLCJsb29rYmVoaW5kIiwiaW5zaWRlIiwiYWxpYXMiLCJwdW5jdHVhdGlvbiIsImdyZWVkeSIsImZ1bmN0aW9uIiwiZiIsImlkTGlzdCIsIm51bWJlciIsIlNVTV9ISU5UX1RIUkVTSE9MRF9DT1VOVCIsImhpbnRzIiwiaGlzdG9ncmFtTWV0cmljIiwibmFtZU1hdGNoIiwiY291bnRlck5hbWVNZXRyaWMiLCJtZXRyaWNNZXRhZGF0YUtleXMiLCJjZXJ0YWluIiwidG9Mb3dlckNhc2UiLCJtZXRyaWNSZWdleCIsImZpeGFibGVRdWVyeSIsInZlcmIiLCJtYXBwaW5nRm9yUXVlcnkiLCJydWxlTmFtZSIsInNpbXBsZU1ldHJpYyIsInByZXZlbnRTdWJtaXQiLCJnZXRBZ2dyZWdhdGlvbk9wZXJhdGlvbnMiLCJnZXRPcGVyYXRpb25EZWZpbml0aW9ucyIsIkxva2lBbmRQcm9tUXVlcnlNb2RlbGxlckJhc2UiLCJQcm9tVmlzdWFsUXVlcnlPcGVyYXRpb25DYXRlZ29yeSIsImFsbE9wZXJhdGlvbnMiLCJmdW5jIiwieCIsInNldE9wZXJhdGlvbkNhdGVnb3JpZXMiLCJBZ2dyZWdhdGlvbnMiLCJSYW5nZUZ1bmN0aW9ucyIsIkZ1bmN0aW9ucyIsIkJpbmFyeU9wcyIsIlRyaWdvbm9tZXRyaWMiLCJUaW1lIiwiZ2V0UXVlcnlQYXR0ZXJucyIsIm9wZXJhdGlvbnMiLCJwcm9tUXVlcnlNb2RlbGxlciIsImFkZE9wZXJhdGlvbldpdGhSYW5nZVZlY3RvciIsImNyZWF0ZUFnZ3JlZ2F0aW9uT3BlcmF0aW9uIiwiY3JlYXRlQWdncmVnYXRpb25PcGVyYXRpb25XaXRoUGFyYW0iLCJnZXRQcm9tQW5kTG9raU9wZXJhdGlvbkRpc3BsYXlOYW1lIiwiZ2V0UmFuZ2VWZWN0b3JQYXJhbURlZiIsIlByb21PcGVyYXRpb25JZCIsIlN1bSIsIkF2ZyIsIk1pbiIsIk1heCIsIkNvdW50IiwiVG9wSyIsImRlZmF1bHRQYXJhbXMiLCJCb3R0b21LIiwiQ291bnRWYWx1ZXMiLCJjcmVhdGVBZ2dyZWdhdGlvbk92ZXJUaW1lIiwiU3VtT3ZlclRpbWUiLCJBdmdPdmVyVGltZSIsIk1pbk92ZXJUaW1lIiwiTWF4T3ZlclRpbWUiLCJDb3VudE92ZXJUaW1lIiwiTGFzdE92ZXJUaW1lIiwiUHJlc2VudE92ZXJUaW1lIiwiQWJzZW50T3ZlclRpbWUiLCJTdGRkZXZPdmVyVGltZSIsImFsdGVybmF0aXZlc0tleSIsImNhdGVnb3J5IiwicmVuZGVyZXIiLCJvcGVyYXRpb25XaXRoUmFuZ2VWZWN0b3JSZW5kZXJlciIsImFkZE9wZXJhdGlvbkhhbmRsZXIiLCJtb2RlbCIsImRlZiIsImlubmVyRXhwciIsInJhbmdlVmVjdG9yIiwiZGVmYXVsdEFkZE9wZXJhdGlvbkhhbmRsZXIiLCJiaW5hcnlTY2FsYXJEZWZzIiwiQWRkaXRpb24iLCJzaWduIiwiU3VidHJhY3Rpb24iLCJNdWx0aXBseUJ5IiwiRGl2aWRlQnkiLCJNb2R1bG8iLCJFeHBvbmVudCIsIkVxdWFsVG8iLCJjb21wYXJpc29uIiwiTm90RXF1YWxUbyIsIkdyZWF0ZXJUaGFuIiwiTGVzc1RoYW4iLCJHcmVhdGVyT3JFcXVhbCIsIkxlc3NPckVxdWFsIiwiYmluYXJ5U2NhbGFyT3BlcmF0aW9ucyIsIm9wRGVmIiwiZ2V0U2ltcGxlQmluYXJ5UmVuZGVyZXIiLCJiaW5hcnlSZW5kZXJlciIsInBhcmFtIiwiYm9vbCIsInRvT3B0aW9uIiwiZ2V0T3BlcmF0aW9uUGFyYW1JZCIsIkxhYmVsUGFyYW1FZGl0b3IiLCJvcGVyYXRpb25JbmRleCIsImlzTG9hZGluZyIsImxvYWRHcm91cEJ5TGFiZWxzIiwicmVuZGVyTGFiZWxzIiwiRWRpdG9yRmllbGQiLCJFZGl0b3JGaWVsZEdyb3VwIiwiSGlnaGxpZ2h0ZXIiLCJzcGxpdFNlcGFyYXRvciIsIk1ldHJpY1NlbGVjdCIsIm9uR2V0TWV0cmljcyIsImN1c3RvbUZpbHRlck9wdGlvbiIsInNlYXJjaFF1ZXJ5Iiwic2VhcmNoV29yZHMiLCJjdXIiLCJmb3JtYXRPcHRpb25MYWJlbCIsImlucHV0VmFsdWUiLCJoaWdobGlnaHQiLCJzZWxlY3QiLCJ3YXJuaW5nIiwiRWRpdG9yUm93cyIsIkZsZXhJdGVtIiwiQXV0b1NpemVJbnB1dCIsIlByb21RdWVyeUJ1aWxkZXIiLCJOZXN0ZWRRdWVyeSIsIm5lc3RlZFF1ZXJ5Iiwib25SZW1vdmUiLCJjYXJkIiwiaGVhZGVyIiwib3BlcmF0b3JzIiwidmVjdG9yTWF0Y2hXcmFwcGVyIiwidmVjdG9yTWF0Y2hlc1R5cGUiLCJ2ZWN0b3JNYXRjaElucHV0IiwidmVjdG9yTWF0Y2hlcyIsImV2dCIsImJvZHkiLCJ1cGRhdGUiLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwicGFkZGluZyIsImFsaWduSXRlbXMiLCJ3aGl0ZVNwYWNlIiwicGFkZGluZ0xlZnQiLCJtYXJnaW5MZWZ0IiwiU3RhY2siLCJOZXN0ZWRRdWVyeUxpc3QiLCJuZXN0ZWRRdWVyaWVzIiwiYmluYXJ5UXVlcmllcyIsIm9uTmVzdGVkUXVlcnlVcGRhdGUiLCJ1cGRhdGVkTGlzdCIsIkxhYmVsRmlsdGVycyIsIk9wZXJhdGlvbkxpc3QiLCJFZGl0b3JSb3ciLCJPcGVyYXRpb25zRWRpdG9yUm93IiwiUHJvbVF1ZXJ5QnVpbGRlckhpbnRzIiwib25DaGFuZ2VMYWJlbHMiLCJ3aXRoVGVtcGxhdGVWYXJpYWJsZU9wdGlvbnMiLCJvcHRpb25zUHJvbWlzZSIsIm9uR2V0TGFiZWxOYW1lcyIsImZvckxhYmVsIiwibGFiZWxzVG9Db25zaWRlciIsImxhYmVsc0luZGV4IiwibGFiZWxOYW1lIiwib25HZXRMYWJlbFZhbHVlcyIsImZvckxhYmVsSW50ZXJwb2xhdGVkIiwiZ2V0TWV0cmljcyIsImNyZWF0ZVNsaWNlIiwiUXVlcnlQcmV2aWV3IiwiUHJvbVF1ZXJ5QnVpbGRlckNvbnRhaW5lciIsImRpc3BhdGNoIiwic3RhdGVTbGljZSIsInJlZHVjZXIiLCJleHByQ2hhbmdlZCIsIm9uVmlzUXVlcnlDaGFuZ2UiLCJ2aXN1YWxRdWVyeUNoYW5nZSIsInJhd1F1ZXJ5IiwiaW5pdGlhbFN0YXRlIiwicmVkdWNlcnMiLCJwYXlsb2FkIiwicGFyc2VSZXN1bHQiLCJhY3Rpb25zIiwiT3BlcmF0aW9uTGlzdEV4cGxhaW5lZCIsIk9wZXJhdGlvbkV4cGxhaW5lZEJveCIsIlByb21RdWVyeUJ1aWxkZXJFeHBsYWluZWQiLCJuZXN0ZWQiLCJzZXRIaW50cyIsImNvbnRhaW5lciIsIm5ld1Byb21RdWVyeSIsInZpc3VhbFF1ZXJ5IiwiUXVlcnlPcHRpb25Hcm91cCIsImdldExlZ2VuZE1vZGVMYWJlbCIsIlByb21RdWVyeUxlZ2VuZEVkaXRvciIsIlByb21RdWVyeUJ1aWxkZXJPcHRpb25zIiwib25DaGFuZ2VGb3JtYXQiLCJvbkNoYW5nZVN0ZXAiLCJxdWVyeVR5cGVPcHRpb25zIiwicXVlcnlUeXBlVmFsdWUiLCJnZXRRdWVyeVR5cGVWYWx1ZSIsInF1ZXJ5VHlwZUxhYmVsIiwiZ2V0Q29sbGFwc2VkSW5mbyIsInNob3VsZFNob3dFeGVtcGxhclN3aXRjaCIsIlByb21RdWVyeUNvZGVFZGl0b3IiLCJFZGl0b3JIZWFkZXIiLCJJbmxpbmVTZWxlY3QiLCJTcGFjZSIsIkNvbmZpcm1Nb2RhbCIsIlF1ZXJ5RWRpdG9yTW9kZVRvZ2dsZSIsIlF1ZXJ5SGVhZGVyU3dpdGNoIiwiUXVlcnlFZGl0b3JNb2RlIiwiY2hhbmdlRWRpdG9yTW9kZSIsImdldFF1ZXJ5V2l0aERlZmF1bHRzIiwiRmVlZGJhY2tMaW5rIiwicGFyc2VNb2RhbE9wZW4iLCJzZXRQYXJzZU1vZGFsT3BlbiIsImRhdGFJc1N0YWxlIiwic2V0RGF0YUlzU3RhbGUiLCJlZGl0b3JNb2RlIiwib25FZGl0b3JNb2RlQ2hhbmdlIiwibmV3TWV0cmljRWRpdG9yTW9kZSIsIkJ1aWxkZXIiLCJlcnJvcnMiLCJvblF1ZXJ5UHJldmlld0NoYW5nZSIsIm9uQ2hhbmdlSW50ZXJuYWwiLCJDb2RlIiwiRXhwbGFpbiIsIkxlZ2VuZEZvcm1hdE1vZGUiLCJsZWdlbmRNb2RlT3B0aW9ucyIsIkF1dG8iLCJWZXJib3NlIiwiQ3VzdG9tIiwibW9kZSIsImdldExlZ2VuZE1vZGUiLCJpbnB1dFJlZiIsIm9uTGVnZW5kRm9ybWF0Q2hhbmdlZCIsIm5ld0Zvcm1hdCIsIm9uTGVnZW5kTW9kZUNoYW5nZWQiLCJzZXRUaW1lb3V0IiwiZm9jdXMiLCJzZXRTZWxlY3Rpb25SYW5nZSIsInVzZVRoZW1lMiIsImhpZ2h0bGlnaHRlZCIsImVkaXRvckZpZWxkIiwiX19odG1sIiwiZm9udEZhbWlseU1vbm9zcGFjZSIsImZvbnRTaXplIiwiYm9keVNtYWxsIiwiZnVuY3Rpb25SZW5kZXJlckxlZnQiLCJmdW5jdGlvblJlbmRlcmVyUmlnaHQiLCJyYW5nZVJlbmRlcmVyTGVmdFdpdGhQYXJhbXMiLCJyYW5nZVJlbmRlcmVyUmlnaHRXaXRoUGFyYW1zIiwiSGlzdG9ncmFtUXVhbnRpbGUiLCJMYWJlbFJlcGxhY2UiLCJMbiIsImNyZWF0ZVJhbmdlRnVuY3Rpb24iLCJDaGFuZ2VzIiwiUmF0ZSIsIklyYXRlIiwiSW5jcmVhc2UiLCJJZGVsdGEiLCJEZWx0YSIsImNyZWF0ZUZ1bmN0aW9uIiwiSG9sdFdpbnRlcnMiLCJjaGFuZ2VUeXBlSGFuZGxlciIsIm9wZXJhdGlvblR5cGVDaGFuZ2VkSGFuZGxlckZvclJhbmdlRnVuY3Rpb24iLCJQcmVkaWN0TGluZWFyIiwiUXVhbnRpbGVPdmVyVGltZSIsImFkZE5lc3RlZFF1ZXJ5SGFuZGxlciIsIkFic2VudCIsIkFjb3MiLCJBY29zaCIsIkFzaW4iLCJBc2luaCIsIkF0YW4iLCJBdGFuaCIsIkNlaWwiLCJDbGFtcCIsIkNsYW1wTWF4IiwiQ2xhbXBNaW4iLCJDb3MiLCJDb3NoIiwiRGF5T2ZNb250aCIsIkRheU9mV2VlayIsIkRheXNJbk1vbnRoIiwiRGVnIiwiRGVyaXYiLCJFeHAiLCJGbG9vciIsIkdyb3VwIiwiSG91ciIsIkxhYmVsSm9pbiIsInJlc3RQYXJhbSIsIm9wdGlvbmFsIiwibGFiZWxKb2luUmVuZGVyZXIiLCJsYWJlbEpvaW5BZGRPcGVyYXRpb25IYW5kbGVyIiwiTG9nMTAiLCJMb2cyIiwiTWludXRlIiwiTW9udGgiLCJQaSIsIlF1YW50aWxlIiwiUmFkIiwiUmVzZXRzIiwiUm91bmQiLCJTY2FsYXIiLCJTZ24iLCJTaW4iLCJTaW5oIiwiU29ydCIsIlNvcnREZXNjIiwiU3FydCIsIlN0ZGRldiIsIlRhbiIsIlRhbmgiLCJUaW1lc3RhbXAiLCJWZWN0b3IiLCJZZWFyIiwiZGVmaW5pdGlvbiIsIndpdGhSYXRlSW50ZXJ2YWwiLCJvcGVyYXRpb24iLCJuZXdEZWYiLCJuZXdPcGVyYXRpb24iLCJmaXJzdE9wIiwiZ2V0T3BlcmF0aW9uRGVmIiwic2VwYXJhdG9yIiwiRXJyb3JOYW1lIiwiZ2V0QWxsQnlUeXBlIiwiZ2V0TGVmdE1vc3RDaGlsZCIsImdldFN0cmluZyIsIm1ha2VCaW5PcCIsIm1ha2VFcnJvciIsInJlcGxhY2VWYXJpYWJsZXMiLCJyZXBsYWNlZEV4cHIiLCJ0b3BOb2RlIiwiaGFuZGxlRXhwcmVzc2lvbiIsImlzRW1wdHlRdWVyeSIsImdldExhYmVsIiwiZ2V0Q2hpbGQiLCJoYW5kbGVGdW5jdGlvbiIsImhhbmRsZUFnZ3JlZ2F0aW9uIiwiaGFuZGxlQmluYXJ5IiwiaXNJbnRlcnZhbFZhcmlhYmxlRXJyb3IiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInByZXZTaWJsaW5nIiwicmFuZ2VGdW5jdGlvbnMiLCJuYW1lTm9kZSIsImZ1bmNOYW1lIiwiY2FsbEFyZ3MiLCJlbmRzV2l0aCIsInVuc2hpZnQiLCJ1cGRhdGVGdW5jdGlvbkFyZ3MiLCJtb2RpZmllciIsImJ5TW9kaWZpZXIiLCJ3aXRob3V0TW9kaWZpZXIiLCJvcGVyYXRvclRvT3BOYW1lIiwibGVmdCIsImJpbk1vZGlmaWVyIiwiZ2V0QmluYXJ5TW9kaWZpZXIiLCJyaWdodCIsImxhc3RDaGlsZCIsImxlZnROdW1iZXIiLCJyaWdodE51bWJlciIsInJpZ2h0QmluYXJ5IiwiaXNCb29sIiwibGVmdE1vc3RDaGlsZCIsImJpblF1ZXJ5IiwiaXNNYXRjaGVyIiwibWF0Y2hUeXBlIiwibWF0Y2hlcyIsIm1hdGNoZXIiLCJtZWFzdXJlVGV4dCIsImZvcndhcmRSZWYiLCJyZWYiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwib25Db21taXRDaGFuZ2UiLCJvbktleURvd24iLCJyZXN0UHJvcHMiLCJzZXRWYWx1ZSIsImlucHV0V2lkdGgiLCJzZXRJbnB1dFdpZHRoIiwiZ2V0V2lkdGhGb3IiLCJleHRyYVNwYWNlIiwicmVhbFdpZHRoIiwiZmVlZGJhY2tVcmwiLCJmZWVkYmFja0xpbmtzRW5hYmxlZCIsImxpbmsiLCJjb2xvciIsInNlY29uZGFyeSIsIkFjY2Vzc29yeUJ1dHRvbiIsIklucHV0R3JvdXAiLCJMYWJlbEZpbHRlckl0ZW0iLCJkZWZhdWx0T3AiLCJpc011bHRpU2VsZWN0IiwiZ2V0VmFsdWUiLCJnZXRPcHRpb25zIiwibGFiZWxWYWx1ZXMiLCJpc0xvYWRpbmdMYWJlbE5hbWVzIiwibGFiZWxOYW1lcyIsImNoYW5nZSIsImlzTG9hZGluZ0xhYmVsVmFsdWVzIiwiY2hhbmdlcyIsIkVkaXRvckxpc3QiLCJsYWJlbHNGaWx0ZXJzIiwic2V0SXRlbXMiLCJvbkxhYmVsc0NoYW5nZSIsIm9uQ2hhbmdlSXRlbSIsIlJlZ2lzdHJ5IiwiZ2V0T3BlcmF0aW9ucyIsIm9wZXJhdGlvbnNSZWdpc3R5IiwiY2F0ZWdvcmllcyIsImdldE9wZXJhdGlvbnNGb3JDYXRlZ29yeSIsImhpZGVGcm9tTGlzdCIsImdldEFsdGVybmF0aXZlT3BlcmF0aW9ucyIsImdldENhdGVnb3JpZXMiLCJnZXRJZkV4aXN0cyIsInJlbmRlck9wZXJhdGlvbnMiLCJxdWVyeVN0cmluZyIsInJlbmRlckJpbmFyeVF1ZXJpZXMiLCJyZW5kZXJCaW5hcnlRdWVyeSIsImxlZnRPcGVyYW5kIiwiYmluYXJ5UXVlcnkiLCJoYXNCaW5hcnlPcCIsIkRyYWdnYWJsZSIsIk9wZXJhdGlvbkhlYWRlciIsImdldE9wZXJhdGlvblBhcmFtRWRpdG9yIiwiT3BlcmF0aW9uRWRpdG9yIiwicXVlcnlNb2RlbGxlciIsInNob3VsZEhpZ2hsaWdodCIsInVzZUhpZ2hsaWdodCIsIm9uUGFyYW1WYWx1ZUNoYW5nZWQiLCJwYXJhbUlkeCIsImNhbGxQYXJhbUNoYW5nZWRUaGVuT25DaGFuZ2UiLCJvbkFkZFJlc3RQYXJhbSIsIm9uUmVtb3ZlUmVzdFBhcmFtIiwib3BlcmF0aW9uRWxlbWVudHMiLCJwYXJhbUluZGV4IiwicGFyYW1EZWYiLCJFZGl0b3IiLCJwYXJhbVJvdyIsImhpZGVOYW1lIiwicGFyYW1OYW1lIiwiaW5mb0ljb24iLCJwYXJhbVZhbHVlIiwibGFzdFBhcmFtRGVmIiwicmVuZGVyQWRkUmVzdFBhcmFtQnV0dG9uIiwicHJvdmlkZWQiLCJjYXJkSGlnaGxpZ2h0IiwiaW5uZXJSZWYiLCJkcmFnZ2FibGVQcm9wcyIsImRyYWdIYW5kbGVQcm9wcyIsImFycm93IiwiYXJyb3dMaW5lIiwiYXJyb3dBcnJvdyIsImtlZXBIaWdobGlnaHQiLCJzZXRLZWVwSGlnaGxpZ2h0IiwiY2xlYXJUaW1lb3V0IiwicGFyYW1DaGFuZ2VkSGFuZGxlciIsImJhY2tncm91bmQiLCJib3JkZXIiLCJtZWRpdW0iLCJjdXJzb3IiLCJib3JkZXJSYWRpdXMiLCJzaGFwZSIsIm1hcmdpbkJvdHRvbSIsInBvc2l0aW9uIiwidHJhbnNpdGlvbiIsImJveFNoYWRvdyIsIm1hcmdpbiIsImZvbnRXZWlnaHQiLCJmb250V2VpZ2h0TWVkaXVtIiwidG9wIiwiYmFja2dyb3VuZENvbG9yIiwic3Ryb25nIiwiYm9yZGVyVG9wIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyTGVmdCIsInJlbmRlck1hcmtkb3duIiwic3RlcE51bWJlciIsIm1hcmtkb3duIiwiY2hpbGRyZW4iLCJib3giLCJib3hJbm5lciIsImp1c3RpZnlDb250ZW50IiwicGFkZGluZ0JvdHRvbSIsImEiLCJ0ZXh0RGVjb3JhdGlvbiIsIk9wZXJhdGlvbkluZm9CdXR0b24iLCJvblRvZ2dsZVN3aXRjaGVyIiwiaXNPcGVuIiwiYWx0ZXJuYXRpdmVzIiwiYWx0Iiwib3BlcmF0aW9uSGVhZGVyQnV0dG9ucyIsInNlbGVjdFdyYXBwZXIiLCJjaGFuZ2VkT3AiLCJvcGFjaXR5IiwidHJhbnNpdGlvbnMiLCJjcmVhdGUiLCJkdXJhdGlvbiIsInNob3J0IiwicGFkZGluZ1JpZ2h0IiwiUG9ydGFsIiwidXNlUG9wcGVyVG9vbHRpcCIsInNob3ciLCJzZXRTaG93IiwiZ2V0VG9vbHRpcFByb3BzIiwic2V0VG9vbHRpcFJlZiIsInNldFRyaWdnZXJSZWYiLCJ2aXNpYmxlIiwicGxhY2VtZW50Iiwib25WaXNpYmxlQ2hhbmdlIiwiaW50ZXJhY3RpdmUiLCJ0cmlnZ2VyIiwiZG9jQm94IiwiZG9jQm94SGVhZGVyIiwiZG9jQm94Qm9keSIsImdldE9wZXJhdGlvbkRvY3MiLCJvdmVyZmxvdyIsInNoYWRvd3MiLCJ6MyIsInpJbmRleCIsInRvb2x0aXAiLCJoNSIsInNpZ25hdHVyZSIsImRyb3Bkb3duIiwiZXhwbGFpbkhhbmRsZXIiLCJDYXNjYWRlciIsIkRyYWdEcm9wQ29udGV4dCIsIkRyb3BwYWJsZSIsInVzZU1vdW50ZWRTdGF0ZSIsIm9wc1RvSGlnaGxpZ2h0IiwidXNlT3BlcmF0aW9uc0hpZ2hsaWdodCIsImNhc2NhZGVyT3BlbiIsInNldENhc2NhZGVyT3BlbiIsIm9uT3BlcmF0aW9uQ2hhbmdlIiwiYWRkT3B0aW9ucyIsImlzTGVhZiIsIm9uQWRkT3BlcmF0aW9uIiwib3BlcmF0aW9uRGVmIiwib25EcmFnRW5kIiwiZGVzdGluYXRpb24iLCJlbGVtZW50Iiwic291cmNlIiwib25DYXNjYWRlckJsdXIiLCJvcGVyYXRpb25MaXN0IiwiZHJvcHBhYmxlUHJvcHMiLCJwbGFjZWhvbGRlciIsImFkZEJ1dHRvbiIsImlzTW91bnRlZCIsInByZXZPcGVyYXRpb25zIiwibmV3T3BzIiwiZXZlcnkiLCJuZXdPcCIsImlzU2FtZU9wIiwib3AxIiwib3AyIiwiaGVhZGluZyIsImZsZXhXcmFwIiwiQ2hlY2tib3giLCJTZWxlY3RJbnB1dFBhcmFtRWRpdG9yIiwiQm9vbElucHV0UGFyYW1FZGl0b3IiLCJTaW1wbGVJbnB1dFBhcmFtRWRpdG9yIiwic2VsZWN0T3B0aW9ucyIsInZhbHVlT3B0aW9uIiwicm9vdCIsIlRhZyIsImVkaXRvck1vZGVzIiwiY29tcG9uZW50IiwidW5pcXVlSWQiLCJpbnB1dFByb3BzIiwic3dpdGNoSWRSZWYiLCJzd2l0Y2hMYWJlbCIsInVzZVRvZ2dsZSIsImNvbGxhcHNlZEluZm8iLCJ0b2dnbGVPcGVuIiwidG9nZ2xlIiwiZW1waGFzaXplIiwiZmxleEdyb3ciLCJwYWRkaW5nVG9wIiwibWFyZ2luUmlnaHQiLCJjYXBpdGFsaXplIiwicGx1cmFsaXplIiwicmVuZGVyUGFyYW1zIiwic3RyIiwicmFuZ2VSZW5kZXJlcldpdGhQYXJhbXMiLCJyZW5kZXJMZWZ0IiwiZ2V0T25MYWJlbEFkZGVkSGFuZGxlciIsImdldEFnZ3JlZ2F0aW9uRXhwbGFpbmVyIiwiZ2V0QWdncmVnYXRpb25CeVJlbmRlcmVyIiwiZ2V0TGFzdExhYmVsUmVtb3ZlZEhhbmRsZXIiLCJnZXRBZ2dyZWdhdGlvbldpdGhvdXRSZW5kZXJlciIsInBhcmFtc0RlZiIsImdldEFnZ3JlZ2F0aW9uQnlSZW5kZXJlcldpdGhQYXJhbWV0ZXIiLCJhZ2dyZWdhdGlvbiIsImFnZ3JlZ2F0aW9uUmVuZGVyZXIiLCJhZ2dyZWdhdGlvbk5hbWUiLCJhZ2dyZWdhdGlvbkV4cGxhaW5lciIsImxhYmVsV29yZCIsIm1hcFR5cGUiLCJwIiwicmVzdFBhcmFtcyIsImNoYW5nZVRvT3BlcmF0aW9uSWQiLCJvblBhcmFtQ2hhbmdlZCIsInBhcmVudFR5cGUiLCJwYXJlbnQiLCJ2YXJpYWJsZVJlZ2V4IiwidmFyMSIsInZhcjIiLCJmbXQyIiwidmFyMyIsImZpZWxkUGF0aCIsImZtdDMiLCJmbXQiLCJ2YXJUeXBlIiwidmFyVHlwZUZ1bmMiLCJyZXR1cm5WYXJpYWJsZXMiLCJudW1iZXJOb2RlIiwiaGFzQm9vbCIsInBvcyIsImNoaWxkQWZ0ZXIiLCJqc29uIiwidG9Kc29uIiwianNvblRvVGV4dCIsInRyZWVKc29uIiwibm9kZVRvU3RyaW5nIiwiaW5kZW50IiwibmV3SW5kZW50IiwiaXNMYXN0Q2hpbGQiLCJzdG9yZSIsInF1ZXJ5RWRpdG9yTW9kZURlZmF1bHRMb2NhbFN0b3JhZ2VLZXkiLCJnZXREZWZhdWx0RWRpdG9yTW9kZSIsIkFycmF5RGF0YUZyYW1lIiwiQXJyYXlWZWN0b3IiLCJEYXRhVG9waWMiLCJGaWVsZFR5cGUiLCJmb3JtYXRMYWJlbHMiLCJnZXREaXNwbGF5UHJvY2Vzc29yIiwiVElNRV9TRVJJRVNfVElNRV9GSUVMRF9OQU1FIiwiVElNRV9TRVJJRVNfVkFMVUVfRklFTERfTkFNRSIsIkRhdGFGcmFtZVR5cGUiLCJnZXREYXRhU291cmNlU3J2IiwicGFydGl0aW9uIiwiZ3JvdXBCeSIsImRlc2NlbmRpbmciLCJkZXZpYXRpb24iLCJpc0V4ZW1wbGFyRGF0YSIsImlzTWF0cml4RGF0YSIsIlBPU0lUSVZFX0lORklOSVRZX1NBTVBMRV9WQUxVRSIsIk5FR0FUSVZFX0lORklOSVRZX1NBTVBMRV9WQUxVRSIsImlzVGFibGVSZXN1bHQiLCJkYXRhRnJhbWUiLCJjdXN0b20iLCJyZXN1bHRUeXBlIiwiaXNIZWF0bWFwUmVzdWx0IiwidGFibGVGcmFtZXMiLCJmcmFtZXNXaXRob3V0VGFibGUiLCJkZiIsInByb2Nlc3NlZFRhYmxlRnJhbWVzIiwidHJhbnNmb3JtREZUb1RhYmxlIiwiZXhlbXBsYXJGcmFtZXMiLCJmcmFtZXNXaXRob3V0VGFibGVBbmRFeGVtcGxhcnMiLCJkZXN0aW5hdGlvbnMiLCJwcm9jZXNzZWRFeGVtcGxhckZyYW1lcyIsImV4ZW1wbGFyVHJhY2VJZERlc3RpbmF0aW9uIiwidHJhY2VJREZpZWxkIiwiZmllbGQiLCJsaW5rcyIsImdldERhdGFMaW5rcyIsImRhdGFUb3BpYyIsIkFubm90YXRpb25zIiwiaGVhdG1hcFJlc3VsdHMiLCJmcmFtZXNXaXRob3V0VGFibGVIZWF0bWFwc0FuZEV4ZW1wbGFycyIsInByb2Nlc3NlZEhlYXRtYXBGcmFtZXMiLCJtZXJnZUhlYXRtYXBGcmFtZXMiLCJ0cmFuc2Zvcm1Ub0hpc3RvZ3JhbU92ZXJUaW1lIiwic29ydFNlcmllc0J5TGFiZWwiLCJvdGhlckZyYW1lcyIsInByZWZlcnJlZFZpc3VhbGlzYXRpb25UeXBlIiwiZGZzIiwiZGF0YUZyYW1lc0J5UmVmSWQiLCJyZWZJZHMiLCJ2YWx1ZVRleHQiLCJnZXRWYWx1ZVRleHQiLCJnZXRWYWx1ZUZpZWxkIiwidmFsdWVOYW1lIiwiZ2V0VGltZUZpZWxkIiwibGFiZWxGaWVsZHMiLCJmcmFtZVZhbHVlRmllbGQiLCJwcm9tTGFiZWxzIiwibnVtYmVyRmllbGQiLCJmaWx0ZXJhYmxlIiwicGFyc2VTYW1wbGVWYWx1ZSIsImxhYmVsc0ZvckZpZWxkIiwiZ2V0TGFiZWxWYWx1ZSIsInJlc3BvbnNlTGVuZ3RoIiwidHJhbnNmb3JtT3B0aW9ucyIsInByb21ldGhldXNSZXN1bHQiLCJldmVudHMiLCJleGVtcGxhckRhdGEiLCJleGVtcGxhcnMiLCJzYW1wbGVkRXhlbXBsYXJzIiwic2FtcGxlRXhlbXBsYXJzIiwidGFibGVEYXRhIiwidHJhbnNmb3JtTWV0cmljRGF0YVRvVGFibGUiLCJ0cmFuc2Zvcm1Ub0RhdGFGcmFtZSIsImRhdGFMaW5rcyIsImRhdGFTb3VyY2VTcnYiLCJkc1NldHRpbmdzIiwiZ2V0SW5zdGFuY2VTZXR0aW5ncyIsImludGVybmFsIiwiZGF0YXNvdXJjZU5hbWUiLCJ0YXJnZXRCbGFuayIsImJ1Y2tldGVkRXhlbXBsYXJzIiwiYWxpZ25lZFRzIiwiU3RyaW5nIiwic3RhbmRhcmREZXZpYXRpb24iLCJzYW1wbGVkQnVja2V0cyIsImV4ZW1wbGFyc0luQnVja2V0IiwiYnVja2V0VmFsdWVzIiwiZXgiLCJzYW1wbGVkQnVja2V0VmFsdWVzIiwiY3VyciIsImNyZWF0ZUxhYmVsSW5mbyIsInN0ZXBNcyIsIk5hTiIsImJhc2VUaW1lc3RhbXAiLCJkcHMiLCJkcFZhbHVlIiwiaXNOYU4iLCJlbmRUaW1lc3RhbXAiLCJwYXJzZVZhbHVlIiwiZGlzcGxheU5hbWVGcm9tRFMiLCJtZXRyaWNGaWVsZHMiLCJkIiwibWV0cmljRmllbGQiLCJpc01zIiwibGFiZWxzV2l0aG91dE5hbWUiLCJsYWJlbFBhcnQiLCJjb3VudEZpZWxkcyIsIkhlYXRtYXBCdWNrZXRzIiwic2VyaWVzTGlzdCIsInRvcFNlcmllcyIsImJvdHRvbVNlcmllcyIsImoiLCJib3R0b21Qb2ludCIsInMxIiwiczIiLCJsZTEiLCJsZTIiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwiU3RhbmRhcmRWYXJpYWJsZVN1cHBvcnQiLCJiaW5kIiwibWV0cmljRmluZFN0cmVhbSIsInRvRGF0YVF1ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==